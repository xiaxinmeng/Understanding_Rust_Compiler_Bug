{"sha": "9508faa2270a35595670cb3ca610ad17abff272d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1MDhmYWEyMjcwYTM1NTk1NjcwY2IzY2E2MTBhZDE3YWJmZjI3MmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T23:45:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-09-17T23:45:36Z"}, "message": "auto merge of #16377 : pcwalton/rust/associated-items, r=nikomatsakis\n\nThis is waiting on an RFC, but this basic functionality should be\r\nstraightforward. The implementation essentially desugars during type\r\ncollection and AST type conversion time into the parameter scheme we\r\nhave now.\r\n\r\nr? @nikomatsakis", "tree": {"sha": "b1c7c6d9c49f84e03b374b5b70cb0c9d0b60a7de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1c7c6d9c49f84e03b374b5b70cb0c9d0b60a7de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9508faa2270a35595670cb3ca610ad17abff272d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9508faa2270a35595670cb3ca610ad17abff272d", "html_url": "https://github.com/rust-lang/rust/commit/9508faa2270a35595670cb3ca610ad17abff272d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9508faa2270a35595670cb3ca610ad17abff272d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8067f4425d245a210c732a0333245fbe83190e89", "url": "https://api.github.com/repos/rust-lang/rust/commits/8067f4425d245a210c732a0333245fbe83190e89", "html_url": "https://github.com/rust-lang/rust/commit/8067f4425d245a210c732a0333245fbe83190e89"}, {"sha": "78a841810eb36e486ba68e6b9fa80e45d805cc4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/78a841810eb36e486ba68e6b9fa80e45d805cc4f", "html_url": "https://github.com/rust-lang/rust/commit/78a841810eb36e486ba68e6b9fa80e45d805cc4f"}], "stats": {"total": 3583, "additions": 3032, "deletions": 551}, "files": [{"sha": "5028f224475a94b839b8977e2eea3d2b46a6bcf5", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -2557,6 +2557,8 @@ The currently implemented features of the reference compiler are:\n \n * `tuple_indexing` - Allows use of tuple indexing (expressions like `expr.0`)\n \n+* `associated_types` - Allows type aliases in traits. Experimental.\n+\n If a feature is promoted to a language feature, then all existing programs will\n start to receive compilation warnings about #[feature] directives which enabled\n the new feature (because the directive is no longer necessary). However, if"}, {"sha": "aae04170ccbfeea620502106b581c3c216cd132a", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -1 +1 @@\n-Subproject commit 2dba541881fb8e35246d653bbe2e7c7088777a4a\n+Subproject commit aae04170ccbfeea620502106b581c3c216cd132a"}, {"sha": "473c3935769be136df314f3510e6f851f0195ce8", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -844,6 +844,17 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n                         }\n                     }\n                 }\n+                ty::TypeTraitItem(typedef) => {\n+                    match typedef.container {\n+                        ty::TraitContainer(..) => TraitDefaultImpl,\n+                        ty::ImplContainer(cid) => {\n+                            match ty::impl_trait_ref(cx.tcx, cid) {\n+                                Some(..) => TraitImpl,\n+                                None => PlainImpl\n+                            }\n+                        }\n+                    }\n+                }\n             }\n         }\n     }\n@@ -1511,13 +1522,9 @@ impl LintPass for Stability {\n                                 method_num: index,\n                                 ..\n                             }) => {\n-                                match ty::trait_item(cx.tcx,\n-                                                     trait_ref.def_id,\n-                                                     index) {\n-                                    ty::MethodTraitItem(method) => {\n-                                        method.def_id\n-                                    }\n-                                }\n+                                ty::trait_item(cx.tcx,\n+                                               trait_ref.def_id,\n+                                               index).def_id()\n                             }\n                         }\n                     }"}, {"sha": "51852a347d16e00352690f363c26784a0320ff78", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -25,6 +25,7 @@\n //! for all lint attributes.\n \n use middle::privacy::ExportedItems;\n+use middle::subst;\n use middle::ty;\n use middle::typeck::astconv::AstConv;\n use middle::typeck::infer;\n@@ -491,6 +492,26 @@ impl<'a, 'tcx> AstConv<'tcx> for Context<'a, 'tcx>{\n     fn ty_infer(&self, _span: Span) -> ty::t {\n         infer::new_infer_ctxt(self.tcx).next_ty_var()\n     }\n+\n+    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+                                           -> bool {\n+        // FIXME(pcwalton): This is wrong.\n+        true\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               _: Span,\n+                               _: Option<ty::t>,\n+                               trait_id: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        // FIXME(pcwalton): This is wrong.\n+        let trait_def = self.get_trait_def(trait_id);\n+        let index = ty::associated_type_parameter_index(self.tcx,\n+                                                        &*trait_def,\n+                                                        associated_type_id);\n+        ty::mk_param(self.tcx, subst::TypeSpace, index, associated_type_id)\n+    }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {"}, {"sha": "c8ed926d6fe483dcaa50a92a0a2e835937821e4c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -349,3 +349,9 @@ pub fn get_stability(cstore: &cstore::CStore,\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_stability(&*cdata, def.node)\n }\n+\n+pub fn is_associated_type(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(def.krate);\n+    decoder::is_associated_type(&*cdata, def.node)\n+}\n+"}, {"sha": "ac7f83cb385c2d6f8c12ee230d477e815c844136", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -23,7 +23,7 @@ use metadata::tydecode::{parse_ty_data, parse_region_data, parse_def_id,\n                          parse_bare_fn_ty_data, parse_trait_ref_data};\n use middle::def;\n use middle::lang_items;\n-use middle::resolve::TraitItemKind;\n+use middle::resolve::{TraitItemKind, TypeTraitItemKind};\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty;\n@@ -167,6 +167,8 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n }\n \n fn item_sort(item: rbml::Doc) -> char {\n+    // NB(pcwalton): The default of 'r' here is relied upon in\n+    // `is_associated_type` below.\n     let mut ret = 'r';\n     reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n         ret = doc.as_str_slice().as_bytes()[0] as char;\n@@ -714,6 +716,7 @@ pub fn get_impl_items(cdata: Cmd, impl_id: ast::NodeId)\n         let def_id = item_def_id(doc, cdata);\n         match item_sort(doc) {\n             'r' | 'p' => impl_items.push(ty::MethodTraitItemId(def_id)),\n+            't' => impl_items.push(ty::TypeTraitItemId(def_id)),\n             _ => fail!(\"unknown impl item sort\"),\n         }\n         true\n@@ -733,6 +736,7 @@ pub fn get_trait_item_name_and_kind(intr: Rc<IdentInterner>,\n             let explicit_self = get_explicit_self(doc);\n             (name, TraitItemKind::from_explicit_self_category(explicit_self))\n         }\n+        't' => (name, TypeTraitItemKind),\n         c => {\n             fail!(\"get_trait_item_name_and_kind(): unknown trait item kind \\\n                    in metadata: `{}`\", c)\n@@ -758,13 +762,13 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n     };\n \n     let name = item_name(&*intr, method_doc);\n+    let vis = item_visibility(method_doc);\n \n     match item_sort(method_doc) {\n         'r' | 'p' => {\n             let generics = doc_generics(method_doc, tcx, cdata,\n                                         tag_method_ty_generics);\n             let fty = doc_method_fty(method_doc, tcx, cdata);\n-            let vis = item_visibility(method_doc);\n             let explicit_self = get_explicit_self(method_doc);\n             let provided_source = get_provided_source(method_doc, cdata);\n \n@@ -777,6 +781,14 @@ pub fn get_impl_or_trait_item(intr: Rc<IdentInterner>,\n                                                         container,\n                                                         provided_source)))\n         }\n+        't' => {\n+            ty::TypeTraitItem(Rc::new(ty::AssociatedType {\n+                ident: name,\n+                vis: vis,\n+                def_id: def_id,\n+                container: container,\n+            }))\n+        }\n         _ => fail!(\"unknown impl/trait item sort\"),\n     }\n }\n@@ -790,6 +802,7 @@ pub fn get_trait_item_def_ids(cdata: Cmd, id: ast::NodeId)\n         let def_id = item_def_id(mth, cdata);\n         match item_sort(mth) {\n             'r' | 'p' => result.push(ty::MethodTraitItemId(def_id)),\n+            't' => result.push(ty::TypeTraitItemId(def_id)),\n             _ => fail!(\"unknown trait item sort\"),\n         }\n         true\n@@ -827,6 +840,7 @@ pub fn get_provided_trait_methods(intr: Rc<IdentInterner>,\n                 ty::MethodTraitItem(ref method) => {\n                     result.push((*method).clone())\n                 }\n+                ty::TypeTraitItem(_) => {}\n             }\n         }\n         true\n@@ -1394,3 +1408,12 @@ fn doc_generics(base_doc: rbml::Doc,\n \n     ty::Generics { types: types, regions: regions }\n }\n+\n+pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n+    match maybe_find_item(id, items) {\n+        None => false,\n+        Some(item) => item_sort(item) == 't',\n+    }\n+}\n+"}, {"sha": "d27a0d27c7b62eaae51274176ba003a9f3d01d00", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 137, "deletions": 33, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -416,6 +416,7 @@ fn encode_reexported_static_base_methods(ecx: &EncodeContext,\n                                                                 m.ident);\n                             }\n                         }\n+                        ty::TypeTraitItem(_) => {}\n                     }\n                 }\n             }\n@@ -887,7 +888,44 @@ fn encode_info_for_method(ecx: &EncodeContext,\n             }\n             encode_method_argument_names(rbml_w, ast_method.pe_fn_decl());\n         }\n+        Some(_) | None => {}\n+    }\n+\n+    rbml_w.end_tag();\n+}\n+\n+fn encode_info_for_associated_type(ecx: &EncodeContext,\n+                                   rbml_w: &mut Encoder,\n+                                   associated_type: &ty::AssociatedType,\n+                                   impl_path: PathElems,\n+                                   parent_id: NodeId,\n+                                   typedef_opt: Option<P<ast::Typedef>>) {\n+    debug!(\"encode_info_for_associated_type({},{})\",\n+           associated_type.def_id,\n+           token::get_ident(associated_type.ident));\n+\n+    rbml_w.start_tag(tag_items_data_item);\n+\n+    encode_def_id(rbml_w, associated_type.def_id);\n+    encode_name(rbml_w, associated_type.ident.name);\n+    encode_visibility(rbml_w, associated_type.vis);\n+    encode_family(rbml_w, 'y');\n+    encode_parent_item(rbml_w, local_def(parent_id));\n+    encode_item_sort(rbml_w, 'r');\n+\n+    let stab = stability::lookup(ecx.tcx, associated_type.def_id);\n+    encode_stability(rbml_w, stab);\n+\n+    let elem = ast_map::PathName(associated_type.ident.name);\n+    encode_path(rbml_w, impl_path.chain(Some(elem).move_iter()));\n+\n+    match typedef_opt {\n         None => {}\n+        Some(typedef) => {\n+            encode_attributes(rbml_w, typedef.attrs.as_slice());\n+            encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n+                                                         typedef.id));\n+        }\n     }\n \n     rbml_w.end_tag();\n@@ -1198,6 +1236,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_def_id(rbml_w, item_def_id);\n                     encode_item_sort(rbml_w, 'r');\n                 }\n+                ty::TypeTraitItemId(item_def_id) => {\n+                    encode_def_id(rbml_w, item_def_id);\n+                    encode_item_sort(rbml_w, 't');\n+                }\n             }\n             rbml_w.end_tag();\n         }\n@@ -1227,10 +1269,46 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                 pos: rbml_w.writer.tell().unwrap(),\n             });\n \n-            let ty::MethodTraitItem(method_type) =\n+            let trait_item_type =\n                 ty::impl_or_trait_item(tcx, trait_item_def_id.def_id());\n-            encode_info_for_method(ecx, rbml_w, &*method_type, path.clone(),\n-                                   false, item.id, ast_item)\n+            match (trait_item_type, ast_item) {\n+                (ty::MethodTraitItem(ref method_type),\n+                 Some(&ast::MethodImplItem(_))) => {\n+                    encode_info_for_method(ecx,\n+                                           rbml_w,\n+                                           &**method_type,\n+                                           path.clone(),\n+                                           false,\n+                                           item.id,\n+                                           ast_item)\n+                }\n+                (ty::MethodTraitItem(ref method_type), _) => {\n+                    encode_info_for_method(ecx,\n+                                           rbml_w,\n+                                           &**method_type,\n+                                           path.clone(),\n+                                           false,\n+                                           item.id,\n+                                           None)\n+                }\n+                (ty::TypeTraitItem(ref associated_type),\n+                 Some(&ast::TypeImplItem(ref typedef))) => {\n+                    encode_info_for_associated_type(ecx,\n+                                                    rbml_w,\n+                                                    &**associated_type,\n+                                                    path.clone(),\n+                                                    item.id,\n+                                                    Some((*typedef).clone()))\n+                }\n+                (ty::TypeTraitItem(ref associated_type), _) => {\n+                    encode_info_for_associated_type(ecx,\n+                                                    rbml_w,\n+                                                    &**associated_type,\n+                                                    path.clone(),\n+                                                    item.id,\n+                                                    None)\n+                }\n+            }\n         }\n       }\n       ItemTrait(_, _, _, ref ms) => {\n@@ -1253,6 +1331,10 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                     encode_def_id(rbml_w, method_def_id);\n                     encode_item_sort(rbml_w, 'r');\n                 }\n+                ty::TypeTraitItemId(type_def_id) => {\n+                    encode_def_id(rbml_w, type_def_id);\n+                    encode_item_sort(rbml_w, 't');\n+                }\n             }\n             rbml_w.end_tag();\n \n@@ -1281,17 +1363,19 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n             rbml_w.start_tag(tag_items_data_item);\n \n+            encode_parent_item(rbml_w, def_id);\n+\n+            let stab = stability::lookup(tcx, item_def_id.def_id());\n+            encode_stability(rbml_w, stab);\n+\n             let trait_item_type =\n                 ty::impl_or_trait_item(tcx, item_def_id.def_id());\n+            let is_nonstatic_method;\n             match trait_item_type {\n-                 ty::MethodTraitItem(method_ty) => {\n+                ty::MethodTraitItem(method_ty) => {\n                     let method_def_id = item_def_id.def_id();\n \n                     encode_method_ty_fields(ecx, rbml_w, &*method_ty);\n-                    encode_parent_item(rbml_w, def_id);\n-\n-                    let stab = stability::lookup(tcx, method_def_id);\n-                    encode_stability(rbml_w, stab);\n \n                     let elem = ast_map::PathName(method_ty.ident.name);\n                     encode_path(rbml_w,\n@@ -1315,33 +1399,53 @@ fn encode_info_for_item(ecx: &EncodeContext,\n                         }\n                     }\n \n-                    let trait_item = ms.get(i);\n-                    match *trait_item {\n-                        RequiredMethod(ref tm) => {\n-                            encode_attributes(rbml_w, tm.attrs.as_slice());\n-                            encode_item_sort(rbml_w, 'r');\n-                            encode_parent_sort(rbml_w, 't');\n-                            encode_method_argument_names(rbml_w, &*tm.decl);\n-                        }\n+                    is_nonstatic_method = method_ty.explicit_self !=\n+                        ty::StaticExplicitSelfCategory;\n+                }\n+                ty::TypeTraitItem(associated_type) => {\n+                    let elem = ast_map::PathName(associated_type.ident.name);\n+                    encode_path(rbml_w,\n+                                path.clone().chain(Some(elem).move_iter()));\n \n-                        ProvidedMethod(ref m) => {\n-                            encode_attributes(rbml_w, m.attrs.as_slice());\n-                            // If this is a static method, we've already\n-                            // encoded this.\n-                            if method_ty.explicit_self !=\n-                                    ty::StaticExplicitSelfCategory {\n-                                // FIXME: I feel like there is something funny\n-                                // going on.\n-                                let pty = ty::lookup_item_type(tcx, method_def_id);\n-                                encode_bounds_and_type(rbml_w, ecx, &pty);\n-                            }\n-                            encode_item_sort(rbml_w, 'p');\n-                            encode_parent_sort(rbml_w, 't');\n-                            encode_inlined_item(ecx, rbml_w,\n-                                                IITraitItemRef(def_id, trait_item));\n-                            encode_method_argument_names(rbml_w, &*m.pe_fn_decl());\n-                        }\n+                    encode_family(rbml_w, 'y');\n+\n+                    is_nonstatic_method = false;\n+                }\n+            }\n+\n+            encode_parent_sort(rbml_w, 't');\n+\n+            let trait_item = ms.get(i);\n+            match ms.get(i) {\n+                &RequiredMethod(ref tm) => {\n+                    encode_attributes(rbml_w, tm.attrs.as_slice());\n+                    encode_item_sort(rbml_w, 'r');\n+                    encode_method_argument_names(rbml_w, &*tm.decl);\n+                }\n+\n+                &ProvidedMethod(ref m) => {\n+                    encode_attributes(rbml_w, m.attrs.as_slice());\n+                    // If this is a static method, we've already\n+                    // encoded this.\n+                    if is_nonstatic_method {\n+                        // FIXME: I feel like there is something funny\n+                        // going on.\n+                        let pty = ty::lookup_item_type(tcx,\n+                                                       item_def_id.def_id());\n+                        encode_bounds_and_type(rbml_w, ecx, &pty);\n                     }\n+                    encode_item_sort(rbml_w, 'p');\n+                    encode_inlined_item(ecx,\n+                                        rbml_w,\n+                                        IITraitItemRef(def_id, trait_item));\n+                    encode_method_argument_names(rbml_w,\n+                                                 &*m.pe_fn_decl());\n+                }\n+\n+                &TypeTraitItem(ref associated_type) => {\n+                    encode_attributes(rbml_w,\n+                                      associated_type.attrs.as_slice());\n+                    encode_item_sort(rbml_w, 't');\n                 }\n             }\n "}, {"sha": "d319559044c4c171e9766142442a4371a2832114", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -630,6 +630,10 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n     assert_eq!(next(st), '|');\n     let index = parse_uint(st);\n     assert_eq!(next(st), '|');\n+    let associated_with = parse_opt(st, |st| {\n+        parse_def(st, NominalType, |x,y| conv(x,y))\n+    });\n+    assert_eq!(next(st), '|');\n     let bounds = parse_bounds(st, |x,y| conv(x,y));\n     let default = parse_opt(st, |st| parse_ty(st, |x,y| conv(x,y)));\n \n@@ -638,6 +642,7 @@ fn parse_type_param_def(st: &mut PState, conv: conv_did) -> ty::TypeParameterDef\n         def_id: def_id,\n         space: space,\n         index: index,\n+        associated_with: associated_with,\n         bounds: bounds,\n         default: default\n     }"}, {"sha": "fd3e4fe6738c7149a9224bfdb6f98c20efca8f92", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -383,6 +383,8 @@ pub fn enc_type_param_def(w: &mut SeekableMemWriter, cx: &ctxt, v: &ty::TypePara\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_ident(v.ident), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n+    enc_opt(w, v.associated_with, |w, did| mywrite!(w, \"{}\", (cx.ds)(did)));\n+    mywrite!(w, \"|\");\n     enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n }"}, {"sha": "399313ddd8ea91508d5e38d10e7dde40a54c0b96", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -83,7 +83,9 @@ pub fn encode_inlined_item(ecx: &e::EncodeContext,\n         e::IIForeignRef(i) => i.id,\n         e::IITraitItemRef(_, &ast::ProvidedMethod(ref m)) => m.id,\n         e::IITraitItemRef(_, &ast::RequiredMethod(ref m)) => m.id,\n-        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id\n+        e::IITraitItemRef(_, &ast::TypeTraitItem(ref ti)) => ti.id,\n+        e::IIImplItemRef(_, &ast::MethodImplItem(ref m)) => m.id,\n+        e::IIImplItemRef(_, &ast::TypeImplItem(ref ti)) => ti.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({})\",\n            ecx.tcx.map.path_to_string(id),\n@@ -155,12 +157,14 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             ast::IITraitItem(_, ref ti) => {\n                 match *ti {\n                     ast::ProvidedMethod(ref m) => m.pe_ident(),\n-                    ast::RequiredMethod(ref ty_m) => ty_m.ident\n+                    ast::RequiredMethod(ref ty_m) => ty_m.ident,\n+                    ast::TypeTraitItem(ref ti) => ti.ident,\n                 }\n             },\n             ast::IIImplItem(_, ref m) => {\n                 match *m {\n-                    ast::MethodImplItem(ref m) => m.pe_ident()\n+                    ast::MethodImplItem(ref m) => m.pe_ident(),\n+                    ast::TypeImplItem(ref ti) => ti.ident,\n                 }\n             }\n         };\n@@ -392,6 +396,12 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                     ast::RequiredMethod(\n                         fold::noop_fold_type_method(ty_m.clone(), &mut fld))\n                 }\n+                ast::TypeTraitItem(ref associated_type) => {\n+                    ast::TypeTraitItem(\n+                        P(fold::noop_fold_associated_type(\n+                            (**associated_type).clone(),\n+                            &mut fld)))\n+                }\n             })\n         }\n         e::IIImplItemRef(d, m) => {\n@@ -402,6 +412,10 @@ fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n                             .expect_one(\"noop_fold_method must produce \\\n                                          exactly one method\"))\n                 }\n+                ast::TypeImplItem(ref td) => {\n+                    ast::TypeImplItem(\n+                        P(fold::noop_fold_typedef((**td).clone(), &mut fld)))\n+                }\n             })\n         }\n         e::IIForeignRef(i) => {\n@@ -455,6 +469,7 @@ impl tr for def::Def {\n           },\n           def::DefTrait(did) => def::DefTrait(did.tr(dcx)),\n           def::DefTy(did, is_enum) => def::DefTy(did.tr(dcx), is_enum),\n+          def::DefAssociatedTy(did) => def::DefAssociatedTy(did.tr(dcx)),\n           def::DefPrimTy(p) => def::DefPrimTy(p),\n           def::DefTyParam(s, did, v) => def::DefTyParam(s, did.tr(dcx), v),\n           def::DefBinding(nid, bm) => def::DefBinding(dcx.tr_id(nid), bm),"}, {"sha": "b75d61100ecd7a5f7cdd5908fdadd5e4974e71db", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -118,6 +118,9 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                             ty::MethodTraitItem(method) => {\n                                 self.check_def_id(method.def_id);\n                             }\n+                            ty::TypeTraitItem(typedef) => {\n+                                self.check_def_id(typedef.def_id);\n+                            }\n                         }\n                     }\n                 }\n@@ -226,6 +229,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         visit::walk_block(self, method.pe_body());\n                     }\n+                    ast::TypeImplItem(_) => {}\n                 }\n             }\n             ast_map::NodeForeignItem(foreign_item) => {\n@@ -341,6 +345,7 @@ impl<'v> Visitor<'v> for LifeSeeder {\n                         ast::MethodImplItem(ref method) => {\n                             self.worklist.push(method.id);\n                         }\n+                        ast::TypeImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -544,7 +549,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n             ast::ProvidedMethod(ref method) => {\n                 visit::walk_block(self, &*method.pe_body())\n             }\n-            ast::RequiredMethod(_) => ()\n+            ast::RequiredMethod(_) => {}\n+            ast::TypeTraitItem(_) => {}\n         }\n     }\n }"}, {"sha": "ae45d827def50b66a6c90293421bbce5ab8a9d58", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -26,6 +26,7 @@ pub enum Def {\n     DefLocal(ast::NodeId, ast::BindingMode),\n     DefVariant(ast::DefId /* enum */, ast::DefId /* variant */, bool /* is_structure */),\n     DefTy(ast::DefId, bool /* is_enum */),\n+    DefAssociatedTy(ast::DefId),\n     DefTrait(ast::DefId),\n     DefPrimTy(ast::PrimTy),\n     DefTyParam(ParamSpace, ast::DefId, uint),\n@@ -62,8 +63,9 @@ impl Def {\n         match *self {\n             DefFn(id, _) | DefStaticMethod(id, _, _) | DefMod(id) |\n             DefForeignMod(id) | DefStatic(id, _) |\n-            DefVariant(_, id, _) | DefTy(id, _) | DefTyParam(_, id, _) |\n-            DefUse(id) | DefStruct(id) | DefTrait(id) | DefMethod(id, _) => {\n+            DefVariant(_, id, _) | DefTy(id, _) | DefAssociatedTy(id) |\n+            DefTyParam(_, id, _) | DefUse(id) | DefStruct(id) | DefTrait(id) |\n+            DefMethod(id, _) => {\n                 id\n             }\n             DefArg(id, _) |\n@@ -90,3 +92,4 @@ impl Def {\n         }\n     }\n }\n+"}, {"sha": "c8c5284022d9931dd1e424070f3af698e77f1d88", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -134,6 +134,9 @@ impl OverloadedCallType {\n             ty::MethodTraitItem(ref method_descriptor) => {\n                 (*method_descriptor).clone()\n             }\n+            ty::TypeTraitItem(_) => {\n+                tcx.sess.bug(\"overloaded call method wasn't in method map\")\n+            }\n         };\n         let impl_id = match method_descriptor.container {\n             ty::TraitContainer(_) => {"}, {"sha": "17d941b5958a73ca0ff1765275352fda7c5f4168", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -319,7 +319,9 @@ impl MutabilityCategory {\n             def::DefTy(..) | def::DefTrait(..) | def::DefPrimTy(..) |\n             def::DefTyParam(..) | def::DefUse(..) | def::DefStruct(..) |\n             def::DefTyParamBinder(..) | def::DefRegion(..) | def::DefLabel(..) |\n-            def::DefMethod(..) => fail!(\"no MutabilityCategory for def: {}\", *def),\n+            def::DefMethod(..) | def::DefAssociatedTy(..) => {\n+                fail!(\"no MutabilityCategory for def: {}\", *def)\n+            }\n \n             def::DefStatic(_, false) => McImmutable,\n             def::DefStatic(_, true) => McDeclared,\n@@ -533,7 +535,8 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           def::DefMod(_) | def::DefForeignMod(_) | def::DefUse(_) |\n           def::DefTrait(_) | def::DefTy(..) | def::DefPrimTy(_) |\n           def::DefTyParam(..) | def::DefTyParamBinder(..) | def::DefRegion(_) |\n-          def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) => {\n+          def::DefLabel(_) | def::DefSelfTy(..) | def::DefMethod(..) |\n+          def::DefAssociatedTy(..) => {\n               Ok(Rc::new(cmt_ {\n                   id:id,\n                   span:span,"}, {"sha": "8aac96a5410a86eae9606999934b0f8b150d20d0", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 46, "deletions": 2, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -82,8 +82,13 @@ impl<'v> Visitor<'v> for ParentVisitor {\n             ast::ItemTrait(_, _, _, ref methods) if item.vis != ast::Public => {\n                 for m in methods.iter() {\n                     match *m {\n-                        ast::ProvidedMethod(ref m) => self.parents.insert(m.id, item.id),\n-                        ast::RequiredMethod(ref m) => self.parents.insert(m.id, item.id),\n+                        ast::ProvidedMethod(ref m) => {\n+                            self.parents.insert(m.id, item.id);\n+                        }\n+                        ast::RequiredMethod(ref m) => {\n+                            self.parents.insert(m.id, item.id);\n+                        }\n+                        ast::TypeTraitItem(_) => {}\n                     };\n                 }\n             }\n@@ -272,6 +277,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                                     self.exported_items.insert(method.id);\n                                 }\n                             }\n+                            ast::TypeImplItem(_) => {}\n                         }\n                     }\n                 }\n@@ -290,6 +296,10 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n                             debug!(\"required {}\", m.id);\n                             self.exported_items.insert(m.id);\n                         }\n+                        ast::TypeTraitItem(ref t) => {\n+                            debug!(\"typedef {}\", t.id);\n+                            self.exported_items.insert(t.id);\n+                        }\n                     }\n                 }\n             }\n@@ -419,6 +429,31 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                Some(&ty::TypeTraitItem(ref typedef)) => {\n+                    match typedef.container {\n+                        ty::TraitContainer(id) => {\n+                            debug!(\"privacy - recursing on trait {:?}\", id);\n+                            self.def_privacy(id)\n+                        }\n+                        ty::ImplContainer(id) => {\n+                            match ty::impl_trait_ref(self.tcx, id) {\n+                                Some(t) => {\n+                                    debug!(\"privacy - impl of trait {:?}\", id);\n+                                    self.def_privacy(t.def_id)\n+                                }\n+                                None => {\n+                                    debug!(\"privacy - found a typedef {:?}\",\n+                                            typedef.vis);\n+                                    if typedef.vis == ast::Public {\n+                                        Allowable\n+                                    } else {\n+                                        ExternallyDenied\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n                 None => {\n                     debug!(\"privacy - nope, not even a method\");\n                     ExternallyDenied\n@@ -469,6 +504,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                                 _ => m.pe_vis()\n                             }\n                         }\n+                        ast::TypeImplItem(_) => return Allowable,\n                     }\n                 }\n                 Some(ast_map::NodeTraitItem(_)) => {\n@@ -670,6 +706,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             ty::MethodTraitItem(method_type) => {\n                 method_type.provided_source.unwrap_or(method_id)\n             }\n+            ty::TypeTraitItem(_) => method_id,\n         };\n \n         let string = token::get_ident(name);\n@@ -1110,6 +1147,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(m.span, m.pe_vis(), \"\");\n                         }\n+                        ast::TypeImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -1149,6 +1187,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                             check_inherited(m.span, m.vis,\n                                             \"unnecessary visibility\");\n                         }\n+                        ast::TypeTraitItem(_) => {}\n                     }\n                 }\n             }\n@@ -1184,6 +1223,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::MethodImplItem(ref m) => {\n                             check_inherited(tcx, m.span, m.pe_vis());\n                         }\n+                        ast::TypeImplItem(_) => {}\n                     }\n                 }\n             }\n@@ -1211,6 +1251,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                         ast::RequiredMethod(..) => {}\n                         ast::ProvidedMethod(ref m) => check_inherited(tcx, m.span,\n                                                                 m.pe_vis()),\n+                        ast::TypeTraitItem(_) => {}\n                     }\n                 }\n             }\n@@ -1351,6 +1392,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                       ast::MethodImplItem(ref m) => {\n                                           self.exported_items.contains(&m.id)\n                                       }\n+                                      ast::TypeImplItem(_) => false,\n                                   }\n                               });\n \n@@ -1367,6 +1409,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                     ast::MethodImplItem(ref method) => {\n                                         visit::walk_method_helper(self, &**method)\n                                     }\n+                                    ast::TypeImplItem(_) => {}\n                                 }\n                             }\n                         }\n@@ -1401,6 +1444,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                     visit::walk_method_helper(self, &**method);\n                                 }\n                             }\n+                            ast::TypeImplItem(_) => {}\n                         }\n                     }\n                     if found_pub_static {"}, {"sha": "555a033a568d169999f68eb2532e22623fedb228", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -197,6 +197,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 match *trait_method {\n                     ast::RequiredMethod(_) => false,\n                     ast::ProvidedMethod(_) => true,\n+                    ast::TypeTraitItem(_) => false,\n                 }\n             }\n             Some(ast_map::NodeImplItem(impl_item)) => {\n@@ -225,6 +226,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             }\n                         }\n                     }\n+                    ast::TypeImplItem(_) => false,\n                 }\n             }\n             Some(_) => false,\n@@ -327,8 +329,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                         // Keep going, nothing to get exported\n                     }\n                     ast::ProvidedMethod(ref method) => {\n-                        visit::walk_block(self, &*method.pe_body())\n+                        visit::walk_block(self, &*method.pe_body());\n                     }\n+                    ast::TypeTraitItem(_) => {}\n                 }\n             }\n             ast_map::NodeImplItem(impl_item) => {\n@@ -339,6 +342,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                             visit::walk_block(self, method.pe_body())\n                         }\n                     }\n+                    ast::TypeImplItem(_) => {}\n                 }\n             }\n             // Nothing to recurse on for these"}, {"sha": "6fa33f4b5aa03206944834b46f795f7999eb66d6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 159, "deletions": 38, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -37,13 +37,15 @@ use syntax::ast::{RegionTyParamBound, StmtDecl, StructField};\n use syntax::ast::{StructVariantKind, TraitRef, TraitTyParamBound};\n use syntax::ast::{TupleVariantKind, Ty, TyBool, TyChar, TyClosure, TyF32};\n use syntax::ast::{TyF64, TyFloat, TyI, TyI8, TyI16, TyI32, TyI64, TyInt};\n-use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyRptr};\n-use syntax::ast::{TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n-use syntax::ast::{UnboxedFnTyParamBound, UnnamedField, UnsafeFn, Variant};\n-use syntax::ast::{ViewItem, ViewItemExternCrate, ViewItemUse, ViewPathGlob};\n-use syntax::ast::{ViewPathList, ViewPathSimple, Visibility};\n+use syntax::ast::{TyParam, TyParamBound, TyPath, TyPtr, TyProc, TyQPath};\n+use syntax::ast::{TyRptr, TyStr, TyU, TyU8, TyU16, TyU32, TyU64, TyUint};\n+use syntax::ast::{TypeImplItem, UnboxedFnTyParamBound, UnnamedField};\n+use syntax::ast::{UnsafeFn, Variant, ViewItem, ViewItemExternCrate};\n+use syntax::ast::{ViewItemUse, ViewPathGlob, ViewPathList, ViewPathSimple};\n+use syntax::ast::{Visibility};\n use syntax::ast;\n use syntax::ast_util::{PostExpansionMethod, local_def, walk_pat};\n+use syntax::ast_util;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::mtwt;\n use syntax::parse::token::special_names;\n@@ -313,6 +315,7 @@ enum ModulePrefixResult {\n pub enum TraitItemKind {\n     NonstaticMethodTraitItemKind,\n     StaticMethodTraitItemKind,\n+    TypeTraitItemKind,\n }\n \n impl TraitItemKind {\n@@ -1393,6 +1396,24 @@ impl<'a> Resolver<'a> {\n                                         method.span,\n                                         is_public);\n                                 }\n+                                TypeImplItem(ref typedef) => {\n+                                    // Add the typedef to the module.\n+                                    let ident = typedef.ident;\n+                                    let typedef_name_bindings =\n+                                        self.add_child(\n+                                            ident,\n+                                            new_parent.clone(),\n+                                            ForbidDuplicateTypesAndModules,\n+                                            typedef.span);\n+                                    let def = DefAssociatedTy(local_def(\n+                                            typedef.id));\n+                                    let is_public = typedef.vis ==\n+                                        ast::Public;\n+                                    typedef_name_bindings.define_type(\n+                                        def,\n+                                        typedef.span,\n+                                        is_public);\n+                                }\n                             }\n                         }\n                     }\n@@ -1432,42 +1453,66 @@ impl<'a> Resolver<'a> {\n \n                 // Add the names of all the methods to the trait info.\n                 for method in methods.iter() {\n-                    let (m_id, m_ident, m_fn_style, m_self, m_span) = match *method {\n-                        ast::RequiredMethod(ref m) => {\n-                            (m.id, m.ident, m.fn_style, &m.explicit_self, m.span)\n-                        }\n-                        ast::ProvidedMethod(ref m) => {\n-                            (m.id, m.pe_ident(), m.pe_fn_style(), m.pe_explicit_self(), m.span)\n-                        }\n-                    };\n+                    let (ident, kind) = match *method {\n+                        ast::RequiredMethod(_) |\n+                        ast::ProvidedMethod(_) => {\n+                            let ty_m =\n+                                ast_util::trait_item_to_ty_method(method);\n+\n+                            let ident = ty_m.ident;\n+\n+                            // Add it as a name in the trait module.\n+                            let (def, static_flag) = match ty_m.explicit_self\n+                                                               .node {\n+                                SelfStatic => {\n+                                    // Static methods become\n+                                    // `def_static_method`s.\n+                                    (DefStaticMethod(\n+                                            local_def(ty_m.id),\n+                                            FromTrait(local_def(item.id)),\n+                                            ty_m.fn_style),\n+                                     StaticMethodTraitItemKind)\n+                                }\n+                                _ => {\n+                                    // Non-static methods become\n+                                    // `def_method`s.\n+                                    (DefMethod(local_def(ty_m.id),\n+                                               Some(local_def(item.id))),\n+                                     NonstaticMethodTraitItemKind)\n+                                }\n+                            };\n \n-                    // Add it as a name in the trait module.\n-                    let (def, static_flag) = match m_self.node {\n-                        SelfStatic => {\n-                            // Static methods become `def_static_method`s.\n-                            (DefStaticMethod(local_def(m_id),\n-                                              FromTrait(local_def(item.id)),\n-                                              m_fn_style),\n-                             StaticMethodTraitItemKind)\n+                            let method_name_bindings =\n+                                self.add_child(ident,\n+                                               module_parent.clone(),\n+                                               ForbidDuplicateTypesAndValues,\n+                                               ty_m.span);\n+                            method_name_bindings.define_value(def,\n+                                                              ty_m.span,\n+                                                              true);\n+\n+                            (ident, static_flag)\n                         }\n-                        _ => {\n-                            // Non-static methods become `def_method`s.\n-                            (DefMethod(local_def(m_id),\n-                                       Some(local_def(item.id))),\n-                             NonstaticMethodTraitItemKind)\n+                        ast::TypeTraitItem(ref associated_type) => {\n+                            let def = DefAssociatedTy(local_def(\n+                                    associated_type.id));\n+\n+                            let name_bindings =\n+                                self.add_child(associated_type.ident,\n+                                               module_parent.clone(),\n+                                               ForbidDuplicateTypesAndValues,\n+                                               associated_type.span);\n+                            name_bindings.define_type(def,\n+                                                      associated_type.span,\n+                                                      true);\n+\n+                            (associated_type.ident, TypeTraitItemKind)\n                         }\n                     };\n \n-                    let method_name_bindings =\n-                        self.add_child(m_ident,\n-                                       module_parent.clone(),\n-                                       ForbidDuplicateValues,\n-                                       m_span);\n-                    method_name_bindings.define_value(def, m_span, true);\n-\n                     self.trait_item_map\n                         .borrow_mut()\n-                        .insert((m_ident.name, def_id), static_flag);\n+                        .insert((ident.name, def_id), kind);\n                 }\n \n                 name_bindings.define_type(DefTrait(def_id), sp, is_public);\n@@ -1823,7 +1868,7 @@ impl<'a> Resolver<'a> {\n                                                   is_public,\n                                                   DUMMY_SP)\n           }\n-          DefTy(..) => {\n+          DefTy(..) | DefAssociatedTy(..) => {\n               debug!(\"(building reduced graph for external \\\n                       crate) building type {}\", final_ident);\n \n@@ -4065,6 +4110,9 @@ impl<'a> Resolver<'a> {\n                                                                 ProvidedMethod(m.id)),\n                                                   &**m)\n                           }\n+                          ast::TypeTraitItem(_) => {\n+                              visit::walk_trait_item(this, method);\n+                          }\n                         }\n                     }\n                 });\n@@ -4509,6 +4557,14 @@ impl<'a> Resolver<'a> {\n                                                   ProvidedMethod(method.id)),\n                                     &**method);\n                             }\n+                            TypeImplItem(ref typedef) => {\n+                                // If this is a trait impl, ensure the method\n+                                // exists in trait\n+                                this.check_trait_item(typedef.ident,\n+                                                      typedef.span);\n+\n+                                this.resolve_type(&*typedef.typ);\n+                            }\n                         }\n                     }\n                 });\n@@ -4745,9 +4801,73 @@ impl<'a> Resolver<'a> {\n                 });\n             }\n \n+            TyQPath(ref qpath) => {\n+                self.resolve_type(&*qpath.for_type);\n+\n+                let current_module = self.current_module.clone();\n+                let module_path_idents: Vec<_> =\n+                    qpath.trait_name\n+                         .segments\n+                         .iter()\n+                         .map(|ps| ps.identifier)\n+                         .collect();\n+                match self.resolve_module_path(\n+                        current_module,\n+                        module_path_idents.as_slice(),\n+                        UseLexicalScope,\n+                        qpath.trait_name.span,\n+                        PathSearch) {\n+                    Success((ref module, _)) if module.kind.get() ==\n+                            TraitModuleKind => {\n+                        match self.resolve_definition_of_name_in_module(\n+                                (*module).clone(),\n+                                qpath.item_name.name,\n+                                TypeNS) {\n+                            ChildNameDefinition(def, lp) |\n+                            ImportNameDefinition(def, lp) => {\n+                                match def {\n+                                    DefAssociatedTy(trait_type_id) => {\n+                                        let def = DefAssociatedTy(\n+                                            trait_type_id);\n+                                        self.record_def(ty.id, (def, lp));\n+                                    }\n+                                    _ => {\n+                                        self.resolve_error(\n+                                            ty.span,\n+                                            \"not an associated type\");\n+                                    }\n+                                }\n+                            }\n+                            NoNameDefinition => {\n+                                self.resolve_error(ty.span,\n+                                                   \"unresolved associated \\\n+                                                    type\");\n+                            }\n+                        }\n+                    }\n+                    Success(..) => self.resolve_error(ty.span, \"not a trait\"),\n+                    Indeterminate => {\n+                        self.session.span_bug(ty.span,\n+                                              \"indeterminate result when \\\n+                                               resolving associated type\")\n+                    }\n+                    Failed(error) => {\n+                        let (span, help) = match error {\n+                            Some((span, msg)) => (span, format!(\"; {}\", msg)),\n+                            None => (ty.span, String::new()),\n+                        };\n+                        self.resolve_error(span,\n+                                           format!(\"unresolved trait: {}\",\n+                                                   help).as_slice())\n+                    }\n+                }\n+            }\n+\n             TyClosure(ref c) | TyProc(ref c) => {\n-                self.resolve_type_parameter_bounds(ty.id, &c.bounds,\n-                                                   TraitBoundingTypeParameter);\n+                self.resolve_type_parameter_bounds(\n+                    ty.id,\n+                    &c.bounds,\n+                    TraitBoundingTypeParameter);\n                 visit::walk_ty(self, ty);\n             }\n \n@@ -5210,8 +5330,9 @@ impl<'a> Resolver<'a> {\n                     Some(def_id) => {\n                         match self.trait_item_map.borrow().find(&(ident.name, def_id)) {\n                             Some(&StaticMethodTraitItemKind) => (),\n+                            Some(&TypeTraitItemKind) => (),\n                             None => (),\n-                            _ => {\n+                            Some(&NonstaticMethodTraitItemKind) => {\n                                 debug!(\"containing module was a trait or impl \\\n                                 and name was a method -> not resolved\");\n                                 return None;"}, {"sha": "cab83f4cda2446330c0538712ff9d1d2edd1993a", "filename": "src/librustc/middle/save/mod.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsave%2Fmod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -227,6 +227,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefForeignMod(_) => Some(recorder::ModRef),\n             def::DefStruct(_) => Some(recorder::StructRef),\n             def::DefTy(..) |\n+            def::DefAssociatedTy(..) |\n             def::DefTrait(_) => Some(recorder::TypeRef),\n             def::DefStatic(_, _) |\n             def::DefBinding(_, _) |\n@@ -355,11 +356,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     ty::MethodTraitItemId(def_id) => {\n                         method.id != 0 && def_id.node == 0\n                     }\n+                    ty::TypeTraitItemId(_) => false,\n                 }\n             });\n         let decl_id = match decl_id {\n             None => None,\n-            Some(ty::MethodTraitItemId(def_id)) => Some(def_id),\n+            Some(id) => Some(id.def_id()),\n         };\n \n         let sub_span = self.span.sub_span_after_keyword(method.span, keywords::Fn);\n@@ -646,6 +648,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(self, &**method)\n                 }\n+                ast::TypeImplItem(ref typedef) => {\n+                    visit::walk_ty(self, &*typedef.typ)\n+                }\n             }\n         }\n     }\n@@ -764,12 +769,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                  def_id)\n                                     .iter()\n                                     .find(|mr| {\n-                                        match **mr {\n-                                            ty::MethodTraitItem(ref mr) => {\n-                                                mr.ident.name == ti.ident()\n-                                                                   .name\n-                                            }\n-                                        }\n+                                        mr.ident().name == ti.ident().name\n                                     })\n                                     .unwrap()\n                                     .def_id())\n@@ -782,18 +782,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             Some(impl_items.get(&def_id)\n                                            .iter()\n                                            .find(|mr| {\n-                                            match **mr {\n-                                                ty::MethodTraitItemId(mr) => {\n-                                                    ty::impl_or_trait_item(\n-                                                            &self.analysis\n-                                                                 .ty_cx,\n-                                                            mr).ident()\n-                                                               .name ==\n-                                                        ti.ident().name\n-                                                    }\n-                                                }\n-                                            }).unwrap()\n-                                              .def_id())\n+                                            ty::impl_or_trait_item(\n+                                                &self.analysis.ty_cx,\n+                                                mr.def_id()).ident().name ==\n+                                                ti.ident().name\n+                                            })\n+                                           .unwrap()\n+                                           .def_id())\n                         }\n                     }\n                 } else {\n@@ -894,7 +889,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match ty::trait_item_of_item(&self.analysis.ty_cx,\n                                                  def_id) {\n                         None => None,\n-                        Some(ty::MethodTraitItemId(decl_id)) => Some(decl_id),\n+                        Some(decl_id) => Some(decl_id.def_id()),\n                     };\n \n                 // This incantation is required if the method referenced is a\n@@ -905,6 +900,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     ty::MethodTraitItem(method) => {\n                         method.provided_source.unwrap_or(def_id)\n                     }\n+                    ty::TypeTraitItem(_) => def_id,\n                 };\n                 (Some(def_id), decl_id)\n             }\n@@ -913,23 +909,15 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mp.trait_ref.def_id,\n                                                 mp.method_num);\n-                match trait_item {\n-                    ty::MethodTraitItem(method) => {\n-                        (None, Some(method.def_id))\n-                    }\n-                }\n-            },\n+                (None, Some(trait_item.def_id()))\n+            }\n             typeck::MethodObject(ref mo) => {\n                 // method invoked on a trait instance\n                 let trait_item = ty::trait_item(&self.analysis.ty_cx,\n                                                 mo.trait_ref.def_id,\n                                                 mo.method_num);\n-                match trait_item {\n-                    ty::MethodTraitItem(method) => {\n-                        (None, Some(method.def_id))\n-                    }\n-                }\n-            },\n+                (None, Some(trait_item.def_id()))\n+            }\n         };\n         let sub_span = self.span.sub_span_for_meth_name(ex.span);\n         self.fmt.meth_call_str(ex.span,\n@@ -1139,7 +1127,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                             qualname,\n                                             method_type.id);\n             }\n-            ast::ProvidedMethod(ref method) => self.process_method(&**method)\n+            ast::ProvidedMethod(ref method) => self.process_method(&**method),\n+            ast::TypeTraitItem(_) => {}\n         }\n     }\n "}, {"sha": "ef169264650f42d3ede0c16fb5a01a04aa20f919", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -16,8 +16,9 @@ use syntax::codemap::Span;\n use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n-use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem, TypeMethod, Method};\n-use syntax::ast::{Generics, StructDef, StructField, Ident};\n+use syntax::ast::{Item, RequiredMethod, ProvidedMethod, TraitItem};\n+use syntax::ast::{TypeMethod, Method, Generics, StructDef, StructField};\n+use syntax::ast::{Ident, TypeTraitItem};\n use syntax::ast_util::is_local;\n use syntax::attr::Stability;\n use syntax::visit::{FnKind, FkMethod, Visitor};\n@@ -79,9 +80,13 @@ impl<'v> Visitor<'v> for Annotator {\n             RequiredMethod(TypeMethod {id, ref attrs, ..}) => (id, attrs),\n \n             // work around lack of pattern matching for @ types\n-            ProvidedMethod(ref method) => match **method {\n-                Method {id, ref attrs, ..} => (id, attrs)\n+            ProvidedMethod(ref method) => {\n+                match **method {\n+                    Method {attrs: ref attrs, id: id, ..} => (id, attrs),\n+                }\n             }\n+\n+            TypeTraitItem(ref typedef) => (typedef.id, &typedef.attrs),\n         };\n         self.annotate(id, attrs, |v| visit::walk_trait_item(v, t));\n     }"}, {"sha": "9583dcf560e9444b8e12fe993dc07341fe4d2851", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -630,7 +630,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n \n         let t1 = match ty::get(t).sty {\n             ty::ty_param(p) => {\n-                check(self, p, t, self.substs.types.opt_get(p.space, p.idx))\n+                check(self,\n+                      p,\n+                      t,\n+                      self.substs.types.opt_get(p.space, p.idx),\n+                      p.space,\n+                      p.idx)\n             }\n             _ => {\n                 ty_fold::super_fold_ty(self, t)\n@@ -648,18 +653,22 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n         fn check(this: &SubstFolder,\n                  p: ty::ParamTy,\n                  source_ty: ty::t,\n-                 opt_ty: Option<&ty::t>)\n+                 opt_ty: Option<&ty::t>,\n+                 space: ParamSpace,\n+                 index: uint)\n                  -> ty::t {\n             match opt_ty {\n                 Some(t) => *t,\n                 None => {\n                     let span = this.span.unwrap_or(DUMMY_SP);\n                     this.tcx().sess.span_bug(\n                         span,\n-                        format!(\"Type parameter `{}` ({}) out of range \\\n+                        format!(\"Type parameter `{}` ({}/{}/{}) out of range \\\n                                  when substituting (root type={})\",\n                                 p.repr(this.tcx()),\n                                 source_ty.repr(this.tcx()),\n+                                space,\n+                                index,\n                                 this.root_ty.repr(this.tcx())).as_slice());\n                 }\n             }"}, {"sha": "a814c9d624cfa789c80d3feaf523d4ac3ef022c4", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -1375,6 +1375,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                     tcx.sess.bug(\"unexpected variant: required trait method \\\n                                   in has_nested_returns\")\n                 }\n+                ast::TypeTraitItem(_) => {\n+                    tcx.sess.bug(\"unexpected variant: type trait item in \\\n+                                  has_nested_returns\")\n+                }\n             }\n         }\n         Some(ast_map::NodeImplItem(ii)) => {\n@@ -1391,6 +1395,10 @@ fn has_nested_returns(tcx: &ty::ctxt, id: ast::NodeId) -> bool {\n                         ast::MethMac(_) => tcx.sess.bug(\"unexpanded macro\")\n                     }\n                 }\n+                ast::TypeImplItem(_) => {\n+                    tcx.sess.bug(\"unexpected variant: type impl item in \\\n+                                  has_nested_returns\")\n+                }\n             }\n         }\n         Some(ast_map::NodeExpr(e)) => {\n@@ -2779,9 +2787,9 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeTraitItem(trait_method) => {\n             debug!(\"get_item_val(): processing a NodeTraitItem\");\n             match *trait_method {\n-                ast::RequiredMethod(_) => {\n-                    ccx.sess().bug(\"unexpected variant: required trait method in \\\n-                                   get_item_val()\");\n+                ast::RequiredMethod(_) | ast::TypeTraitItem(_) => {\n+                    ccx.sess().bug(\"unexpected variant: required trait \\\n+                                    method in get_item_val()\");\n                 }\n                 ast::ProvidedMethod(ref m) => {\n                     register_method(ccx, id, &**m)\n@@ -2792,6 +2800,11 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n         ast_map::NodeImplItem(ii) => {\n             match *ii {\n                 ast::MethodImplItem(ref m) => register_method(ccx, id, &**m),\n+                ast::TypeImplItem(ref typedef) => {\n+                    ccx.sess().span_bug(typedef.span,\n+                                        \"unexpected variant: required impl \\\n+                                         method in get_item_val()\")\n+                }\n             }\n         }\n "}, {"sha": "c54a446c455c7218f3c32b7eca33b331bf424f05", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -203,7 +203,7 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n                 datum_callee(bcx, ref_expr)\n             }\n             def::DefMod(..) | def::DefForeignMod(..) | def::DefTrait(..) |\n-            def::DefTy(..) | def::DefPrimTy(..) |\n+            def::DefTy(..) | def::DefPrimTy(..) | def::DefAssociatedTy(..) |\n             def::DefUse(..) | def::DefTyParamBinder(..) |\n             def::DefRegion(..) | def::DefLabel(..) | def::DefTyParam(..) |\n             def::DefSelfTy(..) | def::DefMethod(..) => {\n@@ -458,6 +458,10 @@ pub fn trans_fn_ref_with_substs(\n \n                     (true, source_id, new_substs)\n                 }\n+                ty::TypeTraitItem(_) => {\n+                    bcx.tcx().sess.bug(\"trans_fn_ref_with_vtables() tried \\\n+                                        to translate an associated type?!\")\n+                }\n             }\n         }\n     };"}, {"sha": "359da14d57eafb5b94bd5039b71a430f79dc7e20", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -1153,6 +1153,11 @@ pub fn create_function_debug_context(cx: &CrateContext,\n                      method.span,\n                      true)\n                 }\n+                ast::TypeImplItem(ref typedef) => {\n+                    cx.sess().span_bug(typedef.span,\n+                                       \"create_function_debug_context() \\\n+                                        called on associated type?!\")\n+                }\n             }\n         }\n         ast_map::NodeExpr(ref expr) => {"}, {"sha": "e5c8d4d0ab343db9852c56a673c0f5a78bfe16cb", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -156,6 +156,9 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                     // don't.\n                     local_def(mth.id)\n                 }\n+                ast::TypeTraitItem(_) => {\n+                    ccx.sess().bug(\"found TypeTraitItem IITraitItem\")\n+                }\n             }\n         }\n         csearch::found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n@@ -185,6 +188,9 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n                     }\n                     local_def(mth.id)\n                 }\n+                ast::TypeImplItem(_) => {\n+                    ccx.sess().bug(\"found TypeImplItem IIImplItem\")\n+                }\n             }\n         }\n     };"}, {"sha": "f1276387745912e49f3d5d3a787e60555dd1ece8", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -71,6 +71,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 ast::MethodImplItem(ref method) => {\n                     visit::walk_method_helper(&mut v, &**method);\n                 }\n+                ast::TypeImplItem(_) => {}\n             }\n         }\n         return;\n@@ -100,6 +101,7 @@ pub fn trans_impl(ccx: &CrateContext,\n                 };\n                 visit::walk_method_helper(&mut v, &**method);\n             }\n+            ast::TypeImplItem(_) => {}\n         }\n     }\n }\n@@ -183,7 +185,11 @@ pub fn trans_static_method_callee(bcx: Block,\n             ast_map::NodeTraitItem(method) => {\n                 let ident = match *method {\n                     ast::RequiredMethod(ref m) => m.ident,\n-                    ast::ProvidedMethod(ref m) => m.pe_ident()\n+                    ast::ProvidedMethod(ref m) => m.pe_ident(),\n+                    ast::TypeTraitItem(_) => {\n+                        bcx.tcx().sess.bug(\"trans_static_method_callee() on \\\n+                                            an associated type?!\")\n+                    }\n                 };\n                 ident.name\n             }\n@@ -294,14 +300,10 @@ fn method_with_name(ccx: &CrateContext, impl_id: ast::DefId, name: ast::Name)\n                   .expect(\"could not find impl while translating\");\n     let meth_did = impl_items.iter()\n                              .find(|&did| {\n-                                match *did {\n-                                    ty::MethodTraitItemId(did) => {\n-                                        ty::impl_or_trait_item(ccx.tcx(),\n-                                                               did).ident()\n-                                                                   .name ==\n-                                            name\n-                                    }\n-                                }\n+                                ty::impl_or_trait_item(ccx.tcx(),\n+                                                       did.def_id()).ident()\n+                                                                    .name ==\n+                                    name\n                              }).expect(\"could not find method while \\\n                                         translating\");\n \n@@ -323,6 +325,10 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             let impl_did = vtable_impl.impl_def_id;\n             let mname = match ty::trait_item(ccx.tcx(), trait_id, n_method) {\n                 ty::MethodTraitItem(method) => method.ident,\n+                ty::TypeTraitItem(_) => {\n+                    bcx.tcx().sess.bug(\"can't monomorphize an associated \\\n+                                        type\")\n+                }\n             };\n             let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n@@ -693,7 +699,7 @@ fn emit_vtable_methods(bcx: Block,\n     ty::populate_implementations_for_trait_if_necessary(bcx.tcx(), trt_id);\n \n     let trait_item_def_ids = ty::trait_item_def_ids(tcx, trt_id);\n-    trait_item_def_ids.iter().map(|method_def_id| {\n+    trait_item_def_ids.iter().flat_map(|method_def_id| {\n         let method_def_id = method_def_id.def_id();\n         let ident = ty::impl_or_trait_item(tcx, method_def_id).ident();\n         // The substitutions we have are on the impl, so we grab\n@@ -710,7 +716,7 @@ fn emit_vtable_methods(bcx: Block,\n                     debug!(\"(making impl vtable) method has self or type \\\n                             params: {}\",\n                            token::get_ident(ident));\n-                    C_null(Type::nil(ccx).ptr_to())\n+                    Some(C_null(Type::nil(ccx).ptr_to())).move_iter()\n                 } else {\n                     let mut fn_ref = trans_fn_ref_with_substs(\n                         bcx,\n@@ -724,9 +730,12 @@ fn emit_vtable_methods(bcx: Block,\n                                                      m_id,\n                                                      substs.clone());\n                     }\n-                    fn_ref\n+                    Some(fn_ref).move_iter()\n                 }\n             }\n+            ty::TypeTraitItem(_) => {\n+                None.move_iter()\n+            }\n         }\n     }).collect()\n }"}, {"sha": "d2bbbdfad0ef69244d967fcfec6e3d935702d3fe", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -231,6 +231,9 @@ pub fn monomorphic_fn(ccx: &CrateContext,\n                     }\n                     d\n                 }\n+                ast::TypeImplItem(_) => {\n+                    ccx.sess().bug(\"can't monomorphize an associated type\")\n+                }\n             }\n         }\n         ast_map::NodeTraitItem(method) => {"}, {"sha": "03550299fbdf5f746aae16760413402429cd30f6", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -92,6 +92,7 @@ impl<'a, 'blk, 'tcx> Reflector<'a, 'blk, 'tcx> {\n                 format!(\"couldn't find visit method for {}\", ty_name).as_slice());\n         let method = match self.visitor_items[mth_idx] {\n             ty::MethodTraitItem(ref method) => (*method).clone(),\n+            ty::TypeTraitItem(_) => return,\n         };\n         let mth_ty = ty::mk_bare_fn(tcx, method.fty.clone());\n         debug!(\"Emit call visit method: visit_{}: {}\", ty_name, ty_to_string(tcx, mth_ty));"}, {"sha": "897bc4517f4e1a442d920409b62014390def8aba", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 148, "deletions": 10, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -97,43 +97,52 @@ impl ImplOrTraitItemContainer {\n #[deriving(Clone)]\n pub enum ImplOrTraitItem {\n     MethodTraitItem(Rc<Method>),\n+    TypeTraitItem(Rc<AssociatedType>),\n }\n \n impl ImplOrTraitItem {\n     fn id(&self) -> ImplOrTraitItemId {\n         match *self {\n             MethodTraitItem(ref method) => MethodTraitItemId(method.def_id),\n+            TypeTraitItem(ref associated_type) => {\n+                TypeTraitItemId(associated_type.def_id)\n+            }\n         }\n     }\n \n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n             MethodTraitItem(ref method) => method.def_id,\n+            TypeTraitItem(ref associated_type) => associated_type.def_id,\n         }\n     }\n \n     pub fn ident(&self) -> ast::Ident {\n         match *self {\n             MethodTraitItem(ref method) => method.ident,\n+            TypeTraitItem(ref associated_type) => associated_type.ident,\n         }\n     }\n \n     pub fn container(&self) -> ImplOrTraitItemContainer {\n         match *self {\n             MethodTraitItem(ref method) => method.container,\n+            TypeTraitItem(ref associated_type) => associated_type.container,\n         }\n     }\n }\n \n #[deriving(Clone)]\n pub enum ImplOrTraitItemId {\n     MethodTraitItemId(ast::DefId),\n+    TypeTraitItemId(ast::DefId),\n }\n \n impl ImplOrTraitItemId {\n     pub fn def_id(&self) -> ast::DefId {\n         match *self {\n             MethodTraitItemId(def_id) => def_id,\n+            TypeTraitItemId(def_id) => def_id,\n         }\n     }\n }\n@@ -182,6 +191,14 @@ impl Method {\n     }\n }\n \n+#[deriving(Clone)]\n+pub struct AssociatedType {\n+    pub ident: ast::Ident,\n+    pub vis: ast::Visibility,\n+    pub def_id: ast::DefId,\n+    pub container: ImplOrTraitItemContainer,\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Hash, Show)]\n pub struct mt {\n     pub ty: t,\n@@ -556,6 +573,13 @@ pub struct ctxt<'tcx> {\n \n     /// Maps closures to their capture clauses.\n     pub capture_modes: RefCell<CaptureModeMap>,\n+\n+    /// Maps def IDs to true if and only if they're associated types.\n+    pub associated_types: RefCell<DefIdMap<bool>>,\n+\n+    /// Maps def IDs of traits to information about their associated types.\n+    pub trait_associated_types:\n+        RefCell<DefIdMap<Rc<Vec<AssociatedTypeInfo>>>>,\n }\n \n pub enum tbox_flag {\n@@ -1179,6 +1203,7 @@ pub struct TypeParameterDef {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: uint,\n+    pub associated_with: Option<ast::DefId>,\n     pub bounds: ParamBounds,\n     pub default: Option<ty::t>,\n }\n@@ -1238,7 +1263,7 @@ pub struct ParameterEnvironment {\n     /// the \"outer\" view of a type or method to the \"inner\" view.\n     /// In general, this means converting from bound parameters to\n     /// free parameters. Since we currently represent bound/free type\n-    /// parameters in the same way, this only has an affect on regions.\n+    /// parameters in the same way, this only has an effect on regions.\n     pub free_substs: Substs,\n \n     /// Bounds on the various type parameters\n@@ -1275,8 +1300,19 @@ impl ParameterEnvironment {\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n+                            TypeTraitItem(_) => {\n+                                cx.sess\n+                                  .bug(\"ParameterEnvironment::from_item(): \\\n+                                        can't create a parameter environment \\\n+                                        for type trait items\")\n+                            }\n                         }\n                     }\n+                    ast::TypeImplItem(_) => {\n+                        cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n+                                     can't create a parameter environment \\\n+                                     for type impl items\")\n+                    }\n                 }\n             }\n             Some(ast_map::NodeTraitItem(trait_method)) => {\n@@ -1299,8 +1335,19 @@ impl ParameterEnvironment {\n                                     method_generics,\n                                     method.pe_body().id)\n                             }\n+                            TypeTraitItem(_) => {\n+                                cx.sess\n+                                  .bug(\"ParameterEnvironment::from_item(): \\\n+                                        can't create a parameter environment \\\n+                                        for type trait items\")\n+                            }\n                         }\n                     }\n+                    ast::TypeTraitItem(_) => {\n+                        cx.sess.bug(\"ParameterEnvironment::from_item(): \\\n+                                     can't create a parameter environment \\\n+                                     for type trait items\")\n+                    }\n                 }\n             }\n             Some(ast_map::NodeItem(item)) => {\n@@ -1476,6 +1523,8 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n         capture_modes: RefCell::new(capture_modes),\n+        associated_types: RefCell::new(DefIdMap::new()),\n+        trait_associated_types: RefCell::new(DefIdMap::new()),\n     }\n }\n \n@@ -1894,6 +1943,10 @@ impl ParamTy {\n     pub fn to_ty(self, tcx: &ty::ctxt) -> ty::t {\n         ty::mk_param(tcx, self.space, self.idx, self.def_id)\n     }\n+\n+    pub fn is_self(&self) -> bool {\n+        self.space == subst::SelfSpace && self.idx == 0\n+    }\n }\n \n impl ItemSubsts {\n@@ -3543,6 +3596,10 @@ pub fn method_call_type_param_defs<'tcx, T>(typer: &T,\n         }) => {\n             match ty::trait_item(typer.tcx(), trait_ref.def_id, n_mth) {\n                 ty::MethodTraitItem(method) => method.generics.types.clone(),\n+                ty::TypeTraitItem(_) => {\n+                    typer.tcx().sess.bug(\"method_call_type_param_defs() \\\n+                                          called on associated type\")\n+                }\n             }\n         }\n     }\n@@ -4007,12 +4064,19 @@ pub fn provided_trait_methods(cx: &ctxt, id: ast::DefId) -> Vec<Rc<Method>> {\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n-                        ms.iter().filter_map(|m| match *m {\n-                            ast::RequiredMethod(_) => None,\n-                            ast::ProvidedMethod(ref m) => {\n-                                match impl_or_trait_item(cx,\n-                                        ast_util::local_def(m.id)) {\n-                                    MethodTraitItem(m) => Some(m),\n+                        let (_, p) =\n+                            ast_util::split_trait_methods(ms.as_slice());\n+                        p.iter()\n+                         .map(|m| {\n+                            match impl_or_trait_item(\n+                                    cx,\n+                                    ast_util::local_def(m.id)) {\n+                                MethodTraitItem(m) => m,\n+                                TypeTraitItem(_) => {\n+                                    cx.sess.bug(\"provided_trait_methods(): \\\n+                                                 split_trait_methods() put \\\n+                                                 associated types in the \\\n+                                                 provided method bucket?!\")\n                                 }\n                             }\n                          }).collect()\n@@ -4097,6 +4161,75 @@ pub fn impl_or_trait_item(cx: &ctxt, id: ast::DefId) -> ImplOrTraitItem {\n     })\n }\n \n+/// Returns true if the given ID refers to an associated type and false if it\n+/// refers to anything else.\n+pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n+    let result = match cx.associated_types.borrow_mut().find(&id) {\n+        Some(result) => return *result,\n+        None if id.krate == ast::LOCAL_CRATE => {\n+            match cx.impl_or_trait_items.borrow().find(&id) {\n+                Some(ref item) => {\n+                    match **item {\n+                        TypeTraitItem(_) => true,\n+                        MethodTraitItem(_) => false,\n+                    }\n+                }\n+                None => false,\n+            }\n+        }\n+        None => {\n+            csearch::is_associated_type(&cx.sess.cstore, id)\n+        }\n+    };\n+\n+    cx.associated_types.borrow_mut().insert(id, result);\n+    result\n+}\n+\n+/// Returns the parameter index that the given associated type corresponds to.\n+pub fn associated_type_parameter_index(cx: &ctxt,\n+                                       trait_def: &TraitDef,\n+                                       associated_type_id: ast::DefId)\n+                                       -> uint {\n+    for type_parameter_def in trait_def.generics.types.iter() {\n+        if type_parameter_def.def_id == associated_type_id {\n+            return type_parameter_def.index\n+        }\n+    }\n+    cx.sess.bug(\"couldn't find associated type parameter index\")\n+}\n+\n+#[deriving(PartialEq, Eq)]\n+pub struct AssociatedTypeInfo {\n+    pub def_id: ast::DefId,\n+    pub index: uint,\n+    pub ident: ast::Ident,\n+}\n+\n+impl PartialOrd for AssociatedTypeInfo {\n+    fn partial_cmp(&self, other: &AssociatedTypeInfo) -> Option<Ordering> {\n+        Some(self.index.cmp(&other.index))\n+    }\n+}\n+\n+impl Ord for AssociatedTypeInfo {\n+    fn cmp(&self, other: &AssociatedTypeInfo) -> Ordering {\n+        self.index.cmp(&other.index)\n+    }\n+}\n+\n+/// Returns the associated types belonging to the given trait, in parameter\n+/// order.\n+pub fn associated_types_for_trait(cx: &ctxt, trait_id: ast::DefId)\n+                                  -> Rc<Vec<AssociatedTypeInfo>> {\n+    cx.trait_associated_types\n+      .borrow()\n+      .find(&trait_id)\n+      .expect(\"associated_types_for_trait(): trait not found, try calling \\\n+               ensure_associated_types()\")\n+      .clone()\n+}\n+\n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n     lookup_locally_or_in_crate_store(\"trait_item_def_ids\",\n@@ -4978,6 +5111,7 @@ pub fn populate_implementations_for_type_if_necessary(tcx: &ctxt,\n                            .insert(method_def_id, source);\n                     }\n                 }\n+                TypeTraitItem(_) => {}\n             }\n         }\n \n@@ -5025,6 +5159,7 @@ pub fn populate_implementations_for_trait_if_necessary(\n                            .insert(method_def_id, source);\n                     }\n                 }\n+                TypeTraitItem(_) => {}\n             }\n         }\n \n@@ -5108,9 +5243,7 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n         Some(m) => m.clone(),\n         None => return None,\n     };\n-    let name = match impl_item {\n-        MethodTraitItem(method) => method.ident.name,\n-    };\n+    let name = impl_item.ident().name;\n     match trait_of_item(tcx, def_id) {\n         Some(trait_did) => {\n             let trait_items = ty::trait_items(tcx, trait_did);\n@@ -5364,6 +5497,11 @@ pub fn construct_parameter_environment(\n                             space: subst::ParamSpace,\n                             defs: &[TypeParameterDef]) {\n         for (i, def) in defs.iter().enumerate() {\n+            debug!(\"construct_parameter_environment(): push_types_from_defs: \\\n+                    space={} def={} index={}\",\n+                   space,\n+                   def.repr(tcx),\n+                   i);\n             let ty = ty::mk_param(tcx, space, i, def.def_id);\n             types.push(space, ty);\n         }"}, {"sha": "3b08ccd5a7b2e6c0c735711e14385f36971beed2", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -301,6 +301,7 @@ impl TypeFoldable for ty::TypeParameterDef {\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n+            associated_with: self.associated_with,\n             bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n         }"}, {"sha": "8f60be8f7fbc029fe5cc52ec3b6b4c7de9772ad2", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 183, "deletions": 33, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -70,14 +70,30 @@ use std::rc::Rc;\n use syntax::abi;\n use syntax::{ast, ast_util};\n use syntax::codemap::Span;\n+use syntax::parse::token;\n \n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n     fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype;\n     fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef>;\n \n-    // what type should we use when a type is omitted?\n+    /// What type should we use when a type is omitted?\n     fn ty_infer(&self, span: Span) -> ty::t;\n+\n+    /// Returns true if associated types from the given trait and type are\n+    /// allowed to be used here and false otherwise.\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool;\n+\n+    /// Returns the binding of the given associated type for some type.\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               trait_id: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -152,13 +168,16 @@ pub fn opt_ast_region_to_region<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     r\n }\n \n-fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-    this: &AC,\n-    rscope: &RS,\n-    decl_generics: &ty::Generics,\n-    self_ty: Option<ty::t>,\n-    path: &ast::Path) -> Substs\n-{\n+fn ast_path_substs<'tcx,AC,RS>(\n+                   this: &AC,\n+                   rscope: &RS,\n+                   decl_def_id: ast::DefId,\n+                   decl_generics: &ty::Generics,\n+                   self_ty: Option<ty::t>,\n+                   associated_ty: Option<ty::t>,\n+                   path: &ast::Path)\n+                   -> Substs\n+                   where AC: AstConv<'tcx>, RS: RegionScope {\n     /*!\n      * Given a path `path` that refers to an item `I` with the\n      * declared generics `decl_generics`, returns an appropriate\n@@ -206,10 +225,17 @@ fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     // Convert the type parameters supplied by the user.\n     let ty_param_defs = decl_generics.types.get_slice(TypeSpace);\n     let supplied_ty_param_count = path.segments.iter().flat_map(|s| s.types.iter()).count();\n-    let formal_ty_param_count = ty_param_defs.len();\n-    let required_ty_param_count = ty_param_defs.iter()\n-                                               .take_while(|x| x.default.is_none())\n-                                               .count();\n+    let formal_ty_param_count =\n+        ty_param_defs.iter()\n+                     .take_while(|x| !ty::is_associated_type(tcx, x.def_id))\n+                     .count();\n+    let required_ty_param_count =\n+        ty_param_defs.iter()\n+                     .take_while(|x| {\n+                        x.default.is_none() &&\n+                        !ty::is_associated_type(tcx, x.def_id)\n+                     })\n+                     .count();\n     if supplied_ty_param_count < required_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at least\"\n@@ -242,9 +268,11 @@ fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n             \"add #![feature(default_type_params)] to the crate attributes to enable\");\n     }\n \n-    let tps = path.segments.iter().flat_map(|s| s.types.iter())\n-                            .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n-                            .collect();\n+    let tps = path.segments\n+                  .iter()\n+                  .flat_map(|s| s.types.iter())\n+                  .map(|a_t| ast_ty_to_ty(this, rscope, &**a_t))\n+                  .collect();\n \n     let mut substs = Substs::new_type(tps, regions);\n \n@@ -263,24 +291,48 @@ fn ast_path_substs<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     }\n \n     for param in ty_param_defs.slice_from(supplied_ty_param_count).iter() {\n-        let default = param.default.unwrap();\n-        let default = default.subst_spanned(tcx, &substs, Some(path.span));\n-        substs.types.push(TypeSpace, default);\n+        match param.default {\n+            Some(default) => {\n+                // This is a default type parameter.\n+                let default = default.subst_spanned(tcx,\n+                                                    &substs,\n+                                                    Some(path.span));\n+                substs.types.push(TypeSpace, default);\n+            }\n+            None => {\n+                // This is an associated type.\n+                substs.types.push(\n+                    TypeSpace,\n+                    this.associated_type_binding(path.span,\n+                                                 associated_ty,\n+                                                 decl_def_id,\n+                                                 param.def_id))\n+            }\n+        }\n     }\n \n     substs\n }\n \n-pub fn ast_path_to_trait_ref<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n-        this: &AC,\n-        rscope: &RS,\n-        trait_def_id: ast::DefId,\n-        self_ty: Option<ty::t>,\n-        path: &ast::Path) -> Rc<ty::TraitRef> {\n+pub fn ast_path_to_trait_ref<'tcx,AC,RS>(this: &AC,\n+                                         rscope: &RS,\n+                                         trait_def_id: ast::DefId,\n+                                         self_ty: Option<ty::t>,\n+                                         associated_type: Option<ty::t>,\n+                                         path: &ast::Path)\n+                                         -> Rc<ty::TraitRef>\n+                                         where AC: AstConv<'tcx>,\n+                                               RS: RegionScope {\n     let trait_def = this.get_trait_def(trait_def_id);\n     Rc::new(ty::TraitRef {\n         def_id: trait_def_id,\n-        substs: ast_path_substs(this, rscope, &trait_def.generics, self_ty, path)\n+        substs: ast_path_substs(this,\n+                                rscope,\n+                                trait_def_id,\n+                                &trait_def.generics,\n+                                self_ty,\n+                                associated_type,\n+                                path)\n     })\n }\n \n@@ -289,15 +341,20 @@ pub fn ast_path_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     rscope: &RS,\n     did: ast::DefId,\n     path: &ast::Path)\n-    -> TypeAndSubsts\n-{\n+    -> TypeAndSubsts {\n     let tcx = this.tcx();\n     let ty::Polytype {\n         generics: generics,\n         ty: decl_ty\n     } = this.get_item_ty(did);\n \n-    let substs = ast_path_substs(this, rscope, &generics, None, path);\n+    let substs = ast_path_substs(this,\n+                                 rscope,\n+                                 did,\n+                                 &generics,\n+                                 None,\n+                                 None,\n+                                 path);\n     let ty = decl_ty.subst(tcx, &substs);\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n@@ -333,7 +390,7 @@ pub fn ast_path_to_ty_relaxed<'tcx, AC: AstConv<'tcx>,\n         Substs::new(VecPerParamSpace::params_from_type(type_params),\n                     VecPerParamSpace::params_from_type(region_params))\n     } else {\n-        ast_path_substs(this, rscope, &generics, None, path)\n+        ast_path_substs(this, rscope, did, &generics, None, None, path)\n     };\n \n     let ty = decl_ty.subst(tcx, &substs);\n@@ -639,8 +696,12 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n                 Some(&def::DefTrait(trait_def_id)) => {\n-                    let result = ast_path_to_trait_ref(\n-                        this, rscope, trait_def_id, None, path);\n+                    let result = ast_path_to_trait_ref(this,\n+                                                       rscope,\n+                                                       trait_def_id,\n+                                                       None,\n+                                                       None,\n+                                                       path);\n                     let bounds = match *opt_bounds {\n                         None => {\n                             conv_existential_bounds(this,\n@@ -686,6 +747,52 @@ fn mk_pointer<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n     constr(ast_ty_to_ty(this, rscope, a_seq_ty))\n }\n \n+fn associated_ty_to_ty<'tcx,AC,RS>(this: &AC,\n+                                   rscope: &RS,\n+                                   trait_path: &ast::Path,\n+                                   for_ast_type: &ast::Ty,\n+                                   trait_type_id: ast::DefId,\n+                                   span: Span)\n+                                   -> ty::t\n+                                   where AC: AstConv<'tcx>, RS: RegionScope {\n+    // Find the trait that this associated type belongs to.\n+    let trait_did = match ty::impl_or_trait_item(this.tcx(),\n+                                                 trait_type_id).container() {\n+        ty::ImplContainer(_) => {\n+            this.tcx().sess.span_bug(span,\n+                                     \"associated_ty_to_ty(): impl associated \\\n+                                      types shouldn't go through this \\\n+                                      function\")\n+        }\n+        ty::TraitContainer(trait_id) => trait_id,\n+    };\n+\n+    let for_type = ast_ty_to_ty(this, rscope, for_ast_type);\n+    if !this.associated_types_of_trait_are_valid(for_type, trait_did) {\n+        this.tcx().sess.span_err(span,\n+                                 \"this associated type is not \\\n+                                  allowed in this context\");\n+        return ty::mk_err()\n+    }\n+\n+    let trait_ref = ast_path_to_trait_ref(this,\n+                                          rscope,\n+                                          trait_did,\n+                                          None,\n+                                          Some(for_type),\n+                                          trait_path);\n+    let trait_def = this.get_trait_def(trait_did);\n+    for type_parameter in trait_def.generics.types.iter() {\n+        if type_parameter.def_id == trait_type_id {\n+            return *trait_ref.substs.types.get(type_parameter.space,\n+                                               type_parameter.index)\n+        }\n+    }\n+    this.tcx().sess.span_bug(span,\n+                             \"this associated type didn't get added \\\n+                              as a parameter for some reason\")\n+}\n+\n // Parses the programmer's textual representation of a type into our\n // internal notion of a type.\n pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n@@ -816,8 +923,12 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                 }\n                 match a_def {\n                     def::DefTrait(trait_def_id) => {\n-                        let result = ast_path_to_trait_ref(\n-                            this, rscope, trait_def_id, None, path);\n+                        let result = ast_path_to_trait_ref(this,\n+                                                           rscope,\n+                                                           trait_def_id,\n+                                                           None,\n+                                                           None,\n+                                                           path);\n                         let empty_bounds: &[ast::TyParamBound] = &[];\n                         let ast_bounds = match *bounds {\n                             Some(ref b) => b.as_slice(),\n@@ -856,6 +967,23 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     def::DefPrimTy(_) => {\n                         fail!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n                     }\n+                    def::DefAssociatedTy(trait_type_id) => {\n+                        let path_str = tcx.map.path_to_string(\n+                            tcx.map.get_parent(trait_type_id.node));\n+                        tcx.sess.span_err(ast_ty.span,\n+                                          format!(\"ambiguous associated \\\n+                                                   type; specify the type \\\n+                                                   using the syntax `<Type \\\n+                                                   as {}>::{}`\",\n+                                                  path_str,\n+                                                  token::get_ident(\n+                                                      path.segments\n+                                                          .last()\n+                                                          .unwrap()\n+                                                          .identifier)\n+                                                  .get()).as_slice());\n+                        ty::mk_err()\n+                    }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n                                             format!(\"found value name used \\\n@@ -864,6 +992,28 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                     }\n                 }\n             }\n+            ast::TyQPath(ref qpath) => {\n+                match tcx.def_map.borrow().find(&ast_ty.id) {\n+                    None => {\n+                        tcx.sess.span_bug(ast_ty.span,\n+                                          \"unbound qualified path\")\n+                    }\n+                    Some(&def::DefAssociatedTy(trait_type_id)) => {\n+                        associated_ty_to_ty(this,\n+                                            rscope,\n+                                            &qpath.trait_name,\n+                                            &*qpath.for_type,\n+                                            trait_type_id,\n+                                            ast_ty.span)\n+                    }\n+                    Some(_) => {\n+                        tcx.sess.span_err(ast_ty.span,\n+                                          \"this qualified path does not name \\\n+                                           an associated type\");\n+                        ty::mk_err()\n+                    }\n+                }\n+            }\n             ast::TyFixedLengthVec(ref ty, ref e) => {\n                 match const_eval::eval_const_expr_partial(tcx, &**e) {\n                     Ok(ref r) => {"}, {"sha": "5d2ce7b080eef7b96c312c61a064b1a2c2e759ad", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -226,6 +226,7 @@ fn get_method_index(tcx: &ty::ctxt,\n             for trait_item in trait_items.iter() {\n                 match *trait_item {\n                     ty::MethodTraitItem(_) => method_count += 1,\n+                    ty::TypeTraitItem(_) => {}\n                 }\n             }\n             true\n@@ -531,6 +532,11 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                                                .clone();\n         let method = match trait_item {\n             ty::MethodTraitItem(method) => method,\n+            ty::TypeTraitItem(_) => {\n+                self.tcx().sess.bug(\n+                    \"push_unboxed_closure_call_candidates_if_applicable(): \\\n+                     unexpected associated type in function trait\")\n+            }\n         };\n \n         // Make sure it has the right name!\n@@ -730,11 +736,16 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                         m.explicit_self != ty::StaticExplicitSelfCategory &&\n                         m.ident.name == self.m_name\n                     }\n+                    ty::TypeTraitItem(_) => false,\n                 }\n             }) {\n                 Some(pos) => {\n                     let method = match *trait_items.get(pos) {\n                         ty::MethodTraitItem(ref method) => (*method).clone(),\n+                        ty::TypeTraitItem(_) => {\n+                            tcx.sess.bug(\"typechecking associated type as \\\n+                                          though it were a method\")\n+                        }\n                     };\n \n                     match mk_cand(self,\n@@ -812,7 +823,10 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                                          m.ident().name == self.m_name\n                                      }) {\n             Some(ty::MethodTraitItem(method)) => method,\n-            None => { return; } // No method with the right name.\n+            Some(ty::TypeTraitItem(_)) | None => {\n+                // No method with the right name.\n+                return\n+            }\n         };\n \n         // determine the `self` of the impl with fresh\n@@ -1575,7 +1589,7 @@ impl<'a, 'tcx> LookupContext<'a, 'tcx> {\n                     // If we're reporting statics, we want to report the trait\n                     // definition if possible, rather than an impl\n                     match ty::trait_item_of_item(self.tcx(), impl_did) {\n-                        None => {\n+                        None | Some(TypeTraitItemId(_)) => {\n                             debug!(\"(report candidate) No trait method \\\n                                     found\");\n                             impl_did"}, {"sha": "c8728d375f6a3f119776df3fec5889849cbe57b2", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 110, "deletions": 4, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -126,7 +126,7 @@ use std::mem::replace;\n use std::rc::Rc;\n use std::slice;\n use syntax::abi;\n-use syntax::ast::{ProvidedMethod, RequiredMethod};\n+use syntax::ast::{ProvidedMethod, RequiredMethod, TypeTraitItem};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n@@ -765,6 +765,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 ast::MethodImplItem(ref m) => {\n                     check_method_body(ccx, &impl_pty.generics, &**m);\n                 }\n+                ast::TypeImplItem(_) => {\n+                    // Nothing to do here.\n+                }\n             }\n         }\n \n@@ -793,6 +796,9 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 ProvidedMethod(ref m) => {\n                     check_method_body(ccx, &trait_def.generics, &**m);\n                 }\n+                TypeTraitItem(_) => {\n+                    // Nothing to do.\n+                }\n             }\n         }\n       }\n@@ -898,6 +904,20 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                                     &**trait_method_ty,\n                                                     &impl_trait_ref.substs);\n                             }\n+                            _ => {\n+                                // This is span_bug as it should have already been\n+                                // caught in resolve.\n+                                tcx.sess\n+                                   .span_bug(impl_method.span,\n+                                             format!(\"item `{}` is of a \\\n+                                                      different kind from \\\n+                                                      its trait `{}`\",\n+                                                     token::get_ident(\n+                                                        impl_item_ty.ident()),\n+                                                     pprust::path_to_string(\n+                                                        &ast_trait_ref.path))\n+                                             .as_slice());\n+                            }\n                         }\n                     }\n                     None => {\n@@ -913,10 +933,57 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                     }\n                 }\n             }\n+            ast::TypeImplItem(ref typedef) => {\n+                let typedef_def_id = local_def(typedef.id);\n+                let typedef_ty = ty::impl_or_trait_item(ccx.tcx,\n+                                                        typedef_def_id);\n+\n+                // If this is an impl of an associated type, find the\n+                // corresponding type definition in the trait.\n+                let opt_associated_type =\n+                    trait_items.iter()\n+                               .find(|ti| {\n+                                   ti.ident().name == typedef_ty.ident().name\n+                               });\n+                match opt_associated_type {\n+                    Some(associated_type) => {\n+                        match (associated_type, &typedef_ty) {\n+                            (&ty::TypeTraitItem(_),\n+                             &ty::TypeTraitItem(_)) => {}\n+                            _ => {\n+                                // This is `span_bug` as it should have\n+                                // already been caught in resolve.\n+                                tcx.sess\n+                                   .span_bug(typedef.span,\n+                                             format!(\"item `{}` is of a \\\n+                                                      different kind from \\\n+                                                      its trait `{}`\",\n+                                                     token::get_ident(\n+                                                        typedef_ty.ident()),\n+                                                     pprust::path_to_string(\n+                                                        &ast_trait_ref.path))\n+                                             .as_slice());\n+                            }\n+                        }\n+                    }\n+                    None => {\n+                        // This is `span_bug` as it should have already been\n+                        // caught in resolve.\n+                        tcx.sess.span_bug(\n+                            typedef.span,\n+                            format!(\n+                                \"associated type `{}` is not a member of \\\n+                                 trait `{}`\",\n+                                token::get_ident(typedef_ty.ident()),\n+                                pprust::path_to_string(\n+                                    &ast_trait_ref.path)).as_slice());\n+                    }\n+                }\n+            }\n         }\n     }\n \n-    // Check for missing methods from trait\n+    // Check for missing items from trait\n     let provided_methods = ty::provided_trait_methods(tcx,\n                                                       impl_trait_ref.def_id);\n     let mut missing_methods = Vec::new();\n@@ -929,6 +996,7 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                             ast::MethodImplItem(ref m) => {\n                                 m.pe_ident().name == trait_method.ident.name\n                             }\n+                            ast::TypeImplItem(_) => false,\n                         }\n                     });\n                 let is_provided =\n@@ -940,12 +1008,27 @@ fn check_impl_items_against_trait(ccx: &CrateCtxt,\n                                 token::get_ident(trait_method.ident)));\n                 }\n             }\n+            ty::TypeTraitItem(ref associated_type) => {\n+                let is_implemented = impl_items.iter().any(|ii| {\n+                    match *ii {\n+                        ast::TypeImplItem(ref typedef) => {\n+                            typedef.ident.name == associated_type.ident.name\n+                        }\n+                        ast::MethodImplItem(_) => false,\n+                    }\n+                });\n+                if !is_implemented {\n+                    missing_methods.push(\n+                        format!(\"`{}`\",\n+                                token::get_ident(associated_type.ident)));\n+                }\n+            }\n         }\n     }\n \n     if !missing_methods.is_empty() {\n         span_err!(tcx.sess, impl_span, E0046,\n-            \"not all trait methods implemented, missing: {}\",\n+            \"not all trait items implemented, missing: {}\",\n             missing_methods.connect(\", \"));\n     }\n }\n@@ -969,7 +1052,8 @@ fn compare_impl_method(tcx: &ty::ctxt,\n                        impl_m_body_id: ast::NodeId,\n                        trait_m: &ty::Method,\n                        trait_to_impl_substs: &subst::Substs) {\n-    debug!(\"compare_impl_method()\");\n+    debug!(\"compare_impl_method(trait_to_impl_substs={})\",\n+           trait_to_impl_substs.repr(tcx));\n     let infcx = infer::new_infer_ctxt(tcx);\n \n     // Try to give more informative error messages about self typing\n@@ -1138,11 +1222,13 @@ fn compare_impl_method(tcx: &ty::ctxt,\n         // FIXME(pcwalton): We could be laxer here regarding sub- and super-\n         // traits, but I doubt that'll be wanted often, so meh.\n         for impl_trait_bound in impl_param_def.bounds.trait_bounds.iter() {\n+            debug!(\"compare_impl_method(): impl-trait-bound subst\");\n             let impl_trait_bound =\n                 impl_trait_bound.subst(tcx, &impl_to_skol_substs);\n \n             let mut ok = false;\n             for trait_bound in trait_param_def.bounds.trait_bounds.iter() {\n+                debug!(\"compare_impl_method(): trait-bound subst\");\n                 let trait_bound =\n                     trait_bound.subst(tcx, &trait_to_skol_substs);\n                 let infcx = infer::new_infer_ctxt(tcx);\n@@ -1185,6 +1271,9 @@ fn compare_impl_method(tcx: &ty::ctxt,\n     // other words, anyone expecting to call a method with the type\n     // from the trait, can safely call a method with the type from the\n     // impl instead.\n+    debug!(\"checking trait method for compatibility: impl ty {}, trait ty {}\",\n+           impl_fty.repr(tcx),\n+           trait_fty.repr(tcx));\n     match infer::mk_subty(&infcx, false, infer::MethodCompatCheck(impl_m_span),\n                           impl_fty, trait_fty) {\n         Ok(()) => {}\n@@ -1513,6 +1602,21 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn ty_infer(&self, _span: Span) -> ty::t {\n         self.infcx().next_ty_var()\n     }\n+\n+    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+                                           -> bool {\n+        false\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               _: Option<ty::t>,\n+                               _: ast::DefId,\n+                               _: ast::DefId)\n+                               -> ty::t {\n+        self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n+        ty::mk_err()\n+    }\n }\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -4938,6 +5042,7 @@ pub fn polytype_for_def(fcx: &FnCtxt,\n       }\n       def::DefTrait(_) |\n       def::DefTy(..) |\n+      def::DefAssociatedTy(..) |\n       def::DefPrimTy(_) |\n       def::DefTyParam(..)=> {\n         fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type\");\n@@ -5048,6 +5153,7 @@ pub fn instantiate_path(fcx: &FnCtxt,\n         def::DefVariant(..) |\n         def::DefTyParamBinder(..) |\n         def::DefTy(..) |\n+        def::DefAssociatedTy(..) |\n         def::DefTrait(..) |\n         def::DefPrimTy(..) |\n         def::DefTyParam(..) => {"}, {"sha": "cef6e31b93704c9e20315c6ec6e23e5ac7c950d5", "filename": "src/librustc/middle/typeck/coherence/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence%2Fmod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -22,7 +22,7 @@ use middle::subst;\n use middle::subst::{Substs};\n use middle::ty::get;\n use middle::ty::{ImplContainer, ImplOrTraitItemId, MethodTraitItemId};\n-use middle::ty::{lookup_item_type};\n+use middle::ty::{TypeTraitItemId, lookup_item_type};\n use middle::ty::{t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil, ty_open};\n use middle::ty::{ty_param, Polytype, ty_ptr};\n@@ -332,6 +332,9 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                     MethodTraitItemId(\n                                         local_def(ast_method.id))\n                                 }\n+                                ast::TypeImplItem(ref typedef) => {\n+                                    TypeTraitItemId(local_def(typedef.id))\n+                                }\n                             }\n                         }).collect();\n \n@@ -393,6 +396,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                            .insert(item_def_id.def_id(), source);\n                     }\n                 }\n+                ty::TypeTraitItem(_) => {}\n             }\n         }\n "}, {"sha": "b7aa7656ae9198dfaa7c6b09f79bfbf418461d79", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 1084, "deletions": 188, "changes": 1272, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -138,7 +138,13 @@ pub trait ToTy {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t;\n }\n \n-impl<'a, 'tcx> ToTy for CrateCtxt<'a, 'tcx> {\n+impl<'a,'tcx> ToTy for ImplCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n+        ast_ty_to_ty(self, rs, ast_ty)\n+    }\n+}\n+\n+impl<'a,'tcx> ToTy for CrateCtxt<'a,'tcx> {\n     fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> ty::t {\n         ast_ty_to_ty(self, rs, ast_ty)\n     }\n@@ -158,6 +164,9 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                 let abi = self.tcx.map.get_foreign_abi(id.node);\n                 ty_of_foreign_item(self, &*foreign_item, abi)\n             }\n+            Some(ast_map::NodeTraitItem(trait_item)) => {\n+                ty_of_trait_item(self, &*trait_item)\n+            }\n             x => {\n                 self.tcx.sess.bug(format!(\"unexpected sort of node \\\n                                            in get_item_ty(): {:?}\",\n@@ -175,6 +184,22 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                   \"the type placeholder `_` is not allowed within types on item signatures.\");\n         ty::mk_err()\n     }\n+\n+    fn associated_types_of_trait_are_valid(&self, _: ty::t, _: ast::DefId)\n+                                           -> bool {\n+        false\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               _: Option<ty::t>,\n+                               _: ast::DefId,\n+                               _: ast::DefId)\n+                               -> ty::t {\n+        self.tcx().sess.span_err(span, \"associated types may not be \\\n+                                        referenced here\");\n+        ty::mk_err()\n+    }\n }\n \n pub fn get_enum_variant_types(ccx: &CrateCtxt,\n@@ -201,7 +226,10 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n \n             ast::StructVariantKind(ref struct_def) => {\n                 let pty = Polytype {\n-                    generics: ty_generics_for_type(ccx, generics),\n+                    generics: ty_generics_for_type(\n+                        ccx,\n+                        generics,\n+                        DontCreateTypeParametersForAssociatedTypes),\n                     ty: enum_ty\n                 };\n \n@@ -214,7 +242,10 @@ pub fn get_enum_variant_types(ccx: &CrateCtxt,\n         };\n \n         let pty = Polytype {\n-            generics: ty_generics_for_type(ccx, generics),\n+            generics: ty_generics_for_type(\n+                          ccx,\n+                          generics,\n+                          DontCreateTypeParametersForAssociatedTypes),\n             ty: result_ty\n         };\n \n@@ -244,6 +275,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             ccx,\n                                             trait_id,\n                                             &trait_def.generics,\n+                                            trait_items.as_slice(),\n                                             &m.id,\n                                             &m.ident,\n                                             &m.explicit_self,\n@@ -257,6 +289,7 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             ccx,\n                                             trait_id,\n                                             &trait_def.generics,\n+                                            trait_items.as_slice(),\n                                             &m.id,\n                                             &m.pe_ident(),\n                                             m.pe_explicit_self(),\n@@ -265,6 +298,12 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                             &m.pe_fn_style(),\n                                             &*m.pe_fn_decl())\n                                     }\n+                                    ast::TypeTraitItem(ref at) => {\n+                                        tcx.sess.span_bug(at.span,\n+                                                          \"there shouldn't \\\n+                                                           be a type trait \\\n+                                                           item here\")\n+                                    }\n                                 });\n \n                                 if ty_method.explicit_self ==\n@@ -277,6 +316,22 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                    .insert(ty_method.def_id,\n                                            ty::MethodTraitItem(ty_method));\n                             }\n+                            ast::TypeTraitItem(ref ast_associated_type) => {\n+                                let trait_did = local_def(trait_id);\n+                                let associated_type = ty::AssociatedType {\n+                                    ident: ast_associated_type.ident,\n+                                    vis: ast::Public,\n+                                    def_id: local_def(ast_associated_type.id),\n+                                    container: TraitContainer(trait_did),\n+                                };\n+\n+                                let trait_item = ty::TypeTraitItem(Rc::new(\n+                                        associated_type));\n+                                tcx.impl_or_trait_items\n+                                   .borrow_mut()\n+                                   .insert(associated_type.def_id,\n+                                           trait_item);\n+                            }\n                         }\n                     }\n \n@@ -293,6 +348,9 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                     ty::MethodTraitItemId(local_def(\n                                             method.id))\n                                 }\n+                                ast::TypeTraitItem(ref typedef) => {\n+                                    ty::TypeTraitItemId(local_def(typedef.id))\n+                                }\n                             }\n                         }).collect());\n \n@@ -314,9 +372,10 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                 ty: ty::mk_bare_fn(ccx.tcx, m.fty.clone()) });\n     }\n \n-    fn ty_method_of_trait_method(this: &CrateCtxt,\n+    fn ty_method_of_trait_method(ccx: &CrateCtxt,\n                                  trait_id: ast::NodeId,\n                                  trait_generics: &ty::Generics,\n+                                 trait_items: &[ast::TraitItem],\n                                  m_id: &ast::NodeId,\n                                  m_ident: &ast::Ident,\n                                  m_explicit_self: &ast::ExplicitSelf,\n@@ -325,20 +384,31 @@ fn collect_trait_methods(ccx: &CrateCtxt,\n                                  m_fn_style: &ast::FnStyle,\n                                  m_decl: &ast::FnDecl)\n                                  -> ty::Method {\n-        let trait_self_ty = ty::mk_self_type(this.tcx, local_def(trait_id));\n-\n-        let (fty, explicit_self_category) =\n-            astconv::ty_of_method(this,\n+        let ty_generics =\n+            ty_generics_for_fn_or_method(\n+                ccx,\n+                m_generics,\n+                (*trait_generics).clone(),\n+                DontCreateTypeParametersForAssociatedTypes);\n+\n+        let (fty, explicit_self_category) = {\n+            let tmcx = TraitMethodCtxt {\n+                ccx: ccx,\n+                trait_id: local_def(trait_id),\n+                trait_items: trait_items.as_slice(),\n+                method_generics: &ty_generics,\n+            };\n+            let trait_self_ty = ty::mk_self_type(tmcx.tcx(),\n+                                                 local_def(trait_id));\n+            astconv::ty_of_method(&tmcx,\n                                   *m_id,\n                                   *m_fn_style,\n                                   trait_self_ty,\n                                   m_explicit_self,\n                                   m_decl,\n-                                  m_abi);\n-        let ty_generics =\n-            ty_generics_for_fn_or_method(this,\n-                                         m_generics,\n-                                         (*trait_generics).clone());\n+                                  m_abi)\n+        };\n+\n         ty::Method::new(\n             *m_ident,\n             ty_generics,\n@@ -386,12 +456,73 @@ pub fn convert_field(ccx: &CrateCtxt,\n     }\n }\n \n-fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n-        container: ImplOrTraitItemContainer,\n-        mut ms: I,\n-        untransformed_rcvr_ty: ty::t,\n-        rcvr_ty_generics: &ty::Generics,\n-        rcvr_visibility: ast::Visibility) {\n+fn convert_associated_type(ccx: &CrateCtxt,\n+                           trait_def: &ty::TraitDef,\n+                           associated_type: &ast::AssociatedType)\n+                           -> ty::Polytype {\n+    // Find the type parameter ID corresponding to this\n+    // associated type.\n+    let type_parameter_def = trait_def.generics\n+                                      .types\n+                                      .get_slice(subst::TypeSpace)\n+                                      .iter()\n+                                      .find(|def| {\n+        def.def_id == local_def(associated_type.id)\n+    });\n+    let type_parameter_def = match type_parameter_def {\n+        Some(type_parameter_def) => type_parameter_def,\n+        None => {\n+            ccx.tcx().sess.span_bug(associated_type.span,\n+                                    \"`convert_associated_type()` didn't find \\\n+                                     a type parameter ID corresponding to \\\n+                                     this type\")\n+        }\n+    };\n+    let param_type = ty::mk_param(ccx.tcx,\n+                                  subst::TypeSpace,\n+                                  type_parameter_def.index,\n+                                  local_def(associated_type.id));\n+    ccx.tcx.tcache.borrow_mut().insert(local_def(associated_type.id),\n+                                       Polytype {\n+                                        generics: ty::Generics::empty(),\n+                                        ty: param_type,\n+                                       });\n+    write_ty_to_tcx(ccx.tcx, associated_type.id, param_type);\n+\n+    let associated_type = Rc::new(ty::AssociatedType {\n+        ident: associated_type.ident,\n+        vis: ast::Public,\n+        def_id: local_def(associated_type.id),\n+        container: TraitContainer(trait_def.trait_ref.def_id),\n+    });\n+    ccx.tcx\n+       .impl_or_trait_items\n+       .borrow_mut()\n+       .insert(associated_type.def_id,\n+               ty::TypeTraitItem(associated_type));\n+\n+    Polytype {\n+        generics: ty::Generics::empty(),\n+        ty: param_type,\n+    }\n+}\n+\n+enum ConvertMethodContext<'a> {\n+    /// Used when converting implementation methods.\n+    ImplConvertMethodContext,\n+    /// Used when converting method signatures. The def ID is the def ID of\n+    /// the trait we're translating.\n+    TraitConvertMethodContext(ast::DefId, &'a [ast::TraitItem]),\n+}\n+\n+fn convert_methods<'a,I>(ccx: &CrateCtxt,\n+                         convert_method_context: ConvertMethodContext,\n+                         container: ImplOrTraitItemContainer,\n+                         mut ms: I,\n+                         untransformed_rcvr_ty: ty::t,\n+                         rcvr_ty_generics: &ty::Generics,\n+                         rcvr_visibility: ast::Visibility)\n+                         where I: Iterator<&'a ast::Method> {\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, \\\n             rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n@@ -400,21 +531,22 @@ fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n     let tcx = ccx.tcx;\n     let mut seen_methods = HashSet::new();\n     for m in ms {\n-        if !seen_methods.insert(m.pe_ident().repr(ccx.tcx)) {\n+        if !seen_methods.insert(m.pe_ident().repr(tcx)) {\n             tcx.sess.span_err(m.span, \"duplicate method in trait impl\");\n         }\n \n         let mty = Rc::new(ty_of_method(ccx,\n+                                       convert_method_context,\n                                        container,\n                                        m,\n                                        untransformed_rcvr_ty,\n                                        rcvr_ty_generics,\n                                        rcvr_visibility));\n         let fty = ty::mk_bare_fn(tcx, mty.fty.clone());\n         debug!(\"method {} (id {}) has type {}\",\n-                m.pe_ident().repr(ccx.tcx),\n+                m.pe_ident().repr(tcx),\n                 m.id,\n-                fty.repr(ccx.tcx));\n+                fty.repr(tcx));\n         tcx.tcache.borrow_mut().insert(\n             local_def(m.id),\n             Polytype {\n@@ -433,6 +565,7 @@ fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n     }\n \n     fn ty_of_method(ccx: &CrateCtxt,\n+                    convert_method_context: ConvertMethodContext,\n                     container: ImplOrTraitItemContainer,\n                     m: &ast::Method,\n                     untransformed_rcvr_ty: ty::t,\n@@ -453,24 +586,50 @@ fn convert_methods<'a, I: Iterator<&'a ast::Method>>(ccx: &CrateCtxt,\n             _ => m.pe_abi(),\n         };\n \n-        let (fty, explicit_self_category) =\n-            astconv::ty_of_method(ccx,\n-                                  m.id,\n-                                  m.pe_fn_style(),\n-                                  untransformed_rcvr_ty,\n-                                  m.pe_explicit_self(),\n-                                  &*m.pe_fn_decl(),\n-                                  real_abi);\n+        let m_ty_generics =\n+            ty_generics_for_fn_or_method(\n+                ccx,\n+                m.pe_generics(),\n+                (*rcvr_ty_generics).clone(),\n+                CreateTypeParametersForAssociatedTypes);\n+\n+        let (fty, explicit_self_category) = match convert_method_context {\n+            ImplConvertMethodContext => {\n+                let imcx = ImplMethodCtxt {\n+                    ccx: ccx,\n+                    method_generics: &m_ty_generics,\n+                };\n+                astconv::ty_of_method(&imcx,\n+                                      m.id,\n+                                      m.pe_fn_style(),\n+                                      untransformed_rcvr_ty,\n+                                      m.pe_explicit_self(),\n+                                      &*m.pe_fn_decl(),\n+                                      real_abi)\n+            }\n+            TraitConvertMethodContext(trait_id, trait_items) => {\n+                let tmcx = TraitMethodCtxt {\n+                    ccx: ccx,\n+                    trait_id: trait_id,\n+                    trait_items: trait_items,\n+                    method_generics: &m_ty_generics,\n+                };\n+                astconv::ty_of_method(&tmcx,\n+                                      m.id,\n+                                      m.pe_fn_style(),\n+                                      untransformed_rcvr_ty,\n+                                      m.pe_explicit_self(),\n+                                      &*m.pe_fn_decl(),\n+                                      real_abi)\n+            }\n+        };\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n         // { fn foo(); }` is public, but private in `priv impl { fn\n         // foo(); }`).\n         let method_vis = m.pe_vis().inherit_from(rcvr_visibility);\n \n-        let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx, m.pe_generics(),\n-                                         (*rcvr_ty_generics).clone());\n         ty::Method::new(m.pe_ident(),\n                         m_ty_generics,\n                         fty,\n@@ -507,6 +666,404 @@ pub fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n+fn is_associated_type_valid_for_param(ty: ty::t,\n+                                      trait_id: ast::DefId,\n+                                      generics: &ty::Generics)\n+                                      -> bool {\n+    match ty::get(ty).sty {\n+        ty::ty_param(param_ty) => {\n+            let type_parameter = generics.types.get(param_ty.space,\n+                                                    param_ty.idx);\n+            for trait_bound in type_parameter.bounds.trait_bounds.iter() {\n+                if trait_bound.def_id == trait_id {\n+                    return true\n+                }\n+            }\n+        }\n+        _ => {}\n+    }\n+\n+    false\n+}\n+\n+fn find_associated_type_in_generics(tcx: &ty::ctxt,\n+                                    span: Span,\n+                                    ty: Option<ty::t>,\n+                                    associated_type_id: ast::DefId,\n+                                    generics: &ty::Generics)\n+                                    -> ty::t {\n+    let ty = match ty {\n+        None => {\n+            tcx.sess.span_bug(span,\n+                              \"find_associated_type_in_generics(): no self \\\n+                               type\")\n+        }\n+        Some(ty) => ty,\n+    };\n+\n+    match ty::get(ty).sty {\n+        ty::ty_param(ref param_ty) => {\n+            /*let type_parameter = generics.types.get(param_ty.space,\n+                                                    param_ty.idx);\n+            let param_id = type_parameter.def_id;*/\n+            let param_id = param_ty.def_id;\n+            for type_parameter in generics.types.iter() {\n+                if type_parameter.def_id == associated_type_id\n+                    && type_parameter.associated_with == Some(param_id) {\n+                    return ty::mk_param_from_def(tcx, type_parameter)\n+                }\n+            }\n+\n+            tcx.sess.span_bug(span,\n+                              \"find_associated_type_in_generics(): didn't \\\n+                               find associated type anywhere in the generics \\\n+                               list\")\n+        }\n+        _ => {\n+            tcx.sess.span_bug(span,\n+                              \"find_associated_type_in_generics(): self type \\\n+                               is not a parameter\")\n+\n+        }\n+    }\n+}\n+\n+fn type_is_self(ty: ty::t) -> bool {\n+    match ty::get(ty).sty {\n+        ty::ty_param(ref param_ty) if param_ty.is_self() => true,\n+        _ => false,\n+    }\n+}\n+\n+struct ImplCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    opt_trait_ref_id: Option<ast::DefId>,\n+    impl_items: &'a [ast::ImplItem],\n+    impl_generics: &'a ty::Generics,\n+}\n+\n+impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        self.ccx.get_item_ty(id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        self.ccx.get_trait_def(id)\n+    }\n+\n+    fn ty_infer(&self, span: Span) -> ty::t {\n+        self.ccx.ty_infer(span)\n+    }\n+\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool {\n+        // OK if the trait with the associated type is the trait we're\n+        // implementing.\n+        match self.opt_trait_ref_id {\n+            Some(trait_ref_id) if trait_ref_id == trait_id => {\n+                if type_is_self(ty) {\n+                    return true\n+                }\n+            }\n+            Some(_) | None => {}\n+        }\n+\n+        // OK if the trait with the associated type is one of the traits in\n+        // our bounds.\n+        is_associated_type_valid_for_param(ty, trait_id, self.impl_generics)\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               trait_id: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        ensure_associated_types(self, trait_id);\n+        let associated_type_ids = ty::associated_types_for_trait(self.ccx.tcx,\n+                                                                 trait_id);\n+        match self.opt_trait_ref_id {\n+            Some(trait_ref_id) if trait_ref_id == trait_id => {\n+                // It's an associated type on the trait that we're\n+                // implementing.\n+                let associated_type_id =\n+                    associated_type_ids.iter()\n+                                       .find(|id| {\n+                                           id.def_id == associated_type_id\n+                                       })\n+                                       .expect(\"associated_type_binding(): \\\n+                                                expected associated type ID \\\n+                                                in trait\");\n+                let associated_type =\n+                    ty::impl_or_trait_item(self.ccx.tcx,\n+                                           associated_type_id.def_id);\n+                for impl_item in self.impl_items.iter() {\n+                    match *impl_item {\n+                        ast::MethodImplItem(_) => {}\n+                        ast::TypeImplItem(ref typedef) => {\n+                            if associated_type.ident().name == typedef.ident\n+                                                                      .name {\n+                                return self.ccx.to_ty(&ExplicitRscope,\n+                                                      &*typedef.typ)\n+                            }\n+                        }\n+                    }\n+                }\n+                self.ccx\n+                    .tcx\n+                    .sess\n+                    .span_bug(span,\n+                              \"ImplCtxt::associated_type_binding(): didn't \\\n+                               find associated type\")\n+            }\n+            Some(_) | None => {}\n+        }\n+\n+        // OK then, it should be an associated type on one of the traits in\n+        // our bounds.\n+        find_associated_type_in_generics(self.ccx.tcx,\n+                                         span,\n+                                         ty,\n+                                         associated_type_id,\n+                                         self.impl_generics)\n+    }\n+}\n+\n+struct FnCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    generics: &'a ty::Generics,\n+}\n+\n+impl<'a,'tcx> AstConv<'tcx> for FnCtxt<'a,'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        self.ccx.get_item_ty(id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        self.ccx.get_trait_def(id)\n+    }\n+\n+    fn ty_infer(&self, span: Span) -> ty::t {\n+        self.ccx.ty_infer(span)\n+    }\n+\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool {\n+        // OK if the trait with the associated type is one of the traits in\n+        // our bounds.\n+        is_associated_type_valid_for_param(ty, trait_id, self.generics)\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               _: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        debug!(\"collect::FnCtxt::associated_type_binding()\");\n+\n+        // The ID should map to an associated type on one of the traits in\n+        // our bounds.\n+        find_associated_type_in_generics(self.ccx.tcx,\n+                                         span,\n+                                         ty,\n+                                         associated_type_id,\n+                                         self.generics)\n+    }\n+}\n+\n+struct ImplMethodCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    method_generics: &'a ty::Generics,\n+}\n+\n+impl<'a,'tcx> AstConv<'tcx> for ImplMethodCtxt<'a,'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        self.ccx.get_item_ty(id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        self.ccx.get_trait_def(id)\n+    }\n+\n+    fn ty_infer(&self, span: Span) -> ty::t {\n+        self.ccx.ty_infer(span)\n+    }\n+\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool {\n+        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               _: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        debug!(\"collect::ImplMethodCtxt::associated_type_binding()\");\n+\n+        // The ID should map to an associated type on one of the traits in\n+        // our bounds.\n+        find_associated_type_in_generics(self.ccx.tcx,\n+                                         span,\n+                                         ty,\n+                                         associated_type_id,\n+                                         self.method_generics)\n+    }\n+}\n+\n+struct TraitMethodCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    trait_id: ast::DefId,\n+    trait_items: &'a [ast::TraitItem],\n+    method_generics: &'a ty::Generics,\n+}\n+\n+impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.ccx.tcx\n+    }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        self.ccx.get_item_ty(id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        self.ccx.get_trait_def(id)\n+    }\n+\n+    fn ty_infer(&self, span: Span) -> ty::t {\n+        self.ccx.ty_infer(span)\n+    }\n+\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool {\n+        // OK if the trait with the associated type is this trait.\n+        if self.trait_id == trait_id && type_is_self(ty) {\n+            return true\n+        }\n+\n+        // OK if the trait with the associated type is one of the traits in\n+        // our bounds.\n+        is_associated_type_valid_for_param(ty, trait_id, self.method_generics)\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               trait_id: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n+\n+        // If this is one of our own associated types, return it.\n+        if trait_id == self.trait_id {\n+            let mut index = 0;\n+            for item in self.trait_items.iter() {\n+                match *item {\n+                    ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n+                    ast::TypeTraitItem(ref item) => {\n+                        if local_def(item.id) == associated_type_id {\n+                            return ty::mk_param(self.tcx(),\n+                                                subst::TypeSpace,\n+                                                index,\n+                                                associated_type_id)\n+                        }\n+                        index += 1;\n+                    }\n+                }\n+            }\n+            self.ccx\n+                .tcx\n+                .sess\n+                .span_bug(span,\n+                          \"TraitMethodCtxt::associated_type_binding(): \\\n+                           didn't find associated type anywhere in the item \\\n+                           list\")\n+        }\n+\n+        // The ID should map to an associated type on one of the traits in\n+        // our bounds.\n+        find_associated_type_in_generics(self.ccx.tcx,\n+                                         span,\n+                                         ty,\n+                                         associated_type_id,\n+                                         self.method_generics)\n+    }\n+}\n+\n+struct GenericsCtxt<'a,AC:'a> {\n+    chain: &'a AC,\n+    associated_types_generics: &'a ty::Generics,\n+}\n+\n+impl<'a,'tcx,AC:AstConv<'tcx>> AstConv<'tcx> for GenericsCtxt<'a,AC> {\n+    fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx> {\n+        self.chain.tcx()\n+    }\n+\n+    fn get_item_ty(&self, id: ast::DefId) -> ty::Polytype {\n+        self.chain.get_item_ty(id)\n+    }\n+\n+    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef> {\n+        self.chain.get_trait_def(id)\n+    }\n+\n+    fn ty_infer(&self, span: Span) -> ty::t {\n+        self.chain.ty_infer(span)\n+    }\n+\n+    fn associated_types_of_trait_are_valid(&self,\n+                                           ty: ty::t,\n+                                           trait_id: ast::DefId)\n+                                           -> bool {\n+        // OK if the trait with the associated type is one of the traits in\n+        // our bounds.\n+        is_associated_type_valid_for_param(ty,\n+                                           trait_id,\n+                                           self.associated_types_generics)\n+    }\n+\n+    fn associated_type_binding(&self,\n+                               span: Span,\n+                               ty: Option<ty::t>,\n+                               _: ast::DefId,\n+                               associated_type_id: ast::DefId)\n+                               -> ty::t {\n+        debug!(\"collect::GenericsCtxt::associated_type_binding()\");\n+\n+        // The ID should map to an associated type on one of the traits in\n+        // our bounds.\n+        find_associated_type_in_generics(self.chain.tcx(),\n+                                         span,\n+                                         ty,\n+                                         associated_type_id,\n+                                         self.associated_types_generics)\n+    }\n+}\n+\n pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n@@ -525,14 +1082,22 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                       ref opt_trait_ref,\n                       ref selfty,\n                       ref impl_items) => {\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n+            // Create generics from the generics specified in the impl head.\n+            let ty_generics = ty_generics_for_type(\n+                    ccx,\n+                    generics,\n+                    CreateTypeParametersForAssociatedTypes);\n+\n             let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n-            tcx.tcache.borrow_mut().insert(local_def(it.id),\n-                                Polytype {\n-                                    generics: ty_generics.clone(),\n-                                    ty: selfty});\n+            tcx.tcache\n+               .borrow_mut()\n+               .insert(local_def(it.id),\n+                       Polytype {\n+                        generics: ty_generics.clone(),\n+                        ty: selfty,\n+                       });\n \n             // If there is a trait reference, treat the methods as always public.\n             // This is to work around some incorrect behavior in privacy checking:\n@@ -545,6 +1110,20 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                 it.vis\n             };\n \n+            let icx = ImplCtxt {\n+                ccx: ccx,\n+                opt_trait_ref_id: match *opt_trait_ref {\n+                    None => None,\n+                    Some(ref ast_trait_ref) => {\n+                        Some(lookup_def_tcx(tcx,\n+                                            ast_trait_ref.path.span,\n+                                            ast_trait_ref.ref_id).def_id())\n+                    }\n+                },\n+                impl_items: impl_items.as_slice(),\n+                impl_generics: &ty_generics,\n+            };\n+\n             let mut methods = Vec::new();\n             for impl_item in impl_items.iter() {\n                 match *impl_item {\n@@ -555,18 +1134,41 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                method.pe_explicit_self());\n                         methods.push(&**method);\n                     }\n+                    ast::TypeImplItem(ref typedef) => {\n+                        let typ = icx.to_ty(&ExplicitRscope, &*typedef.typ);\n+                        tcx.tcache\n+                           .borrow_mut()\n+                           .insert(local_def(typedef.id),\n+                                   Polytype {\n+                                    generics: ty::Generics::empty(),\n+                                    ty: typ,\n+                                   });\n+                        write_ty_to_tcx(ccx.tcx, typedef.id, typ);\n+\n+                        let associated_type = Rc::new(ty::AssociatedType {\n+                            ident: typedef.ident,\n+                            vis: typedef.vis,\n+                            def_id: local_def(typedef.id),\n+                            container: ty::ImplContainer(local_def(it.id)),\n+                        });\n+                        tcx.impl_or_trait_items\n+                           .borrow_mut()\n+                           .insert(local_def(typedef.id),\n+                                   ty::TypeTraitItem(associated_type));\n+                    }\n                 }\n             }\n \n             convert_methods(ccx,\n+                            ImplConvertMethodContext,\n                             ImplContainer(local_def(it.id)),\n                             methods.into_iter(),\n                             selfty,\n                             &ty_generics,\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                instantiate_trait_ref(ccx, trait_ref, selfty);\n+                instantiate_trait_ref(&icx, trait_ref, selfty, None);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -595,16 +1197,27 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                                                self_type,\n                                                method.pe_explicit_self())\n                     }\n+                    ast::TypeTraitItem(ref associated_type) => {\n+                        convert_associated_type(ccx,\n+                                                &*trait_def,\n+                                                &**associated_type);\n+                    }\n                 }\n             }\n \n             // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx, local_def(it.id));\n+            let untransformed_rcvr_ty = ty::mk_self_type(tcx,\n+                                                         local_def(it.id));\n+            let convert_method_context =\n+                TraitConvertMethodContext(local_def(it.id),\n+                                          trait_methods.as_slice());\n             convert_methods(ccx,\n+                            convert_method_context,\n                             TraitContainer(local_def(it.id)),\n                             trait_methods.iter().filter_map(|m| match *m {\n                                 ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(&**m)\n+                                ast::ProvidedMethod(ref m) => Some(&**m),\n+                                ast::TypeTraitItem(_) => None,\n                             }),\n                             untransformed_rcvr_ty,\n                             &trait_def.generics,\n@@ -765,9 +1378,12 @@ pub fn convert_foreign(ccx: &CrateCtxt, i: &ast::ForeignItem) {\n     ccx.tcx.tcache.borrow_mut().insert(local_def(i.id), pty);\n }\n \n-pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n-                             ast_trait_ref: &ast::TraitRef,\n-                             self_ty: ty::t) -> Rc<ty::TraitRef> {\n+pub fn instantiate_trait_ref<'tcx,AC>(this: &AC,\n+                                      ast_trait_ref: &ast::TraitRef,\n+                                      self_ty: ty::t,\n+                                      associated_type: Option<ty::t>)\n+                                      -> Rc<ty::TraitRef>\n+                                      where AC: AstConv<'tcx> {\n     /*!\n      * Instantiates the path for the given trait reference, assuming that\n      * it's bound to a valid trait type. Returns the def_id for the defining\n@@ -777,33 +1393,39 @@ pub fn instantiate_trait_ref(ccx: &CrateCtxt,\n     // FIXME(#5121) -- distinguish early vs late lifetime params\n     let rscope = ExplicitRscope;\n \n-    match lookup_def_tcx(ccx.tcx, ast_trait_ref.path.span, ast_trait_ref.ref_id) {\n+    match lookup_def_tcx(this.tcx(),\n+                         ast_trait_ref.path.span,\n+                         ast_trait_ref.ref_id) {\n         def::DefTrait(trait_did) => {\n             let trait_ref =\n-                astconv::ast_path_to_trait_ref(\n-                    ccx, &rscope, trait_did, Some(self_ty), &ast_trait_ref.path);\n+                astconv::ast_path_to_trait_ref(this,\n+                                               &rscope,\n+                                               trait_did,\n+                                               Some(self_ty),\n+                                               associated_type,\n+                                               &ast_trait_ref.path);\n \n-            ccx.tcx.trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n-                                                   trait_ref.clone());\n+            this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n+                                                      trait_ref.clone());\n             trait_ref\n         }\n         _ => {\n-            ccx.tcx.sess.span_fatal(\n+            this.tcx().sess.span_fatal(\n                 ast_trait_ref.path.span,\n                 format!(\"`{}` is not a trait\",\n                         path_to_string(&ast_trait_ref.path)).as_slice());\n         }\n     }\n }\n \n-pub fn instantiate_unboxed_fn_ty(ccx: &CrateCtxt,\n-                                 unboxed_function: &ast::UnboxedFnTy,\n-                                 param_ty: ty::ParamTy)\n-                                 -> Rc<ty::TraitRef>\n-{\n+pub fn instantiate_unboxed_fn_ty<'tcx,AC>(this: &AC,\n+                                          unboxed_function: &ast::UnboxedFnTy,\n+                                          param_ty: ty::ParamTy)\n+                                          -> Rc<ty::TraitRef>\n+                                          where AC: AstConv<'tcx> {\n     let rscope = ExplicitRscope;\n-    let param_ty = param_ty.to_ty(ccx.tcx);\n-    Rc::new(astconv::trait_ref_for_unboxed_function(ccx,\n+    let param_ty = param_ty.to_ty(this.tcx());\n+    Rc::new(astconv::trait_ref_for_unboxed_function(this,\n                                                     &rscope,\n                                                     unboxed_function,\n                                                     Some(param_ty)))\n@@ -831,9 +1453,12 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         _ => {}\n     }\n \n-    let (generics, unbound, bounds) = match it.node {\n-        ast::ItemTrait(ref generics, ref unbound, ref bounds, _) => {\n-            (generics, unbound, bounds)\n+    let (generics, unbound, bounds, items) = match it.node {\n+        ast::ItemTrait(ref generics,\n+                       ref unbound,\n+                       ref supertraits,\n+                       ref items) => {\n+            (generics, unbound, supertraits, items.as_slice())\n         }\n         ref s => {\n             tcx.sess.span_bug(\n@@ -842,12 +1467,13 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n         }\n     };\n \n-    let substs = mk_trait_substs(ccx, it.id, generics);\n+    let substs = mk_trait_substs(ccx, it.id, generics, items);\n \n     let ty_generics = ty_generics_for_trait(ccx,\n                                             it.id,\n                                             &substs,\n-                                            generics);\n+                                            generics,\n+                                            items);\n \n     let self_param_ty = ty::ParamTy::for_self(def_id);\n \n@@ -870,9 +1496,9 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n \n     fn mk_trait_substs(ccx: &CrateCtxt,\n                        trait_id: ast::NodeId,\n-                       generics: &ast::Generics)\n-                        -> subst::Substs\n-    {\n+                       generics: &ast::Generics,\n+                       items: &[ast::TraitItem])\n+                        -> subst::Substs {\n         // Creates a no-op substitution for the trait's type parameters.\n         let regions =\n             generics.lifetimes\n@@ -884,14 +1510,29 @@ pub fn trait_def_of_item(ccx: &CrateCtxt, it: &ast::Item) -> Rc<ty::TraitDef> {\n                                                      def.lifetime.name))\n                     .collect();\n \n-        let types =\n+        // Start with the generics in the type parameters...\n+        let mut types: Vec<_> =\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::mk_param(ccx.tcx, subst::TypeSpace,\n                                                  i, local_def(def.id)))\n                     .collect();\n \n+        // ...and add generics synthesized from the associated types.\n+        for item in items.iter() {\n+            match *item {\n+                ast::TypeTraitItem(ref trait_item) => {\n+                    let index = types.len();\n+                    types.push(ty::mk_param(ccx.tcx,\n+                                            subst::TypeSpace,\n+                                            index,\n+                                            local_def(trait_item.id)))\n+                }\n+                ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n+            }\n+        }\n+\n         let self_ty =\n             ty::mk_param(ccx.tcx, subst::SelfSpace, 0, local_def(trait_id));\n \n@@ -916,21 +1557,30 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             return pty;\n         }\n         ast::ItemFn(ref decl, fn_style, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(ccx, generics,\n-                                                           ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(ccx,\n-                                              it.id,\n-                                              fn_style,\n-                                              abi,\n-                                              &**decl);\n+            let ty_generics = ty_generics_for_fn_or_method(\n+                ccx,\n+                generics,\n+                ty::Generics::empty(),\n+                CreateTypeParametersForAssociatedTypes);\n+            let tofd = {\n+                let fcx = FnCtxt {\n+                    ccx: ccx,\n+                    generics: &ty_generics,\n+                };\n+                astconv::ty_of_bare_fn(&fcx,\n+                                       it.id,\n+                                       fn_style,\n+                                       abi,\n+                                       &**decl)\n+            };\n             let pty = Polytype {\n                 generics: ty_generics,\n                 ty: ty::mk_bare_fn(ccx.tcx, tofd)\n             };\n             debug!(\"type of {} (id {}) is {}\",\n                     token::get_ident(it.ident),\n                     it.id,\n-                    ppaux::ty_to_string(tcx, pty.ty));\n+                    pty.repr(tcx));\n \n             ccx.tcx.tcache.borrow_mut().insert(local_def(it.id), pty.clone());\n             return pty;\n@@ -944,7 +1594,10 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             let pty = {\n                 let ty = ccx.to_ty(&ExplicitRscope, &**t);\n                 Polytype {\n-                    generics: ty_generics_for_type(ccx, generics),\n+                    generics: ty_generics_for_type(\n+                                  ccx,\n+                                  generics,\n+                                  DontCreateTypeParametersForAssociatedTypes),\n                     ty: ty\n                 }\n             };\n@@ -954,7 +1607,10 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n         }\n         ast::ItemEnum(_, ref generics) => {\n             // Create a new generic polytype.\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n+            let ty_generics = ty_generics_for_type(\n+                ccx,\n+                generics,\n+                DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_enum(tcx, local_def(it.id), substs);\n             let pty = Polytype {\n@@ -969,7 +1625,10 @@ pub fn ty_of_item(ccx: &CrateCtxt, it: &ast::Item)\n             tcx.sess.span_bug(it.span, \"invoked ty_of_item on trait\");\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            let ty_generics = ty_generics_for_type(ccx, generics);\n+            let ty_generics = ty_generics_for_type(\n+                ccx,\n+                generics,\n+                DontCreateTypeParametersForAssociatedTypes);\n             let substs = mk_item_substs(ccx, &ty_generics);\n             let t = ty::mk_struct(tcx, local_def(it.id), substs);\n             let pty = Polytype {\n@@ -1006,30 +1665,88 @@ pub fn ty_of_foreign_item(ccx: &CrateCtxt,\n     }\n }\n \n+fn ty_of_trait_item(ccx: &CrateCtxt, trait_item: &ast::TraitItem)\n+                    -> ty::Polytype {\n+    match *trait_item {\n+        ast::RequiredMethod(ref m) => {\n+            ccx.tcx.sess.span_bug(m.span,\n+                                  \"ty_of_trait_item() on required method\")\n+        }\n+        ast::ProvidedMethod(ref m) => {\n+            ccx.tcx.sess.span_bug(m.span,\n+                                  \"ty_of_trait_item() on provided method\")\n+        }\n+        ast::TypeTraitItem(ref associated_type) => {\n+            let parent = ccx.tcx.map.get_parent(associated_type.id);\n+            let trait_def = match ccx.tcx.map.get(parent) {\n+                ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n+                _ => {\n+                    ccx.tcx.sess.span_bug(associated_type.span,\n+                                          \"associated type's parent wasn't \\\n+                                           an item?!\")\n+                }\n+            };\n+            convert_associated_type(ccx, &*trait_def, &**associated_type)\n+        }\n+    }\n+}\n+\n fn ty_generics_for_type(ccx: &CrateCtxt,\n-                        generics: &ast::Generics)\n-                        -> ty::Generics\n-{\n+                        generics: &ast::Generics,\n+                        create_type_parameters_for_associated_types:\n+                            CreateTypeParametersForAssociatedTypesFlag)\n+                        -> ty::Generics {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n                 generics.lifetimes.as_slice(),\n                 generics.ty_params.as_slice(),\n                 ty::Generics::empty(),\n-                &generics.where_clause)\n+                &generics.where_clause,\n+                create_type_parameters_for_associated_types)\n }\n \n fn ty_generics_for_trait(ccx: &CrateCtxt,\n                          trait_id: ast::NodeId,\n                          substs: &subst::Substs,\n-                         generics: &ast::Generics)\n+                         generics: &ast::Generics,\n+                         items: &[ast::TraitItem])\n                          -> ty::Generics {\n-    let mut generics = ty_generics(ccx,\n-                                   subst::TypeSpace,\n-                                   generics.lifetimes.as_slice(),\n-                                   generics.ty_params.as_slice(),\n-                                   ty::Generics::empty(),\n-                                   &generics.where_clause);\n+    let mut generics =\n+        ty_generics(ccx,\n+                    subst::TypeSpace,\n+                    generics.lifetimes.as_slice(),\n+                    generics.ty_params.as_slice(),\n+                    ty::Generics::empty(),\n+                    &generics.where_clause,\n+                    DontCreateTypeParametersForAssociatedTypes);\n+\n+    // Add in type parameters for any associated types.\n+    for item in items.iter() {\n+        match *item {\n+            ast::TypeTraitItem(ref associated_type) => {\n+                let def = ty::TypeParameterDef {\n+                    space: subst::TypeSpace,\n+                    index: generics.types.len(subst::TypeSpace),\n+                    ident: associated_type.ident,\n+                    def_id: local_def(associated_type.id),\n+                    bounds: ty::ParamBounds {\n+                        builtin_bounds: ty::empty_builtin_bounds(),\n+                        trait_bounds: Vec::new(),\n+                        region_bounds: Vec::new(),\n+                    },\n+                    associated_with: Some(local_def(trait_id)),\n+                    default: None,\n+                };\n+                ccx.tcx.ty_param_defs.borrow_mut().insert(associated_type.id,\n+                                                          def.clone());\n+                generics.types.push(subst::TypeSpace, def);\n+            }\n+            ast::ProvidedMethod(_) | ast::RequiredMethod(_) => {}\n+        }\n+    }\n \n+    // Add in the self type parameter.\n+    //\n     // Something of a hack: use the node id for the trait, also as\n     // the node id for the Self type parameter.\n     let param_id = trait_id;\n@@ -1048,6 +1765,7 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n             builtin_bounds: ty::empty_builtin_bounds(),\n             trait_bounds: vec!(self_trait_ref),\n         },\n+        associated_with: None,\n         default: None\n     };\n \n@@ -1058,70 +1776,153 @@ fn ty_generics_for_trait(ccx: &CrateCtxt,\n     generics\n }\n \n-fn ty_generics_for_fn_or_method(ccx: &CrateCtxt,\n-                                generics: &ast::Generics,\n-                                base_generics: ty::Generics)\n-                                -> ty::Generics {\n+fn ty_generics_for_fn_or_method<'tcx,AC>(\n+        this: &AC,\n+        generics: &ast::Generics,\n+        base_generics: ty::Generics,\n+        create_type_parameters_for_associated_types:\n+        CreateTypeParametersForAssociatedTypesFlag)\n+        -> ty::Generics\n+        where AC: AstConv<'tcx> {\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(ccx,\n+    ty_generics(this,\n                 subst::FnSpace,\n                 early_lifetimes.as_slice(),\n                 generics.ty_params.as_slice(),\n                 base_generics,\n-                &generics.where_clause)\n+                &generics.where_clause,\n+                create_type_parameters_for_associated_types)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `Sized?`.\n-fn add_unsized_bound(ccx: &CrateCtxt,\n-                     unbound: &Option<ast::TyParamBound>,\n-                     bounds: &mut ty::BuiltinBounds,\n-                     desc: &str,\n-                     span: Span) {\n-    let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n-\n+fn add_unsized_bound<'tcx,AC>(this: &AC,\n+                              unbound: &Option<ast::TyParamBound>,\n+                              bounds: &mut ty::BuiltinBounds,\n+                              desc: &str,\n+                              span: Span)\n+                              where AC: AstConv<'tcx> {\n+    let kind_id = this.tcx().lang_items.require(SizedTraitLangItem);\n     match unbound {\n         &Some(ast::TraitTyParamBound(ref tpb)) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n+            let trait_def_id = ty::trait_ref_to_def_id(this.tcx(), tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n-                    ccx.tcx.sess.span_warn(span,\n-                                           format!(\"default bound relaxed \\\n-                                                    for a {}, but this does \\\n-                                                    nothing because the given \\\n-                                                    bound is not a default. \\\n-                                                    Only `Sized?` is supported.\",\n-                                                   desc).as_slice());\n-                    ty::try_add_builtin_trait(ccx.tcx,\n+                    this.tcx().sess.span_warn(span,\n+                                              format!(\"default bound relaxed \\\n+                                                       for a {}, but this \\\n+                                                       does nothing because \\\n+                                                       the given bound is not \\\n+                                                       a default. \\\n+                                                       Only `Sized?` is \\\n+                                                       supported.\",\n+                                                      desc).as_slice());\n+                    ty::try_add_builtin_trait(this.tcx(),\n                                               kind_id,\n                                               bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(ccx.tcx,\n-                                      kind_id.unwrap(),\n-                                      bounds);\n+            ty::try_add_builtin_trait(this.tcx(), kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         _ => {}\n     }\n }\n \n-fn ty_generics(ccx: &CrateCtxt,\n-               space: subst::ParamSpace,\n-               lifetime_defs: &[ast::LifetimeDef],\n-               types: &[ast::TyParam],\n-               base_generics: ty::Generics,\n-               where_clause: &ast::WhereClause)\n-               -> ty::Generics\n-{\n+#[deriving(Clone, PartialEq, Eq)]\n+enum CreateTypeParametersForAssociatedTypesFlag {\n+    DontCreateTypeParametersForAssociatedTypes,\n+    CreateTypeParametersForAssociatedTypes,\n+}\n+\n+fn ensure_associated_types<'tcx,AC>(this: &AC, trait_id: ast::DefId)\n+                                    where AC: AstConv<'tcx> {\n+    if this.tcx().trait_associated_types.borrow().contains_key(&trait_id) {\n+        return\n+    }\n+\n+    if trait_id.krate == ast::LOCAL_CRATE {\n+        match this.tcx().map.find(trait_id.node) {\n+            Some(ast_map::NodeItem(item)) => {\n+                match item.node {\n+                    ast::ItemTrait(_, _, _, ref trait_items) => {\n+                        let mut result = Vec::new();\n+                        let mut index = 0;\n+                        for trait_item in trait_items.iter() {\n+                            match *trait_item {\n+                                ast::RequiredMethod(_) |\n+                                ast::ProvidedMethod(_) => {}\n+                                ast::TypeTraitItem(ref associated_type) => {\n+                                    let info = ty::AssociatedTypeInfo {\n+                                        def_id: local_def(associated_type.id),\n+                                        index: index,\n+                                        ident: associated_type.ident,\n+                                    };\n+                                    result.push(info);\n+                                    index += 1;\n+                                }\n+                            }\n+                        }\n+                        this.tcx()\n+                            .trait_associated_types\n+                            .borrow_mut()\n+                            .insert(trait_id, Rc::new(result));\n+                        return\n+                    }\n+                    _ => {\n+                        this.tcx().sess.bug(\"ensure_associated_types() \\\n+                                             called on non-trait\")\n+                    }\n+                }\n+            }\n+            _ => {\n+                this.tcx().sess.bug(\"ensure_associated_types() called on \\\n+                                     non-trait\")\n+            }\n+        }\n+\n+    }\n+\n+    // Cross-crate case.\n+    let mut result = Vec::new();\n+    let mut index = 0;\n+    let trait_items = ty::trait_items(this.tcx(), trait_id);\n+    for trait_item in trait_items.iter() {\n+        match *trait_item {\n+            ty::MethodTraitItem(_) => {}\n+            ty::TypeTraitItem(ref associated_type) => {\n+                let info = ty::AssociatedTypeInfo {\n+                    def_id: associated_type.def_id,\n+                    index: index,\n+                    ident: associated_type.ident\n+                };\n+                result.push(info);\n+                index += 1;\n+            }\n+        }\n+    }\n+    this.tcx().trait_associated_types.borrow_mut().insert(trait_id,\n+                                                          Rc::new(result));\n+}\n+\n+fn ty_generics<'tcx,AC>(this: &AC,\n+                        space: subst::ParamSpace,\n+                        lifetime_defs: &[ast::LifetimeDef],\n+                        types: &[ast::TyParam],\n+                        base_generics: ty::Generics,\n+                        where_clause: &ast::WhereClause,\n+                        create_type_parameters_for_associated_types:\n+                        CreateTypeParametersForAssociatedTypesFlag)\n+                        -> ty::Generics\n+                        where AC: AstConv<'tcx> {\n     let mut result = base_generics;\n \n     for (i, l) in lifetime_defs.iter().enumerate() {\n         let bounds = l.bounds.iter()\n-                             .map(|l| ast_region_to_region(ccx.tcx, l))\n+                             .map(|l| ast_region_to_region(this.tcx(), l))\n                              .collect();\n         let def = ty::RegionParameterDef { name: l.lifetime.name,\n                                            space: space,\n@@ -1132,102 +1933,194 @@ fn ty_generics(ccx: &CrateCtxt,\n         result.regions.push(space, def);\n     }\n \n+    assert!(result.types.is_empty_in(space));\n+\n+    // First, create the virtual type parameters for associated types if\n+    // necessary.\n+    let mut associated_types_generics = ty::Generics::empty();\n+    match create_type_parameters_for_associated_types {\n+        DontCreateTypeParametersForAssociatedTypes => {}\n+        CreateTypeParametersForAssociatedTypes => {\n+            let mut index = 0;\n+            for param in types.iter() {\n+                for bound in param.bounds.iter() {\n+                    match *bound {\n+                        ast::TraitTyParamBound(ref trait_bound) => {\n+                            match lookup_def_tcx(this.tcx(),\n+                                                 trait_bound.path.span,\n+                                                 trait_bound.ref_id) {\n+                                def::DefTrait(trait_did) => {\n+                                    ensure_associated_types(this, trait_did);\n+                                    let associated_types =\n+                                        ty::associated_types_for_trait(\n+                                            this.tcx(),\n+                                            trait_did);\n+                                    for associated_type_info in\n+                                            associated_types.iter() {\n+                                        let associated_type_trait_item =\n+                                            ty::impl_or_trait_item(\n+                                                this.tcx(),\n+                                                associated_type_info.def_id);\n+                                        let def = ty::TypeParameterDef {\n+                                            ident: associated_type_trait_item\n+                                                       .ident(),\n+                                            def_id:\n+                                                associated_type_info.def_id,\n+                                            space: space,\n+                                            index: types.len() + index,\n+                                            bounds: ty::ParamBounds {\n+                                                builtin_bounds:\n+                                                ty::empty_builtin_bounds(),\n+                                                trait_bounds: Vec::new(),\n+                                                region_bounds: Vec::new(),\n+                                            },\n+                                            associated_with: {\n+                                                Some(local_def(param.id))\n+                                            },\n+                                            default: None,\n+                                        };\n+                                        associated_types_generics.types\n+                                                                 .push(space,\n+                                                                       def);\n+                                        index += 1;\n+                                    }\n+                                }\n+                                _ => {\n+                                    this.tcx().sess.span_bug(trait_bound.path\n+                                                                        .span,\n+                                                             \"not a trait?!\")\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    // Now create the real type parameters.\n+    let gcx = GenericsCtxt {\n+        chain: this,\n+        associated_types_generics: &associated_types_generics,\n+    };\n     for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx,\n+        let def = get_or_create_type_parameter_def(&gcx,\n                                                    space,\n                                                    param,\n                                                    i,\n                                                    where_clause);\n-        debug!(\"ty_generics: def for type param: {}\", def.repr(ccx.tcx));\n+        debug!(\"ty_generics: def for type param: {}, {}\",\n+               def.repr(this.tcx()),\n+               space);\n         result.types.push(space, def);\n     }\n \n+    // Append the associated types to the result.\n+    for associated_type_param in associated_types_generics.types\n+                                                          .get_slice(space)\n+                                                          .iter() {\n+        assert!(result.types.get_slice(space).len() ==\n+                associated_type_param.index);\n+        debug!(\"ty_generics: def for associated type: {}, {}\",\n+               associated_type_param.repr(this.tcx()),\n+               space);\n+        result.types.push(space, (*associated_type_param).clone());\n+    }\n+\n     return result;\n \n-    fn get_or_create_type_parameter_def(ccx: &CrateCtxt,\n+    fn get_or_create_type_parameter_def<'tcx,AC>(\n+                                        this: &AC,\n                                         space: subst::ParamSpace,\n                                         param: &ast::TyParam,\n                                         index: uint,\n                                         where_clause: &ast::WhereClause)\n-                                        -> ty::TypeParameterDef {\n-        match ccx.tcx.ty_param_defs.borrow().find(&param.id) {\n+                                        -> ty::TypeParameterDef\n+                                        where AC: AstConv<'tcx> {\n+        match this.tcx().ty_param_defs.borrow().find(&param.id) {\n             Some(d) => { return (*d).clone(); }\n             None => { }\n         }\n \n         let param_ty = ty::ParamTy::new(space, index, local_def(param.id));\n-        let bounds = compute_bounds(ccx,\n+        let bounds = compute_bounds(this,\n                                     param.ident.name,\n                                     param_ty,\n                                     param.bounds.as_slice(),\n                                     &param.unbound,\n                                     param.span,\n                                     where_clause);\n-            let default = param.default.as_ref().map(|path| {\n-            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n-            let cur_idx = index;\n-\n-            ty::walk_ty(ty, |t| {\n-                match ty::get(t).sty {\n-                    ty::ty_param(p) => if p.idx > cur_idx {\n-                    span_err!(ccx.tcx.sess, path.span, E0128,\n-                              \"type parameters with a default cannot use \\\n-                               forward declared identifiers\");\n-                    },\n-                    _ => {}\n-                }\n-            });\n+        let default = match param.default {\n+            None => None,\n+            Some(ref path) => {\n+                let ty = ast_ty_to_ty(this, &ExplicitRscope, &**path);\n+                let cur_idx = index;\n+\n+                ty::walk_ty(ty, |t| {\n+                    match ty::get(t).sty {\n+                        ty::ty_param(p) => if p.idx > cur_idx {\n+                        span_err!(this.tcx().sess, path.span, E0128,\n+                                  \"type parameters with a default cannot use \\\n+                                   forward declared identifiers\");\n+                        },\n+                        _ => {}\n+                    }\n+                });\n \n-            ty\n-        });\n+                Some(ty)\n+            }\n+        };\n \n         let def = ty::TypeParameterDef {\n             space: space,\n             index: index,\n             ident: param.ident,\n             def_id: local_def(param.id),\n+            associated_with: None,\n             bounds: bounds,\n             default: default\n         };\n \n-        ccx.tcx.ty_param_defs.borrow_mut().insert(param.id, def.clone());\n+        this.tcx().ty_param_defs.borrow_mut().insert(param.id, def.clone());\n \n         def\n     }\n }\n \n-fn compute_bounds(\n-    ccx: &CrateCtxt,\n-    name_of_bounded_thing: ast::Name,\n-    param_ty: ty::ParamTy,\n-    ast_bounds: &[ast::TyParamBound],\n-    unbound: &Option<ast::TyParamBound>,\n-    span: Span,\n-    where_clause: &ast::WhereClause)\n-    -> ty::ParamBounds\n-{\n+fn compute_bounds<'tcx,AC>(this: &AC,\n+                           name_of_bounded_thing: ast::Name,\n+                           param_ty: ty::ParamTy,\n+                           ast_bounds: &[ast::TyParamBound],\n+                           unbound: &Option<ast::TyParamBound>,\n+                           span: Span,\n+                           where_clause: &ast::WhereClause)\n+                           -> ty::ParamBounds\n+                           where AC: AstConv<'tcx> {\n     /*!\n      * Translate the AST's notion of ty param bounds (which are an\n      * enum consisting of a newtyped Ty or a region) to ty's\n      * notion of ty param bounds, which can either be user-defined\n      * traits, or the built-in trait (formerly known as kind): Send.\n      */\n \n-    let mut param_bounds = conv_param_bounds(ccx,\n+    let mut param_bounds = conv_param_bounds(this,\n                                              span,\n                                              param_ty,\n                                              ast_bounds,\n                                              where_clause);\n \n \n-    add_unsized_bound(ccx,\n+    add_unsized_bound(this,\n                       unbound,\n                       &mut param_bounds.builtin_bounds,\n                       \"type parameter\",\n                       span);\n \n-    check_bounds_compatible(ccx.tcx, name_of_bounded_thing,\n-                            &param_bounds, span);\n+    check_bounds_compatible(this.tcx(),\n+                            name_of_bounded_thing,\n+                            &param_bounds,\n+                            span);\n \n     param_bounds.trait_bounds.sort_by(|a,b| a.def_id.cmp(&b.def_id));\n \n@@ -1258,31 +2151,36 @@ fn check_bounds_compatible(tcx: &ty::ctxt,\n     }\n }\n \n-fn conv_param_bounds(ccx: &CrateCtxt,\n-                     span: Span,\n-                     param_ty: ty::ParamTy,\n-                     ast_bounds: &[ast::TyParamBound],\n-                     where_clause: &ast::WhereClause)\n-                     -> ty::ParamBounds\n-{\n+fn conv_param_bounds<'tcx,AC>(this: &AC,\n+                              span: Span,\n+                              param_ty: ty::ParamTy,\n+                              ast_bounds: &[ast::TyParamBound],\n+                              where_clause: &ast::WhereClause)\n+                              -> ty::ParamBounds\n+                              where AC: AstConv<'tcx> {\n     let all_bounds =\n-        merge_param_bounds(ccx, param_ty, ast_bounds, where_clause);\n+        merge_param_bounds(this.tcx(), param_ty, ast_bounds, where_clause);\n     let astconv::PartitionedBounds { builtin_bounds,\n                                      trait_bounds,\n                                      region_bounds,\n                                      unboxed_fn_ty_bounds } =\n-        astconv::partition_bounds(ccx.tcx, span, all_bounds.as_slice());\n+        astconv::partition_bounds(this.tcx(), span, all_bounds.as_slice());\n     let unboxed_fn_ty_bounds =\n         unboxed_fn_ty_bounds.into_iter()\n-        .map(|b| instantiate_unboxed_fn_ty(ccx, b, param_ty));\n+        .map(|b| instantiate_unboxed_fn_ty(this, b, param_ty));\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n-        .map(|b| instantiate_trait_ref(ccx, b, param_ty.to_ty(ccx.tcx)))\n+        .map(|b| {\n+            instantiate_trait_ref(this,\n+                                  b,\n+                                  param_ty.to_ty(this.tcx()),\n+                                  Some(param_ty.to_ty(this.tcx())))\n+        })\n         .chain(unboxed_fn_ty_bounds)\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n         region_bounds.move_iter()\n-        .map(|r| ast_region_to_region(ccx.tcx, r))\n+        .map(|r| ast_region_to_region(this.tcx(), r))\n         .collect();\n     ty::ParamBounds {\n         region_bounds: region_bounds,\n@@ -1291,12 +2189,11 @@ fn conv_param_bounds(ccx: &CrateCtxt,\n     }\n }\n \n-fn merge_param_bounds<'a>(ccx: &CrateCtxt,\n+fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n                           param_ty: ty::ParamTy,\n                           ast_bounds: &'a [ast::TyParamBound],\n                           where_clause: &'a ast::WhereClause)\n-                          -> Vec<&'a ast::TyParamBound>\n-{\n+                          -> Vec<&'a ast::TyParamBound> {\n     /*!\n      * Merges the bounds declared on a type parameter with those\n      * found from where clauses into a single list.\n@@ -1309,15 +2206,13 @@ fn merge_param_bounds<'a>(ccx: &CrateCtxt,\n     }\n \n     for predicate in where_clause.predicates.iter() {\n-        let predicate_param_id = ccx.tcx\n-            .def_map\n-            .borrow()\n-            .find(&predicate.id)\n-            .expect(\"compute_bounds(): resolve \\\n-                     didn't resolve the type \\\n-                     parameter identifier in a \\\n-                     `where` clause\")\n-            .def_id();\n+        let predicate_param_id =\n+            tcx.def_map\n+               .borrow()\n+               .find(&predicate.id)\n+               .expect(\"compute_bounds(): resolve didn't resolve the type \\\n+                        parameter identifier in a `where` clause\")\n+               .def_id();\n         if param_ty.def_id != predicate_param_id {\n             continue\n         }\n@@ -1334,8 +2229,7 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n                              def_id: ast::DefId,\n                              ast_generics: &ast::Generics,\n                              abi: abi::Abi)\n-                          -> ty::Polytype {\n-\n+                             -> ty::Polytype {\n     for i in decl.inputs.iter() {\n         match (*i).pat.node {\n             ast::PatIdent(_, _, _) => (),\n@@ -1347,9 +2241,11 @@ pub fn ty_of_foreign_fn_decl(ccx: &CrateCtxt,\n         }\n     }\n \n-    let ty_generics_for_fn_or_method =\n-        ty_generics_for_fn_or_method(ccx, ast_generics,\n-                                     ty::Generics::empty());\n+    let ty_generics_for_fn_or_method = ty_generics_for_fn_or_method(\n+            ccx,\n+            ast_generics,\n+            ty::Generics::empty(),\n+            DontCreateTypeParametersForAssociatedTypes);\n     let rb = BindingRscope::new(def_id.node);\n     let input_tys = decl.inputs\n                         .iter()"}, {"sha": "6ea80a59230ad7244982519da067ba24d8852854", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -871,6 +871,7 @@ impl<'a, 'tcx> ErrorReporting for InferCtxt<'a, 'tcx> {\n                                   Some(&m.pe_explicit_self().node),\n                                   m.span))\n                         }\n+                        ast::TypeImplItem(_) => None,\n                     }\n                 },\n                 _ => None\n@@ -1687,6 +1688,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n                         taken.push_all(m.pe_generics().lifetimes.as_slice());\n                         Some(m.id)\n                     }\n+                    ast::TypeImplItem(_) => None,\n                 }\n             }\n             _ => None"}, {"sha": "a6edfcf80fdac9bdef45dd8c8285bde2bc724f85", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -522,6 +522,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                             self.add_constraints_from_sig(&method.fty.sig,\n                                                           self.covariant);\n                         }\n+                        ty::TypeTraitItem(_) => {}\n                     }\n                 }\n             }"}, {"sha": "2083aa52bec6c7b9c60d77a1fb112c76326dff10", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -603,9 +603,11 @@ impl Repr for def::Def {\n \n impl Repr for ty::TypeParameterDef {\n     fn repr(&self, tcx: &ctxt) -> String {\n-        format!(\"TypeParameterDef({}, {})\",\n-                self.def_id.repr(tcx),\n-                self.bounds.repr(tcx))\n+        format!(\"TypeParameterDef({}, {}, {}/{})\",\n+                self.def_id,\n+                self.bounds.repr(tcx),\n+                self.space,\n+                self.index)\n     }\n }\n "}, {"sha": "1a324e25472cf186a20f1638f4734c4fb22221e1", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -316,6 +316,10 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                 };\n                 Some(item)\n             }\n+            ty::TypeTraitItem(_) => {\n+                // FIXME(pcwalton): Implement.\n+                None\n+            }\n         }\n     }).collect();\n     return Some(clean::Item {"}, {"sha": "9e05382fa556b123e8f43dea370bca32d6dad598", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -17,7 +17,7 @@ use syntax::ast_util;\n use syntax::ast_util::PostExpansionMethod;\n use syntax::attr;\n use syntax::attr::{AttributeMethods, AttrMetaMethods};\n-use syntax::codemap::Pos;\n+use syntax::codemap::{DUMMY_SP, Pos};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use syntax::ptr::P;\n@@ -317,6 +317,7 @@ pub enum ItemEnum {\n     ForeignStaticItem(Static),\n     MacroItem(Macro),\n     PrimitiveItem(Primitive),\n+    AssociatedTypeItem,\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n@@ -933,6 +934,7 @@ impl Clean<Type> for ast::TraitRef {\n pub enum TraitItem {\n     RequiredMethod(Item),\n     ProvidedMethod(Item),\n+    TypeTraitItem(Item),\n }\n \n impl TraitItem {\n@@ -952,6 +954,7 @@ impl TraitItem {\n         match *self {\n             RequiredMethod(ref item) => item,\n             ProvidedMethod(ref item) => item,\n+            TypeTraitItem(ref item) => item,\n         }\n     }\n }\n@@ -961,19 +964,22 @@ impl Clean<TraitItem> for ast::TraitItem {\n         match self {\n             &ast::RequiredMethod(ref t) => RequiredMethod(t.clean(cx)),\n             &ast::ProvidedMethod(ref t) => ProvidedMethod(t.clean(cx)),\n+            &ast::TypeTraitItem(ref t) => TypeTraitItem(t.clean(cx)),\n         }\n     }\n }\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ImplItem {\n     MethodImplItem(Item),\n+    TypeImplItem(Item),\n }\n \n impl Clean<ImplItem> for ast::ImplItem {\n     fn clean(&self, cx: &DocContext) -> ImplItem {\n         match self {\n             &ast::MethodImplItem(ref t) => MethodImplItem(t.clean(cx)),\n+            &ast::TypeImplItem(ref t) => TypeImplItem(t.clean(cx)),\n         }\n     }\n }\n@@ -1028,6 +1034,7 @@ impl Clean<Item> for ty::ImplOrTraitItem {\n     fn clean(&self, cx: &DocContext) -> Item {\n         match *self {\n             ty::MethodTraitItem(ref mti) => mti.clean(cx),\n+            ty::TypeTraitItem(ref tti) => tti.clean(cx),\n         }\n     }\n }\n@@ -1743,6 +1750,7 @@ impl Clean<Item> for doctree::Impl {\n                 items: self.items.clean(cx).into_iter().map(|ti| {\n                         match ti {\n                             MethodImplItem(i) => i,\n+                            TypeImplItem(i) => i,\n                         }\n                     }).collect(),\n                 derived: detect_derived(self.attrs.as_slice()),\n@@ -2125,6 +2133,54 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n+impl Clean<Item> for ast::AssociatedType {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: self.span.clean(cx),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            inner: AssociatedTypeItem,\n+            visibility: None,\n+            def_id: ast_util::local_def(self.id),\n+            stability: None,\n+        }\n+    }\n+}\n+\n+impl Clean<Item> for ty::AssociatedType {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: DUMMY_SP.clean(cx),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: Vec::new(),\n+            inner: AssociatedTypeItem,\n+            visibility: None,\n+            def_id: self.def_id,\n+            stability: None,\n+        }\n+    }\n+}\n+\n+impl Clean<Item> for ast::Typedef {\n+    fn clean(&self, cx: &DocContext) -> Item {\n+        Item {\n+            source: self.span.clean(cx),\n+            name: Some(self.ident.clean(cx)),\n+            attrs: self.attrs.clean(cx),\n+            inner: TypedefItem(Typedef {\n+                type_: self.typ.clean(cx),\n+                generics: Generics {\n+                    lifetimes: Vec::new(),\n+                    type_params: Vec::new(),\n+                },\n+            }),\n+            visibility: None,\n+            def_id: ast_util::local_def(self.id),\n+            stability: None,\n+        }\n+    }\n+}\n+\n fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n                t: ty::t, name: &str,\n                fallback: fn(Box<Type>) -> Type) -> Type {"}, {"sha": "54e9c29e11df0b59ca47aced1c31b3535a348aae", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -55,6 +55,12 @@ pub trait DocFolder {\n                                 None => return None,\n                             }\n                         },\n+                        TypeTraitItem(it) => {\n+                            match this.fold_item(it) {\n+                                Some(x) => return Some(TypeTraitItem(x)),\n+                                None => return None,\n+                            }\n+                        }\n                     }\n                 }\n                 let mut foo = Vec::new(); swap(&mut foo, &mut i.items);"}, {"sha": "e18ab0bd14f59802ca56f3c1f1b287792afe1d7b", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -38,6 +38,7 @@ pub enum ItemType {\n     ForeignStatic   = 14,\n     Macro           = 15,\n     Primitive       = 16,\n+    AssociatedType  = 17,\n }\n \n impl ItemType {\n@@ -60,6 +61,7 @@ impl ItemType {\n             ForeignStatic   => \"ffs\",\n             Macro           => \"macro\",\n             Primitive       => \"primitive\",\n+            AssociatedType  => \"associatedtype\",\n         }\n     }\n }\n@@ -95,6 +97,7 @@ pub fn shortty(item: &clean::Item) -> ItemType {\n         clean::ForeignStaticItem(..)   => ForeignStatic,\n         clean::MacroItem(..)           => Macro,\n         clean::PrimitiveItem(..)       => Primitive,\n+        clean::AssociatedTypeItem      => AssociatedType,\n     }\n }\n "}, {"sha": "2107854c52b95d9a8d74b43a4fb92d1890e58ec2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -1512,6 +1512,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 clean::ForeignStaticItem(..)   => (\"ffi-statics\", \"Foreign Statics\"),\n                 clean::MacroItem(..)           => (\"macros\", \"Macros\"),\n                 clean::PrimitiveItem(..)       => (\"primitives\", \"Primitive Types\"),\n+                clean::AssociatedTypeItem(..)  => (\"associated-types\", \"Associated Types\"),\n             };\n             try!(write!(w,\n                         \"<h2 id='{id}' class='section-header'>\\"}, {"sha": "33337594b4c67c161cc7bb8f43f9d3433853f2bb", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -175,6 +175,9 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n \n             // Primitives are never stripped\n             clean::PrimitiveItem(..) => {}\n+\n+            // Associated types are never stripped\n+            clean::AssociatedTypeItem(..) => {}\n         }\n \n         let fastreturn = match i.inner {"}, {"sha": "02dc4e9bdb6227d400dcfcc123f32063e049ca23", "filename": "src/librustdoc/stability_summary.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -22,7 +22,7 @@ use syntax::ast::Public;\n \n use clean::{Crate, Item, ModuleItem, Module, StructItem, Struct, EnumItem, Enum};\n use clean::{ImplItem, Impl, Trait, TraitItem, ProvidedMethod, RequiredMethod};\n-use clean::{ViewItemItem, PrimitiveItem};\n+use clean::{TypeTraitItem, ViewItemItem, PrimitiveItem};\n \n #[deriving(Zero, Encodable, Decodable, PartialEq, Eq)]\n /// The counts for each stability level.\n@@ -131,7 +131,8 @@ fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n             fn extract_item<'a>(trait_item: &'a TraitItem) -> &'a Item {\n                 match *trait_item {\n                     ProvidedMethod(ref item) |\n-                    RequiredMethod(ref item) => item\n+                    RequiredMethod(ref item) |\n+                    TypeTraitItem(ref item) => item\n                 }\n             }\n             let subcounts = trait_items.iter()"}, {"sha": "eac158e664c264d6ccda00bef69c2f79f56d8959", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -555,6 +555,18 @@ pub enum Expr_ {\n     ExprParen(P<Expr>)\n }\n \n+/// A \"qualified path\":\n+///\n+///     <Vec<T> as SomeTrait>::SomeAssociatedItem\n+///      ^~~~~     ^~~~~~~~~   ^~~~~~~~~~~~~~~~~~\n+///      for_type  trait_name  item_name\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct QPath {\n+    pub for_type: P<Ty>,\n+    pub trait_name: Path,\n+    pub item_name: Ident,\n+}\n+\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum CaptureClause {\n     CaptureByValue,\n@@ -766,11 +778,31 @@ pub struct TypeMethod {\n pub enum TraitItem {\n     RequiredMethod(TypeMethod),\n     ProvidedMethod(P<Method>),\n+    TypeTraitItem(P<AssociatedType>),\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub enum ImplItem {\n     MethodImplItem(P<Method>),\n+    TypeImplItem(P<Typedef>),\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct AssociatedType {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub attrs: Vec<Attribute>,\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct Typedef {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub ident: Ident,\n+    pub vis: Visibility,\n+    pub attrs: Vec<Attribute>,\n+    pub typ: P<Ty>,\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n@@ -917,6 +949,8 @@ pub enum Ty_ {\n     TyUnboxedFn(P<UnboxedFnTy>),\n     TyTup(Vec<P<Ty>> ),\n     TyPath(Path, Option<TyParamBounds>, NodeId), // for #7264; see above\n+    /// A \"qualified path\", e.g. `<Vec<T> as SomeTrait>::SomeType`\n+    TyQPath(P<QPath>),\n     /// No-op; kept solely so that we can pretty-print faithfully\n     TyParen(P<Ty>),\n     TyTypeof(P<Expr>),"}, {"sha": "8280f34615fc2406051478c3a8e4c578e641381d", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -207,6 +207,9 @@ impl<'a> FnLikeNode<'a> {\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => method(&**m),\n+                    ast::TypeImplItem(_) => {\n+                        fail!(\"impl method FnLikeNode that is not fn-like\")\n+                    }\n                 }\n             }\n             ast_map::NodeExpr(e) => match e.node {"}, {"sha": "a5458461a8b2562bb9975719491d623a686109b3", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 81, "deletions": 27, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -11,11 +11,11 @@\n use abi;\n use ast::*;\n use ast_util;\n-use ast_util::PostExpansionMethod;\n use codemap::{DUMMY_SP, Span, Spanned};\n use fold::Folder;\n use parse::token;\n use print::pprust;\n+use ptr::P;\n use visit::{mod, Visitor};\n \n use arena::TypedArena;\n@@ -391,16 +391,20 @@ impl<'ast> Map<'ast> {\n                             }\n                         }\n                     }\n+                    TypeImplItem(ref t) => PathName(t.ident.name),\n                 }\n             },\n             NodeTraitItem(tm) => match *tm {\n                 RequiredMethod(ref m) => PathName(m.ident.name),\n-                ProvidedMethod(ref m) => match m.node {\n-                    MethDecl(ident, _, _, _, _, _, _, _) => {\n-                        PathName(ident.name)\n+                ProvidedMethod(ref m) => {\n+                    match m.node {\n+                        MethDecl(ident, _, _, _, _, _, _, _) => {\n+                            PathName(ident.name)\n+                        }\n+                        MethMac(_) => fail!(\"no path elem for {:?}\", node),\n                     }\n-                    MethMac(_) => fail!(\"no path elem for {:?}\", node),\n                 }\n+                TypeTraitItem(ref m) => PathName(m.ident.name),\n             },\n             NodeVariant(v) => PathName(v.node.name.name),\n             _ => fail!(\"no path elem for {:?}\", node)\n@@ -459,11 +463,13 @@ impl<'ast> Map<'ast> {\n             NodeForeignItem(fi) => Some(fi.attrs.as_slice()),\n             NodeTraitItem(ref tm) => match **tm {\n                 RequiredMethod(ref type_m) => Some(type_m.attrs.as_slice()),\n-                ProvidedMethod(ref m) => Some(m.attrs.as_slice())\n+                ProvidedMethod(ref m) => Some(m.attrs.as_slice()),\n+                TypeTraitItem(ref typ) => Some(typ.attrs.as_slice()),\n             },\n             NodeImplItem(ref ii) => {\n                 match **ii {\n                     MethodImplItem(ref m) => Some(m.attrs.as_slice()),\n+                    TypeImplItem(ref t) => Some(t.attrs.as_slice()),\n                 }\n             }\n             NodeVariant(ref v) => Some(v.node.attrs.as_slice()),\n@@ -503,11 +509,13 @@ impl<'ast> Map<'ast> {\n                 match *trait_method {\n                     RequiredMethod(ref type_method) => type_method.span,\n                     ProvidedMethod(ref method) => method.span,\n+                    TypeTraitItem(ref typedef) => typedef.span,\n                 }\n             }\n             Some(NodeImplItem(ref impl_item)) => {\n                 match **impl_item {\n                     MethodImplItem(ref method) => method.span,\n+                    TypeImplItem(ref typedef) => typedef.span,\n                 }\n             }\n             Some(NodeVariant(variant)) => variant.span,\n@@ -633,13 +641,15 @@ impl Named for TraitItem {\n         match *self {\n             RequiredMethod(ref tm) => tm.ident.name,\n             ProvidedMethod(ref m) => m.name(),\n+            TypeTraitItem(ref at) => at.ident.name,\n         }\n     }\n }\n impl Named for ImplItem {\n     fn name(&self) -> Name {\n         match *self {\n             MethodImplItem(ref m) => m.name(),\n+            TypeImplItem(ref td) => td.ident.name,\n         }\n     }\n }\n@@ -712,10 +722,14 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n         match i.node {\n             ItemImpl(_, _, _, ref impl_items) => {\n                 for impl_item in impl_items.iter() {\n-                    let id = match *impl_item {\n-                        MethodImplItem(ref m) => m.id\n-                    };\n-                    self.insert(id, NodeImplItem(impl_item));\n+                    match *impl_item {\n+                        MethodImplItem(ref m) => {\n+                            self.insert(m.id, NodeImplItem(impl_item));\n+                        }\n+                        TypeImplItem(ref t) => {\n+                            self.insert(t.id, NodeImplItem(impl_item));\n+                        }\n+                    }\n                 }\n             }\n             ItemEnum(ref enum_definition, _) => {\n@@ -737,13 +751,28 @@ impl<'ast> Visitor<'ast> for NodeCollector<'ast> {\n                     None => {}\n                 }\n             }\n-            ItemTrait(_, _, _, ref methods) => {\n-                for tm in methods.iter() {\n-                    let id = match *tm {\n-                        RequiredMethod(ref m) => m.id,\n-                        ProvidedMethod(ref m) => m.id\n-                    };\n-                    self.insert(id, NodeTraitItem(tm));\n+            ItemTrait(_, _, ref bounds, ref trait_items) => {\n+                for b in bounds.iter() {\n+                    match *b {\n+                        TraitTyParamBound(ref t) => {\n+                            self.insert(t.ref_id, NodeItem(i));\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+\n+                for tm in trait_items.iter() {\n+                    match *tm {\n+                        RequiredMethod(ref m) => {\n+                            self.insert(m.id, NodeTraitItem(tm));\n+                        }\n+                        ProvidedMethod(ref m) => {\n+                            self.insert(m.id, NodeTraitItem(tm));\n+                        }\n+                        TypeTraitItem(ref typ) => {\n+                            self.insert(typ.id, NodeTraitItem(tm));\n+                        }\n+                    }\n                 }\n             }\n             _ => {}\n@@ -892,13 +921,22 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                 IITraitItem(fld.fold_ops.new_def_id(d),\n                             RequiredMethod(fld.fold_type_method(ty_m)))\n             }\n+            TypeTraitItem(at) => {\n+                IITraitItem(\n+                    fld.fold_ops.new_def_id(d),\n+                    TypeTraitItem(P(fld.fold_associated_type((*at).clone()))))\n+            }\n         },\n         IIImplItem(d, m) => match m {\n             MethodImplItem(m) => {\n                 IIImplItem(fld.fold_ops.new_def_id(d),\n                            MethodImplItem(fld.fold_method(m)\n                                              .expect_one(\"expected one method\")))\n             }\n+            TypeImplItem(t) => {\n+                IIImplItem(fld.fold_ops.new_def_id(d),\n+                           TypeImplItem(P(fld.fold_typedef((*t).clone()))))\n+            }\n         },\n         IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n     };\n@@ -924,14 +962,16 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         IITraitItem(_, ref trait_item) => {\n             let trait_item_id = match *trait_item {\n                 ProvidedMethod(ref m) => m.id,\n-                RequiredMethod(ref m) => m.id\n+                RequiredMethod(ref m) => m.id,\n+                TypeTraitItem(ref ty) => ty.id,\n             };\n \n             collector.insert(trait_item_id, NodeTraitItem(trait_item));\n         }\n         IIImplItem(_, ref impl_item) => {\n             let impl_item_id = match *impl_item {\n-                MethodImplItem(ref m) => m.id\n+                MethodImplItem(ref m) => m.id,\n+                TypeImplItem(ref ti) => ti.id,\n             };\n \n             collector.insert(impl_item_id, NodeImplItem(impl_item));\n@@ -1007,16 +1047,30 @@ fn node_id_to_string(map: &Map, id: NodeId) -> String {\n                                     pprust::mac_to_string(mac), id)\n                     }\n                 }\n+                TypeImplItem(ref t) => {\n+                    format!(\"typedef {} in {} (id={})\",\n+                            token::get_ident(t.ident),\n+                            map.path_to_string(id),\n+                            id)\n+                }\n             }\n         }\n-        Some(NodeTraitItem(ref ti)) => {\n-            let ident = match **ti {\n-                ProvidedMethod(ref m) => m.pe_ident(),\n-                RequiredMethod(ref m) => m.ident\n-            };\n-            format!(\"method {} in {} (id={})\",\n-                    token::get_ident(ident),\n-                    map.path_to_string(id), id)\n+        Some(NodeTraitItem(ref tm)) => {\n+            match **tm {\n+                RequiredMethod(_) | ProvidedMethod(_) => {\n+                    let m = ast_util::trait_item_to_ty_method(&**tm);\n+                    format!(\"method {} in {} (id={})\",\n+                            token::get_ident(m.ident),\n+                            map.path_to_string(id),\n+                            id)\n+                }\n+                TypeTraitItem(ref t) => {\n+                    format!(\"type item {} in {} (id={})\",\n+                            token::get_ident(t.ident),\n+                            map.path_to_string(id),\n+                            id)\n+                }\n+            }\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {} (id={})\","}, {"sha": "6d61c851476c3f287c5e5134be636f26074f91ef", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -213,6 +213,62 @@ pub fn impl_pretty_name(trait_ref: &Option<TraitRef>, ty: &Ty) -> Ident {\n     token::gensym_ident(pretty.as_slice())\n }\n \n+pub fn trait_method_to_ty_method(method: &Method) -> TypeMethod {\n+    match method.node {\n+        MethDecl(ident,\n+                 ref generics,\n+                 abi,\n+                 ref explicit_self,\n+                 fn_style,\n+                 ref decl,\n+                 _,\n+                 vis) => {\n+            TypeMethod {\n+                ident: ident,\n+                attrs: method.attrs.clone(),\n+                fn_style: fn_style,\n+                decl: (*decl).clone(),\n+                generics: generics.clone(),\n+                explicit_self: (*explicit_self).clone(),\n+                id: method.id,\n+                span: method.span,\n+                vis: vis,\n+                abi: abi,\n+            }\n+        },\n+        MethMac(_) => fail!(\"expected non-macro method declaration\")\n+    }\n+}\n+\n+/// extract a TypeMethod from a TraitItem. if the TraitItem is\n+/// a default, pull out the useful fields to make a TypeMethod\n+//\n+// NB: to be used only after expansion is complete, and macros are gone.\n+pub fn trait_item_to_ty_method(method: &TraitItem) -> TypeMethod {\n+    match *method {\n+        RequiredMethod(ref m) => (*m).clone(),\n+        ProvidedMethod(ref m) => trait_method_to_ty_method(&**m),\n+        TypeTraitItem(_) => {\n+            fail!(\"trait_method_to_ty_method(): expected method but found \\\n+                   typedef\")\n+        }\n+    }\n+}\n+\n+pub fn split_trait_methods(trait_methods: &[TraitItem])\n+                           -> (Vec<TypeMethod>, Vec<P<Method>> ) {\n+    let mut reqd = Vec::new();\n+    let mut provd = Vec::new();\n+    for trt_method in trait_methods.iter() {\n+        match *trt_method {\n+            RequiredMethod(ref tm) => reqd.push((*tm).clone()),\n+            ProvidedMethod(ref m) => provd.push((*m).clone()),\n+            TypeTraitItem(_) => {}\n+        }\n+    };\n+    (reqd, provd)\n+}\n+\n pub fn struct_field_visibility(field: ast::StructField) -> Visibility {\n     match field.node.kind {\n         ast::NamedField(_, v) | ast::UnnamedField(v) => v\n@@ -471,6 +527,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         match *tm {\n             ast::RequiredMethod(ref m) => self.operation.visit_id(m.id),\n             ast::ProvidedMethod(ref m) => self.operation.visit_id(m.id),\n+            ast::TypeTraitItem(ref typ) => self.operation.visit_id(typ.id),\n         }\n         visit::walk_trait_item(self, tm);\n     }"}, {"sha": "3b250de87016569d5360995cb9261a0dbb72c163", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -235,13 +235,15 @@ fn view_item_in_cfg(cx: &mut Context, item: &ast::ViewItem) -> bool {\n fn trait_method_in_cfg(cx: &mut Context, meth: &ast::TraitItem) -> bool {\n     match *meth {\n         ast::RequiredMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n-        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice())\n+        ast::ProvidedMethod(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::TypeTraitItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n     }\n }\n \n fn impl_item_in_cfg(cx: &mut Context, impl_item: &ast::ImplItem) -> bool {\n     match *impl_item {\n         ast::MethodImplItem(ref meth) => (cx.in_cfg)(meth.attrs.as_slice()),\n+        ast::TypeImplItem(ref typ) => (cx.in_cfg)(typ.attrs.as_slice()),\n     }\n }\n "}, {"sha": "7a7dbc54c9ef940eda864006a669bca9a3243465", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -90,7 +90,10 @@ impl<'a> MacResult for ParserAnyMacro<'a> {\n             let mut parser = self.parser.borrow_mut();\n             match parser.token {\n                 EOF => break,\n-                _ => ret.push(parser.parse_method(None))\n+                _ => {\n+                    let attrs = parser.parse_outer_attributes();\n+                    ret.push(parser.parse_method(attrs, ast::Inherited))\n+                }\n             }\n         }\n         self.ensure_complete_parse(false);"}, {"sha": "5203ed0a07341e247986d97f3acb34f6a09745ed", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 25, "deletions": 1, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -68,6 +68,7 @@ static KNOWN_FEATURES: &'static [(&'static str, Status)] = &[\n     (\"import_shadowing\", Active),\n     (\"advanced_slice_patterns\", Active),\n     (\"tuple_indexing\", Active),\n+    (\"associated_types\", Active),\n \n     // if you change this list without updating src/doc/rust.md, cmr will be sad\n \n@@ -235,7 +236,7 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                 }\n             }\n \n-            ast::ItemImpl(..) => {\n+            ast::ItemImpl(_, _, _, ref items) => {\n                 if attr::contains_name(i.attrs.as_slice(),\n                                        \"unsafe_destructor\") {\n                     self.gate_feature(\"unsafe_destructor\",\n@@ -244,6 +245,18 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n                                        many unsafe patterns and may be \\\n                                        removed in the future\");\n                 }\n+\n+                for item in items.iter() {\n+                    match *item {\n+                        ast::MethodImplItem(_) => {}\n+                        ast::TypeImplItem(ref typedef) => {\n+                            self.gate_feature(\"associated_types\",\n+                                              typedef.span,\n+                                              \"associated types are \\\n+                                               experimental\")\n+                        }\n+                    }\n+                }\n             }\n \n             _ => {}\n@@ -252,6 +265,17 @@ impl<'a, 'v> Visitor<'v> for Context<'a> {\n         visit::walk_item(self, i);\n     }\n \n+    fn visit_trait_item(&mut self, trait_item: &ast::TraitItem) {\n+        match *trait_item {\n+            ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n+            ast::TypeTraitItem(ref ti) => {\n+                self.gate_feature(\"associated_types\",\n+                                  ti.span,\n+                                  \"associated types are experimental\")\n+            }\n+        }\n+    }\n+\n     fn visit_mac(&mut self, macro: &ast::Mac) {\n         let ast::MacInvocTT(ref path, _, _) = macro.node;\n         let id = path.segments.last().unwrap().identifier;"}, {"sha": "3beba5bcda4b2441f4bc289c449d1a5c1415d445", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 114, "deletions": 21, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -287,6 +287,15 @@ pub trait Folder {\n         noop_fold_where_predicate(where_predicate, self)\n     }\n \n+    fn fold_typedef(&mut self, typedef: Typedef) -> Typedef {\n+        noop_fold_typedef(typedef, self)\n+    }\n+\n+    fn fold_associated_type(&mut self, associated_type: AssociatedType)\n+                            -> AssociatedType {\n+        noop_fold_associated_type(associated_type, self)\n+    }\n+\n     fn new_id(&mut self, i: NodeId) -> NodeId {\n         i\n     }\n@@ -414,6 +423,13 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n                         fld.fold_opt_bounds(bounds),\n                         id)\n             }\n+            TyQPath(ref qpath) => {\n+                TyQPath(P(QPath {\n+                    for_type: fld.fold_ty(qpath.for_type.clone()),\n+                    trait_name: fld.fold_path(qpath.trait_name.clone()),\n+                    item_name: fld.fold_ident(qpath.item_name.clone()),\n+                }))\n+            }\n             TyFixedLengthVec(ty, e) => {\n                 TyFixedLengthVec(fld.fold_ty(ty), fld.fold_expr(e))\n             }\n@@ -735,6 +751,44 @@ pub fn noop_fold_where_predicate<T: Folder>(\n     }\n }\n \n+pub fn noop_fold_typedef<T>(t: Typedef, folder: &mut T)\n+                            -> Typedef\n+                            where T: Folder {\n+    let new_id = folder.new_id(t.id);\n+    let new_span = folder.new_span(t.span);\n+    let new_attrs = t.attrs.iter().map(|attr| {\n+        folder.fold_attribute((*attr).clone())\n+    }).collect();\n+    let new_ident = folder.fold_ident(t.ident);\n+    let new_type = folder.fold_ty(t.typ);\n+    ast::Typedef {\n+        ident: new_ident,\n+        typ: new_type,\n+        id: new_id,\n+        span: new_span,\n+        vis: t.vis,\n+        attrs: new_attrs,\n+    }\n+}\n+\n+pub fn noop_fold_associated_type<T>(at: AssociatedType, folder: &mut T)\n+                                    -> AssociatedType\n+                                    where T: Folder {\n+    let new_id = folder.new_id(at.id);\n+    let new_span = folder.new_span(at.span);\n+    let new_ident = folder.fold_ident(at.ident);\n+    let new_attrs = at.attrs\n+                      .iter()\n+                      .map(|attr| folder.fold_attribute((*attr).clone()))\n+                      .collect();\n+    ast::AssociatedType {\n+        ident: new_ident,\n+        attrs: new_attrs,\n+        id: new_id,\n+        span: new_span,\n+    }\n+}\n+\n pub fn noop_fold_struct_def<T: Folder>(struct_def: P<StructDef>, fld: &mut T) -> P<StructDef> {\n     struct_def.map(|StructDef {fields, ctor_id, super_struct, is_virtual}| StructDef {\n         fields: fields.move_map(|f| fld.fold_struct_field(f)),\n@@ -857,31 +911,59 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n             ItemStruct(struct_def, folder.fold_generics(generics))\n         }\n         ItemImpl(generics, ifce, ty, impl_items) => {\n+            let mut new_impl_items = Vec::new();\n+            for impl_item in impl_items.iter() {\n+                match *impl_item {\n+                    MethodImplItem(ref x) => {\n+                        for method in folder.fold_method((*x).clone())\n+                                            .move_iter() {\n+                            new_impl_items.push(MethodImplItem(method))\n+                        }\n+                    }\n+                    TypeImplItem(ref t) => {\n+                        new_impl_items.push(TypeImplItem(\n+                                P(folder.fold_typedef((**t).clone()))));\n+                    }\n+                }\n+            }\n+            let ifce = match ifce {\n+                None => None,\n+                Some(ref trait_ref) => {\n+                    Some(folder.fold_trait_ref((*trait_ref).clone()))\n+                }\n+            };\n             ItemImpl(folder.fold_generics(generics),\n-                     ifce.map(|p| folder.fold_trait_ref(p)),\n+                     ifce,\n                      folder.fold_ty(ty),\n-                     impl_items.into_iter().flat_map(|impl_item| match impl_item {\n-                        MethodImplItem(x) => {\n-                            folder.fold_method(x).into_iter().map(|x| MethodImplItem(x))\n-                        }\n-                     }).collect())\n+                     new_impl_items)\n         }\n         ItemTrait(generics, unbound, bounds, methods) => {\n             let bounds = folder.fold_bounds(bounds);\n-            let methods = methods.into_iter().flat_map(|method| match method {\n-                RequiredMethod(m) => {\n-                    SmallVector::one(RequiredMethod(folder.fold_type_method(m))).into_iter()\n-                }\n-                ProvidedMethod(method) => {\n-                    // the awkward collect/iter idiom here is because\n-                    // even though an iter and a map satisfy the same trait bound,\n-                    // they're not actually the same type, so the method arms\n-                    // don't unify.\n-                    let methods: SmallVector<ast::TraitItem> =\n-                        folder.fold_method(method).into_iter()\n-                        .map(|m| ProvidedMethod(m)).collect();\n-                    methods.into_iter()\n-                }\n+            let methods = methods.into_iter().flat_map(|method| {\n+                let r = match method {\n+                    RequiredMethod(m) => {\n+                            SmallVector::one(RequiredMethod(\n+                                    folder.fold_type_method(m)))\n+                                .move_iter()\n+                    }\n+                    ProvidedMethod(method) => {\n+                        // the awkward collect/iter idiom here is because\n+                        // even though an iter and a map satisfy the same\n+                        // trait bound, they're not actually the same type, so\n+                        // the method arms don't unify.\n+                        let methods: SmallVector<ast::TraitItem> =\n+                            folder.fold_method(method).move_iter()\n+                            .map(|m| ProvidedMethod(m)).collect();\n+                        methods.move_iter()\n+                    }\n+                    TypeTraitItem(at) => {\n+                        SmallVector::one(TypeTraitItem(P(\n+                                    folder.fold_associated_type(\n+                                        (*at).clone()))))\n+                            .move_iter()\n+                    }\n+                };\n+                r\n             }).collect();\n             ItemTrait(folder.fold_generics(generics),\n                       unbound,\n@@ -893,7 +975,18 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n }\n \n pub fn noop_fold_type_method<T: Folder>(m: TypeMethod, fld: &mut T) -> TypeMethod {\n-    let TypeMethod {id, ident, attrs, fn_style, abi, decl, generics, explicit_self, vis, span} = m;\n+    let TypeMethod {\n+        id,\n+        ident,\n+        attrs,\n+        fn_style,\n+        abi,\n+        decl,\n+        generics,\n+        explicit_self,\n+        vis,\n+        span\n+    } = m;\n     TypeMethod {\n         id: fld.new_id(id),\n         ident: fld.fold_ident(ident),"}, {"sha": "ff4fd41fbd78fe6bace6029a2f8b1e2a1d67444b", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 150, "deletions": 94, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -11,11 +11,11 @@\n #![macro_escape]\n \n use abi;\n-use ast::{BareFnTy, ClosureTy};\n+use ast::{AssociatedType, BareFnTy, ClosureTy};\n use ast::{RegionTyParamBound, TraitTyParamBound};\n use ast::{ProvidedMethod, Public, FnStyle};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n-use ast::{BiBitAnd, BiBitOr, BiBitXor, Block};\n+use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, Block};\n use ast::{BlockCheckMode, UnBox};\n use ast::{CaptureByRef, CaptureByValue, CaptureClause};\n use ast::{Crate, CrateConfig, Decl, DeclItem};\n@@ -42,7 +42,7 @@ use ast::{MatchSeq, MatchTok, Method, MutTy, BiMul, Mutability};\n use ast::{MethodImplItem, NamedField, UnNeg, NoReturn, UnNot};\n use ast::{Pat, PatEnum, PatIdent, PatLit, PatRange, PatRegion, PatStruct};\n use ast::{PatTup, PatBox, PatWild, PatWildMulti, PatWildSingle};\n-use ast::{BiRem, RequiredMethod};\n+use ast::{QPath, RequiredMethod};\n use ast::{RetStyle, Return, BiShl, BiShr, Stmt, StmtDecl};\n use ast::{StmtExpr, StmtSemi, StmtMac, StructDef, StructField};\n use ast::{StructVariantKind, BiSub};\n@@ -52,10 +52,10 @@ use ast::{TokenTree, TraitItem, TraitRef, TTDelim, TTSeq, TTTok};\n use ast::{TTNonterminal, TupleVariantKind, Ty, Ty_, TyBot, TyBox};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n-use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyRptr};\n-use ast::{TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n-use ast::{UnboxedClosureKind, UnboxedFnTy, UnboxedFnTyParamBound};\n-use ast::{UnnamedField, UnsafeBlock};\n+use ast::{TyNil, TyParam, TyParamBound, TyParen, TyPath, TyPtr, TyQPath};\n+use ast::{TyRptr, TyTup, TyU32, TyUnboxedFn, TyUniq, TyVec, UnUniq};\n+use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n+use ast::{UnboxedFnTy, UnboxedFnTyParamBound, UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use ast::{Visibility, WhereClause, WherePredicate};\n@@ -1235,86 +1235,125 @@ impl<'a> Parser<'a> {\n         (decl, lifetime_defs)\n     }\n \n-    /// Parse the methods in a trait declaration\n-    pub fn parse_trait_methods(&mut self) -> Vec<TraitItem> {\n+    /// Parses `type Foo;` in a trait declaration only. The `type` keyword has\n+    /// already been parsed.\n+    fn parse_associated_type(&mut self, attrs: Vec<Attribute>)\n+                             -> AssociatedType {\n+        let lo = self.span.lo;\n+        let ident = self.parse_ident();\n+        let hi = self.span.hi;\n+        self.expect(&token::SEMI);\n+        AssociatedType {\n+            id: ast::DUMMY_NODE_ID,\n+            span: mk_sp(lo, hi),\n+            ident: ident,\n+            attrs: attrs,\n+        }\n+    }\n+\n+    /// Parses `type Foo = TYPE;` in an implementation declaration only. The\n+    /// `type` keyword has already been parsed.\n+    fn parse_typedef(&mut self, attrs: Vec<Attribute>, vis: Visibility)\n+                     -> Typedef {\n+        let lo = self.span.lo;\n+        let ident = self.parse_ident();\n+        self.expect(&token::EQ);\n+        let typ = self.parse_ty(true);\n+        let hi = self.span.hi;\n+        self.expect(&token::SEMI);\n+        Typedef {\n+            id: ast::DUMMY_NODE_ID,\n+            span: mk_sp(lo, hi),\n+            ident: ident,\n+            vis: vis,\n+            attrs: attrs,\n+            typ: typ,\n+        }\n+    }\n+\n+    /// Parse the items in a trait declaration\n+    pub fn parse_trait_items(&mut self) -> Vec<TraitItem> {\n         self.parse_unspanned_seq(\n             &token::LBRACE,\n             &token::RBRACE,\n             seq_sep_none(),\n             |p| {\n             let attrs = p.parse_outer_attributes();\n-            let lo = p.span.lo;\n-\n-            // NB: at the moment, trait methods are public by default; this\n-            // could change.\n-            let vis = p.parse_visibility();\n-            let abi = if p.eat_keyword(keywords::Extern) {\n-                p.parse_opt_abi().unwrap_or(abi::C)\n-            } else if attr::contains_name(attrs.as_slice(),\n-                                          \"rust_call_abi_hack\") {\n-                // FIXME(stage0, pcwalton): Remove this awful hack after a\n-                // snapshot, and change to `extern \"rust-call\" fn`.\n-                abi::RustCall\n+\n+            if p.eat_keyword(keywords::Type) {\n+                TypeTraitItem(P(p.parse_associated_type(attrs)))\n             } else {\n-                abi::Rust\n-            };\n-            let style = p.parse_fn_style();\n-            let ident = p.parse_ident();\n+                let lo = p.span.lo;\n \n-            let mut generics = p.parse_generics();\n+                let vis = p.parse_visibility();\n+                let abi = if p.eat_keyword(keywords::Extern) {\n+                    p.parse_opt_abi().unwrap_or(abi::C)\n+                } else if attr::contains_name(attrs.as_slice(),\n+                                              \"rust_call_abi_hack\") {\n+                    // FIXME(stage0, pcwalton): Remove this awful hack after a\n+                    // snapshot, and change to `extern \"rust-call\" fn`.\n+                    abi::RustCall\n+                } else {\n+                    abi::Rust\n+                };\n \n-            let (explicit_self, d) = p.parse_fn_decl_with_self(|p| {\n-                // This is somewhat dubious; We don't want to allow argument\n-                // names to be left off if there is a definition...\n-                p.parse_arg_general(false)\n-            });\n+                let style = p.parse_fn_style();\n+                let ident = p.parse_ident();\n+                let mut generics = p.parse_generics();\n \n-            p.parse_where_clause(&mut generics);\n+                let (explicit_self, d) = p.parse_fn_decl_with_self(|p| {\n+                    // This is somewhat dubious; We don't want to allow\n+                    // argument names to be left off if there is a\n+                    // definition...\n+                    p.parse_arg_general(false)\n+                });\n \n-            let hi = p.last_span.hi;\n-            match p.token {\n-              token::SEMI => {\n-                p.bump();\n-                debug!(\"parse_trait_methods(): parsing required method\");\n-                RequiredMethod(TypeMethod {\n-                    ident: ident,\n-                    attrs: attrs,\n-                    fn_style: style,\n-                    decl: d,\n-                    generics: generics,\n-                    abi: abi,\n-                    explicit_self: explicit_self,\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n-                    vis: vis,\n-                })\n-              }\n-              token::LBRACE => {\n-                debug!(\"parse_trait_methods(): parsing provided method\");\n-                let (inner_attrs, body) =\n-                    p.parse_inner_attrs_and_block();\n-                let mut attrs = attrs;\n-                attrs.extend(inner_attrs.into_iter());\n-                ProvidedMethod(P(ast::Method {\n-                    attrs: attrs,\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: mk_sp(lo, hi),\n-                    node: ast::MethDecl(ident,\n-                                        generics,\n-                                        abi,\n-                                        explicit_self,\n-                                        style,\n-                                        d,\n-                                        body,\n-                                        vis)\n-                }))\n-              }\n+                p.parse_where_clause(&mut generics);\n+\n+                let hi = p.last_span.hi;\n+                match p.token {\n+                  token::SEMI => {\n+                    p.bump();\n+                    debug!(\"parse_trait_methods(): parsing required method\");\n+                    RequiredMethod(TypeMethod {\n+                        ident: ident,\n+                        attrs: attrs,\n+                        fn_style: style,\n+                        decl: d,\n+                        generics: generics,\n+                        abi: abi,\n+                        explicit_self: explicit_self,\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: mk_sp(lo, hi),\n+                        vis: vis,\n+                    })\n+                  }\n+                  token::LBRACE => {\n+                    debug!(\"parse_trait_methods(): parsing provided method\");\n+                    let (inner_attrs, body) =\n+                        p.parse_inner_attrs_and_block();\n+                    let attrs = attrs.append(inner_attrs.as_slice());\n+                    ProvidedMethod(P(ast::Method {\n+                        attrs: attrs,\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: mk_sp(lo, hi),\n+                        node: ast::MethDecl(ident,\n+                                            generics,\n+                                            abi,\n+                                            explicit_self,\n+                                            style,\n+                                            d,\n+                                            body,\n+                                            vis)\n+                    }))\n+                  }\n \n-              _ => {\n-                  let token_str = p.this_token_to_string();\n-                  p.fatal((format!(\"expected `;` or `{{`, found `{}`\",\n-                                   token_str)).as_slice())\n-              }\n+                  _ => {\n+                      let token_str = p.this_token_to_string();\n+                      p.fatal((format!(\"expected `;` or `{{`, found `{}`\",\n+                                       token_str)).as_slice())\n+                  }\n+                }\n             }\n         })\n     }\n@@ -1455,12 +1494,11 @@ impl<'a> Parser<'a> {\n         } else if self.token_is_closure_keyword() ||\n                 self.token == token::BINOP(token::OR) ||\n                 self.token == token::OROR ||\n-                self.token == token::LT {\n+                (self.token == token::LT &&\n+                 self.look_ahead(1, |t| {\n+                     *t == token::GT || Parser::token_is_lifetime(t)\n+                 })) {\n             // CLOSURE\n-            //\n-            // FIXME(pcwalton): Eventually `token::LT` will not unambiguously\n-            // introduce a closure, once procs can have lifetime bounds. We\n-            // will need to refactor the grammar a little bit at that point.\n \n             self.parse_ty_closure()\n         } else if self.eat_keyword(keywords::Typeof) {\n@@ -1472,6 +1510,20 @@ impl<'a> Parser<'a> {\n             TyTypeof(e)\n         } else if self.eat_keyword(keywords::Proc) {\n             self.parse_proc_type()\n+        } else if self.token == token::LT {\n+            // QUALIFIED PATH\n+            self.bump();\n+            let for_type = self.parse_ty(true);\n+            self.expect_keyword(keywords::As);\n+            let trait_name = self.parse_path(LifetimeAndTypesWithoutColons);\n+            self.expect(&token::GT);\n+            self.expect(&token::MOD_SEP);\n+            let item_name = self.parse_ident();\n+            TyQPath(P(QPath {\n+                for_type: for_type,\n+                trait_name: trait_name.path,\n+                item_name: item_name,\n+            }))\n         } else if self.token == token::MOD_SEP\n             || is_ident_or_path(&self.token) {\n             // NAMED TYPE\n@@ -2071,7 +2123,7 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n                 hi = self.last_span.hi;\n-            },\n+            }\n             _ => {\n                 if self.eat_keyword(keywords::Ref) {\n                     return self.parse_lambda_expr(CaptureByRef);\n@@ -4215,14 +4267,9 @@ impl<'a> Parser<'a> {\n \n     /// Parse a method in a trait impl, starting with `attrs` attributes.\n     pub fn parse_method(&mut self,\n-                        already_parsed_attrs: Option<Vec<Attribute>>)\n+                        attrs: Vec<Attribute>,\n+                        visa: Visibility)\n                         -> P<Method> {\n-        let next_attrs = self.parse_outer_attributes();\n-        let attrs = match already_parsed_attrs {\n-            Some(mut a) => { a.push_all_move(next_attrs); a }\n-            None => next_attrs\n-        };\n-\n         let lo = self.span.lo;\n \n         // code copied from parse_macro_use_or_failure... abstraction!\n@@ -4251,7 +4298,6 @@ impl<'a> Parser<'a> {\n                                                              self.span.hi) };\n                 (ast::MethMac(m), self.span.hi, attrs)\n             } else {\n-                let visa = self.parse_visibility();\n                 let abi = if self.eat_keyword(keywords::Extern) {\n                     self.parse_opt_abi().unwrap_or(abi::C)\n                 } else if attr::contains_name(attrs.as_slice(),\n@@ -4302,18 +4348,28 @@ impl<'a> Parser<'a> {\n \n         self.parse_where_clause(&mut tps);\n \n-        let meths = self.parse_trait_methods();\n+        let meths = self.parse_trait_items();\n         (ident, ItemTrait(tps, sized, bounds, meths), None)\n     }\n \n     fn parse_impl_items(&mut self) -> (Vec<ImplItem>, Vec<Attribute>) {\n         let mut impl_items = Vec::new();\n         self.expect(&token::LBRACE);\n-        let (inner_attrs, next) = self.parse_inner_attrs_and_next();\n-        let mut method_attrs = Some(next);\n+        let (inner_attrs, mut method_attrs) =\n+            self.parse_inner_attrs_and_next();\n         while !self.eat(&token::RBRACE) {\n-            impl_items.push(MethodImplItem(self.parse_method(method_attrs)));\n-            method_attrs = None;\n+            method_attrs.push_all_move(self.parse_outer_attributes());\n+            let vis = self.parse_visibility();\n+            if self.eat_keyword(keywords::Type) {\n+                impl_items.push(TypeImplItem(P(self.parse_typedef(\n+                            method_attrs,\n+                            vis))))\n+            } else {\n+                impl_items.push(MethodImplItem(self.parse_method(\n+                            method_attrs,\n+                            vis)));\n+            }\n+            method_attrs = self.parse_outer_attributes();\n         }\n         (impl_items, inner_attrs)\n     }"}, {"sha": "0ae5303641bc6f43d9d3f0b31f563801cf2ce791", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 37, "deletions": 5, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -9,10 +9,11 @@\n // except according to those terms.\n \n use abi;\n-use ast::{FnMutUnboxedClosureKind, FnOnceUnboxedClosureKind};\n-use ast::{FnUnboxedClosureKind, MethodImplItem};\n-use ast::{RegionTyParamBound, TraitTyParamBound, UnboxedClosureKind};\n-use ast::{UnboxedFnTyParamBound, RequiredMethod, ProvidedMethod};\n+use ast::{FnUnboxedClosureKind, FnMutUnboxedClosureKind};\n+use ast::{FnOnceUnboxedClosureKind};\n+use ast::{MethodImplItem, RegionTyParamBound, TraitTyParamBound};\n+use ast::{RequiredMethod, ProvidedMethod, TypeImplItem, TypeTraitItem};\n+use ast::{UnboxedClosureKind, UnboxedFnTyParamBound};\n use ast;\n use ast_util;\n use owned_slice::OwnedSlice;\n@@ -660,6 +661,16 @@ impl<'a> State<'a> {\n             ast::TyPath(ref path, ref bounds, _) => {\n                 try!(self.print_bounded_path(path, bounds));\n             }\n+            ast::TyQPath(ref qpath) => {\n+                try!(word(&mut self.s, \"<\"));\n+                try!(self.print_type(&*qpath.for_type));\n+                try!(space(&mut self.s));\n+                try!(self.word_space(\"as\"));\n+                try!(self.print_path(&qpath.trait_name, false));\n+                try!(word(&mut self.s, \">\"));\n+                try!(word(&mut self.s, \"::\"));\n+                try!(self.print_ident(qpath.item_name));\n+            }\n             ast::TyFixedLengthVec(ref ty, ref v) => {\n                 try!(word(&mut self.s, \"[\"));\n                 try!(self.print_type(&**ty));\n@@ -708,6 +719,22 @@ impl<'a> State<'a> {\n         }\n     }\n \n+    fn print_associated_type(&mut self, typedef: &ast::AssociatedType)\n+                             -> IoResult<()> {\n+        try!(self.word_space(\"type\"));\n+        try!(self.print_ident(typedef.ident));\n+        word(&mut self.s, \";\")\n+    }\n+\n+    fn print_typedef(&mut self, typedef: &ast::Typedef) -> IoResult<()> {\n+        try!(self.word_space(\"type\"));\n+        try!(self.print_ident(typedef.ident));\n+        try!(space(&mut self.s));\n+        try!(self.word_space(\"=\"));\n+        try!(self.print_type(&*typedef.typ));\n+        word(&mut self.s, \";\")\n+    }\n+\n     /// Pretty-print an item\n     pub fn print_item(&mut self, item: &ast::Item) -> IoResult<()> {\n         try!(self.hardbreak_if_not_bol());\n@@ -825,6 +852,9 @@ impl<'a> State<'a> {\n                         ast::MethodImplItem(ref meth) => {\n                             try!(self.print_method(&**meth));\n                         }\n+                        ast::TypeImplItem(ref typ) => {\n+                            try!(self.print_typedef(&**typ));\n+                        }\n                     }\n                 }\n                 try!(self.bclose(item.span));\n@@ -1071,13 +1101,15 @@ impl<'a> State<'a> {\n                               m: &ast::TraitItem) -> IoResult<()> {\n         match *m {\n             RequiredMethod(ref ty_m) => self.print_ty_method(ty_m),\n-            ProvidedMethod(ref m) => self.print_method(&**m)\n+            ProvidedMethod(ref m) => self.print_method(&**m),\n+            TypeTraitItem(ref t) => self.print_associated_type(&**t),\n         }\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> IoResult<()> {\n         match *ii {\n             MethodImplItem(ref m) => self.print_method(&**m),\n+            TypeImplItem(ref td) => self.print_typedef(&**td),\n         }\n     }\n "}, {"sha": "d425c60f4c91fed9fab81723e0c230c61fc2cca5", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -116,12 +116,19 @@ pub trait Visitor<'v> {\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n-pub fn walk_inlined_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v InlinedItem) {\n+pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n+                         where V: Visitor<'v> {\n     match *item {\n         IIItem(ref i) => visitor.visit_item(&**i),\n         IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n         IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-        IIImplItem(_, MethodImplItem(ref m)) => walk_method_helper(visitor, &**m)\n+        IIImplItem(_, MethodImplItem(ref m)) => {\n+            walk_method_helper(visitor, &**m)\n+        }\n+        IIImplItem(_, TypeImplItem(ref typedef)) => {\n+            visitor.visit_ident(typedef.span, typedef.ident);\n+            visitor.visit_ty(&*typedef.typ);\n+        }\n     }\n }\n \n@@ -248,6 +255,10 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                     MethodImplItem(ref method) => {\n                         walk_method_helper(visitor, &**method)\n                     }\n+                    TypeImplItem(ref typedef) => {\n+                        visitor.visit_ident(typedef.span, typedef.ident);\n+                        visitor.visit_ty(&*typedef.typ);\n+                    }\n                 }\n             }\n         }\n@@ -366,6 +377,11 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n                 None => { }\n             }\n         }\n+        TyQPath(ref qpath) => {\n+            visitor.visit_ty(&*qpath.for_type);\n+            visitor.visit_path(&qpath.trait_name, typ.id);\n+            visitor.visit_ident(typ.span, qpath.item_name);\n+        }\n         TyFixedLengthVec(ref ty, ref expression) => {\n             visitor.visit_ty(&**ty);\n             visitor.visit_expr(&**expression)\n@@ -573,10 +589,11 @@ pub fn walk_ty_method<'v, V: Visitor<'v>>(visitor: &mut V, method_type: &'v Type\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_method: &'v TraitItem) {\n     match *trait_method {\n-        RequiredMethod(ref method_type) => {\n-            visitor.visit_ty_method(method_type)\n-        }\n+        RequiredMethod(ref method_type) => visitor.visit_ty_method(method_type),\n         ProvidedMethod(ref method) => walk_method_helper(visitor, &**method),\n+        TypeTraitItem(ref associated_type) => {\n+            visitor.visit_ident(associated_type.span, associated_type.ident)\n+        }\n     }\n }\n "}, {"sha": "d95b94f0067605d87e9f1a828d77ab70f12b292d", "filename": "src/test/compile-fail/associated-types-feature-gate.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-feature-gate.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Get {\n+    type Value; //~ ERROR associated types are experimental\n+    fn get(&self) -> Get::Value;\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;   //~ ERROR associated types are experimental\n+    fn get(&self) -> int {\n+        self.x\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(s.get(), 100);\n+}\n+"}, {"sha": "a2c01fe62f6bba1960d229f08791537acb562f98", "filename": "src/test/compile-fail/associated-types-in-ambiguous-context.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-ambiguous-context.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn get<T:Get,U:Get>(x: T, y: U) -> Get::Value {}\n+//~^ ERROR ambiguous associated type\n+\n+trait Other {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <Self as Get>::Value) {}\n+    //~^ ERROR this associated type is not allowed in this context\n+}\n+\n+impl<T:Get> Other for T {\n+    fn uhoh<U:Get>(&self, foo: U, bar: <(T, U) as Get>::Value) {}\n+    //~^ ERROR this associated type is not allowed in this context\n+}\n+\n+trait Grab {\n+    type Value;\n+    fn grab(&self) -> Grab::Value;\n+    //~^ ERROR ambiguous associated type\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "8fbfc33896b41914bfad7ffcb56dbdc13b66b984", "filename": "src/test/compile-fail/associated-types-in-wrong-context.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-in-wrong-context.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> <Self as Get>::Value;\n+}\n+\n+fn get(x: int) -> <int as Get>::Value {}\n+//~^ ERROR this associated type is not allowed in this context\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Struct {\n+    fn uhoh<T>(foo: <T as Get>::Value) {}\n+    //~^ ERROR this associated type is not allowed in this context\n+}\n+\n+fn main() {\n+}\n+"}, {"sha": "17cf36b73f6432487d7ae31bf414bc0c511ce51e", "filename": "src/test/compile-fail/class-method-missing.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-method-missing.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -17,7 +17,7 @@ struct cat {\n }\n \n impl animal for cat {\n-    //~^ ERROR not all trait methods implemented, missing: `eat`\n+    //~^ ERROR not all trait items implemented, missing: `eat`\n }\n \n fn cat(in_x : uint) -> cat {"}, {"sha": "b88272ed4666e6b97c12b5512ceaff744cf53109", "filename": "src/test/compile-fail/issue-3344.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3344.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -10,7 +10,7 @@\n \n #[deriving(PartialEq)]\n struct thing(uint);\n-impl PartialOrd for thing { //~ ERROR not all trait methods implemented, missing: `partial_cmp`\n+impl PartialOrd for thing { //~ ERROR not all trait items implemented, missing: `partial_cmp`\n     fn le(&self, other: &thing) -> bool { true }\n     fn ge(&self, other: &thing) -> bool { true }\n }"}, {"sha": "db960ac340913e4d95e0a28d06d0ad730af07c39", "filename": "src/test/compile-fail/missing-derivable-attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-derivable-attr.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -20,7 +20,7 @@ impl MyEq for int {\n     fn eq(&self, other: &int) -> bool { *self == *other }\n }\n \n-impl MyEq for A {}  //~ ERROR not all trait methods implemented, missing: `eq`\n+impl MyEq for A {}  //~ ERROR not all trait items implemented, missing: `eq`\n \n fn main() {\n }"}, {"sha": "e01b18a64db22098790ed22f24eb4ebe521898c3", "filename": "src/test/run-pass/associated-types-in-default-method.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-default-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-default-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-in-default-method.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+    fn grab(&self) -> &<Self as Get>::Value {\n+        self.get()\n+    }\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;\n+    fn get(&self) -> &int {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(*s.grab(), 100);\n+}\n+\n+"}, {"sha": "4ed213e85d8787fd484776fd3aa0d8f36cda62ea", "filename": "src/test/run-pass/associated-types-in-fn.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-in-fn.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;\n+    fn get(&self) -> &int {\n+        &self.x\n+    }\n+}\n+\n+fn grab<T:Get>(x: &T) -> &<T as Get>::Value {\n+    x.get()\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(*grab(&s), 100);\n+}\n+"}, {"sha": "f6aaaf3b3fa15d41512489924fb0bf14ebb25ca0", "filename": "src/test/run-pass/associated-types-in-impl-generics.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-impl-generics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-impl-generics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-in-impl-generics.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;\n+    fn get(&self) -> &int {\n+        &self.x\n+    }\n+}\n+\n+trait Grab {\n+    type U;\n+    fn grab(&self) -> &<Self as Grab>::U;\n+}\n+\n+impl<T:Get> Grab for T {\n+    type U = <T as Get>::Value;\n+    fn grab(&self) -> &<T as Get>::Value {\n+        self.get()\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(*s.grab(), 100);\n+}\n+"}, {"sha": "341682692460ff05cdccfa91e08f3bd4416473b9", "filename": "src/test/run-pass/associated-types-in-inherent-method.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-inherent-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-in-inherent-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-in-inherent-method.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;\n+    fn get(&self) -> &int {\n+        &self.x\n+    }\n+}\n+\n+impl Struct {\n+    fn grab<T:Get>(x: &T) -> &<T as Get>::Value {\n+        x.get()\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(*Struct::grab(&s), 100);\n+}\n+"}, {"sha": "82ae0d89b46057930c9137fa10227cdc56158489", "filename": "src/test/run-pass/associated-types-simple.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fassociated-types-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-simple.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_types)]\n+\n+trait Get {\n+    type Value;\n+    fn get(&self) -> &<Self as Get>::Value;\n+}\n+\n+struct Struct {\n+    x: int,\n+}\n+\n+impl Get for Struct {\n+    type Value = int;\n+    fn get(&self) -> &int {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let s = Struct {\n+        x: 100,\n+    };\n+    assert_eq!(*s.get(), 100);\n+}\n+"}, {"sha": "b5400edb41fc431490194da9a877f143f383ee11", "filename": "src/test/run-pass/macro-method-issue-4621.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9508faa2270a35595670cb3ca610ad17abff272d/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-method-issue-4621.rs?ref=9508faa2270a35595670cb3ca610ad17abff272d", "patch": "@@ -12,7 +12,7 @@\n \n struct A;\n \n-macro_rules! make_thirteen_method {() => (pub fn thirteen(&self)->int {13})}\n+macro_rules! make_thirteen_method {() => (fn thirteen(&self)->int {13})}\n impl A { make_thirteen_method!() }\n \n fn main() {"}]}