{"sha": "b25b80401384dc97731909c86557e74598890c4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNWI4MDQwMTM4NGRjOTc3MzE5MDljODY1NTdlNzQ1OTg4OTBjNGI=", "commit": {"author": {"name": "Denis Merigoux", "email": "denis.merigoux@gmail.com", "date": "2018-10-09T14:01:02Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-11-16T13:08:18Z"}, "message": "Added default impl for DerivedTypeMethods + empty impl for Cranelift BaseTypeMethods", "tree": {"sha": "a6c015e132d5064b27498fcbb62fc8a0e8481eb0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6c015e132d5064b27498fcbb62fc8a0e8481eb0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b25b80401384dc97731909c86557e74598890c4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b25b80401384dc97731909c86557e74598890c4b", "html_url": "https://github.com/rust-lang/rust/commit/b25b80401384dc97731909c86557e74598890c4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b25b80401384dc97731909c86557e74598890c4b/comments", "author": {"login": "denismerigoux", "id": 1766128, "node_id": "MDQ6VXNlcjE3NjYxMjg=", "avatar_url": "https://avatars.githubusercontent.com/u/1766128?v=4", "gravatar_id": "", "url": "https://api.github.com/users/denismerigoux", "html_url": "https://github.com/denismerigoux", "followers_url": "https://api.github.com/users/denismerigoux/followers", "following_url": "https://api.github.com/users/denismerigoux/following{/other_user}", "gists_url": "https://api.github.com/users/denismerigoux/gists{/gist_id}", "starred_url": "https://api.github.com/users/denismerigoux/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/denismerigoux/subscriptions", "organizations_url": "https://api.github.com/users/denismerigoux/orgs", "repos_url": "https://api.github.com/users/denismerigoux/repos", "events_url": "https://api.github.com/users/denismerigoux/events{/privacy}", "received_events_url": "https://api.github.com/users/denismerigoux/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54dd3a47fd54eb466dad7e47b41ec1b5b2dafd5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/54dd3a47fd54eb466dad7e47b41ec1b5b2dafd5a", "html_url": "https://github.com/rust-lang/rust/commit/54dd3a47fd54eb466dad7e47b41ec1b5b2dafd5a"}], "stats": {"total": 262, "additions": 111, "deletions": 151}, "files": [{"sha": "53151fef5096d548a9578bb5d839678eefc03576", "filename": "src/librustc_codegen_llvm/type_.rs", "status": "modified", "additions": 5, "deletions": 120, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_llvm%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ftype_.rs?ref=b25b80401384dc97731909c86557e74598890c4b", "patch": "@@ -18,16 +18,12 @@ use context::CodegenCx;\n use rustc_codegen_ssa::interfaces::*;\n use value::Value;\n \n-\n-use syntax::ast;\n-use rustc::ty::layout::{self, Align, Size, HasTyCtxt};\n use rustc::util::nodemap::FxHashMap;\n-use rustc::ty::{self, Ty};\n+use rustc::ty::Ty;\n use rustc::ty::layout::TyLayout;\n use rustc_target::abi::call::{CastTarget, FnType, Reg};\n use rustc_data_structures::small_c_str::SmallCStr;\n use common;\n-use rustc_codegen_ssa;\n use rustc_codegen_ssa::common::TypeKind;\n use type_of::LayoutLlvmExt;\n use abi::{LlvmType, FnTypeExt};\n@@ -108,6 +104,10 @@ impl BaseTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    fn type_isize(&self) -> &'ll Type {\n+        self.isize_ty\n+    }\n+\n     fn type_f32(&self) -> &'ll Type {\n         unsafe {\n             llvm::LLVMFloatTypeInContext(self.llcx)\n@@ -274,121 +274,6 @@ impl Type {\n     }\n }\n \n-impl DerivedTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n-    fn type_bool(&self) -> &'ll Type {\n-        self.type_i8()\n-    }\n-\n-    fn type_i8p(&self) -> &'ll Type {\n-        self.type_ptr_to(self.type_i8())\n-    }\n-\n-    fn type_isize(&self) -> &'ll Type {\n-        self.isize_ty\n-    }\n-\n-    fn type_int(&self) -> &'ll Type {\n-        match &self.sess().target.target.target_c_int_width[..] {\n-            \"16\" => self.type_i16(),\n-            \"32\" => self.type_i32(),\n-            \"64\" => self.type_i64(),\n-            width => bug!(\"Unsupported target_c_int_width: {}\", width),\n-        }\n-    }\n-\n-    fn type_int_from_ty(\n-        &self,\n-        t: ast::IntTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::IntTy::Isize => self.isize_ty,\n-            ast::IntTy::I8 => self.type_i8(),\n-            ast::IntTy::I16 => self.type_i16(),\n-            ast::IntTy::I32 => self.type_i32(),\n-            ast::IntTy::I64 => self.type_i64(),\n-            ast::IntTy::I128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_uint_from_ty(\n-        &self,\n-        t: ast::UintTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::UintTy::Usize => self.isize_ty,\n-            ast::UintTy::U8 => self.type_i8(),\n-            ast::UintTy::U16 => self.type_i16(),\n-            ast::UintTy::U32 => self.type_i32(),\n-            ast::UintTy::U64 => self.type_i64(),\n-            ast::UintTy::U128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_float_from_ty(\n-        &self,\n-        t: ast::FloatTy\n-    ) -> &'ll Type {\n-        match t {\n-            ast::FloatTy::F32 => self.type_f32(),\n-            ast::FloatTy::F64 => self.type_f64(),\n-        }\n-    }\n-\n-    fn type_from_integer(&self, i: layout::Integer) -> &'ll Type {\n-        use rustc::ty::layout::Integer::*;\n-        match i {\n-            I8 => self.type_i8(),\n-            I16 => self.type_i16(),\n-            I32 => self.type_i32(),\n-            I64 => self.type_i64(),\n-            I128 => self.type_i128(),\n-        }\n-    }\n-\n-    fn type_pointee_for_abi_align(&self, align: Align) -> &'ll Type {\n-        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n-        let ity = layout::Integer::approximate_abi_align(self, align);\n-        self.type_from_integer(ity)\n-    }\n-\n-    fn type_padding_filler(\n-        &self,\n-        size: Size,\n-        align: Align\n-    ) -> &'ll Type {\n-        let unit = layout::Integer::approximate_abi_align(self, align);\n-        let size = size.bytes();\n-        let unit_size = unit.size().bytes();\n-        assert_eq!(size % unit_size, 0);\n-        self.type_array(self.type_from_integer(unit), size / unit_size)\n-    }\n-\n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        rustc_codegen_ssa::common::type_needs_drop(self.tcx(), ty)\n-    }\n-\n-    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n-        rustc_codegen_ssa::common::type_is_sized(self.tcx(), ty)\n-    }\n-\n-    fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n-        rustc_codegen_ssa::common::type_is_freeze(self.tcx(), ty)\n-    }\n-\n-    fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n-        use syntax_pos::DUMMY_SP;\n-        if ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n-            return false;\n-        }\n-\n-        let tail = self.tcx().struct_tail(ty);\n-        match tail.sty {\n-            ty::Foreign(..) => false,\n-            ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n-            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n-        }\n-    }\n-}\n \n impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> &'ll Type {"}, {"sha": "6e8233bcb889dbd3b4b9fee50937da4ef8ba74b0", "filename": "src/librustc_codegen_ssa/interfaces/backend.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Fbackend.rs?ref=b25b80401384dc97731909c86557e74598890c4b", "patch": "@@ -35,7 +35,7 @@ pub trait BackendTypes {\n }\n \n pub trait Backend<'tcx>:\n-    BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n+    Sized + BackendTypes + HasTyCtxt<'tcx> + LayoutOf<Ty = Ty<'tcx>, TyLayout = TyLayout<'tcx>>\n {\n }\n "}, {"sha": "1aa1f45f51746a28599100d37b13535d38e99644", "filename": "src/librustc_codegen_ssa/interfaces/type_.rs", "status": "modified", "additions": 105, "deletions": 30, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b25b80401384dc97731909c86557e74598890c4b/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Finterfaces%2Ftype_.rs?ref=b25b80401384dc97731909c86557e74598890c4b", "patch": "@@ -8,13 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use super::misc::MiscMethods;\n use super::Backend;\n use super::HasCodegen;\n-use common::TypeKind;\n+use common::{self, TypeKind};\n use mir::place::PlaceRef;\n-use rustc::ty::layout::TyLayout;\n-use rustc::ty::layout::{self, Align, Size};\n-use rustc::ty::Ty;\n+use rustc::ty::layout::{self, Align, Size, TyLayout};\n+use rustc::ty::{self, Ty};\n use rustc::util::nodemap::FxHashMap;\n use rustc_target::abi::call::{ArgType, CastTarget, FnType, Reg};\n use std::cell::RefCell;\n@@ -32,6 +32,7 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n \n     // Creates an integer type with the given number of bits, e.g. i24\n     fn type_ix(&self, num_bits: u64) -> Self::Type;\n+    fn type_isize(&self) -> Self::Type;\n \n     fn type_f32(&self) -> Self::Type;\n     fn type_f64(&self) -> Self::Type;\n@@ -61,30 +62,109 @@ pub trait BaseTypeMethods<'tcx>: Backend<'tcx> {\n     fn scalar_lltypes(&self) -> &RefCell<FxHashMap<Ty<'tcx>, Self::Type>>;\n }\n \n-pub trait DerivedTypeMethods<'tcx>: Backend<'tcx> {\n-    fn type_bool(&self) -> Self::Type;\n-    fn type_i8p(&self) -> Self::Type;\n-    fn type_isize(&self) -> Self::Type;\n-    fn type_int(&self) -> Self::Type;\n-    fn type_int_from_ty(&self, t: ast::IntTy) -> Self::Type;\n-    fn type_uint_from_ty(&self, t: ast::UintTy) -> Self::Type;\n-    fn type_float_from_ty(&self, t: ast::FloatTy) -> Self::Type;\n-    fn type_from_integer(&self, i: layout::Integer) -> Self::Type;\n-\n-    /// Return a LLVM type that has at most the required alignment,\n-    /// as a conservative approximation for unknown pointee types.\n-    fn type_pointee_for_abi_align(&self, align: Align) -> Self::Type;\n+pub trait DerivedTypeMethods<'tcx>: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {\n+    fn type_bool(&self) -> Self::Type {\n+        self.type_i8()\n+    }\n+\n+    fn type_i8p(&self) -> Self::Type {\n+        self.type_ptr_to(self.type_i8())\n+    }\n+\n+    fn type_int(&self) -> Self::Type {\n+        match &self.sess().target.target.target_c_int_width[..] {\n+            \"16\" => self.type_i16(),\n+            \"32\" => self.type_i32(),\n+            \"64\" => self.type_i64(),\n+            width => bug!(\"Unsupported target_c_int_width: {}\", width),\n+        }\n+    }\n+\n+    fn type_int_from_ty(&self, t: ast::IntTy) -> Self::Type {\n+        match t {\n+            ast::IntTy::Isize => self.type_isize(),\n+            ast::IntTy::I8 => self.type_i8(),\n+            ast::IntTy::I16 => self.type_i16(),\n+            ast::IntTy::I32 => self.type_i32(),\n+            ast::IntTy::I64 => self.type_i64(),\n+            ast::IntTy::I128 => self.type_i128(),\n+        }\n+    }\n+\n+    fn type_uint_from_ty(&self, t: ast::UintTy) -> Self::Type {\n+        match t {\n+            ast::UintTy::Usize => self.type_isize(),\n+            ast::UintTy::U8 => self.type_i8(),\n+            ast::UintTy::U16 => self.type_i16(),\n+            ast::UintTy::U32 => self.type_i32(),\n+            ast::UintTy::U64 => self.type_i64(),\n+            ast::UintTy::U128 => self.type_i128(),\n+        }\n+    }\n+\n+    fn type_float_from_ty(&self, t: ast::FloatTy) -> Self::Type {\n+        match t {\n+            ast::FloatTy::F32 => self.type_f32(),\n+            ast::FloatTy::F64 => self.type_f64(),\n+        }\n+    }\n+\n+    fn type_from_integer(&self, i: layout::Integer) -> Self::Type {\n+        use rustc::ty::layout::Integer::*;\n+        match i {\n+            I8 => self.type_i8(),\n+            I16 => self.type_i16(),\n+            I32 => self.type_i32(),\n+            I64 => self.type_i64(),\n+            I128 => self.type_i128(),\n+        }\n+    }\n+\n+    fn type_pointee_for_abi_align(&self, align: Align) -> Self::Type {\n+        // FIXME(eddyb) We could find a better approximation if ity.align < align.\n+        let ity = layout::Integer::approximate_abi_align(self, align);\n+        self.type_from_integer(ity)\n+    }\n \n     /// Return a LLVM type that has at most the required alignment,\n     /// and exactly the required size, as a best-effort padding array.\n-    fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type;\n-\n-    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool;\n-    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool;\n-    fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool;\n-    fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool;\n+    fn type_padding_filler(&self, size: Size, align: Align) -> Self::Type {\n+        let unit = layout::Integer::approximate_abi_align(self, align);\n+        let size = size.bytes();\n+        let unit_size = unit.size().bytes();\n+        assert_eq!(size % unit_size, 0);\n+        self.type_array(self.type_from_integer(unit), size / unit_size)\n+    }\n+\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_needs_drop(self.tcx(), ty)\n+    }\n+\n+    fn type_is_sized(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_sized(self.tcx(), ty)\n+    }\n+\n+    fn type_is_freeze(&self, ty: Ty<'tcx>) -> bool {\n+        common::type_is_freeze(self.tcx(), ty)\n+    }\n+\n+    fn type_has_metadata(&self, ty: Ty<'tcx>) -> bool {\n+        use syntax_pos::DUMMY_SP;\n+        if ty.is_sized(self.tcx().at(DUMMY_SP), ty::ParamEnv::reveal_all()) {\n+            return false;\n+        }\n+\n+        let tail = self.tcx().struct_tail(ty);\n+        match tail.sty {\n+            ty::Foreign(..) => false,\n+            ty::Str | ty::Slice(..) | ty::Dynamic(..) => true,\n+            _ => bug!(\"unexpected unsized tail: {:?}\", tail.sty),\n+        }\n+    }\n }\n \n+impl<T> DerivedTypeMethods<'tcx> for T where Self: BaseTypeMethods<'tcx> + MiscMethods<'tcx> {}\n+\n pub trait LayoutTypeMethods<'tcx>: Backend<'tcx> {\n     fn backend_type(&self, layout: TyLayout<'tcx>) -> Self::Type;\n     fn cast_backend_type(&self, ty: &CastTarget) -> Self::Type;\n@@ -119,11 +199,6 @@ pub trait ArgTypeMethods<'tcx>: HasCodegen<'tcx> {\n     fn memory_ty(&self, ty: &ArgType<'tcx, Ty<'tcx>>) -> Self::Type;\n }\n \n-pub trait TypeMethods<'tcx>:\n-    BaseTypeMethods<'tcx> + DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx>\n-{\n-}\n+pub trait TypeMethods<'tcx>: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> {}\n \n-impl<T> TypeMethods<'tcx> for T where\n-    Self: BaseTypeMethods<'tcx> + DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx>\n-{}\n+impl<T> TypeMethods<'tcx> for T where Self: DerivedTypeMethods<'tcx> + LayoutTypeMethods<'tcx> {}"}]}