{"sha": "c5edd22646fcde05b39490558371c7ea9d525a0f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZWRkMjI2NDZmY2RlMDViMzk0OTA1NTgzNzFjN2VhOWQ1MjVhMGY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-23T01:57:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-12-30T14:32:42Z"}, "message": "Rewrite the intrinsicck to take the parameter environment into account. Also fixes #20116.", "tree": {"sha": "1c4888ffd5bc2e3e81fd5f73cff9c794bb1002e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c4888ffd5bc2e3e81fd5f73cff9c794bb1002e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5edd22646fcde05b39490558371c7ea9d525a0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5edd22646fcde05b39490558371c7ea9d525a0f", "html_url": "https://github.com/rust-lang/rust/commit/c5edd22646fcde05b39490558371c7ea9d525a0f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5edd22646fcde05b39490558371c7ea9d525a0f/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4946e1a46317a890b3e8d0157e045adf80b535d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/4946e1a46317a890b3e8d0157e045adf80b535d3", "html_url": "https://github.com/rust-lang/rust/commit/4946e1a46317a890b3e8d0157e045adf80b535d3"}], "stats": {"total": 512, "additions": 352, "deletions": 160}, "files": [{"sha": "1f4ddd1a5d6410857a40ea67aa723d8158f9ff4a", "filename": "src/librustc/middle/intrinsicck.rs", "status": "modified", "additions": 192, "deletions": 57, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fintrinsicck.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -10,9 +10,10 @@\n \n use metadata::csearch;\n use middle::def::DefFn;\n-use middle::subst::Subst;\n+use middle::subst::{Subst, Substs, EnumeratedItems};\n use middle::ty::{TransmuteRestriction, ctxt, ty_bare_fn};\n use middle::ty::{mod, Ty};\n+use util::ppaux::Repr;\n \n use syntax::abi::RustIntrinsic;\n use syntax::ast::DefId;\n@@ -23,52 +24,31 @@ use syntax::parse::token;\n use syntax::visit::Visitor;\n use syntax::visit;\n \n-fn type_size_is_affected_by_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>, typ: Ty<'tcx>)\n-                                                  -> bool {\n-    let mut result = false;\n-    ty::maybe_walk_ty(typ, |typ| {\n-        match typ.sty {\n-            ty::ty_uniq(_) | ty::ty_ptr(_) | ty::ty_rptr(..) |\n-            ty::ty_bare_fn(..) | ty::ty_closure(..) => {\n-                false\n-            }\n-            ty::ty_param(_) => {\n-                result = true;\n-                // No need to continue; we now know the result.\n-                false\n-            }\n-            ty::ty_enum(did, substs) => {\n-                for enum_variant in (*ty::enum_variants(tcx, did)).iter() {\n-                    for argument_type in enum_variant.args.iter() {\n-                        let argument_type = argument_type.subst(tcx, substs);\n-                        result = result ||\n-                            type_size_is_affected_by_type_parameters(\n-                                tcx,\n-                                argument_type);\n-                    }\n-                }\n-\n-                // Don't traverse substitutions.\n-                false\n-            }\n-            ty::ty_struct(did, substs) => {\n-                for field in ty::struct_fields(tcx, did, substs).iter() {\n-                    result = result ||\n-                        type_size_is_affected_by_type_parameters(tcx,\n-                                                                 field.mt.ty);\n-                }\n-\n-                // Don't traverse substitutions.\n-                false\n-            }\n-            _ => true,\n-        }\n-    });\n-    result\n+pub fn check_crate(tcx: &ctxt) {\n+    let mut visitor = IntrinsicCheckingVisitor {\n+        tcx: tcx,\n+        param_envs: Vec::new(),\n+        dummy_sized_ty: ty::mk_int(),\n+        dummy_unsized_ty: ty::mk_vec(tcx, ty::mk_int(), None),\n+    };\n+    visit::walk_crate(&mut visitor, tcx.map.krate());\n }\n \n struct IntrinsicCheckingVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ctxt<'tcx>,\n+\n+    // As we traverse the AST, we keep a stack of the parameter\n+    // environments for each function we encounter. When we find a\n+    // call to `transmute`, we can check it in the context of the top\n+    // of the stack (which ought not to be empty).\n+    param_envs: Vec<ty::ParameterEnvironment<'tcx>>,\n+\n+    // Dummy sized/unsized types that use to substitute for type\n+    // parameters in order to estimate how big a type will be for any\n+    // possible instantiation of the type parameters in scope.  See\n+    // `check_transmute` for more details.\n+    dummy_sized_ty: Ty<'tcx>,\n+    dummy_unsized_ty: Ty<'tcx>,\n }\n \n impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n@@ -97,26 +77,175 @@ impl<'a, 'tcx> IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n \n     fn check_transmute(&self, span: Span, from: Ty<'tcx>, to: Ty<'tcx>, id: ast::NodeId) {\n-        if type_size_is_affected_by_type_parameters(self.tcx, from) {\n+        // Find the parameter environment for the most recent function that\n+        // we entered.\n+\n+        let param_env = match self.param_envs.last() {\n+            Some(p) => p,\n+            None => {\n+                self.tcx.sess.span_bug(\n+                    span,\n+                    \"transmute encountered outside of any fn\");\n+            }\n+        };\n+\n+        // Simple case: no type parameters involved.\n+        if\n+            !ty::type_has_params(from) && !ty::type_has_self(from) &&\n+            !ty::type_has_params(to) && !ty::type_has_self(to)\n+        {\n+            let restriction = TransmuteRestriction {\n+                span: span,\n+                original_from: from,\n+                original_to: to,\n+                substituted_from: from,\n+                substituted_to: to,\n+                id: id,\n+            };\n+            self.push_transmute_restriction(restriction);\n+            return;\n+        }\n+\n+        // The rules around type parameters are a bit subtle. We are\n+        // checking these rules before monomorphization, so there may\n+        // be unsubstituted type parameters present in the\n+        // types. Obviously we cannot create LLVM types for those.\n+        // However, if a type parameter appears only indirectly (i.e.,\n+        // through a pointer), it does not necessarily affect the\n+        // size, so that should be allowed. The only catch is that we\n+        // DO want to be careful around unsized type parameters, since\n+        // fat pointers have a different size than a thin pointer, and\n+        // hence `&T` and `&U` have different sizes if `T : Sized` but\n+        // `U : Sized` does not hold.\n+        //\n+        // However, it's not as simple as checking whether `T :\n+        // Sized`, because even if `T : Sized` does not hold, that\n+        // just means that `T` *may* not be sized.  After all, even a\n+        // type parameter `Sized? T` could be bound to a sized\n+        // type. (Issue #20116)\n+        //\n+        // To handle this, we first check for \"interior\" type\n+        // parameters, which are always illegal. If there are none of\n+        // those, then we know that the only way that all type\n+        // parameters `T` are referenced indirectly, e.g. via a\n+        // pointer type like `&T`. In that case, we only care whether\n+        // `T` is sized or not, because that influences whether `&T`\n+        // is a thin or fat pointer.\n+        //\n+        // One could imagine establishing a sophisticated constraint\n+        // system to ensure that the transmute is legal, but instead\n+        // we do something brutally dumb. We just substitute dummy\n+        // sized or unsized types for every type parameter in scope,\n+        // exhaustively checking all possible combinations. Here are some examples:\n+        //\n+        // ```\n+        // fn foo<T,U>() {\n+        //     // T=int, U=int\n+        // }\n+        //\n+        // fn bar<Sized? T,U>() {\n+        //     // T=int, U=int\n+        //     // T=[int], U=int\n+        // }\n+        //\n+        // fn baz<Sized? T, Sized?U>() {\n+        //     // T=int, U=int\n+        //     // T=[int], U=int\n+        //     // T=int, U=[int]\n+        //     // T=[int], U=[int]\n+        // }\n+        // ```\n+        //\n+        // In all cases, we keep the original unsubstituted types\n+        // around for error reporting.\n+\n+        let from_tc = ty::type_contents(self.tcx, from);\n+        let to_tc = ty::type_contents(self.tcx, to);\n+        if from_tc.interior_param() || to_tc.interior_param() {\n             span_err!(self.tcx.sess, span, E0139,\n-                      \"cannot transmute from a type that contains type parameters\");\n+                      \"cannot transmute to or from a type that contains \\\n+                       type parameters in its interior\");\n+            return;\n         }\n-        if type_size_is_affected_by_type_parameters(self.tcx, to) {\n-            span_err!(self.tcx.sess, span, E0140,\n-                      \"cannot transmute to a type that contains type parameters\");\n+\n+        let mut substs = param_env.free_substs.clone();\n+        self.with_each_combination(\n+            param_env,\n+            param_env.free_substs.types.iter_enumerated(),\n+            &mut substs,\n+            &mut |substs| {\n+                let restriction = TransmuteRestriction {\n+                    span: span,\n+                    original_from: from,\n+                    original_to: to,\n+                    substituted_from: from.subst(self.tcx, substs),\n+                    substituted_to: to.subst(self.tcx, substs),\n+                    id: id,\n+                };\n+                self.push_transmute_restriction(restriction);\n+            });\n+    }\n+\n+    fn with_each_combination(&self,\n+                             param_env: &ty::ParameterEnvironment<'tcx>,\n+                             mut types_in_scope: EnumeratedItems<Ty<'tcx>>,\n+                             substs: &mut Substs<'tcx>,\n+                             callback: &mut FnMut(&Substs<'tcx>))\n+    {\n+        // This parameter invokes `callback` many times with different\n+        // substitutions that replace all the parameters in scope with\n+        // either `int` or `[int]`, depending on whether the type\n+        // parameter is known to be sized. See big comment above for\n+        // an explanation of why this is a reasonable thing to do.\n+\n+        match types_in_scope.next() {\n+            None => {\n+                debug!(\"with_each_combination(substs={})\",\n+                       substs.repr(self.tcx));\n+\n+                callback.call_mut((substs,));\n+            }\n+\n+            Some((space, index, &param_ty)) => {\n+                debug!(\"with_each_combination: space={}, index={}, param_ty={}\",\n+                       space, index, param_ty.repr(self.tcx));\n+\n+                if !ty::type_is_sized(self.tcx, param_ty, param_env) {\n+                    debug!(\"with_each_combination: param_ty is not known to be sized\");\n+\n+                    substs.types.get_mut_slice(space)[index] = self.dummy_unsized_ty;\n+                    self.with_each_combination(param_env, types_in_scope.clone(), substs, callback);\n+                }\n+\n+                substs.types.get_mut_slice(space)[index] = self.dummy_sized_ty;\n+                self.with_each_combination(param_env, types_in_scope, substs, callback);\n+            }\n         }\n+    }\n \n-        let restriction = TransmuteRestriction {\n-            span: span,\n-            from: from,\n-            to: to,\n-            id: id,\n-        };\n+    fn push_transmute_restriction(&self, restriction: TransmuteRestriction<'tcx>) {\n+        debug!(\"Pushing transmute restriction: {}\", restriction.repr(self.tcx));\n         self.tcx.transmute_restrictions.borrow_mut().push(restriction);\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n+    fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, s: Span, id: ast::NodeId) {\n+        match fk {\n+            visit::FkItemFn(..) | visit::FkMethod(..) => {\n+                let param_env = ty::ParameterEnvironment::for_item(self.tcx, id);\n+                self.param_envs.push(param_env);\n+                visit::walk_fn(self, fk, fd, b, s);\n+                self.param_envs.pop();\n+            }\n+            visit::FkFnBlock(..) => {\n+                visit::walk_fn(self, fk, fd, b, s);\n+            }\n+        }\n+\n+    }\n+\n     fn visit_expr(&mut self, expr: &ast::Expr) {\n         if let ast::ExprPath(..) = expr.node {\n             match ty::resolve_expr(self.tcx, expr) {\n@@ -144,7 +273,13 @@ impl<'a, 'tcx, 'v> Visitor<'v> for IntrinsicCheckingVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ctxt) {\n-    visit::walk_crate(&mut IntrinsicCheckingVisitor { tcx: tcx },\n-                      tcx.map.krate());\n+impl<'tcx> Repr<'tcx> for TransmuteRestriction<'tcx> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"TransmuteRestriction(id={}, original=({},{}), substituted=({},{}))\",\n+                self.id,\n+                self.original_from.repr(tcx),\n+                self.original_to.repr(tcx),\n+                self.substituted_from.repr(tcx),\n+                self.substituted_to.repr(tcx))\n+    }\n }"}, {"sha": "8d920e0a8211f8c92412b9aed732112fe8096315", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -487,6 +487,7 @@ impl<T> VecPerParamSpace<T> {\n     }\n }\n \n+#[deriving(Clone)]\n pub struct EnumeratedItems<'a,T:'a> {\n     vec: &'a VecPerParamSpace<T>,\n     space_index: uint,"}, {"sha": "b3e9f85c69c786c2a5c8ef2956e3c155c92e46d2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 41, "deletions": 66, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -62,7 +62,7 @@ use middle::ty_fold::{mod, TypeFoldable, TypeFolder};\n use util::ppaux::{note_and_explain_region, bound_region_ptr_to_string};\n use util::ppaux::{trait_store_to_string, ty_to_string};\n use util::ppaux::{Repr, UserString};\n-use util::common::{indenter, memoized, ErrorReported};\n+use util::common::{memoized, ErrorReported};\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n use util::nodemap::{FnvHashMap};\n \n@@ -590,16 +590,33 @@ pub enum vtable_origin<'tcx> {\n pub type ObjectCastMap<'tcx> = RefCell<NodeMap<Rc<ty::PolyTraitRef<'tcx>>>>;\n \n /// A restriction that certain types must be the same size. The use of\n-/// `transmute` gives rise to these restrictions.\n+/// `transmute` gives rise to these restrictions. These generally\n+/// cannot be checked until trans; therefore, each call to `transmute`\n+/// will push one or more such restriction into the\n+/// `transmute_restrictions` vector during `intrinsicck`. They are\n+/// then checked during `trans` by the fn `check_intrinsics`.\n #[deriving(Copy)]\n pub struct TransmuteRestriction<'tcx> {\n-    /// The span from whence the restriction comes.\n+    /// The span whence the restriction comes.\n     pub span: Span,\n+\n     /// The type being transmuted from.\n-    pub from: Ty<'tcx>,\n+    pub original_from: Ty<'tcx>,\n+\n     /// The type being transmuted to.\n-    pub to: Ty<'tcx>,\n-    /// NodeIf of the transmute intrinsic.\n+    pub original_to: Ty<'tcx>,\n+\n+    /// The type being transmuted from, with all type parameters\n+    /// substituted for an arbitrary representative. Not to be shown\n+    /// to the end user.\n+    pub substituted_from: Ty<'tcx>,\n+\n+    /// The type being transmuted to, with all type parameters\n+    /// substituted for an arbitrary representative. Not to be shown\n+    /// to the end user.\n+    pub substituted_to: Ty<'tcx>,\n+\n+    /// NodeId of the transmute intrinsic.\n     pub id: ast::NodeId,\n }\n \n@@ -2856,6 +2873,7 @@ def_type_content_sets! {\n         // Things that are interior to the value (first nibble):\n         InteriorUnsized                     = 0b0000_0000__0000_0000__0001,\n         InteriorUnsafe                      = 0b0000_0000__0000_0000__0010,\n+        InteriorParam                       = 0b0000_0000__0000_0000__0100,\n         // InteriorAll                         = 0b00000000__00000000__1111,\n \n         // Things that are owned by the value (second and third nibbles):\n@@ -2910,6 +2928,10 @@ impl TypeContents {\n         !self.intersects(TC::Nonsized)\n     }\n \n+    pub fn interior_param(&self) -> bool {\n+        self.intersects(TC::InteriorParam)\n+    }\n+\n     pub fn interior_unsafe(&self) -> bool {\n         self.intersects(TC::InteriorUnsafe)\n     }\n@@ -3038,7 +3060,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_closure(ref c) => {\n-                closure_contents(cx, &**c) | TC::ReachesFfiUnsafe\n+                closure_contents(&**c) | TC::ReachesFfiUnsafe\n             }\n \n             ty_uniq(typ) => {\n@@ -3049,7 +3071,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_trait(box TyTrait { bounds, .. }) => {\n-                object_contents(cx, bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n+                object_contents(bounds) | TC::ReachesFfiUnsafe | TC::Nonsized\n             }\n \n             ty_ptr(ref mt) => {\n@@ -3159,26 +3181,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 apply_lang_items(cx, did, res)\n             }\n \n-            ty_param(p) => {\n-                // We only ever ask for the kind of types that are defined in\n-                // the current crate; therefore, the only type parameters that\n-                // could be in scope are those defined in the current crate.\n-                // If this assertion fails, it is likely because of a\n-                // failure of the cross-crate inlining code to translate a\n-                // def-id.\n-                assert_eq!(p.def_id.krate, ast::LOCAL_CRATE);\n-\n-                let ty_param_defs = cx.ty_param_defs.borrow();\n-                let tp_def = &(*ty_param_defs)[p.def_id.node];\n-                kind_bounds_to_contents(\n-                    cx,\n-                    tp_def.bounds.builtin_bounds,\n-                    tp_def.bounds.trait_bounds[])\n-            }\n-\n-            ty_infer(_) => {\n-                // This occurs during coherence, but shouldn't occur at other\n-                // times.\n+            ty_param(_) => {\n                 TC::All\n             }\n \n@@ -3188,6 +3191,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n                 result.unsafe_pointer() | TC::Nonsized\n             }\n \n+            ty_infer(_) |\n             ty_err => {\n                 cx.sess.bug(\"asked to compute contents of error type\");\n             }\n@@ -3227,10 +3231,10 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         b | (TC::ReachesBorrowed).when(region != ty::ReStatic)\n     }\n \n-    fn closure_contents(cx: &ctxt, cty: &ClosureTy) -> TypeContents {\n+    fn closure_contents(cty: &ClosureTy) -> TypeContents {\n         // Closure contents are just like trait contents, but with potentially\n         // even more stuff.\n-        let st = object_contents(cx, cty.bounds);\n+        let st = object_contents(cty.bounds);\n \n         let st = match cty.store {\n             UniqTraitStore => {\n@@ -3244,47 +3248,18 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n         st\n     }\n \n-    fn object_contents(cx: &ctxt,\n-                       bounds: ExistentialBounds)\n-                       -> TypeContents {\n-        // These are the type contents of the (opaque) interior\n-        kind_bounds_to_contents(cx, bounds.builtin_bounds, &[])\n-    }\n-\n-    fn kind_bounds_to_contents<'tcx>(cx: &ctxt<'tcx>,\n-                                     bounds: BuiltinBounds,\n-                                     traits: &[Rc<PolyTraitRef<'tcx>>])\n-                                     -> TypeContents {\n-        let _i = indenter();\n-        let mut tc = TC::All;\n-        each_inherited_builtin_bound(cx, bounds, traits, |bound| {\n+    fn object_contents(bounds: ExistentialBounds) -> TypeContents {\n+        // These are the type contents of the (opaque) interior. We\n+        // make no assumptions (other than that it cannot have an\n+        // in-scope type parameter within, which makes no sense).\n+        let mut tc = TC::All - TC::InteriorParam;\n+        for bound in bounds.builtin_bounds.iter() {\n             tc = tc - match bound {\n                 BoundSync | BoundSend | BoundCopy => TC::None,\n                 BoundSized => TC::Nonsized,\n             };\n-        });\n-        return tc;\n-\n-        // Iterates over all builtin bounds on the type parameter def, including\n-        // those inherited from traits with builtin-kind-supertraits.\n-        fn each_inherited_builtin_bound<'tcx, F>(cx: &ctxt<'tcx>,\n-                                                 bounds: BuiltinBounds,\n-                                                 traits: &[Rc<PolyTraitRef<'tcx>>],\n-                                                 mut f: F) where\n-            F: FnMut(BuiltinBound),\n-        {\n-            for bound in bounds.iter() {\n-                f(bound);\n-            }\n-\n-            each_bound_trait_and_supertraits(cx, traits, |trait_ref| {\n-                let trait_def = lookup_trait_def(cx, trait_ref.def_id());\n-                for bound in trait_def.bounds.builtin_bounds.iter() {\n-                    f(bound);\n-                }\n-                true\n-            });\n         }\n+        return tc;\n     }\n }\n "}, {"sha": "d49018e00c1cbb6078b47430ecd15ddda3aa6602", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -32,7 +32,7 @@ use middle::ty::{mod, Ty};\n use syntax::abi::RustIntrinsic;\n use syntax::ast;\n use syntax::parse::token;\n-use util::ppaux::ty_to_string;\n+use util::ppaux::{Repr, ty_to_string};\n \n pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Option<ValueRef> {\n     let name = match token::get_ident(item.ident).get() {\n@@ -90,46 +90,53 @@ pub fn get_simple_intrinsic(ccx: &CrateContext, item: &ast::ForeignItem) -> Opti\n /// Performs late verification that intrinsics are used correctly. At present,\n /// the only intrinsic that needs such verification is `transmute`.\n pub fn check_intrinsics(ccx: &CrateContext) {\n-    for transmute_restriction in ccx.tcx()\n-                                    .transmute_restrictions\n-                                    .borrow()\n-                                    .iter() {\n+    let mut last_failing_id = None;\n+    for transmute_restriction in ccx.tcx().transmute_restrictions.borrow().iter() {\n+        // Sometimes, a single call to transmute will push multiple\n+        // type pairs to test in order to exhaustively test the\n+        // possibility around a type parameter. If one of those fails,\n+        // there is no sense reporting errors on the others.\n+        if last_failing_id == Some(transmute_restriction.id) {\n+            continue;\n+        }\n+\n+        debug!(\"transmute_restriction: {}\", transmute_restriction.repr(ccx.tcx()));\n+\n+        assert!(!ty::type_has_params(transmute_restriction.substituted_from));\n+        assert!(!ty::type_has_params(transmute_restriction.substituted_to));\n+\n         let llfromtype = type_of::sizing_type_of(ccx,\n-                                                 transmute_restriction.from);\n+                                                 transmute_restriction.substituted_from);\n         let lltotype = type_of::sizing_type_of(ccx,\n-                                               transmute_restriction.to);\n+                                               transmute_restriction.substituted_to);\n         let from_type_size = machine::llbitsize_of_real(ccx, llfromtype);\n         let to_type_size = machine::llbitsize_of_real(ccx, lltotype);\n         if from_type_size != to_type_size {\n-            ccx.sess()\n-               .span_err(transmute_restriction.span,\n-                format!(\"transmute called on types with different sizes: \\\n-                         {} ({} bit{}) to {} ({} bit{})\",\n-                        ty_to_string(ccx.tcx(), transmute_restriction.from),\n-                        from_type_size as uint,\n-                        if from_type_size == 1 {\n-                            \"\"\n-                        } else {\n-                            \"s\"\n-                        },\n-                        ty_to_string(ccx.tcx(), transmute_restriction.to),\n-                        to_type_size as uint,\n-                        if to_type_size == 1 {\n-                            \"\"\n-                        } else {\n-                            \"s\"\n-                        })[]);\n-        }\n-        if type_is_fat_ptr(ccx.tcx(), transmute_restriction.to) ||\n-           type_is_fat_ptr(ccx.tcx(), transmute_restriction.from) {\n-            ccx.sess()\n-               .add_lint(::lint::builtin::FAT_PTR_TRANSMUTES,\n-                         transmute_restriction.id,\n-                         transmute_restriction.span,\n-                         format!(\"Transmuting fat pointer types; {} to {}.\\\n-                                  Beware of relying on the compiler's representation\",\n-                                 ty_to_string(ccx.tcx(), transmute_restriction.from),\n-                                 ty_to_string(ccx.tcx(), transmute_restriction.to)));\n+            last_failing_id = Some(transmute_restriction.id);\n+\n+            if transmute_restriction.original_from != transmute_restriction.substituted_from {\n+                ccx.sess().span_err(\n+                    transmute_restriction.span,\n+                    format!(\"transmute called on types with potentially different sizes: \\\n+                             {} (could be {} bit{}) to {} (could be {} bit{})\",\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                            from_type_size as uint,\n+                            if from_type_size == 1 {\"\"} else {\"s\"},\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                            to_type_size as uint,\n+                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+            } else {\n+                ccx.sess().span_err(\n+                    transmute_restriction.span,\n+                    format!(\"transmute called on types with different sizes: \\\n+                             {} ({} bit{}) to {} ({} bit{})\",\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_from),\n+                            from_type_size as uint,\n+                            if from_type_size == 1 {\"\"} else {\"s\"},\n+                            ty_to_string(ccx.tcx(), transmute_restriction.original_to),\n+                            to_type_size as uint,\n+                            if to_type_size == 1 {\"\"} else {\"s\"}).as_slice());\n+            }\n         }\n     }\n     ccx.sess().abort_if_errors();"}, {"sha": "5c61212a7f5a56324b4c7388acc6dcdd03e09315", "filename": "src/test/compile-fail/transmute-different-sizes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-different-sizes.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -21,7 +21,7 @@ unsafe fn f() {\n \n unsafe fn g<T>(x: &T) {\n     let _: i8 = transmute(x);\n-    //~^ ERROR transmute called on types with different sizes\n+    //~^ ERROR transmute called on types with potentially different sizes\n }\n \n fn main() {}"}, {"sha": "5e81a4cec2284b915ad942b53294dfbc8ca9b0d2", "filename": "src/test/compile-fail/transmute-fat-pointers.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-fat-pointers.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that are conservative around thin/fat pointer mismatches.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+\n+fn a<T, Sized? U>(x: &[T]) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn b<Sized? T, Sized? U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn c<T, U>(x: &T) -> &U {\n+    unsafe { transmute(x) }\n+}\n+\n+fn d<T, U>(x: &[T]) -> &[U] {\n+    unsafe { transmute(x) }\n+}\n+\n+fn e<Sized? T, U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn f<T, Sized? U>(x: &T) -> &U {\n+    unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+}\n+\n+fn main() { }"}, {"sha": "8b5a8c679b245b6392883f23c1cda222c5038fa5", "filename": "src/test/compile-fail/transmute-impl.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5edd22646fcde05b39490558371c7ea9d525a0f/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftransmute-impl.rs?ref=c5edd22646fcde05b39490558371c7ea9d525a0f", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Tests that are conservative around thin/fat pointer mismatches.\n+\n+#![allow(dead_code)]\n+\n+use std::mem::transmute;\n+\n+struct Foo<Sized? T> {\n+    t: Box<T>\n+}\n+\n+impl<Sized? T> Foo<T> {\n+    fn m(x: &T) -> &int where T : Sized {\n+        // OK here, because T : Sized is in scope.\n+        unsafe { transmute(x) }\n+    }\n+\n+    fn n(x: &T) -> &int {\n+        // Not OK here, because T : Sized is not in scope.\n+        unsafe { transmute(x) } //~ ERROR transmute called on types with potentially different sizes\n+    }\n+}\n+\n+fn main() { }"}]}