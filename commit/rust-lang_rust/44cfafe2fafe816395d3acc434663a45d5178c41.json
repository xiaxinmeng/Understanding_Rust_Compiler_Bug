{"sha": "44cfafe2fafe816395d3acc434663a45d5178c41", "node_id": "C_kwDOAAsO6NoAKDQ0Y2ZhZmUyZmFmZTgxNjM5NWQzYWNjNDM0NjYzYTQ1ZDUxNzhjNDE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T19:57:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-03T19:57:10Z"}, "message": "Auto merge of #108707 - matthiaskrgr:rollup-9a2l6pc, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #107981 (new solver: implement canonicalization and region constraints)\n - #108553 (Deny capturing late-bound non-lifetime param in anon const)\n - #108599 (Remove legacy PM leftovers)\n - #108667 (Fix another ICE in `point_at_expr_source_of_inferred_type`)\n - #108674 (Clippy Fix array-size-threshold config deserialization error)\n - #108685 (Match unmatched backticks in compiler/)\n - #108694 (Match unmatched backticks in compiler/ comments)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "7752d393b7fac05f43f2cca290838a22987d4b7f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7752d393b7fac05f43f2cca290838a22987d4b7f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/44cfafe2fafe816395d3acc434663a45d5178c41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/44cfafe2fafe816395d3acc434663a45d5178c41", "html_url": "https://github.com/rust-lang/rust/commit/44cfafe2fafe816395d3acc434663a45d5178c41", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/44cfafe2fafe816395d3acc434663a45d5178c41/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a809ce8997a1697b166b4bb2594993e87d69f31", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a809ce8997a1697b166b4bb2594993e87d69f31", "html_url": "https://github.com/rust-lang/rust/commit/7a809ce8997a1697b166b4bb2594993e87d69f31"}, {"sha": "01fc5a765353741ee0a2597bd48283368253e9b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/01fc5a765353741ee0a2597bd48283368253e9b6", "html_url": "https://github.com/rust-lang/rust/commit/01fc5a765353741ee0a2597bd48283368253e9b6"}], "stats": {"total": 1308, "additions": 1086, "deletions": 222}, "files": [{"sha": "3a0af04f9eb98c11304f140d06ba09d0763fc4a3", "filename": "compiler/rustc_ast/src/util/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Futil%2Fparser.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -225,7 +225,7 @@ impl AssocOp {\n             AssignOp(_) | // `{ 42 } +=`\n             As | // `{ 42 } as usize`\n             // Equal | // `{ 42 } == { 42 }`    Accepting these here would regress incorrect\n-            // NotEqual | // `{ 42 } != { 42 }  struct literals parser recovery.\n+            // NotEqual | // `{ 42 } != { 42 }` struct literals parser recovery.\n             Colon, // `{ 42 }: usize`\n         )\n     }"}, {"sha": "b20157f2c7c8985ad8832ba0364e63eaafeb0b69", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1607,7 +1607,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::OwnerNode::Item(self.arena.alloc(opaque_ty_item))\n     }\n \n-    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds and a `remapping` hash to be\n+    /// Given a `parent_def_id`, a list of `lifetimes_in_bounds` and a `remapping` hash to be\n     /// filled, this function creates new definitions for `Param` and `Fresh` lifetimes, inserts the\n     /// new definition, adds it to the remapping with the definition of the given lifetime and\n     /// returns a list of lifetimes to be lowered afterwards."}, {"sha": "2cc009410f40753b3ba44378563a9123ddff3b63", "filename": "compiler/rustc_ast_passes/src/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_passes%2Fsrc%2Fast_validation.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -192,7 +192,7 @@ impl<'a> AstValidator<'a> {\n                 // We allow these:\n                 //  - `Option<impl Trait>`\n                 //  - `option::Option<impl Trait>`\n-                //  - `option::Option<T>::Foo<impl Trait>\n+                //  - `option::Option<T>::Foo<impl Trait>`\n                 //\n                 // But not these:\n                 //  - `<impl Trait>::Foo`"}, {"sha": "ffe82b46cfd678ae4fa1921b821a180f135d54d1", "filename": "compiler/rustc_borrowck/src/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fregion_errors.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -415,7 +415,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n     /// fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n     /// ```\n     ///\n-    /// Here we would be invoked with `fr = 'a` and `outlived_fr = `'b`.\n+    /// Here we would be invoked with `fr = 'a` and `outlived_fr = 'b`.\n     pub(crate) fn report_region_error(\n         &mut self,\n         fr: RegionVid,\n@@ -949,7 +949,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                     .push_span_label(*span, \"this has an implicit `'static` lifetime requirement\");\n                 multi_span.push_span_label(\n                     ident.span,\n-                    \"calling this method introduces the `impl`'s 'static` requirement\",\n+                    \"calling this method introduces the `impl`'s `'static` requirement\",\n                 );\n                 err.subdiagnostic(RequireStaticErr::UsedImpl { multi_span });\n                 err.span_suggestion_verbose("}, {"sha": "21b5bd7cb94dea7be8e2be6e147ad277bd0309ff", "filename": "compiler/rustc_borrowck/src/region_infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -889,7 +889,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// from a universe it can't name; at present, the only way for\n     /// this to be true is if `scc` outlives `'static`. This is\n     /// actually stricter than necessary: ideally, we'd support bounds\n-    /// like `for<'a: 'b`>` that might then allow us to approximate\n+    /// like `for<'a: 'b>` that might then allow us to approximate\n     /// `'a` with `'b` and not `'static`. But it will have to do for\n     /// now.\n     fn add_incompatible_universe(&mut self, scc: ConstraintSccIndex) {"}, {"sha": "8132800f107a7b385680235bb0622a267e558776", "filename": "compiler/rustc_borrowck/src/region_infer/values.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fregion_infer%2Fvalues.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -235,7 +235,7 @@ pub(crate) struct RegionValues<N: Idx> {\n     free_regions: SparseBitMatrix<N, RegionVid>,\n \n     /// Placeholders represent bound regions -- so something like `'a`\n-    /// in for<'a> fn(&'a u32)`.\n+    /// in `for<'a> fn(&'a u32)`.\n     placeholders: SparseBitMatrix<N, PlaceholderIndex>,\n }\n "}, {"sha": "253c2ca7c768e15a59ad1dd73728506a9c648dd0", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1814,8 +1814,6 @@ extern \"C\" {\n     /// Creates a legacy pass manager -- only used for final codegen.\n     pub fn LLVMCreatePassManager<'a>() -> &'a mut PassManager<'a>;\n \n-    pub fn LLVMInitializePasses();\n-\n     pub fn LLVMTimeTraceProfilerInitialize();\n \n     pub fn LLVMTimeTraceProfilerFinishThread();"}, {"sha": "ba58a2e68e91b75b319822783db4b4bef383b832", "filename": "compiler/rustc_codegen_llvm/src/llvm_util.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm_util.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -120,8 +120,6 @@ unsafe fn configure_llvm(sess: &Session) {\n         llvm::LLVMTimeTraceProfilerInitialize();\n     }\n \n-    llvm::LLVMInitializePasses();\n-\n     rustc_llvm::initialize_available_targets();\n \n     llvm::LLVMRustSetLLVMOptions(llvm_args.len() as c_int, llvm_args.as_ptr());"}, {"sha": "9ad945359b6b3989f9cbf7be39e48a41db34dcb3", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -457,7 +457,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 assert_eq!(input_len, dest_len, \"Return vector length must match input length\");\n                 assert!(\n                     index < dest_len,\n-                    \"Index `{}` must be in bounds of vector with length {}`\",\n+                    \"Index `{}` must be in bounds of vector with length {}\",\n                     index,\n                     dest_len\n                 );\n@@ -477,7 +477,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (input, input_len) = self.operand_to_simd(&args[0])?;\n                 assert!(\n                     index < input_len,\n-                    \"index `{}` must be in bounds of vector with length `{}`\",\n+                    \"index `{}` must be in bounds of vector with length {}\",\n                     index,\n                     input_len\n                 );"}, {"sha": "aa24d9053b98a78b614f753c02c03b6084924e5d", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -332,7 +332,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n \n     fn check_static(&mut self, def_id: DefId, span: Span) {\n         if self.tcx.is_thread_local_static(def_id) {\n-            self.tcx.sess.delay_span_bug(span, \"tls access is checked in `Rvalue::ThreadLocalRef\");\n+            self.tcx.sess.delay_span_bug(span, \"tls access is checked in `Rvalue::ThreadLocalRef`\");\n         }\n         self.check_op_spanned(ops::StaticAccess, span)\n     }"}, {"sha": "724be5888ddb46da7e35744835fc60aeb15e331f", "filename": "compiler/rustc_data_structures/src/stable_hasher/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fstable_hasher%2Ftests.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -150,7 +150,7 @@ fn test_isize_compression() {\n         let hash_b = hash(&(b as isize, a as isize));\n         assert_ne!(\n             hash_a, hash_b,\n-            \"The hash stayed the same when permuting values `{a}` and `{b}!\",\n+            \"The hash stayed the same when permuting values `{a}` and `{b}`!\",\n         );\n     }\n "}, {"sha": "47a8b4bc48885515c701122f62ee6622b0113373", "filename": "compiler/rustc_expand/src/mbe/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Ftranscribe.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -282,7 +282,7 @@ pub(super) fn transcribe<'a>(\n             }\n \n             // There should be no meta-var declarations in the invocation of a macro.\n-            mbe::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl\"),\n+            mbe::TokenTree::MetaVarDecl(..) => panic!(\"unexpected `TokenTree::MetaVarDecl`\"),\n         }\n     }\n }"}, {"sha": "1d313945b529cc0d12fc1b038ab387dd38d62ccb", "filename": "compiler/rustc_hir_analysis/locales/en-US.ftl", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Flocales%2Fen-US.ftl?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -147,3 +147,11 @@ hir_analysis_main_function_generic_parameters = `main` function is not allowed t\n \n hir_analysis_variadic_function_compatible_convention = C-variadic function must have a compatible calling convention, like {$conventions}\n     .label = C-variadic function must have a compatible calling convention\n+\n+hir_analysis_cannot_capture_late_bound_ty_in_anon_const =\n+    cannot capture late-bound type parameter in a constant\n+    .label = parameter defined here\n+\n+hir_analysis_cannot_capture_late_bound_const_in_anon_const =\n+    cannot capture late-bound const parameter in a constant\n+    .label = parameter defined here"}, {"sha": "691d3f8d942b3f0c7806ab495444a7185d70070c", "filename": "compiler/rustc_hir_analysis/src/check/compare_impl_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcompare_impl_item.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1873,7 +1873,7 @@ pub(super) fn check_type_bounds<'tcx>(\n     //     type Bar<C> =...\n     // }\n     //\n-    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>\n+    // - `impl_trait_ref` would be `<(A, B) as Foo<u32>>`\n     // - `impl_ty_substs` would be `[A, B, ^0.0]` (`^0.0` here is the bound var with db 0 and index 0)\n     // - `rebased_substs` would be `[(A, B), u32, ^0.0]`, combining the substs from\n     //    the *trait* with the generic associated type parameters (as bound vars)."}, {"sha": "ffb68abf978de6a34c2360d02edd207c0ac3c658", "filename": "compiler/rustc_hir_analysis/src/coherence/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcoherence%2Fbuiltin.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -437,7 +437,7 @@ pub fn coerce_unsized_info<'tcx>(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUn\n             }\n \n             // Here we are considering a case of converting\n-            // `S<P0...Pn>` to S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n+            // `S<P0...Pn>` to `S<Q0...Qn>`. As an example, let's imagine a struct `Foo<T, U>`,\n             // which acts like a pointer to `U`, but carries along some extra data of type `T`:\n             //\n             //     struct Foo<T, U> {"}, {"sha": "65a9052a60ae0866004b82493e0bc119d83ddd39", "filename": "compiler/rustc_hir_analysis/src/collect/resolve_bound_vars.rs", "status": "modified", "additions": 57, "deletions": 5, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fresolve_bound_vars.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -24,6 +24,8 @@ use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n use std::fmt;\n \n+use crate::errors;\n+\n trait RegionExt {\n     fn early(param: &GenericParam<'_>) -> (LocalDefId, ResolvedArg);\n \n@@ -161,6 +163,15 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n+    /// Disallows capturing non-lifetime binders from parent scopes.\n+    ///\n+    /// This is necessary for something like `for<T> [(); { /* references T */ }]:`,\n+    /// since we don't do something more correct like replacing any captured\n+    /// late-bound vars with early-bound params in the const's own generics.\n+    AnonConstBoundary {\n+        s: ScopeRef<'a>,\n+    },\n+\n     Root {\n         opt_parent_item: Option<LocalDefId>,\n     },\n@@ -211,6 +222,7 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::TraitRefBoundary { s: _ } => f.debug_struct(\"TraitRefBoundary\").finish(),\n+            Scope::AnonConstBoundary { s: _ } => f.debug_struct(\"AnonConstBoundary\").finish(),\n             Scope::Root { opt_parent_item } => {\n                 f.debug_struct(\"Root\").field(\"opt_parent_item\", &opt_parent_item).finish()\n             }\n@@ -312,7 +324,9 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                     break (vec![], BinderScopeType::Normal);\n                 }\n \n-                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n \n@@ -1029,6 +1043,12 @@ impl<'a, 'tcx> Visitor<'tcx> for BoundVarContext<'a, 'tcx> {\n     fn visit_poly_trait_ref(&mut self, trait_ref: &'tcx hir::PolyTraitRef<'tcx>) {\n         self.visit_poly_trait_ref_inner(trait_ref, NonLifetimeBinderAllowed::Allow);\n     }\n+\n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        self.with(Scope::AnonConstBoundary { s: self.scope }, |this| {\n+            intravisit::walk_anon_const(this, c);\n+        });\n+    }\n }\n \n fn object_lifetime_default(tcx: TyCtxt<'_>, param_def_id: DefId) -> ObjectLifetimeDefault {\n@@ -1275,7 +1295,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }\n@@ -1340,7 +1361,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 | Scope::Elision { s, .. }\n                 | Scope::ObjectLifetimeDefault { s, .. }\n                 | Scope::Supertrait { s, .. }\n-                | Scope::TraitRefBoundary { s, .. } => {\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }\n@@ -1359,6 +1381,7 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n         // search.\n         let mut late_depth = 0;\n         let mut scope = self.scope;\n+        let mut crossed_anon_const = false;\n         let result = loop {\n             match *scope {\n                 Scope::Body { s, .. } => {\n@@ -1392,10 +1415,36 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                 | Scope::TraitRefBoundary { s, .. } => {\n                     scope = s;\n                 }\n+\n+                Scope::AnonConstBoundary { s } => {\n+                    crossed_anon_const = true;\n+                    scope = s;\n+                }\n             }\n         };\n \n         if let Some(def) = result {\n+            if let ResolvedArg::LateBound(..) = def && crossed_anon_const {\n+                let use_span = self.tcx.hir().span(hir_id);\n+                let def_span = self.tcx.def_span(param_def_id);\n+                match self.tcx.def_kind(param_def_id) {\n+                    DefKind::ConstParam => {\n+                        self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Const {\n+                            use_span,\n+                            def_span,\n+                        });\n+                    }\n+                    DefKind::TyParam => {\n+                        self.tcx.sess.emit_err(errors::CannotCaptureLateBoundInAnonConst::Type {\n+                            use_span,\n+                            def_span,\n+                        });\n+                    }\n+                    _ => unreachable!(),\n+                }\n+                return;\n+            }\n+\n             self.map.defs.insert(hir_id, def);\n             return;\n         }\n@@ -1474,7 +1523,8 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n                         | Scope::Elision { s, .. }\n                         | Scope::ObjectLifetimeDefault { s, .. }\n                         | Scope::Supertrait { s, .. }\n-                        | Scope::TraitRefBoundary { s, .. } => {\n+                        | Scope::TraitRefBoundary { s, .. }\n+                        | Scope::AnonConstBoundary { s } => {\n                             scope = s;\n                         }\n                     }\n@@ -1710,7 +1760,9 @@ impl<'a, 'tcx> BoundVarContext<'a, 'tcx> {\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n \n-                Scope::Supertrait { s, .. } | Scope::TraitRefBoundary { s, .. } => {\n+                Scope::Supertrait { s, .. }\n+                | Scope::TraitRefBoundary { s, .. }\n+                | Scope::AnonConstBoundary { s } => {\n                     scope = s;\n                 }\n             }"}, {"sha": "3e0692757754fa20e75d40b2c6653da8d10bb3b8", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -381,3 +381,21 @@ pub(crate) struct VariadicFunctionCompatibleConvention<'a> {\n     pub span: Span,\n     pub conventions: &'a str,\n }\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum CannotCaptureLateBoundInAnonConst {\n+    #[diag(hir_analysis_cannot_capture_late_bound_ty_in_anon_const)]\n+    Type {\n+        #[primary_span]\n+        use_span: Span,\n+        #[label]\n+        def_span: Span,\n+    },\n+    #[diag(hir_analysis_cannot_capture_late_bound_const_in_anon_const)]\n+    Const {\n+        #[primary_span]\n+        use_span: Span,\n+        #[label]\n+        def_span: Span,\n+    },\n+}"}, {"sha": "7ba57b3b7a266d51761aa538e0d897ad5a67bea9", "filename": "compiler/rustc_hir_typeck/src/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fdemand.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -315,7 +315,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     probe::ProbeScope::TraitsInScope,\n                     None,\n                 ) {\n-                    Ok(pick) => pick.self_ty,\n+                    Ok(pick) => eraser.fold_ty(pick.self_ty),\n                     Err(_) => rcvr_ty,\n                 };\n                 // Remove one layer of references to account for `&mut self` and"}, {"sha": "4d3969d28aa2d6f95ab1f97fbc6e919eb85d64a4", "filename": "compiler/rustc_hir_typeck/src/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmem_categorization.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -636,7 +636,7 @@ impl<'a, 'tcx> MemCategorizationContext<'a, 'tcx> {\n         // `&&Some(x,)` `place_foo`\n         //  `&Some(x,)` `deref { place_foo}`\n         //   `Some(x,)` `deref { deref { place_foo }}`\n-        //        (x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n+        //       `(x,)` `field0 { deref { deref { place_foo }}}` <- resulting place\n         //\n         // The above example has no adjustments. If the code were instead the (after adjustments,\n         // equivalent) version"}, {"sha": "4a432328c4d1bcb7891ccb8d8aeaea5d1c532ecf", "filename": "compiler/rustc_hir_typeck/src/upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fupvar.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -2223,7 +2223,7 @@ fn determine_place_ancestry_relation<'tcx>(\n ///     || drop(&*m.a.field_of_a)\n ///     // Here we really do want to capture `*m.a` because that outlives `'static`\n ///\n-///     // If we capture `m`, then the closure no longer outlives `'static'\n+///     // If we capture `m`, then the closure no longer outlives `'static`\n ///     // it is constrained to `'a`\n /// }\n /// ```"}, {"sha": "c550e553bb032990d92d9e19947a0b4d41072163", "filename": "compiler/rustc_incremental/src/assert_module_sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fassert_module_sources.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -18,7 +18,7 @@\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n //!\n-//! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]\n+//! `#![rustc_expected_cgu_reuse(module=\"spike\", cfg=\"rpass2\", kind=\"post-lto\")]`\n //! allows for doing a more fine-grained check to see if pre- or post-lto data\n //! was re-used.\n "}, {"sha": "cbf169afb18c19a84084d6820cc8c9d9d6561a1e", "filename": "compiler/rustc_index/src/bit_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_index%2Fsrc%2Fbit_set.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1870,7 +1870,7 @@ impl<R: Idx, C: Idx> SparseBitMatrix<R, C> {\n         }\n     }\n \n-    /// Subtracts `set from `row`. `set` can be either `BitSet` or\n+    /// Subtracts `set` from `row`. `set` can be either `BitSet` or\n     /// `HybridBitSet`. Has no effect if `row` does not exist.\n     ///\n     /// Returns true if the row was changed."}, {"sha": "e3db44477de4e3ab2c811135bff8e0d6777dabc5", "filename": "compiler/rustc_infer/locales/en-US.ftl", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Flocales%2Fen-US.ftl?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -79,7 +79,7 @@ infer_subtype = ...so that the {$requirement ->\n     [if_else_different] `if` and `else` have incompatible types\n     [no_else] `if` missing an `else` returns `()`\n     [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] #[start]` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n     [intristic_correct_type] intrinsic has the correct type\n     [method_correct_type] method receiver has the correct type\n     *[other] types are compatible\n@@ -92,7 +92,7 @@ infer_subtype_2 = ...so that {$requirement ->\n     [if_else_different] `if` and `else` have incompatible types\n     [no_else] `if` missing an `else` returns `()`\n     [fn_main_correct_type] `main` function has the correct type\n-    [fn_start_correct_type] #[start]` function has the correct type\n+    [fn_start_correct_type] `#[start]` function has the correct type\n     [intristic_correct_type] intrinsic has the correct type\n     [method_correct_type] method receiver has the correct type\n     *[other] types are compatible\n@@ -277,7 +277,7 @@ infer_tid_consider_borrowing = consider borrowing this type parameter in the tra\n infer_tid_param_help = the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n \n infer_dtcs_has_lifetime_req_label = this has an implicit `'static` lifetime requirement\n-infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s 'static` requirement\n+infer_dtcs_introduces_requirement = calling this method introduces the `impl`'s `'static` requirement\n infer_dtcs_has_req_note = the used `impl` has a `'static` requirement\n infer_dtcs_suggestion = consider relaxing the implicit `'static` requirement\n \n@@ -313,7 +313,7 @@ infer_but_needs_to_satisfy = {$has_param_name ->\n         [false] ...and is required to live as long as `'static` here\n     }\n     .used_here = ...is used here...\n-    .introduced_by_bound = 'static` lifetime requirement introduced by this bound\n+    .introduced_by_bound = `'static` lifetime requirement introduced by this bound\n \n infer_more_targeted = {$has_param_name ->\n     [true] `{$param_name}`"}, {"sha": "7d9bae735e55d7e481389b89e025b31f2c2baf32", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -369,6 +369,34 @@ impl<'tcx> ToTrace<'tcx> for Const<'tcx> {\n     }\n }\n \n+impl<'tcx> ToTrace<'tcx> for ty::GenericArg<'tcx> {\n+    fn to_trace(\n+        _: TyCtxt<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n+        a_is_expected: bool,\n+        a: Self,\n+        b: Self,\n+    ) -> TypeTrace<'tcx> {\n+        use GenericArgKind::*;\n+        TypeTrace {\n+            cause: cause.clone(),\n+            values: match (a.unpack(), b.unpack()) {\n+                (Lifetime(a), Lifetime(b)) => Regions(ExpectedFound::new(a_is_expected, a, b)),\n+                (Type(a), Type(b)) => Terms(ExpectedFound::new(a_is_expected, a.into(), b.into())),\n+                (Const(a), Const(b)) => {\n+                    Terms(ExpectedFound::new(a_is_expected, a.into(), b.into()))\n+                }\n+\n+                (Lifetime(_), Type(_) | Const(_))\n+                | (Type(_), Lifetime(_) | Const(_))\n+                | (Const(_), Lifetime(_) | Type(_)) => {\n+                    bug!(\"relating different kinds: {a:?} {b:?}\")\n+                }\n+            },\n+        }\n+    }\n+}\n+\n impl<'tcx> ToTrace<'tcx> for ty::Term<'tcx> {\n     fn to_trace(\n         _: TyCtxt<'tcx>,"}, {"sha": "678c4a0beb63e8421c2bed59c2ac3839625688c0", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -50,7 +50,7 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     /// Like [Self::canonicalize_query], but preserves distinct universes. For\n     /// example, canonicalizing `&'?0: Trait<'?1>`, where `'?0` is in `U1` and\n-    /// `'?1` is in `U3` would be canonicalized to have ?0` in `U1` and `'?1`\n+    /// `'?1` is in `U3` would be canonicalized to have `?0` in `U1` and `'?1`\n     /// in `U2`.\n     ///\n     /// This is used for Chalk integration."}, {"sha": "ce230afdab3ce2629474c4bf2ed8f37c1c6622fa", "filename": "compiler/rustc_infer/src/infer/canonical/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -30,7 +30,7 @@ use rustc_middle::ty::{self, List, TyCtxt};\n use rustc_span::source_map::Span;\n \n pub use rustc_middle::infer::canonical::*;\n-use substitute::CanonicalExt;\n+pub use substitute::CanonicalExt;\n \n mod canonicalizer;\n pub mod query_response;\n@@ -100,7 +100,11 @@ impl<'tcx> InferCtxt<'tcx> {\n     /// variable for it. If this is an existentially quantified\n     /// variable, then you'll get a new inference variable; if it is a\n     /// universally quantified variable, you get a placeholder.\n-    fn instantiate_canonical_var(\n+    ///\n+    /// FIXME(-Ztrait-solver=next): This is public because it's used by the\n+    /// new trait solver which has a different canonicalization routine.\n+    /// We should somehow deduplicate all of this.\n+    pub fn instantiate_canonical_var(\n         &self,\n         span: Span,\n         cv_info: CanonicalVarInfo<'tcx>,"}, {"sha": "436d29c2449e4f925b2d748a2ec0d4ea3fca2e2f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -151,11 +151,21 @@ impl<'tcx> InferCtxt<'tcx> {\n         })\n     }\n \n-    /// FIXME: This method should only be used for canonical queries and therefore be private.\n-    ///\n-    /// As the new solver does canonicalization slightly differently, this is also used there\n-    /// for now. This should hopefully change fairly soon.\n-    pub fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+    /// Used by the new solver as that one takes the opaque types at the end of a probe\n+    /// to deal with multiple candidates without having to recompute them.\n+    pub fn clone_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n+        self.inner\n+            .borrow()\n+            .opaque_type_storage\n+            .opaque_types\n+            .iter()\n+            .map(|&(k, ref v)| {\n+                (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty)\n+            })\n+            .collect()\n+    }\n+\n+    fn take_opaque_types_for_query_response(&self) -> Vec<(Ty<'tcx>, Ty<'tcx>)> {\n         std::mem::take(&mut self.inner.borrow_mut().opaque_type_storage.opaque_types)\n             .into_iter()\n             .map(|(k, v)| (self.tcx.mk_opaque(k.def_id.to_def_id(), k.substs), v.hidden_type.ty))"}, {"sha": "cac3b40725158d73164b1568e56c3b0cc6561fc5", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -11,7 +11,9 @@ use rustc_middle::ty::fold::{FnMutDelegate, TypeFoldable};\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_middle::ty::{self, TyCtxt};\n \n-pub(super) trait CanonicalExt<'tcx, V> {\n+/// FIXME(-Ztrait-solver=next): This or public because it is shared with the\n+/// new trait solver implementation. We should deduplicate canonicalization.\n+pub trait CanonicalExt<'tcx, V> {\n     /// Instantiate the wrapped value, replacing each canonical value\n     /// with the value given in `var_values`.\n     fn substitute(&self, tcx: TyCtxt<'tcx>, var_values: &CanonicalVarValues<'tcx>) -> V"}, {"sha": "bf6af57c66a40e47246fc6a34cb041a1aed76c05", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1690,7 +1690,7 @@ impl<'tcx> TypeErrCtxt<'_, 'tcx> {\n                                 format!(\"{name} is defined in the current crate\")\n                             } else {\n                                 let crate_name = self.tcx.crate_name(defid.krate);\n-                                format!(\"{name} is defined in crate `{crate_name}\")\n+                                format!(\"{name} is defined in crate `{crate_name}`\")\n                             };\n                             diagnostic.span_note(def_span, msg);\n                         };"}, {"sha": "2c480355085efc5fcb9ef24a049010e825cb12d3", "filename": "compiler/rustc_infer/src/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -70,7 +70,7 @@ pub enum RegionResolutionError<'tcx> {\n     /// `o` requires that `a <= b`, but this does not hold\n     ConcreteFailure(SubregionOrigin<'tcx>, Region<'tcx>, Region<'tcx>),\n \n-    /// `GenericBoundFailure(p, s, a)\n+    /// `GenericBoundFailure(p, s, a)`:\n     ///\n     /// The parameter/associated-type `p` must be known to outlive the lifetime\n     /// `a` (but none of the known bounds are sufficient)."}, {"sha": "573cd91a2a2a65946704be04e95947626562eb28", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -50,7 +50,7 @@ where\n     ///\n     /// - Covariant means `a <: b`.\n     /// - Contravariant means `b <: a`.\n-    /// - Invariant means `a == b.\n+    /// - Invariant means `a == b`.\n     /// - Bivariant means that it doesn't matter.\n     ambient_variance: ty::Variance,\n "}, {"sha": "872f617474c066e616090af3a1072be297c6c96a", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -249,7 +249,7 @@ pub enum VerifyBound<'tcx> {\n /// in that case we can show `'b: 'c`. But if `'?x` winds up being something\n /// else, the bound isn't relevant.\n ///\n-/// In the [`VerifyBound`], this struct is enclosed in `Binder to account\n+/// In the [`VerifyBound`], this struct is enclosed in `Binder` to account\n /// for cases like\n ///\n /// ```rust"}, {"sha": "37994899a2038acb3eb4aac39127f73c2c684820", "filename": "compiler/rustc_interface/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Flocales%2Fen-US.ftl?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -33,7 +33,7 @@ interface_rustc_error_fatal =\n     fatal error triggered by #[rustc_error]\n \n interface_rustc_error_unexpected_annotation =\n-    unexpected annotation used with `#[rustc_error(...)]!\n+    unexpected annotation used with `#[rustc_error(...)]`!\n \n interface_failed_writing_file =\n     failed to write file {$path}: {$error}\""}, {"sha": "322ec31fb2cff9b66418600e32efa22bc780ce76", "filename": "compiler/rustc_lexer/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Flib.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -166,15 +166,17 @@ pub enum DocStyle {\n     Inner,\n }\n \n-// Note that the suffix is *not* considered when deciding the `LiteralKind` in\n-// this type. This means that float literals like `1f32` are classified by this\n-// type as `Int`. (Compare against `rustc_ast::token::LitKind` and\n-// `rustc_ast::ast::LitKind.)\n+/// Enum representing the literal types supported by the lexer.\n+///\n+/// Note that the suffix is *not* considered when deciding the `LiteralKind` in\n+/// this type. This means that float literals like `1f32` are classified by this\n+/// type as `Int`. (Compare against `rustc_ast::token::LitKind` and\n+/// `rustc_ast::ast::LitKind`).\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum LiteralKind {\n     /// \"12_u8\", \"0o100\", \"0b120i99\", \"1f32\".\n     Int { base: Base, empty_int: bool },\n-    /// \"12.34f32\", \"1e3\", but not \"1f32`.\n+    /// \"12.34f32\", \"1e3\", but not \"1f32\".\n     Float { base: Base, empty_exponent: bool },\n     /// \"'a'\", \"'\\\\'\", \"'''\", \"';\"\n     Char { terminated: bool },"}, {"sha": "5b2100b5da9d1510b8e848bf17ab3a9c5be94c29", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1288,7 +1288,7 @@ declare_lint! {\n }\n \n declare_lint_pass!(\n-    /// Explains corresponding feature flag must be enabled for the `#[track_caller] attribute to\n+    /// Explains corresponding feature flag must be enabled for the `#[track_caller]` attribute to\n     /// do anything\n     UngatedAsyncFnTrackCaller => [UNGATED_ASYNC_FN_TRACK_CALLER]\n );"}, {"sha": "4761ce83fabf18524c4255efb1cee290e70a5262", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 2, "deletions": 34, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -9,7 +9,6 @@\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"\n #include \"llvm/CodeGen/TargetSubtargetInfo.h\"\n-#include \"llvm/InitializePasses.h\"\n #include \"llvm/IR/AutoUpgrade.h\"\n #include \"llvm/IR/AssemblyAnnotationWriter.h\"\n #include \"llvm/IR/IntrinsicInst.h\"\n@@ -58,22 +57,6 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n \n-extern \"C\" void LLVMInitializePasses() {\n-  PassRegistry &Registry = *PassRegistry::getPassRegistry();\n-  initializeCore(Registry);\n-  initializeCodeGen(Registry);\n-  initializeScalarOpts(Registry);\n-  initializeVectorization(Registry);\n-  initializeIPO(Registry);\n-  initializeAnalysis(Registry);\n-  initializeTransformUtils(Registry);\n-  initializeInstCombine(Registry);\n-#if LLVM_VERSION_LT(16, 0)\n-  initializeInstrumentation(Registry);\n-#endif\n-  initializeTarget(Registry);\n-}\n-\n extern \"C\" void LLVMTimeTraceProfilerInitialize() {\n   timeTraceProfilerInitialize(\n       /* TimeTraceGranularity */ 0,\n@@ -1004,23 +987,8 @@ LLVMRustPrintModule(LLVMModuleRef M, const char *Path, DemangleFn Demangle) {\n }\n \n extern \"C\" void LLVMRustPrintPasses() {\n-  LLVMInitializePasses();\n-  struct MyListener : PassRegistrationListener {\n-    void passEnumerate(const PassInfo *Info) {\n-      StringRef PassArg = Info->getPassArgument();\n-      StringRef PassName = Info->getPassName();\n-      if (!PassArg.empty()) {\n-        // These unsigned->signed casts could theoretically overflow, but\n-        // realistically never will (and even if, the result is implementation\n-        // defined rather plain UB).\n-        printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n-               (int)PassName.size(), PassName.data());\n-      }\n-    }\n-  } Listener;\n-\n-  PassRegistry *PR = PassRegistry::getPassRegistry();\n-  PR->enumerateWith(&Listener);\n+  PassBuilder PB;\n+  PB.printPassNames(outs());\n }\n \n extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **Symbols,"}, {"sha": "3ab01f7809b041c1ec829500523977fd22687a1b", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1621,7 +1621,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     #[instrument(level = \"debug\", skip(self))]\n     fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n-        // including on the signature, which is inferred in `typeck.\n+        // including on the signature, which is inferred in `typeck`.\n         let typeck_result: &'tcx ty::TypeckResults<'tcx> = self.tcx.typeck(def_id);\n         let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = typeck_result.node_type(hir_id);"}, {"sha": "7f8fc17744dc9f459111ce18e30eb054644445df", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -123,6 +123,11 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n         self.kind.universe()\n     }\n \n+    #[must_use]\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarInfo<'tcx> {\n+        CanonicalVarInfo { kind: self.kind.with_updated_universe(ui) }\n+    }\n+\n     pub fn is_existential(&self) -> bool {\n         match self.kind {\n             CanonicalVarKind::Ty(_) => true,\n@@ -133,6 +138,28 @@ impl<'tcx> CanonicalVarInfo<'tcx> {\n             CanonicalVarKind::PlaceholderConst(_, _) => false,\n         }\n     }\n+\n+    pub fn is_region(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Region(_) | CanonicalVarKind::PlaceholderRegion(_) => true,\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::PlaceholderTy(_)\n+            | CanonicalVarKind::Const(_, _)\n+            | CanonicalVarKind::PlaceholderConst(_, _) => false,\n+        }\n+    }\n+\n+    pub fn expect_anon_placeholder(self) -> u32 {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_)\n+            | CanonicalVarKind::Region(_)\n+            | CanonicalVarKind::Const(_, _) => bug!(\"expected placeholder: {self:?}\"),\n+\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.name.expect_anon(),\n+            CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.name.as_u32(),\n+        }\n+    }\n }\n \n /// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n@@ -177,6 +204,38 @@ impl<'tcx> CanonicalVarKind<'tcx> {\n             CanonicalVarKind::PlaceholderConst(placeholder, _) => placeholder.universe,\n         }\n     }\n+\n+    /// Replaces the universe of this canonical variable with `ui`.\n+    ///\n+    /// In case this is a float or int variable, this causes an ICE if\n+    /// the updated universe is not the root.\n+    pub fn with_updated_universe(self, ui: ty::UniverseIndex) -> CanonicalVarKind<'tcx> {\n+        match self {\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(_) => {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui))\n+                }\n+                CanonicalTyVarKind::Int | CanonicalTyVarKind::Float => {\n+                    assert_eq!(ui, ty::UniverseIndex::ROOT);\n+                    CanonicalVarKind::Ty(kind)\n+                }\n+            },\n+            CanonicalVarKind::PlaceholderTy(placeholder) => {\n+                CanonicalVarKind::PlaceholderTy(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Region(_) => CanonicalVarKind::Region(ui),\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => {\n+                CanonicalVarKind::PlaceholderRegion(ty::Placeholder { universe: ui, ..placeholder })\n+            }\n+            CanonicalVarKind::Const(_, ty) => CanonicalVarKind::Const(ui, ty),\n+            CanonicalVarKind::PlaceholderConst(placeholder, ty) => {\n+                CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder { universe: ui, ..placeholder },\n+                    ty,\n+                )\n+            }\n+        }\n+    }\n }\n \n /// Rust actually has more than one category of type variables;\n@@ -213,7 +272,8 @@ pub struct QueryResponse<'tcx, R> {\n     pub value: R,\n }\n \n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct QueryRegionConstraints<'tcx> {\n     pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n     pub member_constraints: Vec<MemberConstraint<'tcx>>,"}, {"sha": "2db59f37f4072d1b0a49cd24de531bdc8729d3e2", "filename": "compiler/rustc_middle/src/infer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -12,7 +12,8 @@ use rustc_span::Span;\n /// ```text\n /// R0 member of [O1..On]\n /// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, TypeVisitable, Lift)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(HashStable, TypeFoldable, TypeVisitable, Lift)]\n pub struct MemberConstraint<'tcx> {\n     /// The `DefId` and substs of the opaque type causing this constraint.\n     /// Used for error reporting."}, {"sha": "99cdb769da1e788ccb534844114937dbb5ef1665", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -2908,7 +2908,7 @@ fn pretty_print_const_value<'tcx>(\n             // the `destructure_const` query with an empty `ty::ParamEnv` without\n             // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n             // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n-            // to be able to destructure the tuple into `(0u8, *mut T)\n+            // to be able to destructure the tuple into `(0u8, *mut T)`\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values."}, {"sha": "28a3b51b7fc925cfaa3bc3f0de86fdaf3cba0052", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -11,7 +11,7 @@ use std::io::{self, Write};\n pub const TOOLTIP_INDENT: &str = \"    \";\n \n const CARET: char = '\\u{2038}'; // Unicode `CARET`\n-const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET\n+const ANNOTATION_LEFT_BRACKET: char = '\\u{298a}'; // Unicode `Z NOTATION RIGHT BINDING BRACKET`\n const ANNOTATION_RIGHT_BRACKET: char = '\\u{2989}'; // Unicode `Z NOTATION LEFT BINDING BRACKET`\n const NEW_LINE_SPAN: &str = \"</span>\\n<span class=\\\"line\\\">\";\n const HEADER: &str = r#\"<!DOCTYPE html>"}, {"sha": "5133da3429a9c54b6de756ee5e4491300c79ec0f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1672,7 +1672,7 @@ rustc_queries! {\n \n     /// Does lifetime resolution on items. Importantly, we can't resolve\n     /// lifetimes directly on things like trait methods, because of trait params.\n-    /// See `rustc_resolve::late::lifetimes for details.\n+    /// See `rustc_resolve::late::lifetimes` for details.\n     query resolve_bound_vars(_: hir::OwnerId) -> &'tcx ResolveBoundVars {\n         arena_cache\n         desc { \"resolving lifetimes\" }"}, {"sha": "bd43867a3da805db3fa5c0ea901f1c59af210cdb", "filename": "compiler/rustc_middle/src/traits/solve.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fsolve.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -2,6 +2,7 @@ use std::ops::ControlFlow;\n \n use rustc_data_structures::intern::Interned;\n \n+use crate::infer::canonical::QueryRegionConstraints;\n use crate::ty::{\n     FallibleTypeFolder, Ty, TyCtxt, TypeFoldable, TypeFolder, TypeVisitable, TypeVisitor,\n };\n@@ -18,20 +19,25 @@ impl<'tcx> std::ops::Deref for ExternalConstraints<'tcx> {\n }\n \n /// Additional constraints returned on success.\n-#[derive(Debug, PartialEq, Eq, Clone, Hash, Default)]\n+#[derive(Debug, PartialEq, Eq, Clone, Hash, Default, TypeFoldable, TypeVisitable)]\n pub struct ExternalConstraintsData<'tcx> {\n     // FIXME: implement this.\n-    pub regions: (),\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n     pub opaque_types: Vec<(Ty<'tcx>, Ty<'tcx>)>,\n }\n \n+// FIXME: Having to clone `region_constraints` for folding feels bad and\n+// probably isn't great wrt performance.\n+//\n+// Not sure how to fix this, maybe we should also intern `opaque_types` and\n+// `region_constraints` here or something.\n impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n     fn try_fold_with<F: FallibleTypeFolder<TyCtxt<'tcx>>>(\n         self,\n         folder: &mut F,\n     ) -> Result<Self, F::Error> {\n         Ok(FallibleTypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().try_fold_with(folder)?,\n             opaque_types: self\n                 .opaque_types\n                 .iter()\n@@ -42,7 +48,7 @@ impl<'tcx> TypeFoldable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n \n     fn fold_with<F: TypeFolder<TyCtxt<'tcx>>>(self, folder: &mut F) -> Self {\n         TypeFolder::interner(folder).mk_external_constraints(ExternalConstraintsData {\n-            regions: (),\n+            region_constraints: self.region_constraints.clone().fold_with(folder),\n             opaque_types: self.opaque_types.iter().map(|opaque| opaque.fold_with(folder)).collect(),\n         })\n     }\n@@ -53,7 +59,7 @@ impl<'tcx> TypeVisitable<TyCtxt<'tcx>> for ExternalConstraints<'tcx> {\n         &self,\n         visitor: &mut V,\n     ) -> std::ops::ControlFlow<V::BreakTy> {\n-        self.regions.visit_with(visitor)?;\n+        self.region_constraints.visit_with(visitor)?;\n         self.opaque_types.visit_with(visitor)?;\n         ControlFlow::Continue(())\n     }"}, {"sha": "527ec9f6e1cfef0c19bddd4241d5e922cca8c0fc", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -16,7 +16,7 @@ pub use int::*;\n pub use kind::*;\n pub use valtree::*;\n \n-/// Use this rather than `ConstData, whenever possible.\n+/// Use this rather than `ConstData`, whenever possible.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable)]\n #[rustc_pass_by_value]\n pub struct Const<'tcx>(pub(super) Interned<'tcx, ConstData<'tcx>>);"}, {"sha": "e9e121f9c9b0483962570ee54f05ca227851f70c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -310,7 +310,7 @@ pub struct CommonLifetimes<'tcx> {\n     pub re_vars: Vec<Region<'tcx>>,\n \n     /// Pre-interned values of the form:\n-    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })\n+    /// `ReLateBound(DebruijnIndex(i), BoundRegion { var: v, kind: BrAnon(v, None) })`\n     /// for small values of `i` and `v`.\n     pub re_late_bounds: Vec<Vec<Region<'tcx>>>,\n }\n@@ -2187,7 +2187,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         // Actually intern type lists as lists of `GenericArg`s.\n         //\n         // Transmuting from `Ty<'tcx>` to `GenericArg<'tcx>` is sound\n-        // as explained in ty_slice_as_generic_arg`. With this,\n+        // as explained in `ty_slice_as_generic_arg`. With this,\n         // we guarantee that even when transmuting between `List<Ty<'tcx>>`\n         // and `List<GenericArg<'tcx>>`, the uniqueness requirement for\n         // lists is upheld.\n@@ -2450,7 +2450,7 @@ impl<'tcx> TyCtxtAt<'tcx> {\n         self.tcx.ty_error_with_message(self.span, \"TyKind::Error constructed but no error reported\")\n     }\n \n-    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg to\n+    /// Constructs a `TyKind::Error` type and registers a `delay_span_bug` with the given `msg` to\n     /// ensure it gets used.\n     #[track_caller]\n     pub fn ty_error_with_message(self, msg: &str) -> Ty<'tcx> {"}, {"sha": "92a040068dd75833d5b51b0a5fe9fff786c96fa0", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -105,7 +105,7 @@ impl<'tcx> VariantDef {\n impl<'tcx> Ty<'tcx> {\n     pub fn inhabited_predicate(self, tcx: TyCtxt<'tcx>) -> InhabitedPredicate<'tcx> {\n         match self.kind() {\n-            // For now, union`s are always considered inhabited\n+            // For now, unions are always considered inhabited\n             Adt(adt, _) if adt.is_union() => InhabitedPredicate::True,\n             // Non-exhaustive ADTs from other crates are always considered inhabited\n             Adt(adt, _) if adt.is_variant_list_non_exhaustive() && !adt.did().is_local() => {"}, {"sha": "9a517d2d2b425d65e6f5c66269780026716c668a", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -93,7 +93,7 @@ impl IntegerExt for Integer {\n             if discr < fit {\n                 bug!(\n                     \"Integer::repr_discr: `#[repr]` hint too small for \\\n-                      discriminant range of enum `{}\",\n+                      discriminant range of enum `{}`\",\n                     ty\n                 )\n             }"}, {"sha": "dce18a5850f3fc2bb264e5793fc6b9192971bad0", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -710,7 +710,7 @@ impl<'tcx> Predicate<'tcx> {\n         //   The substitution from the input trait-ref is therefore going to be\n         //   `'a => 'x` (where `'x` has a DB index of 1).\n         // - The supertrait-ref is `for<'b> Bar1<'a,'b>`, where `'a` is an\n-        //   early-bound parameter and `'b' is a late-bound parameter with a\n+        //   early-bound parameter and `'b` is a late-bound parameter with a\n         //   DB index of 1.\n         // - If we replace `'a` with `'x` from the input, it too will have\n         //   a DB index of 1, and thus we'll have `for<'x,'b> Bar1<'x,'b>`\n@@ -2444,7 +2444,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Check if the given `DefId` is `#\\[automatically_derived\\], *and*\n+    /// Check if the given `DefId` is `#\\[automatically_derived\\]`, *and*\n     /// whether it was produced by expanding a builtin derive macro.\n     pub fn is_builtin_derived(self, def_id: DefId) -> bool {\n         if self.is_automatically_derived(def_id)"}, {"sha": "e6a73e8bb1c38f72090c6df3ffa009257c38fe16", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -107,6 +107,15 @@ impl BoundRegionKind {\n             _ => None,\n         }\n     }\n+\n+    pub fn expect_anon(&self) -> u32 {\n+        match *self {\n+            BoundRegionKind::BrNamed(_, _) | BoundRegionKind::BrEnv => {\n+                bug!(\"expected anon region: {self:?}\")\n+            }\n+            BoundRegionKind::BrAnon(idx, _) => idx,\n+        }\n+    }\n }\n \n pub trait Article {"}, {"sha": "cfacb5ea327771b9f36df61da61f80c55107f841", "filename": "compiler/rustc_mir_build/src/build/expr/as_constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_constant.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -55,7 +55,7 @@ pub fn as_constant_inner<'tcx>(\n                         ConstantKind::Ty(tcx.const_error_with_guaranteed(ty, guar))\n                     }\n                     Err(LitToConstError::TypeError) => {\n-                        bug!(\"encountered type error in `lit_to_mir_constant\")\n+                        bug!(\"encountered type error in `lit_to_mir_constant`\")\n                     }\n                 };\n "}, {"sha": "536745d2cfea94de15c82bbe57654c1926d5dd11", "filename": "compiler/rustc_mir_transform/src/check_const_item_mutation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcheck_const_item_mutation.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -74,7 +74,7 @@ impl<'tcx> ConstMutationChecker<'_, 'tcx> {\n         //\n         // `unsafe { *FOO = 0; *BAR.field = 1; }`\n         // `unsafe { &mut *FOO }`\n-        // `unsafe { (*ARRAY)[0] = val; }\n+        // `unsafe { (*ARRAY)[0] = val; }`\n         if !place.projection.iter().any(|p| matches!(p, PlaceElem::Deref)) {\n             let source_info = self.body.source_info(location);\n             let lint_root = self.body.source_scopes[source_info.scope]"}, {"sha": "8ee316773aeaf0daeef4f5428b381e9bce866278", "filename": "compiler/rustc_mir_transform/src/coverage/spans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fspans.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -407,7 +407,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n                 if self.prev().is_macro_expansion() && self.curr().is_macro_expansion() {\n                     // Macros that expand to include branching (such as\n                     // `assert_eq!()`, `assert_ne!()`, `info!()`, `debug!()`, or\n-                    // `trace!()) typically generate callee spans with identical\n+                    // `trace!()`) typically generate callee spans with identical\n                     // ranges (typically the full span of the macro) for all\n                     // `BasicBlocks`. This makes it impossible to distinguish\n                     // the condition (`if val1 != val2`) from the optional\n@@ -694,7 +694,7 @@ impl<'a, 'tcx> CoverageSpans<'a, 'tcx> {\n     /// `prev.span.hi()` will be greater than (further right of) `prev_original_span.hi()`.\n     /// If prev.span() was split off to the right of a closure, prev.span().lo() will be\n     /// greater than prev_original_span.lo(). The actual span of `prev_original_span` is\n-    /// not as important as knowing that `prev()` **used to have the same span** as `curr(),\n+    /// not as important as knowing that `prev()` **used to have the same span** as `curr()`,\n     /// which means their sort order is still meaningful for determining the dominator\n     /// relationship.\n     ///"}, {"sha": "cdd28ae0c0197df622981fb0221a8b4babfdd7ed", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -248,7 +248,7 @@ fn mir_const_qualif(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) ->\n \n     // N.B., this `borrow()` is guaranteed to be valid (i.e., the value\n     // cannot yet be stolen), because `mir_promoted()`, which steals\n-    // from `mir_const(), forces this query to execute before\n+    // from `mir_const()`, forces this query to execute before\n     // performing the steal.\n     let body = &tcx.mir_const(def).borrow();\n "}, {"sha": "c6e7468aab4299424d3e36c9ed5ca763ba77be01", "filename": "compiler/rustc_mir_transform/src/lower_slice_len.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flower_slice_len.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -68,8 +68,11 @@ fn lower_slice_len_call<'tcx>(\n                 ty::FnDef(fn_def_id, _) if fn_def_id == &slice_len_fn_item_def_id => {\n                     // perform modifications\n                     // from something like `_5 = core::slice::<impl [u8]>::len(move _6) -> bb1`\n-                    // into `_5 = Len(*_6)\n+                    // into:\n+                    // ```\n+                    // _5 = Len(*_6)\n                     // goto bb1\n+                    // ```\n \n                     // make new RValue for Len\n                     let deref_arg = tcx.mk_place_deref(arg);"}, {"sha": "b0ab0f1062471523a87d3ccec098dbff86c1a6cd", "filename": "compiler/rustc_parse/src/parser/attr_wrapper.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr_wrapper.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -134,11 +134,11 @@ impl ToAttrTokenStream for LazyAttrTokenStreamImpl {\n             // Process the replace ranges, starting from the highest start\n             // position and working our way back. If have tokens like:\n             //\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // Then we will generate replace ranges for both\n             // the `#[cfg(FALSE)] field: bool` and the entire\n-            // `#[cfg(FALSE)]` struct Foo { #[cfg(FALSE)] field: bool }`\n+            // `#[cfg(FALSE)] struct Foo { #[cfg(FALSE)] field: bool }`\n             //\n             // By starting processing from the replace range with the greatest\n             // start position, we ensure that any replace range which encloses"}, {"sha": "da82e4724d1b5dba8bfb0ede4d17c2e315ae782f", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -335,7 +335,7 @@ impl TokenCursor {\n             num_of_hashes = cmp::max(num_of_hashes, count);\n         }\n \n-        // `/// foo` becomes `doc = r\"foo\".\n+        // `/// foo` becomes `doc = r\"foo\"`.\n         let delim_span = DelimSpan::from_single(span);\n         let body = TokenTree::Delimited(\n             delim_span,"}, {"sha": "5e2d2d3e5a704aafc48bb2a2bef2f4e48fa90c2d", "filename": "compiler/rustc_passes/src/hir_stats.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fhir_stats.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -646,7 +646,7 @@ impl<'v> ast_visit::Visitor<'v> for StatCollector<'v> {\n     }\n \n     // `UseTree` has one inline use (in `ast::ItemKind::Use`) and one\n-    // non-inline use (in `ast::UseTreeKind::Nested). The former case is more\n+    // non-inline use (in `ast::UseTreeKind::Nested`). The former case is more\n     // common, so we don't implement `visit_use_tree` and tolerate the missed\n     // coverage in the latter case.\n "}, {"sha": "053bf5c234acfe96044a005ce41b8c791df05a2c", "filename": "compiler/rustc_passes/src/liveness/rwu_table.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fliveness%2Frwu_table.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -9,7 +9,7 @@ pub(super) struct RWU {\n }\n \n /// Conceptually, this is like a `Vec<Vec<RWU>>`. But the number of\n-/// RWU`s can get very large, so it uses a more compact representation.\n+/// RWU's can get very large, so it uses a more compact representation.\n pub(super) struct RWUTable {\n     /// Total number of live nodes.\n     live_nodes: usize,"}, {"sha": "46e34462cf2252035e60be227dd30226c363013b", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -333,7 +333,7 @@ impl<'sess> rustc_middle::ty::OnDiskCache<'sess> for OnDiskCache<'sess> {\n                 },\n             );\n \n-            // `Encode the file footer.\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(\n                 TAG_FILE_FOOTER,"}, {"sha": "52f0b65fad6724cab3806964bcc3783ba7152ef6", "filename": "compiler/rustc_resolve/src/ident.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_resolve%2Fsrc%2Fident.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fident.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -368,7 +368,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n     /// This is a variation of `fn resolve_ident_in_lexical_scope` that can be run during\n     /// expansion and import resolution (perhaps they can be merged in the future).\n     /// The function is used for resolving initial segments of macro paths (e.g., `foo` in\n-    /// `foo::bar!(); or `foo!();`) and also for import paths on 2018 edition.\n+    /// `foo::bar!();` or `foo!();`) and also for import paths on 2018 edition.\n     #[instrument(level = \"debug\", skip(self, scope_set))]\n     pub(crate) fn early_resolve_ident_in_lexical_scope(\n         &mut self,"}, {"sha": "b8ddc4552578bed8fdfbae84da939203a9d85e2e", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -878,7 +878,7 @@ impl<'a: 'ast, 'ast, 'tcx> LateResolutionVisitor<'a, '_, 'ast, 'tcx> {\n         );\n         let is_assoc_fn = self.self_type_is_available();\n         if let Some((fn_kind, span)) = &self.diagnostic_metadata.current_function {\n-            // The current function has a `self' parameter, but we were unable to resolve\n+            // The current function has a `self` parameter, but we were unable to resolve\n             // a reference to `self`. This can only happen if the `self` identifier we\n             // are resolving came from a different hygiene context.\n             if fn_kind.decl().inputs.get(0).map_or(false, |p| p.is_self()) {"}, {"sha": "ff53f22d43f9316c829295dcf962e1fee21a875c", "filename": "compiler/rustc_session/locales/en-US.ftl", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_session%2Flocales%2Fen-US.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_session%2Flocales%2Fen-US.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Flocales%2Fen-US.ftl?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -5,7 +5,7 @@ session_incorrect_cgu_reuse_type =\n     }`{$expected_reuse}`\n \n session_cgu_not_recorded =\n-    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded`\n+    CGU-reuse for `{$cgu_user_name}` is (mangled: `{$cgu_name}`) was not recorded\n \n session_feature_gate_error = {$explain}\n "}, {"sha": "d4e4ace889b039e3bc9ea7d12aa70be466807b50", "filename": "compiler/rustc_session/src/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_session%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_session%2Fsrc%2Fconfig.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -2245,7 +2245,7 @@ pub fn parse_externs(\n                 early_error(\n                     error_format,\n                     \"the `-Z unstable-options` flag must also be passed to \\\n-                     enable `--extern options\",\n+                     enable `--extern` options\",\n                 );\n             }\n             for opt in opts.split(',') {\n@@ -2792,7 +2792,7 @@ pub enum PpMode {\n     HirTree,\n     /// `-Zunpretty=thir-tree`\n     ThirTree,\n-    /// `-Zunpretty=`thir-flat`\n+    /// `-Zunpretty=thir-flat`\n     ThirFlat,\n     /// `-Zunpretty=mir`\n     Mir,"}, {"sha": "162c15574b56ce8dd285f85228bf6795a2b2c949", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -235,7 +235,7 @@ impl<D: Decoder> Decodable<D> for DefIndex {\n pub struct DefId {\n     // cfg-ing the order of fields so that the `DefIndex` which is high entropy always ends up in\n     // the lower bits no matter the endianness. This allows the compiler to turn that `Hash` impl\n-    // into a direct call to 'u64::hash(_)`.\n+    // into a direct call to `u64::hash(_)`.\n     #[cfg(not(all(target_pointer_width = \"64\", target_endian = \"big\")))]\n     pub index: DefIndex,\n     pub krate: CrateNum,"}, {"sha": "6272bf7f25eb102d81af5e0b1a1c7b14019b002c", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1954,7 +1954,7 @@ impl Interner {\n         let name = Symbol::new(inner.strings.len() as u32);\n \n         // SAFETY: we convert from `&str` to `&[u8]`, clone it into the arena,\n-        // and immediately convert the clone back to `&[u8], all because there\n+        // and immediately convert the clone back to `&[u8]`, all because there\n         // is no `inner.arena.alloc_str()` method. This is clearly safe.\n         let string: &str =\n             unsafe { str::from_utf8_unchecked(inner.arena.alloc_slice(string.as_bytes())) };"}, {"sha": "c048d4a2aad7649d7f787ff9615dd69da1651891", "filename": "compiler/rustc_trait_selection/src/solve/canonical/canonicalize.rs", "status": "added", "additions": 390, "deletions": 0, "changes": 390, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fcanonicalize.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,390 @@\n+use std::cmp::Ordering;\n+\n+use crate::infer::InferCtxt;\n+use rustc_middle::infer::canonical::Canonical;\n+use rustc_middle::infer::canonical::CanonicalTyVarKind;\n+use rustc_middle::infer::canonical::CanonicalVarInfo;\n+use rustc_middle::infer::canonical::CanonicalVarInfos;\n+use rustc_middle::infer::canonical::CanonicalVarKind;\n+use rustc_middle::ty::BoundRegionKind::BrAnon;\n+use rustc_middle::ty::BoundTyKind;\n+use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::TypeVisitableExt;\n+use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{TypeFoldable, TypeFolder, TypeSuperFoldable};\n+\n+/// Whether we're canonicalizing a query input or the query reponse.\n+///\n+/// When canonicalizing an input we're in the context of the caller\n+/// while canonicalizing the response happens in the context of the\n+/// query.\n+#[derive(Debug, Clone, Copy)]\n+pub enum CanonicalizeMode {\n+    Input,\n+    /// FIXME: We currently return region constraints refering to\n+    /// placeholders and inference variables from a binder instantiated\n+    /// inside of the query.\n+    ///\n+    /// In the long term we should eagerly deal with these constraints\n+    /// inside of the query and only propagate constraints which are\n+    /// actually nameable by the caller.\n+    Response {\n+        /// The highest universe nameable by the caller.\n+        ///\n+        /// All variables in a universe nameable by the caller get mapped\n+        /// to the root universe in the response and then mapped back to\n+        /// their correct universe when applying the query response in the\n+        /// context of the caller.\n+        ///\n+        /// This doesn't work for universes created inside of the query so\n+        /// we do remember their universe in the response.\n+        max_input_universe: ty::UniverseIndex,\n+    },\n+}\n+\n+pub struct Canonicalizer<'a, 'tcx> {\n+    infcx: &'a InferCtxt<'tcx>,\n+    canonicalize_mode: CanonicalizeMode,\n+\n+    variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+    primitive_var_infos: Vec<CanonicalVarInfo<'tcx>>,\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl<'a, 'tcx> Canonicalizer<'a, 'tcx> {\n+    #[instrument(level = \"debug\", skip(infcx), ret)]\n+    pub fn canonicalize<T: TypeFoldable<TyCtxt<'tcx>>>(\n+        infcx: &'a InferCtxt<'tcx>,\n+        canonicalize_mode: CanonicalizeMode,\n+        variables: &'a mut Vec<ty::GenericArg<'tcx>>,\n+        value: T,\n+    ) -> Canonical<'tcx, T> {\n+        let mut canonicalizer = Canonicalizer {\n+            infcx,\n+            canonicalize_mode,\n+\n+            variables,\n+            primitive_var_infos: Vec::new(),\n+            binder_index: ty::INNERMOST,\n+        };\n+\n+        let value = value.fold_with(&mut canonicalizer);\n+        assert!(!value.needs_infer());\n+        assert!(!value.has_placeholders());\n+\n+        let (max_universe, variables) = canonicalizer.finalize();\n+\n+        Canonical { max_universe, variables, value }\n+    }\n+\n+    fn finalize(self) -> (ty::UniverseIndex, CanonicalVarInfos<'tcx>) {\n+        let mut var_infos = self.primitive_var_infos;\n+        // See the rustc-dev-guide section about how we deal with universes\n+        // during canonicalization in the new solver.\n+        match self.canonicalize_mode {\n+            // We try to deduplicate as many query calls as possible and hide\n+            // all information which should not matter for the solver.\n+            //\n+            // For this we compress universes as much as possible.\n+            CanonicalizeMode::Input => {}\n+            // When canonicalizing a response we map a universes already entered\n+            // by the caller to the root universe and only return useful universe\n+            // information for placeholders and inference variables created inside\n+            // of the query.\n+            CanonicalizeMode::Response { max_input_universe } => {\n+                for var in var_infos.iter_mut() {\n+                    let uv = var.universe();\n+                    let new_uv = ty::UniverseIndex::from(\n+                        uv.index().saturating_sub(max_input_universe.index()),\n+                    );\n+                    *var = var.with_updated_universe(new_uv);\n+                }\n+                let max_universe = var_infos\n+                    .iter()\n+                    .map(|info| info.universe())\n+                    .max()\n+                    .unwrap_or(ty::UniverseIndex::ROOT);\n+\n+                let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+                return (max_universe, var_infos);\n+            }\n+        }\n+\n+        // Given a `var_infos` with existentials `En` and universals `Un` in\n+        // universes `n`, this algorithm compresses them in place so that:\n+        //\n+        // - the new universe indices are as small as possible\n+        // - we only create a new universe if we would otherwise put a placeholder in\n+        //   the same compressed universe as an existential which cannot name it\n+        //\n+        // Let's walk through an example:\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 0\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 0, next_orig_uv: 1\n+        // - var_infos: [E0, U1, E5, U2, E2, E6, U6], curr_compressed_uv: 1, next_orig_uv: 2\n+        // - var_infos: [E0, U1, E5, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 5\n+        // - var_infos: [E0, U1, E1, U1, E1, E6, U6], curr_compressed_uv: 1, next_orig_uv: 6\n+        // - var_infos: [E0, U1, E1, U1, E1, E2, U2], curr_compressed_uv: 2, next_orig_uv: -\n+        //\n+        // This algorithm runs in `O(n\u00b2)` where `n` is the number of different universe\n+        // indices in the input. This should be fine as `n` is expected to be small.\n+        let mut curr_compressed_uv = ty::UniverseIndex::ROOT;\n+        let mut existential_in_new_uv = false;\n+        let mut next_orig_uv = Some(ty::UniverseIndex::ROOT);\n+        while let Some(orig_uv) = next_orig_uv.take() {\n+            let mut update_uv = |var: &mut CanonicalVarInfo<'tcx>, orig_uv, is_existential| {\n+                let uv = var.universe();\n+                match uv.cmp(&orig_uv) {\n+                    Ordering::Less => (), // Already updated\n+                    Ordering::Equal => {\n+                        if is_existential {\n+                            existential_in_new_uv = true;\n+                        } else if existential_in_new_uv {\n+                            //  `var` is a placeholder from a universe which is not nameable\n+                            // by an existential which we already put into the compressed\n+                            // universe `curr_compressed_uv`. We therefore have to create a\n+                            // new universe for `var`.\n+                            curr_compressed_uv = curr_compressed_uv.next_universe();\n+                            existential_in_new_uv = false;\n+                        }\n+\n+                        *var = var.with_updated_universe(curr_compressed_uv);\n+                    }\n+                    Ordering::Greater => {\n+                        // We can ignore this variable in this iteration. We only look at\n+                        // universes which actually occur in the input for performance.\n+                        //\n+                        // For this we set `next_orig_uv` to the next smallest, not yet compressed,\n+                        // universe of the input.\n+                        if next_orig_uv.map_or(true, |curr_next_uv| uv.cannot_name(curr_next_uv)) {\n+                            next_orig_uv = Some(uv);\n+                        }\n+                    }\n+                }\n+            };\n+\n+            // For each universe which occurs in the input, we first iterate over all\n+            // placeholders and then over all inference variables.\n+            //\n+            // Whenever we compress the universe of a placeholder, no existential with\n+            // an already compressed universe can name that placeholder.\n+            for is_existential in [false, true] {\n+                for var in var_infos.iter_mut() {\n+                    // We simply put all regions from the input into the highest\n+                    // compressed universe, so we only deal with them at the end.\n+                    if !var.is_region() {\n+                        if is_existential == var.is_existential() {\n+                            update_uv(var, orig_uv, is_existential)\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        for var in var_infos.iter_mut() {\n+            if var.is_region() {\n+                assert!(var.is_existential());\n+                *var = var.with_updated_universe(curr_compressed_uv);\n+            }\n+        }\n+\n+        let var_infos = self.infcx.tcx.mk_canonical_var_infos(&var_infos);\n+        (curr_compressed_uv, var_infos)\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n+    fn interner(&self) -> TyCtxt<'tcx> {\n+        self.infcx.tcx\n+    }\n+\n+    fn fold_binder<T>(&mut self, t: ty::Binder<'tcx, T>) -> ty::Binder<'tcx, T>\n+    where\n+        T: TypeFoldable<TyCtxt<'tcx>>,\n+    {\n+        self.binder_index.shift_in(1);\n+        let t = t.super_fold_with(self);\n+        self.binder_index.shift_out(1);\n+        t\n+    }\n+\n+    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        let r = self.infcx.shallow_resolve(r);\n+        let kind = match *r {\n+            ty::ReLateBound(..) => return r,\n+\n+            ty::ReStatic => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => return r,\n+            },\n+\n+            ty::ReErased | ty::ReFree(_) | ty::ReEarlyBound(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => bug!(\"unexpected region in response: {r:?}\"),\n+            },\n+\n+            ty::RePlaceholder(placeholder) => match self.canonicalize_mode {\n+                // We canonicalize placeholder regions as existentials in query inputs.\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { max_input_universe } => {\n+                    // If we have a placeholder region inside of a query, it must be from\n+                    // a new universe.\n+                    if max_input_universe.can_name(placeholder.universe) {\n+                        bug!(\"new placeholder in universe {max_input_universe:?}: {r:?}\");\n+                    }\n+                    CanonicalVarKind::PlaceholderRegion(placeholder)\n+                }\n+            },\n+\n+            ty::ReVar(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::Region(ty::UniverseIndex::ROOT),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::Region(self.infcx.universe_of_region(r))\n+                }\n+            },\n+\n+            ty::ReError(_) => return r,\n+        };\n+\n+        let existing_bound_var = match self.canonicalize_mode {\n+            CanonicalizeMode::Input => None,\n+            CanonicalizeMode::Response { .. } => {\n+                self.variables.iter().position(|&v| v == r.into()).map(ty::BoundVar::from)\n+            }\n+        };\n+        let var = existing_bound_var.unwrap_or_else(|| {\n+            let var = ty::BoundVar::from(self.variables.len());\n+            self.variables.push(r.into());\n+            self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+            var\n+        });\n+        let br = ty::BoundRegion { var, kind: BrAnon(var.as_u32(), None) };\n+        self.interner().mk_re_late_bound(self.binder_index, br)\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        let kind = match *t.kind() {\n+            ty::Infer(ty::TyVar(vid)) => match self.infcx.probe_ty_var(vid) {\n+                Ok(t) => return self.fold_ty(t),\n+                Err(ui) => CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n+            },\n+            ty::Infer(ty::IntVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FloatVar(_)) => {\n+                let nt = self.infcx.shallow_resolve(t);\n+                if nt != t {\n+                    return self.fold_ty(nt);\n+                } else {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int)\n+                }\n+            }\n+            ty::Infer(ty::FreshTy(_) | ty::FreshIntTy(_) | ty::FreshFloatTy(_)) => {\n+                bug!(\"fresh var during canonicalization: {t:?}\")\n+            }\n+            ty::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: placeholder.universe,\n+                    name: BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => CanonicalVarKind::PlaceholderTy(placeholder),\n+            },\n+            ty::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                    universe: ty::UniverseIndex::ROOT,\n+                    name: ty::BoundTyKind::Anon(self.variables.len() as u32),\n+                }),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {t:?}\"),\n+            },\n+            ty::Bool\n+            | ty::Char\n+            | ty::Int(_)\n+            | ty::Uint(_)\n+            | ty::Float(_)\n+            | ty::Adt(_, _)\n+            | ty::Foreign(_)\n+            | ty::Str\n+            | ty::Array(_, _)\n+            | ty::Slice(_)\n+            | ty::RawPtr(_)\n+            | ty::Ref(_, _, _)\n+            | ty::FnDef(_, _)\n+            | ty::FnPtr(_)\n+            | ty::Dynamic(_, _, _)\n+            | ty::Closure(_, _)\n+            | ty::Generator(_, _, _)\n+            | ty::GeneratorWitness(_)\n+            | ty::GeneratorWitnessMIR(..)\n+            | ty::Never\n+            | ty::Tuple(_)\n+            | ty::Alias(_, _)\n+            | ty::Bound(_, _)\n+            | ty::Error(_) => return t.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == t.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(t.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        let bt = ty::BoundTy { var, kind: BoundTyKind::Anon(var.index() as u32) };\n+        self.interner().mk_bound(self.binder_index, bt)\n+    }\n+\n+    fn fold_const(&mut self, c: ty::Const<'tcx>) -> ty::Const<'tcx> {\n+        let kind = match c.kind() {\n+            ty::ConstKind::Infer(ty::InferConst::Var(vid)) => match self.infcx.probe_const_var(vid)\n+            {\n+                Ok(c) => return self.fold_const(c),\n+                Err(universe) => CanonicalVarKind::Const(universe, c.ty()),\n+            },\n+            ty::ConstKind::Infer(ty::InferConst::Fresh(_)) => {\n+                bug!(\"fresh var during canonicalization: {c:?}\")\n+            }\n+            ty::ConstKind::Placeholder(placeholder) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: placeholder.universe,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => {\n+                    CanonicalVarKind::PlaceholderConst(placeholder, c.ty())\n+                }\n+            },\n+            ty::ConstKind::Param(_) => match self.canonicalize_mode {\n+                CanonicalizeMode::Input => CanonicalVarKind::PlaceholderConst(\n+                    ty::Placeholder {\n+                        universe: ty::UniverseIndex::ROOT,\n+                        name: ty::BoundVar::from(self.variables.len()),\n+                    },\n+                    c.ty(),\n+                ),\n+                CanonicalizeMode::Response { .. } => bug!(\"param ty in response: {c:?}\"),\n+            },\n+            ty::ConstKind::Bound(_, _)\n+            | ty::ConstKind::Unevaluated(_)\n+            | ty::ConstKind::Value(_)\n+            | ty::ConstKind::Error(_)\n+            | ty::ConstKind::Expr(_) => return c.super_fold_with(self),\n+        };\n+\n+        let var = ty::BoundVar::from(\n+            self.variables.iter().position(|&v| v == c.into()).unwrap_or_else(|| {\n+                let var = self.variables.len();\n+                self.variables.push(c.into());\n+                self.primitive_var_infos.push(CanonicalVarInfo { kind });\n+                var\n+            }),\n+        );\n+        self.interner().mk_const(ty::ConstKind::Bound(self.binder_index, var), c.ty())\n+    }\n+}"}, {"sha": "8c3be8da16b57841f5a7523f4b3e8754fe11a595", "filename": "compiler/rustc_trait_selection/src/solve/canonical/mod.rs", "status": "added", "additions": 240, "deletions": 0, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonical%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,240 @@\n+/// Canonicalization is used to separate some goal from its context,\n+/// throwing away unnecessary information in the process.\n+///\n+/// This is necessary to cache goals containing inference variables\n+/// and placeholders without restricting them to the current `InferCtxt`.\n+///\n+/// Canonicalization is fairly involved, for more details see the relevant\n+/// section of the [rustc-dev-guide][c].\n+///\n+/// [c]: https://rustc-dev-guide.rust-lang.org/solve/canonicalization.html\n+use self::canonicalize::{CanonicalizeMode, Canonicalizer};\n+use super::{CanonicalGoal, Certainty, EvalCtxt, Goal};\n+use super::{CanonicalResponse, ExternalConstraints, QueryResult, Response};\n+use rustc_infer::infer::canonical::query_response::make_query_region_constraints;\n+use rustc_infer::infer::canonical::CanonicalVarValues;\n+use rustc_infer::infer::canonical::{CanonicalExt, QueryRegionConstraints};\n+use rustc_infer::traits::query::NoSolution;\n+use rustc_infer::traits::solve::ExternalConstraintsData;\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::ty::{self, GenericArgKind};\n+use rustc_span::DUMMY_SP;\n+use std::iter;\n+use std::ops::Deref;\n+\n+mod canonicalize;\n+\n+impl<'tcx> EvalCtxt<'_, 'tcx> {\n+    /// Canonicalizes the goal remembering the original values\n+    /// for each bound variable.\n+    pub(super) fn canonicalize_goal(\n+        &self,\n+        goal: Goal<'tcx, ty::Predicate<'tcx>>,\n+    ) -> (Vec<ty::GenericArg<'tcx>>, CanonicalGoal<'tcx>) {\n+        let mut orig_values = Default::default();\n+        let canonical_goal = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Input,\n+            &mut orig_values,\n+            goal,\n+        );\n+        (orig_values, canonical_goal)\n+    }\n+\n+    /// To return the constraints of a canonical query to the caller, we canonicalize:\n+    ///\n+    /// - `var_values`: a map from bound variables in the canonical goal to\n+    ///   the values inferred while solving the instantiated goal.\n+    /// - `external_constraints`: additional constraints which aren't expressable\n+    ///   using simple unification of inference variables.\n+    #[instrument(level = \"debug\", skip(self))]\n+    pub(super) fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n+        let external_constraints = self.compute_external_query_constraints()?;\n+\n+        let response = Response { var_values: self.var_values, external_constraints, certainty };\n+        let canonical = Canonicalizer::canonicalize(\n+            self.infcx,\n+            CanonicalizeMode::Response { max_input_universe: self.max_input_universe },\n+            &mut Default::default(),\n+            response,\n+        );\n+        Ok(canonical)\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    fn compute_external_query_constraints(&self) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n+        // Cannot use `take_registered_region_obligations` as we may compute the response\n+        // inside of a `probe` whenever we have multiple choices inside of the solver.\n+        let region_obligations = self.infcx.inner.borrow().region_obligations().to_owned();\n+        let region_constraints = self.infcx.with_region_constraints(|region_constraints| {\n+            make_query_region_constraints(\n+                self.tcx(),\n+                region_obligations\n+                    .iter()\n+                    .map(|r_o| (r_o.sup_type, r_o.sub_region, r_o.origin.to_constraint_category())),\n+                region_constraints,\n+            )\n+        });\n+        let opaque_types = self.infcx.clone_opaque_types_for_query_response();\n+        Ok(self\n+            .tcx()\n+            .mk_external_constraints(ExternalConstraintsData { region_constraints, opaque_types }))\n+    }\n+\n+    /// After calling a canonical query, we apply the constraints returned\n+    /// by the query using this function.\n+    ///\n+    /// This happens in three steps:\n+    /// - we instantiate the bound variables of the query response\n+    /// - we unify the `var_values` of the response with the `original_values`\n+    /// - we apply the `external_constraints` returned by the query\n+    pub(super) fn instantiate_and_apply_query_response(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: Vec<ty::GenericArg<'tcx>>,\n+        response: CanonicalResponse<'tcx>,\n+    ) -> Result<Certainty, NoSolution> {\n+        let substitution = self.compute_query_response_substitution(&original_values, &response);\n+\n+        let Response { var_values, external_constraints, certainty } =\n+            response.substitute(self.tcx(), &substitution);\n+\n+        self.unify_query_var_values(param_env, &original_values, var_values)?;\n+\n+        // FIXME: implement external constraints.\n+        let ExternalConstraintsData { region_constraints, opaque_types: _ } =\n+            external_constraints.deref();\n+        self.register_region_constraints(region_constraints);\n+\n+        Ok(certainty)\n+    }\n+\n+    /// This returns the substitutions to instantiate the bound variables of\n+    /// the canonical reponse. This depends on the `original_values` for the\n+    /// bound variables.\n+    fn compute_query_response_substitution(\n+        &self,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        response: &CanonicalResponse<'tcx>,\n+    ) -> CanonicalVarValues<'tcx> {\n+        // FIXME: Longterm canonical queries should deal with all placeholders\n+        // created inside of the query directly instead of returning them to the\n+        // caller.\n+        let prev_universe = self.infcx.universe();\n+        let universes_created_in_query = response.max_universe.index() + 1;\n+        for _ in 0..universes_created_in_query {\n+            self.infcx.create_next_universe();\n+        }\n+\n+        let var_values = response.value.var_values;\n+        assert_eq!(original_values.len(), var_values.len());\n+\n+        // If the query did not make progress with constraining inference variables,\n+        // we would normally create a new inference variables for bound existential variables\n+        // only then unify this new inference variable with the inference variable from\n+        // the input.\n+        //\n+        // We therefore instantiate the existential variable in the canonical response with the\n+        // inference variable of the input right away, which is more performant.\n+        let mut opt_values = vec![None; response.variables.len()];\n+        for (original_value, result_value) in iter::zip(original_values, var_values.var_values) {\n+            match result_value.unpack() {\n+                GenericArgKind::Type(t) => {\n+                    if let &ty::Bound(debruijn, b) = t.kind() {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[b.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Lifetime(r) => {\n+                    if let ty::ReLateBound(debruijn, br) = *r {\n+                        assert_eq!(debruijn, ty::INNERMOST);\n+                        opt_values[br.var.index()] = Some(*original_value);\n+                    }\n+                }\n+                GenericArgKind::Const(c) => {\n+                    if let ty::ConstKind::Bound(debrujin, b) = c.kind() {\n+                        assert_eq!(debrujin, ty::INNERMOST);\n+                        opt_values[b.index()] = Some(*original_value);\n+                    }\n+                }\n+            }\n+        }\n+\n+        let var_values = self.tcx().mk_substs_from_iter(response.variables.iter().enumerate().map(\n+            |(index, info)| {\n+                if info.universe() != ty::UniverseIndex::ROOT {\n+                    // A variable from inside a binder of the query. While ideally these shouldn't\n+                    // exist at all (see the FIXME at the start of this method), we have to deal with\n+                    // them for now.\n+                    self.infcx.instantiate_canonical_var(DUMMY_SP, info, |idx| {\n+                        ty::UniverseIndex::from(prev_universe.index() + idx.index())\n+                    })\n+                } else if info.is_existential() {\n+                    // As an optimization we sometimes avoid creating a new inference variable here.\n+                    //\n+                    // All new inference variables we create start out in the current universe of the caller.\n+                    // This is conceptionally wrong as these inference variables would be able to name\n+                    // more placeholders then they should be able to. However the inference variables have\n+                    // to \"come from somewhere\", so by equating them with the original values of the caller\n+                    // later on, we pull them down into their correct universe again.\n+                    if let Some(v) = opt_values[index] {\n+                        v\n+                    } else {\n+                        self.infcx.instantiate_canonical_var(DUMMY_SP, info, |_| prev_universe)\n+                    }\n+                } else {\n+                    // For placeholders which were already part of the input, we simply map this\n+                    // universal bound variable back the placeholder of the input.\n+                    original_values[info.expect_anon_placeholder() as usize]\n+                }\n+            },\n+        ));\n+\n+        CanonicalVarValues { var_values }\n+    }\n+\n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    fn unify_query_var_values(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        original_values: &[ty::GenericArg<'tcx>],\n+        var_values: CanonicalVarValues<'tcx>,\n+    ) -> Result<(), NoSolution> {\n+        assert_eq!(original_values.len(), var_values.len());\n+        for (&orig, response) in iter::zip(original_values, var_values.var_values) {\n+            // This can fail due to the occurs check, see\n+            // `tests/ui/typeck/lazy-norm/equating-projection-cyclically.rs` for an example\n+            // where that can happen.\n+            //\n+            // FIXME: To deal with #105787 I also expect us to emit nested obligations here at\n+            // some point. We can figure out how to deal with this once we actually have\n+            // an ICE.\n+            let nested_goals = self.eq(param_env, orig, response)?;\n+            assert!(nested_goals.is_empty(), \"{nested_goals:?}\");\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn register_region_constraints(&mut self, region_constraints: &QueryRegionConstraints<'tcx>) {\n+        for &(ty::OutlivesPredicate(lhs, rhs), _) in &region_constraints.outlives {\n+            match lhs.unpack() {\n+                GenericArgKind::Lifetime(lhs) => self.infcx.region_outlives_predicate(\n+                    &ObligationCause::dummy(),\n+                    ty::Binder::dummy(ty::OutlivesPredicate(lhs, rhs)),\n+                ),\n+                GenericArgKind::Type(lhs) => self.infcx.register_region_obligation_with_cause(\n+                    lhs,\n+                    rhs,\n+                    &ObligationCause::dummy(),\n+                ),\n+                GenericArgKind::Const(_) => bug!(\"const outlives: {lhs:?}: {rhs:?}\"),\n+            }\n+        }\n+\n+        for member_constraint in &region_constraints.member_constraints {\n+            // FIXME: Deal with member constraints :<\n+            let _ = member_constraint;\n+        }\n+    }\n+}"}, {"sha": "95612674eb9d417a0fa173e1c6516ce9e4679cfa", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -19,8 +19,17 @@ use super::Goal;\n pub struct EvalCtxt<'a, 'tcx> {\n     // FIXME: should be private.\n     pub(super) infcx: &'a InferCtxt<'tcx>,\n-\n     pub(super) var_values: CanonicalVarValues<'tcx>,\n+    /// The highest universe index nameable by the caller.\n+    ///\n+    /// When we enter a new binder inside of the query we create new universes\n+    /// which the caller cannot name. We have to be careful with variables from\n+    /// these new universes when creating the query response.\n+    ///\n+    /// Both because these new universes can prevent us from reaching a fixpoint\n+    /// if we have a coinductive cycle and because that's the only way we can return\n+    /// new placeholders to the caller.\n+    pub(super) max_input_universe: ty::UniverseIndex,\n \n     pub(super) search_graph: &'a mut SearchGraph<'tcx>,\n "}, {"sha": "57b6a4527371835c0bee86d095e7a9f63a8d480a", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 27, "deletions": 70, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -19,11 +19,9 @@ use std::mem;\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::canonical::{OriginalQueryValues, QueryRegionConstraints, QueryResponse};\n use rustc_infer::infer::{InferCtxt, InferOk, TyCtxtInferExt};\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::Obligation;\n-use rustc_middle::infer::canonical::Certainty as OldCertainty;\n use rustc_middle::traits::solve::{ExternalConstraints, ExternalConstraintsData};\n use rustc_middle::ty::{self, Ty, TyCtxt};\n use rustc_middle::ty::{\n@@ -35,6 +33,7 @@ use crate::solve::search_graph::OverflowHandler;\n use crate::traits::ObligationCause;\n \n mod assembly;\n+mod canonical;\n mod eval_ctxt;\n mod fulfill;\n mod project_goals;\n@@ -89,11 +88,8 @@ trait CanonicalResponseExt {\n \n impl<'tcx> CanonicalResponseExt for Canonical<'tcx, Response<'tcx>> {\n     fn has_no_inference_or_external_constraints(&self) -> bool {\n-        // so that we get a compile error when regions are supported\n-        // so this code can be checked for being correct\n-        let _: () = self.value.external_constraints.regions;\n-\n-        self.value.var_values.is_identity()\n+        self.value.external_constraints.region_constraints.is_empty()\n+            && self.value.var_values.is_identity()\n             && self.value.external_constraints.opaque_types.is_empty()\n     }\n }\n@@ -169,6 +165,8 @@ impl<'tcx> InferCtxtEvalExt<'tcx> for InferCtxt<'tcx> {\n         let result = EvalCtxt {\n             search_graph: &mut search_graph,\n             infcx: self,\n+            // Only relevant when canonicalizing the response.\n+            max_input_universe: ty::UniverseIndex::ROOT,\n             var_values: CanonicalVarValues::dummy(),\n             in_projection_eq_hack: false,\n         }\n@@ -201,36 +199,33 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n         search_graph.with_new_goal(tcx, canonical_goal, |search_graph| {\n             let (ref infcx, goal, var_values) =\n                 tcx.infer_ctxt().build_with_canonical(DUMMY_SP, &canonical_goal);\n-            let mut ecx =\n-                EvalCtxt { infcx, var_values, search_graph, in_projection_eq_hack: false };\n+            let mut ecx = EvalCtxt {\n+                infcx,\n+                var_values,\n+                max_input_universe: canonical_goal.max_universe,\n+                search_graph,\n+                in_projection_eq_hack: false,\n+            };\n             ecx.compute_goal(goal)\n         })\n     }\n \n-    fn make_canonical_response(&self, certainty: Certainty) -> QueryResult<'tcx> {\n-        let external_constraints = compute_external_query_constraints(self.infcx)?;\n-\n-        Ok(self.infcx.canonicalize_response(Response {\n-            var_values: self.var_values,\n-            external_constraints,\n-            certainty,\n-        }))\n-    }\n-\n     /// Recursively evaluates `goal`, returning whether any inference vars have\n     /// been constrained and the certainty of the result.\n     fn evaluate_goal(\n         &mut self,\n         goal: Goal<'tcx, ty::Predicate<'tcx>>,\n     ) -> Result<(bool, Certainty), NoSolution> {\n-        let mut orig_values = OriginalQueryValues::default();\n-        let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+        let (orig_values, canonical_goal) = self.canonicalize_goal(goal);\n         let canonical_response =\n             EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n \n         let has_changed = !canonical_response.value.var_values.is_identity();\n-        let certainty =\n-            instantiate_canonical_query_response(self.infcx, &orig_values, canonical_response);\n+        let certainty = self.instantiate_and_apply_query_response(\n+            goal.param_env,\n+            orig_values,\n+            canonical_response,\n+        )?;\n \n         // Check that rerunning this query with its inference constraints applied\n         // doesn't result in new inference constraints and has the same result.\n@@ -244,8 +239,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             && !self.in_projection_eq_hack\n             && !self.search_graph.in_cycle()\n         {\n-            let mut orig_values = OriginalQueryValues::default();\n-            let canonical_goal = self.infcx.canonicalize_query(goal, &mut orig_values);\n+            let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n             if !canonical_response.value.var_values.is_identity() {\n@@ -316,15 +310,21 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n \n     fn compute_type_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, TypeOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        let ty::OutlivesPredicate(ty, lt) = goal.predicate;\n+        self.infcx.register_region_obligation_with_cause(ty, lt, &ObligationCause::dummy());\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n     fn compute_region_outlives_goal(\n         &mut self,\n-        _goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n+        goal: Goal<'tcx, RegionOutlivesPredicate<'tcx>>,\n     ) -> QueryResult<'tcx> {\n+        self.infcx.region_outlives_predicate(\n+            &ObligationCause::dummy(),\n+            ty::Binder::dummy(goal.predicate),\n+        );\n         self.make_canonical_response(Certainty::Yes)\n     }\n \n@@ -561,49 +561,6 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n     }\n }\n \n-#[instrument(level = \"debug\", skip(infcx), ret)]\n-fn compute_external_query_constraints<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-) -> Result<ExternalConstraints<'tcx>, NoSolution> {\n-    let region_obligations = infcx.take_registered_region_obligations();\n-    let opaque_types = infcx.take_opaque_types_for_query_response();\n-    Ok(infcx.tcx.mk_external_constraints(ExternalConstraintsData {\n-        // FIXME: Now that's definitely wrong :)\n-        //\n-        // Should also do the leak check here I think\n-        regions: drop(region_obligations),\n-        opaque_types,\n-    }))\n-}\n-\n-fn instantiate_canonical_query_response<'tcx>(\n-    infcx: &InferCtxt<'tcx>,\n-    original_values: &OriginalQueryValues<'tcx>,\n-    response: CanonicalResponse<'tcx>,\n-) -> Certainty {\n-    let Ok(InferOk { value, obligations }) = infcx\n-        .instantiate_query_response_and_region_obligations(\n-            &ObligationCause::dummy(),\n-            ty::ParamEnv::empty(),\n-            original_values,\n-            &response.unchecked_map(|resp| QueryResponse {\n-                var_values: resp.var_values,\n-                region_constraints: QueryRegionConstraints::default(),\n-                certainty: match resp.certainty {\n-                    Certainty::Yes => OldCertainty::Proven,\n-                    Certainty::Maybe(_) => OldCertainty::Ambiguous,\n-                },\n-                // FIXME: This to_owned makes me sad, but we should eventually impl\n-                // `instantiate_query_response_and_region_obligations` separately\n-                // instead of piggybacking off of the old implementation.\n-                opaque_types: resp.external_constraints.opaque_types.to_owned(),\n-                value: resp.certainty,\n-            }),\n-        ) else { bug!(); };\n-    assert!(obligations.is_empty());\n-    value\n-}\n-\n pub(super) fn response_no_constraints<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     goal: Canonical<'tcx, impl Sized>,"}, {"sha": "33c66d072e944dd5c8353d230df8855abaf7b796", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -77,10 +77,11 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         let nested_goals = self\n             .eq(goal.param_env, goal.predicate.term, normalized_alias.into())\n             .expect(\"failed to unify with unconstrained term\");\n-        let rhs_certainty =\n+\n+        let unify_certainty =\n             self.evaluate_all(nested_goals).expect(\"failed to unify with unconstrained term\");\n \n-        self.make_canonical_response(normalization_certainty.unify_and(rhs_certainty))\n+        self.make_canonical_response(normalization_certainty.unify_and(unify_certainty))\n     }\n }\n "}, {"sha": "870ecc2a9707ac7eb393d7af8b8d061687befdf0", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -1175,7 +1175,7 @@ fn opt_normalize_projection_type<'a, 'b, 'tcx>(\n /// paths you want to take. To make things worse, it was possible for\n /// cycles to arise, where you basically had a setup like `<MyType<$0>\n /// as Trait>::Foo == $0`. Here, normalizing `<MyType<$0> as\n-/// Trait>::Foo> to `[type error]` would lead to an obligation of\n+/// Trait>::Foo>` to `[type error]` would lead to an obligation of\n /// `<MyType<[type error]> as Trait>::Foo`. We are supposed to report\n /// an error for this obligation, but we legitimately should not,\n /// because it contains `[type error]`. Yuck! (See issue #29857 for"}, {"sha": "e91057356a2dc1a170f83a02b89d3eb931071dd9", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -339,7 +339,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // Essentially any user-written impl will match with an error type,\n         // so creating `ImplCandidates` isn't useful. However, we might\n-        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized)\n+        // end up finding a candidate elsewhere (e.g. a `BuiltinCandidate` for `Sized`)\n         // This helps us avoid overflow: see issue #72839\n         // Since compilation is already guaranteed to fail, this is just\n         // to try to show the 'nicest' possible errors to the user."}, {"sha": "4377de158290a6a73fde8c810343efdcee388aa1", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -151,7 +151,7 @@ struct TraitObligationStack<'prev, 'tcx> {\n     /// you don't want to cache that `B: AutoTrait` or `A: AutoTrait`\n     /// is `EvaluatedToOk`; this is because they were only considered\n     /// ok on the premise that if `A: AutoTrait` held, but we indeed\n-    /// encountered a problem (later on) with `A: AutoTrait. So we\n+    /// encountered a problem (later on) with `A: AutoTrait`. So we\n     /// currently set a flag on the stack node for `B: AutoTrait` (as\n     /// well as the second instance of `A: AutoTrait`) to suppress\n     /// caching.\n@@ -727,7 +727,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                             // Otherwise, we can say that `T: NonAutoTrait` is\n                             // true.\n                             // Let's imagine we have a predicate stack like\n-                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto\n+                            //         `Foo: Bar -> WF(T) -> T: NonAutoTrait -> T: Auto`\n                             // depth   ^1                    ^2                 ^3\n                             // and the current predicate is `WF(T)`. `wf_args`\n                             // would contain `(T, 1)`. We want to check all"}, {"sha": "995dd2f04b1e6ffa850d04a572fe99c8c4d1820a", "filename": "src/tools/clippy/book/src/lint_configuration.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fbook%2Fsrc%2Flint_configuration.md?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -306,7 +306,7 @@ The maximum number of lines a function or method can have\n ### array-size-threshold\n The maximum allowed size for arrays on the stack\n \n-**Default Value:** `512000` (`u128`)\n+**Default Value:** `512000` (`u64`)\n \n * [large_stack_arrays](https://rust-lang.github.io/rust-clippy/master/index.html#large_stack_arrays)\n * [large_const_arrays](https://rust-lang.github.io/rust-clippy/master/index.html#large_const_arrays)"}, {"sha": "c626e0bd99852ba1858fdcd0d24ffb60163c2a7f", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -777,7 +777,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|_| Box::new(mutable_debug_assertion::DebugAssertWithMutCall));\n     store.register_late_pass(|_| Box::new(exit::Exit));\n     store.register_late_pass(|_| Box::new(to_digit_is_some::ToDigitIsSome));\n-    let array_size_threshold = conf.array_size_threshold;\n+    let array_size_threshold = u128::from(conf.array_size_threshold);\n     store.register_late_pass(move |_| Box::new(large_stack_arrays::LargeStackArrays::new(array_size_threshold)));\n     store.register_late_pass(move |_| Box::new(large_const_arrays::LargeConstArrays::new(array_size_threshold)));\n     store.register_late_pass(|_| Box::new(floating_point_arithmetic::FloatingPointArithmetic));"}, {"sha": "1c7f3e96db894b29e4be2bb8420f4d13a5de0979", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -334,7 +334,7 @@ define_Conf! {\n     /// Lint: LARGE_STACK_ARRAYS, LARGE_CONST_ARRAYS.\n     ///\n     /// The maximum allowed size for arrays on the stack\n-    (array_size_threshold: u128 = 512_000),\n+    (array_size_threshold: u64 = 512_000),\n     /// Lint: VEC_BOX.\n     ///\n     /// The size of the boxed type in bytes, where boxing in a `Vec` is allowed"}, {"sha": "65f38fe71188e8384aca61f800cd02563a681f11", "filename": "src/tools/clippy/tests/ui/crashes/ice-10044.rs", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.rs?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,3 +0,0 @@\n-fn main() {\n-    [0; usize::MAX];\n-}"}, {"sha": "731f8265ad6c9efa055d8722438cf242e6d77e97", "filename": "src/tools/clippy/tests/ui/crashes/ice-10044.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7a809ce8997a1697b166b4bb2594993e87d69f31/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcrashes%2Fice-10044.stderr?ref=7a809ce8997a1697b166b4bb2594993e87d69f31", "patch": "@@ -1,10 +0,0 @@\n-error: statement with no effect\n-  --> $DIR/ice-10044.rs:2:5\n-   |\n-LL |     [0; usize::MAX];\n-   |     ^^^^^^^^^^^^^^^^\n-   |\n-   = note: `-D clippy::no-effect` implied by `-D warnings`\n-\n-error: aborting due to previous error\n-"}, {"sha": "99787ffd3d395aeb4ce745f17f924a642b4771c0", "filename": "src/tools/clippy/tests/ui/large_stack_arrays.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -24,6 +24,7 @@ fn main() {\n         [S { data: [0; 32] }; 5000],\n         [Some(\"\"); 20_000_000],\n         [E::T(0); 5000],\n+        [0u8; usize::MAX],\n     );\n \n     let good = ("}, {"sha": "24e90094982aa9fcbd776b3158e28289863452f0", "filename": "src/tools/clippy/tests/ui/large_stack_arrays.stderr", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Flarge_stack_arrays.stderr?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -31,5 +31,13 @@ LL |         [E::T(0); 5000],\n    |\n    = help: consider allocating on the heap with `vec![E::T(0); 5000].into_boxed_slice()`\n \n-error: aborting due to 4 previous errors\n+error: allocating a local array larger than 512000 bytes\n+  --> $DIR/large_stack_arrays.rs:27:9\n+   |\n+LL |         [0u8; usize::MAX],\n+   |         ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider allocating on the heap with `vec![0u8; usize::MAX].into_boxed_slice()`\n+\n+error: aborting due to 5 previous errors\n "}, {"sha": "7f623c7a9ec5499242a63ea705e06a09c1e77c71", "filename": "tests/ui-toml/array_size_threshold/array_size_threshold.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,10 @@\n+#![allow(unused)]\n+#![warn(clippy::large_const_arrays, clippy::large_stack_arrays)]\n+\n+const ABOVE: [u8; 11] = [0; 11];\n+const BELOW: [u8; 10] = [0; 10];\n+\n+fn main() {\n+    let above = [0u8; 11];\n+    let below = [0u8; 10];\n+}"}, {"sha": "ac017b20916dea2b7b6876b53bba0fe7bc1a5c83", "filename": "tests/ui-toml/array_size_threshold/array_size_threshold.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Farray_size_threshold%2Farray_size_threshold.stderr?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,29 @@\n+error: large array defined as const\n+  --> $DIR/array_size_threshold.rs:4:1\n+   |\n+LL | const ABOVE: [u8; 11] = [0; 11];\n+   | -----^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   | |\n+   | help: make this a static item: `static`\n+   |\n+   = note: `-D clippy::large-const-arrays` implied by `-D warnings`\n+\n+error: allocating a local array larger than 10 bytes\n+  --> $DIR/array_size_threshold.rs:4:25\n+   |\n+LL | const ABOVE: [u8; 11] = [0; 11];\n+   |                         ^^^^^^^\n+   |\n+   = help: consider allocating on the heap with `vec![0; 11].into_boxed_slice()`\n+   = note: `-D clippy::large-stack-arrays` implied by `-D warnings`\n+\n+error: allocating a local array larger than 10 bytes\n+  --> $DIR/array_size_threshold.rs:8:17\n+   |\n+LL |     let above = [0u8; 11];\n+   |                 ^^^^^^^^^\n+   |\n+   = help: consider allocating on the heap with `vec![0u8; 11].into_boxed_slice()`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "3f1fe9a12099fa9a060a50c00d1d8cf66cba1d7d", "filename": "tests/ui-toml/array_size_threshold/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Farray_size_threshold%2Fclippy.toml?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1 @@\n+array-size-threshold = 10"}, {"sha": "da72c8ebf19b6a644012741e1f9a02e6e86f5e46", "filename": "tests/ui/suggestions/impl-on-dyn-trait-with-implicit-static-bound.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fsuggestions%2Fimpl-on-dyn-trait-with-implicit-static-bound.stderr?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -17,7 +17,7 @@ note: the used `impl` has a `'static` requirement\n LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> {\n    |                                ^^^^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self<K>(&self) -> &() { panic!() }\n-   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+   |            -------- calling this method introduces the `impl`'s `'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n LL |     impl<T> MyTrait<T> for dyn ObjectTrait<T> + '_ {\n@@ -42,7 +42,7 @@ note: the used `impl` has a `'static` requirement\n LL |     impl dyn ObjectTrait {\n    |              ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+   |            -------- calling this method introduces the `impl`'s `'static` requirement\n help: consider relaxing the implicit `'static` requirement\n    |\n LL |     impl dyn ObjectTrait + '_ {\n@@ -65,7 +65,7 @@ note: the used `impl` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:87:26\n    |\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+   |            -------- calling this method introduces the `impl`'s `'static` requirement\n ...\n LL |     impl MyTrait for dyn ObjectTrait {}\n    |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement\n@@ -91,7 +91,7 @@ note: the used `impl` has a `'static` requirement\n   --> $DIR/impl-on-dyn-trait-with-implicit-static-bound.rs:106:26\n    |\n LL |         fn use_self(&self) -> &() { panic!() }\n-   |            -------- calling this method introduces the `impl`'s 'static` requirement\n+   |            -------- calling this method introduces the `impl`'s `'static` requirement\n ...\n LL |     impl MyTrait for dyn ObjectTrait {}\n    |                          ^^^^^^^^^^^ this has an implicit `'static` lifetime requirement"}, {"sha": "3903bfe9bcf57af05fab3d57300a1e537033a986", "filename": "tests/ui/traits/non_lifetime_binders/late-bound-in-anon-ct.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,11 @@\n+#![feature(non_lifetime_binders, generic_const_exprs)]\n+//~^ WARN the feature `non_lifetime_binders` is incomplete\n+//~| WARN the feature `generic_const_exprs` is incomplete\n+\n+fn foo() -> usize\n+where\n+    for<T> [i32; { let _: T = todo!(); 0 }]:,\n+    //~^ ERROR cannot capture late-bound type parameter in a constant\n+{}\n+\n+fn main() {}"}, {"sha": "fafff02dea6eebf59b73388020004762b8fae1f0", "filename": "tests/ui/traits/non_lifetime_binders/late-bound-in-anon-ct.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnon_lifetime_binders%2Flate-bound-in-anon-ct.stderr?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,27 @@\n+warning: the feature `non_lifetime_binders` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/late-bound-in-anon-ct.rs:1:12\n+   |\n+LL | #![feature(non_lifetime_binders, generic_const_exprs)]\n+   |            ^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #108185 <https://github.com/rust-lang/rust/issues/108185> for more information\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+warning: the feature `generic_const_exprs` is incomplete and may not be safe to use and/or cause compiler crashes\n+  --> $DIR/late-bound-in-anon-ct.rs:1:34\n+   |\n+LL | #![feature(non_lifetime_binders, generic_const_exprs)]\n+   |                                  ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #76560 <https://github.com/rust-lang/rust/issues/76560> for more information\n+\n+error: cannot capture late-bound type parameter in a constant\n+  --> $DIR/late-bound-in-anon-ct.rs:7:27\n+   |\n+LL |     for<T> [i32; { let _: T = todo!(); 0 }]:,\n+   |         -                 ^\n+   |         |\n+   |         parameter defined here\n+\n+error: aborting due to previous error; 2 warnings emitted\n+"}, {"sha": "4433047b75ad2d0c9dd76c46c639b217d9735896", "filename": "tests/ui/typeck/bad-type-in-vec-contains.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.rs?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,7 @@\n+// The error message here still is pretty confusing.\n+\n+fn main() {\n+    let primes = Vec::new();\n+    primes.contains(3);\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "0e03388d2d58cd93cb5dcaf5e61ac30df6e66253", "filename": "tests/ui/typeck/bad-type-in-vec-contains.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/44cfafe2fafe816395d3acc434663a45d5178c41/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftypeck%2Fbad-type-in-vec-contains.stderr?ref=44cfafe2fafe816395d3acc434663a45d5178c41", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/bad-type-in-vec-contains.rs:5:21\n+   |\n+LL |     primes.contains(3);\n+   |            -------- ^\n+   |            |        |\n+   |            |        expected `&_`, found integer\n+   |            |        help: consider borrowing here: `&3`\n+   |            arguments to this method are incorrect\n+   |            here the type of `primes` is inferred to be `[_]`\n+   |\n+   = note: expected reference `&_`\n+                   found type `{integer}`\n+note: method defined here\n+  --> $SRC_DIR/core/src/slice/mod.rs:LL:COL\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}