{"sha": "27532330e909ac7af1507d292621751dbe61cd49", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI3NTMyMzMwZTkwOWFjN2FmMTUwN2QyOTI2MjE3NTFkYmU2MWNkNDk=", "commit": {"author": {"name": "Baoshan", "email": "pangbw@gmail.com", "date": "2019-09-23T21:09:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-09-23T21:09:23Z"}, "message": "Merge pull request #28 from rust-lang/master\n\nSync to rust-lang/rust master", "tree": {"sha": "196ef2334e2f7787737af02f2e78ed53c10fb5a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/196ef2334e2f7787737af02f2e78ed53c10fb5a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/27532330e909ac7af1507d292621751dbe61cd49", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdiTSDCRBK7hj4Ov3rIwAAdHIIAEMnkDXhCyP0GKrToLBCeaxs\nVEEIwnlpISdoEpQX9OL0ER3VsCh5rr3EIVbCLrB4yWs19VBnNsZBGfcdiNTVQSg4\naLWXJhNY/jC3KJzveGNXxF0NAV8ln0w/hYu+6lNouinQpXigAUIVNRHU7iR8HaLJ\n3jk8IOV+uebcWZSfmW8GsY8QolzSn6bEwr+5Vb7jCll9eTebexSC4ZNKch97plWe\nngdEQ2JcMYacr0qZ6q0IyMJGC5+wj7ciqMvwJEmYkNAdwlsFzz9Ahv6joFZv0ziE\nuC1/XPcfX6tZCMpT6SkxPxF9q/9IJUsFnE7Y9VkGPPMzFI6zDQNPQEY6jwWLjAI=\n=ZUf3\n-----END PGP SIGNATURE-----\n", "payload": "tree 196ef2334e2f7787737af02f2e78ed53c10fb5a8\nparent 4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24\nparent 66bf391c3aabfc77f5f7139fc9e6944f995d574e\nauthor Baoshan <pangbw@gmail.com> 1569272963 -0700\ncommitter GitHub <noreply@github.com> 1569272963 -0700\n\nMerge pull request #28 from rust-lang/master\n\nSync to rust-lang/rust master"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/27532330e909ac7af1507d292621751dbe61cd49", "html_url": "https://github.com/rust-lang/rust/commit/27532330e909ac7af1507d292621751dbe61cd49", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/27532330e909ac7af1507d292621751dbe61cd49/comments", "author": {"login": "BaoshanPang", "id": 3380860, "node_id": "MDQ6VXNlcjMzODA4NjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3380860?v=4", "gravatar_id": "", "url": "https://api.github.com/users/BaoshanPang", "html_url": "https://github.com/BaoshanPang", "followers_url": "https://api.github.com/users/BaoshanPang/followers", "following_url": "https://api.github.com/users/BaoshanPang/following{/other_user}", "gists_url": "https://api.github.com/users/BaoshanPang/gists{/gist_id}", "starred_url": "https://api.github.com/users/BaoshanPang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/BaoshanPang/subscriptions", "organizations_url": "https://api.github.com/users/BaoshanPang/orgs", "repos_url": "https://api.github.com/users/BaoshanPang/repos", "events_url": "https://api.github.com/users/BaoshanPang/events{/privacy}", "received_events_url": "https://api.github.com/users/BaoshanPang/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24", "url": "https://api.github.com/repos/rust-lang/rust/commits/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24", "html_url": "https://github.com/rust-lang/rust/commit/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24"}, {"sha": "66bf391c3aabfc77f5f7139fc9e6944f995d574e", "url": "https://api.github.com/repos/rust-lang/rust/commits/66bf391c3aabfc77f5f7139fc9e6944f995d574e", "html_url": "https://github.com/rust-lang/rust/commit/66bf391c3aabfc77f5f7139fc9e6944f995d574e"}], "stats": {"total": 61075, "additions": 35389, "deletions": 25686}, "files": [{"sha": "3ff5af78097fabfe271d45b0924177dcecdacd12", "filename": ".gitmodules", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -43,7 +43,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/9.0-2019-07-12\n+\tbranch = rustc/9.0-2019-09-19\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "9587aaab3594506bf8398f25a9d433096a6cb939", "filename": ".mailmap", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -117,6 +117,9 @@ Jason Toffaletti <toffaletti@gmail.com> Jason Toffaletti <jason@topsy.com>\n Jauhien Piatlicki <jauhien@gentoo.org> Jauhien Piatlicki <jpiatlicki@zertisa.com>\n Jay True <glacjay@gmail.com>\n Jeremy Letang <letang.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <stucki.jeremy@gmail.com>\n+Jeremy Stucki <dev@jeremystucki.ch> <jeremy@myelin.ch>\n+Jeremy Stucki <dev@jeremystucki.ch>\n Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n@@ -181,12 +184,20 @@ Neil Pankey <npankey@gmail.com> <neil@wire.im>\n Nick Platt <platt.nicholas@gmail.com>\n Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n-Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <git-spam9815368754983@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github333195615777966@oli-obk.de>\n-Oliver Schneider <oliver.schneider@kit.edu> Oliver Schneider <github6541940@oli-obk.de>\n+Oliver Middleton <olliemail27@gmail.com> <ollie27@users.noreply.github.com>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam-no-reply9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-spam9815368754983@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github333195615777966@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <rust19446194516@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git-no-reply-9879165716479413131@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <git1984941651981@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github35764891676564198441@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <github6541940@oli-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu> <oli-obk@users.noreply.github.com>\n+Oliver Scherer <oliver.schneider@kit.edu> <public.oliver.schneider@kit.edu>\n+Oliver Scherer <oliver.schneider@kit.edu> <obk8176014uqher834@olio-obk.de>\n+Oliver Scherer <oliver.schneider@kit.edu>\n O\u017ebolt Menegatti <ozbolt.menegatti@gmail.com> gareins <ozbolt.menegatti@gmail.com>\n Paul Faria <paul_faria@ultimatesoftware.com> Paul Faria <Nashenas88@gmail.com>\n Peer Aramillo Irizar <peer.aramillo.irizar@gmail.com> parir <peer.aramillo.irizar@gmail.com>"}, {"sha": "fa749e5e3aebe059c9b8aaa6cb4bde6df2ca0430", "filename": "Cargo.lock", "status": "modified", "additions": 546, "deletions": 244, "changes": 790, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -109,9 +109,9 @@ dependencies = [\n \n [[package]]\n name = \"backtrace\"\n-version = \"0.3.35\"\n+version = \"0.3.37\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"1371048253fa3bac6704bfd6bbfc922ee9bdcee8881330d40f308b81cc5adc55\"\n+checksum = \"5180c5a20655b14a819b652fd2378fa5f1697b6c9ddad3e695c2f9cedf6df4e2\"\n dependencies = [\n  \"backtrace-sys\",\n  \"cfg-if\",\n@@ -185,7 +185,7 @@ dependencies = [\n  \"serde\",\n  \"serde_json\",\n  \"time\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -202,7 +202,7 @@ name = \"build-manifest\"\n version = \"0.1.0\"\n dependencies = [\n  \"serde\",\n- \"toml 0.4.10\",\n+ \"toml\",\n ]\n \n [[package]]\n@@ -223,18 +223,18 @@ checksum = \"560c32574a12a89ecd91f5e742165893f86e3ab98d21f8ea548658eb9eef5f40\"\n \n [[package]]\n name = \"bytecount\"\n-version = \"0.5.1\"\n+version = \"0.6.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"be0fdd54b507df8f22012890aadd099979befdba27713c767993f8380112ca7c\"\n+checksum = \"b0017894339f586ccb943b01b9555de56770c11cda818e7e3d8bd93f4ed7f46e\"\n dependencies = [\n  \"packed_simd\",\n ]\n \n [[package]]\n name = \"byteorder\"\n-version = \"1.2.7\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"94f88df23a25417badc922ab0f5716cc1330e87f71ddd9203b3a3ccd9cedf75d\"\n+checksum = \"a7c3dd8985a7111efc5c80b44e23ecdd8c007de8ade3b96595387e812b957cf5\"\n \n [[package]]\n name = \"bytes\"\n@@ -270,14 +270,15 @@ dependencies = [\n  \"atty\",\n  \"bytesize\",\n  \"cargo-test-macro\",\n+ \"cargo-test-support\",\n  \"clap\",\n  \"core-foundation\",\n  \"crates-io\",\n  \"crossbeam-utils 0.6.5\",\n  \"crypto-hash\",\n  \"curl\",\n  \"curl-sys\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"filetime\",\n  \"flate2\",\n@@ -286,8 +287,9 @@ dependencies = [\n  \"git2\",\n  \"git2-curl\",\n  \"glob\",\n- \"hex\",\n- \"home 0.4.2\",\n+ \"hex 0.4.0\",\n+ \"home\",\n+ \"humantime\",\n  \"ignore\",\n  \"im-rc\",\n  \"jobserver\",\n@@ -309,14 +311,14 @@ dependencies = [\n  \"same-file\",\n  \"semver\",\n  \"serde\",\n- \"serde_ignored 0.1.0\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"shell-escape\",\n  \"strip-ansi-escapes\",\n  \"tar\",\n  \"tempfile\",\n  \"termcolor\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-width\",\n  \"url 2.1.0\",\n  \"walkdir\",\n@@ -327,6 +329,23 @@ dependencies = [\n name = \"cargo-test-macro\"\n version = \"0.1.0\"\n \n+[[package]]\n+name = \"cargo-test-support\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"cargo\",\n+ \"cargo-test-macro\",\n+ \"filetime\",\n+ \"flate2\",\n+ \"git2\",\n+ \"glob\",\n+ \"lazy_static 1.3.0\",\n+ \"remove_dir_all\",\n+ \"serde_json\",\n+ \"tar\",\n+ \"url 2.1.0\",\n+]\n+\n [[package]]\n name = \"cargo_metadata\"\n version = \"0.8.0\"\n@@ -392,9 +411,9 @@ dependencies = [\n \n [[package]]\n name = \"clap\"\n-version = \"2.32.0\"\n+version = \"2.33.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b957d88f4b6a63b9d70d5f454ac8011819c6efa7727858f458ab71c756ce2d3e\"\n+checksum = \"5067f5bb2d80ef5d68b4c87db81601f0b75bca627bc2ef76b141d7b846a3c6d9\"\n dependencies = [\n  \"ansi_term\",\n  \"atty\",\n@@ -436,13 +455,13 @@ dependencies = [\n  \"itertools 0.8.0\",\n  \"lazy_static 1.3.0\",\n  \"matches\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.6.0\",\n  \"quine-mc_cluskey\",\n  \"regex-syntax\",\n  \"semver\",\n  \"serde\",\n  \"smallvec\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-normalization\",\n  \"url 2.1.0\",\n ]\n@@ -507,7 +526,7 @@ name = \"compiletest\"\n version = \"0.0.0\"\n dependencies = [\n  \"diff\",\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"getopts\",\n  \"lazy_static 1.3.0\",\n  \"libc\",\n@@ -698,7 +717,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"09de9ee0fc255ace04c7fa0763c9395a945c37c8292bb554f8d48361d1dcf1b4\"\n dependencies = [\n  \"commoncrypto\",\n- \"hex\",\n+ \"hex 0.3.2\",\n  \"openssl\",\n  \"winapi 0.3.6\",\n ]\n@@ -753,9 +772,9 @@ checksum = \"d2a368589465391e127e10c9e3a08efc8df66fd49b87dc8524c764bbe7f2ef82\"\n dependencies = [\n  \"fnv\",\n  \"ident_case\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -765,8 +784,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"244e8987bd4e174385240cde20a3657f607fb0797563c28255c353b5819a07b1\"\n dependencies = [\n  \"darling_core\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -781,9 +800,9 @@ version = \"0.5.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"6ca414e896ae072546f4d789f452daaecf60ddee4c9df5dc6d5936d769e3d87c\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -792,10 +811,10 @@ version = \"0.13.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3f57d78cf3bd45270dad4e70c21ec77a960b36c7a841ff9db76aaa775a8fb871\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"rustc_version\",\n- \"syn\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -909,21 +928,9 @@ dependencies = [\n \n [[package]]\n name = \"env_logger\"\n-version = \"0.5.13\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"15b0a4d2e39f8420210be8b27eeda28029729e2fd4291019455016c348240c38\"\n-dependencies = [\n- \"atty\",\n- \"humantime\",\n- \"log\",\n- \"termcolor\",\n-]\n-\n-[[package]]\n-name = \"env_logger\"\n-version = \"0.6.0\"\n+version = \"0.6.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"afb070faf94c85d17d50ca44f6ad076bce18ae92f0037d350947240a36e9d42e\"\n+checksum = \"aafcde04e90a5226a6443b7aabdb016ba2f8307c847d524724bd9b346dd1a2d3\"\n dependencies = [\n  \"atty\",\n  \"humantime\",\n@@ -946,6 +953,7 @@ name = \"error_index_generator\"\n version = \"0.0.0\"\n dependencies = [\n  \"rustdoc\",\n+ \"walkdir\",\n ]\n \n [[package]]\n@@ -964,9 +972,9 @@ version = \"0.1.5\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ea1063915fd7ef4309e222a5a07cf9c319fb9c7836b1f89b85458672dbb127e1\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -1010,6 +1018,7 @@ dependencies = [\n name = \"fmt_macros\"\n version = \"0.0.0\"\n dependencies = [\n+ \"rustc_lexer\",\n  \"syntax_pos\",\n ]\n \n@@ -1138,28 +1147,31 @@ dependencies = [\n \n [[package]]\n name = \"getopts\"\n-version = \"0.2.19\"\n+version = \"0.2.21\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"72327b15c228bfe31f1390f93dd5e9279587f0463836393c9df719ce62a3e450\"\n+checksum = \"14dbbfd5c71d70241ecf9e6f13737f7b5ce823821063188d7e46c41d371eebd5\"\n dependencies = [\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"getrandom\"\n-version = \"0.1.8\"\n+version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"34f33de6f0ae7c9cb5e574502a562e2b512799e32abb801cd1e79ad952b62b49\"\n+checksum = \"473a1265acc8ff1e808cd0a1af8cee3c2ee5200916058a2ca113c29f2d903571\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n+ \"wasi\",\n ]\n \n [[package]]\n name = \"git2\"\n-version = \"0.9.2\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8cb400360e8a4d61b10e648285bbfa919bbf9519d0d5d5720354456f44349226\"\n+checksum = \"327d698f86a7ebdfeb86a4238ccdb004828939d3a3555b6ead679541d14e36c0\"\n dependencies = [\n  \"bitflags\",\n  \"libc\",\n@@ -1172,9 +1184,9 @@ dependencies = [\n \n [[package]]\n name = \"git2-curl\"\n-version = \"0.10.1\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"2293de73491c3dc4174c5949ef53d2cc037b27613f88d72032e3f5237247a7dd\"\n+checksum = \"cd6527e480187ce19aaf4fa6acfb7657b25628ce31cb8ffabdfca3bf731524c5\"\n dependencies = [\n  \"curl\",\n  \"git2\",\n@@ -1268,20 +1280,16 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"805026a5d0141ffc30abb3be3173848ad46a1b1664fe632428479619a3644d77\"\n \n [[package]]\n-name = \"home\"\n-version = \"0.3.3\"\n+name = \"hex\"\n+version = \"0.4.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"80dff82fb58cfbbc617fb9a9184b010be0529201553cda50ad04372bc2333aff\"\n-dependencies = [\n- \"scopeguard 0.3.3\",\n- \"winapi 0.3.6\",\n-]\n+checksum = \"023b39be39e3a2da62a94feb433e91e8bcd37676fbc8bea371daf52b7a769a3e\"\n \n [[package]]\n name = \"home\"\n-version = \"0.4.2\"\n+version = \"0.5.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"013e4e6e9134211bb4d6bf53dd8cfb75d9e2715cc33614b9c0827718c6fbe0b8\"\n+checksum = \"c07c315e106bd6f83f026a20ddaeef2706782e490db1dcdd37caad38a0e895b3\"\n dependencies = [\n  \"scopeguard 1.0.0\",\n  \"winapi 0.3.6\",\n@@ -1296,9 +1304,9 @@ dependencies = [\n  \"log\",\n  \"mac\",\n  \"markup5ever\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -1536,11 +1544,30 @@ version = \"0.11.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9ad0485404155f45cce53a40d4b2d6ac356418300daed05273d9e26f91c390be\"\n \n+[[package]]\n+name = \"jsonrpc-client-transports\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"39577db48b004cffb4c5b8e5c9b993c177c52599ecbee88711e815acf65144db\"\n+dependencies = [\n+ \"failure\",\n+ \"futures\",\n+ \"jsonrpc-core\",\n+ \"jsonrpc-pubsub\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"serde\",\n+ \"serde_json\",\n+ \"tokio\",\n+ \"url 1.7.2\",\n+]\n+\n [[package]]\n name = \"jsonrpc-core\"\n-version = \"12.0.0\"\n+version = \"13.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"288dca7f9713710a29e485076b9340156cb701edb46a881f5d0c31aa4f5b9143\"\n+checksum = \"dd42951eb35079520ee29b7efbac654d85821b397ef88c8151600ef7e2d00217\"\n dependencies = [\n  \"futures\",\n  \"log\",\n@@ -1549,6 +1576,70 @@ dependencies = [\n  \"serde_json\",\n ]\n \n+[[package]]\n+name = \"jsonrpc-core-client\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f047c10738edee7c3c6acf5241a0ce33df32ef9230c1a7fb03e4a77ee72c992f\"\n+dependencies = [\n+ \"jsonrpc-client-transports\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-derive\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"29f9149f785deaae92a4c834a9a1a83a4313b8cfedccf15362cd4cf039a64501\"\n+dependencies = [\n+ \"proc-macro-crate\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-ipc-server\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"256c5e4292c17b4c2ecdf542299dc8e9d6b3939c075c54825570ad9317fe5751\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-server-utils\",\n+ \"log\",\n+ \"parity-tokio-ipc\",\n+ \"parking_lot 0.9.0\",\n+ \"tokio-service\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-pubsub\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e2c08b444cc0ed70263798834343d0ac875e664257df8079160f23ac1ea79446\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"log\",\n+ \"parking_lot 0.9.0\",\n+ \"serde\",\n+]\n+\n+[[package]]\n+name = \"jsonrpc-server-utils\"\n+version = \"13.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"44561bfdd31401bad790527f1e951dde144f2341ddc3e1b859d32945e1a34eff\"\n+dependencies = [\n+ \"bytes\",\n+ \"globset\",\n+ \"jsonrpc-core\",\n+ \"lazy_static 1.3.0\",\n+ \"log\",\n+ \"num_cpus\",\n+ \"tokio\",\n+ \"tokio-codec\",\n+ \"unicase 2.5.1\",\n+]\n+\n [[package]]\n name = \"kernel32-sys\"\n version = \"0.2.2\"\n@@ -1579,9 +1670,9 @@ checksum = \"b294d6fa9ee409a054354afc4352b0b9ef7ca222c69b8812cbea9e7d2bf3783f\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.60\"\n+version = \"0.2.62\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d44e80633f007889c7eff624b709ab43c92d708caad982295768a7b13ca3b5eb\"\n+checksum = \"34fcd2c08d2f832f376f4173a231990fa5aef4e99fb569867318a227ef4c06ba\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]\n@@ -1601,9 +1692,9 @@ dependencies = [\n \n [[package]]\n name = \"libgit2-sys\"\n-version = \"0.8.2\"\n+version = \"0.9.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4c179ed6d19cd3a051e68c177fbbc214e79ac4724fac3a850ec9f3d3eb8a5578\"\n+checksum = \"8c2078aec6f4b16d1b89f6a72e4f6eb1e75ffa85312023291e89c6d3087bc8fb\"\n dependencies = [\n  \"cc\",\n  \"libc\",\n@@ -1663,11 +1754,20 @@ dependencies = [\n  \"scopeguard 0.3.3\",\n ]\n \n+[[package]]\n+name = \"lock_api\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f8912e782533a93a167888781b836336a6ca5da6175c05944c86cf28c31104dc\"\n+dependencies = [\n+ \"scopeguard 1.0.0\",\n+]\n+\n [[package]]\n name = \"log\"\n-version = \"0.4.6\"\n+version = \"0.4.8\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n+checksum = \"14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7\"\n dependencies = [\n  \"cfg-if\",\n ]\n@@ -1694,18 +1794,15 @@ dependencies = [\n \n [[package]]\n name = \"lsp-types\"\n-version = \"0.57.2\"\n+version = \"0.60.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b62b77309737b1e262b3bbf37ff8faa740562c633b14702afe9be85dbcb6f88a\"\n+checksum = \"fe3edefcd66dde1f7f1df706f46520a3c93adc5ca4bc5747da6621195e894efd\"\n dependencies = [\n  \"bitflags\",\n- \"num-derive\",\n- \"num-traits\",\n  \"serde\",\n- \"serde_derive\",\n  \"serde_json\",\n- \"url 1.7.2\",\n- \"url_serde\",\n+ \"serde_repr\",\n+ \"url 2.1.0\",\n ]\n \n [[package]]\n@@ -1770,22 +1867,22 @@ dependencies = [\n  \"chrono\",\n  \"clap\",\n  \"elasticlunr-rs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"error-chain\",\n  \"handlebars\",\n  \"itertools 0.8.0\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n  \"memchr\",\n  \"open\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.5.3\",\n  \"regex\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n  \"shlex\",\n  \"tempfile\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query\",\n ]\n \n@@ -1795,20 +1892,20 @@ version = \"0.3.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"77d1f0ba4d1e6b86fa18e8853d026d7d76a97eb7eb5eb052ed80901e43b7fc10\"\n dependencies = [\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"log\",\n  \"mdbook\",\n  \"memchr\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.5.3\",\n  \"rayon\",\n  \"regex\",\n  \"reqwest\",\n  \"semver\",\n  \"serde\",\n  \"serde_derive\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.2.18\",\n  \"url 1.7.2\",\n ]\n \n@@ -1860,7 +1957,7 @@ version = \"0.3.13\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3e27ca21f40a310bd06d9031785f4801710d566c184a6e15bad4f1d9b65f9425\"\n dependencies = [\n- \"unicase 2.4.0\",\n+ \"unicase 2.5.1\",\n ]\n \n [[package]]\n@@ -1988,11 +2085,12 @@ dependencies = [\n  \"colored\",\n  \"compiletest_rs\",\n  \"directories\",\n- \"env_logger 0.6.0\",\n- \"hex\",\n+ \"env_logger\",\n+ \"getrandom\",\n+ \"hex 0.3.2\",\n  \"log\",\n  \"num-traits\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc-workspace-hack\",\n  \"rustc_version\",\n  \"shell-escape\",\n@@ -2040,18 +2138,6 @@ version = \"0.1.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9a2228dca57108069a5262f2ed8bd2e82496d2e074a06d1ccc7ce1687b6ae0a2\"\n \n-[[package]]\n-name = \"num-derive\"\n-version = \"0.2.3\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"8af1847c907c2f04d7bfd572fb25bbb4385c637fe5be163cf2f8c5d778fe1e7d\"\n-dependencies = [\n- \"num-traits\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n [[package]]\n name = \"num-integer\"\n version = \"0.1.39\"\n@@ -2076,6 +2162,12 @@ dependencies = [\n  \"libc\",\n ]\n \n+[[package]]\n+name = \"once_cell\"\n+version = \"1.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"d6a04cb71e910d0034815600180f62a95bf6e67942d7ab52a166a68c7d7e9cd0\"\n+\n [[package]]\n name = \"open\"\n version = \"1.2.1\"\n@@ -2113,9 +2205,9 @@ checksum = \"77af24da69f9d9341038eba93a073b1fdaaa1b788221b00a69bce9e762cb32de\"\n \n [[package]]\n name = \"openssl-src\"\n-version = \"111.3.0+1.1.1c\"\n+version = \"111.6.0+1.1.1d\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"53ed5f31d294bdf5f7a4ba0a206c2754b0f60e9a63b7e3076babc5317873c797\"\n+checksum = \"b9c2da1de8a7a3f860919c01540b03a6db16de042405a8a07a5e9d0b4b825d9c\"\n dependencies = [\n  \"cc\",\n ]\n@@ -2185,14 +2277,43 @@ dependencies = [\n  \"unwind\",\n ]\n \n+[[package]]\n+name = \"parity-tokio-ipc\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8281bf4f1d6429573f89589bf68d89451c46750977a8264f8ea3edbabeba7947\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"log\",\n+ \"mio-named-pipes\",\n+ \"miow 0.3.3\",\n+ \"rand 0.7.0\",\n+ \"tokio\",\n+ \"tokio-named-pipes\",\n+ \"tokio-uds\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"parking_lot\"\n version = \"0.7.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"ab41b4aed082705d1056416ae4468b6ea99d52599ecf3169b00088d43113e337\"\n dependencies = [\n- \"lock_api\",\n- \"parking_lot_core\",\n+ \"lock_api 0.1.3\",\n+ \"parking_lot_core 0.4.0\",\n+]\n+\n+[[package]]\n+name = \"parking_lot\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"f842b1982eb6c2fe34036a4fbfb06dd185a3f5c8edfaacdf7d1ea10b07de6252\"\n+dependencies = [\n+ \"lock_api 0.3.1\",\n+ \"parking_lot_core 0.6.2\",\n+ \"rustc_version\",\n ]\n \n [[package]]\n@@ -2208,6 +2329,21 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"parking_lot_core\"\n+version = \"0.6.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b876b1b9e7ac6e1a74a6da34d25c42e17e8862aa409cbbbdcfc8d86c6f3bc62b\"\n+dependencies = [\n+ \"cfg-if\",\n+ \"cloudabi\",\n+ \"libc\",\n+ \"redox_syscall\",\n+ \"rustc_version\",\n+ \"smallvec\",\n+ \"winapi 0.3.6\",\n+]\n+\n [[package]]\n name = \"percent-encoding\"\n version = \"1.0.1\"\n@@ -2247,9 +2383,9 @@ checksum = \"63120576c4efd69615b5537d3d052257328a4ca82876771d6944424ccfd9f646\"\n dependencies = [\n  \"pest\",\n  \"pest_meta\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -2320,9 +2456,9 @@ checksum = \"676e8eb2b1b4c9043511a9b7bea0915320d7e502b0a079fb03f9635a5252b18c\"\n \n [[package]]\n name = \"polonius-engine\"\n-version = \"0.9.0\"\n+version = \"0.10.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"f6b8a5defa2aef9ba4999aaa745fbc01c622ecea35964a306adc3e44be4f3b5b\"\n+checksum = \"50fa9dbfd0d3d60594da338cfe6f94028433eecae4b11b7e83fd99759227bbfe\"\n dependencies = [\n  \"datafrog\",\n  \"log\",\n@@ -2358,22 +2494,54 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"df8b3f4e0475def7d9c2e5de8e5a1306949849761e107b360d03e98eafaffd61\"\n dependencies = [\n  \"chrono\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"log\",\n ]\n \n+[[package]]\n+name = \"proc-macro-crate\"\n+version = \"0.1.4\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e10d4b51f154c8a7fb96fd6dad097cb74b863943ec010ac94b9fd1be8861fe1e\"\n+dependencies = [\n+ \"toml\",\n+]\n+\n+[[package]]\n+name = \"proc-macro-error\"\n+version = \"0.2.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"aeccfe4d5d8ea175d5f0e4a2ad0637e0f4121d63bd99d356fb1f39ab2e7c6097\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"proc-macro2\"\n version = \"0.4.30\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-xid 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"proc-macro2\"\n+version = \"1.0.3\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"e98a83a9f9b331f54b924e68a66acb1bb35cb01fb0a23645139967abefb697e8\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n name = \"proc_macro\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"std\",\n+]\n \n [[package]]\n name = \"profiler_builtins\"\n@@ -2393,7 +2561,19 @@ dependencies = [\n  \"bitflags\",\n  \"getopts\",\n  \"memchr\",\n- \"unicase 2.4.0\",\n+ \"unicase 2.5.1\",\n+]\n+\n+[[package]]\n+name = \"pulldown-cmark\"\n+version = \"0.6.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"85b0ad0d4c1702965ee6bb5b4ff5e71f83850b497d497e9444302987bf9e26a4\"\n+dependencies = [\n+ \"bitflags\",\n+ \"getopts\",\n+ \"memchr\",\n+ \"unicase 2.5.1\",\n ]\n \n [[package]]\n@@ -2420,19 +2600,28 @@ version = \"0.6.12\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"faf4799c5d274f3868a4aae320a0a182cbd2baee377b378f080e16a23e9d80db\"\n dependencies = [\n- \"proc-macro2\",\n+ \"proc-macro2 0.4.30\",\n+]\n+\n+[[package]]\n+name = \"quote\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"053a8c8bcc71fcce321828dc897a98ab9760bef03a4fc36693c231e5b3216cfe\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n ]\n \n [[package]]\n name = \"racer\"\n-version = \"2.1.25\"\n+version = \"2.1.27\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"0727b9d7baaf9e42851145545d7b980b5c1752bd16a4c77c925c5e573d0069d9\"\n+checksum = \"dde22b84ab75220015cbd91240222402bf885cbe3a5dc856475771abb82533ae\"\n dependencies = [\n  \"bitflags\",\n  \"clap\",\n  \"derive_more\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"humantime\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n@@ -2719,18 +2908,18 @@ checksum = \"cabe4fa914dec5870285fa7f71f602645da47c486e68486d2b4ceb4a343e90ac\"\n \n [[package]]\n name = \"rls\"\n-version = \"1.38.0\"\n+version = \"1.39.0\"\n dependencies = [\n  \"cargo\",\n  \"cargo_metadata\",\n  \"clippy_lints\",\n  \"crossbeam-channel\",\n  \"difference\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"futures\",\n  \"heck\",\n- \"home 0.3.3\",\n+ \"home\",\n  \"itertools 0.8.0\",\n  \"jsonrpc-core\",\n  \"lazy_static 1.3.0\",\n@@ -2745,6 +2934,7 @@ dependencies = [\n  \"regex\",\n  \"rls-analysis\",\n  \"rls-data\",\n+ \"rls-ipc\",\n  \"rls-rustc\",\n  \"rls-span\",\n  \"rls-vfs\",\n@@ -2754,14 +2944,14 @@ dependencies = [\n  \"rustfmt-nightly\",\n  \"serde\",\n  \"serde_derive\",\n- \"serde_ignored 0.0.4\",\n+ \"serde_ignored\",\n  \"serde_json\",\n  \"tempfile\",\n  \"tokio\",\n  \"tokio-process\",\n  \"tokio-timer\",\n- \"toml 0.5.3\",\n- \"url 1.7.2\",\n+ \"toml\",\n+ \"url 2.1.0\",\n  \"walkdir\",\n ]\n \n@@ -2792,9 +2982,33 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"rls-ipc\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"jsonrpc-core\",\n+ \"jsonrpc-core-client\",\n+ \"jsonrpc-derive\",\n+ \"jsonrpc-ipc-server\",\n+ \"rls-data\",\n+ \"serde\",\n+]\n+\n [[package]]\n name = \"rls-rustc\"\n version = \"0.6.0\"\n+dependencies = [\n+ \"clippy_lints\",\n+ \"env_logger\",\n+ \"failure\",\n+ \"futures\",\n+ \"log\",\n+ \"rand 0.6.1\",\n+ \"rls-data\",\n+ \"rls-ipc\",\n+ \"serde\",\n+ \"tokio\",\n+]\n \n [[package]]\n name = \"rls-span\"\n@@ -2837,11 +3051,10 @@ dependencies = [\n  \"fmt_macros\",\n  \"graphviz\",\n  \"jobserver\",\n- \"lazy_static 1.3.0\",\n  \"log\",\n  \"measureme\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"polonius-engine\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -2860,25 +3073,25 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-arena\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"4dc2e1e68b64268c543bfa6e63e3c0d9ea58074c71396f42f76931f35a9287f9\"\n+checksum = \"f59b76d334bd533f3fdc5c651c27678c5e80fac67c6f7da22ba21a58878c55f5\"\n dependencies = [\n  \"rustc-ap-rustc_data_structures\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-graphviz\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"c108d647ce0dd46477b048eafff5a6273b5652e02d47424b0cd684147379c811\"\n+checksum = \"3e632ef08ca17458acfd46d2ead3d541a1c249586cd5329f5fe333dacfab6142\"\n \n [[package]]\n name = \"rustc-ap-rustc_data_structures\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"656771744e0783cb8e4481e3b8b1f975687610aaf18833b898018111a0e0e582\"\n+checksum = \"e89e2c7be68185418f3cd56af3df8b29007a59a1cebefa63612d055f9bcb1a36\"\n dependencies = [\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n@@ -2887,7 +3100,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"rustc-ap-graphviz\",\n  \"rustc-ap-serialize\",\n  \"rustc-hash\",\n@@ -2899,44 +3112,48 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-rustc_errors\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"e37064f6624bc799bfaa2968b61ee6880926dea2a8bba69f18aef6c8e69c9604\"\n+checksum = \"1e47cb380abeb72b01e42b2342d592f7eeea7d536c2f1f0d0e550dc509e46333\"\n dependencies = [\n  \"annotate-snippets\",\n  \"atty\",\n  \"log\",\n  \"rustc-ap-rustc_data_structures\",\n  \"rustc-ap-serialize\",\n  \"rustc-ap-syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_lexer\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"ef5bc0a971823637ea23a857f0ef1467f44b1e05d71968821f83a0abe53e0fe3\"\n+checksum = \"494cfaf67f49217d67d0774eeecbba61ac89acf478db97ef11f113ed8a959305\"\n+dependencies = [\n+ \"unicode-xid 0.2.0\",\n+]\n \n [[package]]\n name = \"rustc-ap-rustc_macros\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b90037e3336fe8835f468db44d0848ae10d9cc8533ae89b55828883f905b7e80\"\n+checksum = \"e2e5d36becc59b4497f9cbd3ae0610081de0207a1d0e95c066369167b14f486f\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n [[package]]\n name = \"rustc-ap-rustc_target\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cadf9ca07315eab3a7a21f63872f9cc81e250fd6ede0419c24f8926ade73a45d\"\n+checksum = \"a7bfc5f96dfc3b9f8d5b57884f7f37467ecff6776cd4b8b491a7daece6fdd7c2\"\n dependencies = [\n  \"bitflags\",\n  \"log\",\n@@ -2947,19 +3164,19 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-serialize\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"61673783f2089e01033ffa82d1988f55175402071b31253a358292e1624d4602\"\n+checksum = \"2bb9ee231cf79eded39c56647499f83d6136ff5c8c0baaa9e21b6febee00f4f6\"\n dependencies = [\n  \"indexmap\",\n  \"smallvec\",\n ]\n \n [[package]]\n name = \"rustc-ap-syntax\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"28f3dd1346d5b0269c07a4a78855e309a298ab569c9c1302d4d4f57f8eee4e84\"\n+checksum = \"b3827fc208814efbde82d613e31d11b4250ce9e8cf8afe4a4d47bbbd099632c9\"\n dependencies = [\n  \"bitflags\",\n  \"lazy_static 1.3.0\",\n@@ -2977,9 +3194,9 @@ dependencies = [\n \n [[package]]\n name = \"rustc-ap-syntax_pos\"\n-version = \"546.0.0\"\n+version = \"583.0.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"45e67b526dbda3a0c7dab91c8947d43685e7697f52686a4949da3c179cd7c979\"\n+checksum = \"930ed81c34f325e512cc315c04d676fa84a373879d5c43bb54054a0522b05213\"\n dependencies = [\n  \"cfg-if\",\n  \"rustc-ap-arena\",\n@@ -3050,31 +3267,34 @@ checksum = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n \n [[package]]\n name = \"rustc-std-workspace-alloc\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"alloc\",\n ]\n \n [[package]]\n name = \"rustc-std-workspace-core\"\n-version = \"1.0.0\"\n+version = \"1.99.0\"\n dependencies = [\n  \"core\",\n ]\n \n+[[package]]\n+name = \"rustc-std-workspace-std\"\n+version = \"1.99.0\"\n+dependencies = [\n+ \"std\",\n+]\n+\n [[package]]\n name = \"rustc-workspace-hack\"\n version = \"1.0.0\"\n dependencies = [\n- \"byteorder\",\n  \"crossbeam-utils 0.6.5\",\n- \"parking_lot\",\n- \"rand 0.6.1\",\n- \"scopeguard 0.3.3\",\n  \"serde\",\n  \"serde_json\",\n  \"smallvec\",\n- \"syn\",\n+ \"url 2.1.0\",\n  \"winapi 0.3.6\",\n ]\n \n@@ -3114,11 +3334,7 @@ dependencies = [\n name = \"rustc_codegen_llvm\"\n version = \"0.0.0\"\n dependencies = [\n- \"cc\",\n- \"memmap\",\n- \"num_cpus\",\n  \"rustc_llvm\",\n- \"tempfile\",\n ]\n \n [[package]]\n@@ -3132,7 +3348,7 @@ dependencies = [\n  \"log\",\n  \"memmap\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc\",\n  \"rustc_apfloat\",\n  \"rustc_codegen_utils\",\n@@ -3175,7 +3391,7 @@ dependencies = [\n  \"jobserver\",\n  \"lazy_static 1.3.0\",\n  \"log\",\n- \"parking_lot\",\n+ \"parking_lot 0.9.0\",\n  \"rustc-hash\",\n  \"rustc-rayon\",\n  \"rustc-rayon-core\",\n@@ -3188,8 +3404,9 @@ dependencies = [\n name = \"rustc_driver\"\n version = \"0.0.0\"\n dependencies = [\n- \"env_logger 0.5.13\",\n+ \"env_logger\",\n  \"graphviz\",\n+ \"lazy_static 1.3.0\",\n  \"log\",\n  \"rustc\",\n  \"rustc_ast_borrowck\",\n@@ -3218,6 +3435,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"serialize\",\n  \"syntax_pos\",\n+ \"term_size\",\n  \"termcolor\",\n  \"unicode-width\",\n ]\n@@ -3232,7 +3450,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"graphviz\",\n  \"log\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc\",\n  \"rustc_data_structures\",\n  \"rustc_fs_util\",\n@@ -3246,6 +3464,7 @@ name = \"rustc_interface\"\n version = \"0.0.0\"\n dependencies = [\n  \"log\",\n+ \"once_cell\",\n  \"rustc\",\n  \"rustc-rayon\",\n  \"rustc_ast_borrowck\",\n@@ -3275,7 +3494,7 @@ dependencies = [\n name = \"rustc_lexer\"\n version = \"0.1.0\"\n dependencies = [\n- \"unicode-xid\",\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n@@ -3314,9 +3533,9 @@ name = \"rustc_macros\"\n version = \"0.1.0\"\n dependencies = [\n  \"itertools 0.8.0\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n  \"synstructure\",\n ]\n \n@@ -3353,6 +3572,7 @@ dependencies = [\n  \"rustc_apfloat\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_lexer\",\n  \"rustc_target\",\n  \"serialize\",\n  \"smallvec\",\n@@ -3524,7 +3744,7 @@ name = \"rustdoc\"\n version = \"0.0.0\"\n dependencies = [\n  \"minifier\",\n- \"pulldown-cmark\",\n+ \"pulldown-cmark 0.5.3\",\n  \"rustc-rayon\",\n  \"tempfile\",\n ]\n@@ -3554,26 +3774,25 @@ dependencies = [\n \n [[package]]\n name = \"rustfmt-config_proc_macro\"\n-version = \"0.1.2\"\n+version = \"0.2.0\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n  \"serde\",\n- \"syn\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n name = \"rustfmt-nightly\"\n-version = \"1.4.4\"\n+version = \"1.4.8\"\n dependencies = [\n  \"annotate-snippets\",\n- \"atty\",\n  \"bytecount\",\n  \"cargo_metadata\",\n  \"derive-new\",\n  \"diff\",\n  \"dirs\",\n- \"env_logger 0.6.0\",\n+ \"env_logger\",\n  \"failure\",\n  \"getopts\",\n  \"ignore\",\n@@ -3588,9 +3807,9 @@ dependencies = [\n  \"rustfmt-config_proc_macro\",\n  \"serde\",\n  \"serde_json\",\n- \"structopt\",\n+ \"structopt 0.3.1\",\n  \"term 0.6.0\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"unicode-segmentation\",\n  \"unicode-width\",\n  \"unicode_categories\",\n@@ -3697,18 +3916,9 @@ version = \"1.0.81\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"477b13b646f5b5b56fc95bedfc3b550d12141ce84f466f6c44b9a17589923885\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n-]\n-\n-[[package]]\n-name = \"serde_ignored\"\n-version = \"0.0.4\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"190e9765dcedb56be63b6e0993a006c7e3b071a016a304736e4a315dc01fb142\"\n-dependencies = [\n- \"serde\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3731,6 +3941,17 @@ dependencies = [\n  \"serde\",\n ]\n \n+[[package]]\n+name = \"serde_repr\"\n+version = \"0.1.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cd02c7587ec314570041b2754829f84d873ced14a96d1fd1823531e11db40573\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n+]\n+\n [[package]]\n name = \"serde_urlencoded\"\n version = \"0.5.5\"\n@@ -3847,12 +4068,13 @@ dependencies = [\n  \"panic_abort\",\n  \"panic_unwind\",\n  \"profiler_builtins\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"rustc_asan\",\n  \"rustc_lsan\",\n  \"rustc_msan\",\n  \"rustc_tsan\",\n  \"unwind\",\n+ \"wasi\",\n ]\n \n [[package]]\n@@ -3887,8 +4109,8 @@ checksum = \"1eea1eee654ef80933142157fdad9dd8bc43cf7c74e999e369263496f04ff4da\"\n dependencies = [\n  \"phf_generator\",\n  \"phf_shared\",\n- \"proc-macro2\",\n- \"quote\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n  \"string_cache_shared\",\n ]\n \n@@ -3909,9 +4131,9 @@ dependencies = [\n \n [[package]]\n name = \"strsim\"\n-version = \"0.7.0\"\n+version = \"0.8.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"bb4f380125926a99e52bc279241539c018323fab05ad6368b56f93d9369ff550\"\n+checksum = \"8ea5119cdb4c55b55d432abb513a0429384878c15dde60cc77b1c99de1a95a6a\"\n \n [[package]]\n name = \"structopt\"\n@@ -3920,7 +4142,17 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"16c2cdbf9cc375f15d1b4141bc48aeef444806655cd0e904207edc8d68d86ed7\"\n dependencies = [\n  \"clap\",\n- \"structopt-derive\",\n+ \"structopt-derive 0.2.18\",\n+]\n+\n+[[package]]\n+name = \"structopt\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ac9d6e93dd792b217bf89cda5c14566e3043960c6f9da890c2ba5d09d07804c\"\n+dependencies = [\n+ \"clap\",\n+ \"structopt-derive 0.3.1\",\n ]\n \n [[package]]\n@@ -3930,9 +4162,22 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"53010261a84b37689f9ed7d395165029f9cc7abb9f56bbfe86bee2597ed25107\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+]\n+\n+[[package]]\n+name = \"structopt-derive\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2ae9e5165d463a0dea76967d021f8d0f9316057bf5163aa2a4843790e842ff37\"\n+dependencies = [\n+ \"heck\",\n+ \"proc-macro-error\",\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"syn 1.0.5\",\n ]\n \n [[package]]\n@@ -3948,9 +4193,9 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"8baacebd7b7c9b864d83a6ba7a246232983e277b86fa5cdec77f565715a4b136\"\n dependencies = [\n  \"heck\",\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -3959,9 +4204,20 @@ version = \"0.15.35\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"641e117d55514d6d918490e47102f7e08d096fdde360247e4a10f7a91a8478d3\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"unicode-xid\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"unicode-xid 0.1.0\",\n+]\n+\n+[[package]]\n+name = \"syn\"\n+version = \"1.0.5\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"66850e97125af79138385e9b88339cbcd037e3f28ceab8c5ad98e64f0f1f80bf\"\n+dependencies = [\n+ \"proc-macro2 1.0.3\",\n+ \"quote 1.0.2\",\n+ \"unicode-xid 0.2.0\",\n ]\n \n [[package]]\n@@ -3970,10 +4226,10 @@ version = \"0.10.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"02353edf96d6e4dc81aea2d8490a7e9db177bf8acb0e951c24940bf866cb313f\"\n dependencies = [\n- \"proc-macro2\",\n- \"quote\",\n- \"syn\",\n- \"unicode-xid\",\n+ \"proc-macro2 0.4.30\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n+ \"unicode-xid 0.1.0\",\n ]\n \n [[package]]\n@@ -4002,6 +4258,7 @@ dependencies = [\n  \"log\",\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n+ \"rustc_lexer\",\n  \"rustc_target\",\n  \"smallvec\",\n  \"syntax\",\n@@ -4041,13 +4298,13 @@ dependencies = [\n \n [[package]]\n name = \"tempfile\"\n-version = \"3.0.5\"\n+version = \"3.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"7e91405c14320e5c79b3d148e1c86f40749a36e490642202a31689cb1a3452b2\"\n+checksum = \"7a6e24d9338a0a5be79593e2fa15a648add6138caa803e2d5bc782c371732ca9\"\n dependencies = [\n  \"cfg-if\",\n  \"libc\",\n- \"rand 0.6.1\",\n+ \"rand 0.7.0\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n  \"winapi 0.3.6\",\n@@ -4067,6 +4324,10 @@ dependencies = [\n [[package]]\n name = \"term\"\n version = \"0.0.0\"\n+dependencies = [\n+ \"core\",\n+ \"std\",\n+]\n \n [[package]]\n name = \"term\"\n@@ -4089,6 +4350,17 @@ dependencies = [\n  \"winapi 0.3.6\",\n ]\n \n+[[package]]\n+name = \"term_size\"\n+version = \"0.3.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9e5b9a66db815dcfd2da92db471106457082577c3c278d4138ab3e3b4e189327\"\n+dependencies = [\n+ \"kernel32-sys\",\n+ \"libc\",\n+ \"winapi 0.2.8\",\n+]\n+\n [[package]]\n name = \"termcolor\"\n version = \"1.0.4\"\n@@ -4113,8 +4385,13 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n+ \"core\",\n  \"getopts\",\n+ \"libc\",\n+ \"panic_abort\",\n+ \"panic_unwind\",\n  \"proc_macro\",\n+ \"std\",\n  \"term 0.0.0\",\n ]\n \n@@ -4131,9 +4408,9 @@ dependencies = [\n \n [[package]]\n name = \"textwrap\"\n-version = \"0.10.0\"\n+version = \"0.11.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"307686869c93e71f94da64286f9a9524c0f308a9e1c87a583de8e9c9039ad3f6\"\n+checksum = \"d326610f408c7a4eb6f51c37c330e496b08506c9457c9d34287ecc38809fb060\"\n dependencies = [\n  \"unicode-width\",\n ]\n@@ -4256,6 +4533,19 @@ dependencies = [\n  \"log\",\n ]\n \n+[[package]]\n+name = \"tokio-named-pipes\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9d282d483052288b2308ba5ee795f5673b159c9bdf63c385a05609da782a5eae\"\n+dependencies = [\n+ \"bytes\",\n+ \"futures\",\n+ \"mio\",\n+ \"mio-named-pipes\",\n+ \"tokio\",\n+]\n+\n [[package]]\n name = \"tokio-process\"\n version = \"0.2.3\"\n@@ -4284,12 +4574,21 @@ dependencies = [\n  \"log\",\n  \"mio\",\n  \"num_cpus\",\n- \"parking_lot\",\n+ \"parking_lot 0.7.1\",\n  \"slab\",\n  \"tokio-executor\",\n  \"tokio-io\",\n ]\n \n+[[package]]\n+name = \"tokio-service\"\n+version = \"0.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"24da22d077e0f15f55162bdbdc661228c1581892f52074fb242678d015b45162\"\n+dependencies = [\n+ \"futures\",\n+]\n+\n [[package]]\n name = \"tokio-signal\"\n version = \"0.2.7\"\n@@ -4382,15 +4681,6 @@ dependencies = [\n  \"tokio-reactor\",\n ]\n \n-[[package]]\n-name = \"toml\"\n-version = \"0.4.10\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"758664fc71a3a69038656bee8b6be6477d2a6c315a6b81f7081f591bffa4111f\"\n-dependencies = [\n- \"serde\",\n-]\n-\n [[package]]\n name = \"toml\"\n version = \"0.5.3\"\n@@ -4411,7 +4701,7 @@ dependencies = [\n  \"is-match\",\n  \"lazy_static 1.3.0\",\n  \"regex\",\n- \"toml 0.5.3\",\n+ \"toml\",\n  \"toml-query_derive\",\n ]\n \n@@ -4422,8 +4712,8 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"3c99ca245ec273c7e75c8ee58f47b882d0146f3c2c8495158082c6671e8b5335\"\n dependencies = [\n  \"darling\",\n- \"quote\",\n- \"syn\",\n+ \"quote 0.6.12\",\n+ \"syn 0.15.35\",\n ]\n \n [[package]]\n@@ -4461,9 +4751,9 @@ dependencies = [\n \n [[package]]\n name = \"unicase\"\n-version = \"2.4.0\"\n+version = \"2.5.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"a84e5511b2a947f3ae965dcb29b13b7b1691b6e7332cf5dbc1744138d5acb7f6\"\n+checksum = \"2e2e6bd1e59e56598518beb94fd6db628ded570326f0a98c679a304bd9f00150\"\n dependencies = [\n  \"version_check\",\n ]\n@@ -4491,16 +4781,27 @@ checksum = \"aa6024fc12ddfd1c6dbc14a80fa2324d4568849869b779f6bd37e5e4c03344d1\"\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.5\"\n+version = \"0.1.6\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"882386231c45df4700b275c7ff55b6f3698780a650026380e72dabe76fa46526\"\n+checksum = \"7007dbd421b92cc6e28410fe7362e2e0a2503394908f417b68ec8d1c364c4e20\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-core\",\n+ \"rustc-std-workspace-std\",\n+]\n \n [[package]]\n name = \"unicode-xid\"\n version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc\"\n \n+[[package]]\n+name = \"unicode-xid\"\n+version = \"0.2.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c\"\n+\n [[package]]\n name = \"unicode_categories\"\n version = \"0.1.1\"\n@@ -4549,16 +4850,6 @@ dependencies = [\n  \"serde\",\n ]\n \n-[[package]]\n-name = \"url_serde\"\n-version = \"0.2.0\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"74e7d099f1ee52f823d4bdd60c93c3602043c728f5db3b97bdb548467f7bddea\"\n-dependencies = [\n- \"serde\",\n- \"url 1.7.2\",\n-]\n-\n [[package]]\n name = \"utf-8\"\n version = \"0.7.2\"\n@@ -4646,6 +4937,17 @@ dependencies = [\n  \"try-lock\",\n ]\n \n+[[package]]\n+name = \"wasi\"\n+version = \"0.7.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b89c3ce4ce14bdc6fb6beaf9ec7928ca331de5df7e5ea278375642a2f478570d\"\n+dependencies = [\n+ \"compiler_builtins\",\n+ \"rustc-std-workspace-alloc\",\n+ \"rustc-std-workspace-core\",\n+]\n+\n [[package]]\n name = \"winapi\"\n version = \"0.2.8\""}, {"sha": "a242f090fbc07e889723c334dcb8689b3314be7b", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -68,6 +68,7 @@ rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n # here\n rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n+rustc-std-workspace-std = { path = 'src/tools/rustc-std-workspace-std' }\n \n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "96d7e938be2f2ca8cbf253e70213530827a547c4", "filename": "README.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -26,12 +26,13 @@ or reading the [rustc guide][rustcguidebuild].\n ### Building on *nix\n 1. Make sure you have installed the dependencies:\n \n-   * `g++` 4.7 or later or `clang++` 3.x or later\n+   * `g++` 5.1 or later or `clang++` 3.5 or later\n    * `python` 2.7 (but not 3.x)\n    * GNU `make` 3.81 or later\n    * `cmake` 3.4.3 or later\n    * `curl`\n    * `git`\n+   * `ssl` which comes in `libssl-dev` or `openssl-devel`\n \n 2. Clone the [source] with `git`:\n \n@@ -56,6 +57,8 @@ or reading the [rustc guide][rustcguidebuild].\n     an installation (using `./x.py install`) that you set the `prefix` value\n     in the `[install]` section to a directory that you have write permissions.\n \n+    Create install directory if you are not installing in default directory\n+\n 4. Build and install:\n \n     ```sh\n@@ -148,6 +151,17 @@ by manually calling the appropriate vcvars file before running the bootstrap.\n > python x.py build\n ```\n \n+### Building rustc with older host toolchains\n+It is still possible to build Rust with the older toolchain versions listed below, but only if the\n+LLVM_TEMPORARILY_ALLOW_OLD_TOOLCHAIN option is set to true in the config.toml file.\n+\n+* Clang 3.1\n+* Apple Clang 3.1\n+* GCC 4.8\n+* Visual Studio 2015 (Update 3)\n+\n+Toolchain versions older than what is listed above cannot be used to build rustc.\n+\n #### Specifying an ABI\n \n Each specific ABI can also be used from either environment (for example, using"}, {"sha": "ecf49278f4b521d9779ffd4e5a7b3242457f6a31", "filename": "RELEASES.md", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,3 +1,117 @@\n+Version 1.38.0 (2019-09-26)\n+==========================\n+\n+Language\n+--------\n+- [The `#[global_allocator]` attribute can now be used in submodules.][62735]\n+- [The `#[deprecated]` attribute can now be used on macros.][62042]\n+\n+Compiler\n+--------\n+- [Added pipelined compilation support to `rustc`.][62766] This will\n+  improve compilation times in some cases. For further information please refer\n+  to the [_\"Evaluating pipelined rustc compilation\"_][pipeline-internals] thread.\n+- [Added tier 3\\* support for the `aarch64-uwp-windows-msvc`, `i686-uwp-windows-gnu`,\n+  `i686-uwp-windows-msvc`, `x86_64-uwp-windows-gnu`, and\n+  `x86_64-uwp-windows-msvc` targets.][60260]\n+- [Added tier 3 support for the `armv7-unknown-linux-gnueabi` and\n+  `armv7-unknown-linux-musleabi` targets.][63107]\n+- [Added tier 3 support for the `hexagon-unknown-linux-musl` target.][62814]\n+- [Added tier 3 support for the `riscv32i-unknown-none-elf` target.][62784]\n+\n+\\* Refer to Rust's [platform support page][forge-platform-support] for more\n+information on Rust's tiered platform support.\n+\n+Libraries\n+---------\n+- [`ascii::EscapeDefault` now implements `Clone` and `Display`.][63421]\n+- [Derive macros for prelude traits (e.g. `Clone`, `Debug`, `Hash`) are now\n+  available at the same path as the trait.][63056] (e.g. The `Clone` derive macro\n+  is available at `std::clone::Clone`). This also makes all built-in macros\n+  available in `std`/`core` root. e.g. `std::include_bytes!`.\n+- [`str::Chars` now implements `Debug`.][63000]\n+- [`slice::{concat, connect, join}` now accepts `&[T]` in addition to `&T`.][62528]\n+- [`*const T` and `*mut T` now implement `marker::Unpin`.][62583]\n+- [`Arc<[T]>` and `Rc<[T]>` now implement `FromIterator<T>`.][61953]\n+- [Added euclidean remainder and division operations (`div_euclid`,\n+  `rem_euclid`) to all numeric primitives.][61884] Additionally `checked`,\n+  `overflowing`, and `wrapping` versions are available for all\n+  integer primitives.\n+- [`thread::AccessError` now implements `Clone`, `Copy`, `Eq`, `Error`, and\n+  `PartialEq`.][61491]\n+- [`iter::{StepBy, Peekable, Take}` now implement `DoubleEndedIterator`.][61457]\n+\n+Stabilized APIs\n+---------------\n+- [`<*const T>::cast`]\n+- [`<*mut T>::cast`]\n+- [`Duration::as_secs_f32`]\n+- [`Duration::as_secs_f64`]\n+- [`Duration::div_duration_f32`]\n+- [`Duration::div_duration_f64`]\n+- [`Duration::div_f32`]\n+- [`Duration::div_f64`]\n+- [`Duration::from_secs_f32`]\n+- [`Duration::from_secs_f64`]\n+- [`Duration::mul_f32`]\n+- [`Duration::mul_f64`]\n+- [`any::type_name`]\n+\n+Cargo\n+-----\n+- [Added pipelined compilation support to `cargo`.][cargo/7143]\n+- [You can now pass the `--features` option multiple times to enable\n+  multiple features.][cargo/7084]\n+\n+Misc\n+----\n+- [`rustc` will now warn about some incorrect uses of\n+  `mem::{uninitialized, zeroed}` that are known to cause undefined behaviour.][63346]\n+\n+Compatibility Notes\n+-------------------\n+- Unfortunately the [`x86_64-unknown-uefi` platform can not be built][62785]\n+  with rustc 1.39.0.\n+- The [`armv7-unknown-linux-gnueabihf` platform is also known to have\n+  issues][62896] for certain crates such as libc.\n+\n+[60260]: https://github.com/rust-lang/rust/pull/60260/\n+[61457]: https://github.com/rust-lang/rust/pull/61457/\n+[61491]: https://github.com/rust-lang/rust/pull/61491/\n+[61884]: https://github.com/rust-lang/rust/pull/61884/\n+[61953]: https://github.com/rust-lang/rust/pull/61953/\n+[62042]: https://github.com/rust-lang/rust/pull/62042/\n+[62528]: https://github.com/rust-lang/rust/pull/62528/\n+[62583]: https://github.com/rust-lang/rust/pull/62583/\n+[62735]: https://github.com/rust-lang/rust/pull/62735/\n+[62766]: https://github.com/rust-lang/rust/pull/62766/\n+[62784]: https://github.com/rust-lang/rust/pull/62784/\n+[62785]: https://github.com/rust-lang/rust/issues/62785/\n+[62814]: https://github.com/rust-lang/rust/pull/62814/\n+[62896]: https://github.com/rust-lang/rust/issues/62896/\n+[63000]: https://github.com/rust-lang/rust/pull/63000/\n+[63056]: https://github.com/rust-lang/rust/pull/63056/\n+[63107]: https://github.com/rust-lang/rust/pull/63107/\n+[63346]: https://github.com/rust-lang/rust/pull/63346/\n+[63421]: https://github.com/rust-lang/rust/pull/63421/\n+[cargo/7084]: https://github.com/rust-lang/cargo/pull/7084/\n+[cargo/7143]: https://github.com/rust-lang/cargo/pull/7143/\n+[`<*const T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`<*mut T>::cast`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.cast\n+[`Duration::as_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f32\n+[`Duration::as_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.as_secs_f64\n+[`Duration::div_duration_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f32\n+[`Duration::div_duration_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_duration_f64\n+[`Duration::div_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f32\n+[`Duration::div_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.div_f64\n+[`Duration::from_secs_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f32\n+[`Duration::from_secs_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.from_secs_f64\n+[`Duration::mul_f32`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f32\n+[`Duration::mul_f64`]: https://doc.rust-lang.org/std/time/struct.Duration.html#method.mul_f64\n+[`any::type_name`]: https://doc.rust-lang.org/std/any/fn.type_name.html\n+[forge-platform-support]: https://forge.rust-lang.org/platform-support.html\n+[pipeline-internals]: https://internals.rust-lang.org/t/evaluating-pipelined-rustc-compilation/10199\n+\n Version 1.37.0 (2019-08-15)\n ==========================\n "}, {"sha": "848147c2974c1d77bc1a7c7c4e88c6cb7bef9cfe", "filename": "config.toml.example", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -184,7 +184,7 @@\n # default.\n #extended = false\n \n-# Installs chosen set of extended tools if enables. By default builds all.\n+# Installs chosen set of extended tools if enabled. By default builds all.\n # If chosen tool failed to build the installation fails.\n #tools = [\"cargo\", \"rls\", \"clippy\", \"rustfmt\", \"analysis\", \"src\"]\n \n@@ -382,11 +382,6 @@\n # This is the name of the directory in which codegen backends will get installed\n #codegen-backends-dir = \"codegen-backends\"\n \n-# Flag indicating whether `libstd` calls an imported function to handle basic IO\n-# when targeting WebAssembly. Enable this to debug tests for the `wasm32-unknown-unknown`\n-# target, as without this option the test output will not be captured.\n-#wasm-syscall = false\n-\n # Indicates whether LLD will be compiled and made available in the sysroot for\n # rustc to execute.\n #lld = false"}, {"sha": "c27c318f5ad07201703bd2a424fc5caed3ac80f3", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -44,7 +44,7 @@ cc = \"1.0.35\"\n libc = \"0.2\"\n serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n-toml = \"0.4\"\n+toml = \"0.5\"\n lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\""}, {"sha": "138b7f4b261046bad584bd2acd730da9e5b1bcf0", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,9 +5,6 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n \n use bootstrap::{Config, Build};"}, {"sha": "84415baa3a14085a63b572e0e4d625c18d077a42", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -15,9 +15,6 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::ffi::OsString;\n use std::io;\n@@ -122,16 +119,18 @@ fn main() {\n         cmd.arg(format!(\"-Cdebuginfo={}\", debuginfo_level));\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n-       env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n-        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n-        // there as well, some code doesn't go through this `rustc` wrapper.\n-        cmd.arg(\"-Dwarnings\");\n-        cmd.arg(\"-Drust_2018_idioms\");\n-        cmd.arg(\"-Dunused_lifetimes\");\n+    if env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n+        // When extending this list, add the new lints to the RUSTFLAGS of the\n+        // build_bootstrap function of src/bootstrap/bootstrap.py as well as\n+        // some code doesn't go through this `rustc` wrapper.\n+        cmd.arg(\"-Wrust_2018_idioms\");\n+        cmd.arg(\"-Wunused_lifetimes\");\n         if use_internal_lints(crate_name) {\n             cmd.arg(\"-Zunstable-options\");\n-            cmd.arg(\"-Drustc::internal\");\n+            cmd.arg(\"-Wrustc::internal\");\n+        }\n+        if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() {\n+            cmd.arg(\"-Dwarnings\");\n         }\n     }\n "}, {"sha": "a13ff69a7b56f79f91a490541f3808cff974c004", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -2,12 +2,10 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::env;\n use std::process::Command;\n use std::path::PathBuf;\n+use std::ffi::OsString;\n \n fn main() {\n     let args = env::args_os().skip(1).collect::<Vec<_>>();\n@@ -47,7 +45,9 @@ fn main() {\n         cmd.arg(\"-Z\").arg(\"force-unstable-if-unmarked\");\n     }\n     if let Some(linker) = env::var_os(\"RUSTC_TARGET_LINKER\") {\n-        cmd.arg(\"--linker\").arg(linker).arg(\"-Z\").arg(\"unstable-options\");\n+        let mut arg = OsString::from(\"-Clinker=\");\n+        arg.push(&linker);\n+        cmd.arg(arg);\n     }\n \n     // Bootstrap's Cargo-command builder sets this variable to the current Rust version; let's pick"}, {"sha": "65129eeeec5041a267012ab20b59a31ec32b7a1b", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -320,7 +320,7 @@ class RustBuild(object):\n     def __init__(self):\n         self.cargo_channel = ''\n         self.date = ''\n-        self._download_url = 'https://static.rust-lang.org'\n+        self._download_url = ''\n         self.rustc_channel = ''\n         self.build = ''\n         self.build_dir = os.path.join(os.getcwd(), \"build\")\n@@ -523,6 +523,10 @@ def get_toml(self, key, section=None):\n         'value2'\n         >>> rb.get_toml('key', 'c') is None\n         True\n+\n+        >>> rb.config_toml = 'key1 = true'\n+        >>> rb.get_toml(\"key1\")\n+        'true'\n         \"\"\"\n \n         cur_section = None\n@@ -571,6 +575,12 @@ def get_string(line):\n \n         >>> RustBuild.get_string('    \"devel\"   ')\n         'devel'\n+        >>> RustBuild.get_string(\"    'devel'   \")\n+        'devel'\n+        >>> RustBuild.get_string('devel') is None\n+        True\n+        >>> RustBuild.get_string('    \"devel   ')\n+        ''\n         \"\"\"\n         start = line.find('\"')\n         if start != -1:\n@@ -631,6 +641,9 @@ def build_bootstrap(self):\n         target_linker = self.get_toml(\"linker\", build_section)\n         if target_linker is not None:\n             env[\"RUSTFLAGS\"] += \"-C linker=\" + target_linker + \" \"\n+        env[\"RUSTFLAGS\"] += \" -Wrust_2018_idioms -Wunused_lifetimes \"\n+        if self.get_toml(\"deny-warnings\", \"rust\") != \"false\":\n+            env[\"RUSTFLAGS\"] += \"-Dwarnings \"\n \n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n@@ -666,7 +679,7 @@ def check_submodule(self, module, slow_submodules):\n     def update_submodule(self, module, checked_out, recorded_submodules):\n         module_path = os.path.join(self.rust_root, module)\n \n-        if checked_out != None:\n+        if checked_out is not None:\n             default_encoding = sys.getdefaultencoding()\n             checked_out = checked_out.communicate()[0].decode(default_encoding).strip()\n             if recorded_submodules[module] == checked_out:\n@@ -695,6 +708,14 @@ def update_submodules(self):\n         if (not os.path.exists(os.path.join(self.rust_root, \".git\"))) or \\\n                 self.get_toml('submodules') == \"false\":\n             return\n+\n+        # check the existence of 'git' command\n+        try:\n+            subprocess.check_output(['git', '--version'])\n+        except (subprocess.CalledProcessError, OSError):\n+            print(\"error: `git` is not found, please make sure it's installed and in the path.\")\n+            sys.exit(1)\n+\n         slow_submodules = self.get_toml('fast-submodules') == \"false\"\n         start_time = time()\n         if slow_submodules:\n@@ -731,9 +752,19 @@ def update_submodules(self):\n             self.update_submodule(module[0], module[1], recorded_submodules)\n         print(\"Submodules updated in %.2f seconds\" % (time() - start_time))\n \n+    def set_normal_environment(self):\n+        \"\"\"Set download URL for normal environment\"\"\"\n+        if 'RUSTUP_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://static.rust-lang.org'\n+\n     def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n-        self._download_url = 'https://dev-static.rust-lang.org'\n+        if 'RUSTUP_DEV_DIST_SERVER' in os.environ:\n+            self._download_url = os.environ['RUSTUP_DEV_DIST_SERVER']\n+        else:\n+            self._download_url = 'https://dev-static.rust-lang.org'\n \n     def check_vendored_status(self):\n         \"\"\"Check that vendoring is configured properly\"\"\"\n@@ -809,13 +840,13 @@ def bootstrap(help_triggered):\n     except (OSError, IOError):\n         pass\n \n-    match = re.search(r'\\nverbose = (\\d+)', build.config_toml)\n-    if match is not None:\n-        build.verbose = max(build.verbose, int(match.group(1)))\n+    config_verbose = build.get_toml('verbose', 'build')\n+    if config_verbose is not None:\n+        build.verbose = max(build.verbose, int(config_verbose))\n \n-    build.use_vendored_sources = '\\nvendor = true' in build.config_toml\n+    build.use_vendored_sources = build.get_toml('vendor', 'build') == 'true'\n \n-    build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n+    build.use_locked_deps = build.get_toml('locked-deps', 'build') == 'true'\n \n     build.check_vendored_status()\n \n@@ -826,6 +857,8 @@ def bootstrap(help_triggered):\n \n     if 'dev' in data:\n         build.set_dev_environment()\n+    else:\n+        build.set_normal_environment()\n \n     build.update_submodules()\n "}, {"sha": "b7873fd1d35814b68811472fe5dea76e2faeca82", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 6, "deletions": 11, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -337,7 +337,6 @@ impl<'a> Builder<'a> {\n         match kind {\n             Kind::Build => describe!(\n                 compile::Std,\n-                compile::Test,\n                 compile::Rustc,\n                 compile::CodegenBackend,\n                 compile::StartupObjects,\n@@ -363,7 +362,6 @@ impl<'a> Builder<'a> {\n             ),\n             Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n-                check::Test,\n                 check::Rustc,\n                 check::CodegenBackend,\n                 check::Rustdoc\n@@ -425,8 +423,6 @@ impl<'a> Builder<'a> {\n                 doc::TheBook,\n                 doc::Standalone,\n                 doc::Std,\n-                doc::Test,\n-                doc::WhitelistedRustc,\n                 doc::Rustc,\n                 doc::Rustdoc,\n                 doc::ErrorIndex,\n@@ -801,7 +797,7 @@ impl<'a> Builder<'a> {\n         }\n \n         match mode {\n-            Mode::Std | Mode::Test | Mode::ToolBootstrap | Mode::ToolStd | Mode::ToolTest=> {},\n+            Mode::Std | Mode::ToolBootstrap | Mode::ToolStd => {},\n             Mode::Rustc | Mode::Codegen | Mode::ToolRustc => {\n                 // Build proc macros both for the host and the target\n                 if target != compiler.host && cmd != \"check\" {\n@@ -852,7 +848,6 @@ impl<'a> Builder<'a> {\n         // things still build right, please do!\n         match mode {\n             Mode::Std => metadata.push_str(\"std\"),\n-            Mode::Test => metadata.push_str(\"test\"),\n             _ => {},\n         }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n@@ -875,8 +870,7 @@ impl<'a> Builder<'a> {\n         }\n \n         if cmd == \"clippy\" {\n-            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n-                --json-rendered=termcolor\");\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked\");\n         }\n \n         if !extra_args.is_empty() {\n@@ -949,9 +943,9 @@ impl<'a> Builder<'a> {\n \n         let debuginfo_level = match mode {\n             Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n-            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::Std => self.config.rust_debuginfo_level_std,\n             Mode::ToolBootstrap | Mode::ToolStd |\n-            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+            Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n         };\n         cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n \n@@ -1151,7 +1145,6 @@ impl<'a> Builder<'a> {\n \n         match (mode, self.config.rust_codegen_units_std, self.config.rust_codegen_units) {\n             (Mode::Std, Some(n), _) |\n-            (Mode::Test, Some(n), _) |\n             (_, _, Some(n)) => {\n                 cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n             }\n@@ -1174,6 +1167,8 @@ impl<'a> Builder<'a> {\n             cargo.arg(\"--frozen\");\n         }\n \n+        cargo.env(\"RUSTC_INSTALL_BINDIR\", &self.config.bindir);\n+\n         self.ci_env.force_coloring_in_ci(&mut cargo);\n \n         cargo"}, {"sha": "2bb90fdb04edcef41bfe0e2df25743d1f4460307", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 64, "deletions": 89, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -365,27 +365,6 @@ fn dist_with_same_targets_and_hosts() {\n             },\n         ]\n     );\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-        ]\n-    );\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -415,7 +394,47 @@ fn build_default() {\n     let b = INTERNER.intern_str(\"B\");\n     let c = INTERNER.intern_str(\"C\");\n \n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n     assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Rustc>()),\n@@ -450,63 +469,61 @@ fn build_default() {\n             },\n         ]\n     );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n \n     assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n+        first(builder.cache.all::<compile::Std>()),\n         &[\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 0 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: a,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 1 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: b,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: a, stage: 2 },\n                 target: c,\n             },\n-            compile::Test {\n+            compile::Std {\n                 compiler: Compiler { host: b, stage: 2 },\n                 target: c,\n             },\n         ]\n     );\n-}\n-\n-#[test]\n-fn build_with_target_flag() {\n-    let mut config = configure(&[\"B\"], &[\"C\"]);\n-    config.skip_only_host_steps = true;\n-    let build = Build::new(config);\n-    let mut builder = Builder::new(&build);\n-    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-    let a = INTERNER.intern_str(\"A\");\n-    let b = INTERNER.intern_str(\"B\");\n-    let c = INTERNER.intern_str(\"C\");\n-\n-    assert!(!builder.cache.all::<compile::Std>().is_empty());\n     assert_eq!(\n         first(builder.cache.all::<compile::Assemble>()),\n         &[\n@@ -541,48 +558,6 @@ fn build_with_target_flag() {\n             },\n         ]\n     );\n-\n-    assert_eq!(\n-        first(builder.cache.all::<compile::Test>()),\n-        &[\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 0 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: a,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 1 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: b,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: c,\n-            },\n-            compile::Test {\n-                compiler: Compiler { host: b, stage: 2 },\n-                target: c,\n-            },\n-        ]\n-    );\n }\n \n #[test]"}, {"sha": "205a80c3a3a9e5b2129bb7be7fcd2308197e8b40", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 3, "deletions": 54, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,6 +1,6 @@\n //! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n-use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n+use crate::compile::{run_cargo, std_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n@@ -34,7 +34,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -92,7 +92,7 @@ impl Step for Rustc {\n         let compiler = builder.compiler(0, builder.config.build);\n         let target = self.target;\n \n-        builder.ensure(Test { target });\n+        builder.ensure(Std { target });\n \n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n             cargo_subcommand(builder.kind));\n@@ -159,47 +159,6 @@ impl Step for CodegenBackend {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            target: run.target,\n-        });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = builder.compiler(0, builder.config.build);\n-        let target = self.target;\n-\n-        builder.ensure(Std { target });\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  args(builder.kind),\n-                  &libtest_stamp(builder, compiler, target),\n-                  true);\n-\n-        let libdir = builder.sysroot_libdir(compiler, target);\n-        let hostdir = builder.sysroot_libdir(compiler, compiler.host);\n-        add_to_sysroot(builder, &libdir, &hostdir, &libtest_stamp(builder, compiler, target));\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustdoc {\n     pub target: Interned<String>,\n@@ -258,16 +217,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd-check.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest-check.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "9a964457ef285b630ad8bcf31fa5dc9c6b32388b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 5, "deletions": 137, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -39,7 +39,7 @@ impl Step for Std {\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"std\")\n+        run.all_krates(\"test\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -212,11 +212,12 @@ pub fn std_cargo(builder: &Builder<'_>,\n                 emscripten: false,\n             });\n             cargo.env(\"LLVM_CONFIG\", llvm_config);\n+            cargo.env(\"RUSTC_BUILD_SANITIZERS\", \"1\");\n         }\n \n         cargo.arg(\"--features\").arg(features)\n             .arg(\"--manifest-path\")\n-            .arg(builder.src.join(\"src/libstd/Cargo.toml\"));\n+            .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n \n         if target.contains(\"musl\") {\n             if let Some(p) = builder.musl_root(target) {\n@@ -358,129 +359,6 @@ impl Step for StartupObjects {\n     }\n }\n \n-#[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct Test {\n-    pub target: Interned<String>,\n-    pub compiler: Compiler,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.all_krates(\"test\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Builds libtest.\n-    ///\n-    /// This will build libtest and supporting libraries for a particular stage of\n-    /// the build using the `compiler` targeting the `target` architecture. The\n-    /// artifacts created will also be linked into the sysroot directory.\n-    fn run(self, builder: &Builder<'_>) {\n-        let target = self.target;\n-        let compiler = self.compiler;\n-\n-        builder.ensure(Std { compiler, target });\n-\n-        if builder.config.keep_stage.contains(&compiler.stage) {\n-            builder.info(\"Warning: Using a potentially old libtest. This may not behave well.\");\n-            builder.ensure(TestLink {\n-                compiler,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n-        if compiler_to_use != compiler {\n-            builder.ensure(Test {\n-                compiler: compiler_to_use,\n-                target,\n-            });\n-            builder.info(\n-                &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n-            builder.ensure(TestLink {\n-                compiler: compiler_to_use,\n-                target_compiler: compiler,\n-                target,\n-            });\n-            return;\n-        }\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n-        test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n-                &compiler.host, target));\n-        run_cargo(builder,\n-                  &mut cargo,\n-                  vec![],\n-                  &libtest_stamp(builder, compiler, target),\n-                  false);\n-\n-        builder.ensure(TestLink {\n-            compiler: builder.compiler(compiler.stage, builder.config.build),\n-            target_compiler: compiler,\n-            target,\n-        });\n-    }\n-}\n-\n-/// Same as `std_cargo`, but for libtest\n-pub fn test_cargo(builder: &Builder<'_>,\n-                  _compiler: &Compiler,\n-                  _target: Interned<String>,\n-                  cargo: &mut Command) {\n-    if let Some(target) = env::var_os(\"MACOSX_STD_DEPLOYMENT_TARGET\") {\n-        cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n-    }\n-    cargo.arg(\"--manifest-path\")\n-        .arg(builder.src.join(\"src/libtest/Cargo.toml\"));\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TestLink {\n-    pub compiler: Compiler,\n-    pub target_compiler: Compiler,\n-    pub target: Interned<String>,\n-}\n-\n-impl Step for TestLink {\n-    type Output = ();\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Same as `std_link`, only for libtest\n-    fn run(self, builder: &Builder<'_>) {\n-        let compiler = self.compiler;\n-        let target_compiler = self.target_compiler;\n-        let target = self.target;\n-        builder.info(&format!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n-                target_compiler.stage,\n-                compiler.stage,\n-                &compiler.host,\n-                target_compiler.host,\n-                target));\n-        add_to_sysroot(\n-            builder,\n-            &builder.sysroot_libdir(target_compiler, target),\n-            &builder.sysroot_libdir(target_compiler, compiler.host),\n-            &libtest_stamp(builder, compiler, target)\n-        );\n-    }\n-}\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct Rustc {\n     pub target: Interned<String>,\n@@ -512,7 +390,7 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.ensure(Test { compiler, target });\n+        builder.ensure(Std { compiler, target });\n \n         if builder.config.keep_stage.contains(&compiler.stage) {\n             builder.info(\"Warning: Using a potentially old librustc. This may not behave well.\");\n@@ -541,7 +419,7 @@ impl Step for Rustc {\n         }\n \n         // Ensure that build scripts and proc macros have a std / libproc_macro to link against.\n-        builder.ensure(Test {\n+        builder.ensure(Std {\n             compiler: builder.compiler(self.compiler.stage, builder.config.build),\n             target: builder.config.build,\n         });\n@@ -872,16 +750,6 @@ pub fn libstd_stamp(\n     builder.cargo_out(compiler, Mode::Std, target).join(\".libstd.stamp\")\n }\n \n-/// Cargo's output path for libtest in a given stage, compiled by a particular\n-/// compiler for the specified target.\n-pub fn libtest_stamp(\n-    builder: &Builder<'_>,\n-    compiler: Compiler,\n-    target: Interned<String>,\n-) -> PathBuf {\n-    builder.cargo_out(compiler, Mode::Test, target).join(\".libtest.stamp\")\n-}\n-\n /// Cargo's output path for librustc in a given stage, compiled by a particular\n /// compiler for the specified target.\n pub fn librustc_stamp("}, {"sha": "52b5cd888df9c20222db09aaf1b7a1920be57b90", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -122,7 +122,6 @@ pub struct Config {\n \n     // libstd features\n     pub backtrace: bool, // support for RUST_BACKTRACE\n-    pub wasm_syscall: bool,\n \n     // misc\n     pub low_priority: bool,\n@@ -138,7 +137,7 @@ pub struct Config {\n     pub sysconfdir: Option<PathBuf>,\n     pub datadir: Option<PathBuf>,\n     pub docdir: Option<PathBuf>,\n-    pub bindir: Option<PathBuf>,\n+    pub bindir: PathBuf,\n     pub libdir: Option<PathBuf>,\n     pub mandir: Option<PathBuf>,\n     pub codegen_tests: bool,\n@@ -318,7 +317,6 @@ struct Rust {\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n     codegen_backends_dir: Option<String>,\n-    wasm_syscall: Option<bool>,\n     lld: Option<bool>,\n     lldb: Option<bool>,\n     llvm_tools: Option<bool>,\n@@ -402,6 +400,7 @@ impl Config {\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n+        config.bindir = \"bin\".into(); // default\n         if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n@@ -484,7 +483,7 @@ impl Config {\n             config.sysconfdir = install.sysconfdir.clone().map(PathBuf::from);\n             config.datadir = install.datadir.clone().map(PathBuf::from);\n             config.docdir = install.docdir.clone().map(PathBuf::from);\n-            config.bindir = install.bindir.clone().map(PathBuf::from);\n+            set(&mut config.bindir, install.bindir.clone().map(PathBuf::from));\n             config.libdir = install.libdir.clone().map(PathBuf::from);\n             config.mandir = install.mandir.clone().map(PathBuf::from);\n         }\n@@ -558,7 +557,6 @@ impl Config {\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n             }\n-            set(&mut config.wasm_syscall, rust.wasm_syscall);\n             set(&mut config.lld_enabled, rust.lld);\n             set(&mut config.lldb_enabled, rust.lldb);\n             set(&mut config.llvm_tools_enabled, rust.llvm_tools);"}, {"sha": "d9dff77a30e6bd0fdd9c5951ffab3e5ca1bb43ac", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 61, "deletions": 30, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -18,7 +18,7 @@ use build_helper::{output, t};\n \n use crate::{Compiler, Mode, LLVM_TOOLS};\n use crate::channel;\n-use crate::util::{is_dylib, exe};\n+use crate::util::{is_dylib, exe, timeit};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::compile;\n use crate::tool::{self, Tool};\n@@ -91,14 +91,15 @@ impl Step for Docs {\n \n         let name = pkgname(builder, \"rust-docs\");\n \n-        builder.info(&format!(\"Dist docs ({})\", host));\n         if !builder.config.docs {\n-            builder.info(\"\\tskipping - docs disabled\");\n             return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n         builder.default_doc(None);\n \n+        builder.info(&format!(\"Dist docs ({})\", host));\n+        let _time = timeit(builder);\n+\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n \n@@ -151,9 +152,7 @@ impl Step for RustcDocs {\n \n         let name = pkgname(builder, \"rustc-docs\");\n \n-        builder.info(&format!(\"Dist compiler docs ({})\", host));\n         if !builder.config.compiler_docs {\n-            builder.info(\"\\tskipping - compiler docs disabled\");\n             return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, host));\n         }\n \n@@ -179,6 +178,9 @@ impl Step for RustcDocs {\n            .arg(\"--component-name=rustc-docs\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--bulk-dirs=share/doc/rust/html\");\n+\n+        builder.info(&format!(\"Dist compiler docs ({})\", host));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n \n@@ -350,6 +352,7 @@ impl Step for Mingw {\n         }\n \n         builder.info(&format!(\"Dist mingw ({})\", host));\n+        let _time = timeit(builder);\n         let name = pkgname(builder, \"rust-mingw\");\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -403,7 +406,6 @@ impl Step for Rustc {\n         let compiler = self.compiler;\n         let host = self.compiler.host;\n \n-        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host));\n         let name = pkgname(builder, \"rustc\");\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, host));\n         let _ = fs::remove_dir_all(&image);\n@@ -460,6 +462,9 @@ impl Step for Rustc {\n            .arg(format!(\"--package-name={}-{}\", name, host))\n            .arg(\"--component-name=rustc\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\"Dist rustc stage{} ({})\", compiler.stage, host));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n         builder.remove_dir(&overlay);\n@@ -662,8 +667,6 @@ impl Step for Std {\n         let target = self.target;\n \n         let name = pkgname(builder, \"rust-std\");\n-        builder.info(&format!(\"Dist std stage{} ({} -> {})\",\n-            compiler.stage, &compiler.host, target));\n \n         // The only true set of target libraries came from the build triple, so\n         // let's reduce redundant work by only producing archives from that host.\n@@ -678,12 +681,7 @@ impl Step for Std {\n         if builder.hosts.iter().any(|t| t == target) {\n             builder.ensure(compile::Rustc { compiler, target });\n         } else {\n-            if builder.no_std(target) == Some(true) {\n-                // the `test` doesn't compile for no-std targets\n-                builder.ensure(compile::Std { compiler, target });\n-            } else {\n-                builder.ensure(compile::Test { compiler, target });\n-            }\n+            builder.ensure(compile::Std { compiler, target });\n         }\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n@@ -719,6 +717,10 @@ impl Step for Std {\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-std-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\"Dist std stage{} ({} -> {})\",\n+            compiler.stage, &compiler.host, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n         distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n@@ -759,15 +761,13 @@ impl Step for Analysis {\n         let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n-        builder.info(\"Dist analysis\");\n         let name = pkgname(builder, \"rust-analysis\");\n \n         if &compiler.host != builder.config.build {\n-            builder.info(\"\\tskipping, not a build host\");\n             return distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target));\n         }\n \n-        builder.ensure(Std { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n@@ -791,6 +791,9 @@ impl Step for Analysis {\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(format!(\"--component-name=rust-analysis-{}\", target))\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(\"Dist analysis\");\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         builder.remove_dir(&image);\n         distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n@@ -813,6 +816,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n+            \"llvm-project/compiler-rt\", \"llvm-project\\\\compiler-rt\",\n         ];\n         if spath.contains(\"llvm-project\") && !spath.ends_with(\"llvm-project\")\n             && !LLVM_PROJECTS.iter().any(|path| spath.contains(path))\n@@ -878,8 +882,6 @@ impl Step for Src {\n \n     /// Creates the `rust-src` installer component\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        builder.info(\"Dist src\");\n-\n         let name = pkgname(builder, \"rust-src\");\n         let image = tmpdir(builder).join(format!(\"{}-image\", name));\n         let _ = fs::remove_dir_all(&image);\n@@ -912,6 +914,7 @@ impl Step for Src {\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n             \"src/tools/rustc-std-workspace-alloc\",\n+            \"src/tools/rustc-std-workspace-std\",\n             \"src/librustc\",\n             \"src/libsyntax\",\n         ];\n@@ -933,6 +936,9 @@ impl Step for Src {\n            .arg(format!(\"--package-name={}\", name))\n            .arg(\"--component-name=rust-src\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(\"Dist src\");\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n \n         builder.remove_dir(&image);\n@@ -960,8 +966,6 @@ impl Step for PlainSourceTarball {\n \n     /// Creates the plain source tarball\n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        builder.info(\"Create plain source tarball\");\n-\n         // Make sure that the root folder of tarball has the correct name\n         let plain_name = format!(\"{}-src\", pkgname(builder, \"rustc\"));\n         let plain_dst_src = tmpdir(builder).join(&plain_name);\n@@ -1023,6 +1027,9 @@ impl Step for PlainSourceTarball {\n            .arg(\"--output\").arg(&tarball)\n            .arg(\"--work-dir=.\")\n            .current_dir(tmpdir(builder));\n+\n+        builder.info(\"Create plain source tarball\");\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         distdir(builder).join(&format!(\"{}.tar.gz\", plain_name))\n     }\n@@ -1076,7 +1083,6 @@ impl Step for Cargo {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = builder.release_num(\"cargo\");\n@@ -1129,6 +1135,9 @@ impl Step for Cargo {\n            .arg(format!(\"--package-name={}-{}\", name, target))\n            .arg(\"--component-name=cargo\")\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\");\n+\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target))\n     }\n@@ -1164,7 +1173,6 @@ impl Step for Rls {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rls\");\n         let release_num = builder.release_num(\"rls\");\n         let name = pkgname(builder, \"rls\");\n@@ -1213,6 +1221,8 @@ impl Step for Rls {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rls-preview\");\n \n+        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n@@ -1248,7 +1258,6 @@ impl Step for Clippy {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/clippy\");\n         let release_num = builder.release_num(\"clippy\");\n         let name = pkgname(builder, \"clippy\");\n@@ -1302,6 +1311,8 @@ impl Step for Clippy {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=clippy-preview\");\n \n+        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n@@ -1337,7 +1348,6 @@ impl Step for Miri {\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/miri\");\n         let release_num = builder.release_num(\"miri\");\n         let name = pkgname(builder, \"miri\");\n@@ -1392,6 +1402,8 @@ impl Step for Miri {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=miri-preview\");\n \n+        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n@@ -1426,7 +1438,6 @@ impl Step for Rustfmt {\n         let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rustfmt\");\n         let release_num = builder.release_num(\"rustfmt\");\n         let name = pkgname(builder, \"rustfmt\");\n@@ -1479,6 +1490,8 @@ impl Step for Rustfmt {\n            .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n            .arg(\"--component-name=rustfmt-preview\");\n \n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n+        let _time = timeit(builder);\n         builder.run(&mut cmd);\n         Some(distdir(builder).join(format!(\"{}-{}.tar.gz\", name, target)))\n     }\n@@ -1579,6 +1592,7 @@ impl Step for Extended {\n             input_tarballs.push(tarball);\n         }\n \n+        builder.info(\"building combined installer\");\n         let mut cmd = rust_installer(builder);\n         cmd.arg(\"combine\")\n             .arg(\"--product-name=Rust\")\n@@ -1590,7 +1604,9 @@ impl Step for Extended {\n             .arg(\"--legacy-manifest-dirs=rustlib,cargo\")\n             .arg(\"--input-tarballs\").arg(input_tarballs)\n             .arg(\"--non-installed-overlay\").arg(&overlay);\n+        let time = timeit(&builder);\n         builder.run(&mut cmd);\n+        drop(time);\n \n         let mut license = String::new();\n         license += &builder.read(&builder.src.join(\"COPYRIGHT\"));\n@@ -1646,6 +1662,7 @@ impl Step for Extended {\n         };\n \n         if target.contains(\"apple-darwin\") {\n+            builder.info(\"building pkg installer\");\n             let pkg = tmp.join(\"pkg\");\n             let _ = fs::remove_dir_all(&pkg);\n \n@@ -1695,6 +1712,7 @@ impl Step for Extended {\n                                                     pkgname(builder, \"rust\"),\n                                                     target)))\n                 .arg(\"--package-path\").arg(&pkg);\n+            let _time = timeit(builder);\n             builder.run(&mut cmd);\n         }\n \n@@ -1745,14 +1763,18 @@ impl Step for Extended {\n             builder.create(&exe.join(\"LICENSE.txt\"), &license);\n \n             // Generate exe installer\n+            builder.info(\"building `exe` installer with `iscc`\");\n             let mut cmd = Command::new(\"iscc\");\n             cmd.arg(\"rust.iss\")\n+                .arg(\"/Q\")\n                 .current_dir(&exe);\n             if target.contains(\"windows-gnu\") {\n                 cmd.arg(\"/dMINGW\");\n             }\n             add_env(builder, &mut cmd, target);\n+            let time = timeit(builder);\n             builder.run(&mut cmd);\n+            drop(time);\n             builder.install(&exe.join(format!(\"{}-{}.exe\", pkgname(builder, \"rust\"), target)),\n                     &distdir(builder),\n                     0o755);\n@@ -1917,6 +1939,7 @@ impl Step for Extended {\n             builder.install(&etc.join(\"gfx/banner.bmp\"), &exe, 0o644);\n             builder.install(&etc.join(\"gfx/dialogbg.bmp\"), &exe, 0o644);\n \n+            builder.info(&format!(\"building `msi` installer with {:?}\", light));\n             let filename = format!(\"{}-{}.msi\", pkgname(builder, \"rust\"), target);\n             let mut cmd = Command::new(&light);\n             cmd.arg(\"-nologo\")\n@@ -1949,6 +1972,7 @@ impl Step for Extended {\n             // ICE57 wrongly complains about the shortcuts\n             cmd.arg(\"-sice:ICE57\");\n \n+            let _time = timeit(builder);\n             builder.run(&mut cmd);\n \n             if !builder.config.dry_run {\n@@ -2003,6 +2027,8 @@ impl Step for HashSign {\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n+        // This gets called by `promote-release`\n+        // (https://github.com/rust-lang/rust-central-station/tree/master/promote-release).\n         let mut cmd = builder.tool_cmd(Tool::BuildManifest);\n         if builder.config.dry_run {\n             return;\n@@ -2013,10 +2039,14 @@ impl Step for HashSign {\n         let addr = builder.config.dist_upload_addr.as_ref().unwrap_or_else(|| {\n             panic!(\"\\n\\nfailed to specify `dist.upload-addr` in `config.toml`\\n\\n\")\n         });\n-        let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n-            panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n-        });\n-        let pass = t!(fs::read_to_string(&file));\n+        let pass = if env::var(\"BUILD_MANIFEST_DISABLE_SIGNING\").is_err() {\n+            let file = builder.config.dist_gpg_password_file.as_ref().unwrap_or_else(|| {\n+                panic!(\"\\n\\nfailed to specify `dist.gpg-password-file` in `config.toml`\\n\\n\")\n+            });\n+            t!(fs::read_to_string(&file))\n+        } else {\n+            String::new()\n+        };\n \n         let today = output(Command::new(\"date\").arg(\"+%Y-%m-%d\"));\n \n@@ -2111,6 +2141,7 @@ impl Step for LlvmTools {\n         }\n \n         builder.info(&format!(\"Dist LlvmTools ({})\", target));\n+        let _time = timeit(builder);\n         let src = builder.src.join(\"src/llvm-project/llvm\");\n         let name = pkgname(builder, \"llvm-tools\");\n "}, {"sha": "873a3c31d1535fe5ed527c917706dc0a68560b40", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 4, "deletions": 131, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -375,7 +375,7 @@ impl Step for Standalone {\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n                up_to_date(&full_toc, &html) &&\n-               up_to_date(&version_info, &html) &&\n+               (builder.config.dry_run || up_to_date(&version_info, &html)) &&\n                (builder.config.dry_run || up_to_date(&rustdoc, &html)) {\n                 continue\n             }\n@@ -413,7 +413,7 @@ impl Step for Std {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run.all_krates(\"std\").default_condition(builder.config.docs)\n+        run.all_krates(\"test\").default_condition(builder.config.docs)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -476,136 +476,10 @@ impl Step for Std {\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n-            builder.cp_r(&my_out, &out);\n         };\n-        for krate in &[\"alloc\", \"core\", \"std\"] {\n+        for krate in &[\"alloc\", \"core\", \"std\", \"proc_macro\", \"test\"] {\n             run_cargo_rustdoc_for(krate);\n         }\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct Test {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for Test {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"test\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Test {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Compile all libtest documentation.\n-    ///\n-    /// This will generate all documentation for libtest and its dependencies. This\n-    /// is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Test { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Test)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"doc\");\n-        compile::test_cargo(builder, &compiler, target, &mut cargo);\n-\n-        cargo.arg(\"--no-deps\")\n-             .arg(\"-p\").arg(\"test\")\n-             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-             .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-\n-        builder.run(&mut cargo);\n-        builder.cp_r(&my_out, &out);\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-pub struct WhitelistedRustc {\n-    stage: u32,\n-    target: Interned<String>,\n-}\n-\n-impl Step for WhitelistedRustc {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let builder = run.builder;\n-        run.krate(\"rustc-main\").default_condition(builder.config.docs)\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(WhitelistedRustc {\n-            stage: run.builder.top_stage,\n-            target: run.target,\n-        });\n-    }\n-\n-    /// Generates whitelisted compiler crate documentation.\n-    ///\n-    /// This will generate all documentation for crates that are whitelisted\n-    /// to be included in the standard documentation. This documentation is\n-    /// included in the standard Rust documentation, so we should always\n-    /// document it and symlink to merge with the rest of the std and test\n-    /// documentation. We don't build other compiler documentation\n-    /// here as we want to be able to keep it separate from the standard\n-    /// documentation. This is largely just a wrapper around `cargo doc`.\n-    fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n-        let target = self.target;\n-        builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n-        let out = builder.doc_out(target);\n-        t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler_for(stage, builder.config.build, target);\n-\n-        // Build libstd docs so that we generate relative links\n-        builder.ensure(Std { stage, target });\n-\n-        builder.ensure(compile::Rustc { compiler, target });\n-        let out_dir = builder.stage_out(compiler, Mode::Rustc)\n-                           .join(target).join(\"doc\");\n-\n-        // See docs in std above for why we symlink\n-        let my_out = builder.crate_doc_out(target);\n-        t!(symlink_dir_force(&builder.config, &my_out, &out_dir));\n-\n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        compile::rustc_cargo(builder, &mut cargo);\n-\n-        // We don't want to build docs for internal compiler dependencies in this\n-        // step (there is another step for that). Therefore, we whitelist the crates\n-        // for which docs must be built.\n-        for krate in &[\"proc_macro\"] {\n-            cargo.arg(\"-p\").arg(krate)\n-                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n-                 .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n-        }\n-\n-        builder.run(&mut cargo);\n         builder.cp_r(&my_out, &out);\n     }\n }\n@@ -825,8 +699,7 @@ impl Step for ErrorIndex {\n         index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n-        index.env(\"CFG_BUILD\", &builder.config.build)\n-             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+        index.env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.run(&mut index);\n     }"}, {"sha": "d9580b598155edc946002b2a77efa6ad0d73ad7f", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -36,7 +36,7 @@ pub struct Flags {\n     // This overrides the deny-warnings configuation option,\n     // which passes -Dwarnings to the compiler invocations.\n     //\n-    // true => deny, false => allow\n+    // true => deny, false => warn\n     pub deny_warnings: Option<bool>,\n }\n \n@@ -556,10 +556,10 @@ fn split(s: &[String]) -> Vec<String> {\n fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n     match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n         Some(\"deny\") => Some(true),\n-        Some(\"allow\") => Some(false),\n+        Some(\"warn\") => Some(false),\n         Some(value) => {\n             eprintln!(\n-                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                r#\"invalid value for --warnings: {:?}, expected \"warn\" or \"deny\"\"#,\n                 value,\n                 );\n             process::exit(1);"}, {"sha": "384219c38fd0483f821754a19dc9029a5434173b", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -67,7 +67,6 @@ fn install_sh(\n     let sysconfdir_default = PathBuf::from(\"/etc\");\n     let datadir_default = PathBuf::from(\"share\");\n     let docdir_default = datadir_default.join(\"doc/rust\");\n-    let bindir_default = PathBuf::from(\"bin\");\n     let libdir_default = PathBuf::from(\"lib\");\n     let mandir_default = datadir_default.join(\"man\");\n     let prefix = builder.config.prefix.as_ref().map_or(prefix_default, |p| {\n@@ -76,7 +75,7 @@ fn install_sh(\n     let sysconfdir = builder.config.sysconfdir.as_ref().unwrap_or(&sysconfdir_default);\n     let datadir = builder.config.datadir.as_ref().unwrap_or(&datadir_default);\n     let docdir = builder.config.docdir.as_ref().unwrap_or(&docdir_default);\n-    let bindir = builder.config.bindir.as_ref().unwrap_or(&bindir_default);\n+    let bindir = &builder.config.bindir;\n     let libdir = builder.config.libdir.as_ref().unwrap_or(&libdir_default);\n     let mandir = builder.config.mandir.as_ref().unwrap_or(&mandir_default);\n "}, {"sha": "5d7581c8211be84c1e05b0ae27663f69aa992202", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -103,9 +103,6 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n@@ -297,9 +294,6 @@ pub enum Mode {\n     /// Build the standard library, placing output in the \"stageN-std\" directory.\n     Std,\n \n-    /// Build libtest, placing output in the \"stageN-test\" directory.\n-    Test,\n-\n     /// Build librustc, and compiler libraries, placing output in the \"stageN-rustc\" directory.\n     Rustc,\n \n@@ -315,7 +309,6 @@ pub enum Mode {\n     /// Compile a tool which uses all libraries we compile (up to rustc).\n     /// Doesn't use the stage0 compiler libraries like \"other\", and includes\n     /// tools like rustdoc, cargo, rls, etc.\n-    ToolTest,\n     ToolStd,\n     ToolRustc,\n }\n@@ -502,9 +495,6 @@ impl Build {\n         if self.config.profiler {\n             features.push_str(\" profiler\");\n         }\n-        if self.config.wasm_syscall {\n-            features.push_str(\" wasm_syscall\");\n-        }\n         features\n     }\n \n@@ -536,11 +526,10 @@ impl Build {\n     fn stage_out(&self, compiler: Compiler, mode: Mode) -> PathBuf {\n         let suffix = match mode {\n             Mode::Std => \"-std\",\n-            Mode::Test => \"-test\",\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))"}, {"sha": "7bf9ea2688f4c5a872d3f6f0b3f1ac645a9a7811", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -81,26 +81,29 @@ impl Step for Llvm {\n             (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n         };\n \n-        if !llvm_info.is_git() {\n-            println!(\n-                \"git could not determine the LLVM submodule commit hash. \\\n-                Assuming that an LLVM build is necessary.\",\n-            );\n-        }\n-\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n         let done_stamp = out_dir.join(\"llvm-finished-building\");\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            if done_stamp.exists() {\n+        if done_stamp.exists() {\n+            if let Some(llvm_commit) = llvm_info.sha() {\n                 let done_contents = t!(fs::read(&done_stamp));\n \n                 // If LLVM was already built previously and the submodule's commit didn't change\n                 // from the previous build, then no action is required.\n                 if done_contents == llvm_commit.as_bytes() {\n-                    return build_llvm_config\n+                    return build_llvm_config;\n                 }\n+            } else {\n+                builder.info(\n+                    \"Could not determine the LLVM submodule commit hash. \\\n+                     Assuming that an LLVM rebuild is not necessary.\",\n+                );\n+                builder.info(&format!(\n+                    \"To force LLVM to rebuild, remove the file `{}`\",\n+                    done_stamp.display()\n+                ));\n+                return build_llvm_config;\n             }\n         }\n \n@@ -303,9 +306,7 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        if let Some(llvm_commit) = llvm_info.sha() {\n-            t!(fs::write(&done_stamp, llvm_commit));\n-        }\n+        t!(fs::write(&done_stamp, llvm_info.sha().unwrap_or(\"\")));\n \n         build_llvm_config\n     }"}, {"sha": "00d87f3841cfffd04af86c5c3139f36591aa3565", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 13, "deletions": 41, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1040,21 +1040,10 @@ impl Step for Compiletest {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n-        if builder.no_std(target) == Some(true) {\n-            // the `test` doesn't compile for no-std targets\n-            builder.ensure(compile::Std { compiler, target });\n-        } else {\n-            builder.ensure(compile::Test { compiler, target });\n-        }\n-\n-        if builder.no_std(target) == Some(true) {\n-            // for no_std run-make (e.g., thumb*),\n-            // we need a host compiler which is called by cargo.\n-            builder.ensure(compile::Std { compiler, target: compiler.host });\n-        }\n+        builder.ensure(compile::Std { compiler, target });\n+        // ensure that `libproc_macro` is available on the host.\n+        builder.ensure(compile::Std { compiler, target: compiler.host });\n \n-        // HACK(eddyb) ensure that `libproc_macro` is available on the host.\n-        builder.ensure(compile::Test { compiler, target: compiler.host });\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n@@ -1338,7 +1327,10 @@ impl Step for Compiletest {\n             cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n-        cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n+        let tmp = builder.out.join(\"tmp\");\n+        std::fs::create_dir_all(&tmp).unwrap();\n+        cmd.env(\"RUST_TEST_TMPDIR\", tmp);\n+\n \n         cmd.arg(\"--adb-path\").arg(\"adb\");\n         cmd.arg(\"--adb-test-dir\").arg(ADB_TEST_DIR);\n@@ -1399,7 +1391,7 @@ impl Step for DocTest {\n     fn run(self, builder: &Builder<'_>) {\n         let compiler = self.compiler;\n \n-        builder.ensure(compile::Test {\n+        builder.ensure(compile::Std {\n             compiler,\n             target: compiler.host,\n         });\n@@ -1535,8 +1527,7 @@ impl Step for ErrorIndex {\n         );\n         tool.arg(\"markdown\")\n             .arg(&output)\n-            .env(\"CFG_BUILD\", &builder.config.build)\n-            .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n+            .env(\"CFG_BUILD\", &builder.config.build);\n \n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n@@ -1710,8 +1701,7 @@ impl Step for Crate {\n \n     fn should_run(mut run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let builder = run.builder;\n-        run = run.krate(\"test\");\n-        for krate in run.builder.in_tree_crates(\"std\") {\n+        for krate in run.builder.in_tree_crates(\"test\") {\n             if !(krate.name.starts_with(\"rustc_\") && krate.name.ends_with(\"san\")) {\n                 run = run.path(krate.local_path(&builder).to_str().unwrap());\n             }\n@@ -1735,14 +1725,9 @@ impl Step for Crate {\n             });\n         };\n \n-        for krate in builder.in_tree_crates(\"std\") {\n-            if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Std, krate);\n-            }\n-        }\n         for krate in builder.in_tree_crates(\"test\") {\n             if run.path.ends_with(&krate.local_path(&builder)) {\n-                make(Mode::Test, krate);\n+                make(Mode::Std, krate);\n             }\n         }\n     }\n@@ -1762,7 +1747,7 @@ impl Step for Crate {\n         let test_kind = self.test_kind;\n         let krate = self.krate;\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         // If we're not doing a full bootstrap but we're testing a stage2\n@@ -1776,9 +1761,6 @@ impl Step for Crate {\n             Mode::Std => {\n                 compile::std_cargo(builder, &compiler, target, &mut cargo);\n             }\n-            Mode::Test => {\n-                compile::test_cargo(builder, &compiler, target, &mut cargo);\n-            }\n             Mode::Rustc => {\n                 builder.ensure(compile::Rustc { compiler, target });\n                 compile::rustc_cargo(builder, &mut cargo);\n@@ -1832,16 +1814,6 @@ impl Step for Crate {\n                     .expect(\"nodejs not configured\"),\n             );\n         } else if target.starts_with(\"wasm32\") {\n-            // Warn about running tests without the `wasm_syscall` feature enabled.\n-            // The javascript shim implements the syscall interface so that test\n-            // output can be correctly reported.\n-            if !builder.config.wasm_syscall {\n-                builder.info(\n-                    \"Libstd was built without `wasm_syscall` feature enabled: \\\n-                     test output may not be visible.\"\n-                );\n-            }\n-\n             // On the wasm32-unknown-unknown target we're using LTO which is\n             // incompatible with `-C prefer-dynamic`, so disable that here\n             cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n@@ -1980,7 +1952,7 @@ impl Step for RemoteCopyLibs {\n             return;\n         }\n \n-        builder.ensure(compile::Test { compiler, target });\n+        builder.ensure(compile::Std { compiler, target });\n \n         builder.info(&format!(\"REMOTE copy libs to emulator ({})\", target));\n         t!(fs::create_dir_all(builder.out.join(\"tmp\")));"}, {"sha": "54fe26f18e741d0a7558ada111628bb68cc84ee3", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 3, "deletions": 36, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -577,12 +577,6 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, so make sure the host\n-        // libstd/libproc_macro is available.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n         builder.ensure(ToolBuild {\n             compiler: self.compiler,\n             target: self.target,\n@@ -650,31 +644,10 @@ macro_rules! tool_extended {\n \n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n-    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n-    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {};\n+    Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {};\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n-    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n-    };\n+    CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {};\n     Rls, rls, \"src/tools/rls\", \"rls\", {\n         let clippy = builder.ensure(Clippy {\n             compiler: self.compiler,\n@@ -684,12 +657,6 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, so make sure that's built for\n-        // the compiler itself.\n-        builder.ensure(compile::Test {\n-            compiler: self.compiler,\n-            target: builder.config.build,\n-        });\n     };\n     Rustfmt, rustfmt, \"src/tools/rustfmt\", \"rustfmt\", {};\n );"}, {"sha": "f035a7119188a1aa3c415e09096e20b8e896104f", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,6 +1,3 @@\n-// NO-RUSTC-WRAPPER\n-#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n-\n use std::fs::File;\n use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio};\n@@ -262,7 +259,7 @@ pub fn native_lib_boilerplate(\n     if !up_to_date(Path::new(\"build.rs\"), &timestamp) || !up_to_date(src_dir, &timestamp) {\n         Ok(NativeLibBoilerplate {\n             src_dir: src_dir.to_path_buf(),\n-            out_dir: out_dir,\n+            out_dir,\n         })\n     } else {\n         Err(())"}, {"sha": "5f7761297095c8eef7e614f1eec90783b90775d5", "filename": "src/ci/azure-pipelines/auto.yml", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -7,7 +7,7 @@ trigger:\n   - auto\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n jobs:\n - job: Linux\n@@ -236,10 +236,16 @@ jobs:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-1\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       i686-msvc-2:\n         MSYS_BITS: 32\n         RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n         SCRIPT: make ci-subset-2\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       # MSVC aux tests\n       x86_64-msvc-aux:\n         MSYS_BITS: 64\n@@ -250,6 +256,9 @@ jobs:\n         SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n         VCVARS_BAT: vcvars64.bat\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n       # MSVC tools tests\n       x86_64-msvc-tools:\n         MSYS_BITS: 64"}, {"sha": "e2baa923d99f7c8f493ee73868b468147f8c77aa", "filename": "src/ci/azure-pipelines/master.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -7,7 +7,7 @@ trigger:\n   - master\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n pool:\n   vmImage: ubuntu-16.04"}, {"sha": "bd4f1ed0cea439c4da31fd97114f16ef8511c865", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -18,9 +18,9 @@ steps:\n # one is MSI installers and one is EXE, but they're not used so frequently at\n # this point anyway so perhaps it's a wash!\n - script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\"\n-    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n     echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n+    curl.exe -o is-install.exe https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-08-22-is.exe\n+    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n   displayName: Install InnoSetup\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n@@ -43,24 +43,18 @@ steps:\n # FIXME: we should probe the default azure image and see if we can use the MSYS2\n # toolchain there. (if there's even one there). For now though this gets the job\n # done.\n-- script: |\n-    set MSYS_PATH=%CD%\\citools\\msys64\n-    choco install msys2 --params=\"/InstallDir:%MSYS_PATH% /NoPath\" -y\n-    set PATH=%MSYS_PATH%\\usr\\bin;%PATH%\n-    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n-    IF \"%MINGW_URL%\"==\"\" (\n-      IF \"%MSYS_BITS%\"==\"32\" pacman -S --noconfirm --needed mingw-w64-i686-toolchain mingw-w64-i686-cmake mingw-w64-i686-gcc mingw-w64-i686-python2\n-      IF \"%MSYS_BITS%\"==\"64\" pacman -S --noconfirm --needed mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-python2\n-    )\n-    where rev\n-    rev --help\n-    where make\n-\n-    echo ##vso[task.setvariable variable=MSYS_PATH]%MSYS_PATH%\n-    echo ##vso[task.prependpath]%MSYS_PATH%\\usr\\bin\n+- bash: |\n+    set -e\n+    choco install msys2 --params=\"/InstallDir:$(System.Workfolder)/msys2 /NoPath\" -y --no-progress\n+    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/usr/bin\"\n+    mkdir -p \"$(System.Workfolder)/msys2/home/$USERNAME\"\n   displayName: Install msys2\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n+- bash: pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n+  displayName: Install msys2 base deps\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n # If we need to download a custom MinGW, do so here and set the path\n # appropriately.\n #\n@@ -81,39 +75,46 @@ steps:\n #\n # Note that we don't literally overwrite the gdb.exe binary because it appears\n # to just use gdborig.exe, so that's the binary we deal with instead.\n-- script: |\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %MINGW_ARCHIVE% %MINGW_URL%/%MINGW_ARCHIVE%\"\n-    7z x -y %MINGW_ARCHIVE% > nul\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\"\n-    mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n-    echo ##vso[task.prependpath]%CD%\\%MINGW_DIR%\\bin\n+- bash: |\n+    set -e\n+    curl -o mingw.7z $MINGW_URL/$MINGW_ARCHIVE\n+    7z x -y mingw.7z > /dev/null\n+    curl -o $MINGW_DIR/bin/gdborig.exe $MINGW_URL/2017-04-20-${MSYS_BITS}bit-gdborig.exe\n+    echo \"##vso[task.prependpath]`pwd`/$MINGW_DIR/bin\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n   displayName: Download custom MinGW\n \n-# Otherwise pull in the MinGW installed on appveyor\n-- script: |\n-    echo ##vso[task.prependpath]%MSYS_PATH%\\mingw%MSYS_BITS%\\bin\n+# Otherwise install MinGW through `pacman`\n+- bash: |\n+    set -e\n+    arch=i686\n+    if [ \"$MSYS_BITS\" = \"64\" ]; then\n+      arch=x86_64\n+    fi\n+    pacman -S --noconfirm --needed mingw-w64-$arch-toolchain mingw-w64-$arch-cmake mingw-w64-$arch-gcc mingw-w64-$arch-python2\n+    echo \"##vso[task.prependpath]$(System.Workfolder)/msys2/mingw$MSYS_BITS/bin\"\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n-  displayName: Add MinGW to path\n+  displayName: Download standard MinGW\n \n # Make sure we use the native python interpreter instead of some msys equivalent\n # one way or another. The msys interpreters seem to have weird path conversions\n # baked in which break LLVM's build system one way or another, so let's use the\n # native version which keeps everything as native as possible.\n-- script: |\n-    copy C:\\Python27amd64\\python.exe C:\\Python27amd64\\python2.7.exe\n-    echo ##vso[task.prependpath]C:\\Python27amd64\n+- bash: |\n+    set -e\n+    cp C:/Python27amd64/python.exe C:/Python27amd64/python2.7.exe\n+    echo \"##vso[task.prependpath]C:/Python27amd64\"\n   displayName: Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n \n # Note that this is originally from the github releases patch of Ninja\n-- script: |\n-    md ninja\n-    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\"\n-    7z x -oninja 2017-03-15-ninja-win.zip\n-    del 2017-03-15-ninja-win.zip\n-    set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n-    echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]%RUST_CONFIGURE_ARGS%\n-    echo ##vso[task.prependpath]%CD%\\ninja\n+- bash: |\n+    set -e\n+    mkdir ninja\n+    curl -o ninja.zip https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc/2017-03-15-ninja-win.zip\n+    7z x -oninja ninja.zip\n+    rm ninja.zip\n+    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --enable-ninja\"\n+    echo \"##vso[task.prependpath]`pwd`/ninja\"\n   displayName: Download and install ninja\n   condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "15a2499e4609e3c6bf0895001d2f49280f610c8e", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -147,8 +147,15 @@ steps:\n     git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n     cd rust-toolstate\n     python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+    # Only check maintainers if this build is supposed to publish toolstate.\n+    # Builds that are not supposed to publish don't have the access token.\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n+      TOOLSTATE_VALIDATE_MAINTAINERS_REPO=rust-lang/rust python2.7 \"${BUILD_SOURCESDIRECTORY}/src/tools/publish_toolstate.py\"\n+    fi\n     cd ..\n     rm -rf rust-toolstate\n+  env:\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n   condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n   displayName: Verify the publish_toolstate script works\n \n@@ -168,7 +175,8 @@ steps:\n   env:\n     CI: true\n     SRC: .\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    AWS_ACCESS_KEY_ID: $(SCCACHE_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(SCCACHE_AWS_SECRET_ACCESS_KEY)\n     TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n   condition: and(succeeded(), not(variables.SKIP_JOB))\n   displayName: Run build\n@@ -192,7 +200,8 @@ steps:\n     fi\n     retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n   env:\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n   condition: and(succeeded(), not(variables.SKIP_JOB), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n   displayName: Upload artifacts\n \n@@ -201,7 +210,8 @@ steps:\n # errors here ever fail the build since this is just informational.\n - bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$CI_JOB_NAME.csv\n   env:\n-    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n-  condition: variables['AWS_SECRET_ACCESS_KEY']\n+    AWS_ACCESS_KEY_ID: $(UPLOAD_AWS_ACCESS_KEY_ID)\n+    AWS_SECRET_ACCESS_KEY: $(UPLOAD_AWS_SECRET_ACCESS_KEY)\n+  condition: variables['UPLOAD_AWS_SECRET_ACCESS_KEY']\n   continueOnError: true\n   displayName: Upload CPU usage statistics"}, {"sha": "c919b1023a0eb2c53de10f3b09b15f442fd5fdcb", "filename": "src/ci/azure-pipelines/try.yml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -3,7 +3,7 @@ trigger:\n - try\n \n variables:\n-- group: real-prod-credentials\n+- group: prod-credentials\n \n jobs:\n - job: Linux"}, {"sha": "105791194628b3130866d55f5293fb1b6431756d", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -104,9 +104,7 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-# FIXME: temporarily disable the redox builder,\n-# see: https://github.com/rust-lang/rust/issues/63160\n-# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n@@ -132,7 +130,7 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n-    \n+\n ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\"}, {"sha": "de8c359d16757a223b84fce8afce6ae2331bd61d", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n+URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/rustc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "517b59c38dcb06b7441802344782df01813a0a1a", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -19,3 +19,6 @@ RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV SCRIPT python2.7 ../x.py test\n+\n+# FIXME(#59637) takes too long on CI right now\n+ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "03db3ba0995d6a94ff0a0737b3e210258d7706e5", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -25,3 +25,6 @@ ENV SCRIPT python2.7 ../x.py test \\\n   --exclude src/test/rustdoc-js \\\n   --exclude src/tools/error_index_generator \\\n   --exclude src/tools/linkchecker\n+\n+# FIXME(#59637) takes too long on CI right now\n+ENV NO_LLVM_ASSERTIONS=1 NO_DEBUG_ASSERTIONS=1"}, {"sha": "871416b85c1a73717d65d6f4a9ea29e5aef3db0e", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit 7ddc46460f09a5cd9bd2a620565bdc20b3315ea9\n+Subproject commit 871416b85c1a73717d65d6f4a9ea29e5aef3db0e"}, {"sha": "5ca585c4a7552efb546e7681c3de0712f4ae4fdc", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999\n+Subproject commit 5ca585c4a7552efb546e7681c3de0712f4ae4fdc"}, {"sha": "4374786f0b4bf0606b35d5c30a9681f342e5707b", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da\n+Subproject commit 4374786f0b4bf0606b35d5c30a9681f342e5707b"}, {"sha": "fa5dfb832ef8a7568e17dabf612f486d641ff4ac", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa\n+Subproject commit fa5dfb832ef8a7568e17dabf612f486d641ff4ac"}, {"sha": "67cfbf31df880728dcf7cb35b15b028ec92caf31", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764\n+Subproject commit 67cfbf31df880728dcf7cb35b15b028ec92caf31"}, {"sha": "941968db2fd9c85788a4f971c8e425d46b4cb734", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1 +1 @@\n-Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c\n+Subproject commit 941968db2fd9c85788a4f971c8e425d46b4cb734"}, {"sha": "5eea9c86879001ef9a13ee6f3c8ecbc487697ccc", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -304,3 +304,10 @@ to customize the output:\n \n Note that it is invalid to combine the `--json` argument with the `--color`\n argument, and it is required to combine `--json` with `--error-format=json`.\n+\n+## `@path`: load command-line flags from a path\n+\n+If you specify `@path` on the command-line, then it will open `path` and read\n+command line options from it. These options are one per line; a blank line indicates\n+an empty option. The file can use Unix or Windows style line endings, and must be\n+encoded as UTF-8."}, {"sha": "6f1bbe60569fd4ccfeadcfceefb68c7ec97ced13", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -105,5 +105,6 @@ The following table shows known good combinations of toolchain versions.\n | Rust 1.34 |     \u2717     |     \u2713     |\n | Rust 1.35 |     \u2717     |     \u2713     |\n | Rust 1.36 |     \u2717     |     \u2713     |\n+| Rust 1.37 |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "d3dfc3197e2f69749bc3e6537f4d55fb97376016", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -208,7 +208,7 @@ error: missing documentation for a function\n \n To fix the lint, add documentation to all items.\n \n-## single-use-lifetime\n+## single-use-lifetimes\n \n This lint detects lifetimes that are only used once. Some example code that\n triggers this lint:"}, {"sha": "49d05b5038df74dd8ff7bd53545adc7fdfc123d9", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 50, "deletions": 13, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -311,19 +311,6 @@ When `rustdoc` receives this flag, it will print an extra \"Version (version)\" in\n the crate root's docs. You can use this flag to differentiate between different versions of your\n library's documentation.\n \n-### `--linker`: control the linker used for documentation tests\n-\n-Using this flag looks like this:\n-\n-```bash\n-$ rustdoc --test src/lib.rs -Z unstable-options --linker foo\n-$ rustdoc --test README.md -Z unstable-options --linker foo\n-```\n-\n-When `rustdoc` runs your documentation tests, it needs to compile and link the tests as executables\n-before running them. This flag can be used to change the linker used on these executables. It's\n-equivalent to passing `-C linker=foo` to `rustc`.\n-\n ### `--sort-modules-by-appearance`: control how items on module pages are sorted\n \n Using this flag looks like this:\n@@ -484,3 +471,53 @@ Some methodology notes about what rustdoc counts in this metric:\n \n Public items that are not documented can be seen with the built-in `missing_docs` lint. Private\n items that are not documented can be seen with Clippy's `missing_docs_in_private_items` lint.\n+\n+### `--enable-per-target-ignores`: allow `ignore-foo` style filters for doctests\n+\n+Using this flag looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --enable-per-target-ignores\n+```\n+\n+This flag allows you to tag doctests with compiltest style `ignore-foo` filters that prevent\n+rustdoc from running that test if the target triple string contains foo. For example:\n+\n+```rust\n+///```ignore-foo,ignore-bar\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+This will not be run when the build target is `super-awesome-foo` or `less-bar-awesome`.\n+If the flag is not enabled, then rustdoc will consume the filter, but do nothing with it, and\n+the above example will be run for all targets.\n+If you want to preserve backwards compatibility for older versions of rustdoc, you can use\n+\n+```rust\n+///```ignore,ignore-foo\n+///assert!(2 == 2);\n+///```\n+struct Foo;\n+```\n+\n+In older versions, this will be ignored on all targets, but on newer versions `ignore-gnu` will\n+override `ignore`.\n+\n+### `--runtool`, `--runtool-arg`: program to run tests with; args to pass to it\n+\n+Using thses options looks like this:\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool runner --runtool-arg --do-thing --runtool-arg --do-other-thing\n+```\n+\n+These options can be used to run the doctest under a program, and also pass arguments to\n+that program. For example, if you want to run your doctests under valgrind you might run\n+\n+```bash\n+$ rustdoc src/lib.rs -Z unstable-options --runtool valgrind\n+```\n+\n+Another use case would be to run a test inside an emulator, or through a Virtual Machine."}, {"sha": "4b83c204ba10579d2152672578834232bd4d1984", "filename": "src/doc/unstable-book/src/language-features/param-attrs.md", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md?ref=4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24", "patch": "@@ -1,27 +0,0 @@\n-# `param_attrs`\n-\n-The tracking issue for this feature is: [#60406]\n-\n-[#60406]: https://github.com/rust-lang/rust/issues/60406\n-\n-Allow attributes in formal function parameter position so external tools and compiler internals can\n-take advantage of the additional information that the parameters provide.\n-\n-Enables finer conditional compilation with `#[cfg(..)]` and linting control of variables. Moreover,\n-opens the path to richer DSLs created by users.\n-\n-------------------------\n-\n-Example:\n-\n-```rust\n-#![feature(param_attrs)]\n-\n-fn len(\n-  #[cfg(windows)] slice: &[u16],\n-  #[cfg(not(windows))] slice: &[u8],\n-) -> usize\n-{\n-  slice.len()\n-}\n-```"}, {"sha": "68877b48433d5462d3581d202f483a87d90224f3", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -57,12 +57,12 @@ extern crate rustc;\n extern crate rustc_driver;\n \n use syntax::parse::token::{self, Token};\n-use syntax::tokenstream::TokenTree;\n+use syntax::tokenstream::{TokenTree, TokenStream};\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n use syntax_pos::Span;\n use rustc_driver::plugin::Registry;\n \n-fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n+fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: TokenStream)\n         -> Box<dyn MacResult + 'static> {\n \n     static NUMERALS: &'static [(&'static str, usize)] = &[\n@@ -78,7 +78,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n         return DummyResult::any(sp);\n     }\n \n-    let text = match args[0] {\n+    let text = match args.into_trees().next().unwrap() {\n         TokenTree::Token(Token { kind: token::Ident(s, _), .. }) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");"}, {"sha": "66a3c8e555405966fae917a6ccfe9f7aa1a6fdf1", "filename": "src/etc/generate-deriving-span-tests.py", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Fgenerate-deriving-span-tests.py", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Fgenerate-deriving-span-tests.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgenerate-deriving-span-tests.py?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -14,6 +14,8 @@\n     os.path.join(os.path.dirname(__file__), '../test/ui/derives/'))\n \n TEMPLATE = \"\"\"\\\n+// ignore-x86\n+// ^ due to stderr output differences\n // This file was auto-generated using 'src/etc/generate-deriving-span-tests.py'\n \n {error_deriving}"}, {"sha": "70648beac38b03565f77547f23542998dcce10b0", "filename": "src/etc/installer/exe/rust.iss", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Finstaller%2Fexe%2Frust.iss", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fexe%2Frust.iss?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -25,9 +25,9 @@ SourceDir=.\\\n OutputBaseFilename={#CFG_PACKAGE_NAME}-{#CFG_BUILD}\n DefaultDirName={sd}\\Rust\n \n-Compression=lzma2/ultra\n-InternalCompressLevel=ultra\n-SolidCompression=true\n+Compression=lzma2/normal\n+InternalCompressLevel=normal\n+SolidCompression=no\n \n ChangesEnvironment=true\n ChangesAssociations=no"}, {"sha": "a2e378f7b1db4e1017b23e5e8aed68d99a7f9695", "filename": "src/etc/installer/msi/rust.wxs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstaller%2Fmsi%2Frust.wxs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -152,7 +152,7 @@\n         </Upgrade>\n \n         <!-- Specifies a single cab file to be embedded in the installer's .msi. -->\n-        <MediaTemplate EmbedCab=\"yes\" CompressionLevel=\"high\" />\n+        <MediaTemplate EmbedCab=\"yes\" CompressionLevel=\"mszip\" />\n \n         <!-- Send a WM_SETTINGCHANGE message to tell processes like explorer to update their\n              environments so any new command prompts get the updated %PATH% -->"}, {"sha": "7c2e91474c1f1710e5f85c62d09c47ea957e19ba", "filename": "src/etc/lldb_batchmode.py", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Flldb_batchmode.py", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Flldb_batchmode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_batchmode.py?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -45,7 +45,10 @@ def normalize_whitespace(s):\n \n def breakpoint_callback(frame, bp_loc, dict):\n     \"\"\"This callback is registered with every breakpoint and makes sure that the\n-    frame containing the breakpoint location is selected\"\"\"\n+    frame containing the breakpoint location is selected \"\"\"\n+\n+    # HACK(eddyb) print a newline to avoid continuing an unfinished line.\n+    print(\"\")\n     print(\"Hit breakpoint \" + str(bp_loc))\n \n     # Select the frame and the thread containing it"}, {"sha": "262a53eabe3c7bf3030eafc9c8c79a8d3000522c", "filename": "src/etc/wasm32-shim.js", "status": "modified", "additions": 1, "deletions": 107, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Fwasm32-shim.js", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fetc%2Fwasm32-shim.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fwasm32-shim.js?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -15,113 +15,7 @@ const buffer = fs.readFileSync(process.argv[2]);\n Error.stackTraceLimit = 20;\n \n let m = new WebAssembly.Module(buffer);\n-\n-let memory = null;\n-\n-function viewstruct(data, fields) {\n-  return new Uint32Array(memory.buffer).subarray(data/4, data/4 + fields);\n-}\n-\n-function copystr(a, b) {\n-  let view = new Uint8Array(memory.buffer).subarray(a, a + b);\n-  return String.fromCharCode.apply(null, view);\n-}\n-\n-function syscall_write([fd, ptr, len]) {\n-  let s = copystr(ptr, len);\n-  switch (fd) {\n-    case 1: process.stdout.write(s); break;\n-    case 2: process.stderr.write(s); break;\n-  }\n-}\n-\n-function syscall_exit([code]) {\n-  process.exit(code);\n-}\n-\n-function syscall_args(params) {\n-  let [ptr, len] = params;\n-\n-  // Calculate total required buffer size\n-  let totalLen = -1;\n-  for (let i = 2; i < process.argv.length; ++i) {\n-    totalLen += Buffer.byteLength(process.argv[i]) + 1;\n-  }\n-  if (totalLen < 0) { totalLen = 0; }\n-  params[2] = totalLen;\n-\n-  // If buffer is large enough, copy data\n-  if (len >= totalLen) {\n-    let view = new Uint8Array(memory.buffer);\n-    for (let i = 2; i < process.argv.length; ++i) {\n-      let value = process.argv[i];\n-      Buffer.from(value).copy(view, ptr);\n-      ptr += Buffer.byteLength(process.argv[i]) + 1;\n-    }\n-  }\n-}\n-\n-function syscall_getenv(params) {\n-  let [keyPtr, keyLen, valuePtr, valueLen] = params;\n-\n-  let key = copystr(keyPtr, keyLen);\n-  let value = process.env[key];\n-\n-  if (value == null) {\n-    params[4] = 0xFFFFFFFF;\n-  } else {\n-    let view = new Uint8Array(memory.buffer);\n-    let totalLen = Buffer.byteLength(value);\n-    params[4] = totalLen;\n-    if (valueLen >= totalLen) {\n-      Buffer.from(value).copy(view, valuePtr);\n-    }\n-  }\n-}\n-\n-function syscall_time(params) {\n-  let t = Date.now();\n-  let secs = Math.floor(t / 1000);\n-  let millis = t % 1000;\n-  params[1] = Math.floor(secs / 0x100000000);\n-  params[2] = secs % 0x100000000;\n-  params[3] = Math.floor(millis * 1000000);\n-}\n-\n-let imports = {};\n-imports.env = {\n-  // These are generated by LLVM itself for various intrinsic calls. Hopefully\n-  // one day this is not necessary and something will automatically do this.\n-  fmod: function(x, y) { return x % y; },\n-  exp2: function(x) { return Math.pow(2, x); },\n-  exp2f: function(x) { return Math.pow(2, x); },\n-  ldexp: function(x, y) { return x * Math.pow(2, y); },\n-  ldexpf: function(x, y) { return x * Math.pow(2, y); },\n-  sin: Math.sin,\n-  sinf: Math.sin,\n-  cos: Math.cos,\n-  cosf: Math.cos,\n-  log: Math.log,\n-  log2: Math.log2,\n-  log10: Math.log10,\n-  log10f: Math.log10,\n-\n-  rust_wasm_syscall: function(index, data) {\n-    switch (index) {\n-      case 1: syscall_write(viewstruct(data, 3)); return true;\n-      case 2: syscall_exit(viewstruct(data, 1)); return true;\n-      case 3: syscall_args(viewstruct(data, 3)); return true;\n-      case 4: syscall_getenv(viewstruct(data, 5)); return true;\n-      case 6: syscall_time(viewstruct(data, 4)); return true;\n-      default:\n-        console.log(\"Unsupported syscall: \" + index);\n-        return false;\n-    }\n-  }\n-};\n-\n-let instance = new WebAssembly.Instance(m, imports);\n-memory = instance.exports.memory;\n+let instance = new WebAssembly.Instance(m, {});\n try {\n   instance.exports.main();\n } catch (e) {"}, {"sha": "a39fcd5ad4c580fef0c96d466dc3d9c05728249d", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -240,7 +240,7 @@ pub(crate) unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[rustc_allocator_nounwind]\n pub fn handle_alloc_error(layout: Layout) -> ! {\n-    #[allow(improper_ctypes)]\n+    #[cfg_attr(bootstrap, allow(improper_ctypes))]\n     extern \"Rust\" {\n         #[lang = \"oom\"]\n         fn oom_impl(layout: Layout) -> !;"}, {"sha": "0cb91ba4c81da148c9f89dde57ca042162b7e529", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -3,7 +3,7 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::cmp::max;\n+use core::cmp::{max, min};\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n@@ -187,8 +187,8 @@ pub struct Intersection<'a, T: 'a> {\n }\n enum IntersectionInner<'a, T: 'a> {\n     Stitch {\n-        small_iter: Iter<'a, T>, // for size_hint, should be the smaller of the sets\n-        other_iter: Iter<'a, T>,\n+        a: Iter<'a, T>,\n+        b: Iter<'a, T>,\n     },\n     Search {\n         small_iter: Iter<'a, T>,\n@@ -201,12 +201,12 @@ impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match &self.inner {\n             IntersectionInner::Stitch {\n-                small_iter,\n-                other_iter,\n+                a,\n+                b,\n             } => f\n                 .debug_tuple(\"Intersection\")\n-                .field(&small_iter)\n-                .field(&other_iter)\n+                .field(&a)\n+                .field(&b)\n                 .finish(),\n             IntersectionInner::Search {\n                 small_iter,\n@@ -397,8 +397,8 @@ impl<T: Ord> BTreeSet<T> {\n             // Iterate both sets jointly, spotting matches along the way.\n             Intersection {\n                 inner: IntersectionInner::Stitch {\n-                    small_iter: small.iter(),\n-                    other_iter: other.iter(),\n+                    a: small.iter(),\n+                    b: other.iter(),\n                 },\n             }\n         } else {\n@@ -1221,11 +1221,11 @@ impl<T> Clone for Intersection<'_, T> {\n         Intersection {\n             inner: match &self.inner {\n                 IntersectionInner::Stitch {\n-                    small_iter,\n-                    other_iter,\n+                    a,\n+                    b,\n                 } => IntersectionInner::Stitch {\n-                    small_iter: small_iter.clone(),\n-                    other_iter: other_iter.clone(),\n+                    a: a.clone(),\n+                    b: b.clone(),\n                 },\n                 IntersectionInner::Search {\n                     small_iter,\n@@ -1245,16 +1245,16 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         match &mut self.inner {\n             IntersectionInner::Stitch {\n-                small_iter,\n-                other_iter,\n+                a,\n+                b,\n             } => {\n-                let mut small_next = small_iter.next()?;\n-                let mut other_next = other_iter.next()?;\n+                let mut a_next = a.next()?;\n+                let mut b_next = b.next()?;\n                 loop {\n-                    match Ord::cmp(small_next, other_next) {\n-                        Less => small_next = small_iter.next()?,\n-                        Greater => other_next = other_iter.next()?,\n-                        Equal => return Some(small_next),\n+                    match Ord::cmp(a_next, b_next) {\n+                        Less => a_next = a.next()?,\n+                        Greater => b_next = b.next()?,\n+                        Equal => return Some(a_next),\n                     }\n                 }\n             }\n@@ -1272,7 +1272,7 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let min_len = match &self.inner {\n-            IntersectionInner::Stitch { small_iter, .. } => small_iter.len(),\n+            IntersectionInner::Stitch { a, b } => min(a.len(), b.len()),\n             IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n         };\n         (0, Some(min_len))"}, {"sha": "816a71f2557982a22b7d53c5dea848098dd96291", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -276,7 +276,7 @@ impl<T> LinkedList<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn new() -> Self {\n+    pub const fn new() -> Self {\n         LinkedList {\n             head: None,\n             tail: None,"}, {"sha": "ecb5948f11b363447d0738106c8175be60e06346", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -102,8 +102,8 @@ fn test_append() {\n         assert_eq!(m.pop_front(), Some(elt))\n     }\n     assert_eq!(n.len(), 0);\n-    // let's make sure it's working properly, since we\n-    // did some direct changes to private members\n+    // Let's make sure it's working properly, since we\n+    // did some direct changes to private members.\n     n.push_back(3);\n     assert_eq!(n.len(), 1);\n     assert_eq!(n.pop_front(), Some(3));"}, {"sha": "a4a0fbb194dd448083c320643d2c8a2ef505a60b", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1810,7 +1810,7 @@ impl<T> VecDeque<T> {\n         other\n     }\n \n-    /// Moves all the elements of `other` into `Self`, leaving `other` empty.\n+    /// Moves all the elements of `other` into `self`, leaving `other` empty.\n     ///\n     /// # Panics\n     ///\n@@ -1847,7 +1847,7 @@ impl<T> VecDeque<T> {\n     ///\n     /// let mut buf = VecDeque::new();\n     /// buf.extend(1..5);\n-    /// buf.retain(|&x| x%2 == 0);\n+    /// buf.retain(|&x| x % 2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n     ///"}, {"sha": "9e6ed92ffb567295d9a312f174838ddbcb11c48b", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -117,7 +117,7 @@\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(rustc_const_unstable)]\n-#![feature(const_vec_new)]\n+#![cfg_attr(bootstrap, feature(const_vec_new))]\n #![feature(slice_partition_dedup)]\n #![feature(maybe_uninit_extra, maybe_uninit_slice)]\n #![feature(alloc_layout_extra)]\n@@ -171,3 +171,9 @@ pub mod vec;\n mod std {\n     pub use core::ops; // RangeFull\n }\n+\n+#[doc(hidden)]\n+#[unstable(feature = \"liballoc_internals\", issue = \"0\", reason = \"implementation detail\")]\n+pub mod __export {\n+    pub use core::format_args;\n+}"}, {"sha": "2f2cdc39c633db3f763d302db11cfdb6c0602031", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -98,5 +98,5 @@ macro_rules! vec {\n #[macro_export]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n macro_rules! format {\n-    ($($arg:tt)*) => ($crate::fmt::format(::core::format_args!($($arg)*)))\n+    ($($arg:tt)*) => ($crate::fmt::format($crate::__export::format_args!($($arg)*)))\n }"}, {"sha": "ee75fc288fee5b7a380b071944c6affc2825103a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 100, "deletions": 77, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -19,26 +19,26 @@ mod tests;\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n /// In particular:\n ///\n-/// * Produces Unique::empty() on zero-sized types\n-/// * Produces Unique::empty() on zero-length allocations\n-/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics)\n-/// * Guards against 32-bit systems allocating more than isize::MAX bytes\n-/// * Guards against overflowing your length\n-/// * Aborts on OOM or calls handle_alloc_error as applicable\n-/// * Avoids freeing Unique::empty()\n-/// * Contains a ptr::Unique and thus endows the user with all related benefits\n+/// * Produces `Unique::empty()` on zero-sized types.\n+/// * Produces `Unique::empty()` on zero-length allocations.\n+/// * Catches all overflows in capacity computations (promotes them to \"capacity overflow\" panics).\n+/// * Guards against 32-bit systems allocating more than isize::MAX bytes.\n+/// * Guards against overflowing your length.\n+/// * Aborts on OOM or calls `handle_alloc_error` as applicable.\n+/// * Avoids freeing `Unique::empty()`.\n+/// * Contains a `ptr::Unique` and thus endows the user with all related benefits.\n ///\n /// This type does not in anyway inspect the memory that it manages. When dropped it *will*\n-/// free its memory, but it *won't* try to Drop its contents. It is up to the user of RawVec\n-/// to handle the actual things *stored* inside of a RawVec.\n+/// free its memory, but it *won't* try to drop its contents. It is up to the user of `RawVec`\n+/// to handle the actual things *stored* inside of a `RawVec`.\n ///\n-/// Note that a RawVec always forces its capacity to be usize::MAX for zero-sized types.\n-/// This enables you to use capacity growing logic catch the overflows in your length\n+/// Note that a `RawVec` always forces its capacity to be `usize::MAX` for zero-sized types.\n+/// This enables you to use capacity-growing logic catch the overflows in your length\n /// that might occur with zero-sized types.\n ///\n-/// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n-/// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n+/// The above means that you need to be careful when round-tripping this type with a\n+/// `Box<[T]>`, since `capacity()` won't yield the length. However, `with_capacity`,\n+/// `shrink_to_fit`, and `from_box` will actually set `RawVec`'s private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n #[allow(missing_debug_implementations)]\n@@ -49,14 +49,14 @@ pub struct RawVec<T, A: Alloc = Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Like `new` but parameterized over the choice of allocator for\n-    /// the returned RawVec.\n+    /// Like `new`, but parameterized over the choice of allocator for\n+    /// the returned `RawVec`.\n     pub const fn new_in(a: A) -> Self {\n-        // !0 is usize::MAX. This branch should be stripped at compile time.\n-        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n         //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n \n-        // Unique::empty() doubles as \"unallocated\" and \"zero-sized allocation\"\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n         RawVec {\n             ptr: Unique::empty(),\n             // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n@@ -65,15 +65,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Like `with_capacity` but parameterized over the choice of\n-    /// allocator for the returned RawVec.\n+    /// Like `with_capacity`, but parameterized over the choice of\n+    /// allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, false, a)\n     }\n \n-    /// Like `with_capacity_zeroed` but parameterized over the choice\n-    /// of allocator for the returned RawVec.\n+    /// Like `with_capacity_zeroed`, but parameterized over the choice\n+    /// of allocator for the returned `RawVec`.\n     #[inline]\n     pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n         RawVec::allocate_in(capacity, true, a)\n@@ -86,7 +86,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `capacity = 0` alike\n+            // Handles ZSTs and `capacity == 0` alike.\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -113,20 +113,45 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Creates the biggest possible RawVec (on the system heap)\n-    /// without allocating. If T has positive size, then this makes a\n-    /// RawVec with capacity 0. If T has 0 size, then it makes a\n-    /// RawVec with capacity `usize::MAX`. Useful for implementing\n+    /// HACK(Centril): This exists because `#[unstable]` `const fn`s needn't conform\n+    /// to `min_const_fn` and so they cannot be called in `min_const_fn`s either.\n+    ///\n+    /// If you change `RawVec<T>::new` or dependencies, please take care to not\n+    /// introduce anything that would truly violate `min_const_fn`.\n+    ///\n+    /// NOTE: We could avoid this hack and check conformance with some\n+    /// `#[rustc_force_min_const_fn]` attribute which requires conformance\n+    /// with `min_const_fn` but does not necessarily allow calling it in\n+    /// `stable(...) const fn` / user code not enabling `foo` when\n+    /// `#[rustc_const_unstable(feature = \"foo\", ..)]` is present.\n+    pub const NEW: Self = Self::new();\n+\n+    /// Creates the biggest possible `RawVec` (on the system heap)\n+    /// without allocating. If `T` has positive size, then this makes a\n+    /// `RawVec` with capacity `0`. If `T` is zero-sized, then it makes a\n+    /// `RawVec` with capacity `usize::MAX`. Useful for implementing\n     /// delayed allocation.\n     pub const fn new() -> Self {\n-        Self::new_in(Global)\n+        // FIXME(Centril): Reintegrate this with `fn new_in` when we can.\n+\n+        // `!0` is `usize::MAX`. This branch should be stripped at compile time.\n+        // FIXME(mark-i-m): use this line when `if`s are allowed in `const`:\n+        //let cap = if mem::size_of::<T>() == 0 { !0 } else { 0 };\n+\n+        // `Unique::empty()` doubles as \"unallocated\" and \"zero-sized allocation\".\n+        RawVec {\n+            ptr: Unique::empty(),\n+            // FIXME(mark-i-m): use `cap` when ifs are allowed in const\n+            cap: [0, !0][(mem::size_of::<T>() == 0) as usize],\n+            a: Global,\n+        }\n     }\n \n-    /// Creates a RawVec (on the system heap) with exactly the\n+    /// Creates a `RawVec` (on the system heap) with exactly the\n     /// capacity and alignment requirements for a `[T; capacity]`. This is\n-    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n+    /// equivalent to calling `RawVec::new` when `capacity` is `0` or `T` is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n-    /// *not* get a RawVec with the requested capacity!\n+    /// *not* get a `RawVec` with the requested capacity.\n     ///\n     /// # Panics\n     ///\n@@ -136,27 +161,27 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     #[inline]\n     pub fn with_capacity(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, false, Global)\n     }\n \n-    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    /// Like `with_capacity`, but guarantees the buffer is zeroed.\n     #[inline]\n     pub fn with_capacity_zeroed(capacity: usize) -> Self {\n         RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Reconstitutes a RawVec from a pointer, capacity, and allocator.\n+    /// Reconstitutes a `RawVec` from a pointer, capacity, and allocator.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n+    /// The `ptr` must be allocated (via the given allocator `a`), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec` created via `a`, then this is guaranteed.\n     pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -167,13 +192,13 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n impl<T> RawVec<T, Global> {\n-    /// Reconstitutes a RawVec from a pointer, capacity.\n+    /// Reconstitutes a `RawVec` from a pointer and capacity.\n     ///\n     /// # Undefined Behavior\n     ///\n-    /// The ptr must be allocated (on the system heap), and with the given capacity. The\n-    /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n-    /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n+    /// The `ptr` must be allocated (on the system heap), and with the given `capacity`.\n+    /// The `capacity` cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n+    /// If the `ptr` and `capacity` come from a `RawVec`, then this is guaranteed.\n     pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n@@ -194,7 +219,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n+    /// `Unique::empty()` if `capacity == 0` or `T` is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -212,12 +237,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n         }\n     }\n \n-    /// Returns a shared reference to the allocator backing this RawVec.\n+    /// Returns a shared reference to the allocator backing this `RawVec`.\n     pub fn alloc(&self) -> &A {\n         &self.a\n     }\n \n-    /// Returns a mutable reference to the allocator backing this RawVec.\n+    /// Returns a mutable reference to the allocator backing this `RawVec`.\n     pub fn alloc_mut(&mut self) -> &mut A {\n         &mut self.a\n     }\n@@ -247,7 +272,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -290,20 +315,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n             let (new_cap, uniq) = match self.current_layout() {\n                 Some(cur) => {\n                     // Since we guarantee that we never allocate more than\n-                    // isize::MAX bytes, `elem_size * self.cap <= isize::MAX` as\n+                    // `isize::MAX` bytes, `elem_size * self.cap <= isize::MAX` as\n                     // a precondition, so this can't overflow. Additionally the\n                     // alignment will never be too large as to \"not be\n                     // satisfiable\", so `Layout::from_size_align` will always\n                     // return `Some`.\n                     //\n-                    // tl;dr; we bypass runtime checks due to dynamic assertions\n+                    // TL;DR, we bypass runtime checks due to dynamic assertions\n                     // in this module, allowing us to use\n                     // `from_size_align_unchecked`.\n                     let new_cap = 2 * self.cap;\n@@ -320,8 +345,8 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     }\n                 }\n                 None => {\n-                    // skip to 4 because tiny Vec's are dumb; but not if that\n-                    // would cause overflow\n+                    // Skip to 4 because tiny `Vec`'s are dumb; but not if that\n+                    // would cause overflow.\n                     let new_cap = if elem_size > (!0) / 8 { 1 } else { 4 };\n                     match self.a.alloc_array::<T>(new_cap) {\n                         Ok(ptr) => (new_cap, ptr.into()),\n@@ -342,7 +367,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Panics\n     ///\n-    /// * Panics if T is zero-sized on the assumption that you managed to exhaust\n+    /// * Panics if `T` is zero-sized on the assumption that you managed to exhaust\n     ///   all `usize::MAX` slots in your imaginary buffer.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n@@ -356,15 +381,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 None => return false, // nothing to double\n             };\n \n-            // since we set the capacity to usize::MAX when elem_size is\n-            // 0, getting to here necessarily means the RawVec is overfull.\n+            // Since we set the capacity to `usize::MAX` when `elem_size` is\n+            // 0, getting to here necessarily means the `RawVec` is overfull.\n             assert!(elem_size != 0, \"capacity overflow\");\n \n-            // Since we guarantee that we never allocate more than isize::MAX\n+            // Since we guarantee that we never allocate more than `isize::MAX`\n             // bytes, `elem_size * self.cap <= isize::MAX` as a precondition, so\n             // this can't overflow.\n             //\n-            // Similarly like with `double` above we can go straight to\n+            // Similarly to with `double` above, we can go straight to\n             // `Layout::from_size_align_unchecked` as we know this won't\n             // overflow and the alignment is sufficiently small.\n             let new_cap = 2 * self.cap;\n@@ -409,7 +434,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n         match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n@@ -424,7 +449,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, TryReserveError> {\n \n-        // Nothing we can really do about these checks :(\n+        // Nothing we can really do about these checks, sadly.\n         let required_cap = used_capacity.checked_add(needed_extra_capacity)\n             .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n@@ -459,7 +484,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// # Aborts\n     ///\n-    /// Aborts on OOM\n+    /// Aborts on OOM.\n     ///\n     /// # Examples\n     ///\n@@ -538,7 +563,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n             // (regardless of whether `self.cap - used_capacity` wrapped).\n-            // Therefore we can safely call grow_in_place.\n+            // Therefore, we can safely call `grow_in_place`.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n@@ -576,14 +601,14 @@ impl<T, A: Alloc> RawVec<T, A> {\n             return;\n         }\n \n-        // This check is my waterloo; it's the only thing Vec wouldn't have to do.\n+        // This check is my waterloo; it's the only thing `Vec` wouldn't have to do.\n         assert!(self.cap >= amount, \"Tried to shrink to a larger capacity\");\n \n         if amount == 0 {\n             // We want to create a new zero-length vector within the\n-            // same allocator.  We use ptr::write to avoid an\n+            // same allocator. We use `ptr::write` to avoid an\n             // erroneous attempt to drop the contents, and we use\n-            // ptr::read to sidestep condition against destructuring\n+            // `ptr::read` to sidestep condition against destructuring\n             // types that implement Drop.\n \n             unsafe {\n@@ -600,7 +625,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 //\n                 // We also know that `self.cap` is greater than `amount`, and\n                 // consequently we don't need runtime checks for creating either\n-                // layout\n+                // layout.\n                 let old_size = elem_size * self.cap;\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n@@ -653,7 +678,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 return Ok(());\n             }\n \n-            // Nothing we can really do about these checks :(\n+            // Nothing we can really do about these checks, sadly.\n             let new_cap = match strategy {\n                 Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n                 Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n@@ -692,15 +717,15 @@ impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n     /// Note that this will correctly reconstitute any `cap` changes\n-    /// that may have been performed. (see description of type for details)\n+    /// that may have been performed. (See description of type for details.)\n     ///\n     /// # Undefined Behavior\n     ///\n     /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n     /// the rules around uninitialized boxed values are not finalized yet,\n     /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here; actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -709,7 +734,7 @@ impl<T> RawVec<T, Global> {\n }\n \n impl<T, A: Alloc> RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     pub unsafe fn dealloc_buffer(&mut self) {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n@@ -721,22 +746,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n }\n \n unsafe impl<#[may_dangle] T, A: Alloc> Drop for RawVec<T, A> {\n-    /// Frees the memory owned by the RawVec *without* trying to Drop its contents.\n+    /// Frees the memory owned by the `RawVec` *without* trying to drop its contents.\n     fn drop(&mut self) {\n         unsafe { self.dealloc_buffer(); }\n     }\n }\n \n-\n-\n // We need to guarantee the following:\n-// * We don't ever allocate `> isize::MAX` byte-size objects\n-// * We don't overflow `usize::MAX` and actually allocate too little\n+// * We don't ever allocate `> isize::MAX` byte-size objects.\n+// * We don't overflow `usize::MAX` and actually allocate too little.\n //\n // On 64-bit we just need to check for overflow since trying to allocate\n // `> isize::MAX` bytes will surely fail. On 32-bit and 16-bit we need to add\n // an extra guard for this in case we're running on a platform which can use\n-// all 4GB in user-space. e.g., PAE or x32\n+// all 4GB in user-space, e.g., PAE or x32.\n \n #[inline]\n fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n@@ -751,5 +774,5 @@ fn alloc_guard(alloc_size: usize) -> Result<(), TryReserveError> {\n // ensure that the code generation related to these panics is minimal as there's\n // only one location which panics rather than a bunch throughout the module.\n fn capacity_overflow() -> ! {\n-    panic!(\"capacity overflow\")\n+    panic!(\"capacity overflow\");\n }"}, {"sha": "d35b62fc1ef15ce8b18ac8bd7628b38a3c9190ee", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,12 +5,12 @@ fn allocator_param() {\n     use crate::alloc::AllocErr;\n \n     // Writing a test of integration between third-party\n-    // allocators and RawVec is a little tricky because the RawVec\n+    // allocators and `RawVec` is a little tricky because the `RawVec`\n     // API does not expose fallible allocation methods, so we\n     // cannot check what happens when allocator is exhausted\n     // (beyond detecting a panic).\n     //\n-    // Instead, this just checks that the RawVec methods do at\n+    // Instead, this just checks that the `RawVec` methods do at\n     // least go through the Allocator API when it reserves\n     // storage.\n \n@@ -44,7 +44,7 @@ fn allocator_param() {\n fn reserve_does_not_overallocate() {\n     {\n         let mut v: RawVec<u32> = RawVec::new();\n-        // First `reserve` allocates like `reserve_exact`\n+        // First, `reserve` allocates like `reserve_exact`.\n         v.reserve(0, 9);\n         assert_eq!(9, v.capacity());\n     }"}, {"sha": "f234ac5ebe51bcd2628df98ccbe5d86199eb5c9d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -567,7 +567,7 @@ impl<T: ?Sized> Rc<T> {\n     ///     let x = Rc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n@@ -1832,8 +1832,9 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just values\n-    /// that compare as equal).\n+    /// Returns `true` if the two `Weak`s point to the same value (not just\n+    /// values that compare as equal), or if both don't point to any value\n+    /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n@@ -1843,7 +1844,6 @@ impl<T: ?Sized> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n@@ -1861,7 +1861,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Comparing `Weak::new`.\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let first = Weak::new();\n@@ -1873,7 +1872,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()\n     }"}, {"sha": "1166e7b5df2959bb3d6d64af27e56b193a898045", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -369,7 +369,7 @@ impl String {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_string_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_string_new\"))]\n     pub const fn new() -> String {\n         String { vec: Vec::new() }\n     }"}, {"sha": "45f98162e4cd57fa3e8798f31b2ee6f76025a68c", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -547,7 +547,7 @@ impl<T: ?Sized> Arc<T> {\n     ///     let x = Arc::from_raw(x_ptr);\n     ///     assert_eq!(&*x, \"hello\");\n     ///\n-    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory unsafe.\n+    ///     // Further calls to `Arc::from_raw(x_ptr)` would be memory-unsafe.\n     /// }\n     ///\n     /// // The memory was freed when `x` went out of scope above, so `x_ptr` is now dangling!\n@@ -1550,19 +1550,18 @@ impl<T: ?Sized> Weak<T> {\n         }\n     }\n \n-    /// Returns `true` if the two `Weak`s point to the same value (not just values\n-    /// that compare as equal).\n+    /// Returns `true` if the two `Weak`s point to the same value (not just\n+    /// values that compare as equal), or if both don't point to any value\n+    /// (because they were created with `Weak::new()`).\n     ///\n     /// # Notes\n     ///\n     /// Since this compares pointers it means that `Weak::new()` will equal each\n     /// other, even though they don't point to any value.\n     ///\n-    ///\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::sync::Arc;\n     ///\n     /// let first_rc = Arc::new(5);\n@@ -1580,7 +1579,6 @@ impl<T: ?Sized> Weak<T> {\n     /// Comparing `Weak::new`.\n     ///\n     /// ```\n-    /// #![feature(weak_ptr_eq)]\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let first = Weak::new();\n@@ -1592,7 +1590,7 @@ impl<T: ?Sized> Weak<T> {\n     /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n-    #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n+    #[stable(feature = \"weak_ptr_eq\", since = \"1.39.0\")]\n     pub fn ptr_eq(&self, other: &Self) -> bool {\n         self.ptr.as_ptr() == other.ptr.as_ptr()\n     }"}, {"sha": "35db18c39c83a705be03ec3b6813c03db8ba06fe", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -90,6 +90,17 @@ fn test_intersection() {\n                        &[1, 3, 11, 77, 103]);\n }\n \n+#[test]\n+fn test_intersection_size_hint() {\n+    let x: BTreeSet<i32> = [3, 4].iter().copied().collect();\n+    let y: BTreeSet<i32> = [1, 2, 3].iter().copied().collect();\n+    let mut iter = x.intersection(&y);\n+    assert_eq!(iter.size_hint(), (0, Some(2)));\n+    assert_eq!(iter.next(), Some(&3));\n+    assert_eq!(iter.size_hint(), (0, Some(0)));\n+    assert_eq!(iter.next(), None);\n+}\n+\n #[test]\n fn test_difference() {\n     fn check_difference(a: &[i32], b: &[i32], expected: &[i32]) {"}, {"sha": "405969a550b88121395350ff4d70d9e4a570bfd8", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -291,6 +291,7 @@ use crate::raw_vec::RawVec;\n /// [`reserve`]: ../../std/vec/struct.Vec.html#method.reserve\n /// [owned slice]: ../../std/boxed/struct.Box.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+#[cfg_attr(all(not(bootstrap), not(test)), rustc_diagnostic_item = \"vec_type\")]\n pub struct Vec<T> {\n     buf: RawVec<T>,\n     len: usize,\n@@ -313,10 +314,10 @@ impl<T> Vec<T> {\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_const_unstable(feature = \"const_vec_new\")]\n+    #[cfg_attr(bootstrap, rustc_const_unstable(feature = \"const_vec_new\"))]\n     pub const fn new() -> Vec<T> {\n         Vec {\n-            buf: RawVec::new(),\n+            buf: RawVec::NEW,\n             len: 0,\n         }\n     }\n@@ -684,21 +685,25 @@ impl<T> Vec<T> {\n     /// [`drain`]: #method.drain\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n-        let current_len = self.len;\n-        unsafe {\n-            let mut ptr = self.as_mut_ptr().add(self.len);\n-            // Set the final length at the end, keeping in mind that\n-            // dropping an element might panic. Works around a missed\n-            // optimization, as seen in the following issue:\n-            // https://github.com/rust-lang/rust/issues/51802\n-            let mut local_len = SetLenOnDrop::new(&mut self.len);\n+        if mem::needs_drop::<T>() {\n+            let current_len = self.len;\n+            unsafe {\n+                let mut ptr = self.as_mut_ptr().add(self.len);\n+                // Set the final length at the end, keeping in mind that\n+                // dropping an element might panic. Works around a missed\n+                // optimization, as seen in the following issue:\n+                // https://github.com/rust-lang/rust/issues/51802\n+                let mut local_len = SetLenOnDrop::new(&mut self.len);\n \n-            // drop any extra elements\n-            for _ in len..current_len {\n-                local_len.decrement_len(1);\n-                ptr = ptr.offset(-1);\n-                ptr::drop_in_place(ptr);\n+                // drop any extra elements\n+                for _ in len..current_len {\n+                    local_len.decrement_len(1);\n+                    ptr = ptr.offset(-1);\n+                    ptr::drop_in_place(ptr);\n+                }\n             }\n+        } else if len <= self.len {\n+            self.len = len;\n         }\n     }\n "}, {"sha": "0afbf4f134679b7343de55c5e8377a577cfd2323", "filename": "src/libcore/any.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -153,13 +153,13 @@ impl dyn Any {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn is<T: Any>(&self) -> bool {\n-        // Get TypeId of the type this function is instantiated with\n+        // Get `TypeId` of the type this function is instantiated with.\n         let t = TypeId::of::<T>();\n \n-        // Get TypeId of the type in the trait object\n+        // Get `TypeId` of the type in the trait object.\n         let concrete = self.type_id();\n \n-        // Compare both TypeIds on equality\n+        // Compare both `TypeId`s on equality.\n         t == concrete\n     }\n "}, {"sha": "32ec26975e375291ec503bd2194c7419e041f917", "filename": "src/libcore/bool.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbool.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -0,0 +1,45 @@\n+//! impl bool {}\n+\n+#[cfg(not(boostrap_stdarch_ignore_this))]\n+#[lang = \"bool\"]\n+impl bool {\n+    /// Returns `Some(t)` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then(0), None);\n+    /// assert_eq!(true.then(0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then<T>(self, t: T) -> Option<T> {\n+        if self {\n+            Some(t)\n+        } else {\n+            None\n+        }\n+    }\n+\n+    /// Returns `Some(f())` if the `bool` is `true`, or `None` otherwise.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(bool_to_option)]\n+    ///\n+    /// assert_eq!(false.then_with(|| 0), None);\n+    /// assert_eq!(true.then_with(|| 0), Some(0));\n+    /// ```\n+    #[unstable(feature = \"bool_to_option\", issue = \"64260\")]\n+    #[inline]\n+    pub fn then_with<T, F: FnOnce() -> T>(self, f: F) -> Option<T> {\n+        if self {\n+            Some(f())\n+        } else {\n+            None\n+        }\n+    }\n+}"}, {"sha": "a69eb0f6d4b20fb1b05e621f4b962f1eb7c465d0", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -547,29 +547,6 @@ impl char {\n         }\n     }\n \n-    /// Returns `true` if this `char` satisfies the `XID_Start` Unicode property, and false\n-    /// otherwise.\n-    ///\n-    /// `XID_Start` is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to `ID_Start` but modified for closure under `NFKx`.\n-    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n-    pub fn is_xid_start(self) -> bool {\n-        derived_property::XID_Start(self)\n-    }\n-\n-    /// Returns `true` if this `char` satisfies the `XID_Continue` Unicode property, and false\n-    /// otherwise.\n-    ///\n-    /// `XID_Continue` is a Unicode Derived Property specified in\n-    /// [UAX #31](http://unicode.org/reports/tr31/#NFKC_Modifications),\n-    /// mostly similar to `ID_Continue` but modified for closure under NFKx.\n-    #[unstable(feature = \"unicode_internals\", issue = \"0\")]\n-    #[inline]\n-    pub fn is_xid_continue(self) -> bool {\n-        derived_property::XID_Continue(self)\n-    }\n-\n     /// Returns `true` if this `char` is lowercase.\n     ///\n     /// 'Lowercase' is defined according to the terms of the Unicode Derived Core"}, {"sha": "4e2b1627e15ef17d9d24161dfcf8b5cc121392af", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 106, "deletions": 10, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -9,14 +9,22 @@\n //! * [`Ord`] and [`PartialOrd`] are traits that allow you to define total and\n //!   partial orderings between values, respectively. Implementing them overloads\n //!   the `<`, `<=`, `>`, and `>=` operators.\n-//! * [`Ordering`][cmp::Ordering] is an enum returned by the\n-//!   main functions of [`Ord`] and [`PartialOrd`], and describes an ordering.\n-//! * [`Reverse`][cmp::Reverse] is a struct that allows you to easily reverse\n-//!   an ordering.\n-//! * [`max`][cmp::max] and [`min`][cmp::min] are functions that build off of\n-//!   [`Ord`] and allow you to find the maximum or minimum of two values.\n+//! * [`Ordering`] is an enum returned by the main functions of [`Ord`] and\n+//!   [`PartialOrd`], and describes an ordering.\n+//! * [`Reverse`] is a struct that allows you to easily reverse an ordering.\n+//! * [`max`] and [`min`] are functions that build off of [`Ord`] and allow you\n+//!   to find the maximum or minimum of two values.\n //!\n //! For more details, see the respective documentation of each item in the list.\n+//!\n+//! [`Eq`]: trait.Eq.html\n+//! [`PartialEq`]: trait.PartialEq.html\n+//! [`Ord`]: trait.Ord.html\n+//! [`PartialOrd`]: trait.PartialOrd.html\n+//! [`Ordering`]: enum.Ordering.html\n+//! [`Reverse`]: struct.Reverse.html\n+//! [`max`]: fn.max.html\n+//! [`min`]: fn.min.html\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n@@ -562,7 +570,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[inline]\n     fn max(self, other: Self) -> Self\n     where Self: Sized {\n-        if other >= self { other } else { self }\n+        max_by(self, other, Ord::cmp)\n     }\n \n     /// Compares and returns the minimum of two values.\n@@ -579,7 +587,7 @@ pub trait Ord: Eq + PartialOrd<Self> {\n     #[inline]\n     fn min(self, other: Self) -> Self\n     where Self: Sized {\n-        if self <= other { self } else { other }\n+        min_by(self, other, Ord::cmp)\n     }\n \n     /// Restrict a value to a certain interval.\n@@ -890,6 +898,49 @@ pub fn min<T: Ord>(v1: T, v2: T) -> T {\n     v1.min(v2)\n }\n \n+/// Returns the minimum of two values with respect to the specified comparison function.\n+///\n+/// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::min_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 1);\n+/// assert_eq!(cmp::min_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn min_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n+    match compare(&v1, &v2) {\n+        Ordering::Less | Ordering::Equal => v1,\n+        Ordering::Greater => v2,\n+    }\n+}\n+\n+/// Returns the element that gives the minimum value from the specified function.\n+///\n+/// Returns the first argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::min_by_key(-2, 1, |x: &i32| x.abs()), 1);\n+/// assert_eq!(cmp::min_by_key(-2, 2, |x: &i32| x.abs()), -2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn min_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    min_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n+}\n+\n /// Compares and returns the maximum of two values.\n ///\n /// Returns the second argument if the comparison determines them to be equal.\n@@ -910,6 +961,49 @@ pub fn max<T: Ord>(v1: T, v2: T) -> T {\n     v1.max(v2)\n }\n \n+/// Returns the maximum of two values with respect to the specified comparison function.\n+///\n+/// Returns the second argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::max_by(-2, 1, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), -2);\n+/// assert_eq!(cmp::max_by(-2, 2, |x: &i32, y: &i32| x.abs().cmp(&y.abs())), 2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn max_by<T, F: FnOnce(&T, &T) -> Ordering>(v1: T, v2: T, compare: F) -> T {\n+    match compare(&v1, &v2) {\n+        Ordering::Less | Ordering::Equal => v2,\n+        Ordering::Greater => v1,\n+    }\n+}\n+\n+/// Returns the element that gives the maximum value from the specified function.\n+///\n+/// Returns the second argument if the comparison determines them to be equal.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(cmp_min_max_by)]\n+///\n+/// use std::cmp;\n+///\n+/// assert_eq!(cmp::max_by_key(-2, 1, |x: &i32| x.abs()), -2);\n+/// assert_eq!(cmp::max_by_key(-2, 2, |x: &i32| x.abs()), 2);\n+/// ```\n+#[inline]\n+#[unstable(feature = \"cmp_min_max_by\", issue = \"64460\")]\n+pub fn max_by_key<T, F: FnMut(&T) -> K, K: Ord>(v1: T, v2: T, mut f: F) -> T {\n+    max_by(v1, v2, |v1, v2| f(v1).cmp(&f(v2)))\n+}\n+\n // Implementation of PartialEq, Eq, PartialOrd and Ord for primitive types\n mod impls {\n     use crate::cmp::Ordering::{self, Less, Greater, Equal};\n@@ -1012,8 +1106,10 @@ mod impls {\n             impl Ord for $t {\n                 #[inline]\n                 fn cmp(&self, other: &$t) -> Ordering {\n-                    if *self == *other { Equal }\n-                    else if *self < *other { Less }\n+                    // The order here is important to generate more optimal assembly.\n+                    // See <https://github.com/rust-lang/rust/issues/63758> for more info.\n+                    if *self < *other { Less }\n+                    else if *self == *other { Equal }\n                     else { Greater }\n                 }\n             }"}, {"sha": "06f2b7bab12ebc548c8c051ce8ee3d1a258b3eb2", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -42,11 +42,11 @@\n \n use crate::fmt;\n \n-/// An identity function.\n+/// The identity function.\n ///\n /// Two things are important to note about this function:\n ///\n-/// - It is not always equivalent to a closure like `|x| x` since the\n+/// - It is not always equivalent to a closure like `|x| x`, since the\n ///   closure may coerce `x` into a different type.\n ///\n /// - It moves the input `x` passed to the function.\n@@ -56,31 +56,32 @@ use crate::fmt;\n ///\n /// # Examples\n ///\n-/// Using `identity` to do nothing among other interesting functions:\n+/// Using `identity` to do nothing in a sequence of other, interesting,\n+/// functions:\n ///\n /// ```rust\n /// use std::convert::identity;\n ///\n /// fn manipulation(x: u32) -> u32 {\n-///     // Let's assume that this function does something interesting.\n+///     // Let's pretend that adding one is an interesting function.\n ///     x + 1\n /// }\n ///\n /// let _arr = &[identity, manipulation];\n /// ```\n ///\n-/// Using `identity` to get a function that changes nothing in a conditional:\n+/// Using `identity` as a \"do nothing\" base case in a conditional:\n ///\n /// ```rust\n /// use std::convert::identity;\n ///\n /// # let condition = true;\n-///\n+/// #\n /// # fn manipulation(x: u32) -> u32 { x + 1 }\n-///\n+/// #\n /// let do_stuff = if condition { manipulation } else { identity };\n ///\n-/// // do more interesting stuff..\n+/// // Do more interesting stuff...\n ///\n /// let _results = do_stuff(42);\n /// ```\n@@ -104,22 +105,17 @@ pub const fn identity<T>(x: T) -> T { x }\n /// If you need to do a costly conversion it is better to implement [`From`] with type\n /// `&T` or write a custom function.\n ///\n-/// `AsRef` has the same signature as [`Borrow`], but `Borrow` is different in few aspects:\n+/// `AsRef` has the same signature as [`Borrow`], but [`Borrow`] is different in few aspects:\n ///\n-/// - Unlike `AsRef`, `Borrow` has a blanket impl for any `T`, and can be used to accept either\n+/// - Unlike `AsRef`, [`Borrow`] has a blanket impl for any `T`, and can be used to accept either\n ///   a reference or a value.\n-/// - `Borrow` also requires that `Hash`, `Eq` and `Ord` for borrowed value are\n+/// - [`Borrow`] also requires that [`Hash`], [`Eq`] and [`Ord`] for borrowed value are\n ///   equivalent to those of the owned value. For this reason, if you want to\n-///   borrow only a single field of a struct you can implement `AsRef`, but not `Borrow`.\n-///\n-/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+///   borrow only a single field of a struct you can implement `AsRef`, but not [`Borrow`].\n ///\n /// **Note: This trait must not fail**. If the conversion can fail, use a\n /// dedicated method which returns an [`Option<T>`] or a [`Result<T, E>`].\n ///\n-/// [`Option<T>`]: ../../std/option/enum.Option.html\n-/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n-///\n /// # Generic Implementations\n ///\n /// - `AsRef` auto-dereferences if the inner type is a reference or a mutable\n@@ -132,9 +128,16 @@ pub const fn identity<T>(x: T) -> T { x }\n /// converted to the specified type `T`.\n ///\n /// For example: By creating a generic function that takes an `AsRef<str>` we express that we\n-/// want to accept all references that can be converted to `&str` as an argument.\n-/// Since both [`String`] and `&str` implement `AsRef<str>` we can accept both as input argument.\n+/// want to accept all references that can be converted to [`&str`] as an argument.\n+/// Since both [`String`] and [`&str`] implement `AsRef<str>` we can accept both as input argument.\n ///\n+/// [`Option<T>`]: ../../std/option/enum.Option.html\n+/// [`Result<T, E>`]: ../../std/result/enum.Result.html\n+/// [`Borrow`]: ../../std/borrow/trait.Borrow.html\n+/// [`Hash`]: ../../std/hash/trait.Hash.html\n+/// [`Eq`]: ../../std/cmp/trait.Eq.html\n+/// [`Ord`]: ../../std/cmp/trait.Ord.html\n+/// [`&str`]: ../../std/primitive.str.html\n /// [`String`]: ../../std/string/struct.String.html\n ///\n /// ```"}, {"sha": "7e35188bc1082e7fbe1e5042b7871851201359bc", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -518,7 +518,8 @@ impl Display for Arguments<'_> {\n     label=\"`{Self}` cannot be formatted using `{{:?}}` because it doesn't implement `{Debug}`\",\n )]\n #[doc(alias = \"{:?}\")]\n-#[lang = \"debug_trait\"]\n+#[cfg_attr(boostrap_stdarch_ignore_this, lang = \"debug_trait\")]\n+#[cfg_attr(not(boostrap_stdarch_ignore_this), rustc_diagnostic_item = \"debug_trait\")]\n pub trait Debug {\n     /// Formats the value using the given formatter.\n     ///"}, {"sha": "ee4be6c9151194b0e7a58e32b8be797e188bd933", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -49,28 +49,16 @@ pub unsafe fn unreachable_unchecked() -> ! {\n     intrinsics::unreachable()\n }\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Emits a machine instruction hinting to the processor that it is running in busy-wait\n+/// spin-loop (\"spin lock\").\n ///\n-/// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n-/// power or switching hyper-threads.\n-///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n-///\n-/// Using a busy-wait spin-loop with `spin_loop` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// For a discussion of different locking strategies and their trade-offs, see\n+/// [`core::sync::atomic::spin_loop_hint`].\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n-/// [`std::thread::yield_now`]: ../../std/thread/fn.yield_now.html\n+/// [`core::sync::atomic::spin_loop_hint`]: ../sync/atomic/fn.spin_loop_hint.html\n #[inline]\n #[unstable(feature = \"renamed_spin_loop\", issue = \"55002\")]\n pub fn spin_loop() {\n@@ -104,11 +92,19 @@ pub fn spin_loop() {\n     }\n }\n \n-/// A function that is opaque to the optimizer, to allow benchmarks to\n-/// pretend to use outputs to assist in avoiding dead-code\n-/// elimination.\n+/// An identity function that *__hints__* to the compiler to be maximally pessimistic about what\n+/// `black_box` could do.\n+///\n+/// [`std::convert::identity`]: https://doc.rust-lang.org/core/convert/fn.identity.html\n+///\n+/// Unlike [`std::convert::identity`], a Rust compiler is encouraged to assume that `black_box` can\n+/// use `x` in any possible valid way that Rust code is allowed to without introducing undefined\n+/// behavior in the calling code. This property makes `black_box` useful for writing code in which\n+/// certain optimizations are not desired, such as benchmarks.\n ///\n-/// This function is a no-op, and does not even read from `dummy`.\n+/// Note however, that `black_box` is only (and can only be) provided on a \"best-effort\" basis. The\n+/// extent to which it can block optimisations may vary depending upon the platform and code-gen\n+/// backend used. Programs cannot rely on `black_box` for *correctness* in any way.\n #[inline]\n #[unstable(feature = \"test\", issue = \"50297\")]\n #[allow(unreachable_code)] // this makes #[cfg] a bit easier below."}, {"sha": "ecff40a75978dbca8587d61c8f147781afb1dc67", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -845,21 +845,26 @@ extern \"rust-intrinsic\" {\n     ///\n     /// ```\n     /// let store = [0, 1, 2, 3];\n-    /// let mut v_orig = store.iter().collect::<Vec<&i32>>();\n+    /// let v_orig = store.iter().collect::<Vec<&i32>>();\n+    ///\n+    /// // clone the vector as we will reuse them later\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // Using transmute: this is Undefined Behavior, and a bad idea.\n     /// // However, it is no-copy.\n     /// let v_transmuted = unsafe {\n-    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(\n-    ///         v_orig.clone())\n+    ///     std::mem::transmute::<Vec<&i32>, Vec<Option<&i32>>>(v_clone)\n     /// };\n     ///\n+    /// let v_clone = v_orig.clone();\n+    ///\n     /// // This is the suggested, safe way.\n     /// // It does copy the entire vector, though, into a new array.\n-    /// let v_collected = v_orig.clone()\n-    ///                         .into_iter()\n-    ///                         .map(|r| Some(r))\n-    ///                         .collect::<Vec<Option<&i32>>>();\n+    /// let v_collected = v_clone.into_iter()\n+    ///                          .map(Some)\n+    ///                          .collect::<Vec<Option<&i32>>>();\n+    ///\n+    /// let v_clone = v_orig.clone();\n     ///\n     /// // The no-copy, unsafe way, still using transmute, but not UB.\n     /// // This is equivalent to the original, but safer, and reuses the\n@@ -869,11 +874,12 @@ extern \"rust-intrinsic\" {\n     /// // the original inner type (`&i32`) to the converted inner type\n     /// // (`Option<&i32>`), so read the nomicon pages linked above.\n     /// let v_from_raw = unsafe {\n-    ///     Vec::from_raw_parts(v_orig.as_mut_ptr() as *mut Option<&i32>,\n-    ///                         v_orig.len(),\n-    ///                         v_orig.capacity())\n+    ///     // Ensure the original vector is not dropped.\n+    ///     let mut v_clone = std::mem::ManuallyDrop::new(v_clone);\n+    ///     Vec::from_raw_parts(v_clone.as_mut_ptr() as *mut Option<&i32>,\n+    ///                         v_clone.len(),\n+    ///                         v_clone.capacity())\n     /// };\n-    /// std::mem::forget(v_orig);\n     /// ```\n     ///\n     /// Implementing `split_at_mut`:"}, {"sha": "3b8edc2ad61770aa786c86a4ce6b3b00e77abd06", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 45, "deletions": 10, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,7 +5,7 @@ use crate::usize;\n use crate::intrinsics;\n \n use super::{Iterator, DoubleEndedIterator, ExactSizeIterator, FusedIterator, TrustedLen};\n-use super::LoopState;\n+use super::{LoopState, from_fn};\n \n mod chain;\n mod flatten;\n@@ -66,13 +66,6 @@ impl<I> Iterator for Rev<I> where I: DoubleEndedIterator {\n     {\n         self.iter.rfind(predicate)\n     }\n-\n-    #[inline]\n-    fn rposition<P>(&mut self, predicate: P) -> Option<usize> where\n-        P: FnMut(Self::Item) -> bool\n-    {\n-        self.iter.position(predicate)\n-    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -541,6 +534,26 @@ impl<I> Iterator for StepBy<I> where I: Iterator {\n             self.iter.nth(nth - 1);\n         }\n     }\n+\n+    fn try_fold<Acc, F, R>(&mut self, mut acc: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth<I: Iterator>(iter: &mut I, step: usize) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth(step)\n+        }\n+\n+        if self.first_take {\n+            self.first_take = false;\n+            match self.iter.next() {\n+                None => return Try::from_ok(acc),\n+                Some(x) => acc = f(acc, x)?,\n+            }\n+        }\n+        from_fn(nth(&mut self.iter, self.step)).try_fold(acc, f)\n+    }\n }\n \n impl<I> StepBy<I> where I: ExactSizeIterator {\n@@ -574,6 +587,28 @@ impl<I> DoubleEndedIterator for StepBy<I> where I: DoubleEndedIterator + ExactSi\n             .saturating_add(self.next_back_index());\n         self.iter.nth_back(n)\n     }\n+\n+    fn try_rfold<Acc, F, R>(&mut self, init: Acc, mut f: F) -> R\n+    where\n+        F: FnMut(Acc, Self::Item) -> R,\n+        R: Try<Ok = Acc>,\n+    {\n+        #[inline]\n+        fn nth_back<I: DoubleEndedIterator>(\n+            iter: &mut I,\n+            step: usize,\n+        ) -> impl FnMut() -> Option<I::Item> + '_ {\n+            move || iter.nth_back(step)\n+        }\n+\n+        match self.next_back() {\n+            None => Try::from_ok(init),\n+            Some(x) => {\n+                let acc = f(init, x)?;\n+                from_fn(nth_back(&mut self.iter, self.step)).try_fold(acc, f)\n+            }\n+        }\n+    }\n }\n \n // StepBy can only make the iterator shorter, so the len will still fit.\n@@ -1309,7 +1344,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         Self: Sized, F: FnMut(B, Self::Item) -> R, R: Try<Ok=B>\n     {\n         match self.peeked.take() {\n-            Some(None) => return Try::from_ok(init),\n+            Some(None) => Try::from_ok(init),\n             Some(Some(v)) => match self.iter.try_rfold(init, &mut f).into_result() {\n                 Ok(acc) => f(acc, v),\n                 Err(e) => {\n@@ -1326,7 +1361,7 @@ impl<I> DoubleEndedIterator for Peekable<I> where I: DoubleEndedIterator {\n         where Fold: FnMut(Acc, Self::Item) -> Acc,\n     {\n         match self.peeked {\n-            Some(None) => return init,\n+            Some(None) => init,\n             Some(Some(v)) => {\n                 let acc = self.iter.rfold(init, &mut fold);\n                 fold(acc, v)"}, {"sha": "da49223dfb28510cf950f644540b0ecc56625322", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 200, "deletions": 37, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,4 +1,4 @@\n-use crate::cmp::Ordering;\n+use crate::cmp::{self, Ordering};\n use crate::ops::{Add, Try};\n \n use super::super::LoopState;\n@@ -2223,13 +2223,12 @@ pub trait Iterator {\n             move |x| (f(&x), x)\n         }\n \n-        // switch to y even if it is only equal, to preserve stability.\n         #[inline]\n-        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n-            x_p <= y_p\n+        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {\n+            x_p.cmp(y_p)\n         }\n \n-        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        let (_, x) = self.map(key(f)).max_by(compare)?;\n         Some(x)\n     }\n \n@@ -2252,13 +2251,12 @@ pub trait Iterator {\n     fn max_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        // switch to y even if it is only equal, to preserve stability.\n         #[inline]\n-        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n-            move |x, y| compare(x, y) != Ordering::Greater\n+        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n+            move |x, y| cmp::max_by(x, y, &mut compare)\n         }\n \n-        select_fold1(self, select(compare))\n+        fold1(self, fold(compare))\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2285,13 +2283,12 @@ pub trait Iterator {\n             move |x| (f(&x), x)\n         }\n \n-        // only switch to y if it is strictly smaller, to preserve stability.\n         #[inline]\n-        fn select<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> bool {\n-            x_p > y_p\n+        fn compare<T, B: Ord>((x_p, _): &(B, T), (y_p, _): &(B, T)) -> Ordering {\n+            x_p.cmp(y_p)\n         }\n \n-        let (_, x) = select_fold1(self.map(key(f)), select)?;\n+        let (_, x) = self.map(key(f)).min_by(compare)?;\n         Some(x)\n     }\n \n@@ -2314,13 +2311,12 @@ pub trait Iterator {\n     fn min_by<F>(self, compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        // only switch to y if it is strictly smaller, to preserve stability.\n         #[inline]\n-        fn select<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(&T, &T) -> bool {\n-            move |x, y| compare(x, y) == Ordering::Greater\n+        fn fold<T>(mut compare: impl FnMut(&T, &T) -> Ordering) -> impl FnMut(T, T) -> T {\n+            move |x, y| cmp::min_by(x, y, &mut compare)\n         }\n \n-        select_fold1(self, select(compare))\n+        fold1(self, fold(compare))\n     }\n \n \n@@ -2546,11 +2542,51 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1].iter().cmp([1].iter()), Ordering::Equal);\n+    /// assert_eq!([1].iter().cmp([1, 2].iter()), Ordering::Less);\n+    /// assert_eq!([1, 2].iter().cmp([1].iter()), Ordering::Greater);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn cmp<I>(mut self, other: I) -> Ordering where\n+    fn cmp<I>(self, other: I) -> Ordering\n+    where\n         I: IntoIterator<Item = Self::Item>,\n         Self::Item: Ord,\n         Self: Sized,\n+    {\n+        self.cmp_by(other, |x, y| x.cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| x.cmp(&y)), Ordering::Less);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (x * x).cmp(&y)), Ordering::Equal);\n+    /// assert_eq!(xs.iter().cmp_by(&ys, |&x, &y| (2 * x).cmp(&y)), Ordering::Greater);\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn cmp_by<I, F>(mut self, other: I, mut cmp: F) -> Ordering\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Ordering,\n     {\n         let mut other = other.into_iter();\n \n@@ -2569,7 +2605,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.cmp(&y) {\n+            match cmp(x, y) {\n                 Ordering::Equal => (),\n                 non_eq => return non_eq,\n             }\n@@ -2578,11 +2614,62 @@ pub trait Iterator {\n \n     /// Lexicographically compares the elements of this `Iterator` with those\n     /// of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// assert_eq!([1.].iter().partial_cmp([1.].iter()), Some(Ordering::Equal));\n+    /// assert_eq!([1.].iter().partial_cmp([1., 2.].iter()), Some(Ordering::Less));\n+    /// assert_eq!([1., 2.].iter().partial_cmp([1.].iter()), Some(Ordering::Greater));\n+    ///\n+    /// assert_eq!([std::f64::NAN].iter().partial_cmp([1.].iter()), None);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn partial_cmp<I>(mut self, other: I) -> Option<Ordering> where\n+    fn partial_cmp<I>(self, other: I) -> Option<Ordering>\n+    where\n         I: IntoIterator,\n         Self::Item: PartialOrd<I::Item>,\n         Self: Sized,\n+    {\n+        self.partial_cmp_by(other, |x, y| x.partial_cmp(&y))\n+    }\n+\n+    /// Lexicographically compares the elements of this `Iterator` with those\n+    /// of another with respect to the specified comparison function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// use std::cmp::Ordering;\n+    ///\n+    /// let xs = [1.0, 2.0, 3.0, 4.0];\n+    /// let ys = [1.0, 4.0, 9.0, 16.0];\n+    ///\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| x.partial_cmp(&y)),\n+    ///     Some(Ordering::Less)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (x * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Equal)\n+    /// );\n+    /// assert_eq!(\n+    ///     xs.iter().partial_cmp_by(&ys, |&x, &y| (2.0 * x).partial_cmp(&y)),\n+    ///     Some(Ordering::Greater)\n+    /// );\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn partial_cmp_by<I, F>(mut self, other: I, mut partial_cmp: F) -> Option<Ordering>\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> Option<Ordering>,\n     {\n         let mut other = other.into_iter();\n \n@@ -2601,7 +2688,7 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            match x.partial_cmp(&y) {\n+            match partial_cmp(x, y) {\n                 Some(Ordering::Equal) => (),\n                 non_eq => return non_eq,\n             }\n@@ -2610,11 +2697,44 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are equal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().eq([1].iter()), true);\n+    /// assert_eq!([1].iter().eq([1, 2].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n-    fn eq<I>(mut self, other: I) -> bool where\n+    fn eq<I>(self, other: I) -> bool\n+    where\n         I: IntoIterator,\n         Self::Item: PartialEq<I::Item>,\n         Self: Sized,\n+    {\n+        self.eq_by(other, |x, y| x == y)\n+    }\n+\n+    /// Determines if the elements of this `Iterator` are equal to those of\n+    /// another with respect to the specified equality function.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_order_by)]\n+    ///\n+    /// let xs = [1, 2, 3, 4];\n+    /// let ys = [1, 4, 9, 16];\n+    ///\n+    /// assert!(xs.iter().eq_by(&ys, |&x, &y| x * x == y));\n+    /// ```\n+    #[unstable(feature = \"iter_order_by\", issue = \"0\")]\n+    fn eq_by<I, F>(mut self, other: I, mut eq: F) -> bool\n+    where\n+        Self: Sized,\n+        I: IntoIterator,\n+        F: FnMut(Self::Item, I::Item) -> bool,\n     {\n         let mut other = other.into_iter();\n \n@@ -2629,12 +2749,21 @@ pub trait Iterator {\n                 Some(val) => val,\n             };\n \n-            if x != y { return false }\n+            if !eq(x, y) {\n+                return false;\n+            }\n         }\n     }\n \n     /// Determines if the elements of this `Iterator` are unequal to those of\n     /// another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ne([1].iter()), false);\n+    /// assert_eq!([1].iter().ne([1, 2].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ne<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2646,6 +2775,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().lt([1].iter()), false);\n+    /// assert_eq!([1].iter().lt([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().lt([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn lt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2657,6 +2794,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// less or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().le([1].iter()), true);\n+    /// assert_eq!([1].iter().le([1, 2].iter()), true);\n+    /// assert_eq!([1, 2].iter().le([1].iter()), false);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn le<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2671,6 +2816,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().gt([1].iter()), false);\n+    /// assert_eq!([1].iter().gt([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().gt([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn gt<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2682,6 +2835,14 @@ pub trait Iterator {\n \n     /// Determines if the elements of this `Iterator` are lexicographically\n     /// greater than or equal to those of another.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([1].iter().ge([1].iter()), true);\n+    /// assert_eq!([1].iter().ge([1, 2].iter()), false);\n+    /// assert_eq!([1, 2].iter().ge([1].iter()), true);\n+    /// ```\n     #[stable(feature = \"iter_order\", since = \"1.5.0\")]\n     fn ge<I>(self, other: I) -> bool where\n         I: IntoIterator,\n@@ -2730,6 +2891,18 @@ pub trait Iterator {\n     /// function to determine the ordering of two elements. Apart from that, it's equivalent to\n     /// [`is_sorted`]; see its documentation for more information.\n     ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(is_sorted)]\n+    ///\n+    /// assert!([1, 2, 2, 9].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![1, 3, 2, 4].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!([0].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(std::iter::empty::<i32>().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// assert!(![0.0, 1.0, std::f32::NAN].iter().is_sorted_by(|a, b| a.partial_cmp(b)));\n+    /// ```\n+    ///\n     /// [`is_sorted`]: trait.Iterator.html#method.is_sorted\n     #[unstable(feature = \"is_sorted\", reason = \"new API\", issue = \"53485\")]\n     fn is_sorted_by<F>(mut self, mut compare: F) -> bool\n@@ -2781,28 +2954,18 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"comparison\"\n-/// function.\n-///\n-/// This is an idiosyncratic helper to try to factor out the\n-/// commonalities of {max,min}{,_by}. In particular, this avoids\n-/// having to implement optimizations several times.\n+/// Fold an iterator without having to provide an initial value.\n #[inline]\n-fn select_fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n+fn fold1<I, F>(mut it: I, f: F) -> Option<I::Item>\n     where\n         I: Iterator,\n-        F: FnMut(&I::Item, &I::Item) -> bool,\n+        F: FnMut(I::Item, I::Item) -> I::Item,\n {\n-    #[inline]\n-    fn select<T>(mut f: impl FnMut(&T, &T) -> bool) -> impl FnMut(T, T) -> T {\n-        move |sel, x| if f(&sel, &x) { x } else { sel }\n-    }\n-\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     let first = it.next()?;\n-    Some(it.fold(first, select(f)))\n+    Some(it.fold(first, f))\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "a2cc585fc51fd3ae11a246c7306eb03197b02c41", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -87,7 +87,7 @@\n #![feature(link_llvm_intrinsics)]\n #![feature(never_type)]\n #![feature(nll)]\n-#![feature(bind_by_move_pattern_guards)]\n+#![cfg_attr(boostrap_stdarch_ignore_this, feature(bind_by_move_pattern_guards))]\n #![feature(exhaustive_patterns)]\n #![feature(no_core)]\n #![feature(on_unimplemented)]\n@@ -227,6 +227,7 @@ pub mod task;\n pub mod alloc;\n \n // note: does not need to be public\n+mod bool;\n mod tuple;\n mod unit;\n "}, {"sha": "384bc87499887ad84542a5fd8573e3722b393ff0", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 4, "deletions": 10, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -734,7 +734,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -747,7 +746,6 @@ pub(crate) mod builtin {\n     #[allow_internal_unstable(fmt_internals)]\n     #[rustc_builtin_macro]\n     #[macro_export]\n-    #[rustc_macro_transparency = \"opaque\"]\n     macro_rules! format_args_nl {\n         ($fmt:expr) => ({ /* compiler built-in */ });\n         ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n@@ -1235,42 +1233,38 @@ pub(crate) mod builtin {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a function to turn it into a benchmark test.\n-    #[unstable(feature = \"test\", issue = \"50297\",\n-               reason = \"`bench` is a part of custom test frameworks which are unstable\")]\n+    #[cfg_attr(not(boostrap_stdarch_ignore_this), unstable(soft, feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n+    #[cfg_attr(boostrap_stdarch_ignore_this, unstable(feature = \"test\", issue = \"50297\",\n+               reason = \"`bench` is a part of custom test frameworks which are unstable\"))]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro bench($item:item) { /* compiler built-in */ }\n \n     /// An implementation detail of the `#[test]` and `#[bench]` macros.\n     #[unstable(feature = \"custom_test_frameworks\", issue = \"50297\",\n                reason = \"custom test frameworks are an unstable feature\")]\n     #[allow_internal_unstable(test, rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro test_case($item:item) { /* compiler built-in */ }\n \n     /// Attribute macro applied to a static to register it as a global allocator.\n     #[stable(feature = \"global_allocator\", since = \"1.28.0\")]\n     #[allow_internal_unstable(rustc_attrs)]\n     #[rustc_builtin_macro]\n-    #[rustc_macro_transparency = \"semitransparent\"]\n     pub macro global_allocator($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics, libstd_sys_internals)]\n     pub macro RustcDecodable($item:item) { /* compiler built-in */ }\n \n     /// Unstable implementation detail of the `rustc` compiler, do not use.\n     #[rustc_builtin_macro]\n-    #[cfg_attr(boostrap_stdarch_ignore_this, rustc_macro_transparency = \"semitransparent\")]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[allow_internal_unstable(core_intrinsics)]\n     pub macro RustcEncodable($item:item) { /* compiler built-in */ }"}, {"sha": "347e7dce6e67d242e7a68bf1a63c41917eea250b", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -602,10 +602,10 @@ unsafe impl<T: ?Sized> Freeze for *mut T {}\n unsafe impl<T: ?Sized> Freeze for &T {}\n unsafe impl<T: ?Sized> Freeze for &mut T {}\n \n-/// Types which can be safely moved after being pinned.\n+/// Types that can be safely moved after being pinned.\n ///\n /// Since Rust itself has no notion of immovable types, and considers moves\n-/// (e.g. through assignment or [`mem::replace`]) to always be safe,\n+/// (e.g., through assignment or [`mem::replace`]) to always be safe,\n /// this trait cannot prevent types from moving by itself.\n ///\n /// Instead it is used to prevent moves through the type system,"}, {"sha": "22e7573eca65b28c5693df365dc17af90fa5ed32", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -315,7 +315,7 @@ impl f32 {\n     /// use std::f32;\n     ///\n     /// let x = 2.0_f32;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference <= f32::EPSILON);\n     /// ```"}, {"sha": "bbe1d040780602df44831bab76ff835a01da7898", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -327,7 +327,7 @@ impl f64 {\n     ///\n     /// ```\n     /// let x = 2.0_f64;\n-    /// let abs_difference = (x.recip() - (1.0/x)).abs();\n+    /// let abs_difference = (x.recip() - (1.0 / x)).abs();\n     ///\n     /// assert!(abs_difference < 1e-10);\n     /// ```"}, {"sha": "0cf2ebb487ddd50d7ea8e2c90af3c451ddf46de8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 27, "deletions": 33, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1401,12 +1401,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn wrapping_abs(self) -> Self {\n-                if self.is_negative() {\n-                    self.wrapping_neg()\n-                } else {\n-                    self\n-                }\n+            pub const fn wrapping_abs(self) -> Self {\n+                (self ^ (self >> ($BITS - 1))).wrapping_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1764,12 +1760,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_abs\", since = \"1.13.0\")]\n             #[inline]\n-            pub fn overflowing_abs(self) -> (Self, bool) {\n-                if self.is_negative() {\n-                    self.overflowing_neg()\n-                } else {\n-                    (self, false)\n-                }\n+            pub const fn overflowing_abs(self) -> (Self, bool) {\n+                (self ^ (self >> ($BITS - 1))).overflowing_sub(self >> ($BITS - 1))\n             }\n         }\n \n@@ -1973,15 +1965,11 @@ $EndFeature, \"\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n-            pub fn abs(self) -> Self {\n-                if self.is_negative() {\n-                    // Note that the #[inline] above means that the overflow\n-                    // semantics of this negation depend on the crate we're being\n-                    // inlined into.\n-                    -self\n-                } else {\n-                    self\n-                }\n+            pub const fn abs(self) -> Self {\n+                // Note that the #[inline] above means that the overflow\n+                // semantics of the subtraction depend on the crate we're being\n+                // inlined into.\n+                (self ^ (self >> ($BITS - 1))) - (self >> ($BITS - 1))\n             }\n         }\n \n@@ -2104,11 +2092,14 @@ $to_xe_bytes_doc,\n \n ```\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n-assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n-    });\n+    }\n+);\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -2200,10 +2191,10 @@ $from_xe_bytes_doc,\n \n ```\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n-        \", $be_bytes, \"\n-    } else {\n-        \", $le_bytes, \"\n-    });\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n assert_eq!(value, \", $swap_op, \");\n ```\n \n@@ -3923,11 +3914,14 @@ $to_xe_bytes_doc,\n \n ```\n let bytes = \", $swap_op, stringify!($SelfT), \".to_ne_bytes();\n-assert_eq!(bytes, if cfg!(target_endian = \\\"big\\\") {\n+assert_eq!(\n+    bytes,\n+    if cfg!(target_endian = \\\"big\\\") {\n         \", $be_bytes, \"\n     } else {\n         \", $le_bytes, \"\n-    });\n+    }\n+);\n ```\"),\n             #[stable(feature = \"int_to_from_bytes\", since = \"1.32.0\")]\n             #[rustc_const_unstable(feature = \"const_int_conversion\")]\n@@ -4019,10 +4013,10 @@ $from_xe_bytes_doc,\n \n ```\n let value = \", stringify!($SelfT), \"::from_ne_bytes(if cfg!(target_endian = \\\"big\\\") {\n-        \", $be_bytes, \"\n-    } else {\n-        \", $le_bytes, \"\n-    });\n+    \", $be_bytes, \"\n+} else {\n+    \", $le_bytes, \"\n+});\n assert_eq!(value, \", $swap_op, \");\n ```\n "}, {"sha": "59a10ae99bb6aa5bff9c66a5ebe3b2520a22a807", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -18,6 +18,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -41,6 +43,8 @@ macro_rules! sh_impl_signed {\n                 }\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {\n@@ -64,6 +68,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shl((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shl, shl for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShlAssign<$f> for Wrapping<$t> {\n@@ -83,6 +89,8 @@ macro_rules! sh_impl_unsigned {\n                 Wrapping(self.0.wrapping_shr((other & self::shift_max::$t as $f) as u32))\n             }\n         }\n+        forward_ref_binop! { impl Shr, shr for Wrapping<$t>, $f,\n+                #[stable(feature = \"wrapping_ref_ops\", since = \"1.39.0\")] }\n \n         #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n         impl ShrAssign<$f> for Wrapping<$t> {"}, {"sha": "4a0a2720fe44161116254e719ffc8403423606bf", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -185,14 +185,6 @@ pub trait FnMut<Args> : FnOnce<Args> {\n ///\n /// # Examples\n ///\n-/// ## Calling a by-value closure\n-///\n-/// ```\n-/// let x = 5;\n-/// let square_x = move || x * x;\n-/// assert_eq!(square_x(), 25);\n-/// ```\n-///\n /// ## Using a `FnOnce` parameter\n ///\n /// ```"}, {"sha": "5569d99f8d81ddfe310210ac76b89dfe1bbd9c68", "filename": "src/libcore/option.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -295,7 +295,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_ref<'a>(self: Pin<&'a Option<T>>) -> Option<Pin<&'a T>> {\n+    pub fn as_pin_ref(self: Pin<&Self>) -> Option<Pin<&T>> {\n         unsafe {\n             Pin::get_ref(self).as_ref().map(|x| Pin::new_unchecked(x))\n         }\n@@ -306,7 +306,7 @@ impl<T> Option<T> {\n     /// [`Pin`]: ../pin/struct.Pin.html\n     #[inline]\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub fn as_pin_mut<'a>(self: Pin<&'a mut Option<T>>) -> Option<Pin<&'a mut T>> {\n+    pub fn as_pin_mut(self: Pin<&mut Self>) -> Option<Pin<&mut T>> {\n         unsafe {\n             Pin::get_unchecked_mut(self).as_mut().map(|x| Pin::new_unchecked(x))\n         }\n@@ -1110,6 +1110,18 @@ impl<T: Deref> Option<T> {\n     /// to the original one, additionally coercing the contents via [`Deref`].\n     ///\n     /// [`Deref`]: ../../std/ops/trait.Deref.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref(), Some(\"hey\"));\n+    ///\n+    /// let x: Option<String> = None;\n+    /// assert_eq!(x.as_deref(), None);\n+    /// ```\n     pub fn as_deref(&self) -> Option<&T::Target> {\n         self.as_ref().map(|t| t.deref())\n     }\n@@ -1121,6 +1133,18 @@ impl<T: DerefMut> Option<T> {\n     ///\n     /// Leaves the original `Option` in-place, creating a new one containing a mutable reference to\n     /// the inner type's `Deref::Target` type.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(inner_deref)]\n+    ///\n+    /// let mut x: Option<String> = Some(\"hey\".to_owned());\n+    /// assert_eq!(x.as_deref_mut().map(|x| {\n+    ///     x.make_ascii_uppercase();\n+    ///     x\n+    /// }), Some(\"HEY\".to_owned().as_mut_str()));\n+    /// ```\n     pub fn as_deref_mut(&mut self) -> Option<&mut T::Target> {\n         self.as_mut().map(|t| t.deref_mut())\n     }\n@@ -1199,6 +1223,13 @@ impl<T: Clone> Clone for Option<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T> Default for Option<T> {\n     /// Returns [`None`][Option::None].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// let opt: Option<u32> = Option::default();\n+    /// assert!(opt.is_none());\n+    /// ```\n     #[inline]\n     fn default() -> Option<T> { None }\n }"}, {"sha": "3d2bc24bf24a5dc35e54f9e58ec1eae895e415f7", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -71,7 +71,7 @@ pub fn panic_fmt(fmt: fmt::Arguments<'_>, file_line_col: &(&'static str, u32, u3\n     }\n \n     // NOTE This function never crosses the FFI boundary; it's a Rust-to-Rust call\n-    #[allow(improper_ctypes)] // PanicInfo contains a trait object which is not FFI safe\n+    #[cfg_attr(boostrap_stdarch_ignore_this, allow(improper_ctypes))]\n     extern \"Rust\" {\n         #[lang = \"panic_impl\"]\n         fn panic_impl(pi: &PanicInfo<'_>) -> !;"}, {"sha": "1dc6d54b08a5aa7700a48f674487bbf1d89755b8", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -233,7 +233,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> &'a mut Field {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> &mut Field {\n //!         // This is okay because `field` is never considered pinned.\n //!         unsafe { &mut self.get_unchecked_mut().field }\n //!     }\n@@ -257,7 +257,7 @@\n //! # type Field = i32;\n //! # struct Struct { field: Field }\n //! impl Struct {\n-//!     fn pin_get_field<'a>(self: Pin<&'a mut Self>) -> Pin<&'a mut Field> {\n+//!     fn pin_get_field(self: Pin<&mut Self>) -> Pin<&mut Field> {\n //!         // This is okay because `field` is pinned when `self` is.\n //!         unsafe { self.map_unchecked_mut(|s| &mut s.field) }\n //!     }\n@@ -462,7 +462,7 @@ impl<P: Deref<Target: Unpin>> Pin<P> {\n     /// can ignore the pinning invariants when unwrapping it.\n     ///\n     /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n-    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n     pub fn into_inner(pin: Pin<P>) -> P {\n         pin.pointer\n@@ -549,7 +549,7 @@ impl<P: Deref> Pin<P> {\n     /// ruled out by the contract of `Pin::new_unchecked`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_ref(self: &Pin<P>) -> Pin<&P::Target> {\n+    pub fn as_ref(&self) -> Pin<&P::Target> {\n         unsafe { Pin::new_unchecked(&*self.pointer) }\n     }\n \n@@ -569,7 +569,7 @@ impl<P: Deref> Pin<P> {\n     ///\n     /// [`Unpin`]: ../../std/marker/trait.Unpin.html\n     /// [`Pin::into_inner`]: #method.into_inner\n-    #[unstable(feature = \"pin_into_inner\", issue = \"60245\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n     pub unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n         pin.pointer\n@@ -584,9 +584,30 @@ impl<P: DerefMut> Pin<P> {\n     /// the pointee cannot move after `Pin<Pointer<T>>` got created.\n     /// \"Malicious\" implementations of `Pointer::DerefMut` are likewise\n     /// ruled out by the contract of `Pin::new_unchecked`.\n+    ///\n+    /// This method is useful when doing multiple calls to functions that consume the pinned type.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// use std::pin::Pin;\n+    ///\n+    /// # struct Type {}\n+    /// impl Type {\n+    ///     fn method(self: Pin<&mut Self>) {\n+    ///         // do something\n+    ///     }\n+    ///\n+    ///     fn call_method_twice(mut self: Pin<&mut Self>) {\n+    ///         // `method` consumes `self`, so reborrow the `Pin<&mut Self>` via `as_mut`.\n+    ///         self.as_mut().method();\n+    ///         self.as_mut().method();\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn as_mut(self: &mut Pin<P>) -> Pin<&mut P::Target> {\n+    pub fn as_mut(&mut self) -> Pin<&mut P::Target> {\n         unsafe { Pin::new_unchecked(&mut *self.pointer) }\n     }\n \n@@ -596,7 +617,7 @@ impl<P: DerefMut> Pin<P> {\n     /// run before being overwritten, so no pinning guarantee is violated.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn set(self: &mut Pin<P>, value: P::Target)\n+    pub fn set(&mut self, value: P::Target)\n     where\n         P::Target: Sized,\n     {\n@@ -621,7 +642,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked<U, F>(self: Pin<&'a T>, func: F) -> Pin<&'a U> where\n+    pub unsafe fn map_unchecked<U, F>(self, func: F) -> Pin<&'a U> where\n         F: FnOnce(&T) -> &U,\n     {\n         let pointer = &*self.pointer;\n@@ -648,7 +669,7 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// [\"pinning projections\"]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_ref(self: Pin<&'a T>) -> &'a T {\n+    pub fn get_ref(self) -> &'a T {\n         self.pointer\n     }\n }\n@@ -657,7 +678,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn into_ref(self: Pin<&'a mut T>) -> Pin<&'a T> {\n+    pub fn into_ref(self) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n@@ -672,7 +693,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// with the same lifetime as the original `Pin`.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_mut(self: Pin<&'a mut T>) -> &'a mut T\n+    pub fn get_mut(self) -> &'a mut T\n         where T: Unpin,\n     {\n         self.pointer\n@@ -690,7 +711,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// instead.\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn get_unchecked_mut(self: Pin<&'a mut T>) -> &'a mut T {\n+    pub unsafe fn get_unchecked_mut(self) -> &'a mut T {\n         self.pointer\n     }\n \n@@ -710,7 +731,7 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// [`pin` module]: ../../std/pin/index.html#projections-and-structural-pinning\n     #[stable(feature = \"pin\", since = \"1.33.0\")]\n-    pub unsafe fn map_unchecked_mut<U, F>(self: Pin<&'a mut T>, func: F) -> Pin<&'a mut U> where\n+    pub unsafe fn map_unchecked_mut<U, F>(self, func: F) -> Pin<&'a mut U> where\n         F: FnOnce(&mut T) -> &mut U,\n     {\n         let pointer = Pin::get_unchecked_mut(self);"}, {"sha": "13ccc9b252a775cbf82564e5b7ca1e21184d1fd1", "filename": "src/libcore/ptr/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1042,7 +1042,7 @@ impl<T: ?Sized> *const T {\n         (self as *const u8) == null()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *const U {\n@@ -1726,7 +1726,7 @@ impl<T: ?Sized> *mut T {\n         (self as *mut u8) == null_mut()\n     }\n \n-    /// Cast to a pointer to a different type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"ptr_cast\", since = \"1.38.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> *mut U {"}, {"sha": "7dcd57f1f985888e9c109fd5fa8c6c3ae6305d1f", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -125,7 +125,7 @@ impl<T: ?Sized> NonNull<T> {\n         &mut *self.as_ptr()\n     }\n \n-    /// Cast to a pointer of another type\n+    /// Casts to a pointer of another type.\n     #[stable(feature = \"nonnull_cast\", since = \"1.27.0\")]\n     #[inline]\n     pub const fn cast<U>(self) -> NonNull<U> {"}, {"sha": "ed40a5f31d9bd75105b25c289407e86d62b2516d", "filename": "src/libcore/result.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -820,6 +820,87 @@ impl<T, E> Result<T, E> {\n     }\n }\n \n+impl<T: Copy, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_copied)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E> {\n+        self.map(|&t| t)\n+    }\n+}\n+\n+impl<T: Copy, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by copying the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_copied)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let copied = x.copied();\n+    /// assert_eq!(copied, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_copied\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn copied(self) -> Result<T, E> {\n+        self.map(|&mut t| t)\n+    }\n+}\n+\n+impl<T: Clone, E> Result<&T, E> {\n+    /// Maps a `Result<&T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_cloned)]\n+    /// let val = 12;\n+    /// let x: Result<&i32, i32> = Ok(&val);\n+    /// assert_eq!(x, Ok(&12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E> {\n+        self.map(|t| t.clone())\n+    }\n+}\n+\n+impl<T: Clone, E> Result<&mut T, E> {\n+    /// Maps a `Result<&mut T, E>` to a `Result<T, E>` by cloning the contents of the\n+    /// `Ok` part.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_cloned)]\n+    /// let mut val = 12;\n+    /// let x: Result<&mut i32, i32> = Ok(&mut val);\n+    /// assert_eq!(x, Ok(&mut 12));\n+    /// let cloned = x.cloned();\n+    /// assert_eq!(cloned, Ok(12));\n+    /// ```\n+    #[unstable(feature = \"result_cloned\", reason = \"newly added\", issue = \"63168\")]\n+    pub fn cloned(self) -> Result<T, E> {\n+        self.map(|t| t.clone())\n+    }\n+}\n+\n+\n impl<T, E: fmt::Debug> Result<T, E> {\n     /// Unwraps a result, yielding the content of an [`Ok`].\n     ///"}, {"sha": "931768564ca3cf8c5a34fca6a14e376567c4f1eb", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -3026,8 +3026,7 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            let diff = ($self.end as usize).wrapping_sub(start as usize);\n-            diff\n+            ($self.end as usize).wrapping_sub(start as usize)\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here"}, {"sha": "5e5b5593fd8a7d19fa949d5ab2a9cbe8c19f7033", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -2170,6 +2170,7 @@ impl str {\n     #[inline(always)]\n     #[rustc_const_unstable(feature=\"const_str_as_bytes\")]\n     pub const fn as_bytes(&self) -> &[u8] {\n+        #[repr(C)]\n         union Slices<'a> {\n             str: &'a str,\n             slice: &'a [u8],\n@@ -3557,7 +3558,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3594,7 +3595,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///\n@@ -3761,7 +3762,7 @@ impl str {\n     /// A string is a sequence of bytes. `start` in this context means the first\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be left side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the right side.\n+    /// Arabic or Hebrew, this will be the right side.\n     ///\n     /// # Examples\n     ///\n@@ -3800,7 +3801,7 @@ impl str {\n     /// A string is a sequence of bytes. `end` in this context means the last\n     /// position of that byte string; for a left-to-right language like English or\n     /// Russian, this will be right side, and for right-to-left languages like\n-    /// like Arabic or Hebrew, this will be the left side.\n+    /// Arabic or Hebrew, this will be the left side.\n     ///\n     /// # Examples\n     ///"}, {"sha": "c9ccef972c2b5faabdabf7f55a79c4378d180a9e", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -124,28 +124,31 @@ use crate::fmt;\n \n use crate::hint::spin_loop;\n \n-/// Signals the processor that it is entering a busy-wait spin-loop.\n+/// Signals the processor that it is inside a busy-wait spin-loop (\"spin lock\").\n ///\n /// Upon receiving spin-loop signal the processor can optimize its behavior by, for example, saving\n /// power or switching hyper-threads.\n ///\n-/// This function is different than [`std::thread::yield_now`] which directly yields to the\n-/// system's scheduler, whereas `spin_loop_hint` only signals the processor that it is entering a\n-/// busy-wait spin-loop without yielding control to the system's scheduler.\n+/// This function is different from [`std::thread::yield_now`] which directly yields to the\n+/// system's scheduler, whereas `spin_loop_hint` does not interact with the operating system.\n ///\n-/// Using a busy-wait spin-loop with `spin_loop_hint` is ideally used in situations where a\n-/// contended lock is held by another thread executed on a different CPU and where the waiting\n-/// times are relatively small. Because entering busy-wait spin-loop does not trigger the system's\n-/// scheduler, no overhead for switching threads occurs. However, if the thread holding the\n-/// contended lock is running on the same CPU, the spin-loop is likely to occupy an entire CPU slice\n-/// before switching to the thread that holds the lock. If the contending lock is held by a thread\n-/// on the same CPU or if the waiting times for acquiring the lock are longer, it is often better to\n-/// use [`std::thread::yield_now`].\n+/// Spin locks can be very efficient for short lock durations because they do not involve context\n+/// switches or interaction with the operating system. For long lock durations they become wasteful\n+/// however because they use CPU cycles for the entire lock duration, and using a\n+/// [`std::sync::Mutex`] is likely the better approach. If actively spinning for a long time is\n+/// required, e.g. because code polls a non-blocking API, calling [`std::thread::yield_now`]\n+/// or [`std::thread::sleep`] may be the best option.\n+///\n+/// **Note**: Spin locks are based on the underlying assumption that another thread will release\n+/// the lock 'soon'. In order for this to work, that other thread must run on a different CPU or\n+/// core (at least potentially). Spin locks do not work efficiently on single CPU / core platforms.\n ///\n /// **Note**: On platforms that do not support receiving spin-loop hints this function does not\n /// do anything at all.\n ///\n /// [`std::thread::yield_now`]: ../../../std/thread/fn.yield_now.html\n+/// [`std::thread::sleep`]: ../../../std/thread/fn.sleep.html\n+/// [`std::sync::Mutex`]: ../../../std/sync/struct.Mutex.html\n #[inline]\n #[stable(feature = \"spin_loop_hint\", since = \"1.24.0\")]\n pub fn spin_loop_hint() {\n@@ -979,9 +982,8 @@ impl<T> AtomicPtr<T> {\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let other_ptr   = &mut 10;\n-    /// let another_ptr = &mut 10;\n     ///\n-    /// let value = some_ptr.compare_and_swap(other_ptr, another_ptr, Ordering::Relaxed);\n+    /// let value = some_ptr.compare_and_swap(ptr, other_ptr, Ordering::Relaxed);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1021,9 +1023,8 @@ impl<T> AtomicPtr<T> {\n     /// let some_ptr  = AtomicPtr::new(ptr);\n     ///\n     /// let other_ptr   = &mut 10;\n-    /// let another_ptr = &mut 10;\n     ///\n-    /// let value = some_ptr.compare_exchange(other_ptr, another_ptr,\n+    /// let value = some_ptr.compare_exchange(ptr, other_ptr,\n     ///                                       Ordering::SeqCst, Ordering::Relaxed);\n     /// ```\n     #[inline]"}, {"sha": "0f1e6e89451e9b4294a6aad180c3250e623f2122", "filename": "src/libcore/tests/bool.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fbool.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -0,0 +1,7 @@\n+#[test]\n+fn test_bool_to_option() {\n+    assert_eq!(false.then(0), None);\n+    assert_eq!(true.then(0), Some(0));\n+    assert_eq!(false.then_with(|| 0), None);\n+    assert_eq!(true.then_with(|| 0), Some(0));\n+}"}, {"sha": "5e6778e222a291a3f17843aaede8c12e23902fa6", "filename": "src/libcore/tests/cmp.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fcmp.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,4 +1,4 @@\n-use core::cmp::Ordering::{Less, Greater, Equal};\n+use core::cmp::{self, Ordering::*};\n \n #[test]\n fn test_int_totalord() {\n@@ -28,6 +28,28 @@ fn test_ord_max_min() {\n     assert_eq!(1.min(1), 1);\n }\n \n+#[test]\n+fn test_ord_min_max_by() {\n+    let f = |x: &i32, y: &i32| x.abs().cmp(&y.abs());\n+    assert_eq!(cmp::min_by(1, -1, f), 1);\n+    assert_eq!(cmp::min_by(1, -2, f), 1);\n+    assert_eq!(cmp::min_by(2, -1, f), -1);\n+    assert_eq!(cmp::max_by(1, -1, f), -1);\n+    assert_eq!(cmp::max_by(1, -2, f), -2);\n+    assert_eq!(cmp::max_by(2, -1, f), 2);\n+}\n+\n+#[test]\n+fn test_ord_min_max_by_key() {\n+    let f = |x: &i32| x.abs();\n+    assert_eq!(cmp::min_by_key(1, -1, f), 1);\n+    assert_eq!(cmp::min_by_key(1, -2, f), 1);\n+    assert_eq!(cmp::min_by_key(2, -1, f), -1);\n+    assert_eq!(cmp::max_by_key(1, -1, f), -1);\n+    assert_eq!(cmp::max_by_key(1, -2, f), -2);\n+    assert_eq!(cmp::max_by_key(2, -1, f), 2);\n+}\n+\n #[test]\n fn test_ordering_reverse() {\n     assert_eq!(Less.reverse(), Greater);"}, {"sha": "c9096b713f20ec42b532913a6eba398888140b4e", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -57,6 +57,62 @@ fn test_multi_iter() {\n     assert!(xs.iter().lt(xs.iter().skip(2)));\n }\n \n+#[test]\n+fn test_cmp_by() {\n+    use core::cmp::Ordering;\n+\n+    let f = |x: i32, y: i32| (x * x).cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().cmp_by(ys(), f), Ordering::Less);\n+    assert_eq!(ys().cmp_by(xs(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(xs().map(|x| x * x), f), Ordering::Equal);\n+    assert_eq!(xs().rev().cmp_by(ys().rev(), f), Ordering::Greater);\n+    assert_eq!(xs().cmp_by(ys().rev(), f), Ordering::Less);\n+    assert_eq!(xs().cmp_by(ys().take(2), f), Ordering::Greater);\n+}\n+\n+#[test]\n+fn test_partial_cmp_by() {\n+    use core::cmp::Ordering;\n+    use core::f64;\n+\n+    let f = |x: i32, y: i32| (x * x).partial_cmp(&y);\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 16].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), Some(Ordering::Less));\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().map(|x| x * x), f), Some(Ordering::Equal));\n+    assert_eq!(xs().rev().partial_cmp_by(ys().rev(), f), Some(Ordering::Greater));\n+    assert_eq!(xs().partial_cmp_by(xs().rev(), f), Some(Ordering::Less));\n+    assert_eq!(xs().partial_cmp_by(ys().take(2), f), Some(Ordering::Greater));\n+\n+    let f = |x: f64, y: f64| (x * x).partial_cmp(&y);\n+    let xs = || [1.0, 2.0, 3.0, 4.0].iter().copied();\n+    let ys = || [1.0, 4.0, f64::NAN, 16.0].iter().copied();\n+\n+    assert_eq!(xs().partial_cmp_by(ys(), f), None);\n+    assert_eq!(ys().partial_cmp_by(xs(), f), Some(Ordering::Greater));\n+}\n+\n+#[test]\n+fn test_eq_by() {\n+    let f = |x: i32, y: i32| x * x == y;\n+    let xs = || [1, 2, 3, 4].iter().copied();\n+    let ys = || [1, 4, 9, 16].iter().copied();\n+\n+    assert!(xs().eq_by(ys(), f));\n+    assert!(!ys().eq_by(xs(), f));\n+    assert!(!xs().eq_by(xs(), f));\n+    assert!(!ys().eq_by(ys(), f));\n+\n+    assert!(!xs().take(3).eq_by(ys(), f));\n+    assert!(!xs().eq_by(ys().take(3), f));\n+    assert!(xs().take(3).eq_by(ys().take(3), f));\n+}\n+\n #[test]\n fn test_counter_from_iter() {\n     let it = (0..).step_by(5).take(10);\n@@ -329,6 +385,23 @@ fn test_iterator_step_by_nth_overflow() {\n     assert_eq!(it.0, (usize::MAX as Bigger) * 1);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_fold() {\n+    let mut it = (0..).step_by(10);\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(60));\n+    assert_eq!(it.try_fold(0, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(90));\n+\n+    let mut it = (100..).step_by(10);\n+    assert_eq!(it.try_fold(50, i8::checked_add), None);\n+    assert_eq!(it.next(), Some(110));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n fn test_iterator_step_by_nth_back() {\n     let mut it = (0..16).step_by(5);\n@@ -354,6 +427,24 @@ fn test_iterator_step_by_nth_back() {\n     assert_eq!(it().nth_back(42), None);\n }\n \n+#[test]\n+fn test_iterator_step_by_nth_try_rfold() {\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(70));\n+    assert_eq!(it.next(), Some(0));\n+    assert_eq!(it.try_rfold(0, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(30));\n+\n+    let mut it = (0..100).step_by(10);\n+    assert_eq!(it.try_rfold(50, i8::checked_add), None);\n+    assert_eq!(it.next_back(), Some(80));\n+\n+    let mut it = (100..=100).step_by(10);\n+    assert_eq!(it.next_back(), Some(100));\n+    assert_eq!(it.try_fold(0, i8::checked_add), Some(0));\n+}\n+\n #[test]\n #[should_panic]\n fn test_iterator_step_by_zero() {\n@@ -1688,6 +1779,12 @@ fn test_rposition() {\n     assert!(v.iter().rposition(g).is_none());\n }\n \n+#[test]\n+fn test_rev_rposition() {\n+    let v = [0, 0, 1, 1];\n+    assert_eq!(v.iter().rev().rposition(|&x| x == 1), Some(1));\n+}\n+\n #[test]\n #[should_panic]\n fn test_rposition_panic() {"}, {"sha": "35661356028cbf2b861c0cdeac28dd2253e5ffdd", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,3 +1,4 @@\n+#![feature(bool_to_option)]\n #![feature(bound_cloned)]\n #![feature(box_syntax)]\n #![feature(cell_update)]\n@@ -32,6 +33,8 @@\n #![feature(const_fn)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_is_partitioned)]\n+#![feature(iter_order_by)]\n+#![feature(cmp_min_max_by)]\n \n extern crate test;\n \n@@ -40,6 +43,7 @@ mod any;\n mod array;\n mod ascii;\n mod atomic;\n+mod bool;\n mod cell;\n mod char;\n mod clone;"}, {"sha": "a3ec9fd51f064cb90b5d325221bba48b313487a5", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -13,8 +13,3 @@ pub mod derived_property {\n pub mod conversions {\n     pub use crate::unicode::tables::conversions::{to_lower, to_upper};\n }\n-\n-// For use in libsyntax\n-pub mod property {\n-    pub use crate::unicode::tables::property::Pattern_White_Space;\n-}"}, {"sha": "4e8b4ecad0200c9a7afcf2dadbacbc57286f5b40", "filename": "src/libcore/unicode/printable.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Fprintable.py", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Fprintable.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fprintable.py?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -60,7 +60,7 @@ def get_codepoints(f):\n         yield Codepoint(codepoint, class_)\n         prev_codepoint = codepoint\n \n-    if class_first != None:\n+    if class_first is not None:\n         raise ValueError(\"Missing Last after First\")\n \n     for c in range(prev_codepoint + 1, NUM_CODEPOINTS):"}, {"sha": "5b5be485431217849a1c4e87e0fb98467d01cd04", "filename": "src/libcore/unicode/tables.rs", "status": "modified", "additions": 0, "deletions": 375, "changes": 375, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Ftables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Ftables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Ftables.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -890,384 +890,9 @@ pub(crate) mod derived_property {\n         Uppercase_table.lookup(c)\n     }\n \n-    const XID_Continue_table: &super::BoolTrie = &super::BoolTrie {\n-        r1: [\n-            0x03ff000000000000, 0x07fffffe87fffffe, 0x04a0040000000000, 0xff7fffffff7fffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n-            0xffffffffffffffff, 0xb8dfffffffffffff, 0xfffffffbffffd7c0, 0xffbfffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffcfb, 0xffffffffffffffff,\n-            0xfffeffffffffffff, 0xffffffff027fffff, 0xbffffffffffe01ff, 0x000787ffffff00b6,\n-            0xffffffff07ff0000, 0xffffc3ffffffffff, 0xffffffffffffffff, 0x9ffffdff9fefffff,\n-            0xffffffffffff0000, 0xffffffffffffe7ff, 0x0003ffffffffffff, 0x243fffffffffffff\n-        ],\n-        r2: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 25, 26, 27, 28, 29, 30, 31, 4, 32, 33, 34, 4, 4, 4, 4, 4, 35, 36, 37, 38, 39, 40,\n-            41, 42, 4, 4, 4, 4, 4, 4, 4, 4, 43, 44, 45, 46, 47, 4, 48, 49, 50, 51, 52, 53, 54, 55,\n-            56, 57, 58, 59, 60, 4, 61, 4, 62, 63, 64, 65, 66, 4, 4, 4, 67, 4, 4, 4, 4, 68, 69, 70,\n-            71, 72, 73, 74, 75, 76, 77, 78, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 79, 80, 4, 81, 82, 83, 84, 85, 60, 60, 60, 60, 60, 60, 60, 60, 86,\n-            42, 87, 88, 89, 4, 90, 91, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 52, 60, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 92, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 93, 94, 4, 4, 4, 4, 95, 96, 4, 97, 98, 4, 99, 100, 101, 62, 4, 102, 103,\n-            104, 4, 105, 106, 107, 4, 108, 109, 110, 4, 111, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 112, 113, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60,\n-            60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 60, 4, 4, 4, 4, 4, 103, 4, 114,\n-            115, 116, 97, 117, 4, 118, 4, 4, 119, 120, 121, 122, 123, 124, 4, 125, 126, 127, 128,\n-            129\n-        ],\n-        r3: &[\n-            0x00003fffffffffff, 0x000007ff0fffffff, 0x3fdfffff00000000, 0xfffffffbfff80000,\n-            0xffffffffffffffff, 0xfffeffcfffffffff, 0xf3c5fdfffff99fef, 0x5003ffcfb080799f,\n-            0xd36dfdfffff987ee, 0x003fffc05e023987, 0xf3edfdfffffbbfee, 0xfe00ffcf00013bbf,\n-            0xf3edfdfffff99fee, 0x0002ffcfb0c0399f, 0xc3ffc718d63dc7ec, 0x0000ffc000813dc7,\n-            0xe3fffdfffffddfff, 0x0000ffcf07603ddf, 0xf3effdfffffddfef, 0x0006ffcf40603ddf,\n-            0xfffffffffffddfef, 0xfc00ffcf80f07ddf, 0x2ffbfffffc7fffec, 0x000cffc0ff5f847f,\n-            0x07fffffffffffffe, 0x0000000003ff7fff, 0x3fffffaffffff7d6, 0x00000000f3ff3f5f,\n-            0xc2a003ff03000001, 0xfffe1ffffffffeff, 0x1ffffffffeffffdf, 0x0000000000000040,\n-            0xffffffffffff03ff, 0xffffffff3fffffff, 0xf7ffffffffff20bf, 0xffffffff3d7f3dff,\n-            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0003fe00e7ffffff,\n-            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n-            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x001fffff001fdfff, 0x000ddfff000fffff,\n-            0x000003ff308fffff, 0xffffffff03ff3800, 0x01ffffffffffffff, 0xffff07ffffffffff,\n-            0x003fffffffffffff, 0x0fff0fff7fffffff, 0x001f3fffffffffc0, 0xffff0fffffffffff,\n-            0x0000000007ff03ff, 0xffffffff0fffffff, 0x9fffffff7fffffff, 0x3fff008003ff03ff,\n-            0x0000000000000000, 0x000ff80003ff0fff, 0x000fffffffffffff, 0x00ffffffffffffff,\n-            0x3fffffffffffe3ff, 0xe7ffffffffff01ff, 0x07fffffffff70000, 0xfbffffffffffffff,\n-            0xffffffff3f3fffff, 0x3fffffffaaff3f3f, 0x5fdfffffffffffff, 0x1fdc1fff0fcf1fdc,\n-            0x8000000000000000, 0x8002000000100001, 0x000000001fff0000, 0x0001ffe21fff0000,\n-            0xf3fffd503f2ffc84, 0xffffffff000043e0, 0x00000000000001ff, 0xffff7fffffffffff,\n-            0xffffffff7fffffff, 0x000ff81fffffffff, 0xffff20bfffffffff, 0x800080ffffffffff,\n-            0x7f7f7f7f007fffff, 0xffffffff7f7f7f7f, 0x1f3efffe000000e0, 0xfffffffee67fffff,\n-            0xf7ffffffffffffff, 0xfffeffffffffffe0, 0x07ffffff00007fff, 0xffff000000000000,\n-            0x0000ffffffffffff, 0x0000000000001fff, 0x3fffffffffff0000, 0x00000fffffff1fff,\n-            0xbff0ffffffffffff, 0x0003ffffffffffff, 0xfffffffcff800000, 0xfffffffffffff9ff,\n-            0xff8000000000007c, 0x000000ffffffffff, 0xe8ffffff03ff003f, 0xffff3fffffffffff,\n-            0x1fffffff000fffff, 0x7fffffff03ff8001, 0x007fffffffffffff, 0xfc7fffff03ff3fff,\n-            0x007cffff38000007, 0xffff7f7f007e7e7e, 0xffff00fff7ffffff, 0x03ff37ffffffffff,\n-            0xffff000fffffffff, 0x0ffffffffffff87f, 0x0000000003ffffff, 0x5f7ffdffe0f8007f,\n-            0xffffffffffffffdb, 0xfffffffffff80000, 0xfffffff03fffffff, 0x3fffffffffffffff,\n-            0xffffffffffff0000, 0xfffffffffffcffff, 0x03ff0000000000ff, 0x0018ffff0000ffff,\n-            0xaa8a00000000e000, 0x1fffffffffffffff, 0x87fffffe03ff0000, 0xffffffc007fffffe,\n-            0x7fffffffffffffff, 0x000000001cfcfcfc\n-        ],\n-        r4: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 17, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n-        ],\n-        r5: &[\n-            0, 1, 2, 3, 4, 5, 4, 6, 4, 4, 7, 8, 9, 10, 11, 12, 2, 2, 13, 14, 15, 16, 4, 4, 2, 2, 2,\n-            2, 17, 18, 4, 4, 19, 20, 21, 22, 23, 4, 24, 4, 25, 26, 27, 28, 29, 30, 31, 4, 2, 32, 33,\n-            33, 34, 4, 4, 4, 4, 4, 4, 4, 35, 36, 4, 37, 2, 38, 3, 39, 40, 41, 2, 42, 43, 4, 44, 45,\n-            46, 47, 4, 4, 2, 48, 2, 49, 4, 4, 50, 51, 2, 52, 53, 54, 55, 4, 4, 4, 3, 4, 56, 57, 4,\n-            4, 58, 59, 60, 61, 62, 53, 4, 4, 4, 4, 63, 64, 65, 4, 66, 67, 68, 4, 4, 4, 4, 37, 4, 4,\n-            4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 69, 4, 2, 70, 2, 2, 2, 71, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 70, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 72, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 2, 2, 2, 2, 2, 2, 2, 53, 73, 4, 74, 17, 75, 76, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2,\n-            4, 4, 2, 77, 78, 79, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 80, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 33, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 21, 81, 2, 2, 2, 2,\n-            2, 82, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 83, 84, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 85, 86, 4, 4, 87, 4, 4, 4, 4, 4, 4, 2, 88, 89, 90, 91, 92, 2, 2, 2, 2, 93, 94, 95,\n-            96, 97, 98, 4, 4, 4, 4, 4, 4, 4, 4, 99, 100, 101, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 102, 4, 4, 4, 103, 104, 4, 4, 4, 4, 4, 105, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 106, 2, 107, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 108, 109, 110, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 111, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 11,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 112, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 113, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 114, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 115, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n-        ],\n-        r6: &[\n-            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n-            0x0000000000000000, 0x001fffffffffffff, 0x2000000000000000, 0xffffffff1fffffff,\n-            0x000000010001ffff, 0xffffe000ffffffff, 0x07ffffffffff07ff, 0xffffffff3fffffff,\n-            0x00000000003eff0f, 0xffff03ff3fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff,\n-            0x0000000fffffffff, 0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f,\n-            0x007fffff003fffff, 0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff,\n-            0xc0ffffffffffffff, 0x873ffffffeeff06f, 0x1fffffff00000000, 0x000000001fffffff,\n-            0x0000007ffffffeff, 0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff,\n-            0x00000000000001ff, 0x0007ffffffffffff, 0x03ff00ffffffffff, 0xffff00801fffffff,\n-            0x000000000001ffff, 0x007fffff00000000, 0x8000ffc00000007f, 0x03ff01ffffff0000,\n-            0xffdfffffffffffff, 0x004fffffffff0070, 0x0000000017ff1e1f, 0x40fffffffffbffff,\n-            0xffff01ffbfffbd7f, 0x03ff07ffffffffff, 0xfbedfdfffff99fef, 0x001f1fcfe081399f,\n-            0x00000000c3ff07ff, 0x0000000003ff00bf, 0xff3fffffffffffff, 0x000000003f000001,\n-            0x0000000003ff0011, 0x01ffffffffffffff, 0x00000000000003ff, 0x03ff0fffe7ffffff,\n-            0xffffffff00000000, 0x800003ffffffffff, 0xfffffcff00000000, 0x0000001bfcffffff,\n-            0x7fffffffffffffff, 0xffffffffffff0080, 0x0000000023ffffff, 0xff7ffffffffffdff,\n-            0xfffc000003ff0001, 0x007ffefffffcffff, 0xb47ffffffffffb7f, 0xfffffdbf03ff00ff,\n-            0x000003ff01fb7fff, 0x0000000003ffffff, 0x00007fffffffffff, 0x000000000000000f,\n-            0x000000000000007f, 0x000003ff7fffffff, 0x001f3fffffff0000, 0xe0fffff803ff000f,\n-            0x000000000000ffff, 0xffffffffffff87ff, 0x00000000ffff80ff, 0x0000000b00000000,\n-            0x00ffffffffffffff, 0xffff00f000070000, 0x0fffffffffffffff, 0x1fff07ffffffffff,\n-            0x0000000063ff01ff, 0xf807e3e000000000, 0x00003c0000000fe7, 0x000000000000001c,\n-            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n-            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n-            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0xffffffffffffcff7, 0xf87fffffffffffff,\n-            0x00201fffffffffff, 0x0000fffef8000010, 0x000007dbf9ffff7f, 0x3fff1fffffffffff,\n-            0x00000000000043ff, 0x03ffffffffffffff, 0x00000000007f001f, 0x0000000003ff0fff,\n-            0x0af7fe96ffffffef, 0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff,\n-            0xffff0003ffffffff, 0x00000001ffffffff, 0x000000003fffffff, 0x0000ffffffffffff\n-        ],\n-    };\n-\n-    pub fn XID_Continue(c: char) -> bool {\n-        XID_Continue_table.lookup(c)\n-    }\n-\n-    const XID_Start_table: &super::BoolTrie = &super::BoolTrie {\n-        r1: [\n-            0x0000000000000000, 0x07fffffe07fffffe, 0x0420040000000000, 0xff7fffffff7fffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000501f0003ffc3,\n-            0x0000000000000000, 0xb8df000000000000, 0xfffffffbffffd740, 0xffbfffffffffffff,\n-            0xffffffffffffffff, 0xffffffffffffffff, 0xfffffffffffffc03, 0xffffffffffffffff,\n-            0xfffeffffffffffff, 0xffffffff027fffff, 0x00000000000001ff, 0x000787ffffff0000,\n-            0xffffffff00000000, 0xfffec000000007ff, 0xffffffffffffffff, 0x9c00c060002fffff,\n-            0x0000fffffffd0000, 0xffffffffffffe000, 0x0002003fffffffff, 0x043007fffffffc00\n-        ],\n-        r2: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,\n-            24, 23, 25, 26, 27, 28, 29, 3, 30, 31, 32, 33, 34, 34, 34, 34, 34, 35, 36, 37, 38, 39,\n-            40, 41, 42, 34, 34, 34, 34, 34, 34, 34, 34, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n-            54, 55, 56, 57, 58, 59, 60, 3, 61, 62, 63, 64, 65, 66, 67, 68, 34, 34, 34, 3, 34, 34,\n-            34, 34, 69, 70, 71, 72, 3, 73, 74, 3, 75, 76, 77, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 78,\n-            79, 34, 80, 81, 82, 83, 84, 3, 3, 3, 3, 3, 3, 3, 3, 85, 42, 86, 87, 88, 34, 89, 90, 3,\n-            3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 53, 3, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 91, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 92, 93, 34, 34, 34, 34, 94,\n-            95, 96, 91, 97, 34, 98, 99, 100, 48, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110,\n-            111, 112, 34, 113, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34, 34,\n-            34, 34, 34, 114, 115, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,\n-            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 34, 34, 34, 34, 34,\n-            116, 34, 117, 118, 119, 120, 121, 34, 122, 34, 34, 123, 124, 125, 126, 3, 127, 34, 128,\n-            129, 130, 131, 132\n-        ],\n-        r3: &[\n-            0x00000110043fffff, 0x000007ff01ffffff, 0x3fdfffff00000000, 0x0000000000000000,\n-            0x23fffffffffffff0, 0xfffe0003ff010000, 0x23c5fdfffff99fe1, 0x10030003b0004000,\n-            0x036dfdfffff987e0, 0x001c00005e000000, 0x23edfdfffffbbfe0, 0x0200000300010000,\n-            0x23edfdfffff99fe0, 0x00020003b0000000, 0x03ffc718d63dc7e8, 0x0000000000010000,\n-            0x23fffdfffffddfe0, 0x0000000307000000, 0x23effdfffffddfe1, 0x0006000340000000,\n-            0x27fffffffffddfe0, 0xfc00000380704000, 0x2ffbfffffc7fffe0, 0x000000000000007f,\n-            0x0005fffffffffffe, 0x2005ffaffffff7d6, 0x00000000f000005f, 0x0000000000000001,\n-            0x00001ffffffffeff, 0x0000000000001f00, 0x800007ffffffffff, 0xffe1c0623c3f0000,\n-            0xffffffff00004003, 0xf7ffffffffff20bf, 0xffffffffffffffff, 0xffffffff3d7f3dff,\n-            0x7f3dffffffff3dff, 0xffffffffff7fff3d, 0xffffffffff3dffff, 0x0000000007ffffff,\n-            0xffffffff0000ffff, 0x3f3fffffffffffff, 0xfffffffffffffffe, 0xffff9fffffffffff,\n-            0xffffffff07fffffe, 0x01ffc7ffffffffff, 0x0003ffff0003dfff, 0x0001dfff0003ffff,\n-            0x000fffffffffffff, 0x0000000010800000, 0xffffffff00000000, 0x01ffffffffffffff,\n-            0xffff05ffffffffff, 0x003fffffffffffff, 0x000000007fffffff, 0x001f3fffffff0000,\n-            0xffff0fffffffffff, 0x00000000000003ff, 0xffffffff007fffff, 0x00000000001fffff,\n-            0x0000008000000000, 0x000fffffffffffe0, 0x0000000000000fe0, 0xfc00c001fffffff8,\n-            0x0000003fffffffff, 0x0000000fffffffff, 0x3ffffffffc00e000, 0xe7ffffffffff01ff,\n-            0x046fde0000000000, 0xffffffff3f3fffff, 0x3fffffffaaff3f3f, 0x5fdfffffffffffff,\n-            0x1fdc1fff0fcf1fdc, 0x8002000000000000, 0x000000001fff0000, 0xf3fffd503f2ffc84,\n-            0xffffffff000043e0, 0x00000000000001ff, 0xffff7fffffffffff, 0xffffffff7fffffff,\n-            0x000c781fffffffff, 0xffff20bfffffffff, 0x000080ffffffffff, 0x7f7f7f7f007fffff,\n-            0x000000007f7f7f7f, 0x1f3e03fe000000e0, 0xfffffffee07fffff, 0xf7ffffffffffffff,\n-            0xfffeffffffffffe0, 0x07ffffff00007fff, 0xffff000000000000, 0x0000ffffffffffff,\n-            0x0000000000001fff, 0x3fffffffffff0000, 0x00000c00ffff1fff, 0x80007fffffffffff,\n-            0xffffffff3fffffff, 0xfffffffcff800000, 0xfffffffffffff9ff, 0xff8000000000007c,\n-            0x00000007fffff7bb, 0x000ffffffffffffc, 0x68fc000000000000, 0xffff003ffffffc00,\n-            0x1fffffff0000007f, 0x0007fffffffffff0, 0x7c00ffdf00008000, 0x000001ffffffffff,\n-            0xc47fffff00000ff7, 0x3e62ffffffffffff, 0x001c07ff38000005, 0xffff7f7f007e7e7e,\n-            0xffff00fff7ffffff, 0x00000007ffffffff, 0xffff000fffffffff, 0x0ffffffffffff87f,\n-            0xffff3fffffffffff, 0x0000000003ffffff, 0x5f7ffdffa0f8007f, 0xffffffffffffffdb,\n-            0x0003ffffffffffff, 0xfffffffffff80000, 0xfffffff03fffffff, 0x3fffffffffffffff,\n-            0xffffffffffff0000, 0xfffffffffffcffff, 0x03ff0000000000ff, 0xaa8a000000000000,\n-            0x1fffffffffffffff, 0x07fffffe00000000, 0xffffffc007fffffe, 0x7fffffff3fffffff,\n-            0x000000001cfcfcfc\n-        ],\n-        r4: [\n-            0, 1, 2, 3, 4, 5, 6, 7, 8, 5, 5, 9, 5, 10, 11, 5, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 12, 13,\n-            14, 7, 15, 16, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n-            5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5\n-        ],\n-        r5: &[\n-            0, 1, 2, 3, 4, 5, 4, 4, 4, 4, 6, 7, 8, 9, 10, 11, 2, 2, 12, 13, 14, 15, 4, 4, 2, 2, 2,\n-            2, 16, 17, 4, 4, 18, 19, 20, 21, 22, 4, 23, 4, 24, 25, 26, 27, 28, 29, 30, 4, 2, 31, 32,\n-            32, 15, 4, 4, 4, 4, 4, 4, 4, 33, 34, 4, 35, 36, 4, 37, 38, 39, 40, 41, 42, 43, 4, 44,\n-            20, 45, 46, 4, 4, 5, 47, 48, 49, 4, 4, 50, 51, 48, 52, 53, 4, 54, 4, 4, 4, 55, 4, 56,\n-            57, 4, 4, 58, 59, 60, 61, 62, 63, 4, 4, 4, 4, 64, 65, 66, 4, 67, 68, 69, 4, 4, 4, 4, 70,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 71, 4, 2, 50, 2, 2, 2, 72, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 50, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 73, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 63, 20, 4, 74, 48, 75, 66, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 2, 4, 4, 2, 76, 77, 78, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 79, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            32, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 20, 80, 2,\n-            2, 2, 2, 2, 81, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 82, 83, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 84, 85, 86, 87, 88, 2, 2, 2, 2, 89, 90,\n-            91, 92, 93, 94, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 95, 96, 4, 4, 4, 4, 4, 55, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 97, 2, 98, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 99, 100, 101, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 102, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 5, 2, 2, 2, 10, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 103,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,\n-            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 104, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 2, 2, 2, 2, 2, 2, 2, 105, 4, 4, 4, 4, 4, 4,\n-            4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4\n-        ],\n-        r6: &[\n-            0xb7ffff7fffffefff, 0x000000003fff3fff, 0xffffffffffffffff, 0x07ffffffffffffff,\n-            0x0000000000000000, 0x001fffffffffffff, 0xffffffff1fffffff, 0x000000000001ffff,\n-            0xffffe000ffffffff, 0x003fffffffff07ff, 0xffffffff3fffffff, 0x00000000003eff0f,\n-            0xffff00003fffffff, 0x0fffffffff0fffff, 0xffff00ffffffffff, 0x0000000fffffffff,\n-            0x007fffffffffffff, 0x000000ff003fffff, 0x91bffffffffffd3f, 0x007fffff003fffff,\n-            0x000000007fffffff, 0x0037ffff00000000, 0x03ffffff003fffff, 0xc0ffffffffffffff,\n-            0x003ffffffeef0001, 0x1fffffff00000000, 0x000000001fffffff, 0x0000001ffffffeff,\n-            0x003fffffffffffff, 0x0007ffff003fffff, 0x000000000003ffff, 0x00000000000001ff,\n-            0x0007ffffffffffff, 0xffff00801fffffff, 0x000000000000003f, 0x007fffff00000000,\n-            0x00fffffffffffff8, 0x0000fffffffffff8, 0x000001ffffff0000, 0x0000007ffffffff8,\n-            0x0047ffffffff0010, 0x0007fffffffffff8, 0x000000001400001e, 0x00000ffffffbffff,\n-            0xffff01ffbfffbd7f, 0x23edfdfffff99fe0, 0x00000003e0010000, 0x0000000080000780,\n-            0x0000ffffffffffff, 0x00000000000000b0, 0x00007fffffffffff, 0x000000000f000000,\n-            0x0000000000000010, 0x010007ffffffffff, 0x0000000007ffffff, 0x00000fffffffffff,\n-            0xffffffff00000000, 0x80000000ffffffff, 0xfffffcff00000000, 0x0000000a0001ffff,\n-            0x0407fffffffff801, 0xfffffffff0010000, 0x00000000200003ff, 0x01ffffffffffffff,\n-            0x00007ffffffffdff, 0xfffc000000000001, 0x000000000000ffff, 0x0001fffffffffb7f,\n-            0xfffffdbf00000040, 0x00000000010003ff, 0x0007ffff00000000, 0x0000000003ffffff,\n-            0x000000000000000f, 0x000000000000007f, 0x00003fffffff0000, 0xe0fffff80000000f,\n-            0x00000000000107ff, 0x00000000fff80000, 0x0000000b00000000, 0x00ffffffffffffff,\n-            0xffff00f000070000, 0x0fffffffffffffff, 0x1fff07ffffffffff, 0x0000000003ff01ff,\n-            0xffffffffffdfffff, 0xebffde64dfffffff, 0xffffffffffffffef, 0x7bffffffdfdfe7bf,\n-            0xfffffffffffdfc5f, 0xffffff3fffffffff, 0xf7fffffff7fffffd, 0xffdfffffffdfffff,\n-            0xffff7fffffff7fff, 0xfffffdfffffffdff, 0x0000000000000ff7, 0x3f801fffffffffff,\n-            0x0000000000004000, 0x000000000000001f, 0x000000000000080f, 0x0af7fe96ffffffef,\n-            0x5ef7f796aa96ea84, 0x0ffffbee0ffffbff, 0x00000000007fffff, 0xffff0003ffffffff,\n-            0x00000001ffffffff, 0x000000003fffffff\n-        ],\n-    };\n-\n-    pub fn XID_Start(c: char) -> bool {\n-        XID_Start_table.lookup(c)\n-    }\n-\n }\n \n pub(crate) mod property {\n-    const Pattern_White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n-        r1: &[\n-            0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n-            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 3\n-        ],\n-        r2: &[\n-            0x0000000100003e00, 0x0000000000000000, 0x0000000000000020, 0x000003000000c000\n-        ],\n-    };\n-\n-    pub fn Pattern_White_Space(c: char) -> bool {\n-        Pattern_White_Space_table.lookup(c)\n-    }\n-\n     const White_Space_table: &super::SmallBoolTrie = &super::SmallBoolTrie {\n         r1: &[\n             0, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,"}, {"sha": "89894f7932d79fac161d5673d6b7778d9dd710f4", "filename": "src/libcore/unicode/unicode.py", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibcore%2Funicode%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode.py?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -728,7 +728,7 @@ def generate_property_module(mod, grouped_categories, category_subset):\n \n     yield \"pub(crate) mod %s {\\n\" % mod\n     for cat in sorted(category_subset):\n-        if cat in (\"Cc\", \"White_Space\", \"Pattern_White_Space\"):\n+        if cat in (\"Cc\", \"White_Space\"):\n             generator = generate_small_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n         else:\n             generator = generate_bool_trie(\"%s_table\" % cat, grouped_categories[cat])\n@@ -841,19 +841,18 @@ def main():\n     unicode_data = load_unicode_data(get_path(UnicodeFiles.UNICODE_DATA))\n     load_special_casing(get_path(UnicodeFiles.SPECIAL_CASING), unicode_data)\n \n-    want_derived = {\"XID_Start\", \"XID_Continue\", \"Alphabetic\", \"Lowercase\", \"Uppercase\",\n+    want_derived = {\"Alphabetic\", \"Lowercase\", \"Uppercase\",\n                     \"Cased\", \"Case_Ignorable\", \"Grapheme_Extend\"}\n     derived = load_properties(get_path(UnicodeFiles.DERIVED_CORE_PROPERTIES), want_derived)\n \n     props = load_properties(get_path(UnicodeFiles.PROPS),\n-                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\",\n-                             \"Pattern_White_Space\"})\n+                            {\"White_Space\", \"Join_Control\", \"Noncharacter_Code_Point\"})\n \n     # Category tables\n     for (name, categories, category_subset) in (\n             (\"general_category\", unicode_data.general_categories, [\"N\", \"Cc\"]),\n             (\"derived_property\", derived, want_derived),\n-            (\"property\", props, [\"White_Space\", \"Pattern_White_Space\"])\n+            (\"property\", props, [\"White_Space\"])\n     ):\n         for fragment in generate_property_module(name, categories, category_subset):\n             buf.write(fragment)"}, {"sha": "fff4ec716dfdad4e3453f7217bbbaf118fd4a4d0", "filename": "src/libfmt_macros/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibfmt_macros%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibfmt_macros%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -10,4 +10,4 @@ path = \"lib.rs\"\n \n [dependencies]\n syntax_pos = { path = \"../libsyntax_pos\" }\n-\n+rustc_lexer = { path = \"../librustc_lexer\" }"}, {"sha": "f9c1be20b8bc132aed7ac28364713e714427a797", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -597,12 +597,11 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses a word starting at the current position. A word is considered to\n-    /// be an alphabetic character followed by any number of alphanumeric\n-    /// characters.\n+    /// Parses a word starting at the current position. A word is the same as\n+    /// Rust identifier, except that it can't start with `_` character.\n     fn word(&mut self) -> &'a str {\n         let start = match self.cur.peek() {\n-            Some(&(pos, c)) if c.is_xid_start() => {\n+            Some(&(pos, c)) if c != '_' && rustc_lexer::is_id_start(c) => {\n                 self.cur.next();\n                 pos\n             }\n@@ -611,7 +610,7 @@ impl<'a> Parser<'a> {\n             }\n         };\n         while let Some(&(pos, c)) = self.cur.peek() {\n-            if c.is_xid_continue() {\n+            if rustc_lexer::is_id_continue(c) {\n                 self.cur.next();\n             } else {\n                 return &self.input[start..pos];"}, {"sha": "187bdac80019d51e914a6c70ec31e914c567d231", "filename": "src/libproc_macro/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -6,3 +6,6 @@ edition = \"2018\"\n \n [lib]\n path = \"lib.rs\"\n+\n+[dependencies]\n+std = { path = \"../libstd\" }"}, {"sha": "d408fef75153e2f83c597d9bfa6547b66585b1e2", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -19,12 +19,15 @@\n \n #![feature(nll)]\n #![feature(staged_api)]\n+#![feature(allow_internal_unstable)]\n #![feature(const_fn)]\n+#![feature(decl_macro)]\n #![feature(extern_types)]\n #![feature(in_band_lifetimes)]\n #![feature(optin_builtin_traits)]\n #![feature(mem_take)]\n #![feature(non_exhaustive)]\n+#![feature(rustc_attrs)]\n #![feature(specialization)]\n \n #![recursion_limit=\"256\"]\n@@ -222,11 +225,10 @@ pub mod token_stream {\n ///\n /// Unquoting is done with `$`, and works by taking the single next ident as the unquoted term.\n /// To quote `$` itself, use `$$`.\n-///\n-/// This is a dummy macro, the actual implementation is in `quote::quote`.`\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n-#[macro_export]\n-macro_rules! quote { () => {} }\n+#[allow_internal_unstable(proc_macro_def_site)]\n+#[cfg_attr(not(bootstrap), rustc_builtin_macro)]\n+pub macro quote ($($t:tt)*) { /* compiler built-in */ }\n \n #[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n #[doc(hidden)]"}, {"sha": "144e2d6bac43bb3061ecbb3c785965732e56c7e5", "filename": "src/libproc_macro/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibproc_macro%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fquote.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -57,9 +57,9 @@ macro_rules! quote {\n }\n \n /// Quote a `TokenStream` into a `TokenStream`.\n-/// This is the actual `quote!()` proc macro.\n+/// This is the actual implementation of the `quote!()` proc macro.\n ///\n-/// It is manually loaded in `CStore::load_macro_untracked`.\n+/// It is loaded by the compiler in `register_builtin_macros`.\n #[unstable(feature = \"proc_macro_quote\", issue = \"54722\")]\n pub fn quote(stream: TokenStream) -> TokenStream {\n     if stream.is_empty() {"}, {"sha": "0834faf1324245b9249c0625b5a56a14e6e95fc4", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -15,13 +15,12 @@ bitflags = \"1.0\"\n fmt_macros = { path = \"../libfmt_macros\" }\n graphviz = { path = \"../libgraphviz\" }\n jobserver = \"0.1\"\n-lazy_static = \"1.0.0\"\n num_cpus = \"1.0\"\n scoped-tls = \"1.0\"\n log = { version = \"0.4\", features = [\"release_max_level_info\", \"std\"] }\n rustc-rayon = \"0.2.0\"\n rustc-rayon-core = \"0.2.0\"\n-polonius-engine  = \"0.9.0\"\n+polonius-engine  = \"0.10.0\"\n rustc_apfloat = { path = \"../librustc_apfloat\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_macros = { path = \"../librustc_macros\" }\n@@ -31,8 +30,8 @@ rustc_serialize = { path = \"../libserialize\", package = \"serialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n backtrace = \"0.3.3\"\n-parking_lot = \"0.7\"\n-byteorder = { version = \"1.1\", features = [\"i128\"]}\n+parking_lot = \"0.9\"\n+byteorder = { version = \"1.3\" }\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "d4fc1b12830a12eeb4af48f5a5306f0841da4252", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -25,6 +25,16 @@ macro_rules! arena_types {\n             [] adt_def: rustc::ty::AdtDef,\n             [] steal_mir: rustc::ty::steal::Steal<rustc::mir::Body<$tcx>>,\n             [] mir: rustc::mir::Body<$tcx>,\n+            [] steal_promoted: rustc::ty::steal::Steal<\n+                rustc_data_structures::indexed_vec::IndexVec<\n+                    rustc::mir::Promoted,\n+                    rustc::mir::Body<$tcx>\n+                >\n+            >,\n+            [] promoted: rustc_data_structures::indexed_vec::IndexVec<\n+                rustc::mir::Promoted,\n+                rustc::mir::Body<$tcx>\n+            >,\n             [] tables: rustc::ty::TypeckTables<$tcx>,\n             [] const_allocs: rustc::mir::interpret::Allocation,\n             [] vtable_method: Option<(\n@@ -84,6 +94,10 @@ macro_rules! arena_types {\n                         rustc::hir::def_id::CrateNum\n                     >\n                 >,\n+            [few] diagnostic_items: rustc_data_structures::fx::FxHashMap<\n+                syntax::symbol::Symbol,\n+                rustc::hir::def_id::DefId,\n+            >,\n             [few] resolve_lifetimes: rustc::middle::resolve_lifetime::ResolveLifetimes,\n             [decode] generic_predicates: rustc::ty::GenericPredicates<'tcx>,\n             [few] lint_levels: rustc::lint::LintLevelMap,\n@@ -173,7 +187,7 @@ impl<T: Copy> ArenaAllocatable for T {}\n \n unsafe trait ArenaField<'tcx>: Sized {\n     /// Returns a specific arena to allocate from.\n-    /// If None is returned, the DropArena will be used.\n+    /// If `None` is returned, the `DropArena` will be used.\n     fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;\n }\n "}, {"sha": "e76a70350b33eb4b4c80c590e07a6d866f6dc202", "filename": "src/librustc/dep_graph/graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fgraph.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,4 +1,4 @@\n-use errors::{Diagnostic, DiagnosticBuilder};\n+use errors::Diagnostic;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n@@ -819,7 +819,7 @@ impl DepGraph {\n             let handle = tcx.sess.diagnostic();\n \n             for diagnostic in diagnostics {\n-                DiagnosticBuilder::new_diagnostic(handle, diagnostic).emit();\n+                handle.emit_diagnostic(&diagnostic);\n             }\n \n             // Mark the node as green now that diagnostics are emitted"}, {"sha": "f6564f1fcd4c19bff0b41716bbdf5204801e4ad7", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 47, "deletions": 15, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,7 +1,8 @@\n // Error messages for EXXXX errors.\n-// Each message should start and end with a new line, and be wrapped to 80 characters.\n-// In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use `:set tw=0` to disable.\n-register_long_diagnostics! {\n+// Each message should start and end with a new line, and be wrapped to 80\n+// characters.  In vim you can `:set tw=80` and use `gq` to wrap paragraphs. Use\n+// `:set tw=0` to disable.\n+syntax::register_diagnostics! {\n E0038: r##\"\n Trait objects like `Box<Trait>` can only be constructed when certain\n requirements are satisfied by the trait in question.\n@@ -39,7 +40,7 @@ Generally, `Self: Sized` is used to indicate that the trait should not be used\n as a trait object. If the trait comes from your own crate, consider removing\n this restriction.\n \n-### Method references the `Self` type in its arguments or return type\n+### Method references the `Self` type in its parameters or return type\n \n This happens when a trait has a method like the following:\n \n@@ -1346,6 +1347,39 @@ struct Foo<T: 'static> {\n ```\n \"##,\n \n+E0312: r##\"\n+Reference's lifetime of borrowed content doesn't match the expected lifetime.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0312\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'static str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Invalid lifetime!\n+    }\n+}\n+```\n+\n+To fix this error, either lessen the expected lifetime or find a way to not have\n+to use this reference outside of its current scope (by running the code directly\n+in the same block for example?):\n+\n+```\n+// In this case, we can fix the issue by switching from \"static\" lifetime to 'a\n+pub fn opt_str<'a>(maybestr: &'a Option<String>) -> &'a str {\n+    if maybestr.is_none() {\n+        \"(none)\"\n+    } else {\n+        let s: &'a str = maybestr.as_ref().unwrap();\n+        s  // Ok!\n+    }\n+}\n+```\n+\"##,\n+\n E0317: r##\"\n This error occurs when an `if` expression without an `else` block is used in a\n context where a type other than `()` is expected, for example a `let`\n@@ -2183,11 +2217,7 @@ Examples of erroneous code:\n static X: u32 = 42;\n ```\n \"##,\n-\n-}\n-\n-\n-register_diagnostics! {\n+;\n //  E0006, // merged with E0005\n //  E0101, // replaced with E0282\n //  E0102, // replaced with E0282\n@@ -2205,8 +2235,8 @@ register_diagnostics! {\n //  E0304, // expected signed integer constant\n //  E0305, // expected constant\n     E0311, // thing may not live long enough\n-    E0312, // lifetime of reference outlives lifetime of borrowed content\n-    E0313, // lifetime of borrowed pointer outlives lifetime of captured variable\n+    E0313, // lifetime of borrowed pointer outlives lifetime of captured\n+           // variable\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n@@ -2223,23 +2253,25 @@ register_diagnostics! {\n     E0483, // lifetime of operand does not outlive the operation\n     E0484, // reference is not valid at the time of borrow\n     E0485, // automatically reference is not valid at the time of borrow\n-    E0486, // type of expression contains references that are not valid during...\n+    E0486, // type of expression contains references that are not valid during..\n     E0487, // unsafe use of destructor: destructor might be called while...\n     E0488, // lifetime of variable does not enclose its declaration\n     E0489, // type/lifetime parameter not in scope here\n     E0490, // a value of type `..` is borrowed for too long\n-    E0495, // cannot infer an appropriate lifetime due to conflicting requirements\n+    E0495, // cannot infer an appropriate lifetime due to conflicting\n+           // requirements\n     E0566, // conflicting representation hints\n     E0623, // lifetime mismatch where both parameters are anonymous regions\n-    E0628, // generators cannot have explicit arguments\n+    E0628, // generators cannot have explicit parameters\n     E0631, // type mismatch in closure arguments\n     E0637, // \"'_\" is not a valid lifetime bound\n     E0657, // `impl Trait` can only capture lifetimes bound at the fn level\n     E0687, // in-band lifetimes cannot be used in `fn`/`Fn` syntax\n     E0688, // in-band lifetimes cannot be mixed with explicit lifetime binders\n     E0697, // closures cannot be static\n     E0707, // multiple elided lifetimes used in arguments of `async fn`\n-    E0708, // `async` non-`move` closures with arguments are not currently supported\n+    E0708, // `async` non-`move` closures with parameters are not currently\n+           // supported\n     E0709, // multiple different lifetimes used in arguments of `async fn`\n     E0710, // an unknown tool name found in scoped lint\n     E0711, // a feature has been declared with conflicting stability attributes"}, {"sha": "1df09429e519f835948af6007239498a3beefe14", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,13 +4,12 @@\n //! conflicts between multiple such attributes attached to the same\n //! item.\n \n-\n-use crate::ty::TyCtxt;\n-use crate::ty::query::Providers;\n-\n use crate::hir;\n use crate::hir::def_id::DefId;\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::ty::TyCtxt;\n+use crate::ty::query::Providers;\n+\n use std::fmt::{self, Display};\n use syntax::symbol::sym;\n use syntax_pos::Span;"}, {"sha": "f7d31ca06ee56e173dc8d900632d980de17d8206", "filename": "src/librustc/hir/def.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,15 +1,17 @@\n+use self::Namespace::*;\n+\n use crate::hir::def_id::{DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use crate::hir;\n+use crate::ty;\n use crate::util::nodemap::DefIdMap;\n+\n use syntax::ast;\n use syntax::ext::base::MacroKind;\n use syntax::ast::NodeId;\n use syntax_pos::Span;\n use rustc_macros::HashStable;\n-use crate::hir;\n-use crate::ty;\n-use std::fmt::Debug;\n \n-use self::Namespace::*;\n+use std::fmt::Debug;\n \n /// Encodes if a `DefKind::Ctor` is the constructor of an enum variant or a struct.\n #[derive(Clone, Copy, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, HashStable)]\n@@ -115,7 +117,7 @@ impl DefKind {\n         }\n     }\n \n-    /// An English article for the def.\n+    /// Gets an English article for the definition.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             DefKind::AssocTy\n@@ -134,18 +136,22 @@ pub enum Res<Id = hir::HirId> {\n     Def(DefKind, DefId),\n \n     // Type namespace\n+\n     PrimTy(hir::PrimTy),\n     SelfTy(Option<DefId> /* trait */, Option<DefId> /* impl */),\n     ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n \n     // Value namespace\n+\n     SelfCtor(DefId /* impl */),  // `DefId` refers to the impl\n     Local(Id),\n \n     // Macro namespace\n+\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // All namespaces\n+\n     Err,\n }\n \n@@ -330,7 +336,7 @@ impl NonMacroAttrKind {\n }\n \n impl<Id> Res<Id> {\n-    /// Return the `DefId` of this `Def` if it has an id, else panic.\n+    /// Return the `DefId` of this `Def` if it has an ID, else panic.\n     pub fn def_id(&self) -> DefId\n     where\n         Id: Debug,\n@@ -340,7 +346,7 @@ impl<Id> Res<Id> {\n         })\n     }\n \n-    /// Return `Some(..)` with the `DefId` of this `Res` if it has a id, else `None`.\n+    /// Return `Some(..)` with the `DefId` of this `Res` if it has a ID, else `None`.\n     pub fn opt_def_id(&self) -> Option<DefId> {\n         match *self {\n             Res::Def(_, id) => Some(id),\n@@ -379,7 +385,7 @@ impl<Id> Res<Id> {\n         }\n     }\n \n-    /// An English article for the res.\n+    /// Gets an English article for the `Res`.\n     pub fn article(&self) -> &'static str {\n         match *self {\n             Res::Def(kind, _) => kind.article(),"}, {"sha": "d0bdc149131835c8bc62d9c300d18e37c1c2669d", "filename": "src/librustc/hir/def_id.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fdef_id.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -11,7 +11,7 @@ newtype_index! {\n \n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum CrateNum {\n-    /// A special CrateNum that we use for the tcx.rcache when decoding from\n+    /// A special `CrateNum` that we use for the `tcx.rcache` when decoding from\n     /// the incr. comp. cache.\n     ReservedForIncrCompCache,\n     Index(CrateId),\n@@ -26,11 +26,10 @@ impl ::std::fmt::Debug for CrateNum {\n     }\n }\n \n-/// Item definitions in the currently-compiled crate would have the CrateNum\n-/// LOCAL_CRATE in their DefId.\n+/// Item definitions in the currently-compiled crate would have the `CrateNum`\n+/// `LOCAL_CRATE` in their `DefId`.\n pub const LOCAL_CRATE: CrateNum = CrateNum::Index(CrateId::from_u32_const(0));\n \n-\n impl Idx for CrateNum {\n     #[inline]\n     fn new(value: usize) -> Self {"}, {"sha": "1f125de9672168d6e599aeef32378264ad20dbc7", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 18, "deletions": 16, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -31,11 +31,13 @@\n //! This order consistency is required in a few places in rustc, for\n //! example generator inference, and possibly also HIR borrowck.\n \n-use syntax::ast::{Ident, Name, Attribute};\n-use syntax_pos::Span;\n+use super::itemlikevisit::DeepVisitor;\n+\n use crate::hir::*;\n use crate::hir::map::Map;\n-use super::itemlikevisit::DeepVisitor;\n+\n+use syntax::ast::{Ident, Name, Attribute};\n+use syntax_pos::Span;\n \n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n@@ -139,7 +141,7 @@ impl<'this, 'tcx> NestedVisitorMap<'this, 'tcx> {\n /// explicitly, you need to override each method. (And you also need\n /// to monitor future changes to `Visitor` in case a new method with a\n /// new default implementation gets introduced.)\n-pub trait Visitor<'v> : Sized {\n+pub trait Visitor<'v>: Sized {\n     ///////////////////////////////////////////////////////////////////////////\n     // Nested items.\n \n@@ -162,8 +164,8 @@ pub trait Visitor<'v> : Sized {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'v>;\n \n     /// Invoked when a nested item is encountered. By default does\n-    /// nothing unless you override `nested_visit_map` to return\n-    /// `Some(_)`, in which case it will walk the item. **You probably\n+    /// nothing unless you override `nested_visit_map` to return other than\n+    /// `None`, in which case it will walk the item. **You probably\n     /// don't want to override this method** -- instead, override\n     /// `nested_visit_map` or use the \"shallow\" or \"deep\" visit\n     /// patterns described on `itemlikevisit::ItemLikeVisitor`. The only\n@@ -201,17 +203,17 @@ pub trait Visitor<'v> : Sized {\n \n     /// Invoked to visit the body of a function, method or closure. Like\n     /// visit_nested_item, does nothing by default unless you override\n-    /// `nested_visit_map` to return `Some(_)`, in which case it will walk the\n-    /// body.\n+    /// `nested_visit_map` to return other htan `None`, in which case it will walk\n+    /// the body.\n     fn visit_nested_body(&mut self, id: BodyId) {\n         let opt_body = self.nested_visit_map().intra().map(|map| map.body(id));\n         if let Some(body) = opt_body {\n             self.visit_body(body);\n         }\n     }\n \n-    fn visit_arg(&mut self, arg: &'v Arg) {\n-        walk_arg(self, arg)\n+    fn visit_param(&mut self, param: &'v Param) {\n+        walk_param(self, param)\n     }\n \n     /// Visits the top-level item and (optionally) nested items / impl items. See\n@@ -400,7 +402,7 @@ pub fn walk_mod<'v, V: Visitor<'v>>(visitor: &mut V, module: &'v Mod, mod_hir_id\n }\n \n pub fn walk_body<'v, V: Visitor<'v>>(visitor: &mut V, body: &'v Body) {\n-    walk_list!(visitor, visit_arg, &body.arguments);\n+    walk_list!(visitor, visit_param, &body.params);\n     visitor.visit_expr(&body.value);\n }\n \n@@ -454,10 +456,10 @@ pub fn walk_trait_ref<'v, V>(visitor: &mut V, trait_ref: &'v TraitRef)\n     visitor.visit_path(&trait_ref.path, trait_ref.hir_ref_id)\n }\n \n-pub fn walk_arg<'v, V: Visitor<'v>>(visitor: &mut V, arg: &'v Arg) {\n-    visitor.visit_id(arg.hir_id);\n-    visitor.visit_pat(&arg.pat);\n-    walk_list!(visitor, visit_attribute, &arg.attrs);\n+pub fn walk_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Param) {\n+    visitor.visit_id(param.hir_id);\n+    visitor.visit_pat(&param.pat);\n+    walk_list!(visitor, visit_attribute, &param.attrs);\n }\n \n pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n@@ -603,7 +605,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n             visitor.visit_lifetime(lifetime);\n             visitor.visit_ty(&mutable_type.ty)\n         }\n-        TyKind::Never => {},\n+        TyKind::Never => {}\n         TyKind::Tup(ref tuple_element_types) => {\n             walk_list!(visitor, visit_ty, tuple_element_types);\n         }"}, {"sha": "39dd46c2d2903473e35e8b26a88e3163d24add3d", "filename": "src/librustc/hir/itemlikevisit.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fitemlikevisit.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,7 +1,7 @@\n use super::{Item, ImplItem, TraitItem};\n use super::intravisit::Visitor;\n \n-/// The \"item-like visitor\" visitor defines only the top-level methods\n+/// The \"item-like visitor\" defines only the top-level methods\n /// that can be invoked by `Crate::visit_all_item_likes()`. Whether\n /// this trait is the right one to implement will depend on the\n /// overall pattern you need. Here are the three available patterns,\n@@ -18,22 +18,21 @@ use super::intravisit::Visitor;\n ///    an item, but don't care about how item-like things are nested\n ///    within one another.\n ///    - Example: Examine each expression to look for its type and do some check or other.\n-///    - How: Implement `intravisit::Visitor` and use\n-///      `tcx.hir().krate().visit_all_item_likes(visitor.as_deep_visitor())`. Within\n-///      your `intravisit::Visitor` impl, implement methods like\n-///      `visit_expr()`; don't forget to invoke\n-///      `intravisit::walk_visit_expr()` to keep walking the subparts.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::OnlyBodies` and use\n+///      `tcx.hir().krate().visit_all_item_likes(&mut visitor.as_deep_visitor())`. Within\n+///      your `intravisit::Visitor` impl, implement methods like `visit_expr()` (don't forget\n+///      to invoke `intravisit::walk_expr()` to keep walking the subparts).\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Integrates well into dependency tracking.\n ///    - Con: Don't get information about nesting between items\n /// 3. **Nested visit**: Want to visit the whole HIR and you care about the nesting between\n ///    item-like things.\n ///    - Example: Lifetime resolution, which wants to bring lifetimes declared on the\n ///      impl into scope while visiting the impl-items, and then back out again.\n-///    - How: Implement `intravisit::Visitor` and override the\n-///      `nested_visit_map()` methods to return\n-///      `NestedVisitorMap::All`. Walk your crate with\n-///      `intravisit::walk_crate()` invoked on `tcx.hir().krate()`.\n+///    - How: Implement `intravisit::Visitor` and override the `nested_visit_map()` method\n+///      to return `NestedVisitorMap::All`. Walk your crate with `intravisit::walk_crate()`\n+///      invoked on `tcx.hir().krate()`.\n ///    - Pro: Visitor methods for any kind of HIR node, not just item-like things.\n ///    - Pro: Preserves nesting information\n ///    - Con: Does not integrate well into dependency tracking.\n@@ -79,7 +78,7 @@ impl<'v, 'hir, V> ItemLikeVisitor<'hir> for DeepVisitor<'v, V>\n     }\n }\n \n-/// A parallel variant of ItemLikeVisitor\n+/// A parallel variant of `ItemLikeVisitor`.\n pub trait ParItemLikeVisitor<'hir> {\n     fn visit_item(&self, item: &'hir Item);\n     fn visit_trait_item(&self, trait_item: &'hir TraitItem);"}, {"sha": "f6b872623d78976722bc659dbd399de8bf63bcde", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 68, "deletions": 41, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -79,7 +79,7 @@ const HIR_ID_COUNTER_LOCKED: u32 = 0xFFFFFFFF;\n pub struct LoweringContext<'a> {\n     crate_root: Option<Symbol>,\n \n-    /// Used to assign ids to HIR nodes that do not directly correspond to an AST node.\n+    /// Used to assign IDs to HIR nodes that do not directly correspond to AST nodes.\n     sess: &'a Session,\n \n     cstore: &'a dyn CrateStore,\n@@ -126,7 +126,7 @@ pub struct LoweringContext<'a> {\n     /// lifetime definitions in the corresponding impl or function generics.\n     lifetimes_to_define: Vec<(Span, ParamName)>,\n \n-    /// Whether or not in-band lifetimes are being collected. This is used to\n+    /// `true` if in-band lifetimes are being collected. This is used to\n     /// indicate whether or not we're in a place where new lifetimes will result\n     /// in in-band lifetime definitions, such a function or an impl header,\n     /// including implicit lifetimes from `impl_header_lifetime_elision`.\n@@ -154,13 +154,13 @@ pub struct LoweringContext<'a> {\n }\n \n pub trait Resolver {\n-    /// Obtain resolution for a `NodeId` with a single resolution.\n+    /// Obtains resolution for a `NodeId` with a single resolution.\n     fn get_partial_res(&mut self, id: NodeId) -> Option<PartialRes>;\n \n-    /// Obtain per-namespace resolutions for `use` statement with the given `NoedId`.\n+    /// Obtains per-namespace resolutions for `use` statement with the given `NodeId`.\n     fn get_import_res(&mut self, id: NodeId) -> PerNS<Option<Res<NodeId>>>;\n \n-    /// Obtain resolution for a label with the given `NodeId`.\n+    /// Obtains resolution for a label with the given `NodeId`.\n     fn get_label_res(&mut self, id: NodeId) -> Option<NodeId>;\n \n     /// We must keep the set of definitions up to date as we add nodes that weren't in the AST.\n@@ -425,19 +425,44 @@ impl<'a> LoweringContext<'a> {\n \n         impl<'tcx, 'interner> Visitor<'tcx> for MiscCollector<'tcx, 'interner> {\n             fn visit_pat(&mut self, p: &'tcx Pat) {\n-                match p.node {\n+                if let PatKind::Paren(..) | PatKind::Rest = p.node {\n                     // Doesn't generate a HIR node\n-                    PatKind::Paren(..) | PatKind::Rest => {},\n-                    _ => {\n-                        if let Some(owner) = self.hir_id_owner {\n-                            self.lctx.lower_node_id_with_owner(p.id, owner);\n-                        }\n-                    }\n-                };\n+                } else if let Some(owner) = self.hir_id_owner {\n+                    self.lctx.lower_node_id_with_owner(p.id, owner);\n+                }\n \n                 visit::walk_pat(self, p)\n             }\n \n+            // HACK(or_patterns; Centril | dlrobertson): Avoid creating\n+            // HIR  nodes for `PatKind::Or` for the top level of a `ast::Arm`.\n+            // This is a temporary hack that should go away once we push down\n+            // `arm.pats: HirVec<P<Pat>>` -> `arm.pat: P<Pat>` to HIR. // Centril\n+            fn visit_arm(&mut self, arm: &'tcx Arm) {\n+                match &arm.pat.node {\n+                    PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                    _ => self.visit_pat(&arm.pat),\n+                }\n+                walk_list!(self, visit_expr, &arm.guard);\n+                self.visit_expr(&arm.body);\n+                walk_list!(self, visit_attribute, &arm.attrs);\n+            }\n+\n+            // HACK(or_patterns; Centril | dlrobertson): Same as above. // Centril\n+            fn visit_expr(&mut self, e: &'tcx Expr) {\n+                if let ExprKind::Let(pat, scrutinee) = &e.node {\n+                    walk_list!(self, visit_attribute, e.attrs.iter());\n+                    match &pat.node {\n+                        PatKind::Or(pats) => pats.iter().for_each(|p| self.visit_pat(p)),\n+                        _ => self.visit_pat(&pat),\n+                    }\n+                    self.visit_expr(scrutinee);\n+                    self.visit_expr_post(e);\n+                    return;\n+                }\n+                visit::walk_expr(self, e)\n+            }\n+\n             fn visit_item(&mut self, item: &'tcx Item) {\n                 let hir_id = self.lctx.allocate_hir_id_counter(item.id);\n \n@@ -510,12 +535,12 @@ impl<'a> LoweringContext<'a> {\n                             &f.generic_params\n                         );\n                         // Mirrors visit::walk_fn_decl\n-                        for argument in &f.decl.inputs {\n+                        for parameter in &f.decl.inputs {\n                             // We don't lower the ids of argument patterns\n                             self.with_hir_id_owner(None, |this| {\n-                                this.visit_pat(&argument.pat);\n+                                this.visit_pat(&parameter.pat);\n                             });\n-                            self.visit_ty(&argument.ty)\n+                            self.visit_ty(&parameter.ty)\n                         }\n                         self.visit_fn_ret_ty(&f.decl.output)\n                     }\n@@ -674,7 +699,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_res(&mut self, res: Res<NodeId>) -> Res {\n         res.map_id(|id| {\n             self.lower_node_id_generic(id, |_| {\n-                panic!(\"expected node_id to be lowered already for res {:#?}\", res)\n+                panic!(\"expected `NodeId` to be lowered already for res {:#?}\", res);\n             })\n         })\n     }\n@@ -735,7 +760,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T, F>(\n         &mut self,\n         parent_id: DefId,\n@@ -880,7 +905,7 @@ impl<'a> LoweringContext<'a> {\n     ///\n     /// Presuming that in-band lifetimes are enabled, then\n     /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// argument while `f` is running (and restored afterwards).\n+    /// parameter while `f` is running (and restored afterwards).\n     fn add_in_band_defs<F, T>(\n         &mut self,\n         generics: &Generics,\n@@ -1080,7 +1105,7 @@ impl<'a> LoweringContext<'a> {\n                     ImplTraitContext::Disallowed(_) if self.is_in_dyn_type =>\n                         (true, ImplTraitContext::OpaqueTy(None)),\n \n-                    // We are in the argument position, but not within a dyn type:\n+                    // We are in the parameter position, but not within a dyn type:\n                     //\n                     //     fn foo(x: impl Iterator<Item: Debug>)\n                     //\n@@ -1204,7 +1229,7 @@ impl<'a> LoweringContext<'a> {\n                                 unsafety: this.lower_unsafety(f.unsafety),\n                                 abi: f.abi,\n                                 decl: this.lower_fn_decl(&f.decl, None, false, None),\n-                                arg_names: this.lower_fn_args_to_names(&f.decl),\n+                                param_names: this.lower_fn_params_to_names(&f.decl),\n                             }))\n                         },\n                     )\n@@ -1291,7 +1316,7 @@ impl<'a> LoweringContext<'a> {\n                             ImplTraitContext::Universal(in_band_ty_params),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n-                        let ident = Ident::from_str(&pprust::ty_to_string(t)).with_span_pos(span);\n+                        let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(ident),\n@@ -1339,7 +1364,7 @@ impl<'a> LoweringContext<'a> {\n                     }\n                 }\n             }\n-            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now.\"),\n+            TyKind::Mac(_) => bug!(\"`TyMac` should have been expanded by now\"),\n             TyKind::CVarArgs => {\n                 // Create the implicit lifetime of the \"spoofed\" `VaListImpl`.\n                 let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n@@ -1868,10 +1893,13 @@ impl<'a> LoweringContext<'a> {\n                         if let Ok(snippet) = self.sess.source_map().span_to_snippet(data.span) {\n                             // Do not suggest going from `Trait()` to `Trait<>`\n                             if data.inputs.len() > 0 {\n+                                let split = snippet.find('(').unwrap();\n+                                let trait_name = &snippet[0..split];\n+                                let args = &snippet[split + 1 .. snippet.len() - 1];\n                                 err.span_suggestion(\n                                     data.span,\n                                     \"use angle brackets instead\",\n-                                    format!(\"<{}>\", &snippet[1..snippet.len() - 1]),\n+                                    format!(\"{}<{}>\", trait_name, args),\n                                     Applicability::MaybeIncorrect,\n                                 );\n                             }\n@@ -2093,12 +2121,12 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_fn_args_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n+    fn lower_fn_params_to_names(&mut self, decl: &FnDecl) -> hir::HirVec<Ident> {\n         decl.inputs\n             .iter()\n-            .map(|arg| match arg.pat.node {\n+            .map(|param| match param.pat.node {\n                 PatKind::Ident(_, ident, _) => ident,\n-                _ => Ident::new(kw::Invalid, arg.pat.span),\n+                _ => Ident::new(kw::Invalid, param.pat.span),\n             })\n             .collect()\n     }\n@@ -2136,11 +2164,11 @@ impl<'a> LoweringContext<'a> {\n         let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n             decl.inputs\n                 .iter()\n-                .map(|arg| {\n+                .map(|param| {\n                     if let Some((_, ibty)) = &mut in_band_ty_params {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::Universal(ibty))\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::Universal(ibty))\n                     } else {\n-                        this.lower_ty_direct(&arg.ty, ImplTraitContext::disallowed())\n+                        this.lower_ty_direct(&param.ty, ImplTraitContext::disallowed())\n                     }\n                 })\n                 .collect::<HirVec<_>>()\n@@ -2205,7 +2233,7 @@ impl<'a> LoweringContext<'a> {\n     //\n     //     type OpaqueTy<generics_from_parent_fn> = impl Future<Output = T>;\n     //\n-    // `inputs`: lowered types of arguments to the function (used to collect lifetimes)\n+    // `inputs`: lowered types of parameters to the function (used to collect lifetimes)\n     // `output`: unlowered output type (`T` in `-> T`)\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n@@ -2657,12 +2685,8 @@ impl<'a> LoweringContext<'a> {\n         bounds.iter().map(|bound| self.lower_param_bound(bound, itctx.reborrow())).collect()\n     }\n \n-    fn lower_block_with_stmts(\n-        &mut self,\n-        b: &Block,\n-        targeted_by_break: bool,\n-        mut stmts: Vec<hir::Stmt>,\n-    ) -> P<hir::Block> {\n+    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n+        let mut stmts = vec![];\n         let mut expr = None;\n \n         for (index, stmt) in b.stmts.iter().enumerate() {\n@@ -2687,8 +2711,11 @@ impl<'a> LoweringContext<'a> {\n         })\n     }\n \n-    fn lower_block(&mut self, b: &Block, targeted_by_break: bool) -> P<hir::Block> {\n-        self.lower_block_with_stmts(b, targeted_by_break, vec![])\n+    /// Lowers a block directly to an expression, presuming that it\n+    /// has no attributes and is not targeted by a `break`.\n+    fn lower_block_expr(&mut self, b: &Block) -> hir::Expr {\n+        let block = self.lower_block(b, false);\n+        self.expr_block(block, ThinVec::new())\n     }\n \n     fn lower_pat(&mut self, p: &Pat) -> P<hir::Pat> {\n@@ -2974,7 +3001,7 @@ impl<'a> LoweringContext<'a> {\n             }\n             StmtKind::Expr(ref e) => hir::StmtKind::Expr(P(self.lower_expr(e))),\n             StmtKind::Semi(ref e) => hir::StmtKind::Semi(P(self.lower_expr(e))),\n-            StmtKind::Mac(..) => panic!(\"Shouldn't exist here\"),\n+            StmtKind::Mac(..) => panic!(\"shouldn't exist here\"),\n         };\n         smallvec![hir::Stmt {\n             hir_id: self.lower_node_id(s.id),\n@@ -3162,7 +3189,7 @@ impl<'a> LoweringContext<'a> {\n \n         hir::Path {\n             span,\n-            res: res.map_id(|_| panic!(\"unexpected node_id\")),\n+            res: res.map_id(|_| panic!(\"unexpected `NodeId`\")),\n             segments: segments.into(),\n         }\n     }"}, {"sha": "990728fa0e68079b795e01a82e2cc85380e6a513", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 61, "deletions": 70, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -68,7 +68,7 @@ impl LoweringContext<'_> {\n                 let ohs = P(self.lower_expr(ohs));\n                 hir::ExprKind::AddrOf(m, ohs)\n             }\n-            ExprKind::Let(ref pats, ref scrutinee) => self.lower_expr_let(e.span, pats, scrutinee),\n+            ExprKind::Let(ref pat, ref scrutinee) => self.lower_expr_let(e.span, pat, scrutinee),\n             ExprKind::If(ref cond, ref then, ref else_opt) => {\n                 self.lower_expr_if(e.span, cond, then, else_opt.as_deref())\n             }\n@@ -90,10 +90,7 @@ impl LoweringContext<'_> {\n             ),\n             ExprKind::Async(capture_clause, closure_node_id, ref block) => {\n                 self.make_async_expr(capture_clause, closure_node_id, None, block.span, |this| {\n-                    this.with_new_scopes(|this| {\n-                        let block = this.lower_block(block, false);\n-                        this.expr_block(block, ThinVec::new())\n-                    })\n+                    this.with_new_scopes(|this| this.lower_block_expr(block))\n                 })\n             }\n             ExprKind::Await(ref expr) => self.lower_expr_await(e.span, expr),\n@@ -227,16 +224,11 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    /// Emit an error and lower `ast::ExprKind::Let(pats, scrutinee)` into:\n+    /// Emit an error and lower `ast::ExprKind::Let(pat, scrutinee)` into:\n     /// ```rust\n     /// match scrutinee { pats => true, _ => false }\n     /// ```\n-    fn lower_expr_let(\n-        &mut self,\n-        span: Span,\n-        pats: &[AstP<Pat>],\n-        scrutinee: &Expr\n-    ) -> hir::ExprKind {\n+    fn lower_expr_let(&mut self, span: Span, pat: &Pat, scrutinee: &Expr) -> hir::ExprKind {\n         // If we got here, the `let` expression is not allowed.\n         self.sess\n             .struct_span_err(span, \"`let` expressions are not supported here\")\n@@ -246,23 +238,23 @@ impl LoweringContext<'_> {\n \n         // For better recovery, we emit:\n         // ```\n-        // match scrutinee { pats => true, _ => false }\n+        // match scrutinee { pat => true, _ => false }\n         // ```\n         // While this doesn't fully match the user's intent, it has key advantages:\n         // 1. We can avoid using `abort_if_errors`.\n-        // 2. We can typeck both `pats` and `scrutinee`.\n-        // 3. `pats` is allowed to be refutable.\n+        // 2. We can typeck both `pat` and `scrutinee`.\n+        // 3. `pat` is allowed to be refutable.\n         // 4. The return type of the block is `bool` which seems like what the user wanted.\n         let scrutinee = self.lower_expr(scrutinee);\n         let then_arm = {\n-            let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n+            let pat = self.lower_pat_top_hack(pat);\n             let expr = self.expr_bool(span, true);\n-            self.arm(pats, P(expr))\n+            self.arm(pat, P(expr))\n         };\n         let else_arm = {\n-            let pats = hir_vec![self.pat_wild(span)];\n+            let pat = self.pat_wild(span);\n             let expr = self.expr_bool(span, false);\n-            self.arm(pats, P(expr))\n+            self.arm(hir_vec![pat], P(expr))\n         };\n         hir::ExprKind::Match(\n             P(scrutinee),\n@@ -289,15 +281,13 @@ impl LoweringContext<'_> {\n         let else_arm = self.arm(hir_vec![else_pat], P(else_expr));\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(then, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar) = match cond.node {\n+        let then_expr = self.lower_block_expr(then);\n+        let (then_pat, scrutinee, desugar) = match cond.node {\n             // `<pat> => <then>`:\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 let scrutinee = self.lower_expr(scrutinee);\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::IfLetDesugar { contains_else_clause };\n-                (pats, scrutinee, desugar)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::IfLetDesugar { contains_else_clause })\n             }\n             // `true => <then>`:\n             _ => {\n@@ -312,13 +302,11 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `if cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::IfDesugar { contains_else_clause };\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::IfDesugar { contains_else_clause })\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         hir::ExprKind::Match(P(scrutinee), vec![then_arm, else_arm].into(), desugar)\n     }\n@@ -343,10 +331,9 @@ impl LoweringContext<'_> {\n         };\n \n         // Handle then + scrutinee:\n-        let then_blk = self.lower_block(body, false);\n-        let then_expr = self.expr_block(then_blk, ThinVec::new());\n-        let (then_pats, scrutinee, desugar, source) = match cond.node {\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n+        let then_expr = self.lower_block_expr(body);\n+        let (then_pat, scrutinee, desugar, source) = match cond.node {\n+            ExprKind::Let(ref pat, ref scrutinee) => {\n                 // to:\n                 //\n                 //   [opt_ident]: loop {\n@@ -356,16 +343,15 @@ impl LoweringContext<'_> {\n                 //     }\n                 //   }\n                 let scrutinee = self.with_loop_condition_scope(|t| t.lower_expr(scrutinee));\n-                let pats = pats.iter().map(|pat| self.lower_pat(pat)).collect();\n-                let desugar = hir::MatchSource::WhileLetDesugar;\n-                (pats, scrutinee, desugar, hir::LoopSource::WhileLet)\n+                let pat = self.lower_pat_top_hack(pat);\n+                (pat, scrutinee, hir::MatchSource::WhileLetDesugar, hir::LoopSource::WhileLet)\n             }\n             _ => {\n                 // We desugar: `'label: while $cond $body` into:\n                 //\n                 // ```\n                 // 'label: loop {\n-                //     match DropTemps($cond) {\n+                //     match drop-temps { $cond } {\n                 //         true => $body,\n                 //         _ => break,\n                 //     }\n@@ -383,14 +369,12 @@ impl LoweringContext<'_> {\n                 // to preserve drop semantics since `while cond { ... }` does not\n                 // let temporaries live outside of `cond`.\n                 let cond = self.expr_drop_temps(span_block, P(cond), ThinVec::new());\n-\n-                let desugar = hir::MatchSource::WhileDesugar;\n                 // `true => <then>`:\n-                let pats = hir_vec![self.pat_bool(span, true)];\n-                (pats, cond, desugar, hir::LoopSource::While)\n+                let pat = self.pat_bool(span, true);\n+                (hir_vec![pat], cond, hir::MatchSource::WhileDesugar, hir::LoopSource::While)\n             }\n         };\n-        let then_arm = self.arm(then_pats, P(then_expr));\n+        let then_arm = self.arm(then_pat, P(then_expr));\n \n         // `match <scrutinee> { ... }`\n         let match_expr = self.expr_match(\n@@ -440,7 +424,7 @@ impl LoweringContext<'_> {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: self.lower_attrs(&arm.attrs),\n-            pats: arm.pats.iter().map(|x| self.lower_pat(x)).collect(),\n+            pats: self.lower_pat_top_hack(&arm.pat),\n             guard: match arm.guard {\n                 Some(ref x) => Some(hir::Guard::If(P(self.lower_expr(x)))),\n                 _ => None,\n@@ -450,6 +434,16 @@ impl LoweringContext<'_> {\n         }\n     }\n \n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn lower_pat_top_hack(&mut self, pat: &Pat) -> HirVec<P<hir::Pat>> {\n+        match pat.node {\n+            PatKind::Or(ref ps) => ps.iter().map(|x| self.lower_pat(x)).collect(),\n+            _ => hir_vec![self.lower_pat(pat)],\n+        }\n+    }\n+\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n@@ -508,14 +502,13 @@ impl LoweringContext<'_> {\n \n     /// Desugar `<expr>.await` into:\n     /// ```rust\n-    /// {\n-    ///     let mut pinned = <expr>;\n-    ///     loop {\n+    /// match <expr> {\n+    ///     mut pinned => loop {\n     ///         match ::std::future::poll_with_tls_context(unsafe {\n-    ///             ::std::pin::Pin::new_unchecked(&mut pinned)\n+    ///             <::std::pin::Pin>::new_unchecked(&mut pinned)\n     ///         }) {\n     ///             ::std::task::Poll::Ready(result) => break result,\n-    ///             ::std::task::Poll::Pending => {},\n+    ///             ::std::task::Poll::Pending => {}\n     ///         }\n     ///         yield ();\n     ///     }\n@@ -550,21 +543,12 @@ impl LoweringContext<'_> {\n             self.allow_gen_future.clone(),\n         );\n \n-        // let mut pinned = <expr>;\n-        let expr = P(self.lower_expr(expr));\n         let pinned_ident = Ident::with_dummy_span(sym::pinned);\n         let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n             span,\n             pinned_ident,\n             hir::BindingAnnotation::Mutable,\n         );\n-        let pinned_let = self.stmt_let_pat(\n-            ThinVec::new(),\n-            span,\n-            Some(expr),\n-            pinned_pat,\n-            hir::LocalSource::AwaitDesugar,\n-        );\n \n         // ::std::future::poll_with_tls_context(unsafe {\n         //     ::std::pin::Pin::new_unchecked(&mut pinned)\n@@ -622,7 +606,7 @@ impl LoweringContext<'_> {\n             self.arm(hir_vec![pending_pat], empty_block)\n         };\n \n-        let match_stmt = {\n+        let inner_match_stmt = {\n             let match_expr = self.expr_match(\n                 span,\n                 poll_expr,\n@@ -644,10 +628,11 @@ impl LoweringContext<'_> {\n \n         let loop_block = P(self.block_all(\n             span,\n-            hir_vec![match_stmt, yield_stmt],\n+            hir_vec![inner_match_stmt, yield_stmt],\n             None,\n         ));\n \n+        // loop { .. }\n         let loop_expr = P(hir::Expr {\n             hir_id: loop_hir_id,\n             node: hir::ExprKind::Loop(\n@@ -659,10 +644,14 @@ impl LoweringContext<'_> {\n             attrs: ThinVec::new(),\n         });\n \n-        hir::ExprKind::Block(\n-            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n-            None,\n-        )\n+        // mut pinned => loop { ... }\n+        let pinned_arm = self.arm(hir_vec![pinned_pat], loop_expr);\n+\n+        // match <expr> {\n+        //     mut pinned => loop { .. }\n+        // }\n+        let expr = P(self.lower_expr(expr));\n+        hir::ExprKind::Match(expr, hir_vec![pinned_arm], hir::MatchSource::AwaitDesugar)\n     }\n \n     fn lower_expr_closure(\n@@ -724,7 +713,7 @@ impl LoweringContext<'_> {\n                         self.sess,\n                         fn_decl_span,\n                         E0628,\n-                        \"generators cannot have explicit arguments\"\n+                        \"generators cannot have explicit parameters\"\n                     );\n                     self.sess.abort_if_errors();\n                 }\n@@ -775,7 +764,7 @@ impl LoweringContext<'_> {\n                     this.sess,\n                     fn_decl_span,\n                     E0708,\n-                    \"`async` non-`move` closures with arguments are not currently supported\",\n+                    \"`async` non-`move` closures with parameters are not currently supported\",\n                 )\n                 .help(\n                     \"consider using `let` statements to manually capture \\\n@@ -1255,7 +1244,6 @@ impl LoweringContext<'_> {\n                 ThinVec::from(attrs.clone()),\n             ));\n             let ok_pat = self.pat_ok(span, val_pat);\n-\n             self.arm(hir_vec![ok_pat], val_expr)\n         };\n \n@@ -1317,7 +1305,7 @@ impl LoweringContext<'_> {\n     /// `{ let _t = $expr; _t }` but should provide better compile-time performance.\n     ///\n     /// The drop order can be important in e.g. `if expr { .. }`.\n-    fn expr_drop_temps(\n+    pub(super) fn expr_drop_temps(\n         &mut self,\n         span: Span,\n         expr: P<hir::Expr>,\n@@ -1486,7 +1474,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn arm(&mut self, pats: hir::HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n+    /// HACK(or_patterns; Centril | dlrobertson): For now we don't push down top level or-patterns\n+    /// `p | q` into `hir::PatKind::Or(...)` as post-lowering bits of the compiler are not ready\n+    /// to deal with it. This should by fixed by pushing it down to HIR and then HAIR.\n+    fn arm(&mut self, pats: HirVec<P<hir::Pat>>, expr: P<hir::Expr>) -> hir::Arm {\n         hir::Arm {\n             hir_id: self.next_id(),\n             attrs: hir_vec![],"}, {"sha": "61be40a6b907f63e6ea69cd712bcc7bdeb7c9ae2", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 82, "deletions": 50, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -718,9 +718,9 @@ impl LoweringContext<'_> {\n                         AnonymousLifetimeMode::PassThrough,\n                         |this, _| {\n                             (\n-                                // Disallow impl Trait in foreign items\n+                                // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, false, None),\n-                                this.lower_fn_args_to_names(fdec),\n+                                this.lower_fn_params_to_names(fdec),\n                             )\n                         },\n                     );\n@@ -732,7 +732,7 @@ impl LoweringContext<'_> {\n                         self.lower_ty(t, ImplTraitContext::disallowed()), self.lower_mutability(m))\n                 }\n                 ForeignItemKind::Ty => hir::ForeignItemKind::Type,\n-                ForeignItemKind::Macro(_) => panic!(\"shouldn't exist here\"),\n+                ForeignItemKind::Macro(_) => panic!(\"macro shouldn't exist here\"),\n             },\n             vis: self.lower_visibility(&i.vis, None),\n             span: i.span,\n@@ -827,7 +827,7 @@ impl LoweringContext<'_> {\n                 ),\n             ),\n             TraitItemKind::Method(ref sig, None) => {\n-                let names = self.lower_fn_args_to_names(&sig.decl);\n+                let names = self.lower_fn_params_to_names(&sig.decl);\n                 let (generics, sig) = self.lower_method_sig(\n                     &i.generics,\n                     sig,\n@@ -1028,10 +1028,10 @@ impl LoweringContext<'_> {\n         }\n     }\n \n-    fn record_body(&mut self, arguments: HirVec<hir::Arg>, value: hir::Expr) -> hir::BodyId {\n+    fn record_body(&mut self, params: HirVec<hir::Param>, value: hir::Expr) -> hir::BodyId {\n         let body = hir::Body {\n             generator_kind: self.generator_kind,\n-            arguments,\n+            params,\n             value,\n         };\n         let id = body.id();\n@@ -1041,21 +1041,21 @@ impl LoweringContext<'_> {\n \n     fn lower_body(\n         &mut self,\n-        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Arg>, hir::Expr),\n+        f: impl FnOnce(&mut LoweringContext<'_>) -> (HirVec<hir::Param>, hir::Expr),\n     ) -> hir::BodyId {\n         let prev_gen_kind = self.generator_kind.take();\n-        let (arguments, result) = f(self);\n-        let body_id = self.record_body(arguments, result);\n+        let (parameters, result) = f(self);\n+        let body_id = self.record_body(parameters, result);\n         self.generator_kind = prev_gen_kind;\n         body_id\n     }\n \n-    fn lower_arg(&mut self, arg: &Arg) -> hir::Arg {\n-        hir::Arg {\n-            attrs: self.lower_attrs(&arg.attrs),\n-            hir_id: self.lower_node_id(arg.id),\n-            pat: self.lower_pat(&arg.pat),\n-            span: arg.span,\n+    fn lower_param(&mut self, param: &Param) -> hir::Param {\n+        hir::Param {\n+            attrs: self.lower_attrs(&param.attrs),\n+            hir_id: self.lower_node_id(param.id),\n+            pat: self.lower_pat(&param.pat),\n+            span: param.span,\n         }\n     }\n \n@@ -1065,16 +1065,13 @@ impl LoweringContext<'_> {\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::BodyId {\n         self.lower_body(|this| (\n-            decl.inputs.iter().map(|x| this.lower_arg(x)).collect(),\n+            decl.inputs.iter().map(|x| this.lower_param(x)).collect(),\n             body(this),\n         ))\n     }\n \n     fn lower_fn_body_block(&mut self, decl: &FnDecl, body: &Block) -> hir::BodyId {\n-        self.lower_fn_body(decl, |this| {\n-            let body = this.lower_block(body, false);\n-            this.expr_block(body, ThinVec::new())\n-        })\n+        self.lower_fn_body(decl, |this| this.lower_block_expr(body))\n     }\n \n     pub(super) fn lower_const_body(&mut self, expr: &Expr) -> hir::BodyId {\n@@ -1093,17 +1090,16 @@ impl LoweringContext<'_> {\n         };\n \n         self.lower_body(|this| {\n-            let mut arguments: Vec<hir::Arg> = Vec::new();\n+            let mut parameters: Vec<hir::Param> = Vec::new();\n             let mut statements: Vec<hir::Stmt> = Vec::new();\n \n-            // Async function arguments are lowered into the closure body so that they are\n+            // Async function parameters are lowered into the closure body so that they are\n             // captured and so that the drop order matches the equivalent non-async functions.\n             //\n             // from:\n             //\n             //     async fn foo(<pattern>: <ty>, <pattern>: <ty>, <pattern>: <ty>) {\n-            //       async move {\n-            //       }\n+            //         <body>\n             //     }\n             //\n             // into:\n@@ -1116,18 +1112,26 @@ impl LoweringContext<'_> {\n             //         let <pattern> = __arg1;\n             //         let __arg0 = __arg0;\n             //         let <pattern> = __arg0;\n+            //         drop-temps { <body> } // see comments later in fn for details\n             //       }\n             //     }\n             //\n             // If `<pattern>` is a simple ident, then it is lowered to a single\n             // `let <pattern> = <pattern>;` statement as an optimization.\n-            for (index, argument) in decl.inputs.iter().enumerate() {\n-                let argument = this.lower_arg(argument);\n-                let span = argument.pat.span;\n+            //\n+            // Note that the body is embedded in `drop-temps`; an\n+            // equivalent desugaring would be `return { <body>\n+            // };`. The key point is that we wish to drop all the\n+            // let-bound variables and temporaries created in the body\n+            // (and its tail expression!) before we drop the\n+            // parameters (c.f. rust-lang/rust#64512).\n+            for (index, parameter) in decl.inputs.iter().enumerate() {\n+                let parameter = this.lower_param(parameter);\n+                let span = parameter.pat.span;\n \n                 // Check if this is a binding pattern, if so, we can optimize and avoid adding a\n-                // `let <pat> = __argN;` statement. In this case, we do not rename the argument.\n-                let (ident, is_simple_argument) = match argument.pat.node {\n+                // `let <pat> = __argN;` statement. In this case, we do not rename the parameter.\n+                let (ident, is_simple_parameter) = match parameter.pat.node {\n                     hir::PatKind::Binding(hir::BindingAnnotation::Unannotated, _, ident, _) =>\n                         (ident, true),\n                     _ => {\n@@ -1142,32 +1146,32 @@ impl LoweringContext<'_> {\n                 let desugared_span =\n                     this.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n-                // Construct an argument representing `__argN: <ty>` to replace the argument of the\n+                // Construct a parameter representing `__argN: <ty>` to replace the parameter of the\n                 // async function.\n                 //\n-                // If this is the simple case, this argument will end up being the same as the\n-                // original argument, but with a different pattern id.\n+                // If this is the simple case, this parameter will end up being the same as the\n+                // original parameter, but with a different pattern id.\n                 let mut stmt_attrs = ThinVec::new();\n-                stmt_attrs.extend(argument.attrs.iter().cloned());\n-                let (new_argument_pat, new_argument_id) = this.pat_ident(desugared_span, ident);\n-                let new_argument = hir::Arg {\n-                    attrs: argument.attrs,\n-                    hir_id: argument.hir_id,\n-                    pat: new_argument_pat,\n-                    span: argument.span,\n+                stmt_attrs.extend(parameter.attrs.iter().cloned());\n+                let (new_parameter_pat, new_parameter_id) = this.pat_ident(desugared_span, ident);\n+                let new_parameter = hir::Param {\n+                    attrs: parameter.attrs,\n+                    hir_id: parameter.hir_id,\n+                    pat: new_parameter_pat,\n+                    span: parameter.span,\n                 };\n \n \n-                if is_simple_argument {\n+                if is_simple_parameter {\n                     // If this is the simple case, then we only insert one statement that is\n                     // `let <pat> = <pat>;`. We re-use the original argument's pattern so that\n                     // `HirId`s are densely assigned.\n-                    let expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n                     statements.push(stmt);\n@@ -1179,7 +1183,7 @@ impl LoweringContext<'_> {\n                     // let <pat> = __argN;\n                     // ```\n                     //\n-                    // The first statement moves the argument into the closure and thus ensures\n+                    // The first statement moves the parameter into the closure and thus ensures\n                     // that the drop order is correct.\n                     //\n                     // The second statement creates the bindings that the user wrote.\n@@ -1189,7 +1193,7 @@ impl LoweringContext<'_> {\n                     // statement.\n                     let (move_pat, move_id) = this.pat_ident_binding_mode(\n                         desugared_span, ident, hir::BindingAnnotation::Mutable);\n-                    let move_expr = this.expr_ident(desugared_span, ident, new_argument_id);\n+                    let move_expr = this.expr_ident(desugared_span, ident, new_parameter_id);\n                     let move_stmt = this.stmt_let_pat(\n                         ThinVec::new(),\n                         desugared_span,\n@@ -1199,30 +1203,58 @@ impl LoweringContext<'_> {\n                     );\n \n                     // Construct the `let <pat> = __argN;` statement. We re-use the original\n-                    // argument's pattern so that `HirId`s are densely assigned.\n+                    // parameter's pattern so that `HirId`s are densely assigned.\n                     let pattern_expr = this.expr_ident(desugared_span, ident, move_id);\n                     let pattern_stmt = this.stmt_let_pat(\n                         stmt_attrs,\n                         desugared_span,\n                         Some(P(pattern_expr)),\n-                        argument.pat,\n+                        parameter.pat,\n                         hir::LocalSource::AsyncFn\n                     );\n \n                     statements.push(move_stmt);\n                     statements.push(pattern_stmt);\n                 };\n \n-                arguments.push(new_argument);\n+                parameters.push(new_parameter);\n             }\n \n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value, closure_id, None, body.span,\n                 |this| {\n-                    let body = this.lower_block_with_stmts(body, false, statements);\n-                    this.expr_block(body, ThinVec::new())\n+                    // Create a block from the user's function body:\n+                    let user_body = this.lower_block_expr(body);\n+\n+                    // Transform into `drop-temps { <user-body> }`, an expression:\n+                    let desugared_span = this.mark_span_with_reason(\n+                        DesugaringKind::Async,\n+                        user_body.span,\n+                        None,\n+                    );\n+                    let user_body = this.expr_drop_temps(\n+                        desugared_span,\n+                        P(user_body),\n+                        ThinVec::new(),\n+                    );\n+\n+                    // As noted above, create the final block like\n+                    //\n+                    // ```\n+                    // {\n+                    //   let $param_pattern = $raw_param;\n+                    //   ...\n+                    //   drop-temps { <user-body> }\n+                    // }\n+                    // ```\n+                    let body = this.block_all(\n+                        desugared_span,\n+                        statements.into(),\n+                        Some(P(user_body)),\n+                    );\n+                    this.expr_block(P(body), ThinVec::new())\n                 });\n-            (HirVec::from(arguments), this.expr(body.span, async_expr, ThinVec::new()))\n+            (HirVec::from(parameters), this.expr(body.span, async_expr, ThinVec::new()))\n         })\n     }\n "}, {"sha": "4179cf2ff807fd0d169900eef3e3c8bbec10afcf", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -186,7 +186,7 @@ impl<'a, 'hir> NodeCollector<'a, 'hir> {\n             });\n \n         let mut upstream_crates: Vec<_> = cstore.crates_untracked().iter().map(|&cnum| {\n-            let name = cstore.crate_name_untracked(cnum).as_str();\n+            let name = cstore.crate_name_untracked(cnum).as_interned_str();\n             let disambiguator = cstore.crate_disambiguator_untracked(cnum).to_fingerprint();\n             let hash = cstore.crate_hash_untracked(cnum);\n             (name, disambiguator, hash)\n@@ -340,7 +340,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     /// their outer items.\n \n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'hir> {\n-        panic!(\"visit_nested_xxx must be manually implemented in this visitor\")\n+        panic!(\"`visit_nested_xxx` must be manually implemented in this visitor\");\n     }\n \n     fn visit_nested_item(&mut self, item: ItemId) {\n@@ -363,11 +363,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         self.currently_in_body = prev_in_body;\n     }\n \n-    fn visit_arg(&mut self, arg: &'hir Arg) {\n-        let node = Node::Arg(arg);\n-        self.insert(arg.pat.span, arg.hir_id, node);\n-        self.with_parent(arg.hir_id, |this| {\n-            intravisit::walk_arg(this, arg);\n+    fn visit_param(&mut self, param: &'hir Param) {\n+        let node = Node::Param(param);\n+        self.insert(param.pat.span, param.hir_id, node);\n+        self.with_parent(param.hir_id, |this| {\n+            intravisit::walk_param(this, param);\n         });\n     }\n "}, {"sha": "d1cc7a8ce988fd30efc58a0bb6ccfd7418a18c92", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 72, "deletions": 11, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -31,7 +31,7 @@ impl<'a> DefCollector<'a> {\n         self.definitions.create_def_with_parent(parent_def, node_id, data, self.expansion, span)\n     }\n \n-    pub fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n+    fn with_parent<F: FnOnce(&mut Self)>(&mut self, parent_def: DefIndex, f: F) {\n         let orig_parent_def = std::mem::replace(&mut self.parent_def, parent_def);\n         f(self);\n         self.parent_def = orig_parent_def;\n@@ -74,6 +74,22 @@ impl<'a> DefCollector<'a> {\n         })\n     }\n \n+    fn collect_field(&mut self, field: &'a StructField, index: Option<usize>) {\n+        if field.is_placeholder {\n+            self.visit_macro_invoc(field.id);\n+        } else {\n+            let name = field.ident.map(|ident| ident.name)\n+                .or_else(|| index.map(sym::integer))\n+                .unwrap_or_else(|| {\n+                    let node_id = NodeId::placeholder_from_expn_id(self.expansion);\n+                    sym::integer(self.definitions.placeholder_field_indices[&node_id])\n+                })\n+                .as_interned_str();\n+            let def = self.create_def(field.id, DefPathData::ValueNs(name), field.span);\n+            self.with_parent(def, |this| visit::walk_struct_field(this, field));\n+        }\n+    }\n+\n     pub fn visit_macro_invoc(&mut self, id: NodeId) {\n         self.definitions.set_invocation_parent(id.placeholder_to_expn_id(), self.parent_def);\n     }\n@@ -154,31 +170,38 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n         });\n     }\n \n-    fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n+    fn visit_variant(&mut self, v: &'a Variant) {\n+        if v.is_placeholder {\n+            return self.visit_macro_invoc(v.id);\n+        }\n         let def = self.create_def(v.id,\n                                   DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n             if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n-            visit::walk_variant(this, v, g, item_id)\n+            visit::walk_variant(this, v)\n         });\n     }\n \n-    fn visit_variant_data(&mut self, data: &'a VariantData, _: Ident,\n-                          _: &'a Generics, _: NodeId, _: Span) {\n+    fn visit_variant_data(&mut self, data: &'a VariantData) {\n+        // The assumption here is that non-`cfg` macro expansion cannot change field indices.\n+        // It currently holds because only inert attributes are accepted on fields,\n+        // and every such attribute expands into a single field after it's resolved.\n         for (index, field) in data.fields().iter().enumerate() {\n-            let name = field.ident.map(|ident| ident.name)\n-                .unwrap_or_else(|| sym::integer(index));\n-            let def = self.create_def(field.id,\n-                                      DefPathData::ValueNs(name.as_interned_str()),\n-                                      field.span);\n-            self.with_parent(def, |this| this.visit_struct_field(field));\n+            self.collect_field(field, Some(index));\n+            if field.is_placeholder && field.ident.is_none() {\n+                self.definitions.placeholder_field_indices.insert(field.id, index);\n+            }\n         }\n     }\n \n     fn visit_generic_param(&mut self, param: &'a GenericParam) {\n+        if param.is_placeholder {\n+            self.visit_macro_invoc(param.id);\n+            return;\n+        }\n         let name = param.ident.as_interned_str();\n         let def_path_data = match param.kind {\n             GenericParamKind::Lifetime { .. } => DefPathData::LifetimeNs(name),\n@@ -295,4 +318,42 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n             }\n         }\n     }\n+\n+    fn visit_arm(&mut self, arm: &'a Arm) {\n+        if arm.is_placeholder {\n+            self.visit_macro_invoc(arm.id)\n+        } else {\n+            visit::walk_arm(self, arm)\n+        }\n+    }\n+\n+    fn visit_field(&mut self, f: &'a Field) {\n+        if f.is_placeholder {\n+            self.visit_macro_invoc(f.id)\n+        } else {\n+            visit::walk_field(self, f)\n+        }\n+    }\n+\n+    fn visit_field_pattern(&mut self, fp: &'a FieldPat) {\n+        if fp.is_placeholder {\n+            self.visit_macro_invoc(fp.id)\n+        } else {\n+            visit::walk_field_pattern(self, fp)\n+        }\n+    }\n+\n+    fn visit_param(&mut self, p: &'a Param) {\n+        if p.is_placeholder {\n+            self.visit_macro_invoc(p.id)\n+        } else {\n+            visit::walk_param(self, p)\n+        }\n+    }\n+\n+    // This method is called only when we are visiting an individual field\n+    // after expanding an attribute on it.\n+    fn visit_struct_field(&mut self, field: &'a StructField) {\n+        self.collect_field(field, None);\n+    }\n }"}, {"sha": "187bc5933246078819b9cba87d3a819c453c9677", "filename": "src/librustc/hir/map/definitions.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdefinitions.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -7,23 +7,24 @@\n use crate::hir;\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE, CRATE_DEF_INDEX};\n use crate::ich::Fingerprint;\n+use crate::session::CrateDisambiguator;\n+use crate::util::nodemap::NodeMap;\n+\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::{IndexVec};\n use rustc_data_structures::stable_hasher::StableHasher;\n-use crate::session::CrateDisambiguator;\n use std::borrow::Borrow;\n use std::fmt::Write;\n use std::hash::Hash;\n use syntax::ast;\n use syntax::ext::hygiene::ExpnId;\n use syntax::symbol::{Symbol, sym, InternedString};\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::util::nodemap::NodeMap;\n \n-/// The DefPathTable maps DefIndexes to DefKeys and vice versa.\n-/// Internally the DefPathTable holds a tree of DefKeys, where each DefKey\n-/// stores the DefIndex of its parent.\n-/// There is one DefPathTable for each crate.\n+/// The `DefPathTable` maps `DefIndex`es to `DefKey`s and vice versa.\n+/// Internally the `DefPathTable` holds a tree of `DefKey`s, where each `DefKey`\n+/// stores the `DefIndex` of its parent.\n+/// There is one `DefPathTable` for each crate.\n #[derive(Clone, Default, RustcDecodable, RustcEncodable)]\n pub struct DefPathTable {\n     index_to_key: Vec<DefKey>,\n@@ -103,6 +104,8 @@ pub struct Definitions {\n     /// When collecting definitions from an AST fragment produced by a macro invocation `ExpnId`\n     /// we know what parent node that fragment should be attached to thanks to this table.\n     invocation_parents: FxHashMap<ExpnId, DefIndex>,\n+    /// Indices of unnamed struct or variant fields with unresolved attributes.\n+    pub(super) placeholder_field_indices: NodeMap<usize>,\n }\n \n /// A unique identifier that we can use to lookup a definition\n@@ -121,7 +124,7 @@ impl DefKey {\n     fn compute_stable_hash(&self, parent_hash: DefPathHash) -> DefPathHash {\n         let mut hasher = StableHasher::new();\n \n-        // We hash a 0u8 here to disambiguate between regular DefPath hashes,\n+        // We hash a `0u8` here to disambiguate between regular `DefPath` hashes,\n         // and the special \"root_parent\" below.\n         0u8.hash(&mut hasher);\n         parent_hash.hash(&mut hasher);\n@@ -145,8 +148,7 @@ impl DefKey {\n                                crate_disambiguator: CrateDisambiguator)\n                                -> DefPathHash {\n         let mut hasher = StableHasher::new();\n-        // Disambiguate this from a regular DefPath hash,\n-        // see compute_stable_hash() above.\n+        // Disambiguate this from a regular `DefPath` hash; see `compute_stable_hash()` above.\n         1u8.hash(&mut hasher);\n         crate_name.hash(&mut hasher);\n         crate_disambiguator.hash(&mut hasher);\n@@ -155,10 +157,10 @@ impl DefKey {\n }\n \n /// A pair of `DefPathData` and an integer disambiguator. The integer is\n-/// normally 0, but in the event that there are multiple defs with the\n+/// normally `0`, but in the event that there are multiple defs with the\n /// same `parent` and `data`, we use this field to disambiguate\n /// between them. This introduces some artificial ordering dependency\n-/// but means that if you have (e.g.) two impls for the same type in\n+/// but means that if you have, e.g., two impls for the same type in\n /// the same module, they do get distinct `DefId`s.\n #[derive(Clone, PartialEq, Debug, Hash, RustcEncodable, RustcDecodable)]\n pub struct DisambiguatedDefPathData {\n@@ -277,29 +279,34 @@ impl DefPath {\n pub enum DefPathData {\n     // Root: these should only be used for the root nodes, because\n     // they are treated specially by the `def_path` function.\n-    /// The crate root (marker)\n+\n+    /// The crate root (marker).\n     CrateRoot,\n-    // Catch-all for random DefId things like `DUMMY_NODE_ID`\n+    // Catch-all for random `DefId` things like `DUMMY_NODE_ID`.\n     Misc,\n+\n     // Different kinds of items and item-like things:\n-    /// An impl\n+\n+    /// An impl.\n     Impl,\n-    /// Something in the type NS\n+    /// Something in the type namespace.\n     TypeNs(InternedString),\n-    /// Something in the value NS\n+    /// Something in the value namespace.\n     ValueNs(InternedString),\n-    /// Something in the macro NS\n+    /// Something in the macro namespace.\n     MacroNs(InternedString),\n-    /// Something in the lifetime NS\n+    /// Something in the lifetime namespace.\n     LifetimeNs(InternedString),\n-    /// A closure expression\n+    /// A closure expression.\n     ClosureExpr,\n-    // Subportions of items\n-    /// Implicit ctor for a unit or tuple-like struct or enum variant.\n+\n+    // Subportions of items:\n+\n+    /// Implicit constructor for a unit or tuple-like struct or enum variant.\n     Ctor,\n-    /// A constant expression (see {ast,hir}::AnonConst).\n+    /// A constant expression (see `{ast,hir}::AnonConst`).\n     AnonConst,\n-    /// An `impl Trait` type node\n+    /// An `impl Trait` type node.\n     ImplTrait,\n     /// Identifies a piece of crate metadata that is global to a whole crate\n     /// (as opposed to just one item). `GlobalMetaData` components are only\n@@ -435,7 +442,7 @@ impl Definitions {\n         self.node_to_def_index.insert(ast::CRATE_NODE_ID, root_index);\n         self.set_invocation_parent(ExpnId::root(), root_index);\n \n-        // Allocate some other DefIndices that always must exist.\n+        // Allocate some other `DefIndex`es that always must exist.\n         GlobalMetaDataKind::allocate_def_indices(self);\n \n         root_index\n@@ -458,7 +465,7 @@ impl Definitions {\n                 data,\n                 self.table.def_key(self.node_to_def_index[&node_id]));\n \n-        // The root node must be created with create_root_def()\n+        // The root node must be created with `create_root_def()`.\n         assert!(data != DefPathData::CrateRoot);\n \n         // Find the next free disambiguator for this key.\n@@ -486,9 +493,9 @@ impl Definitions {\n         assert_eq!(index.index(), self.def_index_to_node.len());\n         self.def_index_to_node.push(node_id);\n \n-        // Some things for which we allocate DefIndices don't correspond to\n-        // anything in the AST, so they don't have a NodeId. For these cases\n-        // we don't need a mapping from NodeId to DefIndex.\n+        // Some things for which we allocate `DefIndex`es don't correspond to\n+        // anything in the AST, so they don't have a `NodeId`. For these cases\n+        // we don't need a mapping from `NodeId` to `DefIndex`.\n         if node_id != ast::DUMMY_NODE_ID {\n             debug!(\"create_def_with_parent: def_index_to_node[{:?} <-> {:?}\", index, node_id);\n             self.node_to_def_index.insert(node_id, index);\n@@ -498,20 +505,20 @@ impl Definitions {\n             self.expansions_that_defined.insert(index, expn_id);\n         }\n \n-        // The span is added if it isn't dummy\n+        // The span is added if it isn't dummy.\n         if !span.is_dummy() {\n             self.def_index_to_span.insert(index, span);\n         }\n \n         index\n     }\n \n-    /// Initialize the `ast::NodeId` to `HirId` mapping once it has been generated during\n+    /// Initializes the `ast::NodeId` to `HirId` mapping once it has been generated during\n     /// AST to HIR lowering.\n     pub fn init_node_id_to_hir_id_mapping(&mut self,\n                                           mapping: IndexVec<ast::NodeId, hir::HirId>) {\n         assert!(self.node_to_hir_id.is_empty(),\n-                \"Trying initialize NodeId -> HirId mapping twice\");\n+                \"trying to initialize `NodeId` -> `HirId` mapping twice\");\n         self.node_to_hir_id = mapping;\n     }\n \n@@ -533,7 +540,7 @@ impl Definitions {\n \n     pub fn set_invocation_parent(&mut self, invoc_id: ExpnId, parent: DefIndex) {\n         let old_parent = self.invocation_parents.insert(invoc_id, parent);\n-        assert!(old_parent.is_none(), \"parent def-index is reset for an invocation\");\n+        assert!(old_parent.is_none(), \"parent `DefIndex` is reset for an invocation\");\n     }\n }\n \n@@ -585,9 +592,9 @@ impl DefPathData {\n     }\n }\n \n-// We define the GlobalMetaDataKind enum with this macro because we want to\n+// We define the `GlobalMetaDataKind` enum with this macro because we want to\n // make sure that we exhaustively iterate over all variants when registering\n-// the corresponding DefIndices in the DefTable.\n+// the corresponding `DefIndex`es in the `DefTable`.\n macro_rules! define_global_metadata_kind {\n     (pub enum GlobalMetaDataKind {\n         $($variant:ident),*\n@@ -609,7 +616,7 @@ macro_rules! define_global_metadata_kind {\n                         DUMMY_SP\n                     );\n \n-                    // Make sure calling def_index does not crash.\n+                    // Make sure calling `def_index` does not crash.\n                     instance.def_index(&definitions.table);\n                 })*\n             }\n@@ -623,7 +630,7 @@ macro_rules! define_global_metadata_kind {\n                     }\n                 };\n \n-                // These DefKeys are all right after the root,\n+                // These `DefKey`s are all right after the root,\n                 // so a linear search is fine.\n                 let index = def_path_table.index_to_key\n                                           .iter()"}, {"sha": "5cec8a593f12af42337d18b12bf41164b2a516f1", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 38, "deletions": 32, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,10 +5,15 @@ pub use self::definitions::{\n };\n \n use crate::dep_graph::{DepGraph, DepNode, DepKind, DepNodeIndex};\n-\n+use crate::hir::*;\n+use crate::hir::DefKind;\n use crate::hir::def_id::{CRATE_DEF_INDEX, DefId, LocalDefId};\n-\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir::print::Nested;\n use crate::middle::cstore::CrateStoreDyn;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::FxHashMap;\n+use crate::util::common::time;\n \n use rustc_target::spec::abi::Abi;\n use rustc_data_structures::svh::Svh;\n@@ -18,15 +23,7 @@ use syntax::source_map::Spanned;\n use syntax::ext::base::MacroKind;\n use syntax_pos::{Span, DUMMY_SP};\n \n-use crate::hir::*;\n-use crate::hir::DefKind;\n-use crate::hir::itemlikevisit::ItemLikeVisitor;\n-use crate::hir::print::Nested;\n-use crate::util::nodemap::FxHashMap;\n-use crate::util::common::time;\n-\n use std::result::Result::Err;\n-use crate::ty::query::Providers;\n \n pub mod blocks;\n mod collector;\n@@ -360,7 +357,7 @@ impl<'hir> Map<'hir> {\n             Node::Pat(_) |\n             Node::Binding(_) |\n             Node::Local(_) |\n-            Node::Arg(_) |\n+            Node::Param(_) |\n             Node::Arm(_) |\n             Node::Lifetime(_) |\n             Node::Visibility(_) |\n@@ -514,8 +511,7 @@ impl<'hir> Map<'hir> {\n         &self.forest.krate.attrs\n     }\n \n-    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId)\n-    {\n+    pub fn get_module(&self, module: DefId) -> (&'hir Mod, Span, HirId) {\n         let hir_id = self.as_local_hir_id(module).unwrap();\n         self.read(hir_id);\n         match self.find_entry(hir_id).unwrap().node {\n@@ -525,7 +521,7 @@ impl<'hir> Map<'hir> {\n                 ..\n             }) => (m, span, hir_id),\n             Node::Crate => (&self.forest.krate.module, self.forest.krate.span, hir_id),\n-            _ => panic!(\"not a module\")\n+            node => panic!(\"not a module: {:?}\", node),\n         }\n     }\n \n@@ -628,7 +624,7 @@ impl<'hir> Map<'hir> {\n             .unwrap_or(hir_id)\n     }\n \n-    /// Check if the node is an argument. An argument is a local variable whose\n+    /// Checks if the node is an argument. An argument is a local variable whose\n     /// immediate parent is an item or a closure.\n     pub fn is_argument(&self, id: HirId) -> bool {\n         match self.find(id) {\n@@ -679,6 +675,16 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n+    /// Wether `hir_id` corresponds to a `mod` or a crate.\n+    pub fn is_hir_id_module(&self, hir_id: HirId) -> bool {\n+        match self.lookup(hir_id) {\n+            Some(Entry { node: Node::Item(Item { node: ItemKind::Mod(_), .. }), .. }) |\n+            Some(Entry { node: Node::Crate, .. }) => true,\n+            _ => false,\n+        }\n+    }\n+\n+\n     /// If there is some error when walking the parents (e.g., a node does not\n     /// have a parent in the map or a node can't be found), then we return the\n     /// last good `HirId` we found. Note that reaching the crate root (`id == 0`),\n@@ -724,7 +730,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     if x == 1 {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     } else {  // to this, it will return `foo`'s `HirId`.\n     ///         false\n     ///     }\n@@ -734,7 +740,7 @@ impl<'hir> Map<'hir> {\n     /// ```\n     /// fn foo(x: usize) -> bool {\n     ///     loop {\n-    ///         true  // `get_return_block` gets passed the `id` corresponding\n+    ///         true  // If `get_return_block` gets passed the `id` corresponding\n     ///     }         // to this, it will return `None`.\n     ///     false\n     /// }\n@@ -955,7 +961,7 @@ impl<'hir> Map<'hir> {\n     pub fn attrs(&self, id: HirId) -> &'hir [ast::Attribute] {\n         self.read(id); // reveals attributes on the node\n         let attrs = match self.find_entry(id).map(|entry| entry.node) {\n-            Some(Node::Arg(a)) => Some(&a.attrs[..]),\n+            Some(Node::Param(a)) => Some(&a.attrs[..]),\n             Some(Node::Local(l)) => Some(&l.attrs[..]),\n             Some(Node::Item(i)) => Some(&i.attrs[..]),\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n@@ -985,9 +991,9 @@ impl<'hir> Map<'hir> {\n         self.map.iter().enumerate().filter_map(|(i, local_map)| {\n             local_map.as_ref().map(|m| (i, m))\n         }).flat_map(move |(array_index, local_map)| {\n-            // Iterate over each valid entry in the local map\n+            // Iterate over each valid entry in the local map.\n             local_map.iter_enumerated().filter_map(move |(i, entry)| entry.map(move |_| {\n-                // Reconstruct the HirId based on the 3 indices we used to find it\n+                // Reconstruct the `HirId` based on the 3 indices we used to find it.\n                 HirId {\n                     owner: DefIndex::from(array_index),\n                     local_id: i,\n@@ -1019,7 +1025,7 @@ impl<'hir> Map<'hir> {\n     pub fn span(&self, hir_id: HirId) -> Span {\n         self.read(hir_id); // reveals span from node\n         match self.find_entry(hir_id).map(|entry| entry.node) {\n-            Some(Node::Arg(arg)) => arg.span,\n+            Some(Node::Param(param)) => param.span,\n             Some(Node::Item(item)) => item.span,\n             Some(Node::ForeignItem(foreign_item)) => foreign_item.span,\n             Some(Node::TraitItem(trait_method)) => trait_method.span,\n@@ -1198,7 +1204,7 @@ pub fn map_crate<'hir>(sess: &crate::session::Session,\n         definitions,\n     };\n \n-    time(sess, \"validate hir map\", || {\n+    time(sess, \"validate HIR map\", || {\n         hir_id_validator::check_crate(&map);\n     });\n \n@@ -1214,15 +1220,15 @@ impl<'hir> print::PpAnn for Map<'hir> {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n \n impl<'a> print::State<'a> {\n     pub fn print_node(&mut self, node: Node<'_>) {\n         match node {\n-            Node::Arg(a)          => self.print_arg(&a),\n+            Node::Param(a)        => self.print_param(&a),\n             Node::Item(a)         => self.print_item(&a),\n             Node::ForeignItem(a)  => self.print_foreign_item(&a),\n             Node::TraitItem(a)    => self.print_trait_item(a),\n@@ -1238,18 +1244,18 @@ impl<'a> print::State<'a> {\n             Node::Pat(a)          => self.print_pat(&a),\n             Node::Arm(a)          => self.print_arm(&a),\n             Node::Block(a)        => {\n-                // containing cbox, will be closed by print-block at }\n+                // Containing cbox, will be closed by print-block at `}`.\n                 self.cbox(print::INDENT_UNIT);\n-                // head-ibox, will be closed by print-block after {\n+                // Head-ibox, will be closed by print-block after `{`.\n                 self.ibox(0);\n                 self.print_block(&a)\n             }\n             Node::Lifetime(a)     => self.print_lifetime(&a),\n             Node::Visibility(a)   => self.print_visibility(&a),\n             Node::GenericParam(_) => bug!(\"cannot print Node::GenericParam\"),\n             Node::Field(_)        => bug!(\"cannot print StructField\"),\n-            // these cases do not carry enough information in the\n-            // hir_map to reconstruct their full structure for pretty\n+            // These cases do not carry enough information in the\n+            // `hir_map` to reconstruct their full structure for pretty\n             // printing.\n             Node::Ctor(..)        => bug!(\"cannot print isolated Ctor\"),\n             Node::Local(a)        => self.print_local_decl(&a),\n@@ -1264,8 +1270,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n     let id_str = if include_id { &id_str[..] } else { \"\" };\n \n     let path_str = || {\n-        // This functionality is used for debugging, try to use TyCtxt to get\n-        // the user-friendly path, otherwise fall back to stringifying DefPath.\n+        // This functionality is used for debugging, try to use `TyCtxt` to get\n+        // the user-friendly path, otherwise fall back to stringifying `DefPath`.\n         crate::ty::tls::with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n                 let def_id = map.local_def_id(id);\n@@ -1364,8 +1370,8 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         Some(Node::Pat(_)) => {\n             format!(\"pat {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n-        Some(Node::Arg(_)) => {\n-            format!(\"arg {}{}\", map.hir_to_pretty_string(id), id_str)\n+        Some(Node::Param(_)) => {\n+            format!(\"param {}{}\", map.hir_to_pretty_string(id), id_str)\n         }\n         Some(Node::Arm(_)) => {\n             format!(\"arm {}{}\", map.hir_to_pretty_string(id), id_str)"}, {"sha": "92a8c008047333b2394b7b0c232032835669a93d", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 49, "deletions": 38, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -13,26 +13,24 @@ pub use self::UnsafeSource::*;\n use crate::hir::def::{Res, DefKind};\n use crate::hir::def_id::{DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX};\n use crate::hir::ptr::P;\n-use crate::util::nodemap::{NodeMap, FxHashSet};\n use crate::mir::mono::Linkage;\n+use crate::ty::AdtKind;\n+use crate::ty::query::Providers;\n+use crate::util::nodemap::{NodeMap, FxHashSet};\n \n use errors::FatalError;\n use syntax_pos::{Span, DUMMY_SP, symbol::InternedString, MultiSpan};\n use syntax::source_map::Spanned;\n-use rustc_target::spec::abi::Abi;\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n use syntax::attr::{InlineAttr, OptimizeAttr};\n use syntax::symbol::{Symbol, kw};\n use syntax::tokenstream::TokenStream;\n use syntax::util::parser::ExprPrecedence;\n-use crate::ty::AdtKind;\n-use crate::ty::query::Providers;\n-\n+use rustc_target::spec::abi::Abi;\n use rustc_data_structures::sync::{par_for_each_in, Send, Sync};\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_macros::HashStable;\n-\n use rustc_serialize::{self, Encoder, Encodable, Decoder, Decodable};\n use std::collections::{BTreeSet, BTreeMap};\n use std::fmt;\n@@ -99,7 +97,8 @@ impl rustc_serialize::UseSpecializedEncodable for HirId {\n         } = *self;\n \n         owner.encode(s)?;\n-        local_id.encode(s)\n+        local_id.encode(s)?;\n+        Ok(())\n     }\n }\n \n@@ -121,7 +120,7 @@ impl fmt::Display for HirId {\n     }\n }\n \n-// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module\n+// Hack to ensure that we don't try to access the private parts of `ItemLocalId` in this module.\n mod item_local_id_inner {\n     use rustc_data_structures::indexed_vec::Idx;\n     use rustc_macros::HashStable;\n@@ -191,7 +190,7 @@ pub enum ParamName {\n     Fresh(usize),\n \n     /// Indicates an illegal name was given and an error has been\n-    /// repored (so we should squelch other derived errors). Occurs\n+    /// reported (so we should squelch other derived errors). Occurs\n     /// when, e.g., `'_` is used in the wrong place.\n     Error,\n }\n@@ -746,7 +745,7 @@ pub struct Crate {\n     // Attributes from non-exported macros, kept only for collecting the library feature list.\n     pub non_exported_macro_attrs: HirVec<Attribute>,\n \n-    // N.B., we use a BTreeMap here so that `visit_all_items` iterates\n+    // N.B., we use a `BTreeMap` here so that `visit_all_items` iterates\n     // over the ids in increasing order. In principle it should not\n     // matter what order we visit things in, but in *practice* it\n     // does, because it can affect the order in which errors are\n@@ -1030,7 +1029,7 @@ pub enum Mutability {\n }\n \n impl Mutability {\n-    /// Returns `MutMutable` only if both arguments are mutable.\n+    /// Returns `MutMutable` only if both `self` and `other` are mutable.\n     pub fn and(self, other: Self) -> Self {\n         match self {\n             MutMutable => other,\n@@ -1324,15 +1323,15 @@ pub struct BodyId {\n ///\n /// Here, the `Body` associated with `foo()` would contain:\n ///\n-/// - an `arguments` array containing the `(x, y)` pattern\n+/// - an `params` array containing the `(x, y)` pattern\n /// - a `value` containing the `x + y` expression (maybe wrapped in a block)\n /// - `generator_kind` would be `None`\n ///\n /// All bodies have an **owner**, which can be accessed via the HIR\n /// map using `body_owner_def_id()`.\n #[derive(RustcEncodable, RustcDecodable, Debug)]\n pub struct Body {\n-    pub arguments: HirVec<Arg>,\n+    pub params: HirVec<Param>,\n     pub value: Expr,\n     pub generator_kind: Option<GeneratorKind>,\n }\n@@ -1403,13 +1402,13 @@ pub struct AnonConst {\n     pub body: BodyId,\n }\n \n-/// An expression\n+/// An expression.\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct Expr {\n-    pub span: Span,\n+    pub hir_id: HirId,\n     pub node: ExprKind,\n     pub attrs: ThinVec<Attribute>,\n-    pub hir_id: HirId,\n+    pub span: Span,\n }\n \n // `Expr` is used a lot. Make sure it doesn't unintentionally get bigger.\n@@ -1644,7 +1643,7 @@ pub enum LocalSource {\n     /// A desugared `for _ in _ { .. }` loop.\n     ForLoopDesugar,\n     /// When lowering async functions, we create locals within the `async move` so that\n-    /// all arguments are dropped after the future is polled.\n+    /// all parameters are dropped after the future is polled.\n     ///\n     /// ```ignore (pseudo-Rust)\n     /// async fn foo(<pattern> @ x: Type) {\n@@ -1940,7 +1939,7 @@ pub struct BareFnTy {\n     pub abi: Abi,\n     pub generic_params: HirVec<GenericParam>,\n     pub decl: P<FnDecl>,\n-    pub arg_names: HirVec<Ident>,\n+    pub param_names: HirVec<Ident>,\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n@@ -2027,9 +2026,9 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect,\n }\n \n-/// Represents an argument in a function header.\n+/// Represents a parameter in a function header.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct Arg {\n+pub struct Param {\n     pub attrs: HirVec<Attribute>,\n     pub hir_id: HirId,\n     pub pat: P<Pat>,\n@@ -2039,9 +2038,9 @@ pub struct Arg {\n /// Represents the header (not the body) of a function declaration.\n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub struct FnDecl {\n-    /// The types of the function's arguments.\n+    /// The types of the function's parameters.\n     ///\n-    /// Additional argument data is stored in the function's [body](Body::arguments).\n+    /// Additional argument data is stored in the function's [body](Body::parameters).\n     pub inputs: HirVec<Ty>,\n     pub output: FunctionRetTy,\n     pub c_variadic: bool,\n@@ -2422,37 +2421,37 @@ pub enum ItemKind {\n     ///\n     /// or just\n     ///\n-    /// `use foo::bar::baz;` (with `as baz` implicitly on the right)\n+    /// `use foo::bar::baz;` (with `as baz` implicitly on the right).\n     Use(P<Path>, UseKind),\n \n-    /// A `static` item\n+    /// A `static` item.\n     Static(P<Ty>, Mutability, BodyId),\n-    /// A `const` item\n+    /// A `const` item.\n     Const(P<Ty>, BodyId),\n-    /// A function declaration\n+    /// A function declaration.\n     Fn(P<FnDecl>, FnHeader, Generics, BodyId),\n-    /// A module\n+    /// A module.\n     Mod(Mod),\n-    /// An external module\n+    /// An external module.\n     ForeignMod(ForeignMod),\n-    /// Module-level inline assembly (from global_asm!)\n+    /// Module-level inline assembly (from `global_asm!`).\n     GlobalAsm(P<GlobalAsm>),\n-    /// A type alias, e.g., `type Foo = Bar<u8>`\n+    /// A type alias, e.g., `type Foo = Bar<u8>`.\n     TyAlias(P<Ty>, Generics),\n-    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`\n+    /// An opaque `impl Trait` type alias, e.g., `type Foo = impl Bar;`.\n     OpaqueTy(OpaqueTy),\n-    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`\n+    /// An enum definition, e.g., `enum Foo<A, B> {C<A>, D<B>}`.\n     Enum(EnumDef, Generics),\n-    /// A struct definition, e.g., `struct Foo<A> {x: A}`\n+    /// A struct definition, e.g., `struct Foo<A> {x: A}`.\n     Struct(VariantData, Generics),\n-    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`\n+    /// A union definition, e.g., `union Foo<A, B> {x: A, y: B}`.\n     Union(VariantData, Generics),\n-    /// A trait definition\n+    /// A trait definition.\n     Trait(IsAuto, Unsafety, Generics, GenericBounds, HirVec<TraitItemRef>),\n-    /// A trait alias\n+    /// A trait alias.\n     TraitAlias(Generics, GenericBounds),\n \n-    /// An implementation, eg `impl<A> Trait for Foo { .. }`\n+    /// An implementation, e.g., `impl<A> Trait for Foo { .. }`.\n     Impl(Unsafety,\n          ImplPolarity,\n          Defaultness,\n@@ -2721,7 +2720,7 @@ impl CodegenFnAttrs {\n \n #[derive(Copy, Clone, Debug)]\n pub enum Node<'hir> {\n-    Arg(&'hir Arg),\n+    Param(&'hir Param),\n     Item(&'hir Item),\n     ForeignItem(&'hir ForeignItem),\n     TraitItem(&'hir TraitItem),\n@@ -2751,3 +2750,15 @@ pub enum Node<'hir> {\n \n     Crate,\n }\n+\n+impl Node<'_> {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self {\n+            Node::TraitItem(TraitItem { ident, .. }) |\n+            Node::ImplItem(ImplItem { ident, .. }) |\n+            Node::ForeignItem(ForeignItem { ident, .. }) |\n+            Node::Item(Item { ident, .. }) => Some(*ident),\n+            _ => None,\n+        }\n+    }\n+}"}, {"sha": "cfbfb5eceb550f4016afe6b49f82cc29b462de5b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -33,7 +33,7 @@ pub enum Nested {\n     TraitItem(hir::TraitItemId),\n     ImplItem(hir::ImplItemId),\n     Body(hir::BodyId),\n-    BodyArgPat(hir::BodyId, usize)\n+    BodyParamPat(hir::BodyId, usize)\n }\n \n pub trait PpAnn {\n@@ -62,7 +62,7 @@ impl PpAnn for hir::Crate {\n             Nested::TraitItem(id) => state.print_trait_item(self.trait_item(id)),\n             Nested::ImplItem(id) => state.print_impl_item(self.impl_item(id)),\n             Nested::Body(id) => state.print_expr(&self.body(id).value),\n-            Nested::BodyArgPat(id, i) => state.print_pat(&self.body(id).arguments[i].pat)\n+            Nested::BodyParamPat(id, i) => state.print_pat(&self.body(id).params[i].pat)\n         }\n     }\n }\n@@ -318,7 +318,7 @@ impl<'a> State<'a> {\n             }\n             hir::TyKind::BareFn(ref f) => {\n                 self.print_ty_fn(f.abi, f.unsafety, &f.decl, None, &f.generic_params,\n-                                 &f.arg_names[..]);\n+                                 &f.param_names[..]);\n             }\n             hir::TyKind::Def(..) => {},\n             hir::TyKind::Path(ref qpath) => {\n@@ -1290,14 +1290,14 @@ impl<'a> State<'a> {\n             hir::ExprKind::Closure(capture_clause, ref decl, body, _fn_decl_span, _gen) => {\n                 self.print_capture_clause(capture_clause);\n \n-                self.print_closure_args(&decl, body);\n+                self.print_closure_params(&decl, body);\n                 self.s.space();\n \n-                // this is a bare expression\n+                // This is a bare expression.\n                 self.ann.nested(self, Nested::Body(body));\n                 self.end(); // need to close a box\n \n-                // a box will be closed by print_expr, but we didn't want an overall\n+                // A box will be closed by `print_expr`, but we didn't want an overall\n                 // wrapper so we closed the corresponding opening. so create an\n                 // empty box to satisfy the close.\n                 self.ibox(0);\n@@ -1307,9 +1307,9 @@ impl<'a> State<'a> {\n                     self.print_ident(label.ident);\n                     self.word_space(\":\");\n                 }\n-                // containing cbox, will be closed by print-block at }\n+                // containing cbox, will be closed by print-block at `}`\n                 self.cbox(INDENT_UNIT);\n-                // head-box, will be closed by print-block after {\n+                // head-box, will be closed by print-block after `{`\n                 self.ibox(0);\n                 self.print_block(&blk);\n             }\n@@ -1759,7 +1759,7 @@ impl<'a> State<'a> {\n                         self.word_space(\",\");\n                     }\n                     if let PatKind::Wild = p.node {\n-                        // Print nothing\n+                        // Print nothing.\n                     } else {\n                         self.print_pat(&p);\n                     }\n@@ -1775,7 +1775,7 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Pat(pat))\n     }\n \n-    pub fn print_arg(&mut self, arg: &hir::Arg) {\n+    pub fn print_param(&mut self, arg: &hir::Param) {\n         self.print_outer_attributes(&arg.attrs);\n         self.print_pat(&arg.pat);\n     }\n@@ -1864,7 +1864,7 @@ impl<'a> State<'a> {\n                 s.s.word(\":\");\n                 s.s.space();\n             } else if let Some(body_id) = body_id {\n-                s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+                s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n                 s.s.word(\":\");\n                 s.s.space();\n             }\n@@ -1881,17 +1881,17 @@ impl<'a> State<'a> {\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    fn print_closure_args(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n+    fn print_closure_params(&mut self, decl: &hir::FnDecl, body_id: hir::BodyId) {\n         self.s.word(\"|\");\n         let mut i = 0;\n         self.commasep(Inconsistent, &decl.inputs, |s, ty| {\n             s.ibox(INDENT_UNIT);\n \n-            s.ann.nested(s, Nested::BodyArgPat(body_id, i));\n+            s.ann.nested(s, Nested::BodyParamPat(body_id, i));\n             i += 1;\n \n             if let hir::TyKind::Infer = ty.node {\n-                // Print nothing\n+                // Print nothing.\n             } else {\n                 s.s.word(\":\");\n                 s.s.space();\n@@ -2221,14 +2221,15 @@ impl<'a> State<'a> {\n     }\n }\n \n-// Dup'ed from parse::classify, but adapted for the HIR.\n /// Does this expression require a semicolon to be treated\n /// as a statement? The negation of this: 'can this expression\n /// be used as a statement without a semicolon' -- is used\n /// as an early-bail-out in the parser so that, for instance,\n ///     if true {...} else {...}\n ///      |x| 5\n /// isn't parsed as (if true {...} else {...} | x) | 5\n+//\n+// Duplicated from `parse::classify`, but adapted for the HIR.\n fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     match e.node {\n         hir::ExprKind::Match(..) |\n@@ -2238,7 +2239,7 @@ fn expr_requires_semi_to_be_stmt(e: &hir::Expr) -> bool {\n     }\n }\n \n-/// this statement requires a semicolon after it.\n+/// This statement requires a semicolon after it.\n /// note that in one case (stmt_semi), we've already\n /// seen the semicolon, and thus don't need another.\n fn stmt_ends_with_semi(stmt: &hir::StmtKind) -> bool {\n@@ -2277,7 +2278,7 @@ fn bin_op_to_assoc_op(op: hir::BinOpKind) -> AssocOp {\n     }\n }\n \n-/// Expressions that syntactically contain an \"exterior\" struct literal i.e., not surrounded by any\n+/// Expressions that syntactically contain an \"exterior\" struct literal, i.e., not surrounded by any\n /// parens or other delimiters, e.g., `X { y: 1 }`, `X { y: 1 }.method()`, `foo == X { y: 1 }` and\n /// `X { y: 1 } == foo` all do, but `(X { y: 1 }) == foo` does not.\n fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n@@ -2287,20 +2288,20 @@ fn contains_exterior_struct_lit(value: &hir::Expr) -> bool {\n         hir::ExprKind::Assign(ref lhs, ref rhs) |\n         hir::ExprKind::AssignOp(_, ref lhs, ref rhs) |\n         hir::ExprKind::Binary(_, ref lhs, ref rhs) => {\n-            // X { y: 1 } + X { y: 2 }\n+            // `X { y: 1 } + X { y: 2 }`\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n         hir::ExprKind::Unary(_, ref x) |\n         hir::ExprKind::Cast(ref x, _) |\n         hir::ExprKind::Type(ref x, _) |\n         hir::ExprKind::Field(ref x, _) |\n         hir::ExprKind::Index(ref x, _) => {\n-            // &X { y: 1 }, X { y: 1 }.y\n+            // `&X { y: 1 }, X { y: 1 }.y`\n             contains_exterior_struct_lit(&x)\n         }\n \n         hir::ExprKind::MethodCall(.., ref exprs) => {\n-            // X { y: 1 }.bar(...)\n+            // `X { y: 1 }.bar(...)`\n             contains_exterior_struct_lit(&exprs[0])\n         }\n "}, {"sha": "182a9ade8c36ead44a39da901c9126bc1cf5c4b3", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 25, "deletions": 29, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -12,17 +12,16 @@ use std::hash as std_hash;\n use std::cell::RefCell;\n \n use syntax::ast;\n-\n use syntax::source_map::SourceMap;\n use syntax::ext::hygiene::SyntaxContext;\n use syntax::symbol::Symbol;\n use syntax::tokenstream::DelimSpan;\n use syntax_pos::{Span, DUMMY_SP};\n use syntax_pos::hygiene;\n \n-use rustc_data_structures::stable_hasher::{HashStable,\n-                                           StableHasher, StableHasherResult,\n-                                           ToStableHashKey};\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, ToStableHashKey,\n+};\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n use smallvec::SmallVec;\n \n@@ -32,9 +31,9 @@ fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n }\n \n /// This is the context state available during incr. comp. hashing. It contains\n-/// enough information to transform DefIds and HirIds into stable DefPaths (i.e.\n-/// a reference to the TyCtxt) and it holds a few caches for speeding up various\n-/// things (e.g., each DefId/DefPath is only hashed once).\n+/// enough information to transform `DefId`s and `HirId`s into stable `DefPath`s (i.e.,\n+/// a reference to the `TyCtxt`) and it holds a few caches for speeding up various\n+/// things (e.g., each `DefId`/`DefPath` is only hashed once).\n #[derive(Clone)]\n pub struct StableHashingContext<'a> {\n     sess: &'a Session,\n@@ -46,7 +45,7 @@ pub struct StableHashingContext<'a> {\n     node_id_hashing_mode: NodeIdHashingMode,\n \n     // Very often, we are hashing something that does not need the\n-    // CachingSourceMapView, so we initialize it lazily.\n+    // `CachingSourceMapView`, so we initialize it lazily.\n     raw_source_map: &'a SourceMap,\n     caching_source_map: Option<CachingSourceMapView<'a>>,\n }\n@@ -57,24 +56,24 @@ pub enum NodeIdHashingMode {\n     HashDefPath,\n }\n \n-/// The BodyResolver allows to map a BodyId to the corresponding hir::Body.\n-/// We could also just store a plain reference to the hir::Crate but we want\n+/// The `BodyResolver` allows mapping a `BodyId` to the corresponding `hir::Body`.\n+/// We could also just store a plain reference to the `hir::Crate` but we want\n /// to avoid that the crate is used to get untracked access to all of the HIR.\n #[derive(Clone, Copy)]\n struct BodyResolver<'tcx>(&'tcx hir::Crate);\n \n impl<'tcx> BodyResolver<'tcx> {\n-    // Return a reference to the hir::Body with the given BodyId.\n-    // DOES NOT DO ANY TRACKING, use carefully.\n+    /// Returns a reference to the `hir::Body` with the given `BodyId`.\n+    /// **Does not do any tracking**; use carefully.\n     fn body(self, id: hir::BodyId) -> &'tcx hir::Body {\n         self.0.body(id)\n     }\n }\n \n impl<'a> StableHashingContext<'a> {\n-    // The `krate` here is only used for mapping BodyIds to Bodies.\n-    // Don't use it for anything else or you'll run the risk of\n-    // leaking data out of the tracking system.\n+    /// The `krate` here is only used for mapping `BodyId`s to `Body`s.\n+    /// Don't use it for anything else or you'll run the risk of\n+    /// leaking data out of the tracking system.\n     #[inline]\n     pub fn new(sess: &'a Session,\n                krate: &'a hir::Crate,\n@@ -217,9 +216,7 @@ impl<'a> StableHashingContextProvider<'a> for StableHashingContext<'a> {\n     }\n }\n \n-impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {\n-}\n-\n+impl<'a> crate::dep_graph::DepGraphSafe for StableHashingContext<'a> {}\n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::BodyId {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -292,16 +289,15 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for ast::NodeId {\n }\n \n impl<'a> HashStable<StableHashingContext<'a>> for Span {\n-\n-    // Hash a span in a stable way. We can't directly hash the span's BytePos\n-    // fields (that would be similar to hashing pointers, since those are just\n-    // offsets into the SourceMap). Instead, we hash the (file name, line, column)\n-    // triple, which stays the same even if the containing SourceFile has moved\n-    // within the SourceMap.\n-    // Also note that we are hashing byte offsets for the column, not unicode\n-    // codepoint offsets. For the purpose of the hash that's sufficient.\n-    // Also, hashing filenames is expensive so we avoid doing it twice when the\n-    // span starts and ends in the same file, which is almost always the case.\n+    /// Hashes a span in a stable way. We can't directly hash the span's `BytePos`\n+    /// fields (that would be similar to hashing pointers, since those are just\n+    /// offsets into the `SourceMap`). Instead, we hash the (file name, line, column)\n+    /// triple, which stays the same even if the containing `SourceFile` has moved\n+    /// within the `SourceMap`.\n+    /// Also note that we are hashing byte offsets for the column, not unicode\n+    /// codepoint offsets. For the purpose of the hash that's sufficient.\n+    /// Also, hashing filenames is expensive so we avoid doing it twice when the\n+    /// span starts and ends in the same file, which is almost always the case.\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n@@ -340,7 +336,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Span {\n         }\n \n         std_hash::Hash::hash(&TAG_VALID_SPAN, hasher);\n-        // We truncate the stable_id hash and line and col numbers. The chances\n+        // We truncate the stable ID hash and line and column numbers. The chances\n         // of causing a collision this way should be minimal.\n         std_hash::Hash::hash(&(file_lo.name_hash as u64), hasher);\n "}, {"sha": "6e6492d0426f257c7fe9927b9361f9c9c5a3bf48", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,8 +5,10 @@ use crate::hir;\n use crate::hir::map::DefPathHash;\n use crate::hir::def_id::{DefId, LocalDefId, CrateNum, CRATE_DEF_INDEX};\n use crate::ich::{StableHashingContext, NodeIdHashingMode, Fingerprint};\n-use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n-                                           StableHasher, StableHasherResult};\n+\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, ToStableHashKey, StableHasher, StableHasherResult,\n+};\n use smallvec::SmallVec;\n use std::mem;\n use syntax::ast;\n@@ -82,9 +84,9 @@ for hir::ItemLocalId {\n     }\n }\n \n-// The following implementations of HashStable for ItemId, TraitItemId, and\n-// ImplItemId deserve special attention. Normally we do not hash NodeIds within\n-// the HIR, since they just signify a HIR nodes own path. But ItemId et al\n+// The following implementations of HashStable for `ItemId`, `TraitItemId`, and\n+// `ImplItemId` deserve special attention. Normally we do not hash `NodeId`s within\n+// the HIR, since they just signify a HIR nodes own path. But `ItemId` et al\n // are used when another item in the HIR is *referenced* and we certainly\n // want to pick up on a reference changing its target, so we hash the NodeIds\n // in \"DefPath Mode\".\n@@ -131,7 +133,6 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItemId {\n     }\n }\n \n-\n impl_stable_hash_for!(struct ast::Label {\n     ident\n });\n@@ -241,7 +242,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n     }\n }\n \n-impl_stable_hash_for!(enum ::syntax::ast::CrateSugar {\n+impl_stable_hash_for!(enum ast::CrateSugar {\n     JustCrate,\n     PubCrate,\n });\n@@ -331,13 +332,13 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Body {\n                                           hcx: &mut StableHashingContext<'a>,\n                                           hasher: &mut StableHasher<W>) {\n         let hir::Body {\n-            arguments,\n+            params,\n             value,\n             generator_kind,\n         } = self;\n \n         hcx.with_node_id_hashing_mode(NodeIdHashingMode::Ignore, |hcx| {\n-            arguments.hash_stable(hcx, hasher);\n+            params.hash_stable(hcx, hasher);\n             value.hash_stable(hcx, hasher);\n             generator_kind.hash_stable(hcx, hasher);\n         });\n@@ -365,8 +366,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     }\n }\n \n-impl<'a> ToStableHashKey<StableHashingContext<'a>>\n-for hir::def_id::DefIndex {\n+impl<'a> ToStableHashKey<StableHashingContext<'a>> for hir::def_id::DefIndex {\n     type KeyType = DefPathHash;\n \n     #[inline]"}, {"sha": "a33181e5925cda13aef96e1b5f138237beb138e3", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 24, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -9,7 +9,7 @@ use std::mem;\n use syntax::ast;\n use syntax::feature_gate;\n use syntax::parse::token;\n-use syntax::symbol::{InternedString, LocalInternedString};\n+use syntax::symbol::InternedString;\n use syntax::tokenstream;\n use syntax_pos::SourceFile;\n \n@@ -39,27 +39,6 @@ impl<'a> ToStableHashKey<StableHashingContext<'a>> for InternedString {\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for LocalInternedString {\n-    #[inline]\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a>,\n-                                          hasher: &mut StableHasher<W>) {\n-        let s: &str = &**self;\n-        s.hash_stable(hcx, hasher);\n-    }\n-}\n-\n-impl<'a> ToStableHashKey<StableHashingContext<'a>> for LocalInternedString {\n-    type KeyType = LocalInternedString;\n-\n-    #[inline]\n-    fn to_stable_hash_key(&self,\n-                          _: &StableHashingContext<'a>)\n-                          -> LocalInternedString {\n-        self.clone()\n-    }\n-}\n-\n impl<'a> HashStable<StableHashingContext<'a>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -136,9 +115,10 @@ for ::syntax::attr::StabilityLevel {\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue } => {\n+            ::syntax::attr::StabilityLevel::Unstable { ref reason, ref issue, ref is_soft } => {\n                 reason.hash_stable(hcx, hasher);\n                 issue.hash_stable(hcx, hasher);\n+                is_soft.hash_stable(hcx, hasher);\n             }\n             ::syntax::attr::StabilityLevel::Stable { ref since } => {\n                 since.hash_stable(hcx, hasher);\n@@ -402,7 +382,6 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n     parent -> _,\n     call_site,\n     def_site,\n-    default_transparency,\n     allow_internal_unstable,\n     allow_internal_unsafe,\n     local_inner_macros,\n@@ -412,9 +391,17 @@ impl_stable_hash_for!(struct ::syntax_pos::hygiene::ExpnData {\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnKind {\n     Root,\n     Macro(kind, descr),\n+    AstPass(kind),\n     Desugaring(kind)\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::hygiene::AstPass {\n+    StdImports,\n+    TestHarness,\n+    ProcMacroHarness,\n+    PluginMacroDefs,\n+});\n+\n impl_stable_hash_for!(enum ::syntax_pos::hygiene::DesugaringKind {\n     CondTemporary,\n     Async,"}, {"sha": "f230c53728748d4a215cc7186a98b79303977fee", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -168,25 +168,21 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n     }\n }\n \n-// Allocations treat their relocations specially\n-impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::Allocation {\n+// `Relocations` with default type parameters is a sorted map.\n+impl<'a, Tag> HashStable<StableHashingContext<'a>>\n+for mir::interpret::Relocations<Tag>\n+where\n+    Tag: HashStable<StableHashingContext<'a>>,\n+{\n     fn hash_stable<W: StableHasherResult>(\n         &self,\n         hcx: &mut StableHashingContext<'a>,\n         hasher: &mut StableHasher<W>,\n     ) {\n-        let mir::interpret::Allocation {\n-            bytes, relocations, undef_mask, align, mutability,\n-            extra: _,\n-        } = self;\n-        bytes.hash_stable(hcx, hasher);\n-        relocations.len().hash_stable(hcx, hasher);\n-        for reloc in relocations.iter() {\n+        self.len().hash_stable(hcx, hasher);\n+        for reloc in self.iter() {\n             reloc.hash_stable(hcx, hasher);\n         }\n-        undef_mask.hash_stable(hcx, hasher);\n-        align.hash_stable(hcx, hasher);\n-        mutability.hash_stable(hcx, hasher);\n     }\n }\n \n@@ -208,7 +204,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::TyVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // TyVid values are confined to an inference context and hence\n+        // `TyVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a TyVid {:?}.\", *self)\n     }\n@@ -218,7 +214,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::IntVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // IntVid values are confined to an inference context and hence\n+        // `IntVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash an IntVid {:?}.\", *self)\n     }\n@@ -228,7 +224,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::FloatVid {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _hcx: &mut StableHashingContext<'a>,\n                                           _hasher: &mut StableHasher<W>) {\n-        // FloatVid values are confined to an inference context and hence\n+        // `FloatVid` values are confined to an inference context and hence\n         // should not be hashed.\n         bug!(\"ty::TyKind::hash_stable() - can't hash a FloatVid {:?}.\", *self)\n     }"}, {"sha": "966c5810171af34535fbe00e289ae9486bf45b05", "filename": "src/librustc/infer/combine.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcombine.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -30,6 +30,7 @@ use super::sub::Sub;\n use super::type_variable::TypeVariableValue;\n use super::unify_key::{ConstVarValue, ConstVariableValue};\n use super::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n+use super::unify_key::replace_if_possible;\n \n use crate::hir::def_id::DefId;\n use crate::mir::interpret::ConstValue;\n@@ -127,6 +128,12 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     where\n         R: TypeRelation<'tcx>,\n     {\n+        debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n+        if a == b { return Ok(a); }\n+\n+        let a = replace_if_possible(self.const_unification_table.borrow_mut(), a);\n+        let b = replace_if_possible(self.const_unification_table.borrow_mut(), b);\n+\n         let a_is_expected = relation.a_is_expected();\n \n         match (a.val, b.val) {"}, {"sha": "6065387647fa758ae3a7f9b5c0e25245c0f29395", "filename": "src/librustc/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 38, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fequate.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,14 +1,12 @@\n-use super::combine::{CombineFields, RelationDir, const_unification_error};\n+use super::combine::{CombineFields, RelationDir};\n use super::Subtype;\n \n use crate::hir::def_id::DefId;\n \n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::TyVar;\n use crate::ty::subst::SubstsRef;\n use crate::ty::relate::{self, Relate, RelateResult, TypeRelation};\n-use crate::mir::interpret::ConstValue;\n-use crate::infer::unify_key::replace_if_possible;\n \n /// Ensures `a` is made equal to `b`. Returns `a` on success.\n pub struct Equate<'combine, 'infcx, 'tcx> {\n@@ -97,7 +95,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n                self.tag(),\n                a,\n                b);\n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_eqregion(origin, a, b);\n         Ok(a)\n@@ -108,39 +106,7 @@ impl TypeRelation<'tcx> for Equate<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b { return Ok(a); }\n-\n-        let infcx = self.fields.infcx;\n-        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n-        let a_is_expected = self.a_is_expected();\n-\n-        match (a.val, b.val) {\n-            (ConstValue::Infer(InferConst::Var(a_vid)),\n-                ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                infcx.const_unification_table\n-                    .borrow_mut()\n-                    .unify_var_var(a_vid, b_vid)\n-                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                return Ok(a);\n-            }\n-\n-            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                return Ok(a);\n-            }\n-\n-            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                return Ok(a);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.fields.infcx.super_combine_consts(self, a, b)?;\n-        Ok(a)\n+        self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "0b6740d7bbbc88ee3234d0e756c3b278f0f9a968", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 30, "deletions": 17, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -55,7 +55,8 @@ use crate::hir::def_id::DefId;\n use crate::hir::Node;\n use crate::infer::opaque_types;\n use crate::middle::region;\n-use crate::traits::{ObligationCause, ObligationCauseCode};\n+use crate::traits::{IfExpressionCause, MatchExpressionArmCause, ObligationCause};\n+use crate::traits::{ObligationCauseCode};\n use crate::ty::error::TypeError;\n use crate::ty::{self, subst::{Subst, SubstsRef}, Region, Ty, TyCtxt, TypeFoldable};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n@@ -624,13 +625,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n-            ObligationCauseCode::MatchExpressionArm {\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n                 ..\n-            } => match source {\n+            }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n                     let msg = \"`if let` arms have incompatible types\";\n                     err.span_label(cause.span, msg);\n@@ -681,7 +682,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             },\n-            ObligationCauseCode::IfExpression { then, outer, semicolon } => {\n+            ObligationCauseCode::IfExpression(box IfExpressionCause { then, outer, semicolon }) => {\n                 err.span_label(then, \"expected because of this\");\n                 outer.map(|sp| err.span_label(sp, \"if and else have incompatible types\"));\n                 if let Some(sp) = semicolon {\n@@ -1118,7 +1119,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     Some((expected, found)) => Some((expected, found)),\n                     None => {\n                         // Derived error. Cancel the emitter.\n-                        self.tcx.sess.diagnostic().cancel(diag);\n+                        diag.cancel();\n                         return;\n                     }\n                 };\n@@ -1136,12 +1137,19 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         if let Some((expected, found)) = expected_found {\n             match (terr, is_simple_error, expected == found) {\n                 (&TypeError::Sorts(ref values), false, true) => {\n+                    let sort_string = | a_type: Ty<'tcx> |\n+                        if let ty::Opaque(def_id, _) = a_type.sty {\n+                            format!(\" (opaque type at {})\", self.tcx.sess.source_map()\n+                                .mk_substr_filename(self.tcx.def_span(def_id)))\n+                        } else {\n+                            format!(\" ({})\", a_type.sort_string(self.tcx))\n+                        };\n                     diag.note_expected_found_extra(\n                         &\"type\",\n                         expected,\n                         found,\n-                        &format!(\" ({})\", values.expected.sort_string(self.tcx)),\n-                        &format!(\" ({})\", values.found.sort_string(self.tcx)),\n+                        &sort_string(values.expected),\n+                        &sort_string(values.found),\n                     );\n                 }\n                 (_, false, _) => {\n@@ -1615,19 +1623,21 @@ impl<'tcx> ObligationCause<'tcx> {\n         use crate::traits::ObligationCauseCode::*;\n         match self.code {\n             CompareImplMethodObligation { .. } => Error0308(\"method not compatible with trait\"),\n-            MatchExpressionArm { source, .. } => Error0308(match source {\n-                hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have incompatible types\",\n-                hir::MatchSource::TryDesugar => {\n-                    \"try expression alternatives have incompatible types\"\n-                }\n-                _ => \"match arms have incompatible types\",\n-            }),\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) =>\n+                Error0308(match source {\n+                    hir::MatchSource::IfLetDesugar { .. } =>\n+                        \"`if let` arms have incompatible types\",\n+                    hir::MatchSource::TryDesugar => {\n+                        \"try expression alternatives have incompatible types\"\n+                    }\n+                    _ => \"match arms have incompatible types\",\n+                }),\n             IfExpression { .. } => Error0308(\"if and else have incompatible types\"),\n             IfExpressionWithNoElse => Error0317(\"if may be missing an else clause\"),\n             MainFunctionType => Error0580(\"main function has wrong type\"),\n             StartFunctionType => Error0308(\"start function has wrong type\"),\n             IntrinsicType => Error0308(\"intrinsic has wrong type\"),\n-            MethodReceiver => Error0308(\"mismatched method receiver\"),\n+            MethodReceiver => Error0308(\"mismatched `self` parameter type\"),\n \n             // In the case where we have no more specific thing to\n             // say, also take a look at the error code, maybe we can\n@@ -1636,6 +1646,9 @@ impl<'tcx> ObligationCause<'tcx> {\n                 TypeError::CyclicTy(ty) if ty.is_closure() || ty.is_generator() => {\n                     Error0644(\"closure/generator type that references itself\")\n                 }\n+                TypeError::IntrinsicCast => {\n+                    Error0308(\"cannot coerce intrinsics to function pointers\")\n+                }\n                 _ => Error0308(\"mismatched types\"),\n             },\n         }\n@@ -1646,11 +1659,11 @@ impl<'tcx> ObligationCause<'tcx> {\n         match self.code {\n             CompareImplMethodObligation { .. } => \"method type is compatible with trait\",\n             ExprAssignable => \"expression is assignable\",\n-            MatchExpressionArm { source, .. } => match source {\n+            MatchExpressionArm(box MatchExpressionArmCause { source, .. }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => \"`if let` arms have compatible types\",\n                 _ => \"match arms have compatible types\",\n             },\n-            IfExpression { .. } => \"if and else have compatible types\",\n+            IfExpression { .. } => \"if and else have incompatible types\",\n             IfExpressionWithNoElse => \"if missing an else returns ()\",\n             MainFunctionType => \"`main` function has the correct type\",\n             StartFunctionType => \"`start` function has the correct type\","}, {"sha": "7068fe3601a62de8e562237094ce5afde888a230", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 35, "deletions": 10, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -78,12 +78,12 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_body(&mut self, body: &'tcx Body) {\n-        for argument in &body.arguments {\n+        for param in &body.params {\n             if let (None, Some(ty)) = (\n                 self.found_arg_pattern,\n-                self.node_matches_type(argument.hir_id),\n+                self.node_matches_type(param.hir_id),\n             ) {\n-                self.found_arg_pattern = Some(&*argument.pat);\n+                self.found_arg_pattern = Some(&*param.pat);\n                 self.found_ty = Some(ty);\n             }\n         }\n@@ -150,12 +150,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         ty: Ty<'tcx>,\n         highlight: Option<ty::print::RegionHighlightMode>,\n-    ) -> String {\n+    ) -> (String, Option<Span>) {\n         if let ty::Infer(ty::TyVar(ty_vid)) = ty.sty {\n             let ty_vars = self.type_variables.borrow();\n-            if let TypeVariableOriginKind::TypeParameterDefinition(name) =\n-                ty_vars.var_origin(ty_vid).kind {\n-                return name.to_string();\n+            let var_origin = ty_vars.var_origin(ty_vid);\n+            if let TypeVariableOriginKind::TypeParameterDefinition(name) = var_origin.kind {\n+                return (name.to_string(), Some(var_origin.span));\n             }\n         }\n \n@@ -165,7 +165,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             printer.region_highlight_mode = highlight;\n         }\n         let _ = ty.print(printer);\n-        s\n+        (s, None)\n     }\n \n     pub fn need_type_info_err(\n@@ -175,7 +175,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let (name, name_sp) = self.extract_type_name(&ty, None);\n \n         let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n@@ -200,6 +200,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n         let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n             pattern.span\n+        } else if let Some(span) = name_sp {\n+            // `span` here lets us point at `sum` instead of the entire right hand side expr:\n+            // error[E0282]: type annotations needed\n+            //  --> file2.rs:3:15\n+            //   |\n+            // 3 |     let _ = x.sum() as f64;\n+            //   |               ^^^ cannot infer type for `S`\n+            span\n         } else {\n             span\n         };\n@@ -325,6 +333,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             };\n             err.span_label(pattern.span, msg);\n         }\n+        // Instead of the following:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |             --^^^--------- cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        // We want:\n+        // error[E0282]: type annotations needed\n+        //  --> file2.rs:3:15\n+        //   |\n+        // 3 |     let _ = x.sum() as f64;\n+        //   |               ^^^ cannot infer type for `S`\n+        //   |\n+        //   = note: type must be known at this point\n+        let span = name_sp.unwrap_or(span);\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span\n             }) && local_visitor.found_arg_pattern.is_none()\n@@ -342,7 +367,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) -> DiagnosticBuilder<'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n-        let name = self.extract_type_name(&ty, None);\n+        let name = self.extract_type_name(&ty, None).0;\n         let mut err = struct_span_err!(\n             self.tcx.sess, span, E0698, \"type inside {} must be known in this context\", kind,\n         );"}, {"sha": "979815fa7f1843199df09f4e141df8a246abf387", "filename": "src/librustc/infer/error_reporting/nice_region_error/different_lifetimes.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fdifferent_lifetimes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -2,7 +2,7 @@\n //! where both the regions are anonymous.\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n-use crate::infer::error_reporting::nice_region_error::util::AnonymousArgInfo;\n+use crate::infer::error_reporting::nice_region_error::util::AnonymousParamInfo;\n use crate::util::common::ErrorReported;\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n@@ -59,13 +59,13 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let ty_sub = self.find_anon_type(sub, &bregion_sub)?;\n \n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg1={:?} sup={:?} br1={:?}\",\n+            \"try_report_anon_anon_conflict: found_param1={:?} sup={:?} br1={:?}\",\n             ty_sub,\n             sup,\n             bregion_sup\n         );\n         debug!(\n-            \"try_report_anon_anon_conflict: found_arg2={:?} sub={:?} br2={:?}\",\n+            \"try_report_anon_anon_conflict: found_param2={:?} sub={:?} br2={:?}\",\n             ty_sup,\n             sub,\n             bregion_sub\n@@ -74,24 +74,24 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         let (ty_sup, ty_fndecl_sup) = ty_sup;\n         let (ty_sub, ty_fndecl_sub) = ty_sub;\n \n-        let AnonymousArgInfo {\n-            arg: anon_arg_sup, ..\n-        } = self.find_arg_with_region(sup, sup)?;\n-        let AnonymousArgInfo {\n-            arg: anon_arg_sub, ..\n-        } = self.find_arg_with_region(sub, sub)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sup, ..\n+        } = self.find_param_with_region(sup, sup)?;\n+        let AnonymousParamInfo {\n+            param: anon_param_sub, ..\n+        } = self.find_param_with_region(sub, sub)?;\n \n         let sup_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sup, bregion_sup, ty_fndecl_sup);\n         let sub_is_ret_type =\n             self.is_return_type_anon(scope_def_id_sub, bregion_sub, ty_fndecl_sub);\n \n-        let span_label_var1 = match anon_arg_sup.pat.simple_ident() {\n+        let span_label_var1 = match anon_param_sup.pat.simple_ident() {\n             Some(simple_ident) => format!(\" from `{}`\", simple_ident),\n             None => String::new(),\n         };\n \n-        let span_label_var2 = match anon_arg_sub.pat.simple_ident() {\n+        let span_label_var2 = match anon_param_sub.pat.simple_ident() {\n             Some(simple_ident) => format!(\" into `{}`\", simple_ident),\n             None => String::new(),\n         };"}, {"sha": "604115cfc371157225e7ca912bdb6797a1cd41cd", "filename": "src/librustc/infer/error_reporting/nice_region_error/named_anon_conflict.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fnamed_anon_conflict.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -6,7 +6,7 @@ use crate::ty;\n use errors::{Applicability, DiagnosticBuilder};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    /// When given a `ConcreteFailure` for a function with arguments containing a named region and\n+    /// When given a `ConcreteFailure` for a function with parameters containing a named region and\n     /// an anonymous region, emit an descriptive diagnostic error.\n     pub(super) fn try_report_named_anon_conflict(&self) -> Option<DiagnosticBuilder<'a>> {\n         let (span, sub, sup) = self.get_regions();\n@@ -24,23 +24,23 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // only introduced anonymous regions in parameters) as well as a\n         // version new_ty of its type where the anonymous region is replaced\n         // with the named one.//scope_def_id\n-        let (named, anon, anon_arg_info, region_info) = if self.is_named_region(sub)\n+        let (named, anon, anon_param_info, region_info) = if self.is_named_region(sub)\n             && self.tcx().is_suitable_region(sup).is_some()\n-            && self.find_arg_with_region(sup, sub).is_some()\n+            && self.find_param_with_region(sup, sub).is_some()\n         {\n             (\n                 sub,\n                 sup,\n-                self.find_arg_with_region(sup, sub).unwrap(),\n+                self.find_param_with_region(sup, sub).unwrap(),\n                 self.tcx().is_suitable_region(sup).unwrap(),\n             )\n         } else if self.is_named_region(sup) && self.tcx().is_suitable_region(sub).is_some()\n-            && self.find_arg_with_region(sub, sup).is_some()\n+            && self.find_param_with_region(sub, sup).is_some()\n         {\n             (\n                 sup,\n                 sub,\n-                self.find_arg_with_region(sub, sup).unwrap(),\n+                self.find_param_with_region(sub, sup).unwrap(),\n                 self.tcx().is_suitable_region(sub).unwrap(),\n             )\n         } else {\n@@ -49,20 +49,20 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n \n         debug!(\"try_report_named_anon_conflict: named = {:?}\", named);\n         debug!(\n-            \"try_report_named_anon_conflict: anon_arg_info = {:?}\",\n-            anon_arg_info\n+            \"try_report_named_anon_conflict: anon_param_info = {:?}\",\n+            anon_param_info\n         );\n         debug!(\n             \"try_report_named_anon_conflict: region_info = {:?}\",\n             region_info\n         );\n \n-        let (arg, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n-            anon_arg_info.arg,\n-            anon_arg_info.arg_ty,\n-            anon_arg_info.arg_ty_span,\n-            anon_arg_info.bound_region,\n-            anon_arg_info.is_first,\n+        let (param, new_ty, new_ty_span, br, is_first, scope_def_id, is_impl_item) = (\n+            anon_param_info.param,\n+            anon_param_info.param_ty,\n+            anon_param_info.param_ty_span,\n+            anon_param_info.bound_region,\n+            anon_param_info.is_first,\n             region_info.def_id,\n             region_info.is_impl_item,\n         );\n@@ -95,7 +95,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n             }\n         }\n \n-        let (error_var, span_label_var) = match arg.pat.simple_ident() {\n+        let (error_var, span_label_var) = match param.pat.simple_ident() {\n             Some(simple_ident) => (\n                 format!(\"the type of `{}`\", simple_ident),\n                 format!(\"the type of `{}`\", simple_ident),"}, {"sha": "bfa8353ca343f0be89499f5a20a6feab856eb07f", "filename": "src/librustc/infer/error_reporting/nice_region_error/placeholder_error.rs", "status": "modified", "additions": 38, "deletions": 29, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fplaceholder_error.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -30,7 +30,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -50,7 +50,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -70,7 +70,7 @@ impl NiceRegionError<'me, 'tcx> {\n             Some(RegionResolutionError::SubSupConflict(\n                 vid,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -92,7 +92,7 @@ impl NiceRegionError<'me, 'tcx> {\n                 _,\n                 _,\n                 _,\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -108,7 +108,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -125,7 +125,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -142,7 +142,7 @@ impl NiceRegionError<'me, 'tcx> {\n             )),\n \n             Some(RegionResolutionError::ConcreteFailure(\n-                SubregionOrigin::Subtype(TypeTrace {\n+                SubregionOrigin::Subtype(box TypeTrace {\n                     cause,\n                     values: ValuePairs::TraitRefs(ExpectedFound { expected, found }),\n                 }),\n@@ -192,23 +192,28 @@ impl NiceRegionError<'me, 'tcx> {\n             vid, sub_placeholder, sup_placeholder, trait_def_id, expected_substs, actual_substs\n         );\n \n-        let mut err = self.tcx().sess.struct_span_err(\n-            cause.span(self.tcx()),\n-            &format!(\n-                \"implementation of `{}` is not general enough\",\n-                self.tcx().def_path_str(trait_def_id),\n-            ),\n+        let span = cause.span(self.tcx());\n+        let msg = format!(\n+            \"implementation of `{}` is not general enough\",\n+            self.tcx().def_path_str(trait_def_id),\n+        );\n+        let mut err = self.tcx().sess.struct_span_err(span, &msg);\n+        err.span_label(\n+            self.tcx().def_span(trait_def_id),\n+            format!(\"trait `{}` defined here\", self.tcx().def_path_str(trait_def_id)),\n         );\n \n-        match cause.code {\n-            ObligationCauseCode::ItemObligation(def_id) => {\n-                err.note(&format!(\n-                    \"Due to a where-clause on `{}`,\",\n-                    self.tcx().def_path_str(def_id),\n-                ));\n-            }\n-            _ => (),\n-        }\n+        let leading_ellipsis = if let ObligationCauseCode::ItemObligation(def_id) = cause.code {\n+            err.span_label(span, \"doesn't satisfy where-clause\");\n+            err.span_label(\n+                self.tcx().def_span(def_id),\n+                &format!(\"due to a where-clause on `{}`...\", self.tcx().def_path_str(def_id)),\n+            );\n+            true\n+        } else {\n+            err.span_label(span, &msg);\n+            false\n+        };\n \n         let expected_trait_ref = self.infcx.resolve_vars_if_possible(&ty::TraitRef {\n             def_id: trait_def_id,\n@@ -295,6 +300,7 @@ impl NiceRegionError<'me, 'tcx> {\n             expected_has_vid,\n             actual_has_vid,\n             any_self_ty_has_vid,\n+            leading_ellipsis,\n         );\n \n         err\n@@ -318,6 +324,7 @@ impl NiceRegionError<'me, 'tcx> {\n         expected_has_vid: Option<usize>,\n         actual_has_vid: Option<usize>,\n         any_self_ty_has_vid: bool,\n+        leading_ellipsis: bool,\n     ) {\n         // HACK(eddyb) maybe move this in a more central location.\n         #[derive(Copy, Clone)]\n@@ -392,13 +399,15 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"`{}` would have to be implemented for the type `{}`\",\n+                    \"{}`{}` would have to be implemented for the type `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref,\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"`{}` must implement `{}`\",\n+                    \"{}`{}` must implement `{}`\",\n+                    if leading_ellipsis { \"...\" } else { \"\" },\n                     expected_trait_ref.map(|tr| tr.self_ty()),\n                     expected_trait_ref,\n                 )\n@@ -407,20 +416,20 @@ impl NiceRegionError<'me, 'tcx> {\n             match (has_sub, has_sup) {\n                 (Some(n1), Some(n2)) => {\n                     let _ = write!(note,\n-                        \", for any two lifetimes `'{}` and `'{}`\",\n+                        \", for any two lifetimes `'{}` and `'{}`...\",\n                         std::cmp::min(n1, n2),\n                         std::cmp::max(n1, n2),\n                     );\n                 }\n                 (Some(n), _) | (_, Some(n)) => {\n                     let _ = write!(note,\n-                        \", for any lifetime `'{}`\",\n+                        \", for any lifetime `'{}`...\",\n                         n,\n                     );\n                 }\n                 (None, None) => if let Some(n) = expected_has_vid {\n                     let _ = write!(note,\n-                        \", for some specific lifetime `'{}`\",\n+                        \", for some specific lifetime `'{}`...\",\n                         n,\n                     );\n                 },\n@@ -439,13 +448,13 @@ impl NiceRegionError<'me, 'tcx> {\n \n             let mut note = if passive_voice {\n                 format!(\n-                    \"but `{}` is actually implemented for the type `{}`\",\n+                    \"...but `{}` is actually implemented for the type `{}`\",\n                     actual_trait_ref,\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                 )\n             } else {\n                 format!(\n-                    \"but `{}` actually implements `{}`\",\n+                    \"...but `{}` actually implements `{}`\",\n                     actual_trait_ref.map(|tr| tr.self_ty()),\n                     actual_trait_ref,\n                 )"}, {"sha": "668c99da0034fa5bc05725fca3406c4a2bc60e0f", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -10,37 +10,37 @@ use syntax_pos::Span;\n // The struct contains the information about the anonymous region\n // we are searching for.\n #[derive(Debug)]\n-pub(super) struct AnonymousArgInfo<'tcx> {\n-    // the argument corresponding to the anonymous region\n-    pub arg: &'tcx hir::Arg,\n-    // the type corresponding to the anonymopus region argument\n-    pub arg_ty: Ty<'tcx>,\n+pub(super) struct AnonymousParamInfo<'tcx> {\n+    // the parameter corresponding to the anonymous region\n+    pub param: &'tcx hir::Param,\n+    // the type corresponding to the anonymopus region parameter\n+    pub param_ty: Ty<'tcx>,\n     // the ty::BoundRegion corresponding to the anonymous region\n     pub bound_region: ty::BoundRegion,\n-    // arg_ty_span contains span of argument type\n-    pub arg_ty_span : Span,\n+    // param_ty_span contains span of parameter type\n+    pub param_ty_span : Span,\n     // corresponds to id the argument is the first parameter\n     // in the declaration\n     pub is_first: bool,\n }\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n-    // This method walks the Type of the function body arguments using\n+    // This method walks the Type of the function body parameters using\n     // `fold_regions()` function and returns the\n-    // &hir::Arg of the function argument corresponding to the anonymous\n+    // &hir::Param of the function parameter corresponding to the anonymous\n     // region and the Ty corresponding to the named region.\n     // Currently only the case where the function declaration consists of\n     // one named region and one anonymous region is handled.\n     // Consider the example `fn foo<'a>(x: &'a i32, y: &i32) -> &'a i32`\n-    // Here, we would return the hir::Arg for y, we return the type &'a\n+    // Here, we would return the hir::Param for y, we return the type &'a\n     // i32, which is the type of y but with the anonymous region replaced\n     // with 'a, the corresponding bound region and is_first which is true if\n-    // the hir::Arg is the first argument in the function declaration.\n-    pub(super) fn find_arg_with_region(\n+    // the hir::Param is the first parameter in the function declaration.\n+    pub(super) fn find_param_with_region(\n         &self,\n         anon_region: Region<'tcx>,\n         replace_region: Region<'tcx>,\n-    ) -> Option<AnonymousArgInfo<'_>> {\n+    ) -> Option<AnonymousParamInfo<'_>> {\n         let (id, bound_region) = match *anon_region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n             ty::ReEarlyBound(ebr) => (\n@@ -57,16 +57,16 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                 let owner_id = hir.body_owner(body_id);\n                 let fn_decl = hir.fn_decl_by_hir_id(owner_id).unwrap();\n                 if let Some(tables) = self.tables {\n-                    body.arguments\n+                    body.params\n                         .iter()\n                         .enumerate()\n-                        .filter_map(|(index, arg)| {\n+                        .filter_map(|(index, param)| {\n                             // May return None; sometimes the tables are not yet populated.\n                             let ty_hir_id = fn_decl.inputs[index].hir_id;\n-                            let arg_ty_span = hir.span(ty_hir_id);\n-                            let ty = tables.node_type_opt(arg.hir_id)?;\n+                            let param_ty_span = hir.span(ty_hir_id);\n+                            let ty = tables.node_type_opt(param.hir_id)?;\n                             let mut found_anon_region = false;\n-                            let new_arg_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n+                            let new_param_ty = self.tcx().fold_regions(&ty, &mut false, |r, _| {\n                                 if *r == *anon_region {\n                                     found_anon_region = true;\n                                     replace_region\n@@ -76,10 +76,10 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                             });\n                             if found_anon_region {\n                                 let is_first = index == 0;\n-                                Some(AnonymousArgInfo {\n-                                    arg: arg,\n-                                    arg_ty: new_arg_ty,\n-                                    arg_ty_span : arg_ty_span,\n+                                Some(AnonymousParamInfo {\n+                                    param: param,\n+                                    param_ty: new_param_ty,\n+                                    param_ty_span : param_ty_span,\n                                     bound_region: bound_region,\n                                     is_first: is_first,\n                                 })"}, {"sha": "115ffea97bf1a47a3e3a0809f3a90163068d70e7", "filename": "src/librustc/infer/error_reporting/note.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnote.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -138,7 +138,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                           sup: Region<'tcx>)\n                                           -> DiagnosticBuilder<'tcx> {\n         match origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n                 let mut err = self.report_and_explain_type_error(trace, &terr);\n                 self.tcx.note_and_explain_region(region_scope_tree, &mut err, \"\", sup, \"...\");\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) -> DiagnosticBuilder<'tcx> {\n         // I can't think how to do better than this right now. -nikomatsakis\n         match placeholder_origin {\n-            infer::Subtype(trace) => {\n+            infer::Subtype(box trace) => {\n                 let terr = TypeError::RegionsPlaceholderMismatch;\n                 self.report_and_explain_type_error(trace, &terr)\n             }"}, {"sha": "37de54a7e8558c520983e904a636fb46e360cfee", "filename": "src/librustc/infer/glb.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fglb.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().glb_regions(self.tcx(), origin, a, b))\n     }\n \n@@ -66,11 +66,6 @@ impl TypeRelation<'tcx> for Glb<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b {\n-            return Ok(a);\n-        }\n-\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n "}, {"sha": "a1a94865e74e3fd680b435839c4597a2473280ce", "filename": "src/librustc/infer/lub.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Flub.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -57,7 +57,7 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n                a,\n                b);\n \n-        let origin = Subtype(self.fields.trace.clone());\n+        let origin = Subtype(box self.fields.trace.clone());\n         Ok(self.fields.infcx.borrow_region_constraints().lub_regions(self.tcx(), origin, a, b))\n     }\n \n@@ -66,11 +66,6 @@ impl TypeRelation<'tcx> for Lub<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b {\n-            return Ok(a);\n-        }\n-\n         self.fields.infcx.super_combine_consts(self, a, b)\n     }\n "}, {"sha": "c5712cc9941a9d84d32dae63876a813360716607", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 48, "deletions": 12, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -254,7 +254,7 @@ pub struct TypeTrace<'tcx> {\n #[derive(Clone, Debug)]\n pub enum SubregionOrigin<'tcx> {\n     /// Arose from a subtyping relation\n-    Subtype(TypeTrace<'tcx>),\n+    Subtype(Box<TypeTrace<'tcx>>),\n \n     /// Stack-allocated closures cannot outlive innermost loop\n     /// or function so as to ensure we only require finite stack\n@@ -340,6 +340,10 @@ pub enum SubregionOrigin<'tcx> {\n     },\n }\n \n+// `SubregionOrigin` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(SubregionOrigin<'_>, 32);\n+\n /// Places that type/region parameters can appear.\n #[derive(Clone, Copy, Debug)]\n pub enum ParameterOrigin {\n@@ -1321,13 +1325,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         if !value.needs_infer() {\n-            return value.clone(); // avoid duplicated subst-folding\n+            return value.clone(); // Avoid duplicated subst-folding.\n         }\n         let mut r = resolve::OpportunisticVarResolver::new(self);\n         value.fold_with(&mut r)\n     }\n \n-    /// Returns first unresolved variable contained in `T`. In the\n+    /// Returns the first unresolved variable contained in `T`. In the\n     /// process of visiting `T`, this will resolve (where possible)\n     /// type variables in `T`, but it never constructs the final,\n     /// resolved type, so it's more efficient than\n@@ -1460,9 +1464,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             }\n         }\n \n-        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+        let copy_def_id = self.tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n \n-        // this can get called from typeck (by euv), and moves_by_default\n+        // This can get called from typeck (by euv), and `moves_by_default`\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n@@ -1482,7 +1486,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         closure_kind_ty.to_opt_closure_kind()\n     }\n \n-    /// Obtain the signature of a closure. For closures, unlike\n+    /// Obtains the signature of a closure. For closures, unlike\n     /// `tcx.fn_sig(def_id)`, this method will work during the\n     /// type-checking of the enclosing function and return the closure\n     /// signature in its partially inferred state.\n@@ -1558,11 +1562,7 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n         ShallowResolver { infcx }\n     }\n \n-    // We have this force-inlined variant of `shallow_resolve` for the one\n-    // callsite that is extremely hot. All other callsites use the normal\n-    // variant.\n-    #[inline(always)]\n-    pub fn inlined_shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n+    pub fn shallow_resolve(&mut self, typ: Ty<'tcx>) -> Ty<'tcx> {\n         match typ.sty {\n             ty::Infer(ty::TyVar(v)) => {\n                 // Not entirely obvious: if `typ` is a type variable,\n@@ -1597,6 +1597,42 @@ impl<'a, 'tcx> ShallowResolver<'a, 'tcx> {\n             _ => typ,\n         }\n     }\n+\n+    // `resolver.shallow_resolve_changed(ty)` is equivalent to\n+    // `resolver.shallow_resolve(ty) != ty`, but more efficient. It's always\n+    // inlined, despite being large, because it has a single call site that is\n+    // extremely hot.\n+    #[inline(always)]\n+    pub fn shallow_resolve_changed(&mut self, typ: Ty<'tcx>) -> bool {\n+        match typ.sty {\n+            ty::Infer(ty::TyVar(v)) => {\n+                use self::type_variable::TypeVariableValue;\n+\n+                // See the comment in `shallow_resolve()`.\n+                match self.infcx.type_variables.borrow_mut().probe(v) {\n+                    TypeVariableValue::Known { value: t } => self.fold_ty(t) != typ,\n+                    TypeVariableValue::Unknown { .. } => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::IntVar(v)) => {\n+                match self.infcx.int_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            ty::Infer(ty::FloatVar(v)) => {\n+                match self.infcx.float_unification_table.borrow_mut().probe_value(v) {\n+                    Some(v) => v.to_type(self.infcx.tcx) != typ,\n+                    None => false,\n+                }\n+            }\n+\n+            _ => false,\n+        }\n+    }\n+\n }\n \n impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n@@ -1605,7 +1641,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for ShallowResolver<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        self.inlined_shallow_resolve(ty)\n+        self.shallow_resolve(ty)\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {"}, {"sha": "67c97ef5d8b295d68650eaf40c4440e7baf02ea6", "filename": "src/librustc/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 40, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fsub.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,13 +1,11 @@\n use super::SubregionOrigin;\n-use super::combine::{CombineFields, RelationDir, const_unification_error};\n+use super::combine::{CombineFields, RelationDir};\n \n use crate::traits::Obligation;\n-use crate::ty::{self, Ty, TyCtxt, InferConst};\n+use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::TyVar;\n use crate::ty::fold::TypeFoldable;\n use crate::ty::relate::{Cause, Relate, RelateResult, TypeRelation};\n-use crate::infer::unify_key::replace_if_possible;\n-use crate::mir::interpret::ConstValue;\n use std::mem;\n \n /// Ensures `a` is made a subtype of `b`. Returns `a` on success.\n@@ -130,7 +128,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         // FIXME -- we have more fine-grained information available\n         // from the \"cause\" field, we could perhaps give more tailored\n         // error messages.\n-        let origin = SubregionOrigin::Subtype(self.fields.trace.clone());\n+        let origin = SubregionOrigin::Subtype(box self.fields.trace.clone());\n         self.fields.infcx.borrow_region_constraints()\n                          .make_subregion(origin, a, b);\n \n@@ -142,41 +140,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n         a: &'tcx ty::Const<'tcx>,\n         b: &'tcx ty::Const<'tcx>,\n     ) -> RelateResult<'tcx, &'tcx ty::Const<'tcx>> {\n-        debug!(\"{}.consts({:?}, {:?})\", self.tag(), a, b);\n-        if a == b { return Ok(a); }\n-\n-        let infcx = self.fields.infcx;\n-        let a = replace_if_possible(infcx.const_unification_table.borrow_mut(), a);\n-        let b = replace_if_possible(infcx.const_unification_table.borrow_mut(), b);\n-\n-        // Consts can only be equal or unequal to each other: there's no subtyping\n-        // relation, so we're just going to perform equating here instead.\n-        let a_is_expected = self.a_is_expected();\n-        match (a.val, b.val) {\n-            (ConstValue::Infer(InferConst::Var(a_vid)),\n-                ConstValue::Infer(InferConst::Var(b_vid))) => {\n-                infcx.const_unification_table\n-                    .borrow_mut()\n-                    .unify_var_var(a_vid, b_vid)\n-                    .map_err(|e| const_unification_error(a_is_expected, e))?;\n-                return Ok(a);\n-            }\n-\n-            (ConstValue::Infer(InferConst::Var(a_id)), _) => {\n-                self.fields.infcx.unify_const_variable(a_is_expected, a_id, b)?;\n-                return Ok(a);\n-            }\n-\n-            (_, ConstValue::Infer(InferConst::Var(b_id))) => {\n-                self.fields.infcx.unify_const_variable(!a_is_expected, b_id, a)?;\n-                return Ok(a);\n-            }\n-\n-            _ => {}\n-        }\n-\n-        self.fields.infcx.super_combine_consts(self, a, b)?;\n-        Ok(a)\n+        self.fields.infcx.super_combine_consts(self, a, b)\n     }\n \n     fn binders<T>(&mut self, a: &ty::Binder<T>, b: &ty::Binder<T>)"}, {"sha": "7a01ae6b6d9ccb546b0f5b251ddfb65a7c4740b3", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -45,7 +45,6 @@\n #![feature(non_exhaustive)]\n #![feature(optin_builtin_traits)]\n #![feature(range_is_empty)]\n-#![feature(rustc_diagnostic_macros)]\n #![feature(slice_patterns)]\n #![feature(specialization)]\n #![feature(unboxed_closures)]\n@@ -62,12 +61,12 @@\n #![feature(log_syntax)]\n #![feature(mem_take)]\n #![feature(associated_type_bounds)]\n+#![feature(rustc_attrs)]\n \n #![recursion_limit=\"512\"]\n \n #[macro_use] extern crate bitflags;\n extern crate getopts;\n-#[macro_use] extern crate lazy_static;\n #[macro_use] extern crate scoped_tls;\n #[cfg(windows)]\n extern crate libc;\n@@ -87,16 +86,13 @@ mod tests;\n #[macro_use]\n mod macros;\n \n-// N.B., this module needs to be declared first so diagnostics are\n-// registered before they are used.\n pub mod error_codes;\n \n #[macro_use]\n pub mod query;\n \n #[macro_use]\n pub mod arena;\n-pub mod cfg;\n pub mod dep_graph;\n pub mod hir;\n pub mod ich;\n@@ -109,6 +105,7 @@ pub mod middle {\n     pub mod cstore;\n     pub mod dead;\n     pub mod dependency_format;\n+    pub mod diagnostic_items;\n     pub mod entry;\n     pub mod exported_symbols;\n     pub mod free_region;\n@@ -141,6 +138,3 @@ pub mod util {\n \n // Allows macros to refer to this crate as `::rustc`\n extern crate self as rustc;\n-\n-// Build the diagnostics array at the end so that the metadata includes error use sites.\n-__build_diagnostic_array! { librustc, DIAGNOSTICS }"}, {"sha": "5906a6388a8bd5209ed84ebb67323ce065d37129", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -7,7 +7,7 @@\n use crate::lint::{LintPass, LateLintPass, LintArray};\n use crate::middle::stability;\n use crate::session::Session;\n-use errors::{Applicability, DiagnosticBuilder};\n+use errors::{Applicability, DiagnosticBuilder, pluralise};\n use syntax::ast;\n use syntax::source_map::Span;\n use syntax::symbol::Symbol;\n@@ -395,6 +395,12 @@ declare_lint! {\n     \"reservation of a two-phased borrow conflicts with other shared borrows\"\n }\n \n+declare_lint! {\n+    pub SOFT_UNSTABLE,\n+    Deny,\n+    \"a feature gate that doesn't break dependent crates\"\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -460,6 +466,7 @@ declare_lint_pass! {\n         NESTED_IMPL_TRAIT,\n         MUTABLE_BORROW_RESERVATION_CONFLICT,\n         INDIRECT_STRUCTURAL_MATCH,\n+        SOFT_UNSTABLE,\n     ]\n }\n \n@@ -517,7 +524,7 @@ pub(crate) fn add_elided_lifetime_in_path_suggestion(\n     };\n     db.span_suggestion(\n         replace_span,\n-        &format!(\"indicate the anonymous lifetime{}\", if n >= 2 { \"s\" } else { \"\" }),\n+        &format!(\"indicate the anonymous lifetime{}\", pluralise!(n)),\n         suggestion,\n         Applicability::MachineApplicable\n     );"}, {"sha": "c658120b95df36a393aa7c773b9f4906cec6971d", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -16,32 +16,32 @@\n \n use self::TargetLint::*;\n \n-use std::slice;\n-use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use crate::hir;\n+use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n+use crate::hir::intravisit as hir_visit;\n+use crate::hir::intravisit::Visitor;\n+use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::{EarlyLintPass, LateLintPass, EarlyLintPassObject, LateLintPassObject};\n use crate::lint::{LintArray, Level, Lint, LintId, LintPass, LintBuffer};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n use crate::middle::privacy::AccessLevels;\n-use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use crate::session::{config, early_error, Session};\n use crate::ty::{self, print::Printer, subst::Kind, TyCtxt, Ty};\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::util::nodemap::FxHashMap;\n use crate::util::common::time;\n \n+use errors::DiagnosticBuilder;\n+use std::slice;\n use std::default::Default as StdDefault;\n+use rustc_data_structures::sync::{ReadGuard, Lock, ParallelIterator, join, par_iter};\n+use rustc_serialize::{Decoder, Decodable, Encoder, Encodable};\n use syntax::ast;\n use syntax::edition;\n-use syntax_pos::{MultiSpan, Span, symbol::{LocalInternedString, Symbol}};\n-use errors::DiagnosticBuilder;\n-use crate::hir;\n-use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use crate::hir::intravisit as hir_visit;\n-use crate::hir::intravisit::Visitor;\n-use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax::visit as ast_visit;\n+use syntax_pos::{MultiSpan, Span, symbol::Symbol};\n \n /// Information about the registered lints.\n ///\n@@ -405,7 +405,7 @@ impl LintStore {\n     pub fn check_lint_name(\n         &self,\n         lint_name: &str,\n-        tool_name: Option<LocalInternedString>,\n+        tool_name: Option<Symbol>,\n     ) -> CheckLintNameResult<'_> {\n         let complete_name = if let Some(tool_name) = tool_name {\n             format!(\"{}::{}\", tool_name, lint_name)\n@@ -966,10 +966,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n         self.context.tables = old_tables;\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |cx| {\n-            lint_callback!(cx, check_arg, arg);\n-            hir_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1040,13 +1040,13 @@ for LateContextAndPass<'a, 'tcx, T> {\n \n     fn visit_variant_data(&mut self,\n                         s: &'tcx hir::VariantData,\n-                        name: ast::Name,\n-                        g: &'tcx hir::Generics,\n-                        item_id: hir::HirId,\n+                        _: ast::Name,\n+                        _: &'tcx hir::Generics,\n+                        _: hir::HirId,\n                         _: Span) {\n-        lint_callback!(self, check_struct_def, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def, s);\n         hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s, name, g, item_id);\n+        lint_callback!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'tcx hir::StructField) {\n@@ -1061,9 +1061,9 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n         self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v, g);\n+            lint_callback!(cx, check_variant, v);\n             hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v, g);\n+            lint_callback!(cx, check_variant_post, v);\n         })\n     }\n \n@@ -1163,10 +1163,10 @@ for LateContextAndPass<'a, 'tcx, T> {\n }\n \n impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_arg(&mut self, arg: &'a ast::Arg) {\n-        self.with_lint_attrs(arg.id, &arg.attrs, |cx| {\n-            run_early_pass!(cx, check_arg, arg);\n-            ast_visit::walk_arg(cx, arg);\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n         });\n     }\n \n@@ -1214,18 +1214,13 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         run_early_pass!(self, check_fn_post, fk, decl, span, id);\n     }\n \n-    fn visit_variant_data(&mut self,\n-                        s: &'a ast::VariantData,\n-                        ident: ast::Ident,\n-                        g: &'a ast::Generics,\n-                        item_id: ast::NodeId,\n-                        _: Span) {\n-        run_early_pass!(self, check_struct_def, s, ident, g, item_id);\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n         if let Some(ctor_hir_id) = s.ctor_id() {\n             self.check_id(ctor_hir_id);\n         }\n         ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s, ident, g, item_id);\n+        run_early_pass!(self, check_struct_def_post, s);\n     }\n \n     fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n@@ -1235,11 +1230,11 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n         })\n     }\n \n-    fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v, g);\n-            ast_visit::walk_variant(cx, v, g, item_id);\n-            run_early_pass!(cx, check_variant_post, v, g);\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n         })\n     }\n "}, {"sha": "13834eaf40f576591e17ac71c75536a31bc4ac38", "filename": "src/librustc/lint/internal.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Finternal.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -159,29 +159,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TyTyKind {\n }\n \n fn lint_ty_kind_usage(cx: &LateContext<'_, '_>, segment: &PathSegment) -> bool {\n-    if segment.ident.name == sym::TyKind {\n-        if let Some(res) = segment.res {\n-            if let Some(did) = res.opt_def_id() {\n-                return cx.match_def_path(did, TYKIND_PATH);\n-            }\n+    if let Some(res) = segment.res {\n+        if let Some(did) = res.opt_def_id() {\n+            return cx.tcx.is_diagnostic_item(sym::TyKind, did);\n         }\n     }\n \n     false\n }\n \n-const TYKIND_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::sty, sym::TyKind];\n-const TY_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::Ty];\n-const TYCTXT_PATH: &[Symbol] = &[sym::rustc, sym::ty, sym::context, sym::TyCtxt];\n-\n fn is_ty_or_ty_ctxt(cx: &LateContext<'_, '_>, ty: &Ty) -> Option<String> {\n     match &ty.node {\n         TyKind::Path(qpath) => {\n             if let QPath::Resolved(_, path) = qpath {\n                 let did = path.res.opt_def_id()?;\n-                if cx.match_def_path(did, TY_PATH) {\n+                if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n                     return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-                } else if cx.match_def_path(did, TYCTXT_PATH) {\n+                } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n                     return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n                 }\n             }"}, {"sha": "cbc6dbdba7e6cc9716f29a7c2e8c295291c483ea", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -291,7 +291,7 @@ impl<'a> LintLevelsBuilder<'a> {\n                         continue;\n                     }\n \n-                    Some(tool_ident.as_str())\n+                    Some(tool_ident.name)\n                 } else {\n                     None\n                 };"}, {"sha": "5b490b701267deae304e620ddce0e8178eb2b305", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 41, "deletions": 57, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -206,7 +206,7 @@ macro_rules! declare_lint_pass {\n macro_rules! late_lint_methods {\n     ($macro:path, $args:tt, [$hir:tt]) => (\n         $macro!($args, [$hir], [\n-            fn check_arg(a: &$hir hir::Arg);\n+            fn check_param(a: &$hir hir::Param);\n             fn check_body(a: &$hir hir::Body);\n             fn check_body_post(a: &$hir hir::Body);\n             fn check_name(a: Span, b: ast::Name);\n@@ -248,21 +248,11 @@ macro_rules! late_lint_methods {\n             fn check_trait_item_post(a: &$hir hir::TraitItem);\n             fn check_impl_item(a: &$hir hir::ImplItem);\n             fn check_impl_item_post(a: &$hir hir::ImplItem);\n-            fn check_struct_def(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n-            fn check_struct_def_post(\n-                a: &$hir hir::VariantData,\n-                b: ast::Name,\n-                c: &$hir hir::Generics,\n-                d: hir::HirId\n-            );\n+            fn check_struct_def(a: &$hir hir::VariantData);\n+            fn check_struct_def_post(a: &$hir hir::VariantData);\n             fn check_struct_field(a: &$hir hir::StructField);\n-            fn check_variant(a: &$hir hir::Variant, b: &$hir hir::Generics);\n-            fn check_variant_post(a: &$hir hir::Variant, b: &$hir hir::Generics);\n+            fn check_variant(a: &$hir hir::Variant);\n+            fn check_variant_post(a: &$hir hir::Variant);\n             fn check_lifetime(a: &$hir hir::Lifetime);\n             fn check_path(a: &$hir hir::Path, b: hir::HirId);\n             fn check_attribute(a: &$hir ast::Attribute);\n@@ -359,7 +349,7 @@ macro_rules! declare_combined_late_lint_pass {\n macro_rules! early_lint_methods {\n     ($macro:path, $args:tt) => (\n         $macro!($args, [\n-            fn check_arg(a: &ast::Arg);\n+            fn check_param(a: &ast::Param);\n             fn check_ident(a: ast::Ident);\n             fn check_crate(a: &ast::Crate);\n             fn check_crate_post(a: &ast::Crate);\n@@ -395,21 +385,11 @@ macro_rules! early_lint_methods {\n             fn check_trait_item_post(a: &ast::TraitItem);\n             fn check_impl_item(a: &ast::ImplItem);\n             fn check_impl_item_post(a: &ast::ImplItem);\n-            fn check_struct_def(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n-            fn check_struct_def_post(\n-                a: &ast::VariantData,\n-                b: ast::Ident,\n-                c: &ast::Generics,\n-                d: ast::NodeId\n-            );\n+            fn check_struct_def(a: &ast::VariantData);\n+            fn check_struct_def_post(a: &ast::VariantData);\n             fn check_struct_field(a: &ast::StructField);\n-            fn check_variant(a: &ast::Variant, b: &ast::Generics);\n-            fn check_variant_post(a: &ast::Variant, b: &ast::Generics);\n+            fn check_variant(a: &ast::Variant);\n+            fn check_variant_post(a: &ast::Variant);\n             fn check_lifetime(a: &ast::Lifetime);\n             fn check_path(a: &ast::Path, b: ast::NodeId);\n             fn check_attribute(a: &ast::Attribute);\n@@ -666,6 +646,30 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         (Level::Forbid, None) => sess.struct_err(msg),\n     };\n \n+    // Check for future incompatibility lints and issue a stronger warning.\n+    let lints = sess.lint_store.borrow();\n+    let lint_id = LintId::of(lint);\n+    let future_incompatible = lints.future_incompatible(lint_id);\n+\n+    // If this code originates in a foreign macro, aka something that this crate\n+    // did not itself author, then it's likely that there's nothing this crate\n+    // can do about it. We probably want to skip the lint entirely.\n+    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n+        // Any suggestions made here are likely to be incorrect, so anything we\n+        // emit shouldn't be automatically fixed by rustfix.\n+        err.allow_suggestions(false);\n+\n+        // If this is a future incompatible lint it'll become a hard error, so\n+        // we have to emit *something*. Also allow lints to whitelist themselves\n+        // on a case-by-case basis for emission in a foreign macro.\n+        if future_incompatible.is_none() && !lint.report_in_external_macro {\n+            err.cancel();\n+            // Don't continue further, since we don't want to have\n+            // `diag_span_note_once` called for a diagnostic that isn't emitted.\n+            return err;\n+        }\n+    }\n+\n     let name = lint.name_lower();\n     match src {\n         LintSource::Default => {\n@@ -715,10 +719,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n \n     err.code(DiagnosticId::Lint(name));\n \n-    // Check for future incompatibility lints and issue a stronger warning.\n-    let lints = sess.lint_store.borrow();\n-    let lint_id = LintId::of(lint);\n-    let future_incompatible = lints.future_incompatible(lint_id);\n     if let Some(future_incompatible) = future_incompatible {\n         const STANDARD_MESSAGE: &str =\n             \"this was previously accepted by the compiler but is being phased out; \\\n@@ -743,22 +743,6 @@ pub fn struct_lint_level<'a>(sess: &'a Session,\n         err.note(&citation);\n     }\n \n-    // If this code originates in a foreign macro, aka something that this crate\n-    // did not itself author, then it's likely that there's nothing this crate\n-    // can do about it. We probably want to skip the lint entirely.\n-    if err.span.primary_spans().iter().any(|s| in_external_macro(sess, *s)) {\n-        // Any suggestions made here are likely to be incorrect, so anything we\n-        // emit shouldn't be automatically fixed by rustfix.\n-        err.allow_suggestions(false);\n-\n-        // If this is a future incompatible lint it'll become a hard error, so\n-        // we have to emit *something*. Also allow lints to whitelist themselves\n-        // on a case-by-case basis for emission in a foreign macro.\n-        if future_incompatible.is_none() && !lint.report_in_external_macro {\n-            err.cancel()\n-        }\n-    }\n-\n     return err\n }\n \n@@ -812,9 +796,9 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n         intravisit::NestedVisitorMap::All(&self.tcx.hir())\n     }\n \n-    fn visit_arg(&mut self, arg: &'tcx hir::Arg) {\n-        self.with_lint_attrs(arg.hir_id, &arg.attrs, |builder| {\n-            intravisit::walk_arg(builder, arg);\n+    fn visit_param(&mut self, param: &'tcx hir::Param) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+            intravisit::walk_param(builder, param);\n         });\n     }\n \n@@ -888,23 +872,23 @@ pub fn in_external_macro(sess: &Session, span: Span) -> bool {\n     let expn_data = span.ctxt().outer_expn_data();\n     match expn_data.kind {\n         ExpnKind::Root | ExpnKind::Desugaring(DesugaringKind::ForLoop) => false,\n-        ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n+        ExpnKind::AstPass(_) | ExpnKind::Desugaring(_) => true, // well, it's \"external\"\n         ExpnKind::Macro(MacroKind::Bang, _) => {\n             if expn_data.def_site.is_dummy() {\n-                // dummy span for the def_site means it's an external macro\n+                // Dummy span for the `def_site` means it's an external macro.\n                 return true;\n             }\n             match sess.source_map().span_to_snippet(expn_data.def_site) {\n                 Ok(code) => !code.starts_with(\"macro_rules\"),\n-                // no snippet = external macro or compiler-builtin expansion\n+                // No snippet means external macro or compiler-builtin expansion.\n                 Err(_) => true,\n             }\n         }\n         ExpnKind::Macro(..) => true, // definitely a plugin\n     }\n }\n \n-/// Returns whether `span` originates in a derive macro's expansion\n+/// Returns `true` if `span` originates in a derive-macro's expansion.\n pub fn in_derive_expansion(span: Span) -> bool {\n     if let ExpnKind::Macro(MacroKind::Derive, _) = span.ctxt().outer_expn_data().kind {\n         return true;"}, {"sha": "d4805a7c7832252731a46186446e7c35298d4a43", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -30,10 +30,11 @@ fn should_explore(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n         Some(Node::Item(..)) |\n         Some(Node::ImplItem(..)) |\n         Some(Node::ForeignItem(..)) |\n-        Some(Node::TraitItem(..)) =>\n-            true,\n-        _ =>\n-            false\n+        Some(Node::TraitItem(..)) |\n+        Some(Node::Variant(..)) |\n+        Some(Node::AnonConst(..)) |\n+        Some(Node::Pat(..)) => true,\n+        _ => false\n     }\n }\n \n@@ -75,7 +76,7 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 self.check_def_id(res.def_id());\n             }\n             _ if self.in_pat => {},\n-            Res::PrimTy(..) | Res::SelfTy(..) | Res::SelfCtor(..) |\n+            Res::PrimTy(..) | Res::SelfCtor(..) |\n             Res::Local(..) => {}\n             Res::Def(DefKind::Ctor(CtorOf::Variant, ..), ctor_def_id) => {\n                 let variant_id = self.tcx.parent(ctor_def_id).unwrap();\n@@ -92,6 +93,14 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     self.check_def_id(variant_id);\n                 }\n             }\n+            Res::SelfTy(t, i) => {\n+                if let Some(t) = t {\n+                    self.check_def_id(t);\n+                }\n+                if let Some(i) = i {\n+                    self.check_def_id(i);\n+                }\n+            }\n             Res::ToolMod | Res::NonMacroAttr(..) | Res::Err => {}\n             _ => {\n                 self.check_def_id(res.def_id());\n@@ -271,7 +280,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n                 let res = self.tables.qpath_res(path, pat.hir_id);\n                 self.handle_field_pattern_match(pat, res, fields);\n             }\n-            PatKind::Path(ref qpath @ hir::QPath::TypeRelative(..)) => {\n+            PatKind::Path(ref qpath) => {\n                 let res = self.tables.qpath_res(qpath, pat.hir_id);\n                 self.handle_res(res);\n             }\n@@ -298,6 +307,11 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkSymbolVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_ty(self, ty);\n     }\n+\n+    fn visit_anon_const(&mut self, c: &'tcx hir::AnonConst) {\n+        self.live_symbols.insert(c.hir_id);\n+        intravisit::walk_anon_const(self, c);\n+    }\n }\n \n fn has_allow_dead_code_or_lang_attr("}, {"sha": "dfae169b27824abe35d7242c0c6ee3e7ac66139e", "filename": "src/librustc/middle/diagnostic_items.rs", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdiagnostic_items.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -0,0 +1,123 @@\n+//! Detecting diagnostic items.\n+//!\n+//! Diagnostic items are items that are not language-inherent, but can reasonably be expected to\n+//! exist for diagnostic purposes. This allows diagnostic authors to refer to specific items\n+//! directly, without having to guess module paths and crates.\n+//! Examples are:\n+//!\n+//! * Traits like `Debug`, that have no bearing on language semantics\n+//!\n+//! * Compiler internal types like `Ty` and `TyCtxt`\n+\n+use crate::hir::def_id::{DefId, LOCAL_CRATE};\n+use crate::ty::TyCtxt;\n+use crate::util::nodemap::FxHashMap;\n+\n+use syntax::ast;\n+use syntax::symbol::{Symbol, sym};\n+use crate::hir::itemlikevisit::ItemLikeVisitor;\n+use crate::hir;\n+\n+struct DiagnosticItemCollector<'tcx> {\n+    // items from this crate\n+    items: FxHashMap<Symbol, DefId>,\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'v, 'tcx> ItemLikeVisitor<'v> for DiagnosticItemCollector<'tcx> {\n+    fn visit_item(&mut self, item: &hir::Item) {\n+        self.observe_item(&item.attrs, item.hir_id);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        self.observe_item(&trait_item.attrs, trait_item.hir_id);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        self.observe_item(&impl_item.attrs, impl_item.hir_id);\n+    }\n+}\n+\n+impl<'tcx> DiagnosticItemCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>) -> DiagnosticItemCollector<'tcx> {\n+        DiagnosticItemCollector {\n+            tcx,\n+            items: Default::default(),\n+        }\n+    }\n+\n+    fn observe_item(&mut self, attrs: &[ast::Attribute], hir_id: hir::HirId) {\n+        if let Some(name) = extract(attrs) {\n+            let def_id = self.tcx.hir().local_def_id(hir_id);\n+            // insert into our table\n+            collect_item(self.tcx, &mut self.items, name, def_id);\n+        }\n+    }\n+}\n+\n+fn collect_item(\n+    tcx: TyCtxt<'_>,\n+    items: &mut FxHashMap<Symbol, DefId>,\n+    name: Symbol,\n+    item_def_id: DefId,\n+) {\n+    // Check for duplicates.\n+    if let Some(original_def_id) = items.insert(name, item_def_id) {\n+        if original_def_id != item_def_id {\n+            let mut err = match tcx.hir().span_if_local(item_def_id) {\n+                Some(span) => tcx.sess.struct_span_err(\n+                    span,\n+                    &format!(\"duplicate diagnostic item found: `{}`.\", name)),\n+                None => tcx.sess.struct_err(&format!(\n+                        \"duplicate diagnostic item in crate `{}`: `{}`.\",\n+                        tcx.crate_name(item_def_id.krate),\n+                        name)),\n+            };\n+            if let Some(span) = tcx.hir().span_if_local(original_def_id) {\n+                span_note!(&mut err, span, \"first defined here.\");\n+            } else {\n+                err.note(&format!(\"first defined in crate `{}`.\",\n+                                    tcx.crate_name(original_def_id.krate)));\n+            }\n+            err.emit();\n+        }\n+    }\n+}\n+\n+/// Extract the first `rustc_diagnostic_item = \"$name\"` out of a list of attributes.\n+fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n+    attrs.iter().find_map(|attr| {\n+        if attr.check_name(sym::rustc_diagnostic_item) {\n+            attr.value_str()\n+        } else {\n+            None\n+        }\n+    })\n+}\n+\n+/// Traverse and collect the diagnostic items in the current\n+pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = DiagnosticItemCollector::new(tcx);\n+\n+    // Collect diagnostic items in this crate.\n+    tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    tcx.arena.alloc(collector.items)\n+}\n+\n+\n+/// Traverse and collect all the diagnostic items in all crates.\n+pub fn collect_all<'tcx>(tcx: TyCtxt<'tcx>) -> &'tcx FxHashMap<Symbol, DefId> {\n+    // Initialize the collector.\n+    let mut collector = FxHashMap::default();\n+\n+    // Collect diagnostic items in other crates.\n+    for &cnum in tcx.crates().iter().chain(std::iter::once(&LOCAL_CRATE)) {\n+        for (&name, &def_id) in tcx.diagnostic_items(cnum).iter() {\n+            collect_item(tcx, &mut collector, name, def_id);\n+        }\n+    }\n+\n+    tcx.arena.alloc(collector)\n+}"}, {"sha": "ba27d332e43f784d08084de10aa3843858fce99e", "filename": "src/librustc/middle/entry.rs", "status": "modified", "additions": 49, "deletions": 35, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fentry.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -16,17 +16,17 @@ struct EntryContext<'a, 'tcx> {\n \n     map: &'a hir_map::Map<'tcx>,\n \n-    // The top-level function called 'main'\n+    /// The top-level function called `main`.\n     main_fn: Option<(HirId, Span)>,\n \n-    // The function that has attribute named 'main'\n+    /// The function that has attribute named `main`.\n     attr_main_fn: Option<(HirId, Span)>,\n \n-    // The function that has the attribute 'start' on it\n+    /// The function that has the attribute 'start' on it.\n     start_fn: Option<(HirId, Span)>,\n \n-    // The functions that one might think are 'main' but aren't, e.g.\n-    // main functions not defined at the top level. For diagnostics.\n+    /// The functions that one might think are `main` but aren't, e.g.\n+    /// main functions not defined at the top level. For diagnostics.\n     non_main_fns: Vec<(HirId, Span)> ,\n }\n \n@@ -39,11 +39,11 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for EntryContext<'a, 'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &'tcx TraitItem) {\n-        // entry fn is never a trait item\n+        // Entry fn is never a trait item.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &'tcx ImplItem) {\n-        // entry fn is never an impl item\n+        // Entry fn is never a trait item.\n     }\n }\n \n@@ -54,7 +54,7 @@ fn entry_fn(tcx: TyCtxt<'_>, cnum: CrateNum) -> Option<(DefId, EntryFnType)> {\n         *ty == config::CrateType::Executable\n     });\n     if !any_exe {\n-        // No need to find a main function\n+        // No need to find a main function.\n         return None;\n     }\n \n@@ -88,7 +88,7 @@ fn entry_point_type(item: &Item, at_root: bool) -> EntryPointType {\n                 EntryPointType::MainAttr\n             } else if item.ident.name == sym::main {\n                 if at_root {\n-                    // This is a top-level function so can be 'main'.\n+                    // This is a top-level function so can be `main`.\n                     EntryPointType::MainNamed\n                 } else {\n                     EntryPointType::OtherMain\n@@ -109,7 +109,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n                 ctxt.main_fn = Some((item.hir_id, item.span));\n             } else {\n                 span_err!(ctxt.session, item.span, E0136,\n-                          \"multiple 'main' functions\");\n+                          \"multiple `main` functions\");\n             }\n         },\n         EntryPointType::OtherMain => {\n@@ -130,7 +130,7 @@ fn find_item(item: &Item, ctxt: &mut EntryContext<'_, '_>, at_root: bool) {\n             if ctxt.start_fn.is_none() {\n                 ctxt.start_fn = Some((item.hir_id, item.span));\n             } else {\n-                struct_span_err!(ctxt.session, item.span, E0138, \"multiple 'start' functions\")\n+                struct_span_err!(ctxt.session, item.span, E0138, \"multiple `start` functions\")\n                     .span_label(ctxt.start_fn.unwrap().1, \"previous `start` function here\")\n                     .span_label(item.span, \"multiple `start` functions\")\n                     .emit();\n@@ -148,34 +148,48 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n     } else if let Some((hir_id, _)) = visitor.main_fn {\n         Some((tcx.hir().local_def_id(hir_id), EntryFnType::Main))\n     } else {\n-        // No main function\n-        let mut err = struct_err!(tcx.sess, E0601,\n-            \"`main` function not found in crate `{}`\", tcx.crate_name(LOCAL_CRATE));\n-        if !visitor.non_main_fns.is_empty() {\n-            // There were some functions named 'main' though. Try to give the user a hint.\n-            err.note(\"the main function must be defined at the crate level \\\n-                      but you have one or more functions named 'main' that are not \\\n-                      defined at the crate level. Either move the definition or \\\n-                      attach the `#[main]` attribute to override this behavior.\");\n-            for &(_, span) in &visitor.non_main_fns {\n-                err.span_note(span, \"here is a function named 'main'\");\n-            }\n-            err.emit();\n-        } else {\n-            if let Some(ref filename) = tcx.sess.local_crate_source_file {\n-                err.note(&format!(\"consider adding a `main` function to `{}`\", filename.display()));\n-            }\n-            if tcx.sess.teach(&err.get_code().unwrap()) {\n-                err.note(\"If you don't know the basics of Rust, you can go look to the Rust Book \\\n-                          to get started: https://doc.rust-lang.org/book/\");\n-            }\n-            err.emit();\n-        }\n-\n+        no_main_err(tcx, visitor);\n         None\n     }\n }\n \n+fn no_main_err(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) {\n+    // There is no main function.\n+    let mut err = struct_err!(tcx.sess, E0601,\n+        \"`main` function not found in crate `{}`\", tcx.crate_name(LOCAL_CRATE));\n+    let filename = &tcx.sess.local_crate_source_file;\n+    let note = if !visitor.non_main_fns.is_empty() {\n+        for &(_, span) in &visitor.non_main_fns {\n+            err.span_note(span, \"here is a function named `main`\");\n+        }\n+        err.note(\"you have one or more functions named `main` not defined at the crate level\");\n+        err.help(\"either move the `main` function definitions or attach the `#[main]` attribute \\\n+                  to one of them\");\n+        // There were some functions named `main` though. Try to give the user a hint.\n+        format!(\"the main function must be defined at the crate level{}\",\n+                 filename.as_ref().map(|f| format!(\" (in `{}`)\", f.display())).unwrap_or_default())\n+    } else if let Some(filename) = filename {\n+        format!(\"consider adding a `main` function to `{}`\", filename.display())\n+    } else {\n+        String::from(\"consider adding a `main` function at the crate level\")\n+    };\n+    let sp = tcx.hir().krate().span;\n+    // The file may be empty, which leads to the diagnostic machinery not emitting this\n+    // note. This is a relatively simple way to detect that case and emit a span-less\n+    // note instead.\n+    if let Ok(_) = tcx.sess.source_map().lookup_line(sp.lo()) {\n+        err.set_span(sp);\n+        err.span_label(sp, &note);\n+    } else {\n+        err.note(&note);\n+    }\n+    if tcx.sess.teach(&err.get_code().unwrap()) {\n+        err.note(\"If you don't know the basics of Rust, you can go look to the Rust Book \\\n+                  to get started: https://doc.rust-lang.org/book/\");\n+    }\n+    err.emit();\n+}\n+\n pub fn find_entry_point(tcx: TyCtxt<'_>) -> Option<(DefId, EntryFnType)> {\n     tcx.entry_fn(LOCAL_CRATE)\n }"}, {"sha": "de6dadabcbf5623f846f9ecc70f8b1a17e4a1a92", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -313,23 +313,23 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n     pub fn consume_body(&mut self, body: &hir::Body) {\n         debug!(\"consume_body(body={:?})\", body);\n \n-        for arg in &body.arguments {\n-            let arg_ty = return_if_err!(self.mc.pat_ty_adjusted(&arg.pat));\n-            debug!(\"consume_body: arg_ty = {:?}\", arg_ty);\n+        for param in &body.params {\n+            let param_ty = return_if_err!(self.mc.pat_ty_adjusted(&param.pat));\n+            debug!(\"consume_body: param_ty = {:?}\", param_ty);\n \n             let fn_body_scope_r =\n                 self.tcx().mk_region(ty::ReScope(\n                     region::Scope {\n                         id: body.value.hir_id.local_id,\n                         data: region::ScopeData::Node\n                 }));\n-            let arg_cmt = Rc::new(self.mc.cat_rvalue(\n-                arg.hir_id,\n-                arg.pat.span,\n-                fn_body_scope_r, // Args live only as long as the fn body.\n-                arg_ty));\n+            let param_cmt = Rc::new(self.mc.cat_rvalue(\n+                param.hir_id,\n+                param.pat.span,\n+                fn_body_scope_r, // Parameters live only as long as the fn body.\n+                param_ty));\n \n-            self.walk_irrefutable_pat(arg_cmt, &arg.pat);\n+            self.walk_irrefutable_pat(param_cmt, &param.pat);\n         }\n \n         self.consume_expr(&body.value);\n@@ -596,7 +596,7 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n             }\n \n             hir::StmtKind::Item(_) => {\n-                // we don't visit nested items in this visitor,\n+                // We don't visit nested items in this visitor,\n                 // only the fn body we were given.\n             }\n "}, {"sha": "c5d9a722ae18e09c5c9fdbebd9151f1a13295021", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -3,10 +3,8 @@\n //! Language items are items that represent concepts intrinsic to the language\n //! itself. Examples are:\n //!\n-//! * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n-//!\n-//! * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n-//!\n+//! * Traits that specify \"kinds\"; e.g., `Sync`, `Send`.\n+//! * Traits that represent operators; e.g., `Add`, `Sub`, `Index`.\n //! * Functions called by the compiler itself.\n \n pub use self::LangItem::*;\n@@ -151,11 +149,11 @@ impl ItemLikeVisitor<'v> for LanguageItemCollector<'tcx> {\n     }\n \n     fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-        // at present, lang items are always items, not trait items\n+        // At present, lang items are always items, not trait items.\n     }\n \n     fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-        // at present, lang items are always items, not impl items\n+        // At present, lang items are always items, not impl items.\n     }\n }\n \n@@ -204,7 +202,7 @@ impl LanguageItemCollector<'tcx> {\n     }\n }\n \n-/// Extract the first `lang = \"$name\"` out of a list of attributes.\n+/// Extracts the first `lang = \"$name\"` out of a list of attributes.\n /// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n /// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n@@ -216,7 +214,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n     }))\n }\n \n-/// Traverse and collect all the lang items in all crates.\n+/// Traverses and collects all the lang items in all crates.\n pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n     // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n@@ -246,6 +244,7 @@ pub fn collect<'tcx>(tcx: TyCtxt<'tcx>) -> LanguageItems {\n \n language_item_table! {\n //  Variant name,                Name,                 Method name,             Target;\n+    BoolImplItem,                \"bool\",               bool_impl,               Target::Impl;\n     CharImplItem,                \"char\",               char_impl,               Target::Impl;\n     StrImplItem,                 \"str\",                str_impl,                Target::Impl;\n     SliceImplItem,               \"slice\",              slice_impl,              Target::Impl;\n@@ -367,9 +366,7 @@ language_item_table! {\n \n     MaybeUninitLangItem,         \"maybe_uninit\",       maybe_uninit,            Target::Union;\n \n-    DebugTraitLangItem,          \"debug_trait\",        debug_trait,             Target::Trait;\n-\n-    // Align offset for stride != 1, must not panic.\n+    // Align offset for stride != 1; must not panic.\n     AlignOffsetLangItem,         \"align_offset\",       align_offset_fn,         Target::Fn;\n \n     TerminationTraitLangItem,    \"termination\",        termination,             Target::Trait;\n@@ -380,10 +377,14 @@ language_item_table! {\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n-    /// If not found, fatally abort compilation.\n-    pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n+    /// If not found, fatally aborts compilation.\n+    pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n-            self.sess.fatal(&msg)\n+            if let Some(span) = span {\n+                self.sess.span_fatal(span, &msg)\n+            } else {\n+                self.sess.fatal(&msg)\n+            }\n         })\n     }\n }"}, {"sha": "00013bfc574f4e108ce489807281d0c089fe4ecf", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -242,7 +242,7 @@ struct LocalInfo {\n \n #[derive(Copy, Clone, Debug)]\n enum VarKind {\n-    Arg(HirId, ast::Name),\n+    Param(HirId, ast::Name),\n     Local(LocalInfo),\n     CleanExit\n }\n@@ -298,7 +298,7 @@ impl IrMaps<'tcx> {\n         self.num_vars += 1;\n \n         match vk {\n-            Local(LocalInfo { id: node_id, .. }) | Arg(node_id, _) => {\n+            Local(LocalInfo { id: node_id, .. }) | Param(node_id, _) => {\n                 self.variable_map.insert(node_id, v);\n             },\n             CleanExit => {}\n@@ -320,7 +320,7 @@ impl IrMaps<'tcx> {\n \n     fn variable_name(&self, var: Variable) -> String {\n         match self.var_kinds[var.get()] {\n-            Local(LocalInfo { name, .. }) | Arg(_, name) => {\n+            Local(LocalInfo { name, .. }) | Param(_, name) => {\n                 name.to_string()\n             },\n             CleanExit => \"<clean-exit>\".to_owned()\n@@ -330,7 +330,7 @@ impl IrMaps<'tcx> {\n     fn variable_is_shorthand(&self, var: Variable) -> bool {\n         match self.var_kinds[var.get()] {\n             Local(LocalInfo { is_shorthand, .. }) => is_shorthand,\n-            Arg(..) | CleanExit => false\n+            Param(..) | CleanExit => false\n         }\n     }\n \n@@ -371,21 +371,21 @@ fn visit_fn<'tcx>(\n \n     let body = ir.tcx.hir().body(body_id);\n \n-    for arg in &body.arguments {\n-        let is_shorthand = match arg.pat.node {\n+    for param in &body.params {\n+        let is_shorthand = match param.pat.node {\n             crate::hir::PatKind::Struct(..) => true,\n             _ => false,\n         };\n-        arg.pat.each_binding(|_bm, hir_id, _x, ident| {\n-            debug!(\"adding argument {:?}\", hir_id);\n+        param.pat.each_binding(|_bm, hir_id, _x, ident| {\n+            debug!(\"adding parameters {:?}\", hir_id);\n             let var = if is_shorthand {\n                 Local(LocalInfo {\n                     id: hir_id,\n                     name: ident.name,\n                     is_shorthand: true,\n                 })\n             } else {\n-                Arg(hir_id, ident.name)\n+                Param(hir_id, ident.name)\n             };\n             fn_maps.add_variable(var);\n         })\n@@ -1525,8 +1525,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n     }\n \n     fn warn_about_unused_args(&self, body: &hir::Body, entry_ln: LiveNode) {\n-        for arg in &body.arguments {\n-            arg.pat.each_binding(|_bm, hir_id, _, ident| {\n+        for param in &body.params {\n+            param.pat.each_binding(|_bm, hir_id, _, ident| {\n                 let sp = ident.span;\n                 let var = self.variable(hir_id, sp);\n                 // Ignore unused self."}, {"sha": "87470140e3148dd19dc04e409ee4f2bdbae6d013", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 42, "deletions": 46, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -6,29 +6,27 @@\n //!\n //! [rustc guide]: https://rust-lang.github.io/rustc-guide/mir/borrowck.html\n \n+use crate::hir;\n+use crate::hir::Node;\n+use crate::hir::def_id::DefId;\n+use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n use crate::ich::{StableHashingContext, NodeIdHashingMode};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n-use crate::ty;\n+use crate::ty::{self, DefIdTree, TyCtxt};\n+use crate::ty::query::Providers;\n \n-use std::mem;\n-use std::fmt;\n+use rustc_data_structures::indexed_vec::Idx;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher, StableHasherResult};\n use rustc_macros::HashStable;\n use syntax::source_map;\n use syntax_pos::{Span, DUMMY_SP};\n-use crate::ty::{DefIdTree, TyCtxt};\n-use crate::ty::query::Providers;\n \n-use crate::hir;\n-use crate::hir::Node;\n-use crate::hir::def_id::DefId;\n-use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use crate::hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use std::fmt;\n+use std::mem;\n \n-/// Scope represents a statically-describable scope that can be\n-/// used to bound the lifetime/region for values.\n+/// Represents a statically-describable scope that can be used to\n+/// bound the lifetime/region for values.\n ///\n /// `Node(node_id)`: Any AST node that has any scope at all has the\n /// `Node(node_id)` scope. Other variants represent special cases not\n@@ -225,25 +223,25 @@ pub struct ScopeTree {\n     /// have lifetime parameters free in this body.\n     root_parent: Option<hir::HirId>,\n \n-    /// `parent_map` maps from a scope ID to the enclosing scope id;\n+    /// Maps from a scope ID to the enclosing scope id;\n     /// this is usually corresponding to the lexical nesting, though\n     /// in the case of closures the parent scope is the innermost\n     /// conditional expression or repeating block. (Note that the\n     /// enclosing scope ID for the block associated with a closure is\n     /// the closure itself.)\n     parent_map: FxHashMap<Scope, (Scope, ScopeDepth)>,\n \n-    /// `var_map` maps from a variable or binding ID to the block in\n-    /// which that variable is declared.\n+    /// Maps from a variable or binding ID to the block in which that\n+    /// variable is declared.\n     var_map: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// maps from a `NodeId` to the associated destruction scope (if any)\n+    /// Maps from a `NodeId` to the associated destruction scope (if any).\n     destruction_scopes: FxHashMap<hir::ItemLocalId, Scope>,\n \n-    /// `rvalue_scopes` includes entries for those expressions whose cleanup scope is\n-    /// larger than the default. The map goes from the expression id\n-    /// to the cleanup scope id. For rvalues not present in this\n-    /// table, the appropriate cleanup scope is the innermost\n+    /// `rvalue_scopes` includes entries for those expressions whose\n+    /// cleanup scope is larger than the default. The map goes from the\n+    /// expression ID to the cleanup scope id. For rvalues not present in\n+    /// this table, the appropriate cleanup scope is the innermost\n     /// enclosing statement, conditional expression, or repeating\n     /// block (see `terminating_scopes`).\n     /// In constants, None is used to indicate that certain expressions\n@@ -318,7 +316,7 @@ pub struct ScopeTree {\n     ///     4. By `2.` and `3.`, `D` is *statically* storage-dead at `U`,\n     ///     QED.\n     ///\n-    /// I don't think this property relies on `3.` in an essential way - it\n+    /// This property ought to not on (3) in an essential way -- it\n     /// is probably still correct even if we have \"unrestricted\" terminating\n     /// scopes. However, why use the complicated proof when a simple one\n     /// works?\n@@ -341,20 +339,20 @@ pub struct ScopeTree {\n \n #[derive(Debug, Copy, Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub struct YieldData {\n-    /// `Span` of the yield.\n+    /// The `Span` of the yield.\n     pub span: Span,\n-    /// The number of expressions and patterns appearing before the `yield` in the body + 1.\n+    /// The number of expressions and patterns appearing before the `yield` in the body plus one.\n     pub expr_and_pat_count: usize,\n     pub source: hir::YieldSource,\n }\n \n #[derive(Debug, Copy, Clone)]\n pub struct Context {\n-    /// the root of the current region tree. This is typically the id\n+    /// The root of the current region tree. This is typically the id\n     /// of the innermost fn body. Each fn forms its own disjoint tree\n     /// in the region hierarchy. These fn bodies are themselves\n     /// arranged into a tree. See the \"Modeling closures\" section of\n-    /// the README in infer::region_constraints for more\n+    /// the README in `infer::region_constraints` for more\n     /// details.\n     root_id: Option<hir::ItemLocalId>,\n \n@@ -369,15 +367,15 @@ pub struct Context {\n struct RegionResolutionVisitor<'tcx> {\n     tcx: TyCtxt<'tcx>,\n \n-    // The number of expressions and patterns visited in the current body\n+    // The number of expressions and patterns visited in the current body.\n     expr_and_pat_count: usize,\n     // When this is `true`, we record the `Scopes` we encounter\n     // when processing a Yield expression. This allows us to fix\n     // up their indices.\n     pessimistic_yield: bool,\n-    // Stores scopes when pessimistic_yield is true.\n+    // Stores scopes when `pessimistic_yield` is `true`.\n     fixup_scopes: Vec<Scope>,\n-    // Generated scope tree:\n+    // The generated scope tree.\n     scope_tree: ScopeTree,\n \n     cx: Context,\n@@ -411,7 +409,7 @@ struct ExprLocatorVisitor {\n     expr_and_pat_count: usize,\n }\n \n-// This visitor has to have the same visit_expr calls as RegionResolutionVisitor\n+// This visitor has to have the same `visit_expr` calls as `RegionResolutionVisitor`\n // since `expr_count` is compared against the results there.\n impl<'tcx> Visitor<'tcx> for ExprLocatorVisitor {\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n@@ -456,7 +454,7 @@ impl<'tcx> ScopeTree {\n             assert!(prev.is_none());\n         }\n \n-        // record the destruction scopes for later so we can query them\n+        // Record the destruction scopes for later so we can query them.\n         if let ScopeData::Destruction = child.data {\n             self.destruction_scopes.insert(child.item_local_id(), child);\n         }\n@@ -478,7 +476,7 @@ impl<'tcx> ScopeTree {\n         self.destruction_scopes.get(&n).cloned()\n     }\n \n-    /// Records that `sub_closure` is defined within `sup_closure`. These ids\n+    /// Records that `sub_closure` is defined within `sup_closure`. These IDs\n     /// should be the ID of the block that is the fn body, which is\n     /// also the root of the region hierarchy for that fn.\n     fn record_closure_parent(&mut self,\n@@ -505,14 +503,14 @@ impl<'tcx> ScopeTree {\n         self.rvalue_scopes.insert(var, lifetime);\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     pub fn opt_encl_scope(&self, id: Scope) -> Option<Scope> {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.parent_map.get(&id).cloned().map(|(p, _)| p)\n     }\n \n+    /// Returns the narrowest scope that encloses `id`, if any.\n     #[allow(dead_code)] // used in cfg\n     pub fn encl_scope(&self, id: Scope) -> Scope {\n-        //! Returns the narrowest scope that encloses `id`, if any.\n         self.opt_encl_scope(id).unwrap()\n     }\n \n@@ -522,16 +520,15 @@ impl<'tcx> ScopeTree {\n             bug!(\"no enclosing scope for id {:?}\", var_id))\n     }\n \n+    /// Returns the scope when the temp created by `expr_id` will be cleaned up.\n     pub fn temporary_scope(&self, expr_id: hir::ItemLocalId) -> Option<Scope> {\n-        //! Returns the scope when temp created by expr_id will be cleaned up\n-\n-        // check for a designated rvalue scope\n+        // Check for a designated rvalue scope.\n         if let Some(&s) = self.rvalue_scopes.get(&expr_id) {\n             debug!(\"temporary_scope({:?}) = {:?} [custom]\", expr_id, s);\n             return s;\n         }\n \n-        // else, locate the innermost terminating scope\n+        // Otherwise, locate the innermost terminating scope\n         // if there's one. Static items, for instance, won't\n         // have an enclosing scope, hence no scope will be\n         // returned.\n@@ -552,9 +549,8 @@ impl<'tcx> ScopeTree {\n         return None;\n     }\n \n+    /// Returns the lifetime of the variable `id`.\n     pub fn var_region(&self, id: hir::ItemLocalId) -> ty::RegionKind {\n-        //! Returns the lifetime of the variable `id`.\n-\n         let scope = ty::ReScope(self.var_scope(id));\n         debug!(\"var_region({:?}) = {:?}\", id, scope);\n         scope\n@@ -589,7 +585,7 @@ impl<'tcx> ScopeTree {\n         return true;\n     }\n \n-    /// Returns the ID of the innermost containing body\n+    /// Returns the ID of the innermost containing body.\n     pub fn containing_body(&self, mut scope: Scope) -> Option<hir::ItemLocalId> {\n         loop {\n             if let ScopeData::CallSite = scope.data {\n@@ -1140,7 +1136,7 @@ fn resolve_local<'tcx>(\n     // Rule A. `let (ref x, ref y) = (foo().x, 44)`. The rvalue `(22, 44)`\n     // would have an extended lifetime, but not `foo()`.\n     //\n-    // Rule B. `let x = &foo().x`. The rvalue ``foo()` would have extended\n+    // Rule B. `let x = &foo().x`. The rvalue `foo()` would have extended\n     // lifetime.\n     //\n     // In some cases, multiple rules may apply (though not to the same\n@@ -1383,8 +1379,8 @@ impl<'tcx> Visitor<'tcx> for RegionResolutionVisitor<'tcx> {\n \n         // The arguments and `self` are parented to the fn.\n         self.cx.var_parent = self.cx.parent.take();\n-        for argument in &body.arguments {\n-            self.visit_pat(&argument.pat);\n+        for param in &body.params {\n+            self.visit_pat(&param.pat);\n         }\n \n         // The body of the every fn is a root scope."}, {"sha": "d833a34385b2d8400f0830c87d339250d915376d", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -17,7 +17,7 @@ use crate::ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n use crate::rustc::lint;\n use crate::session::Session;\n use crate::util::nodemap::{DefIdMap, FxHashMap, FxHashSet, HirIdMap, HirIdSet};\n-use errors::{Applicability, DiagnosticBuilder};\n+use errors::{Applicability, DiagnosticBuilder, pluralise};\n use rustc_macros::HashStable;\n use std::borrow::Cow;\n use std::cell::Cell;\n@@ -2557,7 +2557,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } = info;\n \n             let help_name = if let Some(ident) = parent.and_then(|body| {\n-                self.tcx.hir().body(body).arguments[index].pat.simple_ident()\n+                self.tcx.hir().body(body).params[index].pat.simple_ident()\n             }) {\n                 format!(\"`{}`\", ident)\n             } else {\n@@ -3047,7 +3047,7 @@ pub fn report_missing_lifetime_specifiers(\n         span,\n         E0106,\n         \"missing lifetime specifier{}\",\n-        if count > 1 { \"s\" } else { \"\" }\n+        pluralise!(count)\n     )\n }\n "}, {"sha": "c06a0feb6a99381f6f8d870e992b80c610832cec", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -438,6 +438,7 @@ impl<'tcx> Index<'tcx> {\n                     level: attr::StabilityLevel::Unstable {\n                         reason: Some(Symbol::intern(reason)),\n                         issue: 27812,\n+                        is_soft: false,\n                     },\n                     feature: sym::rustc_private,\n                     rustc_depr: None,\n@@ -480,7 +481,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n }\n \n pub fn report_unstable(\n-    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, span: Span\n+    sess: &Session, feature: Symbol, reason: Option<Symbol>, issue: u32, is_soft: bool, span: Span\n ) {\n     let msg = match reason {\n         Some(r) => format!(\"use of unstable library feature '{}': {}\", feature, r),\n@@ -505,7 +506,13 @@ pub fn report_unstable(\n     let error_id = (DiagnosticMessageId::StabilityId(issue), span_key, msg.clone());\n     let fresh = sess.one_time_diagnostics.borrow_mut().insert(error_id);\n     if fresh {\n-        emit_feature_err(&sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg);\n+        if is_soft {\n+            sess.buffer_lint(lint::builtin::SOFT_UNSTABLE, CRATE_NODE_ID, span, &msg);\n+        } else {\n+            emit_feature_err(\n+                &sess.parse_sess, feature, span, GateIssue::Library(Some(issue)), &msg\n+            );\n+        }\n     }\n }\n \n@@ -621,6 +628,7 @@ pub enum EvalResult {\n         feature: Symbol,\n         reason: Option<Symbol>,\n         issue: u32,\n+        is_soft: bool,\n     },\n     /// The item does not have the `#[stable]` or `#[unstable]` marker assigned.\n     Unmarked,\n@@ -720,7 +728,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n \n         match stability {\n-            Some(&Stability { level: attr::Unstable { reason, issue }, feature, .. }) => {\n+            Some(&Stability {\n+                level: attr::Unstable { reason, issue, is_soft }, feature, ..\n+            }) => {\n                 if span.allows_unstable(feature) {\n                     debug!(\"stability: skipping span={:?} since it is internal\", span);\n                     return EvalResult::Allow;\n@@ -744,7 +754,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     }\n                 }\n \n-                EvalResult::Deny { feature, reason, issue }\n+                EvalResult::Deny { feature, reason, issue, is_soft }\n             }\n             Some(_) => {\n                 // Stable APIs are always ok to call and deprecated APIs are\n@@ -767,8 +777,8 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn check_stability(self, def_id: DefId, id: Option<HirId>, span: Span) {\n         match self.eval_stability(def_id, id, span) {\n             EvalResult::Allow => {}\n-            EvalResult::Deny { feature, reason, issue } =>\n-                report_unstable(self.sess, feature, reason, issue, span),\n+            EvalResult::Deny { feature, reason, issue, is_soft } =>\n+                report_unstable(self.sess, feature, reason, issue, is_soft, span),\n             EvalResult::Unmarked => {\n                 // The API could be uncallable for other reasons, for example when a private module\n                 // was referenced."}, {"sha": "fa5fa2257dbc8ce9940f1ec6181b86e8afba253b", "filename": "src/librustc/middle/weak_lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fweak_lang_items.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -116,8 +116,8 @@ fn verify<'tcx>(tcx: TyCtxt<'tcx>,\n }\n \n impl<'a, 'tcx> Context<'a, 'tcx> {\n-    fn register(&mut self, name: &str, span: Span) {\n-        $(if name == stringify!($name) {\n+    fn register(&mut self, name: Symbol, span: Span) {\n+        $(if name == sym::$name {\n             if self.items.$name().is_none() {\n                 self.items.missing.push(lang_items::$item);\n             }\n@@ -136,7 +136,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n \n     fn visit_foreign_item(&mut self, i: &hir::ForeignItem) {\n         if let Some((lang_item, _)) = lang_items::extract(&i.attrs) {\n-            self.register(&lang_item.as_str(), i.span);\n+            self.register(lang_item, i.span);\n         }\n         intravisit::walk_foreign_item(self, i)\n     }"}, {"sha": "1f604877841a730e117322eb4bced048ded902d1", "filename": "src/librustc/mir/cache.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fcache.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -27,7 +27,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for Cache {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           _: &mut StableHashingContext<'a>,\n                                           _: &mut StableHasher<W>) {\n-        // do nothing\n+        // Do nothing.\n     }\n }\n "}, {"sha": "15e6cb6bcabaeab755d8bb9a413647675a87b634", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 274, "deletions": 63, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,38 +4,53 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n+use crate::mir;\n use crate::ty::layout::{Size, Align};\n+\n+use rustc_data_structures::sorted_map::SortedMap;\n+use rustc_target::abi::HasDataLayout;\n use syntax::ast::Mutability;\n use std::iter;\n-use crate::mir;\n use std::ops::{Range, Deref, DerefMut};\n-use rustc_data_structures::sorted_map::SortedMap;\n-use rustc_target::abi::HasDataLayout;\n use std::borrow::Cow;\n \n-#[derive(Clone, Debug, Eq, PartialEq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n-pub struct Allocation<Tag=(),Extra=()> {\n+// NOTE: When adding new fields, make sure to adjust the `Snapshot` impl in\n+// `src/librustc_mir/interpret/snapshot.rs`.\n+#[derive(\n+    Clone,\n+    Debug,\n+    Eq,\n+    PartialEq,\n+    PartialOrd,\n+    Ord,\n+    Hash,\n+    RustcEncodable,\n+    RustcDecodable,\n+    HashStable,\n+)]\n+pub struct Allocation<Tag = (),Extra = ()> {\n     /// The actual bytes of the allocation.\n-    /// Note that the bytes of a pointer represent the offset of the pointer\n-    pub bytes: Vec<u8>,\n+    /// Note that the bytes of a pointer represent the offset of the pointer.\n+    bytes: Vec<u8>,\n     /// Maps from byte addresses to extra data for each pointer.\n     /// Only the first byte of a pointer is inserted into the map; i.e.,\n     /// every entry in this map applies to `pointer_size` consecutive bytes starting\n     /// at the given offset.\n-    pub relocations: Relocations<Tag>,\n-    /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n-    pub undef_mask: UndefMask,\n+    relocations: Relocations<Tag>,\n+    /// Denotes which part of this allocation is initialized.\n+    undef_mask: UndefMask,\n+    /// The size of the allocation. Currently, must always equal `bytes.len()`.\n+    pub size: Size,\n     /// The alignment of the allocation to detect unaligned reads.\n     pub align: Align,\n-    /// Whether the allocation is mutable.\n+    /// `true` if the allocation is mutable.\n     /// Also used by codegen to determine if a static should be put into mutable memory,\n     /// which happens for `static mut` and `static` with interior mutability.\n     pub mutability: Mutability,\n     /// Extra state for the machine.\n     pub extra: Extra,\n }\n \n-\n pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     // There is no constructor in here because the constructor's type depends\n     // on `MemoryKind`, and making things sufficiently generic leads to painful\n@@ -77,19 +92,20 @@ pub trait AllocationExtra<Tag>: ::std::fmt::Debug + Clone {\n     }\n }\n \n-// For Tag=() and no extra state, we have is a trivial implementation.\n+// For `Tag = ()` and no extra state, we have a trivial implementation.\n impl AllocationExtra<()> for () { }\n \n // The constructors are all without extra; the extra gets added by a machine hook later.\n impl<Tag> Allocation<Tag> {\n     /// Creates a read-only allocation initialized by the given bytes\n     pub fn from_bytes<'a>(slice: impl Into<Cow<'a, [u8]>>, align: Align) -> Self {\n         let bytes = slice.into().into_owned();\n-        let undef_mask = UndefMask::new(Size::from_bytes(bytes.len() as u64), true);\n+        let size = Size::from_bytes(bytes.len() as u64);\n         Self {\n             bytes,\n             relocations: Relocations::new(),\n-            undef_mask,\n+            undef_mask: UndefMask::new(size, true),\n+            size,\n             align,\n             mutability: Mutability::Immutable,\n             extra: (),\n@@ -106,16 +122,70 @@ impl<Tag> Allocation<Tag> {\n             bytes: vec![0; size.bytes() as usize],\n             relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size, false),\n+            size,\n             align,\n             mutability: Mutability::Mutable,\n             extra: (),\n         }\n     }\n }\n \n+impl Allocation<(), ()> {\n+    /// Add Tag and Extra fields\n+    pub fn with_tags_and_extra<T, E>(\n+        self,\n+        mut tagger: impl FnMut(AllocId) -> T,\n+        extra: E,\n+    ) -> Allocation<T, E> {\n+        Allocation {\n+            bytes: self.bytes,\n+            size: self.size,\n+            relocations: Relocations::from_presorted(\n+                self.relocations.iter()\n+                    // The allocations in the relocations (pointers stored *inside* this allocation)\n+                    // all get the base pointer tag.\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = tagger(alloc);\n+                        (offset, (tag, alloc))\n+                    })\n+                    .collect()\n+            ),\n+            undef_mask: self.undef_mask,\n+            align: self.align,\n+            mutability: self.mutability,\n+            extra,\n+        }\n+    }\n+}\n+\n+/// Raw accessors. Provide access to otherwise private bytes.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    pub fn len(&self) -> usize {\n+        self.size.bytes() as usize\n+    }\n+\n+    /// Looks at a slice which may describe undefined bytes or describe a relocation. This differs\n+    /// from `get_bytes_with_undef_and_ptr` in that it does no relocation checks (even on the\n+    /// edges) at all. It further ignores `AllocationExtra` callbacks.\n+    /// This must not be used for reads affecting the interpreter execution.\n+    pub fn inspect_with_undef_and_ptr_outside_interpreter(&self, range: Range<usize>) -> &[u8] {\n+        &self.bytes[range]\n+    }\n+\n+    /// Returns the undef mask.\n+    pub fn undef_mask(&self) -> &UndefMask {\n+        &self.undef_mask\n+    }\n+\n+    /// Returns the relocation list.\n+    pub fn relocations(&self) -> &Relocations<Tag> {\n+        &self.relocations\n+    }\n+}\n+\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n-/// Byte accessors\n+/// Byte accessors.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Just a small local helper function to avoid a bit of code repetition.\n     /// Returns the range of this allocation that was meant.\n@@ -125,16 +195,16 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         offset: Size,\n         size: Size\n     ) -> Range<usize> {\n-        let end = offset + size; // this does overflow checking\n+        let end = offset + size; // This does overflow checking.\n         assert_eq!(\n             end.bytes() as usize as u64, end.bytes(),\n             \"cannot handle this access on this host architecture\"\n         );\n         let end = end.bytes() as usize;\n         assert!(\n-            end <= self.bytes.len(),\n+            end <= self.len(),\n             \"Out-of-bounds access at offset {}, size {} in allocation of size {}\",\n-            offset.bytes(), size.bytes(), self.bytes.len()\n+            offset.bytes(), size.bytes(), self.len()\n         );\n         (offset.bytes() as usize)..end\n     }\n@@ -162,7 +232,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n-            // We still don't want relocations on the *edges*\n+            // We still don't want relocations on the *edges*.\n             self.check_relocation_edges(cx, ptr, size)?;\n         }\n \n@@ -171,7 +241,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(&self.bytes[range])\n     }\n \n-    /// Check that these bytes are initialized and not pointer bytes, and then return them\n+    /// Checks that these bytes are initialized and not pointer bytes, and then return them\n     /// as a slice.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n@@ -223,7 +293,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Reading and writing\n+/// Reading and writing.\n impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     /// Reads bytes until a `0` is encountered. Will error if the end of the allocation is reached\n     /// before a `0` is found.\n@@ -259,9 +329,9 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         allow_ptr_and_undef: bool,\n     ) -> InterpResult<'tcx>\n     {\n-        // Check bounds and relocations on the edges\n+        // Check bounds and relocations on the edges.\n         self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n-        // Check undef and ptr\n+        // Check undef and ptr.\n         if !allow_ptr_and_undef {\n             self.check_defined(ptr, size)?;\n             self.check_relocations(cx, ptr, size)?;\n@@ -302,12 +372,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Read a *non-ZST* scalar\n+    /// Reads a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in order to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_scalar(\n@@ -317,20 +387,20 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         size: Size\n     ) -> InterpResult<'tcx, ScalarMaybeUndef<Tag>>\n     {\n-        // get_bytes_unchecked tests relocation edges\n+        // `get_bytes_unchecked` tests relocation edges.\n         let bytes = self.get_bytes_with_undef_and_ptr(cx, ptr, size)?;\n         // Undef check happens *after* we established that the alignment is correct.\n-        // We must not return Ok() for unaligned pointers!\n+        // We must not return `Ok()` for unaligned pointers!\n         if self.check_defined(ptr, size).is_err() {\n-            // this inflates undefined bytes to the entire scalar, even if only a few\n-            // bytes are undefined\n+            // This inflates undefined bytes to the entire scalar, even if only a few\n+            // bytes are undefined.\n             return Ok(ScalarMaybeUndef::Undef);\n         }\n-        // Now we do the actual reading\n+        // Now we do the actual reading.\n         let bits = read_target_uint(cx.data_layout().endian, bytes).unwrap();\n-        // See if we got a pointer\n+        // See if we got a pointer.\n         if size != cx.data_layout().pointer_size {\n-            // *Now* better make sure that the inside also is free of relocations.\n+            // *Now*, we better make sure that the inside is free of relocations too.\n             self.check_relocations(cx, ptr, size)?;\n         } else {\n             match self.relocations.get(&ptr.offset) {\n@@ -345,7 +415,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(ScalarMaybeUndef::Scalar(Scalar::from_uint(bits, size)))\n     }\n \n-    /// Read a pointer-sized scalar.\n+    /// Reads a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn read_ptr_sized(\n@@ -357,12 +427,12 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         self.read_scalar(cx, ptr, cx.data_layout().pointer_size)\n     }\n \n-    /// Write a *non-ZST* scalar\n+    /// Writes a *non-ZST* scalar.\n     ///\n-    /// zsts can't be read out of two reasons:\n-    /// * byteorder cannot work with zero element buffers\n-    /// * in oder to obtain a `Pointer` we need to check for ZSTness anyway due to integer pointers\n-    ///   being valid for ZSTs\n+    /// ZSTs can't be read for two reasons:\n+    /// * byte-order cannot work with zero-element buffers;\n+    /// * in order to obtain a `Pointer`, we need to check for ZSTness anyway due to integer\n+    ///   pointers being valid for ZSTs.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_scalar(\n@@ -390,7 +460,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         let dst = self.get_bytes_mut(cx, ptr, type_size)?;\n         write_target_uint(endian, dst, bytes).unwrap();\n \n-        // See if we have to also write a relocation\n+        // See if we have to also write a relocation.\n         match val {\n             Scalar::Ptr(val) => {\n                 self.relocations.insert(\n@@ -404,7 +474,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Write a pointer-sized scalar.\n+    /// Writes a pointer-sized scalar.\n     ///\n     /// It is the caller's responsibility to check bounds and alignment beforehand.\n     pub fn write_ptr_sized(\n@@ -419,10 +489,10 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Relocations.\n impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n-    /// Returns all relocations overlapping with the given ptr-offset pair.\n-    pub fn relocations(\n+    /// Returns all relocations overlapping with the given pointer-offset pair.\n+    pub fn get_relocations(\n         &self,\n         cx: &impl HasDataLayout,\n         ptr: Pointer<Tag>,\n@@ -431,7 +501,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // We have to go back `pointer_size - 1` bytes, as that one would still overlap with\n         // the beginning of this range.\n         let start = ptr.offset.bytes().saturating_sub(cx.data_layout().pointer_size.bytes() - 1);\n-        let end = ptr.offset + size; // this does overflow checking\n+        let end = ptr.offset + size; // This does overflow checking.\n         self.relocations.range(Size::from_bytes(start)..end)\n     }\n \n@@ -443,7 +513,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        if self.relocations(cx, ptr, size).is_empty() {\n+        if self.get_relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n             throw_unsup!(ReadPointerAsBytes)\n@@ -465,7 +535,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         // Find the start and end of the given range and its outermost relocations.\n         let (first, last) = {\n             // Find all relocations overlapping the given range.\n-            let relocations = self.relocations(cx, ptr, size);\n+            let relocations = self.get_relocations(cx, ptr, size);\n             if relocations.is_empty() {\n                 return Ok(());\n             }\n@@ -491,7 +561,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         Ok(())\n     }\n \n-    /// Error if there are relocations overlapping with the edges of the\n+    /// Errors if there are relocations overlapping with the edges of the\n     /// given memory range.\n     #[inline]\n     fn check_relocation_edges(\n@@ -507,7 +577,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n }\n \n \n-/// Undefined bytes\n+/// Undefined bytes.\n impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     /// Checks that a range of bytes is defined. If not, returns the `ReadUndefBytes`\n     /// error which will report the first byte which is undefined.\n@@ -536,9 +606,97 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n     }\n }\n \n-/// Relocations\n+/// Run-length encoding of the undef mask.\n+/// Used to copy parts of a mask multiple times to another allocation.\n+pub struct AllocationDefinedness {\n+    /// The definedness of the first range.\n+    initial: bool,\n+    /// The lengths of ranges that are run-length encoded.\n+    /// The definedness of the ranges alternate starting with `initial`.\n+    ranges: smallvec::SmallVec::<[u64; 1]>,\n+}\n+\n+/// Transferring the definedness mask to other allocations.\n+impl<Tag, Extra> Allocation<Tag, Extra> {\n+    /// Creates a run-length encoding of the undef mask.\n+    pub fn compress_undef_range(\n+        &self,\n+        src: Pointer<Tag>,\n+        size: Size,\n+    ) -> AllocationDefinedness {\n+        // Since we are copying `size` bytes from `src` to `dest + i * size` (`for i in 0..repeat`),\n+        // a naive undef mask copying algorithm would repeatedly have to read the undef mask from\n+        // the source and write it to the destination. Even if we optimized the memory accesses,\n+        // we'd be doing all of this `repeat` times.\n+        // Therefor we precompute a compressed version of the undef mask of the source value and\n+        // then write it back `repeat` times without computing any more information from the source.\n+\n+        // A precomputed cache for ranges of defined/undefined bits\n+        // 0000010010001110 will become\n+        // `[5, 1, 2, 1, 3, 3, 1]`,\n+        // where each element toggles the state.\n+\n+        let mut ranges = smallvec::SmallVec::<[u64; 1]>::new();\n+        let initial = self.undef_mask.get(src.offset);\n+        let mut cur_len = 1;\n+        let mut cur = initial;\n+\n+        for i in 1..size.bytes() {\n+            // FIXME: optimize to bitshift the current undef block's bits and read the top bit.\n+            if self.undef_mask.get(src.offset + Size::from_bytes(i)) == cur {\n+                cur_len += 1;\n+            } else {\n+                ranges.push(cur_len);\n+                cur_len = 1;\n+                cur = !cur;\n+            }\n+        }\n+\n+        ranges.push(cur_len);\n+\n+        AllocationDefinedness { ranges, initial, }\n+    }\n+\n+    /// Applies multiple instances of the run-length encoding to the undef mask.\n+    pub fn mark_compressed_undef_range(\n+        &mut self,\n+        defined: &AllocationDefinedness,\n+        dest: Pointer<Tag>,\n+        size: Size,\n+        repeat: u64,\n+    ) {\n+        // An optimization where we can just overwrite an entire range of definedness bits if\n+        // they are going to be uniformly `1` or `0`.\n+        if defined.ranges.len() <= 1 {\n+            self.undef_mask.set_range_inbounds(\n+                dest.offset,\n+                dest.offset + size * repeat,\n+                defined.initial,\n+            );\n+            return;\n+        }\n+\n+        for mut j in 0..repeat {\n+            j *= size.bytes();\n+            j += dest.offset.bytes();\n+            let mut cur = defined.initial;\n+            for range in &defined.ranges {\n+                let old_j = j;\n+                j += range;\n+                self.undef_mask.set_range_inbounds(\n+                    Size::from_bytes(old_j),\n+                    Size::from_bytes(j),\n+                    cur,\n+                );\n+                cur = !cur;\n+            }\n+        }\n+    }\n+}\n+\n+/// Relocations.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n-pub struct Relocations<Tag=(), Id=AllocId>(SortedMap<Size, (Tag, Id)>);\n+pub struct Relocations<Tag = (), Id = AllocId>(SortedMap<Size, (Tag, Id)>);\n \n impl<Tag, Id> Relocations<Tag, Id> {\n     pub fn new() -> Self {\n@@ -566,6 +724,59 @@ impl<Tag> DerefMut for Relocations<Tag> {\n     }\n }\n \n+/// A partial, owned list of relocations to transfer into another allocation.\n+pub struct AllocationRelocations<Tag> {\n+    relative_relocations: Vec<(Size, (Tag, AllocId))>,\n+}\n+\n+impl<Tag: Copy, Extra> Allocation<Tag, Extra> {\n+    pub fn prepare_relocation_copy(\n+        &self,\n+        cx: &impl HasDataLayout,\n+        src: Pointer<Tag>,\n+        size: Size,\n+        dest: Pointer<Tag>,\n+        length: u64,\n+    ) -> AllocationRelocations<Tag> {\n+        let relocations = self.get_relocations(cx, src, size);\n+        if relocations.is_empty() {\n+            return AllocationRelocations { relative_relocations: Vec::new() };\n+        }\n+\n+        let mut new_relocations = Vec::with_capacity(relocations.len() * (length as usize));\n+\n+        for i in 0..length {\n+            new_relocations.extend(\n+                relocations\n+                .iter()\n+                .map(|&(offset, reloc)| {\n+                    // compute offset for current repetition\n+                    let dest_offset = dest.offset + (i * size);\n+                    (\n+                        // shift offsets from source allocation to destination allocation\n+                        offset + dest_offset - src.offset,\n+                        reloc,\n+                    )\n+                })\n+            );\n+        }\n+\n+        AllocationRelocations {\n+            relative_relocations: new_relocations,\n+        }\n+    }\n+\n+    /// Applies a relocation copy.\n+    /// The affected range, as defined in the parameters to `prepare_relocation_copy` is expected\n+    /// to be clear of relocations.\n+    pub fn mark_relocation_range(\n+        &mut self,\n+        relocations: AllocationRelocations<Tag>,\n+    ) {\n+        self.relocations.insert_presorted(relocations.relative_relocations);\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Undefined byte tracking\n ////////////////////////////////////////////////////////////////////////////////\n@@ -627,8 +838,8 @@ impl UndefMask {\n         let (blocka, bita) = bit_index(start);\n         let (blockb, bitb) = bit_index(end);\n         if blocka == blockb {\n-            // first set all bits but the first `bita`\n-            // then unset the last `64 - bitb` bits\n+            // First set all bits except the first `bita`,\n+            // then unset the last `64 - bitb` bits.\n             let range = if bitb == 0 {\n                 u64::max_value() << bita\n             } else {\n@@ -643,24 +854,24 @@ impl UndefMask {\n         }\n         // across block boundaries\n         if new_state {\n-            // set bita..64 to 1\n+            // Set `bita..64` to `1`.\n             self.blocks[blocka] |= u64::max_value() << bita;\n-            // set 0..bitb to 1\n+            // Set `0..bitb` to `1`.\n             if bitb != 0 {\n                 self.blocks[blockb] |= u64::max_value() >> (64 - bitb);\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = u64::max_value();\n             }\n         } else {\n-            // set bita..64 to 0\n+            // Set `bita..64` to `0`.\n             self.blocks[blocka] &= !(u64::max_value() << bita);\n-            // set 0..bitb to 0\n+            // Set `0..bitb` to `0`.\n             if bitb != 0 {\n                 self.blocks[blockb] &= !(u64::max_value() >> (64 - bitb));\n             }\n-            // fill in all the other blocks (much faster than one bit at a time)\n+            // Fill in all the other blocks (much faster than one bit at a time).\n             for block in (blocka + 1) .. blockb {\n                 self.blocks[block] = 0;\n             }\n@@ -697,7 +908,7 @@ impl UndefMask {\n             let additional_blocks = amount.bytes() / Self::BLOCK_SIZE + 1;\n             assert_eq!(additional_blocks as usize as u64, additional_blocks);\n             self.blocks.extend(\n-                // FIXME(oli-obk): optimize this by repeating `new_state as Block`\n+                // FIXME(oli-obk): optimize this by repeating `new_state as Block`.\n                 iter::repeat(0).take(additional_blocks as usize),\n             );\n         }"}, {"sha": "ac99ccd45eafe4e8b0c578a5d1c63d174e0bc3cf", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 36, "deletions": 16, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,23 +1,21 @@\n-use std::{fmt, env};\n+use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n \n use crate::hir;\n use crate::hir::map::definitions::DefPathData;\n use crate::mir;\n use crate::ty::{self, Ty, layout};\n use crate::ty::layout::{Size, Align, LayoutError};\n-use rustc_target::spec::abi::Abi;\n-use rustc_macros::HashStable;\n-\n-use super::{RawConst, Pointer, CheckInAllocMsg, ScalarMaybeUndef};\n+use crate::ty::query::TyCtxtAt;\n \n use backtrace::Backtrace;\n-\n-use crate::ty::query::TyCtxtAt;\n use errors::DiagnosticBuilder;\n-\n+use rustc_macros::HashStable;\n+use rustc_target::spec::abi::Abi;\n use syntax_pos::{Pos, Span};\n use syntax::symbol::Symbol;\n \n+use std::{fmt, env};\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, HashStable, RustcEncodable, RustcDecodable)]\n pub enum ErrorHandled {\n     /// Already reported a lint or an error for this evaluation.\n@@ -215,6 +213,15 @@ fn print_backtrace(backtrace: &mut Backtrace) {\n     eprintln!(\"\\n\\nAn error occurred in miri:\\n{:?}\", backtrace);\n }\n \n+impl From<ErrorHandled> for InterpErrorInfo<'tcx> {\n+    fn from(err: ErrorHandled) -> Self {\n+        match err {\n+            ErrorHandled::Reported => err_inval!(ReferencedConstant),\n+            ErrorHandled::TooGeneric => err_inval!(TooGeneric),\n+        }.into()\n+    }\n+}\n+\n impl<'tcx> From<InterpError<'tcx>> for InterpErrorInfo<'tcx> {\n     fn from(kind: InterpError<'tcx>) -> Self {\n         let backtrace = match env::var(\"RUSTC_CTFE_BACKTRACE\") {\n@@ -315,6 +322,9 @@ impl<O: fmt::Debug> fmt::Debug for PanicInfo<O> {\n     }\n }\n \n+/// Error information for when the program we executed turned out not to actually be a valid\n+/// program. This cannot happen in stand-alone Miri, but it can happen during CTFE/ConstProp\n+/// where we work on generic code or execution does not have all information available.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InvalidProgramInfo<'tcx> {\n     /// Resolution can fail if we are in a too generic context.\n@@ -344,6 +354,7 @@ impl fmt::Debug for InvalidProgramInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program caused Undefined Behavior.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UndefinedBehaviorInfo {\n     /// Free-form case. Only for errors that are never caught!\n@@ -366,12 +377,19 @@ impl fmt::Debug for UndefinedBehaviorInfo {\n     }\n }\n \n+/// Error information for when the program did something that might (or might not) be correct\n+/// to do according to the Rust spec, but due to limitations in the interpreter, the\n+/// operation could not be carried out. These limitations can differ between CTFE and the\n+/// Miri engine, e.g., CTFE does not support casting pointers to \"real\" integers.\n+///\n+/// Currently, we also use this as fall-back error kind for errors that have not been\n+/// categorized yet.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedOpInfo<'tcx> {\n     /// Free-form case. Only for errors that are never caught!\n     Unsupported(String),\n \n-    // -- Everything below is not classified yet --\n+    // -- Everything below is not categorized yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -430,13 +448,13 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n         match self {\n             PointerOutOfBounds { ptr, msg, allocation_size } => {\n                 write!(f, \"{} failed: pointer must be in-bounds at offset {}, \\\n-                          but is outside bounds of allocation {} which has size {}\",\n+                           but is outside bounds of allocation {} which has size {}\",\n                     msg, ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n             ValidationFailure(ref err) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n-            NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n+            NoMirFor(ref func) => write!(f, \"no MIR for `{}`\", func),\n             FunctionAbiMismatch(caller_abi, callee_abi) =>\n                 write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n                     callee_abi, caller_abi),\n@@ -451,9 +469,9 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             FunctionArgCountMismatch =>\n                 write!(f, \"tried to call a function with incorrect number of arguments\"),\n             ReallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n+                write!(f, \"tried to reallocate memory from `{}` to `{}`\", old, new),\n             DeallocatedWrongMemoryKind(ref old, ref new) =>\n-                write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n+                write!(f, \"tried to deallocate `{}` memory but gave `{}` as the kind\", old, new),\n             InvalidChar(c) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n             AlignmentCheckFailed { required, has } =>\n@@ -462,7 +480,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             TypeNotPrimitive(ty) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n             PathNotFound(ref path) =>\n-                write!(f, \"Cannot find path {:?}\", path),\n+                write!(f, \"cannot find path {:?}\", path),\n             IncorrectAllocationInformation(size, size2, align, align2) =>\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n                            got size {} and align {}\",\n@@ -525,7 +543,7 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n             InvalidBoolOp(_) =>\n                 write!(f, \"invalid boolean operation\"),\n             UnterminatedCString(_) =>\n-                write!(f, \"attempted to get length of a null terminated string, but no null \\\n+                write!(f, \"attempted to get length of a null-terminated string, but no null \\\n                     found before end of allocation\"),\n             ReadUndefBytes(_) =>\n                 write!(f, \"attempted to read undefined bytes\"),\n@@ -538,6 +556,8 @@ impl fmt::Debug for UnsupportedOpInfo<'tcx> {\n     }\n }\n \n+/// Error information for when the program exhausted the resources granted to it\n+/// by the interpreter.\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ResourceExhaustionInfo {\n     /// The stack grew too big.\n@@ -582,7 +602,7 @@ pub type InterpResult<'tcx, T = ()> = Result<T, InterpErrorInfo<'tcx>>;\n \n impl fmt::Display for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Forward `Display` to `Debug`\n+        // Forward `Display` to `Debug`.\n         write!(f, \"{:?}\", self)\n     }\n }"}, {"sha": "23433c2e8834d28dc65e8b162712e62451a96db6", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 55, "deletions": 54, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,4 +1,4 @@\n-//! An interpreter for MIR used in CTFE and by miri\n+//! An interpreter for MIR used in CTFE and by miri.\n \n #[macro_export]\n macro_rules! err_unsup {\n@@ -107,21 +107,21 @@ pub use self::allocation::{Allocation, AllocationExtra, Relocations, UndefMask};\n \n pub use self::pointer::{Pointer, PointerArithmetic, CheckInAllocMsg};\n \n-use std::fmt;\n use crate::mir;\n use crate::hir::def_id::DefId;\n use crate::ty::{self, TyCtxt, Instance, subst::UnpackedKind};\n+use crate::ty::codec::TyDecoder;\n use crate::ty::layout::{self, Size};\n use std::io;\n+use std::fmt;\n+use std::num::NonZeroU32;\n+use std::sync::atomic::{AtomicU32, Ordering};\n use rustc_serialize::{Encoder, Decodable, Encodable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::sync::{Lock as Mutex, HashMapExt};\n+use rustc_data_structures::sync::{Lock, HashMapExt};\n use rustc_data_structures::tiny_list::TinyList;\n use rustc_macros::HashStable;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n-use crate::ty::codec::TyDecoder;\n-use std::sync::atomic::{AtomicU32, Ordering};\n-use std::num::NonZeroU32;\n \n /// Uniquely identifies a specific constant or static.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n@@ -152,8 +152,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n     tcx: TyCtxt<'tcx>,\n     alloc_id: AllocId,\n ) -> Result<(), E::Error> {\n-    let alloc: GlobalAlloc<'tcx> =\n-        tcx.alloc_map.lock().get(alloc_id).expect(\"no value for AllocId\");\n+    let alloc: GlobalAlloc<'tcx> = tcx.alloc_map.lock().get(alloc_id)\n+        .expect(\"no value for given alloc ID\");\n     match alloc {\n         GlobalAlloc::Memory(alloc) => {\n             trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n@@ -166,8 +166,8 @@ pub fn specialized_encode_alloc_id<'tcx, E: Encoder>(\n             fn_instance.encode(encoder)?;\n         }\n         GlobalAlloc::Static(did) => {\n-            // referring to statics doesn't need to know about their allocations,\n-            // just about its DefId\n+            // References to statics doesn't need to know about their allocations,\n+            // just about its `DefId`.\n             AllocDiscriminant::Static.encode(encoder)?;\n             did.encode(encoder)?;\n         }\n@@ -187,19 +187,18 @@ enum State {\n }\n \n pub struct AllocDecodingState {\n-    // For each AllocId we keep track of which decoding state it's currently in.\n-    decoding_state: Vec<Mutex<State>>,\n+    // For each `AllocId`, we keep track of which decoding state it's currently in.\n+    decoding_state: Vec<Lock<State>>,\n     // The offsets of each allocation in the data stream.\n     data_offsets: Vec<u32>,\n }\n \n impl AllocDecodingState {\n-\n     pub fn new_decoding_session(&self) -> AllocDecodingSession<'_> {\n         static DECODER_SESSION_ID: AtomicU32 = AtomicU32::new(0);\n         let counter = DECODER_SESSION_ID.fetch_add(1, Ordering::SeqCst);\n \n-        // Make sure this is never zero\n+        // Make sure this is never zero.\n         let session_id = DecodingSessionId::new((counter & 0x7FFFFFFF) + 1).unwrap();\n \n         AllocDecodingSession {\n@@ -208,10 +207,10 @@ impl AllocDecodingState {\n         }\n     }\n \n-    pub fn new(data_offsets: Vec<u32>) -> AllocDecodingState {\n-        let decoding_state = vec![Mutex::new(State::Empty); data_offsets.len()];\n+    pub fn new(data_offsets: Vec<u32>) -> Self {\n+        let decoding_state = vec![Lock::new(State::Empty); data_offsets.len()];\n \n-        AllocDecodingState {\n+        Self {\n             decoding_state,\n             data_offsets,\n         }\n@@ -225,23 +224,23 @@ pub struct AllocDecodingSession<'s> {\n }\n \n impl<'s> AllocDecodingSession<'s> {\n-    // Decodes an AllocId in a thread-safe way.\n+    /// Decodes an `AllocId` in a thread-safe way.\n     pub fn decode_alloc_id<D>(&self, decoder: &mut D) -> Result<AllocId, D::Error>\n     where\n         D: TyDecoder<'tcx>,\n     {\n-        // Read the index of the allocation\n+        // Read the index of the allocation.\n         let idx = decoder.read_u32()? as usize;\n         let pos = self.state.data_offsets[idx] as usize;\n \n-        // Decode the AllocDiscriminant now so that we know if we have to reserve an\n-        // AllocId.\n+        // Decode the `AllocDiscriminant` now so that we know if we have to reserve an\n+        // `AllocId`.\n         let (alloc_kind, pos) = decoder.with_position(pos, |decoder| {\n             let alloc_kind = AllocDiscriminant::decode(decoder)?;\n             Ok((alloc_kind, decoder.position()))\n         })?;\n \n-        // Check the decoding state, see if it's already decoded or if we should\n+        // Check the decoding state to see if it's already decoded or if we should\n         // decode it here.\n         let alloc_id = {\n             let mut entry = self.state.decoding_state[idx].lock();\n@@ -251,20 +250,20 @@ impl<'s> AllocDecodingSession<'s> {\n                     return Ok(alloc_id);\n                 }\n                 ref mut entry @ State::Empty => {\n-                    // We are allowed to decode\n+                    // We are allowed to decode.\n                     match alloc_kind {\n                         AllocDiscriminant::Alloc => {\n                             // If this is an allocation, we need to reserve an\n-                            // AllocId so we can decode cyclic graphs.\n+                            // `AllocId` so we can decode cyclic graphs.\n                             let alloc_id = decoder.tcx().alloc_map.lock().reserve();\n                             *entry = State::InProgress(\n                                 TinyList::new_single(self.session_id),\n                                 alloc_id);\n                             Some(alloc_id)\n                         },\n                         AllocDiscriminant::Fn | AllocDiscriminant::Static => {\n-                            // Fns and statics cannot be cyclic and their AllocId\n-                            // is determined later by interning\n+                            // Fns and statics cannot be cyclic, and their `AllocId`\n+                            // is determined later by interning.\n                             *entry = State::InProgressNonAlloc(\n                                 TinyList::new_single(self.session_id));\n                             None\n@@ -273,9 +272,9 @@ impl<'s> AllocDecodingSession<'s> {\n                 }\n                 State::InProgressNonAlloc(ref mut sessions) => {\n                     if sessions.contains(&self.session_id) {\n-                        bug!(\"This should be unreachable\")\n+                        bug!(\"this should be unreachable\");\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         None\n                     }\n@@ -285,37 +284,38 @@ impl<'s> AllocDecodingSession<'s> {\n                         // Don't recurse.\n                         return Ok(alloc_id)\n                     } else {\n-                        // Start decoding concurrently\n+                        // Start decoding concurrently.\n                         sessions.insert(self.session_id);\n                         Some(alloc_id)\n                     }\n                 }\n             }\n         };\n \n-        // Now decode the actual data\n+        // Now decode the actual data.\n         let alloc_id = decoder.with_position(pos, |decoder| {\n             match alloc_kind {\n                 AllocDiscriminant::Alloc => {\n-                    let allocation = <&'tcx Allocation as Decodable>::decode(decoder)?;\n-                    // We already have a reserved AllocId.\n+                    let alloc = <&'tcx Allocation as Decodable>::decode(decoder)?;\n+                    // We already have a reserved `AllocId`.\n                     let alloc_id = alloc_id.unwrap();\n-                    trace!(\"decoded alloc {:?} {:#?}\", alloc_id, allocation);\n-                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, allocation);\n+                    trace!(\"decoded alloc {:?}: {:#?}\", alloc_id, alloc);\n+                    decoder.tcx().alloc_map.lock().set_alloc_id_same_memory(alloc_id, alloc);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Fn => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating fn alloc id\");\n+                    trace!(\"creating fn alloc ID\");\n                     let instance = ty::Instance::decode(decoder)?;\n                     trace!(\"decoded fn alloc instance: {:?}\", instance);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_fn_alloc(instance);\n                     Ok(alloc_id)\n                 },\n                 AllocDiscriminant::Static => {\n                     assert!(alloc_id.is_none());\n-                    trace!(\"creating extern static alloc id at\");\n+                    trace!(\"creating extern static alloc ID\");\n                     let did = DefId::decode(decoder)?;\n+                    trace!(\"decoded static def-ID: {:?}\", did);\n                     let alloc_id = decoder.tcx().alloc_map.lock().create_static_alloc(did);\n                     Ok(alloc_id)\n                 }\n@@ -340,7 +340,7 @@ impl fmt::Display for AllocId {\n /// a static, or a \"real\" allocation with some data in it.\n #[derive(Debug, Clone, Eq, PartialEq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n pub enum GlobalAlloc<'tcx> {\n-    /// The alloc ID is used as a function pointer\n+    /// The alloc ID is used as a function pointer.\n     Function(Instance<'tcx>),\n     /// The alloc ID points to a \"lazy\" static variable that did not get computed (yet).\n     /// This is also used to break the cycle in recursive statics.\n@@ -350,16 +350,17 @@ pub enum GlobalAlloc<'tcx> {\n }\n \n pub struct AllocMap<'tcx> {\n-    /// Lets you know what an `AllocId` refers to.\n+    /// Maps `AllocId`s to their corresponding allocations.\n     alloc_map: FxHashMap<AllocId, GlobalAlloc<'tcx>>,\n \n     /// Used to ensure that statics and functions only get one associated `AllocId`.\n     /// Should never contain a `GlobalAlloc::Memory`!\n-    /// FIXME: Should we just have two separate dedup maps for statics and functions each?\n+    //\n+    // FIXME: Should we just have two separate dedup maps for statics and functions each?\n     dedup: FxHashMap<GlobalAlloc<'tcx>, AllocId>,\n \n     /// The `AllocId` to assign to the next requested ID.\n-    /// Always incremented, never gets smaller.\n+    /// Always incremented; never gets smaller.\n     next_id: AllocId,\n }\n \n@@ -389,7 +390,7 @@ impl<'tcx> AllocMap<'tcx> {\n         next\n     }\n \n-    /// Reserve a new ID *if* this allocation has not been dedup-reserved before.\n+    /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n     fn reserve_and_set_dedup(&mut self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n@@ -430,17 +431,17 @@ impl<'tcx> AllocMap<'tcx> {\n             }\n         });\n         if is_generic {\n-            // Get a fresh ID\n+            // Get a fresh ID.\n             let id = self.reserve();\n             self.alloc_map.insert(id, GlobalAlloc::Function(instance));\n             id\n         } else {\n-            // Deduplicate\n+            // Deduplicate.\n             self.reserve_and_set_dedup(GlobalAlloc::Function(instance))\n         }\n     }\n \n-    /// Intern the `Allocation` and return a new `AllocId`, even if there's already an identical\n+    /// Interns the `Allocation` and return a new `AllocId`, even if there's already an identical\n     /// `Allocation` with a different `AllocId`.\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n@@ -465,19 +466,19 @@ impl<'tcx> AllocMap<'tcx> {\n     pub fn unwrap_memory(&self, id: AllocId) -> &'tcx Allocation {\n         match self.get(id) {\n             Some(GlobalAlloc::Memory(mem)) => mem,\n-            _ => bug!(\"expected allocation id {} to point to memory\", id),\n+            _ => bug!(\"expected allocation ID {} to point to memory\", id),\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n     pub fn set_alloc_id_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n-            bug!(\"tried to set allocation id {}, but it was already existing as {:#?}\", id, old);\n+            bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n-    /// Freeze an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n+    /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n     fn set_alloc_id_same_memory(&mut self, id: AllocId, mem: &'tcx Allocation) {\n         self.alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n@@ -513,7 +514,7 @@ pub fn read_target_uint(endianness: layout::Endian, mut source: &[u8]) -> Result\n // Methods to facilitate working with signed integers stored in a u128\n ////////////////////////////////////////////////////////////////////////////////\n \n-/// Truncate `value` to `size` bits and then sign-extend it to 128 bits\n+/// Truncates `value` to `size` bits and then sign-extend it to 128 bits\n /// (i.e., if it is negative, fill with 1's on the left).\n #[inline]\n pub fn sign_extend(value: u128, size: Size) -> u128 {\n@@ -522,14 +523,14 @@ pub fn sign_extend(value: u128, size: Size) -> u128 {\n         // Truncated until nothing is left.\n         return 0;\n     }\n-    // sign extend\n+    // Sign-extend it.\n     let shift = 128 - size;\n-    // shift the unsigned value to the left\n-    // and back to the right as signed (essentially fills with FF on the left)\n+    // Shift the unsigned value to the left, then shift back to the right as signed\n+    // (essentially fills with FF on the left).\n     (((value << shift) as i128) >> shift) as u128\n }\n \n-/// Truncate `value` to `size` bits.\n+/// Truncates `value` to `size` bits.\n #[inline]\n pub fn truncate(value: u128, size: Size) -> u128 {\n     let size = size.bits();\n@@ -538,6 +539,6 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n         return 0;\n     }\n     let shift = 128 - size;\n-    // truncate (shift left to drop out leftover values, shift right to fill with zeroes)\n+    // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }"}, {"sha": "1bb4d9ea4d6d92edddac3a6541ec36a84f930145", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -86,18 +86,17 @@ pub trait PointerArithmetic: layout::HasDataLayout {\n \n impl<T: layout::HasDataLayout> PointerArithmetic for T {}\n \n-\n-/// Pointer is generic over the type that represents a reference to Allocations,\n+/// `Pointer` is generic over the type that represents a reference to `Allocation`s,\n /// thus making it possible for the most convenient representation to be used in\n /// each context.\n ///\n-/// Defaults to the index based and loosely coupled AllocId.\n+/// Defaults to the index based and loosely coupled `AllocId`.\n ///\n /// Pointer is also generic over the `Tag` associated with each pointer,\n /// which is used to do provenance tracking during execution.\n #[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub struct Pointer<Tag=(),Id=AllocId> {\n+pub struct Pointer<Tag = (), Id = AllocId> {\n     pub alloc_id: Id,\n     pub offset: Size,\n     pub tag: Tag,\n@@ -117,7 +116,7 @@ impl<Id: fmt::Debug> fmt::Debug for Pointer<(), Id> {\n     }\n }\n \n-/// Produces a `Pointer` which points to the beginning of the Allocation\n+/// Produces a `Pointer` which points to the beginning of the `Allocation`.\n impl From<AllocId> for Pointer {\n     #[inline(always)]\n     fn from(alloc_id: AllocId) -> Self {"}, {"sha": "b8bc74141973882f992c236832f625986dfc7945", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -17,8 +17,8 @@ pub struct RawConst<'tcx> {\n     pub ty: Ty<'tcx>,\n }\n \n-/// Represents a constant value in Rust. `Scalar` and `ScalarPair` are optimizations that\n-/// match the `LocalState` optimizations for easy conversions between `Value` and `ConstValue`.\n+/// Represents a constant value in Rust. `Scalar` and `Slice` are optimizations for\n+/// array length computations, enum discriminants and the pattern matching logic.\n #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub enum ConstValue<'tcx> {\n@@ -91,7 +91,7 @@ impl<'tcx> ConstValue<'tcx> {\n /// of a simple value or a pointer into another `Allocation`\n #[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd,\n          RustcEncodable, RustcDecodable, Hash, HashStable)]\n-pub enum Scalar<Tag=(), Id=AllocId> {\n+pub enum Scalar<Tag = (), Id = AllocId> {\n     /// The raw bytes of a simple value.\n     Raw {\n         /// The first `size` bytes of `data` are the value.\n@@ -359,7 +359,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_bits(self, target_size: Size) -> u128 {\n-        self.to_bits(target_size).expect(\"Expected Raw bits but got a Pointer\")\n+        self.to_bits(target_size).expect(\"expected Raw bits but got a Pointer\")\n     }\n \n     /// Do not call this method!  Use either `assert_ptr` or `force_ptr`.\n@@ -374,7 +374,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n \n     #[inline(always)]\n     pub fn assert_ptr(self) -> Pointer<Tag> {\n-        self.to_ptr().expect(\"Expected a Pointer but got Raw bits\")\n+        self.to_ptr().expect(\"expected a Pointer but got Raw bits\")\n     }\n \n     /// Do not call this method!  Dispatch based on the type instead.\n@@ -482,8 +482,8 @@ impl<Tag> From<Pointer<Tag>> for Scalar<Tag> {\n     }\n }\n \n-#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, RustcEncodable, RustcDecodable, Hash)]\n-pub enum ScalarMaybeUndef<Tag=(), Id=AllocId> {\n+#[derive(Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Hash, RustcEncodable, RustcDecodable)]\n+pub enum ScalarMaybeUndef<Tag = (), Id = AllocId> {\n     Scalar(Scalar<Tag, Id>),\n     Undef,\n }"}, {"sha": "92efcf44dea3636ce1fcad46d89d0f48322056fc", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 278, "deletions": 311, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -18,6 +18,7 @@ use crate::ty::{\n     self, AdtDef, CanonicalUserTypeAnnotations, ClosureSubsts, GeneratorSubsts, Region, Ty, TyCtxt,\n     UserTypeAnnotationIndex,\n };\n+\n use polonius_engine::Atom;\n use rustc_data_structures::bit_set::BitMatrix;\n use rustc_data_structures::fx::FxHashSet;\n@@ -31,7 +32,6 @@ use rustc_serialize::{Encodable, Decodable};\n use smallvec::SmallVec;\n use std::borrow::Cow;\n use std::fmt::{self, Debug, Display, Formatter, Write};\n-use std::iter::FusedIterator;\n use std::ops::{Index, IndexMut};\n use std::slice;\n use std::vec::IntoIter;\n@@ -70,7 +70,7 @@ impl<'tcx> HasLocalDecls<'tcx> for Body<'tcx> {\n \n /// The various \"big phases\" that MIR goes through.\n ///\n-/// Warning: ordering of variants is significant\n+/// Warning: ordering of variants is significant.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, PartialOrd, Ord)]\n pub enum MirPhase {\n     Build = 0,\n@@ -80,16 +80,16 @@ pub enum MirPhase {\n }\n \n impl MirPhase {\n-    /// Gets the index of the current MirPhase within the set of all MirPhases.\n+    /// Gets the index of the current MirPhase within the set of all `MirPhase`s.\n     pub fn phase_index(&self) -> usize {\n         *self as usize\n     }\n }\n \n-/// Lowered representation of a single function.\n+/// The lowered representation of a single function.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Body<'tcx> {\n-    /// List of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n+    /// A list of basic blocks. References to basic block use a newtyped index type `BasicBlock`\n     /// that indexes into this vector.\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n \n@@ -100,23 +100,18 @@ pub struct Body<'tcx> {\n     /// us to see the difference and forego optimization on the inlined promoted items.\n     pub phase: MirPhase,\n \n-    /// List of source scopes; these are referenced by statements\n+    /// A list of source scopes; these are referenced by statements\n     /// and used for debuginfo. Indexed by a `SourceScope`.\n     pub source_scopes: IndexVec<SourceScope, SourceScopeData>,\n \n     /// Crate-local information for each source scope, that can't (and\n     /// needn't) be tracked across crates.\n     pub source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n \n-    /// Rvalues promoted from this function, such as borrows of constants.\n-    /// Each of them is the Body of a constant with the fn's type parameters\n-    /// in scope, but a separate set of locals.\n-    pub promoted: IndexVec<Promoted, Body<'tcx>>,\n-\n-    /// Yields type of the function, if it is a generator.\n+    /// The yield type of the function, if it is a generator.\n     pub yield_ty: Option<Ty<'tcx>>,\n \n-    /// Generator drop glue\n+    /// Generator drop glue.\n     pub generator_drop: Option<Box<Body<'tcx>>>,\n \n     /// The layout of a generator. Produced by the state transformation.\n@@ -129,10 +124,10 @@ pub struct Body<'tcx> {\n     /// variables and temporaries.\n     pub local_decls: LocalDecls<'tcx>,\n \n-    /// User type annotations\n+    /// User type annotations.\n     pub user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n \n-    /// Number of arguments this function takes.\n+    /// The number of arguments this function takes.\n     ///\n     /// Starting at local 1, `arg_count` locals will be provided by the caller\n     /// and can be assumed to be initialized.\n@@ -148,10 +143,11 @@ pub struct Body<'tcx> {\n \n     /// Names and capture modes of all the closure upvars, assuming\n     /// the first argument is either the closure or a reference to it.\n+    //\n     // NOTE(eddyb) This is *strictly* a temporary hack for codegen\n     // debuginfo generation, and will be removed at some point.\n-    // Do **NOT** use it for anything else, upvar information should not be\n-    // in the MIR, please rely on local crate HIR or other side-channels.\n+    // Do **NOT** use it for anything else; upvar information should not be\n+    // in the MIR, so please rely on local crate HIR or other side-channels.\n     pub __upvar_debuginfo_codegen_only_do_not_use: Vec<UpvarDebuginfo>,\n \n     /// Mark this MIR of a const context other than const functions as having converted a `&&` or\n@@ -162,10 +158,10 @@ pub struct Body<'tcx> {\n     /// List of places where control flow was destroyed. Used for error reporting.\n     pub control_flow_destroyed: Vec<(Span, String)>,\n \n-    /// A span representing this MIR, for error reporting\n+    /// A span representing this MIR, for error reporting.\n     pub span: Span,\n \n-    /// A cache for various calculations\n+    /// A cache for various calculations.\n     cache: cache::Cache,\n }\n \n@@ -174,7 +170,6 @@ impl<'tcx> Body<'tcx> {\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData>,\n         source_scope_local_data: ClearCrossCrate<IndexVec<SourceScope, SourceScopeLocalData>>,\n-        promoted: IndexVec<Promoted, Body<'tcx>>,\n         yield_ty: Option<Ty<'tcx>>,\n         local_decls: LocalDecls<'tcx>,\n         user_type_annotations: CanonicalUserTypeAnnotations<'tcx>,\n@@ -183,7 +178,7 @@ impl<'tcx> Body<'tcx> {\n         span: Span,\n         control_flow_destroyed: Vec<(Span, String)>,\n     ) -> Self {\n-        // We need `arg_count` locals, and one for the return place\n+        // We need `arg_count` locals, and one for the return place.\n         assert!(\n             local_decls.len() >= arg_count + 1,\n             \"expected at least {} locals, got {}\",\n@@ -196,7 +191,6 @@ impl<'tcx> Body<'tcx> {\n             basic_blocks,\n             source_scopes,\n             source_scope_local_data,\n-            promoted,\n             yield_ty,\n             generator_drop: None,\n             generator_layout: None,\n@@ -391,12 +385,12 @@ impl<'tcx> Body<'tcx> {\n         true\n     }\n \n-    /// Returns the return type, it always return first element from `local_decls` array\n+    /// Returns the return type; it always return first element from `local_decls` array.\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n \n-    /// Gets the location of the terminator for the given block\n+    /// Gets the location of the terminator for the given block.\n     pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n         Location { block: bb, statement_index: self[bb].statements.len() }\n     }\n@@ -418,7 +412,6 @@ impl_stable_hash_for!(struct Body<'tcx> {\n     basic_blocks,\n     source_scopes,\n     source_scope_local_data,\n-    promoted,\n     yield_ty,\n     generator_drop,\n     generator_layout,\n@@ -471,7 +464,7 @@ impl<T: Decodable> rustc_serialize::UseSpecializedDecodable for ClearCrossCrate<\n /// Most passes can work with it as a whole, within a single function.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, HashStable)]\n pub struct SourceInfo {\n-    /// Source span for the AST pertaining to this MIR entity.\n+    /// The source span for the AST pertaining to this MIR entity.\n     pub span: Span,\n \n     /// The source scope, keeping track of which bindings can be\n@@ -599,13 +592,13 @@ impl Atom for Local {\n /// Classifies locals into categories. See `Body::local_kind`.\n #[derive(PartialEq, Eq, Debug, HashStable)]\n pub enum LocalKind {\n-    /// User-declared variable binding\n+    /// User-declared variable binding.\n     Var,\n-    /// Compiler-introduced temporary\n+    /// Compiler-introduced temporary.\n     Temp,\n-    /// Function argument\n+    /// Function argument.\n     Arg,\n-    /// Location of function's return value\n+    /// Location of function's return value.\n     ReturnPointer,\n }\n \n@@ -627,7 +620,7 @@ pub struct VarBindingForm<'tcx> {\n     /// (b) it gives a way to separate this case from the remaining cases\n     ///     for diagnostics.\n     pub opt_match_place: Option<(Option<Place<'tcx>>, Span)>,\n-    /// Span of the pattern in which this variable was bound.\n+    /// The span of the pattern in which this variable was bound.\n     pub pat_span: Span,\n }\n \n@@ -729,12 +722,12 @@ impl_stable_hash_for!(struct BlockTailInfo { tail_result_is_ignored });\n /// argument, or the return place.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct LocalDecl<'tcx> {\n-    /// `let mut x` vs `let x`.\n+    /// Whether this is a mutable minding (i.e., `let x` or `let mut x`).\n     ///\n     /// Temporaries and the return place are always mutable.\n     pub mutability: Mutability,\n \n-    /// Some(binding_mode) if this corresponds to a user-declared local variable.\n+    /// `Some(binding_mode)` if this corresponds to a user-declared local variable.\n     ///\n     /// This is solely used for local diagnostics when generating\n     /// warnings/errors when compiling the current crate, and\n@@ -768,7 +761,7 @@ pub struct LocalDecl<'tcx> {\n     /// intervening statement context).\n     pub is_block_tail: Option<BlockTailInfo>,\n \n-    /// Type of this local.\n+    /// The type of this local.\n     pub ty: Ty<'tcx>,\n \n     /// If the user manually ascribed a type to this variable,\n@@ -777,7 +770,7 @@ pub struct LocalDecl<'tcx> {\n     /// region inference.\n     pub user_ty: UserTypeProjections,\n \n-    /// Name of the local, used in debuginfo and pretty-printing.\n+    /// The name of the local, used in debuginfo and pretty-printing.\n     ///\n     /// Note that function arguments can also have this set to `Some(_)`\n     /// to generate better debuginfo.\n@@ -845,8 +838,8 @@ pub struct LocalDecl<'tcx> {\n     /// ROOT SCOPE\n     ///  \u2502{ argument x: &str }\n     ///  \u2502\n-    ///  \u2502 \u2502{ #[allow(unused_mut)] } // this is actually split into 2 scopes\n-    ///  \u2502 \u2502                        // in practice because I'm lazy.\n+    ///  \u2502 \u2502{ #[allow(unused_mut)] } // This is actually split into 2 scopes\n+    ///  \u2502 \u2502                         // in practice because I'm lazy.\n     ///  \u2502 \u2502\n     ///  \u2502 \u2502\u2190 x.source_info.scope\n     ///  \u2502 \u2502\u2190 `x.parse().unwrap()`\n@@ -860,7 +853,7 @@ pub struct LocalDecl<'tcx> {\n     ///  \u2502\n     ///  \u2502 \u2502{ let x: u32 }\n     ///  \u2502 \u2502\u2190 x.visibility_scope\n-    ///  \u2502 \u2502\u2190 `drop(x)` // this accesses `x: u32`\n+    ///  \u2502 \u2502\u2190 `drop(x)` // This accesses `x: u32`.\n     /// ```\n     pub source_info: SourceInfo,\n \n@@ -1046,16 +1039,16 @@ pub struct Terminator<'tcx> {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum TerminatorKind<'tcx> {\n-    /// block should have one successor in the graph; we jump there\n+    /// Block should have one successor in the graph; we jump there.\n     Goto { target: BasicBlock },\n \n-    /// operand evaluates to an integer; jump depending on its value\n-    /// to one of the targets, and otherwise fallback to `otherwise`\n+    /// Operand evaluates to an integer; jump depending on its value\n+    /// to one of the targets, and otherwise fallback to `otherwise`.\n     SwitchInt {\n-        /// discriminant value being tested\n+        /// The discriminant value being tested.\n         discr: Operand<'tcx>,\n \n-        /// type of value being tested\n+        /// The type of value being tested.\n         switch_ty: Ty<'tcx>,\n \n         /// Possible values. The locations to branch to in each case\n@@ -1065,6 +1058,7 @@ pub enum TerminatorKind<'tcx> {\n         /// Possible branch sites. The last element of this vector is used\n         /// for the otherwise branch, so targets.len() == values.len() + 1\n         /// should hold.\n+        //\n         // This invariant is quite non-obvious and also could be improved.\n         // One way to make this invariant is to have something like this instead:\n         //\n@@ -1077,7 +1071,7 @@ pub enum TerminatorKind<'tcx> {\n     },\n \n     /// Indicates that the landing pad is finished and unwinding should\n-    /// continue. Emitted by build::scope::diverge_cleanup.\n+    /// continue. Emitted by `build::scope::diverge_cleanup`.\n     Resume,\n \n     /// Indicates that the landing pad is finished and that the process\n@@ -1091,10 +1085,10 @@ pub enum TerminatorKind<'tcx> {\n     /// Indicates a terminator that can never be reached.\n     Unreachable,\n \n-    /// Drop the Place\n+    /// Drop the `Place`.\n     Drop { location: Place<'tcx>, target: BasicBlock, unwind: Option<BasicBlock> },\n \n-    /// Drop the Place and assign the new value over it. This ensures\n+    /// Drop the `Place` and assign the new value over it. This ensures\n     /// that the assignment to `P` occurs *even if* the destructor for\n     /// place unwinds. Its semantics are best explained by the\n     /// elaboration:\n@@ -1127,9 +1121,9 @@ pub enum TerminatorKind<'tcx> {\n         unwind: Option<BasicBlock>,\n     },\n \n-    /// Block ends with a call of a converging function\n+    /// Block ends with a call of a converging function.\n     Call {\n-        /// The function that\u2019s being called\n+        /// The function that\u2019s being called.\n         func: Operand<'tcx>,\n         /// Arguments the function is called with.\n         /// These are owned by the callee, which is free to modify them.\n@@ -1140,7 +1134,7 @@ pub enum TerminatorKind<'tcx> {\n         destination: Option<(Place<'tcx>, BasicBlock)>,\n         /// Cleanups to be done if the call unwinds.\n         cleanup: Option<BasicBlock>,\n-        /// Whether this is from a call in HIR, rather than from an overloaded\n+        /// `true` if this is from a call in HIR rather than from an overloaded\n         /// operator. True for overloaded function call.\n         from_hir_call: bool,\n     },\n@@ -1155,40 +1149,40 @@ pub enum TerminatorKind<'tcx> {\n         cleanup: Option<BasicBlock>,\n     },\n \n-    /// A suspend point\n+    /// A suspend point.\n     Yield {\n-        /// The value to return\n+        /// The value to return.\n         value: Operand<'tcx>,\n-        /// Where to resume to\n+        /// Where to resume to.\n         resume: BasicBlock,\n-        /// Cleanup to be done if the generator is dropped at this suspend point\n+        /// Cleanup to be done if the generator is dropped at this suspend point.\n         drop: Option<BasicBlock>,\n     },\n \n-    /// Indicates the end of the dropping of a generator\n+    /// Indicates the end of the dropping of a generator.\n     GeneratorDrop,\n \n     /// A block where control flow only ever takes one real path, but borrowck\n     /// needs to be more conservative.\n     FalseEdges {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// A block control flow could conceptually jump to, but won't in\n-        /// practice\n+        /// practice.\n         imaginary_target: BasicBlock,\n     },\n     /// A terminator for blocks that only take one path in reality, but where we\n     /// reserve the right to unwind in borrowck, even if it won't happen in practice.\n     /// This can arise in infinite loops with no function calls for example.\n     FalseUnwind {\n-        /// The target normal control flow will take\n+        /// The target normal control flow will take.\n         real_target: BasicBlock,\n         /// The imaginary cleanup block link. This particular path will never be taken\n         /// in practice, but in order to avoid fragility we want to always\n         /// consider it in borrowck. We don't want to accept programs which\n-        /// pass borrowck only when panic=abort or some assertions are disabled\n-        /// due to release vs. debug mode builds. This needs to be an Option because\n-        /// of the remove_noop_landing_pads and no_landing_pads passes\n+        /// pass borrowck only when `panic=abort` or some assertions are disabled\n+        /// due to release vs. debug mode builds. This needs to be an `Option` because\n+        /// of the `remove_noop_landing_pads` and `no_landing_pads` passes.\n         unwind: Option<BasicBlock>,\n     },\n }\n@@ -1453,7 +1447,7 @@ impl<'tcx> Debug for TerminatorKind<'tcx> {\n }\n \n impl<'tcx> TerminatorKind<'tcx> {\n-    /// Write the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n+    /// Writes the \"head\" part of the terminator; that is, its name and the data it uses to pick the\n     /// successor basic block, if any. The only information not included is the list of possible\n     /// successors, which may be rendered differently between the text and the graphviz format.\n     pub fn fmt_head<W: Write>(&self, fmt: &mut W) -> fmt::Result {\n@@ -1553,9 +1547,9 @@ pub struct Statement<'tcx> {\n \n // `Statement` is used a lot. Make sure it doesn't unintentionally get bigger.\n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(Statement<'_>, 56);\n+static_assert_size!(Statement<'_>, 32);\n \n-impl<'tcx> Statement<'tcx> {\n+impl Statement<'_> {\n     /// Changes a statement to a nop. This is both faster than deleting instructions and avoids\n     /// invalidating statement indices in `Location`s.\n     pub fn make_nop(&mut self) {\n@@ -1574,7 +1568,7 @@ impl<'tcx> Statement<'tcx> {\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum StatementKind<'tcx> {\n     /// Write the RHS Rvalue to the LHS Place.\n-    Assign(Place<'tcx>, Box<Rvalue<'tcx>>),\n+    Assign(Box<(Place<'tcx>, Rvalue<'tcx>)>),\n \n     /// This represents all the reading that a pattern match may do\n     /// (e.g., inspecting constants and discriminant values), and the\n@@ -1583,10 +1577,10 @@ pub enum StatementKind<'tcx> {\n     ///\n     /// Note that this also is emitted for regular `let` bindings to ensure that locals that are\n     /// never accessed still get some sanity checks for, e.g., `let x: ! = ..;`\n-    FakeRead(FakeReadCause, Place<'tcx>),\n+    FakeRead(FakeReadCause, Box<Place<'tcx>>),\n \n     /// Write the discriminant for a variant to the enum Place.\n-    SetDiscriminant { place: Place<'tcx>, variant_index: VariantIdx },\n+    SetDiscriminant { place: Box<Place<'tcx>>, variant_index: VariantIdx },\n \n     /// Start a live range for the storage of the local.\n     StorageLive(Local),\n@@ -1603,7 +1597,7 @@ pub enum StatementKind<'tcx> {\n     /// by miri and only generated when \"-Z mir-emit-retag\" is passed.\n     /// See <https://internals.rust-lang.org/t/stacked-borrows-an-aliasing-model-for-rust/8153/>\n     /// for more details.\n-    Retag(RetagKind, Place<'tcx>),\n+    Retag(RetagKind, Box<Place<'tcx>>),\n \n     /// Encodes a user's type ascription. These need to be preserved\n     /// intact so that NLL can respect them. For example:\n@@ -1617,26 +1611,26 @@ pub enum StatementKind<'tcx> {\n     /// - `Contravariant` -- requires that `T_y :> T`\n     /// - `Invariant` -- requires that `T_y == T`\n     /// - `Bivariant` -- no effect\n-    AscribeUserType(Place<'tcx>, ty::Variance, Box<UserTypeProjection>),\n+    AscribeUserType(Box<(Place<'tcx>, UserTypeProjection)>, ty::Variance),\n \n     /// No-op. Useful for deleting instructions without affecting statement indices.\n     Nop,\n }\n \n-/// `RetagKind` describes what kind of retag is to be performed.\n+/// Describes what kind of retag is to be performed.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, PartialEq, Eq, HashStable)]\n pub enum RetagKind {\n-    /// The initial retag when entering a function\n+    /// The initial retag when entering a function.\n     FnEntry,\n-    /// Retag preparing for a two-phase borrow\n+    /// Retag preparing for a two-phase borrow.\n     TwoPhase,\n-    /// Retagging raw pointers\n+    /// Retagging raw pointers.\n     Raw,\n-    /// A \"normal\" retag\n+    /// A \"normal\" retag.\n     Default,\n }\n \n-/// The `FakeReadCause` describes the type of pattern why a `FakeRead` statement exists.\n+/// The `FakeReadCause` describes the type of pattern why a FakeRead statement exists.\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum FakeReadCause {\n     /// Inject a fake read of the borrowed input at the end of each guards\n@@ -1677,11 +1671,11 @@ pub struct InlineAsm<'tcx> {\n     pub inputs: Box<[(Span, Operand<'tcx>)]>,\n }\n \n-impl<'tcx> Debug for Statement<'tcx> {\n+impl Debug for Statement<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         use self::StatementKind::*;\n         match self.kind {\n-            Assign(ref place, ref rv) => write!(fmt, \"{:?} = {:?}\", place, rv),\n+            Assign(box(ref place, ref rv)) => write!(fmt, \"{:?} = {:?}\", place, rv),\n             FakeRead(ref cause, ref place) => write!(fmt, \"FakeRead({:?}, {:?})\", cause, place),\n             Retag(ref kind, ref place) => write!(\n                 fmt,\n@@ -1702,7 +1696,7 @@ impl<'tcx> Debug for Statement<'tcx> {\n             InlineAsm(ref asm) => {\n                 write!(fmt, \"asm!({:?} : {:?} : {:?})\", asm.asm, asm.outputs, asm.inputs)\n             }\n-            AscribeUserType(ref place, ref variance, ref c_ty) => {\n+            AscribeUserType(box(ref place, ref c_ty), ref variance) => {\n                 write!(fmt, \"AscribeUserType({:?}, {:?}, {:?})\", place, variance, c_ty)\n             }\n             Nop => write!(fmt, \"nop\"),\n@@ -1722,7 +1716,7 @@ pub struct Place<'tcx> {\n     pub base: PlaceBase<'tcx>,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n-    pub projection: Option<Box<Projection<'tcx>>>,\n+    pub projection: Box<[PlaceElem<'tcx>]>,\n }\n \n #[derive(\n@@ -1737,34 +1731,34 @@ pub enum PlaceBase<'tcx> {\n }\n \n /// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub struct Static<'tcx> {\n     pub ty: Ty<'tcx>,\n-    pub kind: StaticKind,\n+    pub kind: StaticKind<'tcx>,\n+    /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n+    /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n+    /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n+    /// into the calling frame.\n+    pub def_id: DefId,\n }\n \n #[derive(\n-    Clone, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n+    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, HashStable, RustcEncodable, RustcDecodable,\n )]\n-pub enum StaticKind {\n-    Promoted(Promoted),\n-    Static(DefId),\n+pub enum StaticKind<'tcx> {\n+    /// Promoted references consist of an id (`Promoted`) and the substs necessary to monomorphize\n+    /// it. Usually, these substs are just the identity substs for the item. However, the inliner\n+    /// will adjust these substs when it inlines a function based on the substs at the callsite.\n+    Promoted(Promoted, SubstsRef<'tcx>),\n+    Static,\n }\n \n impl_stable_hash_for!(struct Static<'tcx> {\n     ty,\n-    kind\n+    kind,\n+    def_id\n });\n \n-/// The `Projection` data structure defines things of the form `base.x`, `*b` or `b[index]`.\n-#[derive(\n-    Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n-)]\n-pub struct Projection<'tcx> {\n-    pub base: Option<Box<Projection<'tcx>>>,\n-    pub elem: PlaceElem<'tcx>,\n-}\n-\n #[derive(\n     Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable,\n )]\n@@ -1807,6 +1801,23 @@ pub enum ProjectionElem<V, T> {\n     Downcast(Option<Symbol>, VariantIdx),\n }\n \n+impl<V, T> ProjectionElem<V, T> {\n+    /// Returns `true` if the target of this projection may refer to a different region of memory\n+    /// than the base.\n+    fn is_indirect(&self) -> bool {\n+        match self {\n+            Self::Deref => true,\n+\n+            | Self::Field(_, _)\n+            | Self::Index(_)\n+            | Self::ConstantIndex { .. }\n+            | Self::Subslice { .. }\n+            | Self::Downcast(_, _)\n+            => false\n+        }\n+    }\n+}\n+\n /// Alias for projections as they appear in places, where the base is a place\n /// and the index is a local.\n pub type PlaceElem<'tcx> = ProjectionElem<Local, Ty<'tcx>>;\n@@ -1829,14 +1840,22 @@ newtype_index! {\n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n     pub base: &'a PlaceBase<'tcx>,\n-    pub projection: &'a Option<Box<Projection<'tcx>>>,\n+    pub projection: &'a [PlaceElem<'tcx>],\n }\n \n impl<'tcx> Place<'tcx> {\n-    pub const RETURN_PLACE: Place<'tcx> = Place {\n-        base: PlaceBase::Local(RETURN_PLACE),\n-        projection: None,\n-    };\n+    // FIXME change this back to a const when projection is a shared slice.\n+    //\n+    // pub const RETURN_PLACE: Place<'tcx> = Place {\n+    //     base: PlaceBase::Local(RETURN_PLACE),\n+    //     projection: &[],\n+    // };\n+    pub fn return_place() -> Place<'tcx> {\n+        Place {\n+            base: PlaceBase::Local(RETURN_PLACE),\n+            projection: Box::new([]),\n+        }\n+    }\n \n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n@@ -1862,12 +1881,24 @@ impl<'tcx> Place<'tcx> {\n     }\n \n     pub fn elem(self, elem: PlaceElem<'tcx>) -> Place<'tcx> {\n+        // FIXME(spastorino): revisit this again once projection is not a Box<[T]> anymore\n+        let mut projection = self.projection.into_vec();\n+        projection.push(elem);\n+\n         Place {\n             base: self.base,\n-            projection: Some(Box::new(Projection { base: self.projection, elem })),\n+            projection: projection.into_boxed_slice(),\n         }\n     }\n \n+    /// Returns `true` if this `Place` contains a `Deref` projection.\n+    ///\n+    /// If `Place::is_indirect` returns false, the caller knows that the `Place` refers to the\n+    /// same region of memory as its base.\n+    pub fn is_indirect(&self) -> bool {\n+        self.projection.iter().any(|elem| elem.is_indirect())\n+    }\n+\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -1876,59 +1907,23 @@ impl<'tcx> Place<'tcx> {\n         match self {\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: box [],\n             } |\n             Place {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: box [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n \n-    /// Recursively \"iterates\" over place components, generating a `PlaceBase` and\n-    /// `Projections` list and invoking `op` with a `ProjectionsIter`.\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(&self.base, &self.projection, op)\n-    }\n-\n-    pub fn iterate_over<R>(\n-        place_base: &PlaceBase<'tcx>,\n-        place_projection: &Option<Box<Projection<'tcx>>>,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        fn iterate_over2<'tcx, R>(\n-            place_base: &PlaceBase<'tcx>,\n-            place_projection: &Option<Box<Projection<'tcx>>>,\n-            next: &Projections<'_, 'tcx>,\n-            op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-        ) -> R {\n-            match place_projection {\n-                None => {\n-                    op(place_base, next.iter())\n-                }\n-\n-                Some(interior) => {\n-                    iterate_over2(\n-                        place_base,\n-                        &interior.base,\n-                        &Projections::List {\n-                            projection: interior,\n-                            next,\n-                        },\n-                        op,\n-                    )\n-                }\n-            }\n+    /// If this place represents a local variable like `_X` with no\n+    /// projections, return `Some(_X)`.\n+    pub fn as_local(&self) -> Option<Local> {\n+        match self {\n+            Place { projection: box [], base: PlaceBase::Local(l) } => Some(*l),\n+            _ => None,\n         }\n-\n-        iterate_over2(place_base, place_projection, &Projections::Empty, op)\n     }\n \n     pub fn as_ref(&self) -> PlaceRef<'_, 'tcx> {\n@@ -1943,7 +1938,7 @@ impl From<Local> for Place<'_> {\n     fn from(local: Local) -> Self {\n         Place {\n             base: local.into(),\n-            projection: None,\n+            projection: Box::new([]),\n         }\n     }\n }\n@@ -1955,13 +1950,6 @@ impl From<Local> for PlaceBase<'_> {\n }\n \n impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n-    pub fn iterate<R>(\n-        &self,\n-        op: impl FnOnce(&PlaceBase<'tcx>, ProjectionsIter<'_, 'tcx>) -> R,\n-    ) -> R {\n-        Place::iterate_over(self.base, self.projection, op)\n-    }\n-\n     /// Finds the innermost `Local` from this `Place`, *if* it is either a local itself or\n     /// a single deref of a local.\n     //\n@@ -1970,154 +1958,84 @@ impl<'a, 'tcx> PlaceRef<'a, 'tcx> {\n         match self {\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: None,\n+                projection: [],\n             } |\n             PlaceRef {\n                 base: PlaceBase::Local(local),\n-                projection: Some(box Projection {\n-                    base: None,\n-                    elem: ProjectionElem::Deref,\n-                }),\n+                projection: [ProjectionElem::Deref],\n             } => Some(*local),\n             _ => None,\n         }\n     }\n }\n \n-/// A linked list of projections running up the stack; begins with the\n-/// innermost projection and extends to the outermost (e.g., `a.b.c`\n-/// would have the place `b` with a \"next\" pointer to `b.c`).\n-/// Created by `Place::iterate`.\n-///\n-/// N.B., this particular impl strategy is not the most obvious. It was\n-/// chosen because it makes a measurable difference to NLL\n-/// performance, as this code (`borrow_conflicts_with_place`) is somewhat hot.\n-pub enum Projections<'p, 'tcx> {\n-    Empty,\n-\n-    List { projection: &'p Projection<'tcx>, next: &'p Projections<'p, 'tcx> },\n-}\n-\n-impl<'p, 'tcx> Projections<'p, 'tcx> {\n-    fn iter(&self) -> ProjectionsIter<'_, 'tcx> {\n-        ProjectionsIter { value: self }\n-    }\n-}\n-\n-impl<'p, 'tcx> IntoIterator for &'p Projections<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-    type IntoIter = ProjectionsIter<'p, 'tcx>;\n-\n-    /// Converts a list of `Projection` components into an iterator;\n-    /// this iterator yields up a never-ending stream of `Option<&Place>`.\n-    /// These begin with the \"innermost\" projection and then with each\n-    /// projection therefrom. So given a place like `a.b.c` it would\n-    /// yield up:\n-    ///\n-    /// ```notrust\n-    /// Some(`a`), Some(`a.b`), Some(`a.b.c`), None, None, ...\n-    /// ```\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-/// Iterator over components; see `Projections::iter` for more\n-/// information.\n-///\n-/// N.B., this is not a *true* Rust iterator -- the code above just\n-/// manually invokes `next`. This is because we (sometimes) want to\n-/// keep executing even after `None` has been returned.\n-pub struct ProjectionsIter<'p, 'tcx> {\n-    pub value: &'p Projections<'p, 'tcx>,\n-}\n-\n-impl<'p, 'tcx> Iterator for ProjectionsIter<'p, 'tcx> {\n-    type Item = &'p Projection<'tcx>;\n-\n-    fn next(&mut self) -> Option<Self::Item> {\n-        if let &Projections::List { projection, next } = self.value {\n-            self.value = next;\n-            Some(projection)\n-        } else {\n-            None\n-        }\n-    }\n-}\n-\n-impl<'p, 'tcx> FusedIterator for ProjectionsIter<'p, 'tcx> {}\n-\n-impl<'tcx> Debug for Place<'tcx> {\n+impl Debug for Place<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n-        self.iterate(|_place_base, place_projections| {\n-            // FIXME: remove this collect once we have migrated to slices\n-            let projs_vec: Vec<_> = place_projections.collect();\n-            for projection in projs_vec.iter().rev() {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n-                        write!(fmt, \"(\").unwrap();\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \"(*\").unwrap();\n-                    }\n-                    ProjectionElem::Index(_)\n-                    | ProjectionElem::ConstantIndex { .. }\n-                    | ProjectionElem::Subslice { .. } => {}\n+        for elem in self.projection.iter().rev() {\n+            match elem {\n+                ProjectionElem::Downcast(_, _) | ProjectionElem::Field(_, _) => {\n+                    write!(fmt, \"(\").unwrap();\n                 }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \"(*\").unwrap();\n+                }\n+                ProjectionElem::Index(_)\n+                | ProjectionElem::ConstantIndex { .. }\n+                | ProjectionElem::Subslice { .. } => {}\n             }\n-        });\n+        }\n \n-        self.iterate(|place_base, place_projections| {\n-            write!(fmt, \"{:?}\", place_base)?;\n+        write!(fmt, \"{:?}\", self.base)?;\n \n-            for projection in place_projections {\n-                match projection.elem {\n-                    ProjectionElem::Downcast(Some(name), _index) => {\n-                        write!(fmt, \" as {})\", name)?;\n-                    }\n-                    ProjectionElem::Downcast(None, index) => {\n-                        write!(fmt, \" as variant#{:?})\", index)?;\n-                    }\n-                    ProjectionElem::Deref => {\n-                        write!(fmt, \")\")?;\n-                    }\n-                    ProjectionElem::Field(field, ty) => {\n-                        write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n-                    }\n-                    ProjectionElem::Index(ref index) => {\n-                        write!(fmt, \"[{:?}]\", index)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n-                        write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n-                        write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if to == 0 => {\n-                        write!(fmt, \"[{:?}:]\", from)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } if from == 0 => {\n-                        write!(fmt, \"[:-{:?}]\", to)?;\n-                    }\n-                    ProjectionElem::Subslice { from, to } => {\n-                        write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n-                    }\n+        for elem in self.projection.iter() {\n+            match elem {\n+                ProjectionElem::Downcast(Some(name), _index) => {\n+                    write!(fmt, \" as {})\", name)?;\n+                }\n+                ProjectionElem::Downcast(None, index) => {\n+                    write!(fmt, \" as variant#{:?})\", index)?;\n+                }\n+                ProjectionElem::Deref => {\n+                    write!(fmt, \")\")?;\n+                }\n+                ProjectionElem::Field(field, ty) => {\n+                    write!(fmt, \".{:?}: {:?})\", field.index(), ty)?;\n+                }\n+                ProjectionElem::Index(ref index) => {\n+                    write!(fmt, \"[{:?}]\", index)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: false } => {\n+                    write!(fmt, \"[{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end: true } => {\n+                    write!(fmt, \"[-{:?} of {:?}]\", offset, min_length)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *to == 0 => {\n+                    write!(fmt, \"[{:?}:]\", from)?;\n+                }\n+                ProjectionElem::Subslice { from, to } if *from == 0 => {\n+                    write!(fmt, \"[:-{:?}]\", to)?;\n+                }\n+                ProjectionElem::Subslice { from, to } => {\n+                    write!(fmt, \"[{:?}:-{:?}]\", from, to)?;\n                 }\n             }\n+        }\n \n-            Ok(())\n-        })\n+        Ok(())\n     }\n }\n \n impl Debug for PlaceBase<'_> {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static(def_id) }) => {\n+            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Static, def_id }) => {\n                 write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n             }\n-            PlaceBase::Static(box self::Static { ty, kind: StaticKind::Promoted(promoted) }) => {\n+            PlaceBase::Static(box self::Static {\n+                ty, kind: StaticKind::Promoted(promoted, _), def_id: _\n+            }) => {\n                 write!(fmt, \"({:?}: {:?})\", promoted, ty)\n             }\n         }\n@@ -2143,7 +2061,7 @@ pub struct SourceScopeData {\n \n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct SourceScopeLocalData {\n-    /// A HirId with lint levels equivalent to this scope's lint levels.\n+    /// An `HirId` with lint levels equivalent to this scope's lint levels.\n     pub lint_root: hir::HirId,\n     /// The unsafe block that contains this node.\n     pub safety: Safety,\n@@ -2732,11 +2650,12 @@ impl<'a, 'b> graph::GraphSuccessors<'b> for Body<'a> {\n \n #[derive(Copy, Clone, PartialEq, Eq, Hash, Ord, PartialOrd, HashStable)]\n pub struct Location {\n-    /// the location is within this block\n+    /// The block that the location is within.\n     pub block: BasicBlock,\n \n-    /// the location is the start of the statement; or, if `statement_index`\n-    /// == num-statements, then the start of the terminator.\n+    /// The location is the position of the start of the statement; or, if\n+    /// `statement_index` equals the number of statements, then the start of the\n+    /// terminator.\n     pub statement_index: usize,\n }\n \n@@ -2799,7 +2718,7 @@ impl Location {\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n     General,\n-    /// Permitted in const fn and regular fns.\n+    /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n     ExternStatic(hir::HirId),\n     BorrowPacked(hir::HirId),\n@@ -2815,9 +2734,9 @@ pub struct UnsafetyViolation {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyCheckResult {\n-    /// Violations that are propagated *upwards* from this function\n+    /// Violations that are propagated *upwards* from this function.\n     pub violations: Lrc<[UnsafetyViolation]>,\n-    /// unsafe blocks in this function, along with whether they are used. This is\n+    /// `unsafe` blocks in this function, along with whether they are used. This is\n     /// used for the \"unused_unsafe\" lint.\n     pub unsafe_blocks: Lrc<[(hir::HirId, bool)]>,\n }\n@@ -2829,7 +2748,7 @@ newtype_index! {\n     }\n }\n \n-/// The layout of generator state\n+/// The layout of generator state.\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct GeneratorLayout<'tcx> {\n     /// The type of every local stored inside the generator.\n@@ -2844,11 +2763,14 @@ pub struct GeneratorLayout<'tcx> {\n     /// layout.\n     pub storage_conflicts: BitMatrix<GeneratorSavedLocal, GeneratorSavedLocal>,\n \n-    /// Names and scopes of all the stored generator locals.\n-    /// NOTE(tmandry) This is *strictly* a temporary hack for codegen\n+    /// The names and scopes of all the stored generator locals.\n+    ///\n+    /// N.B., this is *strictly* a temporary hack for codegen\n     /// debuginfo generation, and will be removed at some point.\n     /// Do **NOT** use it for anything else, local information should not be\n     /// in the MIR, please rely on local crate HIR or other side-channels.\n+    //\n+    // FIXME(tmandry): see above.\n     pub __local_debuginfo_codegen_only_do_not_use: IndexVec<GeneratorSavedLocal, LocalDecl<'tcx>>,\n }\n \n@@ -2906,7 +2828,7 @@ pub struct BorrowCheckResult<'tcx> {\n /// instances assigned one of these same indices. Those regions will\n /// be substituted away by the creator. We use `ReClosureBound` in\n /// that case because the regions must be allocated in the global\n-/// TyCtxt, and hence we cannot use `ReVar` (which is what we use\n+/// `TyCtxt`, and hence we cannot use `ReVar` (which is what we use\n /// internally within the rest of the NLL code).\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureRegionRequirements<'tcx> {\n@@ -2922,8 +2844,8 @@ pub struct ClosureRegionRequirements<'tcx> {\n     pub outlives_requirements: Vec<ClosureOutlivesRequirement<'tcx>>,\n }\n \n-/// Indicates an outlives constraint between a type or between two\n-/// free-regions declared on the closure.\n+/// Indicates an outlives-constraint between a type or between two\n+/// free regions declared on the closure.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ClosureOutlivesRequirement<'tcx> {\n     // This region or type ...\n@@ -2939,11 +2861,11 @@ pub struct ClosureOutlivesRequirement<'tcx> {\n     pub category: ConstraintCategory,\n }\n \n-/// Outlives constraints can be categorized to determine whether and why they\n+/// Outlives-constraints can be categorized to determine whether and why they\n /// are interesting (for error reporting). Order of variants indicates sort\n /// order of the category, thereby influencing diagnostic output.\n ///\n-/// See also [rustc_mir::borrow_check::nll::constraints]\n+/// See also [rustc_mir::borrow_check::nll::constraints].\n #[derive(\n     Copy,\n     Clone,\n@@ -2991,7 +2913,7 @@ pub enum ConstraintCategory {\n     Internal,\n }\n \n-/// The subject of a ClosureOutlivesRequirement -- that is, the thing\n+/// The subject of a `ClosureOutlivesRequirement` -- that is, the thing\n /// that must outlive some region.\n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum ClosureOutlivesSubject<'tcx> {\n@@ -3009,7 +2931,7 @@ pub enum ClosureOutlivesSubject<'tcx> {\n }\n \n /*\n- * TypeFoldable implementations for MIR types\n+ * `TypeFoldable` implementations for MIR types\n */\n \n CloneTypeFoldableAndLiftImpls! {\n@@ -3032,7 +2954,6 @@ BraceStructTypeFoldableImpl! {\n         basic_blocks,\n         source_scopes,\n         source_scope_local_data,\n-        promoted,\n         yield_ty,\n         generator_drop,\n         generator_layout,\n@@ -3086,14 +3007,14 @@ BraceStructTypeFoldableImpl! {\n \n EnumTypeFoldableImpl! {\n     impl<'tcx> TypeFoldable<'tcx> for StatementKind<'tcx> {\n-        (StatementKind::Assign)(a, b),\n+        (StatementKind::Assign)(a),\n         (StatementKind::FakeRead)(cause, place),\n         (StatementKind::SetDiscriminant) { place, variant_index },\n         (StatementKind::StorageLive)(a),\n         (StatementKind::StorageDead)(a),\n         (StatementKind::InlineAsm)(a),\n         (StatementKind::Retag)(kind, place),\n-        (StatementKind::AscribeUserType)(a, v, b),\n+        (StatementKind::AscribeUserType)(a, v),\n         (StatementKind::Nop),\n     }\n }\n@@ -3226,13 +3147,63 @@ impl<'tcx> TypeFoldable<'tcx> for Terminator<'tcx> {\n impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         Place {\n-            base: self.base.clone(),\n+            base: self.base.fold_with(folder),\n             projection: self.projection.fold_with(folder),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.projection.visit_with(visitor)\n+        self.base.visit_with(visitor) || self.projection.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n+            PlaceBase::Static(static_) => PlaceBase::Static(static_.fold_with(folder)),\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            PlaceBase::Local(local) => local.visit_with(visitor),\n+            PlaceBase::Static(static_) => (**static_).visit_with(visitor),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        Static {\n+            ty: self.ty.fold_with(folder),\n+            kind: self.kind.fold_with(folder),\n+            def_id: self.def_id,\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        let Static { ty, kind, def_id: _ } = self;\n+\n+        ty.visit_with(visitor) || kind.visit_with(visitor)\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for StaticKind<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                StaticKind::Promoted(promoted.fold_with(folder), substs.fold_with(folder)),\n+            StaticKind::Static => StaticKind::Static\n+        }\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        match self {\n+            StaticKind::Promoted(promoted, substs) =>\n+                promoted.visit_with(visitor) || substs.visit_with(visitor),\n+            StaticKind::Static => { false }\n+        }\n     }\n }\n \n@@ -3325,30 +3296,26 @@ impl<'tcx> TypeFoldable<'tcx> for Operand<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Projection<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceElem<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::ProjectionElem::*;\n \n-        let base = self.base.fold_with(folder);\n-        let elem = match self.elem {\n+        match self {\n             Deref => Deref,\n-            Field(f, ref ty) => Field(f, ty.fold_with(folder)),\n-            Index(ref v) => Index(v.fold_with(folder)),\n-            ref elem => elem.clone(),\n-        };\n-\n-        Projection { base, elem }\n+            Field(f, ty) => Field(*f, ty.fold_with(folder)),\n+            Index(v) => Index(v.fold_with(folder)),\n+            elem => elem.clone(),\n+        }\n     }\n \n     fn super_visit_with<Vs: TypeVisitor<'tcx>>(&self, visitor: &mut Vs) -> bool {\n         use crate::mir::ProjectionElem::*;\n \n-        self.base.visit_with(visitor)\n-            || match self.elem {\n-                Field(_, ref ty) => ty.visit_with(visitor),\n-                Index(ref v) => v.visit_with(visitor),\n-                _ => false,\n-            }\n+        match self {\n+            Field(_, ty) => ty.visit_with(visitor),\n+            Index(v) => v.visit_with(visitor),\n+            _ => false,\n+        }\n     }\n }\n "}, {"sha": "d7768098397433176a95c4450c872033b601dd98", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 5, "deletions": 10, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -121,21 +121,16 @@ BraceStructTypeFoldableImpl! {\n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n         base: &PlaceBase<'tcx>,\n-        projection: &Option<Box<Projection<'tcx>>>,\n+        projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>\n     ) -> PlaceTy<'tcx>\n         where D: HasLocalDecls<'tcx>\n     {\n-        Place::iterate_over(base, projection, |place_base, place_projections| {\n-            let mut place_ty = place_base.ty(local_decls);\n-\n-            for proj in place_projections {\n-                place_ty = place_ty.projection_ty(tcx, &proj.elem);\n-            }\n-\n-            place_ty\n-        })\n+        projection.iter().fold(\n+            base.ty(local_decls),\n+            |place_ty, elem| place_ty.projection_ty(tcx, elem)\n+        )\n     }\n \n     pub fn ty<D>(&self, local_decls: &D, tcx: TyCtxt<'tcx>) -> PlaceTy<'tcx>"}, {"sha": "1e3b9eb29c79d0f07198409ccc43ee32f66eb1c3", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 40, "deletions": 37, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -152,18 +152,18 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_place_base(place_base, context, location);\n+                self.super_place_base(base, context, location);\n             }\n \n             fn visit_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                place: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                self.super_projection(place_base, place, context, location);\n+                self.super_projection(base, projection, context, location);\n             }\n \n             fn visit_constant(&mut self,\n@@ -344,7 +344,9 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_source_info(source_info);\n                 match kind {\n-                    StatementKind::Assign(place, rvalue) => {\n+                    StatementKind::Assign(\n+                        box(ref $($mutability)? place, ref $($mutability)? rvalue)\n+                    ) => {\n                         self.visit_assign(place, rvalue, location);\n                     }\n                     StatementKind::FakeRead(_, place) => {\n@@ -391,7 +393,10 @@ macro_rules! make_mir_visitor {\n                     StatementKind::Retag(kind, place) => {\n                         self.visit_retag(kind, place, location);\n                     }\n-                    StatementKind::AscribeUserType(place, variance, user_ty) => {\n+                    StatementKind::AscribeUserType(\n+                        box(ref $($mutability)? place, ref $($mutability)? user_ty),\n+                        variance\n+                    ) => {\n                         self.visit_ascribe_user_ty(place, variance, user_ty, location);\n                     }\n                     StatementKind::Nop => {}\n@@ -685,7 +690,7 @@ macro_rules! make_mir_visitor {\n                             location: Location) {\n                 let mut context = context;\n \n-                if place.projection.is_some() {\n+                if !place.projection.is_empty() {\n                     context = if context.is_mutating_use() {\n                         PlaceContext::MutatingUse(MutatingUseContext::Projection)\n                     } else {\n@@ -695,9 +700,10 @@ macro_rules! make_mir_visitor {\n \n                 self.visit_place_base(& $($mutability)? place.base, context, location);\n \n-                if let Some(box proj) = & $($mutability)? place.projection {\n-                    self.visit_projection(& $($mutability)? place.base, proj, context, location);\n-                }\n+                self.visit_projection(& $($mutability)? place.base,\n+                                      & $($mutability)? place.projection,\n+                                      context,\n+                                      location);\n             }\n \n             fn super_place_base(&mut self,\n@@ -708,41 +714,38 @@ macro_rules! make_mir_visitor {\n                     PlaceBase::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    PlaceBase::Static(box Static { kind: _, ty }) => {\n+                    PlaceBase::Static(box Static { kind: _, ty, def_id: _ }) => {\n                         self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n                     }\n                 }\n             }\n \n             fn super_projection(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n-                                proj: & $($mutability)? Projection<'tcx>,\n+                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                projection: & $($mutability)? [PlaceElem<'tcx>],\n                                 context: PlaceContext,\n                                 location: Location) {\n-                if let Some(box proj_base) = & $($mutability)? proj.base {\n-                    self.visit_projection(place_base, proj_base, context, location);\n-                }\n+                if let [proj_base @ .., elem] = projection {\n+                    self.visit_projection(base, proj_base, context, location);\n \n-                match & $($mutability)? proj.elem {\n-                    ProjectionElem::Deref => {\n-                    }\n-                    ProjectionElem::Subslice { from: _, to: _ } => {\n-                    }\n-                    ProjectionElem::Field(_field, ty) => {\n-                        self.visit_ty(ty, TyContext::Location(location));\n-                    }\n-                    ProjectionElem::Index(local) => {\n-                        self.visit_local(\n-                            local,\n-                            PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n-                            location\n-                        );\n-                    }\n-                    ProjectionElem::ConstantIndex { offset: _,\n-                                                    min_length: _,\n-                                                    from_end: _ } => {\n-                    }\n-                    ProjectionElem::Downcast(_name, _variant_index) => {\n+                    match elem {\n+                        ProjectionElem::Field(_field, ty) => {\n+                            self.visit_ty(ty, TyContext::Location(location));\n+                        }\n+                        ProjectionElem::Index(local) => {\n+                            self.visit_local(\n+                                local,\n+                                PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy),\n+                                location\n+                            );\n+                        }\n+                        ProjectionElem::Deref |\n+                        ProjectionElem::Subslice { from: _, to: _ } |\n+                        ProjectionElem::ConstantIndex { offset: _,\n+                                                        min_length: _,\n+                                                        from_end: _ } |\n+                        ProjectionElem::Downcast(_, _) => {\n+                        }\n                     }\n                 }\n             }"}, {"sha": "c7260945295a6e4c294dd48809ae030d64ffa945", "filename": "src/librustc/query/mod.rs", "status": "modified", "additions": 34, "deletions": 13, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fquery%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -17,7 +17,6 @@ use crate::traits::query::{\n use std::borrow::Cow;\n use syntax_pos::symbol::InternedString;\n \n-\n // Each of these queries corresponds to a function pointer field in the\n // `Providers` struct for requesting a value of that type, and a method\n // on `tcx: TyCtxt` (and `tcx.at(span)`) for doing that request in a way\n@@ -110,7 +109,11 @@ rustc_queries! {\n             no_hash\n         }\n \n-        query mir_validated(_: DefId) -> &'tcx Steal<mir::Body<'tcx>> {\n+        query mir_validated(_: DefId) ->\n+            (\n+                &'tcx Steal<mir::Body<'tcx>>,\n+                &'tcx Steal<IndexVec<mir::Promoted, mir::Body<'tcx>>>\n+            ) {\n             no_hash\n         }\n \n@@ -125,7 +128,17 @@ rustc_queries! {\n             }\n         }\n \n-        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> { }\n+        query promoted_mir(key: DefId) -> &'tcx IndexVec<mir::Promoted, mir::Body<'tcx>> {\n+            cache_on_disk_if { key.is_local() }\n+            load_cached(tcx, id) {\n+                let promoted: Option<\n+                    rustc_data_structures::indexed_vec::IndexVec<\n+                        crate::mir::Promoted,\n+                        crate::mir::Body<'tcx>\n+                    >> = tcx.queries.on_disk_cache.try_load_query_result(tcx, id);\n+                promoted.map(|p| &*tcx.arena.alloc(p))\n+            }\n+        }\n     }\n \n     TypeChecking {\n@@ -449,15 +462,6 @@ rustc_queries! {\n             no_force\n             desc { \"extract field of const\" }\n         }\n-\n-        /// Produces an absolute path representation of the given type. See also the documentation\n-        /// on `std::any::type_name`.\n-        query type_name(key: Ty<'tcx>) -> &'tcx ty::Const<'tcx> {\n-            eval_always\n-            no_force\n-            desc { \"get absolute path of type\" }\n-        }\n-\n     }\n \n     TypeChecking {\n@@ -790,7 +794,7 @@ rustc_queries! {\n     }\n \n     BorrowChecking {\n-        // Lifetime resolution. See `middle::resolve_lifetimes`.\n+        /// Lifetime resolution. See `middle::resolve_lifetimes`.\n         query resolve_lifetimes(_: CrateNum) -> &'tcx ResolveLifetimes {\n             desc { \"resolving lifetimes\" }\n         }\n@@ -832,13 +836,30 @@ rustc_queries! {\n             -> &'tcx [(Symbol, Option<Symbol>)] {\n             desc { \"calculating the lib features defined in a crate\" }\n         }\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n+        // FIXME: It is illegal to pass a `CrateNum` other than `LOCAL_CRATE` here, just get rid\n+        // of that argument?\n         query get_lang_items(_: CrateNum) -> &'tcx LanguageItems {\n             eval_always\n             desc { \"calculating the lang items map\" }\n         }\n+\n+        /// Returns all diagnostic items defined in all crates.\n+        query all_diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            eval_always\n+            desc { \"calculating the diagnostic items map\" }\n+        }\n+\n+        /// Returns the lang items defined in another crate by loading it from metadata.\n         query defined_lang_items(_: CrateNum) -> &'tcx [(DefId, usize)] {\n             desc { \"calculating the lang items defined in a crate\" }\n         }\n+\n+        /// Returns the diagnostic items defined in a crate.\n+        query diagnostic_items(_: CrateNum) -> &'tcx FxHashMap<Symbol, DefId> {\n+            desc { \"calculating the diagnostic items map in a crate\" }\n+        }\n+\n         query missing_lang_items(_: CrateNum) -> &'tcx [LangItem] {\n             desc { \"calculating the missing lang items in a crate\" }\n         }"}, {"sha": "5eda3df378126dd3215e6a51baedce568382c27c", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 102, "deletions": 86, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,36 +1,38 @@\n //! Contains infrastructure for configuring the compiler, including parsing\n-//! command line options.\n-\n-use std::str::FromStr;\n+//! command-line options.\n \n+use crate::lint;\n+use crate::middle::cstore;\n use crate::session::{early_error, early_warn, Session};\n use crate::session::search_paths::SearchPath;\n \n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sync::Lrc;\n+\n use rustc_target::spec::{LinkerFlavor, MergeFunctions, PanicStrategy, RelroLevel};\n use rustc_target::spec::{Target, TargetTriple};\n-use crate::lint;\n-use crate::middle::cstore;\n \n use syntax;\n use syntax::ast::{self, IntTy, UintTy, MetaItemKind};\n use syntax::source_map::{FileName, FilePathMapping};\n use syntax::edition::{Edition, EDITION_NAME_LIST, DEFAULT_EDITION};\n+use syntax::parse::{ParseSess, new_parser_from_source_str};\n use syntax::parse::token;\n-use syntax::parse;\n use syntax::symbol::{sym, Symbol};\n use syntax::feature_gate::UnstableFeatures;\n-use errors::emitter::HumanReadableErrorType;\n+use syntax::source_map::SourceMap;\n \n+use errors::emitter::HumanReadableErrorType;\n use errors::{ColorConfig, FatalError, Handler};\n \n use getopts;\n-use std::collections::{BTreeMap, BTreeSet};\n-use std::collections::btree_map::Iter as BTreeMapIter;\n-use std::collections::btree_map::Keys as BTreeMapKeysIter;\n-use std::collections::btree_map::Values as BTreeMapValuesIter;\n \n-use rustc_data_structures::fx::FxHashSet;\n-use std::{fmt, str};\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::collections::btree_map::{\n+    Iter as BTreeMapIter, Keys as BTreeMapKeysIter, Values as BTreeMapValuesIter,\n+};\n+use std::fmt;\n+use std::str::{self, FromStr};\n use std::hash::Hasher;\n use std::collections::hash_map::DefaultHasher;\n use std::iter::FromIterator;\n@@ -241,14 +243,14 @@ pub enum ErrorOutputType {\n }\n \n impl Default for ErrorOutputType {\n-    fn default() -> ErrorOutputType {\n-        ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n+    fn default() -> Self {\n+        Self::HumanReadable(HumanReadableErrorType::Default(ColorConfig::Auto))\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap out for an unsorted container type! That would break\n-// dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` out for an unsorted container type! That would break\n+/// dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct OutputTypes(BTreeMap<OutputType, Option<PathBuf>>);\n \n@@ -281,7 +283,7 @@ impl OutputTypes {\n         self.0.len()\n     }\n \n-    // True if any of the output types require codegen or linking.\n+    // Returns `true` if any of the output types require codegen or linking.\n     pub fn should_codegen(&self) -> bool {\n         self.0.keys().any(|k| match *k {\n             OutputType::Bitcode\n@@ -295,9 +297,9 @@ impl OutputTypes {\n     }\n }\n \n-// Use tree-based collections to cheaply get a deterministic Hash implementation.\n-// DO NOT switch BTreeMap or BTreeSet out for an unsorted container type! That\n-// would break dependency tracking for command-line arguments.\n+/// Use tree-based collections to cheaply get a deterministic `Hash` implementation.\n+/// *Do not* switch `BTreeMap` or `BTreeSet` out for an unsorted container type! That\n+/// would break dependency tracking for command-line arguments.\n #[derive(Clone, Hash)]\n pub struct Externs(BTreeMap<String, ExternEntry>);\n \n@@ -327,7 +329,7 @@ macro_rules! hash_option {\n     ($opt_name:ident, $opt_expr:expr, $sub_hashes:expr, [TRACKED]) => ({\n         if $sub_hashes.insert(stringify!($opt_name),\n                               $opt_expr as &dyn dep_tracking::DepTrackingHash).is_some() {\n-            bug!(\"Duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n+            bug!(\"duplicate key in CLI DepTrackingHash: {}\", stringify!($opt_name))\n         }\n     });\n }\n@@ -362,7 +364,7 @@ macro_rules! top_level_options {\n     );\n }\n \n-// The top-level command-line options struct\n+// The top-level command-line options struct.\n //\n // For each option, one has to specify how it behaves with regard to the\n // dependency tracking system of incremental compilation. This is done via the\n@@ -376,16 +378,16 @@ macro_rules! top_level_options {\n // Incremental compilation is not influenced by this option.\n //\n // If you add a new option to this struct or one of the sub-structs like\n-// CodegenOptions, think about how it influences incremental compilation. If in\n+// `CodegenOptions`, think about how it influences incremental compilation. If in\n // doubt, specify [TRACKED], which is always \"correct\" but might lead to\n // unnecessary re-compilation.\n top_level_options!(\n     pub struct Options {\n         // The crate config requested for the session, which may be combined\n-        // with additional crate configurations during the compile process\n+        // with additional crate configurations during the compile process.\n         crate_types: Vec<CrateType> [TRACKED],\n         optimize: OptLevel [TRACKED],\n-        // Include the debug_assertions flag into dependency tracking, since it\n+        // Include the `debug_assertions` flag in dependency tracking, since it\n         // can influence whether overflow checks are done or not.\n         debug_assertions: bool [TRACKED],\n         debuginfo: DebugInfo [TRACKED],\n@@ -402,8 +404,8 @@ top_level_options!(\n         test: bool [TRACKED],\n         error_format: ErrorOutputType [UNTRACKED],\n \n-        // if Some, enable incremental compilation, using the given\n-        // directory to store intermediate results\n+        // If `Some`, enable incremental compilation, using the given\n+        // directory to store intermediate results.\n         incremental: Option<PathBuf> [UNTRACKED],\n \n         debugging_opts: DebuggingOptions [TRACKED],\n@@ -418,7 +420,7 @@ top_level_options!(\n         // written `extern crate name as std`. Defaults to `std`. Used by\n         // out-of-tree drivers.\n         alt_std_name: Option<String> [TRACKED],\n-        // Indicates how the compiler should treat unstable features\n+        // Indicates how the compiler should treat unstable features.\n         unstable_features: UnstableFeatures [TRACKED],\n \n         // Indicates whether this run of the compiler is actually rustdoc. This\n@@ -434,12 +436,12 @@ top_level_options!(\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n         cli_forced_thinlto_off: bool [UNTRACKED],\n \n-        // Remap source path prefixes in all output (messages, object files, debug, etc)\n+        // Remap source path prefixes in all output (messages, object files, debug, etc.).\n         remap_path_prefix: Vec<(PathBuf, PathBuf)> [UNTRACKED],\n \n         edition: Edition [TRACKED],\n \n-        // Whether or not we're emitting JSON blobs about each artifact produced\n+        // `true` if we're emitting JSON blobs about each artifact produced\n         // by the compiler.\n         json_artifact_notifications: bool [TRACKED],\n     }\n@@ -468,7 +470,7 @@ pub enum BorrowckMode {\n }\n \n impl BorrowckMode {\n-    /// Should we run the MIR-based borrow check, but also fall back\n+    /// Returns whether we should run the MIR-based borrow check, but also fall back\n     /// on the AST borrow check if the MIR-based one errors.\n     pub fn migrate(self) -> bool {\n         match self {\n@@ -477,7 +479,7 @@ impl BorrowckMode {\n         }\n     }\n \n-    /// Should we emit the AST-based borrow checker errors?\n+    /// Returns whether we should emit the AST-based borrow checker errors.\n     pub fn use_ast(self) -> bool {\n         match self {\n             BorrowckMode::Mir => false,\n@@ -487,12 +489,13 @@ impl BorrowckMode {\n }\n \n pub enum Input {\n-    /// Loads source from file\n+    /// Load source code from a file.\n     File(PathBuf),\n+    /// Load source code from a string.\n     Str {\n-        /// String that is shown in place of a filename\n+        /// A string that is shown in place of a filename.\n         name: FileName,\n-        /// Anonymous source string\n+        /// An anonymous string containing the source code.\n         input: String,\n     },\n }\n@@ -651,7 +654,7 @@ impl Options {\n         FilePathMapping::new(self.remap_path_prefix.clone())\n     }\n \n-    /// Returns `true` if there will be an output file generated\n+    /// Returns `true` if there will be an output file generated.\n     pub fn will_create_output_file(&self) -> bool {\n         !self.debugging_opts.parse_only && // The file is just being parsed\n             !self.debugging_opts.ls // The file is just being queried\n@@ -709,16 +712,14 @@ impl Passes {\n     }\n }\n \n-/// Declare a macro that will define all CodegenOptions/DebuggingOptions fields and parsers all\n-/// at once. The goal of this macro is to define an interface that can be\n-/// programmatically used by the option parser in order to initialize the struct\n-/// without hardcoding field names all over the place.\n+/// Defines all `CodegenOptions`/`DebuggingOptions` fields and parsers all at once. The goal of this\n+/// macro is to define an interface that can be programmatically used by the option parser\n+/// to initialize the struct without hardcoding field names all over the place.\n ///\n-/// The goal is to invoke this macro once with the correct fields, and then this\n-/// macro generates all necessary code. The main gotcha of this macro is the\n-/// cgsetters module which is a bunch of generated code to parse an option into\n-/// its respective field in the struct. There are a few hand-written parsers for\n-/// parsing specific types of values in this module.\n+/// The goal is to invoke this macro once with the correct fields, and then this macro generates all\n+/// necessary code. The main gotcha of this macro is the `cgsetters` module which is a bunch of\n+/// generated code to parse an option into its respective field in the struct. There are a few\n+/// hand-written parsers for parsing specific types of values in this module.\n macro_rules! options {\n     ($struct_name:ident, $setter_name:ident, $defaultfn:ident,\n      $buildfn:ident, $prefix:expr, $outputname:expr,\n@@ -1292,6 +1293,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"show macro backtraces even for non-local macros\"),\n     teach: bool = (false, parse_bool, [TRACKED],\n         \"show extended diagnostic help\"),\n+    terminal_width: Option<usize> = (None, parse_opt_uint, [UNTRACKED],\n+        \"set the current terminal width\"),\n     continue_parse_after_error: bool = (false, parse_bool, [TRACKED],\n         \"attempt to recover from parse errors (experimental)\"),\n     dep_tasks: bool = (false, parse_bool, [UNTRACKED],\n@@ -1537,7 +1540,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     ret\n }\n \n-/// Converts the crate cfg! configuration from String to Symbol.\n+/// Converts the crate `cfg!` configuration from `String` to `Symbol`.\n /// `rustc_interface::interface::Config` accepts this in the compiler configuration,\n /// but the symbol interner is not yet set up then, so we must convert it later.\n pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateConfig {\n@@ -1548,9 +1551,9 @@ pub fn to_crate_config(cfg: FxHashSet<(String, Option<String>)>) -> ast::CrateCo\n \n pub fn build_configuration(sess: &Session, mut user_cfg: ast::CrateConfig) -> ast::CrateConfig {\n     // Combine the configuration requested by the session (command line) with\n-    // some default and generated configuration items\n+    // some default and generated configuration items.\n     let default_cfg = default_configuration(sess);\n-    // If the user wants a test runner, then add the test cfg\n+    // If the user wants a test runner, then add the test cfg.\n     if sess.opts.test {\n         user_cfg.insert((sym::test, None));\n     }\n@@ -1719,13 +1722,7 @@ pub fn rustc_short_optgroups() -> Vec<RustcOptGroup> {\n                              static, framework, or dylib (the default).\",\n             \"[KIND=]NAME\",\n         ),\n-        opt::multi_s(\n-            \"\",\n-            \"crate-type\",\n-            \"Comma separated list of types of crates\n-                                    for the compiler to emit\",\n-            \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n-        ),\n+        make_crate_type_option(),\n         opt::opt_s(\n             \"\",\n             \"crate-name\",\n@@ -1855,13 +1852,22 @@ pub fn rustc_optgroups() -> Vec<RustcOptGroup> {\n     opts\n }\n \n-// Convert strings provided as --cfg [cfgspec] into a crate_cfg\n+struct NullEmitter;\n+\n+impl errors::emitter::Emitter for NullEmitter {\n+    fn emit_diagnostic(&mut self, _: &errors::Diagnostic) {}\n+}\n+\n+// Converts strings provided as `--cfg [cfgspec]` into a `crate_cfg`.\n pub fn parse_cfgspecs(cfgspecs: Vec<String>) -> FxHashSet<(String, Option<String>)> {\n     syntax::with_default_globals(move || {\n         let cfg = cfgspecs.into_iter().map(|s| {\n-            let sess = parse::ParseSess::new(FilePathMapping::empty());\n+\n+            let cm = Lrc::new(SourceMap::new(FilePathMapping::empty()));\n+            let handler = Handler::with_emitter(false, None, Box::new(NullEmitter));\n+            let sess = ParseSess::with_span_handler(handler, cm);\n             let filename = FileName::cfg_spec_source_code(&s);\n-            let mut parser = parse::new_parser_from_source_str(&sess, filename, s.to_string());\n+            let mut parser = new_parser_from_source_str(&sess, filename, s.to_string());\n \n             macro_rules! error {($reason: expr) => {\n                 early_error(ErrorOutputType::default(),\n@@ -1921,7 +1927,7 @@ pub fn get_cmd_lint_options(matches: &getopts::Matches,\n     (lint_opts, describe_lints, lint_cap)\n }\n \n-/// Parse the `--color` flag\n+/// Parses the `--color` flag.\n pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n     match matches.opt_str(\"color\").as_ref().map(|s| &s[..]) {\n         Some(\"auto\") => ColorConfig::Auto,\n@@ -1933,7 +1939,7 @@ pub fn parse_color(matches: &getopts::Matches) -> ColorConfig {\n         Some(arg) => early_error(\n             ErrorOutputType::default(),\n             &format!(\n-                \"argument for --color must be auto, \\\n+                \"argument for `--color` must be auto, \\\n                  always or never (instead was `{}`)\",\n                 arg\n             ),\n@@ -1978,16 +1984,16 @@ pub fn parse_json(matches: &getopts::Matches) -> (HumanReadableErrorType, bool)\n     (json_rendered(json_color), json_artifact_notifications)\n }\n \n-/// Parse the `--error-format` flag\n+/// Parses the `--error-format` flag.\n pub fn parse_error_format(\n     matches: &getopts::Matches,\n     color: ColorConfig,\n     json_rendered: HumanReadableErrorType,\n ) -> ErrorOutputType {\n-    // We need the opts_present check because the driver will send us Matches\n+    // We need the `opts_present` check because the driver will send us Matches\n     // with only stable options if no unstable options are used. Since error-format\n-    // is unstable, it will not be present. We have to use opts_present not\n-    // opt_present because the latter will panic.\n+    // is unstable, it will not be present. We have to use `opts_present` not\n+    // `opt_present` because the latter will panic.\n     let error_format = if matches.opts_present(&[\"error-format\".to_owned()]) {\n         match matches.opt_str(\"error-format\").as_ref().map(|s| &s[..]) {\n             None |\n@@ -2002,7 +2008,7 @@ pub fn parse_error_format(\n             Some(arg) => early_error(\n                 ErrorOutputType::HumanReadable(HumanReadableErrorType::Default(color)),\n                 &format!(\n-                    \"argument for --error-format must be `human`, `json` or \\\n+                    \"argument for `--error-format` must be `human`, `json` or \\\n                      `short` (instead was `{}`)\",\n                     arg\n                 ),\n@@ -2041,7 +2047,7 @@ pub fn build_session_options_and_crate_config(\n             early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"argument for --edition must be one of: \\\n+                    \"argument for `--edition` must be one of: \\\n                      {}. (instead was `{}`)\",\n                     EDITION_NAME_LIST,\n                     arg\n@@ -2055,7 +2061,7 @@ pub fn build_session_options_and_crate_config(\n         early_error(\n                 ErrorOutputType::default(),\n                 &format!(\n-                    \"Edition {} is unstable and only \\\n+                    \"edition {} is unstable and only \\\n                      available for nightly builds of rustc.\",\n                     edition,\n                 )\n@@ -2079,14 +2085,14 @@ pub fn build_session_options_and_crate_config(\n         if let ErrorOutputType::Json { pretty: true, json_rendered } = error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=pretty-json is unstable\",\n+                \"`--error-format=pretty-json` is unstable\",\n             );\n         }\n         if let ErrorOutputType::HumanReadable(HumanReadableErrorType::AnnotateSnippet(_)) =\n             error_format {\n             early_error(\n                 ErrorOutputType::Json { pretty: false, json_rendered },\n-                \"--error-format=human-annotate-rs is unstable\",\n+                \"`--error-format=human-annotate-rs` is unstable\",\n             );\n         }\n     }\n@@ -2120,7 +2126,7 @@ pub fn build_session_options_and_crate_config(\n     let mut codegen_units = cg.codegen_units;\n     let mut disable_thinlto = false;\n \n-    // Issue #30063: if user requests llvm-related output to one\n+    // Issue #30063: if user requests LLVM-related output to one\n     // particular path, disable codegen-units.\n     let incompatible: Vec<_> = output_types\n         .iter()\n@@ -2136,8 +2142,8 @@ pub fn build_session_options_and_crate_config(\n                         early_warn(\n                             error_format,\n                             &format!(\n-                                \"--emit={} with -o incompatible with \\\n-                                 -C codegen-units=N for N > 1\",\n+                                \"`--emit={}` with `-o` incompatible with \\\n+                                 `-C codegen-units=N` for N > 1\",\n                                 ot\n                             ),\n                         );\n@@ -2157,21 +2163,21 @@ pub fn build_session_options_and_crate_config(\n     if debugging_opts.threads == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for threads must be a positive nonzero integer\",\n+            \"value for threads must be a positive non-zero integer\",\n         );\n     }\n \n     if debugging_opts.threads.unwrap_or(1) > 1 && debugging_opts.fuel.is_some() {\n         early_error(\n             error_format,\n-            \"Optimization fuel is incompatible with multiple threads\",\n+            \"optimization fuel is incompatible with multiple threads\",\n         );\n     }\n \n     if codegen_units == Some(0) {\n         early_error(\n             error_format,\n-            \"Value for codegen units must be a positive nonzero integer\",\n+            \"value for codegen units must be a positive non-zero integer\",\n         );\n     }\n \n@@ -2418,10 +2424,10 @@ pub fn build_session_options_and_crate_config(\n         )\n     }\n \n-    // We start out with a Vec<(Option<String>, bool)>>,\n-    // and later convert it into a BTreeSet<(Option<String>, bool)>\n+    // We start out with a `Vec<(Option<String>, bool)>>`,\n+    // and later convert it into a `BTreeSet<(Option<String>, bool)>`\n     // This allows to modify entries in-place to set their correct\n-    // 'public' value\n+    // 'public' value.\n     let mut externs: BTreeMap<String, ExternEntry> = BTreeMap::new();\n     for (arg, private) in matches.opt_strs(\"extern\").into_iter().map(|v| (v, false))\n         .chain(matches.opt_strs(\"extern-private\").into_iter().map(|v| (v, true))) {\n@@ -2506,6 +2512,16 @@ pub fn build_session_options_and_crate_config(\n     )\n }\n \n+pub fn make_crate_type_option() -> RustcOptGroup {\n+    opt::multi_s(\n+        \"\",\n+        \"crate-type\",\n+        \"Comma separated list of types of crates\n+                                for the compiler to emit\",\n+        \"[bin|lib|rlib|dylib|cdylib|staticlib|proc-macro]\",\n+    )\n+}\n+\n pub fn parse_crate_types_from_list(list_list: Vec<String>) -> Result<Vec<CrateType>, String> {\n     let mut crate_types: Vec<CrateType> = Vec::new();\n     for unparsed_crate_type in &list_list {\n@@ -2610,15 +2626,15 @@ impl fmt::Display for CrateType {\n /// The values of all command-line arguments that are relevant for dependency\n /// tracking are hashed into a single value that determines whether the\n /// incremental compilation cache can be re-used or not. This hashing is done\n-/// via the DepTrackingHash trait defined below, since the standard Hash\n-/// implementation might not be suitable (e.g., arguments are stored in a Vec,\n+/// via the `DepTrackingHash` trait defined below, since the standard `Hash`\n+/// implementation might not be suitable (e.g., arguments are stored in a `Vec`,\n /// the hash of which is order dependent, but we might not want the order of\n /// arguments to make a difference for the hash).\n ///\n-/// However, since the value provided by Hash::hash often *is* suitable,\n+/// However, since the value provided by `Hash::hash` often *is* suitable,\n /// especially for primitive types, there is the\n-/// impl_dep_tracking_hash_via_hash!() macro that allows to simply reuse the\n-/// Hash implementation for DepTrackingHash. It's important though that\n+/// `impl_dep_tracking_hash_via_hash!()` macro that allows to simply reuse the\n+/// `Hash` implementation for `DepTrackingHash`. It's important though that\n /// we have an opt-in scheme here, so one is hopefully forced to think about\n /// how the hash should be calculated when adding a new command-line argument.\n mod dep_tracking {\n@@ -2631,9 +2647,9 @@ mod dep_tracking {\n     use super::{CrateType, DebugInfo, ErrorOutputType, OptLevel, OutputTypes,\n                 Passes, Sanitizer, LtoCli, LinkerPluginLto, SwitchWithOptPath,\n                 SymbolManglingVersion};\n-    use syntax::feature_gate::UnstableFeatures;\n     use rustc_target::spec::{MergeFunctions, PanicStrategy, RelroLevel, TargetTriple};\n     use syntax::edition::Edition;\n+    use syntax::feature_gate::UnstableFeatures;\n \n     pub trait DepTrackingHash {\n         fn hash(&self, hasher: &mut DefaultHasher, error_format: ErrorOutputType);"}, {"sha": "9eb68056bfd97f0c09afc8bf7f33df30ef9627ec", "filename": "src/librustc/session/config/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig%2Ftests.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -87,7 +87,7 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(!sess.diagnostic().flags.can_emit_warnings);\n+        assert!(!sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n@@ -97,15 +97,15 @@ fn test_can_print_warnings() {\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n \n     syntax::with_default_globals(|| {\n         let matches = optgroups().parse(&[\"-Adead_code\".to_string()]).unwrap();\n         let registry = errors::registry::Registry::new(&[]);\n         let (sessopts, _) = build_session_options_and_crate_config(&matches);\n         let sess = build_session(sessopts, None, registry);\n-        assert!(sess.diagnostic().flags.can_emit_warnings);\n+        assert!(sess.diagnostic().can_emit_warnings());\n     });\n }\n "}, {"sha": "a24fed8f21c5a1edcb2d25eb911d02f54be20ac2", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 47, "deletions": 40, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -79,24 +79,24 @@ pub struct Session {\n     /// if the value stored here has been affected by path remapping.\n     pub working_dir: (PathBuf, bool),\n \n-    // FIXME: lint_store and buffered_lints are not thread-safe,\n-    // but are only used in a single thread\n+    // FIXME: `lint_store` and `buffered_lints` are not thread-safe,\n+    // but are only used in a single thread.\n     pub lint_store: RwLock<lint::LintStore>,\n     pub buffered_lints: Lock<Option<lint::LintBuffer>>,\n \n-    /// Set of (DiagnosticId, Option<Span>, message) tuples tracking\n+    /// Set of `(DiagnosticId, Option<Span>, message)` tuples tracking\n     /// (sub)diagnostics that have been set once, but should not be set again,\n     /// in order to avoid redundantly verbose output (Issue #24690, #44953).\n     pub one_time_diagnostics: Lock<FxHashSet<(DiagnosticMessageId, Option<Span>, String)>>,\n     pub plugin_llvm_passes: OneThread<RefCell<Vec<String>>>,\n     pub plugin_attributes: Lock<Vec<(Symbol, AttributeType)>>,\n     pub crate_types: Once<Vec<config::CrateType>>,\n     pub dependency_formats: Once<dependency_format::Dependencies>,\n-    /// The crate_disambiguator is constructed out of all the `-C metadata`\n+    /// The `crate_disambiguator` is constructed out of all the `-C metadata`\n     /// arguments passed to the compiler. Its value together with the crate-name\n     /// forms a unique global identifier for the crate. It is used to allow\n     /// multiple crates with the same name to coexist. See the\n-    /// rustc_codegen_llvm::back::symbol_names module for more information.\n+    /// `rustc_codegen_llvm::back::symbol_names` module for more information.\n     pub crate_disambiguator: Once<CrateDisambiguator>,\n \n     features: Once<feature_gate::Features>,\n@@ -111,7 +111,7 @@ pub struct Session {\n     /// The maximum number of stackframes allowed in const eval.\n     pub const_eval_stack_frame_limit: usize,\n \n-    /// The metadata::creader module may inject an allocator/panic_runtime\n+    /// The `metadata::creader` module may inject an allocator/`panic_runtime`\n     /// dependency if it didn't already find one, and this tracks what was\n     /// injected.\n     pub allocator_kind: Once<Option<AllocatorKind>>,\n@@ -130,7 +130,7 @@ pub struct Session {\n     /// Used by `-Z profile-queries` in `util::common`.\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n-    /// Used by -Z self-profile\n+    /// Used by `-Z self-profile`.\n     pub self_profiling: Option<Arc<SelfProfiler>>,\n \n     /// Some measurements that are being gathered during compilation.\n@@ -187,16 +187,16 @@ pub struct PerfStats {\n     pub normalize_projection_ty: AtomicUsize,\n }\n \n-/// Enum to support dispatch of one-time diagnostics (in Session.diag_once)\n+/// Enum to support dispatch of one-time diagnostics (in `Session.diag_once`).\n enum DiagnosticBuilderMethod {\n     Note,\n     SpanNote,\n     SpanSuggestion(String), // suggestion\n-                            // add more variants as needed to support one-time diagnostics\n+                            // Add more variants as needed to support one-time diagnostics.\n }\n \n-/// Diagnostic message ID\u2014used by `Session.one_time_diagnostics` to avoid\n-/// emitting the same message more than once\n+/// Diagnostic message ID, used by `Session.one_time_diagnostics` to avoid\n+/// emitting the same message more than once.\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum DiagnosticMessageId {\n     ErrorId(u16), // EXXXX error code as integer\n@@ -365,12 +365,6 @@ impl Session {\n     pub fn span_note_without_error<S: Into<MultiSpan>>(&self, sp: S, msg: &str) {\n         self.diagnostic().span_note_without_error(sp, msg)\n     }\n-    pub fn span_unimpl<S: Into<MultiSpan>>(&self, sp: S, msg: &str) -> ! {\n-        self.diagnostic().span_unimpl(sp, msg)\n-    }\n-    pub fn unimpl(&self, msg: &str) -> ! {\n-        self.diagnostic().unimpl(msg)\n-    }\n \n     pub fn buffer_lint<S: Into<MultiSpan>>(\n         &self,\n@@ -408,7 +402,7 @@ impl Session {\n             Some(next) => {\n                 self.next_node_id.set(ast::NodeId::from_usize(next));\n             }\n-            None => bug!(\"Input too large, ran out of node ids!\"),\n+            None => bug!(\"input too large; ran out of node-IDs!\"),\n         }\n \n         id\n@@ -440,11 +434,11 @@ impl Session {\n                     diag_builder.note(message);\n                 }\n                 DiagnosticBuilderMethod::SpanNote => {\n-                    let span = span_maybe.expect(\"span_note needs a span\");\n+                    let span = span_maybe.expect(\"`span_note` needs a span\");\n                     diag_builder.span_note(span, message);\n                 }\n                 DiagnosticBuilderMethod::SpanSuggestion(suggestion) => {\n-                    let span = span_maybe.expect(\"span_suggestion_* needs a span\");\n+                    let span = span_maybe.expect(\"`span_suggestion_*` needs a span\");\n                     diag_builder.span_suggestion(\n                         span,\n                         message,\n@@ -688,7 +682,7 @@ impl Session {\n \n     pub fn must_not_eliminate_frame_pointers(&self) -> bool {\n         // \"mcount\" function relies on stack pointer.\n-        // See https://sourceware.org/binutils/docs/gprof/Implementation.html\n+        // See <https://sourceware.org/binutils/docs/gprof/Implementation.html>.\n         if self.instrument_mcount() {\n             true\n         } else if let Some(x) = self.opts.cg.force_frame_pointers {\n@@ -699,7 +693,7 @@ impl Session {\n     }\n \n     /// Returns the symbol name for the registrar function,\n-    /// given the crate Svh and the function DefIndex.\n+    /// given the crate `Svh` and the function `DefIndex`.\n     pub fn generate_plugin_registrar_symbol(&self, disambiguator: CrateDisambiguator) -> String {\n         format!(\n             \"__rustc_plugin_registrar_{}__\",\n@@ -719,7 +713,7 @@ impl Session {\n             &self.sysroot,\n             self.opts.target_triple.triple(),\n             &self.opts.search_paths,\n-            // target_tlib_path==None means it's the same as host_tlib_path.\n+            // `target_tlib_path == None` means it's the same as `host_tlib_path`.\n             self.target_tlib_path.as_ref().unwrap_or(&self.host_tlib_path),\n             kind,\n         )\n@@ -779,12 +773,12 @@ impl Session {\n         if let IncrCompSession::Active { .. } = *incr_comp_session {\n         } else {\n             bug!(\n-                \"Trying to finalize IncrCompSession `{:?}`\",\n+                \"trying to finalize `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n-            )\n+            );\n         }\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n         *incr_comp_session = IncrCompSession::Finalized {\n             session_directory: new_directory_path,\n         };\n@@ -800,13 +794,15 @@ impl Session {\n             } => session_directory.clone(),\n             IncrCompSession::InvalidBecauseOfErrors { .. } => return,\n             _ => bug!(\n-                \"Trying to invalidate IncrCompSession `{:?}`\",\n+                \"trying to invalidate `IncrCompSession` `{:?}`\",\n                 *incr_comp_session\n             ),\n         };\n \n-        // Note: This will also drop the lock file, thus unlocking the directory\n-        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors { session_directory };\n+        // Note: this will also drop the lock file, thus unlocking the directory.\n+        *incr_comp_session = IncrCompSession::InvalidBecauseOfErrors {\n+            session_directory,\n+        };\n     }\n \n     pub fn incr_comp_session_dir(&self) -> cell::Ref<'_, PathBuf> {\n@@ -815,8 +811,8 @@ impl Session {\n             incr_comp_session,\n             |incr_comp_session| match *incr_comp_session {\n                 IncrCompSession::NotInitialized => bug!(\n-                    \"Trying to get session directory from IncrCompSession `{:?}`\",\n-                    *incr_comp_session\n+                    \"trying to get session directory from `IncrCompSession`: {:?}\",\n+                    *incr_comp_session,\n                 ),\n                 IncrCompSession::Active {\n                     ref session_directory,\n@@ -1038,6 +1034,7 @@ fn default_emitter(\n     source_map: &Lrc<source_map::SourceMap>,\n     emitter_dest: Option<Box<dyn Write + Send>>,\n ) -> Box<dyn Emitter + sync::Send> {\n+    let external_macro_backtrace = sopts.debugging_opts.external_macro_backtrace;\n     match (sopts.error_format, emitter_dest) {\n         (config::ErrorOutputType::HumanReadable(kind), dst) => {\n             let (short, color_config) = kind.unzip();\n@@ -1046,6 +1043,7 @@ fn default_emitter(\n                 let emitter = AnnotateSnippetEmitterWriter::new(\n                     Some(source_map.clone()),\n                     short,\n+                    external_macro_backtrace,\n                 );\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n             } else {\n@@ -1055,13 +1053,17 @@ fn default_emitter(\n                         Some(source_map.clone()),\n                         short,\n                         sopts.debugging_opts.teach,\n+                        sopts.debugging_opts.terminal_width,\n+                        external_macro_backtrace,\n                     ),\n                     Some(dst) => EmitterWriter::new(\n                         dst,\n                         Some(source_map.clone()),\n                         short,\n                         false, // no teach messages when writing to a buffer\n                         false, // no colors when writing to a buffer\n+                        None,  // no terminal width\n+                        external_macro_backtrace,\n                     ),\n                 };\n                 Box::new(emitter.ui_testing(sopts.debugging_opts.ui_testing))\n@@ -1073,6 +1075,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n+                external_macro_backtrace,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n         (config::ErrorOutputType::Json { pretty, json_rendered }, Some(dst)) => Box::new(\n@@ -1082,6 +1085,7 @@ fn default_emitter(\n                 source_map.clone(),\n                 pretty,\n                 json_rendered,\n+                external_macro_backtrace,\n             ).ui_testing(sopts.debugging_opts.ui_testing),\n         ),\n     }\n@@ -1183,7 +1187,10 @@ fn build_session_(\n     );\n     let target_cfg = config::build_target_config(&sopts, &span_diagnostic);\n \n-    let p_s = parse::ParseSess::with_span_handler(span_diagnostic, source_map);\n+    let parse_sess = parse::ParseSess::with_span_handler(\n+        span_diagnostic,\n+        source_map,\n+    );\n     let sysroot = match &sopts.maybe_sysroot {\n         Some(sysroot) => sysroot.clone(),\n         None => filesearch::get_or_default_sysroot(),\n@@ -1212,7 +1219,7 @@ fn build_session_(\n     let print_fuel = AtomicU64::new(0);\n \n     let working_dir = env::current_dir().unwrap_or_else(|e|\n-        p_s.span_diagnostic\n+        parse_sess.span_diagnostic\n             .fatal(&format!(\"Current directory is invalid: {}\", e))\n             .raise()\n     );\n@@ -1230,7 +1237,7 @@ fn build_session_(\n         opts: sopts,\n         host_tlib_path,\n         target_tlib_path,\n-        parse_sess: p_s,\n+        parse_sess,\n         sysroot,\n         local_crate_source_file,\n         working_dir,\n@@ -1375,27 +1382,27 @@ pub fn early_error(output: config::ErrorOutputType, msg: &str) -> ! {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n-            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, false)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n-    handler.emit(&MultiSpan::new(), msg, errors::Level::Fatal);\n+    handler.struct_fatal(msg).emit();\n     errors::FatalError.raise();\n }\n \n pub fn early_warn(output: config::ErrorOutputType, msg: &str) {\n     let emitter: Box<dyn Emitter + sync::Send> = match output {\n         config::ErrorOutputType::HumanReadable(kind) => {\n             let (short, color_config) = kind.unzip();\n-            Box::new(EmitterWriter::stderr(color_config, None, short, false))\n+            Box::new(EmitterWriter::stderr(color_config, None, short, false, None, false))\n         }\n         config::ErrorOutputType::Json { pretty, json_rendered } =>\n-            Box::new(JsonEmitter::basic(pretty, json_rendered)),\n+            Box::new(JsonEmitter::basic(pretty, json_rendered, false)),\n     };\n     let handler = errors::Handler::with_emitter(true, None, emitter);\n-    handler.emit(&MultiSpan::new(), msg, errors::Level::Warning);\n+    handler.struct_warn(msg).emit();\n }\n \n pub type CompileResult = Result<(), ErrorReported>;"}, {"sha": "a7e1f2a6a73a75047a758834aedb040c22c56f0b", "filename": "src/librustc/traits/chalk_fulfill.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fchalk_fulfill.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -81,6 +81,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                 .map(|obligation| FulfillmentError {\n                     obligation: obligation.goal.clone(),\n                     code: FulfillmentErrorCode::CodeAmbiguity,\n+                    points_at_arg_span: false,\n                 })\n                 .collect();\n             Err(errors)\n@@ -129,6 +130,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                                     code: FulfillmentErrorCode::CodeSelectionError(\n                                         SelectionError::Unimplemented\n                                     ),\n+                                    points_at_arg_span: false,\n                                 }),\n                             }\n                         } else {\n@@ -142,6 +144,7 @@ impl TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                         code: FulfillmentErrorCode::CodeSelectionError(\n                             SelectionError::Unimplemented\n                         ),\n+                        points_at_arg_span: false,\n                     })\n                 }\n             }"}, {"sha": "aff866fa76d5f4ccd275638fd2a3ea154814c136", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 163, "deletions": 48, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,20 +1,21 @@\n use super::{\n+    ConstEvalFailure,\n+    EvaluationResult,\n     FulfillmentError,\n     FulfillmentErrorCode,\n     MismatchedProjectionTypes,\n+    ObjectSafetyViolation,\n     Obligation,\n     ObligationCause,\n     ObligationCauseCode,\n     OnUnimplementedDirective,\n     OnUnimplementedNote,\n     OutputTypeParameterMismatch,\n-    TraitNotObjectSafe,\n-    ConstEvalFailure,\n+    Overflow,\n     PredicateObligation,\n     SelectionContext,\n     SelectionError,\n-    ObjectSafetyViolation,\n-    Overflow,\n+    TraitNotObjectSafe,\n };\n \n use crate::hir;\n@@ -32,17 +33,19 @@ use crate::ty::subst::Subst;\n use crate::ty::SubtypePredicate;\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n \n-use errors::{Applicability, DiagnosticBuilder};\n+use errors::{Applicability, DiagnosticBuilder, pluralise};\n use std::fmt;\n use syntax::ast;\n-use syntax::symbol::sym;\n+use syntax::symbol::{sym, kw};\n use syntax_pos::{DUMMY_SP, Span, ExpnKind};\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n-    pub fn report_fulfillment_errors(&self,\n-                                     errors: &[FulfillmentError<'tcx>],\n-                                     body_id: Option<hir::BodyId>,\n-                                     fallback_has_occurred: bool) {\n+    pub fn report_fulfillment_errors(\n+        &self,\n+        errors: &[FulfillmentError<'tcx>],\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n         #[derive(Debug)]\n         struct ErrorDescriptor<'tcx> {\n             predicate: ty::Predicate<'tcx>,\n@@ -118,11 +121,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n     // returns if `cond` not occurring implies that `error` does not occur - i.e., that\n     // `error` occurring implies that `cond` occurs.\n-    fn error_implies(&self,\n-                     cond: &ty::Predicate<'tcx>,\n-                     error: &ty::Predicate<'tcx>)\n-                     -> bool\n-    {\n+    fn error_implies(\n+        &self,\n+        cond: &ty::Predicate<'tcx>,\n+        error: &ty::Predicate<'tcx>,\n+    ) -> bool {\n         if cond == error {\n             return true\n         }\n@@ -154,13 +157,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         false\n     }\n \n-    fn report_fulfillment_error(&self, error: &FulfillmentError<'tcx>,\n-                                body_id: Option<hir::BodyId>,\n-                                fallback_has_occurred: bool) {\n+    fn report_fulfillment_error(\n+        &self,\n+        error: &FulfillmentError<'tcx>,\n+        body_id: Option<hir::BodyId>,\n+        fallback_has_occurred: bool,\n+    ) {\n         debug!(\"report_fulfillment_errors({:?})\", error);\n         match error.code {\n-            FulfillmentErrorCode::CodeSelectionError(ref e) => {\n-                self.report_selection_error(&error.obligation, e, fallback_has_occurred);\n+            FulfillmentErrorCode::CodeSelectionError(ref selection_error) => {\n+                self.report_selection_error(\n+                    &error.obligation,\n+                    selection_error,\n+                    fallback_has_occurred,\n+                    error.points_at_arg_span,\n+                );\n             }\n             FulfillmentErrorCode::CodeProjectionError(ref e) => {\n                 self.report_projection_error(&error.obligation, e);\n@@ -169,19 +180,21 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 self.maybe_report_ambiguity(&error.obligation, body_id);\n             }\n             FulfillmentErrorCode::CodeSubtypeError(ref expected_found, ref err) => {\n-                self.report_mismatched_types(&error.obligation.cause,\n-                                             expected_found.expected,\n-                                             expected_found.found,\n-                                             err.clone())\n-                    .emit();\n+                self.report_mismatched_types(\n+                    &error.obligation.cause,\n+                    expected_found.expected,\n+                    expected_found.found,\n+                    err.clone(),\n+                ).emit();\n             }\n         }\n     }\n \n-    fn report_projection_error(&self,\n-                               obligation: &PredicateObligation<'tcx>,\n-                               error: &MismatchedProjectionTypes<'tcx>)\n-    {\n+    fn report_projection_error(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        error: &MismatchedProjectionTypes<'tcx>,\n+    ) {\n         let predicate =\n             self.resolve_vars_if_possible(&obligation.predicate);\n \n@@ -602,6 +615,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n         error: &SelectionError<'tcx>,\n         fallback_has_occurred: bool,\n+        points_at_arg: bool,\n     ) {\n         let span = obligation.cause.span;\n \n@@ -657,19 +671,22 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                             span,\n                             E0277,\n                             \"{}\",\n-                            message.unwrap_or_else(||\n-                                format!(\"the trait bound `{}` is not satisfied{}\",\n-                                        trait_ref.to_predicate(), post_message)\n-                            ));\n+                            message.unwrap_or_else(|| format!(\n+                                \"the trait bound `{}` is not satisfied{}\",\n+                                trait_ref.to_predicate(),\n+                                post_message,\n+                            )));\n \n                         let explanation =\n                             if obligation.cause.code == ObligationCauseCode::MainFunctionType {\n                                 \"consider using `()`, or a `Result`\".to_owned()\n                             } else {\n-                                format!(\"{}the trait `{}` is not implemented for `{}`\",\n-                                        pre_message,\n-                                        trait_ref,\n-                                        trait_ref.self_ty())\n+                                format!(\n+                                    \"{}the trait `{}` is not implemented for `{}`\",\n+                                    pre_message,\n+                                    trait_ref,\n+                                    trait_ref.self_ty(),\n+                                )\n                             };\n \n                         if let Some(ref s) = label {\n@@ -686,6 +703,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         }\n \n                         self.suggest_borrow_on_unsized_slice(&obligation.cause.code, &mut err);\n+                        self.suggest_fn_call(&obligation, &mut err, &trait_ref, points_at_arg);\n                         self.suggest_remove_reference(&obligation, &mut err, &trait_ref);\n                         self.suggest_semicolon_removal(&obligation, &mut err, span, &trait_ref);\n \n@@ -953,6 +971,74 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_fn_call(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        trait_ref: &ty::Binder<ty::TraitRef<'tcx>>,\n+        points_at_arg: bool,\n+    ) {\n+        let self_ty = trait_ref.self_ty();\n+        match self_ty.sty {\n+            ty::FnDef(def_id, _) => {\n+                // We tried to apply the bound to an `fn`. Check whether calling it would evaluate\n+                // to a type that *would* satisfy the trait binding. If it would, suggest calling\n+                // it: `bar(foo)` -> `bar(foo)`. This case is *very* likely to be hit if `foo` is\n+                // `async`.\n+                let output_ty = self_ty.fn_sig(self.tcx).output();\n+                let new_trait_ref = ty::TraitRef {\n+                    def_id: trait_ref.def_id(),\n+                    substs: self.tcx.mk_substs_trait(output_ty.skip_binder(), &[]),\n+                };\n+                let obligation = Obligation::new(\n+                    obligation.cause.clone(),\n+                    obligation.param_env,\n+                    new_trait_ref.to_predicate(),\n+                );\n+                match self.evaluate_obligation(&obligation) {\n+                    Ok(EvaluationResult::EvaluatedToOk) |\n+                    Ok(EvaluationResult::EvaluatedToOkModuloRegions) |\n+                    Ok(EvaluationResult::EvaluatedToAmbig) => {\n+                        if let Some(hir::Node::Item(hir::Item {\n+                            ident,\n+                            node: hir::ItemKind::Fn(.., body_id),\n+                            ..\n+                        })) = self.tcx.hir().get_if_local(def_id) {\n+                            let body = self.tcx.hir().body(*body_id);\n+                            let msg = \"use parentheses to call the function\";\n+                            let snippet = format!(\n+                                \"{}({})\",\n+                                ident,\n+                                body.params.iter()\n+                                    .map(|arg| match &arg.pat.node {\n+                                        hir::PatKind::Binding(_, _, ident, None)\n+                                        if ident.name != kw::SelfLower => ident.to_string(),\n+                                        _ => \"_\".to_string(),\n+                                    }).collect::<Vec<_>>().join(\", \"),\n+                            );\n+                            // When the obligation error has been ensured to have been caused by\n+                            // an argument, the `obligation.cause.span` points at the expression\n+                            // of the argument, so we can provide a suggestion. This is signaled\n+                            // by `points_at_arg`. Otherwise, we give a more general note.\n+                            if points_at_arg {\n+                                err.span_suggestion(\n+                                    obligation.cause.span,\n+                                    msg,\n+                                    snippet,\n+                                    Applicability::HasPlaceholders,\n+                                );\n+                            } else {\n+                                err.help(&format!(\"{}: `{}`\", msg, snippet));\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+\n     /// Whenever references are used by mistake, like `for (i, e) in &vec.iter().enumerate()`,\n     /// suggest removing these references until we reach a type that implements the trait.\n     fn suggest_remove_reference(\n@@ -969,6 +1055,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .filter(|c| !c.is_whitespace())\n                 .take_while(|c| *c == '&')\n                 .count();\n+            if let Some('\\'') = snippet.chars()\n+                .filter(|c| !c.is_whitespace())\n+                .skip(refs_number)\n+                .next()\n+            { // Do not suggest removal of borrow from type arguments.\n+                return;\n+            }\n \n             let mut trait_type = trait_ref.self_ty();\n \n@@ -1044,7 +1137,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n-                (self.tcx.sess.source_map().def_span(span), self.tcx.hir().body(id).arguments.iter()\n+                (self.tcx.sess.source_map().def_span(span),\n+                 self.tcx.hir().body(id).params.iter()\n                     .map(|arg| {\n                         if let hir::Pat {\n                             node: hir::PatKind::Tuple(ref args, _),\n@@ -1129,7 +1223,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 _ => format!(\"{} {}argument{}\",\n                              arg_length,\n                              if distinct && arg_length > 1 { \"distinct \" } else { \"\" },\n-                             if arg_length == 1 { \"\" } else { \"s\" }),\n+                             pluralise!(arg_length))\n             }\n         };\n \n@@ -1327,7 +1421,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut reported_violations = FxHashSet::default();\n         for violation in violations {\n             if reported_violations.insert(violation.clone()) {\n-                err.note(&violation.error_msg());\n+                match violation.span() {\n+                    Some(span) => err.span_label(span, violation.error_msg()),\n+                    None => err.note(&violation.error_msg()),\n+                };\n             }\n         }\n         Some(err)\n@@ -1534,25 +1631,43 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.note(\"only the last element of a tuple may have a dynamically sized type\");\n             }\n             ObligationCauseCode::ProjectionWf(data) => {\n-                err.note(&format!(\"required so that the projection `{}` is well-formed\",\n-                                  data));\n+                err.note(&format!(\n+                    \"required so that the projection `{}` is well-formed\",\n+                    data,\n+                ));\n             }\n             ObligationCauseCode::ReferenceOutlivesReferent(ref_ty) => {\n-                err.note(&format!(\"required so that reference `{}` does not outlive its referent\",\n-                                  ref_ty));\n+                err.note(&format!(\n+                    \"required so that reference `{}` does not outlive its referent\",\n+                    ref_ty,\n+                ));\n             }\n             ObligationCauseCode::ObjectTypeBound(object_ty, region) => {\n-                err.note(&format!(\"required so that the lifetime bound of `{}` for `{}` \\\n-                                   is satisfied\",\n-                                  region, object_ty));\n+                err.note(&format!(\n+                    \"required so that the lifetime bound of `{}` for `{}` is satisfied\",\n+                    region,\n+                    object_ty,\n+                ));\n             }\n             ObligationCauseCode::ItemObligation(item_def_id) => {\n                 let item_name = tcx.def_path_str(item_def_id);\n                 let msg = format!(\"required by `{}`\", item_name);\n \n                 if let Some(sp) = tcx.hir().span_if_local(item_def_id) {\n                     let sp = tcx.sess.source_map().def_span(sp);\n-                    err.span_note(sp, &msg);\n+                    err.span_label(sp, &msg);\n+                } else {\n+                    err.note(&msg);\n+                }\n+            }\n+            ObligationCauseCode::BindingObligation(item_def_id, span) => {\n+                let item_name = tcx.def_path_str(item_def_id);\n+                let msg = format!(\"required by this bound in `{}`\", item_name);\n+                if let Some(ident) = tcx.opt_item_name(item_def_id) {\n+                    err.span_label(ident.span, \"\");\n+                }\n+                if span != DUMMY_SP {\n+                    err.span_label(span, &msg);\n                 } else {\n                     err.note(&msg);\n                 }"}, {"sha": "805727b6ce0d72c0711065f284f07d2bf9af9d30", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -68,6 +68,10 @@ pub struct PendingPredicateObligation<'tcx> {\n     pub stalled_on: Vec<Ty<'tcx>>,\n }\n \n+// `PendingPredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PendingPredicateObligation<'_>, 136);\n+\n impl<'a, 'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     pub fn new() -> FulfillmentContext<'tcx> {\n@@ -252,15 +256,20 @@ impl<'a, 'b, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'tcx> {\n         &mut self,\n         pending_obligation: &mut Self::Obligation,\n     ) -> ProcessResult<Self::Obligation, Self::Error> {\n-        // if we were stalled on some unresolved variables, first check\n+        // If we were stalled on some unresolved variables, first check\n         // whether any of them have been resolved; if not, don't bother\n         // doing more work yet\n         if !pending_obligation.stalled_on.is_empty() {\n-            if pending_obligation.stalled_on.iter().all(|&ty| {\n-                // Use the force-inlined variant of shallow_resolve() because this code is hot.\n-                let resolved = ShallowResolver::new(self.selcx.infcx()).inlined_shallow_resolve(ty);\n-                resolved == ty // nothing changed here\n-            }) {\n+            let mut changed = false;\n+            // This `for` loop was once a call to `all()`, but this lower-level\n+            // form was a perf win. See #64545 for details.\n+            for &ty in &pending_obligation.stalled_on {\n+                if ShallowResolver::new(self.selcx.infcx()).shallow_resolve_changed(ty) {\n+                    changed = true;\n+                    break;\n+                }\n+            }\n+            if !changed {\n                 debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n                        self.selcx.infcx()\n                            .resolve_vars_if_possible(&pending_obligation.obligation),"}, {"sha": "1123422ad6008244666bad70a1d8ee24ea7380a6", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 42, "deletions": 20, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -123,6 +123,10 @@ pub struct Obligation<'tcx, T> {\n pub type PredicateObligation<'tcx> = Obligation<'tcx, ty::Predicate<'tcx>>;\n pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n \n+// `PredicateObligation` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(PredicateObligation<'_>, 112);\n+\n /// The reason why we incurred this obligation; used for error reporting.\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct ObligationCause<'tcx> {\n@@ -147,7 +151,8 @@ impl<'tcx> ObligationCause<'tcx> {\n             ObligationCauseCode::StartFunctionType => {\n                 tcx.sess.source_map().def_span(self.span)\n             }\n-            ObligationCauseCode::MatchExpressionArm { arm_span, .. } => arm_span,\n+            ObligationCauseCode::MatchExpressionArm(\n+                box MatchExpressionArmCause { arm_span, .. }) => arm_span,\n             _ => self.span,\n         }\n     }\n@@ -171,6 +176,9 @@ pub enum ObligationCauseCode<'tcx> {\n     /// also implement all supertraits of `X`.\n     ItemObligation(DefId),\n \n+    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n+    BindingObligation(DefId, Span),\n+\n     /// A type like `&'a T` is WF only if `T: 'a`.\n     ReferenceOutlivesReferent(Ty<'tcx>),\n \n@@ -223,23 +231,13 @@ pub enum ObligationCauseCode<'tcx> {\n     ExprAssignable,\n \n     /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm {\n-        arm_span: Span,\n-        source: hir::MatchSource,\n-        prior_arms: Vec<Span>,\n-        last_ty: Ty<'tcx>,\n-        discrim_hir_id: hir::HirId,\n-    },\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n     /// Computing common supertype in the pattern guard for the arms of a match expression\n     MatchExpressionArmPattern { span: Span, ty: Ty<'tcx> },\n \n     /// Computing common supertype in an if expression\n-    IfExpression {\n-        then: Span,\n-        outer: Option<Span>,\n-        semicolon: Option<Span>,\n-    },\n+    IfExpression(Box<IfExpressionCause>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -269,6 +267,26 @@ pub enum ObligationCauseCode<'tcx> {\n     TrivialBound,\n }\n \n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub discrim_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n pub struct DerivedObligationCause<'tcx> {\n     /// The trait reference of the parent obligation that led to the\n@@ -469,7 +487,11 @@ EnumTypeFoldableImpl! {\n \n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n-    pub code: FulfillmentErrorCode<'tcx>\n+    pub code: FulfillmentErrorCode<'tcx>,\n+    /// Diagnostics only: we opportunistically change the `code.span` when we encounter an\n+    /// obligation error caused by a call argument. When this is the case, we also signal that in\n+    /// this field to ensure accuracy of suggestions.\n+    pub points_at_arg_span: bool,\n }\n \n #[derive(Clone)]\n@@ -640,11 +662,11 @@ pub struct VtableTraitAliasData<'tcx, N> {\n }\n \n /// Creates predicate obligations from the generic bounds.\n-pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n-                                     -> PredicateObligations<'tcx>\n-{\n+pub fn predicates_for_generics<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n+) -> PredicateObligations<'tcx> {\n     util::predicates_for_generics(cause, 0, param_env, generic_bounds)\n }\n \n@@ -1168,7 +1190,7 @@ impl<'tcx> FulfillmentError<'tcx> {\n            code: FulfillmentErrorCode<'tcx>)\n            -> FulfillmentError<'tcx>\n     {\n-        FulfillmentError { obligation: obligation, code: code }\n+        FulfillmentError { obligation: obligation, code: code, points_at_arg_span: false }\n     }\n }\n "}, {"sha": "a7990c4af69fd50fd0bfa7862689d4d243982b7a", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 59, "deletions": 42, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -20,7 +20,7 @@ use std::borrow::Cow;\n use std::iter::{self};\n use syntax::ast::{self};\n use syntax::symbol::InternedString;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, DUMMY_SP};\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum ObjectSafetyViolation {\n@@ -32,10 +32,10 @@ pub enum ObjectSafetyViolation {\n     SupertraitSelf,\n \n     /// Method has something illegal.\n-    Method(ast::Name, MethodViolationCode),\n+    Method(ast::Name, MethodViolationCode, Span),\n \n     /// Associated const.\n-    AssocConst(ast::Name),\n+    AssocConst(ast::Name, Span),\n }\n \n impl ObjectSafetyViolation {\n@@ -46,22 +46,35 @@ impl ObjectSafetyViolation {\n             ObjectSafetyViolation::SupertraitSelf =>\n                 \"the trait cannot use `Self` as a type parameter \\\n                  in the supertraits or where-clauses\".into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod) =>\n-                format!(\"method `{}` has no receiver\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf) =>\n-                format!(\"method `{}` references the `Self` type \\\n-                         in its arguments or return type\", name).into(),\n-            ObjectSafetyViolation::Method(name,\n-                                            MethodViolationCode::WhereClauseReferencesSelf(_)) =>\n-                format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod, _) =>\n+                format!(\"associated function `{}` has no `self` parameter\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf, _) => format!(\n+                \"method `{}` references the `Self` type in its parameters or return type\",\n+                name,\n+            ).into(),\n+            ObjectSafetyViolation::Method(\n+                name,\n+                MethodViolationCode::WhereClauseReferencesSelf,\n+                _,\n+            ) => format!(\"method `{}` references the `Self` type in where clauses\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic, _) =>\n                 format!(\"method `{}` has generic type parameters\", name).into(),\n-            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver) =>\n-                format!(\"method `{}`'s receiver cannot be dispatched on\", name).into(),\n-            ObjectSafetyViolation::AssocConst(name) =>\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::UndispatchableReceiver, _) =>\n+                format!(\"method `{}`'s `self` parameter cannot be dispatched on\", name).into(),\n+            ObjectSafetyViolation::AssocConst(name, _) =>\n                 format!(\"the trait cannot contain associated consts like `{}`\", name).into(),\n         }\n     }\n+\n+    pub fn span(&self) -> Option<Span> {\n+        // When `span` comes from a separate crate, it'll be `DUMMY_SP`. Treat it as `None` so\n+        // diagnostics use a `note` instead of a `span_label`.\n+        match *self {\n+            ObjectSafetyViolation::AssocConst(_, span) |\n+            ObjectSafetyViolation::Method(_, _, span) if span != DUMMY_SP => Some(span),\n+            _ => None,\n+        }\n+    }\n }\n \n /// Reasons a method might not be object-safe.\n@@ -74,7 +87,7 @@ pub enum MethodViolationCode {\n     ReferencesSelf,\n \n     /// e.g., `fn foo(&self) where Self: Clone`\n-    WhereClauseReferencesSelf(Span),\n+    WhereClauseReferencesSelf,\n \n     /// e.g., `fn foo<A>()`\n     Generic,\n@@ -88,9 +101,10 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// astconv -- currently, `Self` in supertraits. This is needed\n     /// because `object_safety_violations` can't be used during\n     /// type collection.\n-    pub fn astconv_object_safety_violations(self, trait_def_id: DefId)\n-                                            -> Vec<ObjectSafetyViolation>\n-    {\n+    pub fn astconv_object_safety_violations(\n+        self,\n+        trait_def_id: DefId,\n+    ) -> Vec<ObjectSafetyViolation> {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         let violations = traits::supertrait_def_ids(self, trait_def_id)\n             .filter(|&def_id| self.predicates_reference_self(def_id, true))\n@@ -116,19 +130,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// We say a method is *vtable safe* if it can be invoked on a trait\n-    /// object.  Note that object-safe traits can have some\n-    /// non-vtable-safe methods, so long as they require `Self:Sized` or\n-    /// otherwise ensure that they cannot be used when `Self=Trait`.\n+    /// object. Note that object-safe traits can have some\n+    /// non-vtable-safe methods, so long as they require `Self: Sized` or\n+    /// otherwise ensure that they cannot be used when `Self = Trait`.\n     pub fn is_vtable_safe_method(self, trait_def_id: DefId, method: &ty::AssocItem) -> bool {\n         debug_assert!(self.generics_of(trait_def_id).has_self);\n         debug!(\"is_vtable_safe_method({:?}, {:?})\", trait_def_id, method);\n-        // Any method that has a `Self : Sized` requisite can't be called.\n+        // Any method that has a `Self: Sized` bound cannot be called.\n         if self.generics_require_sized_self(method.def_id) {\n             return false;\n         }\n \n         match self.virtual_call_violation_for_method(trait_def_id, method) {\n-            None | Some(MethodViolationCode::WhereClauseReferencesSelf(_)) => true,\n+            None | Some(MethodViolationCode::WhereClauseReferencesSelf) => true,\n             Some(_) => false,\n         }\n     }\n@@ -138,12 +152,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         let mut violations: Vec<_> = self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Method)\n             .filter_map(|item|\n-                self.object_safety_violation_for_method(trait_def_id, &item)\n-                    .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n+                self.object_safety_violation_for_method(trait_def_id, &item).map(|code| {\n+                    ObjectSafetyViolation::Method(item.ident.name, code, item.ident.span)\n+                })\n             ).filter(|violation| {\n-                if let ObjectSafetyViolation::Method(_,\n-                    MethodViolationCode::WhereClauseReferencesSelf(span)) = violation\n-                {\n+                if let ObjectSafetyViolation::Method(\n+                    _,\n+                    MethodViolationCode::WhereClauseReferencesSelf,\n+                    span,\n+                ) = violation {\n                     // Using `CRATE_NODE_ID` is wrong, but it's hard to get a more precise id.\n                     // It's also hard to get a use site span, so we use the method definition span.\n                     self.lint_node_note(\n@@ -169,7 +186,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         violations.extend(self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssocKind::Const)\n-            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name)));\n+            .map(|item| ObjectSafetyViolation::AssocConst(item.ident.name, item.ident.span)));\n \n         debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n                trait_def_id,\n@@ -325,24 +342,23 @@ impl<'tcx> TyCtxt<'tcx> {\n                 .visit_tys_shallow(|t| {\n                     self.contains_illegal_self_type_reference(trait_def_id, t)\n                 }) {\n-            let span = self.def_span(method.def_id);\n-            return Some(MethodViolationCode::WhereClauseReferencesSelf(span));\n+            return Some(MethodViolationCode::WhereClauseReferencesSelf);\n         }\n \n         let receiver_ty = self.liberate_late_bound_regions(\n             method.def_id,\n             &sig.map_bound(|sig| sig.inputs()[0]),\n         );\n \n-        // until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n+        // Until `unsized_locals` is fully implemented, `self: Self` can't be dispatched on.\n         // However, this is already considered object-safe. We allow it as a special case here.\n         // FIXME(mikeyhew) get rid of this `if` statement once `receiver_is_dispatchable` allows\n-        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`\n+        // `Receiver: Unsize<Receiver[Self => dyn Trait]>`.\n         if receiver_ty != self.types.self_param {\n             if !self.receiver_is_dispatchable(method, receiver_ty) {\n                 return Some(MethodViolationCode::UndispatchableReceiver);\n             } else {\n-                // sanity check to make sure the receiver actually has the layout of a pointer\n+                // Do sanity check to make sure the receiver actually has the layout of a pointer.\n \n                 use crate::ty::layout::Abi;\n \n@@ -352,12 +368,12 @@ impl<'tcx> TyCtxt<'tcx> {\n                     match self.layout_of(param_env.and(ty)) {\n                         Ok(layout) => &layout.abi,\n                         Err(err) => bug!(\n-                            \"Error: {}\\n while computing layout for type {:?}\", err, ty\n+                            \"error: {}\\n while computing layout for type {:?}\", err, ty\n                         )\n                     }\n                 };\n \n-                // e.g., Rc<()>\n+                // e.g., `Rc<()>`\n                 let unit_receiver_ty = self.receiver_for_self_ty(\n                     receiver_ty, self.mk_unit(), method.def_id\n                 );\n@@ -368,7 +384,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = () should have a Scalar ABI, found {:?}\",\n+                                \"receiver when `Self = ()` should have a Scalar ABI; found {:?}\",\n                                 abi\n                             ),\n                         );\n@@ -379,7 +395,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                     trait_def_id, self.mk_region(ty::ReStatic)\n                 );\n \n-                // e.g., Rc<dyn Trait>\n+                // e.g., `Rc<dyn Trait>`\n                 let trait_object_receiver = self.receiver_for_self_ty(\n                     receiver_ty, trait_object_ty, method.def_id\n                 );\n@@ -390,7 +406,8 @@ impl<'tcx> TyCtxt<'tcx> {\n                         self.sess.delay_span_bug(\n                             self.def_span(method.def_id),\n                             &format!(\n-                                \"Receiver when Self = {} should have a ScalarPair ABI, found {:?}\",\n+                                \"receiver when `Self = {}` should have a ScalarPair ABI; \\\n+                                 found {:?}\",\n                                 trait_object_ty, abi\n                             ),\n                         );\n@@ -402,8 +419,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         None\n     }\n \n-    /// Performs a type substitution to produce the version of receiver_ty when `Self = self_ty`\n-    /// e.g., for receiver_ty = `Rc<Self>` and self_ty = `Foo`, returns `Rc<Foo>`.\n+    /// Performs a type substitution to produce the version of `receiver_ty` when `Self = self_ty`.\n+    /// For example, for `receiver_ty = Rc<Self>` and `self_ty = Foo`, returns `Rc<Foo>`.\n     fn receiver_for_self_ty(\n         self,\n         receiver_ty: Ty<'tcx>,"}, {"sha": "5a988d9509e800ee8cb903b36810b8c218c638a3", "filename": "src/librustc/traits/on_unimplemented.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fon_unimplemented.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -9,10 +9,9 @@ use syntax::ast::{MetaItem, NestedMetaItem};\n use syntax::attr;\n use syntax::symbol::{Symbol, kw, sym};\n use syntax_pos::Span;\n-use syntax_pos::symbol::LocalInternedString;\n \n #[derive(Clone, Debug)]\n-pub struct OnUnimplementedFormatString(LocalInternedString);\n+pub struct OnUnimplementedFormatString(Symbol);\n \n #[derive(Debug)]\n pub struct OnUnimplementedDirective {\n@@ -89,19 +88,19 @@ impl<'tcx> OnUnimplementedDirective {\n             if item.check_name(sym::message) && message.is_none() {\n                 if let Some(message_) = item.value_str() {\n                     message = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, message_.as_str(), span)?);\n+                        tcx, trait_def_id, message_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::label) && label.is_none() {\n                 if let Some(label_) = item.value_str() {\n                     label = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, label_.as_str(), span)?);\n+                        tcx, trait_def_id, label_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::note) && note.is_none() {\n                 if let Some(note_) = item.value_str() {\n                     note = Some(OnUnimplementedFormatString::try_parse(\n-                        tcx, trait_def_id, note_.as_str(), span)?);\n+                        tcx, trait_def_id, note_, span)?);\n                     continue;\n                 }\n             } else if item.check_name(sym::on) && is_root &&\n@@ -154,7 +153,7 @@ impl<'tcx> OnUnimplementedDirective {\n                 message: None,\n                 subcommands: vec![],\n                 label: Some(OnUnimplementedFormatString::try_parse(\n-                    tcx, trait_def_id, value.as_str(), attr.span)?),\n+                    tcx, trait_def_id, value, attr.span)?),\n                 note: None,\n             }))\n         } else {\n@@ -218,7 +217,7 @@ impl<'tcx> OnUnimplementedFormatString {\n     fn try_parse(\n         tcx: TyCtxt<'tcx>,\n         trait_def_id: DefId,\n-        from: LocalInternedString,\n+        from: Symbol,\n         err_sp: Span,\n     ) -> Result<Self, ErrorReported> {\n         let result = OnUnimplementedFormatString(from);\n@@ -234,7 +233,8 @@ impl<'tcx> OnUnimplementedFormatString {\n     ) -> Result<(), ErrorReported> {\n         let name = tcx.item_name(trait_def_id);\n         let generics = tcx.generics_of(trait_def_id);\n-        let parser = Parser::new(&self.0, None, vec![], false);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(&s, None, vec![], false);\n         let mut result = Ok(());\n         for token in parser {\n             match token {\n@@ -294,7 +294,8 @@ impl<'tcx> OnUnimplementedFormatString {\n         }).collect::<FxHashMap<Symbol, String>>();\n         let empty_string = String::new();\n \n-        let parser = Parser::new(&self.0, None, vec![], false);\n+        let s = self.0.as_str();\n+        let parser = Parser::new(&s, None, vec![], false);\n         parser.map(|p|\n             match p {\n                 Piece::String(s) => s,"}, {"sha": "87a23f655a8f33560917b9db59563381a8c42fdf", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -15,7 +15,6 @@ use super::util;\n use crate::hir::def_id::DefId;\n use crate::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime};\n use crate::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_macros::HashStable;\n use syntax::ast::Ident;\n@@ -397,40 +396,7 @@ impl<'a, 'b, 'tcx> TypeFolder<'tcx> for AssocTypeNormalizer<'a, 'b, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.selcx.tcx().global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.selcx.tcx(), self.param_env)\n     }\n }\n "}, {"sha": "b9557ceaa6d9f87aaf53cd7b540e3723509f69a2", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,7 +1,8 @@\n use crate::infer::InferCtxt;\n use crate::infer::canonical::OriginalQueryValues;\n-use crate::traits::{EvaluationResult, PredicateObligation, SelectionContext,\n-             TraitQueryMode, OverflowError};\n+use crate::traits::{\n+    EvaluationResult, PredicateObligation, SelectionContext, TraitQueryMode, OverflowError,\n+};\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied (by any means)"}, {"sha": "039dea1ffcd1655d4346485a8129d9c57e0c38ad", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -6,11 +6,11 @@ use crate::ty::Ty;\n pub struct CandidateStep<'tcx> {\n     pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n     pub autoderefs: usize,\n-    // true if the type results from a dereference of a raw pointer.\n-    // when assembling candidates, we include these steps, but not when\n-    // picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    // `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    // `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    /// `true` if the type results from a dereference of a raw pointer.\n+    /// when assembling candidates, we include these steps, but not when\n+    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n     pub from_unsafe_deref: bool,\n     pub unsize: bool,\n }"}, {"sha": "c31ff3ab1b55ddfba793327ca3665875abd26d4d", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 36, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,11 +5,10 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::{InferCtxt, InferOk};\n-use crate::mir::interpret::{GlobalId, ConstValue};\n use crate::traits::project::Normalized;\n use crate::traits::{Obligation, ObligationCause, PredicateObligation, Reveal};\n use crate::ty::fold::{TypeFoldable, TypeFolder};\n-use crate::ty::subst::{Subst, InternalSubsts};\n+use crate::ty::subst::Subst;\n use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n@@ -191,40 +190,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for QueryNormalizer<'cx, 'tcx> {\n     }\n \n     fn fold_const(&mut self, constant: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if let ConstValue::Unevaluated(def_id, substs) = constant.val {\n-            let tcx = self.infcx.tcx.global_tcx();\n-            let param_env = self.param_env;\n-            if !param_env.has_local_value() {\n-                if substs.needs_infer() || substs.has_placeholders() {\n-                    let identity_substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    let instance = ty::Instance::resolve(tcx, param_env, def_id, identity_substs);\n-                    if let Some(instance) = instance {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                            let evaluated = evaluated.subst(tcx, substs);\n-                            return evaluated;\n-                        }\n-                    }\n-                } else {\n-                    if !substs.has_local_value() {\n-                        let instance = ty::Instance::resolve(tcx, param_env, def_id, substs);\n-                        if let Some(instance) = instance {\n-                            let cid = GlobalId {\n-                                instance,\n-                                promoted: None,\n-                            };\n-                            if let Ok(evaluated) = tcx.const_eval(param_env.and(cid)) {\n-                                return evaluated;\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        constant\n+        constant.eval(self.infcx.tcx, self.param_env)\n     }\n }\n "}, {"sha": "a54bc05f169615917beae66bd191b58209457937", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -134,7 +134,7 @@ impl IntercrateAmbiguityCause {\n                     String::new()\n                 };\n                 format!(\n-                    \"upstream crates may add new impl of trait `{}`{} \\\n+                    \"upstream crates may add a new impl of trait `{}`{} \\\n                      in future versions\",\n                     trait_desc, self_desc\n                 )\n@@ -3513,7 +3513,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 // We can only make objects from sized types.\n                 let tr = ty::TraitRef {\n-                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                    def_id: tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                     substs: tcx.mk_substs_trait(source, &[]),\n                 };\n                 nested.push(predicate_to_obligation(tr.to_predicate()));"}, {"sha": "68c97226f89cfd7fb156669108a8c7cb85e5d83e", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -472,6 +472,7 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n             super::TupleElem => Some(super::TupleElem),\n             super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n             super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n             super::ReferenceOutlivesReferent(ty) => {\n                 tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n             }\n@@ -508,31 +509,33 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 trait_item_def_id,\n             }),\n             super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm {\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                 arm_span,\n                 source,\n                 ref prior_arms,\n                 last_ty,\n                 discrim_hir_id,\n-            } => {\n+            }) => {\n                 tcx.lift(&last_ty).map(|last_ty| {\n-                    super::MatchExpressionArm {\n+                    super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                         arm_span,\n                         source,\n                         prior_arms: prior_arms.clone(),\n                         last_ty,\n                         discrim_hir_id,\n-                    }\n+                    })\n                 })\n             }\n             super::MatchExpressionArmPattern { span, ty } => {\n                 tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n             }\n-            super::IfExpression { then, outer, semicolon } => Some(super::IfExpression {\n-                then,\n-                outer,\n-                semicolon,\n-            }),\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause {\n+                    then,\n+                    outer,\n+                    semicolon,\n+                }))\n+            }\n             super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n             super::MainFunctionType => Some(super::MainFunctionType),\n             super::StartFunctionType => Some(super::StartFunctionType),"}, {"sha": "3e5520dd46557af9c9112fca61b3f4b81135e632", "filename": "src/librustc/traits/util.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Futil.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -512,21 +512,20 @@ pub fn impl_trait_ref_and_oblig<'a, 'tcx>(\n     (impl_trait_ref, impl_obligations)\n }\n \n-/// See `super::obligations_for_generics`\n-pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n-                                     recursion_depth: usize,\n-                                     param_env: ty::ParamEnv<'tcx>,\n-                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n-                                     -> Vec<PredicateObligation<'tcx>>\n-{\n-    debug!(\"predicates_for_generics(generic_bounds={:?})\",\n-           generic_bounds);\n-\n-    generic_bounds.predicates.iter().map(|predicate| {\n-        Obligation { cause: cause.clone(),\n-                     recursion_depth,\n-                     param_env,\n-                     predicate: predicate.clone() }\n+/// See [`super::obligations_for_generics`].\n+pub fn predicates_for_generics<'tcx>(\n+    cause: ObligationCause<'tcx>,\n+    recursion_depth: usize,\n+    param_env: ty::ParamEnv<'tcx>,\n+    generic_bounds: &ty::InstantiatedPredicates<'tcx>,\n+) -> Vec<PredicateObligation<'tcx>> {\n+    debug!(\"predicates_for_generics(generic_bounds={:?})\", generic_bounds);\n+\n+    generic_bounds.predicates.iter().map(|predicate| Obligation {\n+        cause: cause.clone(),\n+        recursion_depth,\n+        param_env,\n+        predicate: predicate.clone(),\n     }).collect()\n }\n \n@@ -562,7 +561,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         predicate_for_trait_ref(cause, param_env, trait_ref, recursion_depth)\n     }\n \n-    /// Cast a trait reference into a reference to one of its super\n+    /// Casts a trait reference into a reference to one of its super\n     /// traits; returns `None` if `target_trait_def_id` is not a\n     /// supertrait.\n     pub fn upcast_choices(self,\n@@ -571,7 +570,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                           -> Vec<ty::PolyTraitRef<'tcx>>\n     {\n         if source_trait_ref.def_id() == target_trait_def_id {\n-            return vec![source_trait_ref]; // shorcut the most common case\n+            return vec![source_trait_ref]; // Shortcut the most common case.\n         }\n \n         supertraits(self, source_trait_ref)"}, {"sha": "1aa21501129c8ab41718b6fc465f05c292ddc627", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -284,9 +284,11 @@ where\n #[macro_export]\n macro_rules! __impl_decoder_methods {\n     ($($name:ident -> $ty:ty;)*) => {\n-        $(fn $name(&mut self) -> Result<$ty, Self::Error> {\n-            self.opaque.$name()\n-        })*\n+        $(\n+            fn $name(&mut self) -> Result<$ty, Self::Error> {\n+                self.opaque.$name()\n+            }\n+        )*\n     }\n }\n \n@@ -327,14 +329,17 @@ macro_rules! impl_arena_allocatable_decoders {\n macro_rules! implement_ty_decoder {\n     ($DecoderName:ident <$($typaram:tt),*>) => {\n         mod __ty_decoder_impl {\n-            use super::$DecoderName;\n+            use std::borrow::Cow;\n+\n+            use rustc_serialize::{Decoder, SpecializedDecoder};\n+\n             use $crate::infer::canonical::CanonicalVarInfos;\n             use $crate::ty;\n             use $crate::ty::codec::*;\n             use $crate::ty::subst::SubstsRef;\n             use $crate::hir::def_id::{CrateNum};\n-            use rustc_serialize::{Decoder, SpecializedDecoder};\n-            use std::borrow::Cow;\n+\n+            use super::$DecoderName;\n \n             impl<$($typaram ),*> Decoder for $DecoderName<$($typaram),*> {\n                 type Error = String;\n@@ -368,8 +373,8 @@ macro_rules! implement_ty_decoder {\n                 }\n             }\n \n-            // FIXME(#36588) These impls are horribly unsound as they allow\n-            // the caller to pick any lifetime for 'tcx, including 'static,\n+            // FIXME(#36588): These impls are horribly unsound as they allow\n+            // the caller to pick any lifetime for `'tcx`, including `'static`,\n             // by using the unspecialized proxies to them.\n \n             arena_types!(impl_arena_allocatable_decoders, [$DecoderName [$($typaram),*]], 'tcx);"}, {"sha": "0155803e30580ace326f457a2559e75a2ef5836b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 136, "deletions": 108, "changes": 244, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -7,7 +7,7 @@ use crate::session::Session;\n use crate::session::config::{BorrowckMode, OutputFilenames};\n use crate::session::config::CrateType;\n use crate::middle;\n-use crate::hir::{TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n+use crate::hir::{self, TraitCandidate, HirId, ItemKind, ItemLocalId, Node};\n use crate::hir::def::{Res, DefKind, Export};\n use crate::hir::def_id::{CrateNum, DefId, DefIndex, LOCAL_CRATE};\n use crate::hir::map as hir_map;\n@@ -21,7 +21,7 @@ use crate::middle::cstore::EncodedMetadata;\n use crate::middle::lang_items;\n use crate::middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::{Body, interpret, ProjectionKind};\n+use crate::mir::{Body, interpret, ProjectionKind, Promoted};\n use crate::mir::interpret::{ConstValue, Allocation, Scalar};\n use crate::ty::subst::{Kind, InternalSubsts, SubstsRef, Subst};\n use crate::ty::ReprOptions;\n@@ -45,15 +45,16 @@ use crate::ty::CanonicalPolyFnSig;\n use crate::util::common::ErrorReported;\n use crate::util::nodemap::{DefIdMap, DefIdSet, ItemLocalMap, ItemLocalSet};\n use crate::util::nodemap::{FxHashMap, FxHashSet};\n+\n use errors::DiagnosticBuilder;\n-use smallvec::SmallVec;\n-use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n-                                           StableHasher, StableHasherResult,\n-                                           StableVec};\n use arena::SyncDroplessArena;\n+use smallvec::SmallVec;\n+use rustc_data_structures::stable_hasher::{\n+    HashStable, StableHasher, StableHasherResult, StableVec, hash_stable_hashmap,\n+};\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n-use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use rustc_data_structures::sharded::ShardedHashMap;\n+use rustc_data_structures::sync::{Lrc, Lock, WorkerLocal};\n use std::any::Any;\n use std::borrow::Borrow;\n use std::cmp::Ordering;\n@@ -74,8 +75,6 @@ use syntax::feature_gate;\n use syntax::symbol::{Symbol, InternedString, kw, sym};\n use syntax_pos::Span;\n \n-use crate::hir;\n-\n pub struct AllArenas {\n     pub interner: SyncDroplessArena,\n }\n@@ -91,10 +90,10 @@ impl AllArenas {\n type InternedSet<'tcx, T> = ShardedHashMap<Interned<'tcx, T>, ()>;\n \n pub struct CtxtInterners<'tcx> {\n-    /// The arena that types, regions, etc are allocated from\n+    /// The arena that types, regions, etc. are allocated from.\n     arena: &'tcx SyncDroplessArena,\n \n-    /// Specifically use a speedy hash algorithm for these hash sets,\n+    /// Specifically use a speedy hash algorithm for these hash sets, since\n     /// they're accessed quite often.\n     type_: InternedSet<'tcx, TyS<'tcx>>,\n     type_list: InternedSet<'tcx, List<Ty<'tcx>>>,\n@@ -129,7 +128,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n         }\n     }\n \n-    /// Intern a type\n+    /// Interns a type.\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline(never)]\n     fn intern_ty(&self,\n@@ -144,7 +143,6 @@ impl<'tcx> CtxtInterners<'tcx> {\n                 outer_exclusive_binder: flags.outer_exclusive_binder,\n             };\n \n-\n             Interned(self.arena.alloc(ty_struct))\n         }).0\n     }\n@@ -207,26 +205,24 @@ pub struct LocalTableInContext<'a, V> {\n fn validate_hir_id_for_typeck_tables(local_id_root: Option<DefId>,\n                                      hir_id: hir::HirId,\n                                      mut_access: bool) {\n-    if cfg!(debug_assertions) {\n-        if let Some(local_id_root) = local_id_root {\n-            if hir_id.owner != local_id_root.index {\n-                ty::tls::with(|tcx| {\n-                    bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n-                          TypeckTables with local_id_root {:?}\",\n-                         tcx.hir().node_to_string(hir_id),\n-                         DefId::local(hir_id.owner),\n-                         local_id_root)\n-                });\n-            }\n-        } else {\n-            // We use \"Null Object\" TypeckTables in some of the analysis passes.\n-            // These are just expected to be empty and their `local_id_root` is\n-            // `None`. Therefore we cannot verify whether a given `HirId` would\n-            // be a valid key for the given table. Instead we make sure that\n-            // nobody tries to write to such a Null Object table.\n-            if mut_access {\n-                bug!(\"access to invalid TypeckTables\")\n-            }\n+    if let Some(local_id_root) = local_id_root {\n+        if hir_id.owner != local_id_root.index {\n+            ty::tls::with(|tcx| {\n+                bug!(\"node {} with HirId::owner {:?} cannot be placed in \\\n+                        TypeckTables with local_id_root {:?}\",\n+                        tcx.hir().node_to_string(hir_id),\n+                        DefId::local(hir_id.owner),\n+                        local_id_root)\n+            });\n+        }\n+    } else {\n+        // We use \"Null Object\" TypeckTables in some of the analysis passes.\n+        // These are just expected to be empty and their `local_id_root` is\n+        // `None`. Therefore we cannot verify whether a given `HirId` would\n+        // be a valid key for the given table. Instead we make sure that\n+        // nobody tries to write to such a Null Object table.\n+        if mut_access {\n+            bug!(\"access to invalid TypeckTables\")\n         }\n     }\n }\n@@ -978,6 +974,7 @@ pub struct FreeRegionInfo {\n ///\n /// [rustc guide]: https://rust-lang.github.io/rustc-guide/ty.html\n #[derive(Copy, Clone)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyCtxt\")]\n pub struct TyCtxt<'tcx> {\n     gcx: &'tcx GlobalCtxt<'tcx>,\n }\n@@ -1024,7 +1021,7 @@ pub struct GlobalCtxt<'tcx> {\n \n     hir_map: hir_map::Map<'tcx>,\n \n-    /// A map from DefPathHash -> DefId. Includes DefIds from the local crate\n+    /// A map from `DefPathHash` -> `DefId`. Includes `DefId`s from the local crate\n     /// as well as all upstream crates. Only populated in incremental mode.\n     pub def_path_hash_to_def_id: Option<FxHashMap<DefPathHash, DefId>>,\n \n@@ -1096,6 +1093,16 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.arena.alloc(Steal::new(mir))\n     }\n \n+    pub fn alloc_steal_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx Steal<IndexVec<Promoted, Body<'tcx>>> {\n+        self.arena.alloc(Steal::new(promoted))\n+    }\n+\n+    pub fn intern_promoted(self, promoted: IndexVec<Promoted, Body<'tcx>>) ->\n+        &'tcx IndexVec<Promoted, Body<'tcx>> {\n+        self.arena.alloc(promoted)\n+    }\n+\n     pub fn alloc_adt_def(\n         self,\n         did: DefId,\n@@ -1113,9 +1120,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    /// Allocates a byte or string literal for `mir::interpret`, read-only\n+    /// Allocates a read-only byte or string literal for `mir::interpret`.\n     pub fn allocate_bytes(self, bytes: &[u8]) -> interpret::AllocId {\n-        // create an allocation that just contains these bytes\n+        // Create an allocation that just contains these bytes.\n         let alloc = interpret::Allocation::from_byte_aligned_bytes(bytes);\n         let alloc = self.intern_const_alloc(alloc);\n         self.alloc_map.lock().create_memory_alloc(alloc)\n@@ -1298,10 +1305,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.get_lib_features(LOCAL_CRATE)\n     }\n \n+    /// Obtain all lang items of this crate and all dependencies (recursively)\n     pub fn lang_items(self) -> &'tcx middle::lang_items::LanguageItems {\n         self.get_lang_items(LOCAL_CRATE)\n     }\n \n+    /// Obtain the given diagnostic item's `DefId`. Use `is_diagnostic_item` if you just want to\n+    /// compare against another `DefId`, since `is_diagnostic_item` is cheaper.\n+    pub fn get_diagnostic_item(self, name: Symbol) -> Option<DefId> {\n+        self.all_diagnostic_items(LOCAL_CRATE).get(&name).copied()\n+    }\n+\n+    /// Check whether the diagnostic item with the given `name` has the given `DefId`.\n+    pub fn is_diagnostic_item(self, name: Symbol, did: DefId) -> bool {\n+        self.diagnostic_items(did.krate).get(&name) == Some(&did)\n+    }\n+\n     pub fn stability(self) -> &'tcx stability::Index<'tcx> {\n         self.stability_index(LOCAL_CRATE)\n     }\n@@ -1323,7 +1342,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Converts a `DefId` into its fully expanded `DefPath` (every\n-    /// `DefId` is really just an interned def-path).\n+    /// `DefId` is really just an interned `DefPath`).\n     ///\n     /// Note that if `id` is not local to this crate, the result will\n     ///  be a non-local `DefPath`.\n@@ -1379,6 +1398,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.cstore.metadata_encoding_version().to_vec()\n     }\n \n+    pub fn encode_metadata(self)-> EncodedMetadata {\n+        self.cstore.encode_metadata(self)\n+    }\n+\n     // Note that this is *untracked* and should only be used within the query\n     // system if the result is otherwise tracked through queries\n     pub fn crate_data_as_rc_any(self, cnum: CrateNum) -> Lrc<dyn Any> {\n@@ -1423,25 +1446,25 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.queries.on_disk_cache.serialize(self.global_tcx(), encoder)\n     }\n \n-    /// If true, we should use the AST-based borrowck (we may *also* use\n+    /// If `true`, we should use the AST-based borrowck (we may *also* use\n     /// the MIR-based borrowck).\n     pub fn use_ast_borrowck(self) -> bool {\n         self.borrowck_mode().use_ast()\n     }\n \n-    /// If true, we should use the MIR-based borrow check, but also\n-    /// fall back on the AST borrow check if the MIR-based one errors.\n+    /// If `true`, we should use the MIR-based borrowck, but also\n+    /// fall back on the AST borrowck if the MIR-based one errors.\n     pub fn migrate_borrowck(self) -> bool {\n         self.borrowck_mode().migrate()\n     }\n \n-    /// If true, make MIR codegen for `match` emit a temp that holds a\n+    /// If `true`, make MIR codegen for `match` emit a temp that holds a\n     /// borrow of the input to the match expression.\n     pub fn generate_borrow_of_any_match_input(&self) -> bool {\n         self.emit_read_for_match()\n     }\n \n-    /// If true, make MIR codegen for `match` emit FakeRead\n+    /// If `true`, make MIR codegen for `match` emit FakeRead\n     /// statements (which simulate the maximal effect of executing the\n     /// patterns in a match arm).\n     pub fn emit_read_for_match(&self) -> bool {\n@@ -1494,7 +1517,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    // This method returns the DefId and the BoundRegion corresponding to the given region.\n+    // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n     pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => (free_region.scope, free_region.bound_region),\n@@ -1527,18 +1550,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self,\n         scope_def_id: DefId,\n     ) -> Option<Ty<'tcx>> {\n-        // HACK: `type_of_def_id()` will fail on these (#55796), so return None\n+        // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().as_local_hir_id(scope_def_id).unwrap();\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.node {\n-                    ItemKind::Fn(..) => { /* type_of_def_id() will work */ }\n+                    ItemKind::Fn(..) => { /* `type_of_def_id()` will work */ }\n                     _ => {\n                         return None;\n                     }\n                 }\n             }\n-            _ => { /* type_of_def_id() will work or panic */ }\n+            _ => { /* `type_of_def_id()` will work or panic */ }\n         }\n \n         let ret_ty = self.type_of(scope_def_id);\n@@ -1556,7 +1579,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    // Here we check if the bound region is in Impl Item.\n+    // Checks if the bound region is in Impl Item.\n     pub fn is_bound_region_in_impl_item(\n         &self,\n         suitable_region_binding_scope: DefId,\n@@ -1576,23 +1599,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         false\n     }\n \n-    /// Determine whether identifiers in the assembly have strict naming rules.\n+    /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n     pub fn has_strict_asm_symbol_naming(&self) -> bool {\n-        self.gcx.sess.target.target.arch.contains(\"nvptx\")\n-    }\n-}\n-\n-impl<'tcx> TyCtxt<'tcx> {\n-    pub fn encode_metadata(self)\n-        -> EncodedMetadata\n-    {\n-        self.cstore.encode_metadata(self)\n+        self.sess.target.target.arch.contains(\"nvptx\")\n     }\n }\n \n impl<'tcx> GlobalCtxt<'tcx> {\n-    /// Call the closure with a local `TyCtxt` using the given arena.\n+    /// Calls the closure with a local `TyCtxt` using the given arena.\n     /// `interners` is a slot passed so we can create a CtxtInterners\n     /// with the same lifetime as `arena`.\n     pub fn enter_local<F, R>(&'tcx self, f: F) -> R\n@@ -1628,7 +1643,7 @@ impl<'tcx> GlobalCtxt<'tcx> {\n /// It would be more efficient if `TypedArena` provided a way to\n /// determine whether the address is in the allocated range.\n ///\n-/// None is returned if the value or one of the components is not part\n+/// `None` is returned if the value or one of the components is not part\n /// of the provided context.\n /// For `Ty`, `None` can be returned if either the type interner doesn't\n /// contain the `TyKind` key or if the address of the interned\n@@ -1639,7 +1654,6 @@ pub trait Lift<'tcx>: fmt::Debug {\n     fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted>;\n }\n \n-\n macro_rules! nop_lift {\n     ($ty:ty => $lifted:ty) => {\n         impl<'a, 'tcx> Lift<'tcx> for $ty {\n@@ -1686,7 +1700,7 @@ nop_list_lift!{Predicate<'a> => Predicate<'tcx>}\n nop_list_lift!{CanonicalVarInfo => CanonicalVarInfo}\n nop_list_lift!{ProjectionKind => ProjectionKind}\n \n-// this is the impl for `&'a InternalSubsts<'a>`\n+// This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift!{Kind<'a> => Kind<'tcx>}\n \n pub mod tls {\n@@ -1709,43 +1723,43 @@ pub mod tls {\n     use rustc_rayon_core as rayon_core;\n \n     /// This is the implicit state of rustc. It contains the current\n-    /// TyCtxt and query. It is updated when creating a local interner or\n-    /// executing a new query. Whenever there's a TyCtxt value available\n-    /// you should also have access to an ImplicitCtxt through the functions\n+    /// `TyCtxt` and query. It is updated when creating a local interner or\n+    /// executing a new query. Whenever there's a `TyCtxt` value available\n+    /// you should also have access to an `ImplicitCtxt` through the functions\n     /// in this module.\n     #[derive(Clone)]\n     pub struct ImplicitCtxt<'a, 'tcx> {\n-        /// The current TyCtxt. Initially created by `enter_global` and updated\n-        /// by `enter_local` with a new local interner\n+        /// The current `TyCtxt`. Initially created by `enter_global` and updated\n+        /// by `enter_local` with a new local interner.\n         pub tcx: TyCtxt<'tcx>,\n \n-        /// The current query job, if any. This is updated by JobOwner::start in\n-        /// ty::query::plumbing when executing a query\n+        /// The current query job, if any. This is updated by `JobOwner::start` in\n+        /// `ty::query::plumbing` when executing a query.\n         pub query: Option<Lrc<query::QueryJob<'tcx>>>,\n \n         /// Where to store diagnostics for the current query job, if any.\n-        /// This is updated by JobOwner::start in ty::query::plumbing when executing a query\n+        /// This is updated by `JobOwner::start` in `ty::query::plumbing` when executing a query.\n         pub diagnostics: Option<&'a Lock<ThinVec<Diagnostic>>>,\n \n         /// Used to prevent layout from recursing too deeply.\n         pub layout_depth: usize,\n \n         /// The current dep graph task. This is used to add dependencies to queries\n-        /// when executing them\n+        /// when executing them.\n         pub task_deps: Option<&'a Lock<TaskDeps>>,\n     }\n \n-    /// Sets Rayon's thread local variable which is preserved for Rayon jobs\n+    /// Sets Rayon's thread-local variable, which is preserved for Rayon jobs\n     /// to `value` during the call to `f`. It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n         rayon_core::tlv::with(value, f)\n     }\n \n-    /// Gets Rayon's thread local variable which is preserved for Rayon jobs.\n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets Rayon's thread-local variable, which is preserved for Rayon jobs.\n+    /// This is used to get the pointer to the current `ImplicitCtxt`.\n     #[cfg(parallel_compiler)]\n     #[inline]\n     fn get_tlv() -> usize {\n@@ -1754,13 +1768,13 @@ pub mod tls {\n \n     #[cfg(not(parallel_compiler))]\n     thread_local! {\n-        /// A thread local variable which stores a pointer to the current ImplicitCtxt.\n+        /// A thread local variable that stores a pointer to the current `ImplicitCtxt`.\n         static TLV: Cell<usize> = Cell::new(0);\n     }\n \n     /// Sets TLV to `value` during the call to `f`.\n     /// It is restored to its previous value after.\n-    /// This is used to set the pointer to the new ImplicitCtxt.\n+    /// This is used to set the pointer to the new `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     #[inline]\n     fn set_tlv<F: FnOnce() -> R, R>(value: usize, f: F) -> R {\n@@ -1770,14 +1784,14 @@ pub mod tls {\n         f()\n     }\n \n-    /// This is used to get the pointer to the current ImplicitCtxt.\n+    /// Gets the pointer to the current `ImplicitCtxt`.\n     #[cfg(not(parallel_compiler))]\n     fn get_tlv() -> usize {\n         TLV.with(|tlv| tlv.get())\n     }\n \n     /// This is a callback from libsyntax as it cannot access the implicit state\n-    /// in librustc otherwise\n+    /// in librustc otherwise.\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         with_opt(|tcx| {\n             if let Some(tcx) = tcx {\n@@ -1802,7 +1816,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets up the callbacks from libsyntax on the current thread\n+    /// Sets up the callbacks from libsyntax on the current thread.\n     pub fn with_thread_locals<F, R>(f: F) -> R\n         where F: FnOnce() -> R\n     {\n@@ -1827,7 +1841,7 @@ pub mod tls {\n         })\n     }\n \n-    /// Sets `context` as the new current ImplicitCtxt for the duration of the function `f`\n+    /// Sets `context` as the new current `ImplicitCtxt` for the duration of the function `f`.\n     #[inline]\n     pub fn enter_context<'a, 'tcx, F, R>(context: &ImplicitCtxt<'a, 'tcx>, f: F) -> R\n     where\n@@ -1838,19 +1852,19 @@ pub mod tls {\n         })\n     }\n \n-    /// Enters GlobalCtxt by setting up libsyntax callbacks and\n-    /// creating a initial TyCtxt and ImplicitCtxt.\n-    /// This happens once per rustc session and TyCtxts only exists\n+    /// Enters `GlobalCtxt` by setting up libsyntax callbacks and\n+    /// creating a initial `TyCtxt` and `ImplicitCtxt`.\n+    /// This happens once per rustc session and `TyCtxt`s only exists\n     /// inside the `f` function.\n     pub fn enter_global<'tcx, F, R>(gcx: &'tcx GlobalCtxt<'tcx>, f: F) -> R\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // Update GCX_PTR to indicate there's a GlobalCtxt available\n+        // Update `GCX_PTR` to indicate there's a `GlobalCtxt` available.\n         GCX_PTR.with(|lock| {\n             *lock.lock() = gcx as *const _ as usize;\n         });\n-        // Set GCX_PTR back to 0 when we exit\n+        // Set `GCX_PTR` back to 0 when we exit.\n         let _on_drop = OnDrop(move || {\n             GCX_PTR.with(|lock| *lock.lock() = 0);\n         });\n@@ -1871,12 +1885,12 @@ pub mod tls {\n     }\n \n     scoped_thread_local! {\n-        /// Stores a pointer to the GlobalCtxt if one is available.\n-        /// This is used to access the GlobalCtxt in the deadlock handler given to Rayon.\n+        /// Stores a pointer to the `GlobalCtxt` if one is available.\n+        /// This is used to access the `GlobalCtxt` in the deadlock handler given to Rayon.\n         pub static GCX_PTR: Lock<usize>\n     }\n \n-    /// Creates a TyCtxt and ImplicitCtxt based on the GCX_PTR thread local.\n+    /// Creates a `TyCtxt` and `ImplicitCtxt` based on the `GCX_PTR` thread local.\n     /// This is used in the deadlock handler.\n     pub unsafe fn with_global<F, R>(f: F) -> R\n     where\n@@ -1898,7 +1912,7 @@ pub mod tls {\n         enter_context(&icx, |_| f(tcx))\n     }\n \n-    /// Allows access to the current ImplicitCtxt in a closure if one is available\n+    /// Allows access to the current `ImplicitCtxt` in a closure if one is available.\n     #[inline]\n     pub fn with_context_opt<F, R>(f: F) -> R\n     where\n@@ -1908,16 +1922,16 @@ pub mod tls {\n         if context == 0 {\n             f(None)\n         } else {\n-            // We could get a ImplicitCtxt pointer from another thread.\n-            // Ensure that ImplicitCtxt is Sync\n+            // We could get a `ImplicitCtxt` pointer from another thread.\n+            // Ensure that `ImplicitCtxt` is `Sync`.\n             sync::assert_sync::<ImplicitCtxt<'_, '_>>();\n \n             unsafe { f(Some(&*(context as *const ImplicitCtxt<'_, '_>))) }\n         }\n     }\n \n-    /// Allows access to the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_context<F, R>(f: F) -> R\n     where\n@@ -1926,11 +1940,11 @@ pub mod tls {\n         with_context_opt(|opt_context| f(opt_context.expect(\"no ImplicitCtxt stored in tls\")))\n     }\n \n-    /// Allows access to the current ImplicitCtxt whose tcx field has the same global\n-    /// interner as the tcx argument passed in. This means the closure is given an ImplicitCtxt\n-    /// with the same 'tcx lifetime as the TyCtxt passed in.\n-    /// This will panic if you pass it a TyCtxt which has a different global interner from\n-    /// the current ImplicitCtxt's tcx field.\n+    /// Allows access to the current `ImplicitCtxt` whose tcx field has the same global\n+    /// interner as the tcx argument passed in. This means the closure is given an `ImplicitCtxt`\n+    /// with the same `'tcx` lifetime as the `TyCtxt` passed in.\n+    /// This will panic if you pass it a `TyCtxt` which has a different global interner from\n+    /// the current `ImplicitCtxt`'s `tcx` field.\n     #[inline]\n     pub fn with_related_context<'tcx, F, R>(tcx: TyCtxt<'tcx>, f: F) -> R\n     where\n@@ -1945,8 +1959,8 @@ pub mod tls {\n         })\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// Panics if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// Panics if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with<F, R>(f: F) -> R\n     where\n@@ -1955,8 +1969,8 @@ pub mod tls {\n         with_context(|context| f(context.tcx))\n     }\n \n-    /// Allows access to the TyCtxt in the current ImplicitCtxt.\n-    /// The closure is passed None if there is no ImplicitCtxt available\n+    /// Allows access to the `TyCtxt` in the current `ImplicitCtxt`.\n+    /// The closure is passed None if there is no `ImplicitCtxt` available.\n     #[inline]\n     pub fn with_opt<F, R>(f: F) -> R\n     where\n@@ -1968,7 +1982,7 @@ pub mod tls {\n \n macro_rules! sty_debug_print {\n     ($ctxt: expr, $($variant: ident),*) => {{\n-        // curious inner module to allow variant names to be used as\n+        // Curious inner module to allow variant names to be used as\n         // variable names.\n         #[allow(non_snake_case)]\n         mod inner {\n@@ -2242,9 +2256,9 @@ slice_interners!(\n     projs: _intern_projs(ProjectionKind)\n );\n \n-// This isn't a perfect fit: CanonicalVarInfo slices are always\n+// This isn't a perfect fit: `CanonicalVarInfo` slices are always\n // allocated in the global arena, so this `intern_method!` macro is\n-// overly general.  But we just return false for the code that checks\n+// overly general. However, we just return `false` for the code that checks\n // whether they belong in the thread-local arena, so no harm done, and\n // seems better than open-coding the rest.\n intern_method! {\n@@ -2343,7 +2357,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_adt(self, def: &'tcx AdtDef, substs: SubstsRef<'tcx>) -> Ty<'tcx> {\n-        // take a copy of substs so that we own the vectors inside\n+        // Take a copy of substs so that we own the vectors inside.\n         self.mk_ty(Adt(def, substs))\n     }\n \n@@ -2375,13 +2389,19 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     #[inline]\n     pub fn mk_box(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem);\n+        let def_id = self.require_lang_item(lang_items::OwnedBoxLangItem, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n+    #[inline]\n+    pub fn mk_lang_item(self, ty: Ty<'tcx>, item: lang_items::LangItem)  -> Option<Ty<'tcx>> {\n+        let def_id = self.lang_items().require(item).ok()?;\n+        Some(self.mk_generic_adt(def_id, ty))\n+    }\n+\n     #[inline]\n     pub fn mk_maybe_uninit(self, ty: Ty<'tcx>) -> Ty<'tcx> {\n-        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem);\n+        let def_id = self.require_lang_item(lang_items::MaybeUninitLangItem, None);\n         self.mk_generic_adt(def_id, ty)\n     }\n \n@@ -2886,6 +2906,14 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         assert_eq!(id, LOCAL_CRATE);\n         tcx.arena.alloc(middle::lang_items::collect(tcx))\n     };\n+    providers.diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect(tcx)\n+    };\n+    providers.all_diagnostic_items = |tcx, id| {\n+        assert_eq!(id, LOCAL_CRATE);\n+        middle::diagnostic_items::collect_all(tcx)\n+    };\n     providers.maybe_unused_trait_import = |tcx, id| {\n         tcx.maybe_unused_trait_imports.contains(&id)\n     };"}, {"sha": "125c48f5f31d738baad7209eceda2cdaae924773", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 118, "deletions": 16, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,6 +4,7 @@ use std::borrow::Cow;\n use std::fmt;\n use rustc_target::spec::abi;\n use syntax::ast;\n+use syntax::errors::pluralise;\n use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n \n@@ -46,6 +47,8 @@ pub enum TypeError<'tcx> {\n     ExistentialMismatch(ExpectedFound<&'tcx ty::List<ty::ExistentialPredicate<'tcx>>>),\n \n     ConstMismatch(ExpectedFound<&'tcx ty::Const<'tcx>>),\n+\n+    IntrinsicCast,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -80,12 +83,6 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             }\n         };\n \n-        macro_rules! pluralise {\n-            ($x:expr) => {\n-                if $x != 1 { \"s\" } else { \"\" }\n-            };\n-        }\n-\n         match *self {\n             CyclicTy(_) => write!(f, \"cyclic type of infinite size\"),\n             Mismatch => write!(f, \"types differ\"),\n@@ -179,6 +176,9 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             ConstMismatch(ref values) => {\n                 write!(f, \"expected `{}`, found `{}`\", values.expected, values.found)\n             }\n+            IntrinsicCast => {\n+                write!(f, \"cannot coerce intrinsics to function pointers\")\n+            }\n         }\n     }\n }\n@@ -195,7 +195,9 @@ impl<'tcx> ty::TyS<'tcx> {\n             ty::Array(_, n) => {\n                 let n = tcx.lift_to_global(&n).unwrap();\n                 match n.try_eval_usize(tcx, ty::ParamEnv::empty()) {\n-                    Some(n) => format!(\"array of {} elements\", n).into(),\n+                    Some(n) => {\n+                        format!(\"array of {} element{}\", n, pluralise!(n)).into()\n+                    }\n                     None => \"array\".into(),\n                 }\n             }\n@@ -247,24 +249,36 @@ impl<'tcx> ty::TyS<'tcx> {\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    pub fn note_and_explain_type_err(self,\n-                                     db: &mut DiagnosticBuilder<'_>,\n-                                     err: &TypeError<'tcx>,\n-                                     sp: Span) {\n+    pub fn note_and_explain_type_err(\n+        self,\n+        db: &mut DiagnosticBuilder<'_>,\n+        err: &TypeError<'tcx>,\n+        sp: Span,\n+    ) {\n         use self::TypeError::*;\n \n-        match err.clone() {\n+        match err {\n             Sorts(values) => {\n                 let expected_str = values.expected.sort_string(self);\n                 let found_str = values.found.sort_string(self);\n                 if expected_str == found_str && expected_str == \"closure\" {\n                     db.note(\"no two closures, even if identical, have the same type\");\n                     db.help(\"consider boxing your closure and/or using it as a trait object\");\n                 }\n-                if let (ty::Infer(ty::IntVar(_)), ty::Float(_)) =\n-                       (&values.found.sty, &values.expected.sty) // Issue #53280\n-                {\n-                    if let Ok(snippet) = self.sess.source_map().span_to_snippet(sp) {\n+                if expected_str == found_str && expected_str == \"opaque type\" { // Issue #63167\n+                    db.note(\"distinct uses of `impl Trait` result in different opaque types\");\n+                    let e_str = values.expected.to_string();\n+                    let f_str = values.found.to_string();\n+                    if &e_str == &f_str && &e_str == \"impl std::future::Future\" {\n+                        // FIXME: use non-string based check.\n+                        db.help(\"if both `Future`s have the same `Output` type, consider \\\n+                                 `.await`ing on both of them\");\n+                    }\n+                }\n+                match (&values.expected.sty, &values.found.sty) {\n+                    (ty::Float(_), ty::Infer(ty::IntVar(_))) => if let Ok( // Issue #53280\n+                        snippet,\n+                    ) = self.sess.source_map().span_to_snippet(sp) {\n                         if snippet.chars().all(|c| c.is_digit(10) || c == '-' || c == '_') {\n                             db.span_suggestion(\n                                 sp,\n@@ -273,8 +287,96 @@ impl<'tcx> TyCtxt<'tcx> {\n                                 Applicability::MachineApplicable\n                             );\n                         }\n+                    },\n+                    (ty::Param(_), ty::Param(_)) => {\n+                        db.note(\"a type parameter was expected, but a different one was found; \\\n+                                 you might be missing a type parameter or trait bound\");\n+                        db.note(\"for more information, visit \\\n+                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                                 #traits-as-parameters\");\n+                    }\n+                    (ty::Projection(_), ty::Projection(_)) => {\n+                        db.note(\"an associated type was expected, but a different one was found\");\n+                    }\n+                    (ty::Param(_), ty::Projection(_)) | (ty::Projection(_), ty::Param(_)) => {\n+                        db.note(\"you might be missing a type parameter or trait bound\");\n+                    }\n+                    (ty::Param(_), _) | (_, ty::Param(_)) => {\n+                        db.help(\"type parameters must be constrained to match other types\");\n+                        if self.sess.teach(&db.get_code().unwrap()) {\n+                            db.help(\"given a type parameter `T` and a method `foo`:\n+```\n+trait Trait<T> { fn foo(&self) -> T; }\n+```\n+the only ways to implement method `foo` are:\n+- constrain `T` with an explicit type:\n+```\n+impl Trait<String> for X {\n+    fn foo(&self) -> String { String::new() }\n+}\n+```\n+- add a trait bound to `T` and call a method on that trait that returns `Self`:\n+```\n+impl<T: std::default::Default> Trait<T> for X {\n+    fn foo(&self) -> T { <T as std::default::Default>::default() }\n+}\n+```\n+- change `foo` to return an argument of type `T`:\n+```\n+impl<T> Trait<T> for X {\n+    fn foo(&self, x: T) -> T { x }\n+}\n+```\");\n+                        }\n+                        db.note(\"for more information, visit \\\n+                                 https://doc.rust-lang.org/book/ch10-02-traits.html\\\n+                                 #traits-as-parameters\");\n+                    }\n+                    (ty::Projection(_), _) => {\n+                        db.note(&format!(\n+                            \"consider constraining the associated type `{}` to `{}` or calling a \\\n+                             method that returns `{}`\",\n+                            values.expected,\n+                            values.found,\n+                            values.expected,\n+                        ));\n+                        if self.sess.teach(&db.get_code().unwrap()) {\n+                            db.help(\"given an associated type `T` and a method `foo`:\n+```\n+trait Trait {\n+    type T;\n+    fn foo(&self) -> Self::T;\n+}\n+```\n+the only way of implementing method `foo` is to constrain `T` with an explicit associated type:\n+```\n+impl Trait for X {\n+    type T = String;\n+    fn foo(&self) -> Self::T { String::new() }\n+}\n+```\");\n+                        }\n+                        db.note(\"for more information, visit \\\n+                                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\");\n+                    }\n+                    (_, ty::Projection(_)) => {\n+                        db.note(&format!(\n+                            \"consider constraining the associated type `{}` to `{}`\",\n+                            values.found,\n+                            values.expected,\n+                        ));\n+                        db.note(\"for more information, visit \\\n+                                 https://doc.rust-lang.org/book/ch19-03-advanced-traits.html\");\n                     }\n+                    _ => {}\n                 }\n+                debug!(\n+                    \"note_and_explain_type_err expected={:?} ({:?}) found={:?} ({:?})\",\n+                    values.expected,\n+                    values.expected.sty,\n+                    values.found,\n+                    values.found.sty,\n+                );\n             },\n             CyclicTy(ty) => {\n                 // Watch out for various cases of cyclic types and try to explain."}, {"sha": "1e08ae45951d1e4db2b17a19b36af95c1009954b", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -39,8 +39,8 @@ use std::collections::BTreeMap;\n use std::fmt;\n use crate::util::nodemap::FxHashSet;\n \n-/// The TypeFoldable trait is implemented for every type that can be folded.\n-/// Basically, every type that has a corresponding method in TypeFolder.\n+/// This trait is implemented for every type that can be folded.\n+/// Basically, every type that has a corresponding method in `TypeFolder`.\n ///\n /// To implement this conveniently, use the\n /// `BraceStructTypeFoldableImpl` etc macros found in `macros.rs`."}, {"sha": "63cc60d80aada4e682db73528e837dacac1d313d", "filename": "src/librustc/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,20 +4,20 @@ use rustc::hir::CRATE_HIR_ID;\n use crate::ty::context::TyCtxt;\n use crate::ty::{DefId, DefIdTree};\n \n-/// Represents a forest of DefIds closed under the ancestor relation. That is,\n-/// if a DefId representing a module is contained in the forest then all\n-/// DefIds defined in that module or submodules are also implicitly contained\n+/// Represents a forest of `DefId`s closed under the ancestor relation. That is,\n+/// if a `DefId` representing a module is contained in the forest then all\n+/// `DefId`s defined in that module or submodules are also implicitly contained\n /// in the forest.\n ///\n /// This is used to represent a set of modules in which a type is visibly\n /// uninhabited.\n #[derive(Clone)]\n pub struct DefIdForest {\n-    /// The minimal set of DefIds required to represent the whole set.\n-    /// If A and B are DefIds in the DefIdForest, and A is a descendant\n-    /// of B, then only B will be in root_ids.\n-    /// We use a SmallVec here because (for its use for caching inhabitedness)\n-    /// its rare that this will contain even two ids.\n+    /// The minimal set of `DefId`s required to represent the whole set.\n+    /// If A and B are DefIds in the `DefIdForest`, and A is a descendant\n+    /// of B, then only B will be in `root_ids`.\n+    /// We use a `SmallVec` here because (for its use for caching inhabitedness)\n+    /// its rare that this will contain even two IDs.\n     root_ids: SmallVec<[DefId; 1]>,\n }\n \n@@ -37,7 +37,7 @@ impl<'tcx> DefIdForest {\n         DefIdForest::from_id(crate_id)\n     }\n \n-    /// Creates a forest containing a DefId and all its descendants.\n+    /// Creates a forest containing a `DefId` and all its descendants.\n     pub fn from_id(id: DefId) -> DefIdForest {\n         let mut root_ids = SmallVec::new();\n         root_ids.push(id);"}, {"sha": "1a0e3517338773209352e43f4f282800ebc41c2b", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,16 +1,16 @@\n+pub use self::def_id_forest::DefIdForest;\n+\n use crate::ty::context::TyCtxt;\n use crate::ty::{AdtDef, VariantDef, FieldDef, Ty, TyS};\n use crate::ty::{DefId, SubstsRef};\n use crate::ty::{AdtKind, Visibility};\n use crate::ty::TyKind::*;\n use crate::ty;\n \n-pub use self::def_id_forest::DefIdForest;\n-\n mod def_id_forest;\n \n-// The methods in this module calculate DefIdForests of modules in which a\n-// AdtDef/VariantDef/FieldDef is visibly uninhabited.\n+// The methods in this module calculate `DefIdForest`s of modules in which a\n+// `AdtDef`/`VariantDef`/`FieldDef` is visibly uninhabited.\n //\n // # Example\n // ```rust\n@@ -36,24 +36,25 @@ mod def_id_forest;\n //     y: c::AlsoSecretlyUninhabited,\n // }\n // ```\n-// In this code, the type Foo will only be visibly uninhabited inside the\n-// modules b, c and d. Calling uninhabited_from on Foo or its AdtDef will\n-// return the forest of modules {b, c->d} (represented in a DefIdForest by the\n-// set {b, c})\n+// In this code, the type `Foo` will only be visibly uninhabited inside the\n+// modules `b`, `c` and `d`. Calling `uninhabited_from` on `Foo` or its `AdtDef` will\n+// return the forest of modules {`b`, `c`->`d`} (represented in a `DefIdForest` by the\n+// set {`b`, `c`}).\n //\n-// We need this information for pattern-matching on Foo or types that contain\n-// Foo.\n+// We need this information for pattern-matching on `Foo` or types that contain\n+// `Foo`.\n //\n // # Example\n // ```rust\n // let foo_result: Result<T, Foo> = ... ;\n // let Ok(t) = foo_result;\n // ```\n-// This code should only compile in modules where the uninhabitedness of Foo is\n+// This code should only compile in modules where the uninhabitedness of `Foo` is\n // visible.\n \n impl<'tcx> TyCtxt<'tcx> {\n     /// Checks whether a type is visibly uninhabited from a particular module.\n+    ///\n     /// # Example\n     /// ```rust\n     /// enum Void {}\n@@ -91,7 +92,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// visible.\n     pub fn is_ty_uninhabited_from(self, module: DefId, ty: Ty<'tcx>) -> bool {\n         // To check whether this type is uninhabited at all (not just from the\n-        // given node) you could check whether the forest is empty.\n+        // given node), you could check whether the forest is empty.\n         // ```\n         // forest.is_empty()\n         // ```\n@@ -108,7 +109,7 @@ impl<'tcx> TyCtxt<'tcx> {\n }\n \n impl<'tcx> AdtDef {\n-    /// Calculate the forest of DefIds from which this adt is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this ADT is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>, substs: SubstsRef<'tcx>) -> DefIdForest {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n@@ -122,7 +123,7 @@ impl<'tcx> AdtDef {\n }\n \n impl<'tcx> VariantDef {\n-    /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this variant is visibly uninhabited.\n     pub fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -148,7 +149,7 @@ impl<'tcx> VariantDef {\n }\n \n impl<'tcx> FieldDef {\n-    /// Calculate the forest of DefIds from which this field is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this field is visibly uninhabited.\n     fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -159,7 +160,7 @@ impl<'tcx> FieldDef {\n             self.ty(tcx, substs).uninhabited_from(tcx)\n         };\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n-        // Visibility::Invisible so we need to override self.vis if we're\n+        // `Visibility::Invisible` so we need to override `self.vis` if we're\n         // dealing with an enum.\n         if is_enum {\n             data_uninhabitedness()\n@@ -178,7 +179,7 @@ impl<'tcx> FieldDef {\n }\n \n impl<'tcx> TyS<'tcx> {\n-    /// Calculate the forest of DefIds from which this type is visibly uninhabited.\n+    /// Calculates the forest of `DefId`s from which this type is visibly uninhabited.\n     fn uninhabited_from(&self, tcx: TyCtxt<'tcx>) -> DefIdForest {\n         match self.sty {\n             Adt(def, substs) => def.uninhabited_from(tcx, substs),"}, {"sha": "a26fa72f330410180080ffa6f143e1be1819e210", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -327,7 +327,7 @@ impl<'tcx> Instance<'tcx> {\n     }\n \n     pub fn resolve_drop_in_place(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> ty::Instance<'tcx> {\n-        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem);\n+        let def_id = tcx.require_lang_item(DropInPlaceFnLangItem, None);\n         let substs = tcx.intern_substs(&[ty.into()]);\n         Instance::resolve(tcx, ty::ParamEnv::reveal_all(), def_id, substs).unwrap()\n     }"}, {"sha": "e52feea1624c11e3b5f1912f8a199e0105483ccc", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -127,6 +127,7 @@ impl IntegerExt for Integer {\n \n pub trait PrimitiveExt {\n     fn to_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n+    fn to_int_ty<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n impl PrimitiveExt for Primitive {\n@@ -138,6 +139,16 @@ impl PrimitiveExt for Primitive {\n             Pointer => tcx.mk_mut_ptr(tcx.mk_unit()),\n         }\n     }\n+\n+    /// Return an *integer* type matching this primitive.\n+    /// Useful in particular when dealing with enum discriminants.\n+    fn to_int_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match *self {\n+            Int(i, signed) => i.to_ty(tcx, signed),\n+            Pointer => tcx.types.usize,\n+            Float(..) => bug!(\"floats do not have an int type\"),\n+        }\n+    }\n }\n \n /// The first half of a fat pointer.\n@@ -273,14 +284,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                              repr: &ReprOptions,\n                              kind: StructKind) -> Result<LayoutDetails, LayoutError<'tcx>> {\n         let dl = self.data_layout();\n-        let packed = repr.packed();\n-        if packed && repr.align > 0 {\n+        let pack = repr.pack;\n+        if pack.is_some() && repr.align.is_some() {\n             bug!(\"struct cannot be packed and aligned\");\n         }\n \n-        let pack = Align::from_bytes(repr.pack as u64).unwrap();\n-\n-        let mut align = if packed {\n+        let mut align = if pack.is_some() {\n             dl.i8_align\n         } else {\n             dl.aggregate_align\n@@ -303,7 +312,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             };\n             let optimizing = &mut inverse_memory_index[..end];\n             let field_align = |f: &TyLayout<'_>| {\n-                if packed { f.align.abi.min(pack) } else { f.align.abi }\n+                if let Some(pack) = pack { f.align.abi.min(pack) } else { f.align.abi }\n             };\n             match kind {\n                 StructKind::AlwaysSized |\n@@ -334,7 +343,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         let mut largest_niche_available = 0;\n \n         if let StructKind::Prefixed(prefix_size, prefix_align) = kind {\n-            let prefix_align = if packed {\n+            let prefix_align = if let Some(pack) = pack {\n                 prefix_align.min(pack)\n             } else {\n                 prefix_align\n@@ -355,7 +364,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n             }\n \n             // Invariant: offset < dl.obj_size_bound() <= 1<<61\n-            let field_align = if packed {\n+            let field_align = if let Some(pack) = pack {\n                 field.align.min(AbiAndPrefAlign::new(pack))\n             } else {\n                 field.align\n@@ -379,10 +388,8 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 .ok_or(LayoutError::SizeOverflow(ty))?;\n         }\n \n-        if repr.align > 0 {\n-            let repr_align = repr.align as u64;\n-            align = align.max(AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n-            debug!(\"univariant repr_align: {:?}\", repr_align);\n+        if let Some(repr_align) = repr.align {\n+            align = align.max(AbiAndPrefAlign::new(repr_align));\n         }\n \n         debug!(\"univariant min_size: {:?}\", offset);\n@@ -730,23 +737,18 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 }).collect::<Result<IndexVec<VariantIdx, _>, _>>()?;\n \n                 if def.is_union() {\n-                    let packed = def.repr.packed();\n-                    if packed && def.repr.align > 0 {\n-                        bug!(\"Union cannot be packed and aligned\");\n+                    if def.repr.pack.is_some() && def.repr.align.is_some() {\n+                        bug!(\"union cannot be packed and aligned\");\n                     }\n \n-                    let pack = Align::from_bytes(def.repr.pack as u64).unwrap();\n-\n-                    let mut align = if packed {\n+                    let mut align = if def.repr.pack.is_some() {\n                         dl.i8_align\n                     } else {\n                         dl.aggregate_align\n                     };\n \n-                    if def.repr.align > 0 {\n-                        let repr_align = def.repr.align as u64;\n-                        align = align.max(\n-                            AbiAndPrefAlign::new(Align::from_bytes(repr_align).unwrap()));\n+                    if let Some(repr_align) = def.repr.align {\n+                        align = align.max(AbiAndPrefAlign::new(repr_align));\n                     }\n \n                     let optimize = !def.repr.inhibit_union_abi_opt();\n@@ -755,13 +757,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     let index = VariantIdx::new(0);\n                     for field in &variants[index] {\n                         assert!(!field.is_unsized());\n-\n-                        let field_align = if packed {\n-                            field.align.min(AbiAndPrefAlign::new(pack))\n-                        } else {\n-                            field.align\n-                        };\n-                        align = align.max(field_align);\n+                        align = align.max(field.align);\n \n                         // If all non-ZST fields have the same ABI, forward this ABI\n                         if optimize && !field.is_zst() {\n@@ -796,6 +792,10 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                         size = cmp::max(size, field.size);\n                     }\n \n+                    if let Some(pack) = def.repr.pack {\n+                        align = align.min(AbiAndPrefAlign::new(pack));\n+                    }\n+\n                     return Ok(tcx.intern_layout(LayoutDetails {\n                         variants: Variants::Single { index },\n                         fields: FieldPlacement::Union(variants[index].len()),\n@@ -1637,7 +1637,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         };\n \n         let adt_kind = adt_def.adt_kind();\n-        let adt_packed = adt_def.repr.packed();\n+        let adt_packed = adt_def.repr.pack.is_some();\n \n         let build_variant_info = |n: Option<Ident>,\n                                   flds: &[ast::Name],"}, {"sha": "8bb9648e031ef5e98c4979fd8c234ded1303939d", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -33,6 +33,7 @@ use arena::SyncDroplessArena;\n use crate::session::DataTypeKind;\n \n use rustc_serialize::{self, Encodable, Encoder};\n+use rustc_target::abi::Align;\n use std::cell::RefCell;\n use std::cmp::{self, Ordering};\n use std::fmt;\n@@ -45,7 +46,7 @@ use std::ops::Range;\n use syntax::ast::{self, Name, Ident, NodeId};\n use syntax::attr;\n use syntax::ext::hygiene::ExpnId;\n-use syntax::symbol::{kw, sym, Symbol, LocalInternedString, InternedString};\n+use syntax::symbol::{kw, sym, Symbol, InternedString};\n use syntax_pos::Span;\n \n use smallvec;\n@@ -580,6 +581,7 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for ty::TyS<'tcx> {\n     }\n }\n \n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"Ty\")]\n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n impl<'tcx> rustc_serialize::UseSpecializedEncodable for Ty<'tcx> {}\n@@ -588,7 +590,7 @@ impl<'tcx> rustc_serialize::UseSpecializedDecodable for Ty<'tcx> {}\n pub type CanonicalTy<'tcx> = Canonical<'tcx, Ty<'tcx>>;\n \n extern {\n-    /// A dummy type used to force List to by unsized without requiring fat pointers\n+    /// A dummy type used to force `List` to by unsized without requiring fat pointers.\n     type OpaqueListContents;\n }\n \n@@ -1936,9 +1938,15 @@ pub struct FieldDef {\n     pub vis: Visibility,\n }\n \n-/// The definition of an abstract data type -- a struct or enum.\n+/// The definition of a user-defined type, e.g., a `struct`, `enum`, or `union`.\n ///\n /// These are all interned (by `intern_adt_def`) into the `adt_defs` table.\n+///\n+/// The initialism *\"Adt\"* stands for an [*algebraic data type (ADT)*][adt].\n+/// This is slightly wrong because `union`s are not ADTs.\n+/// Moreover, Rust only allows recursive data types through indirection.\n+///\n+/// [adt]: https://en.wikipedia.org/wiki/Algebraic_data_type\n pub struct AdtDef {\n     /// `DefId` of the struct, enum or union item.\n     pub did: DefId,\n@@ -2057,8 +2065,8 @@ impl_stable_hash_for!(struct ReprFlags {\n #[derive(Copy, Clone, Debug, Eq, PartialEq, RustcEncodable, RustcDecodable, Default)]\n pub struct ReprOptions {\n     pub int: Option<attr::IntType>,\n-    pub align: u32,\n-    pub pack: u32,\n+    pub align: Option<Align>,\n+    pub pack: Option<Align>,\n     pub flags: ReprFlags,\n }\n \n@@ -2073,18 +2081,19 @@ impl ReprOptions {\n     pub fn new(tcx: TyCtxt<'_>, did: DefId) -> ReprOptions {\n         let mut flags = ReprFlags::empty();\n         let mut size = None;\n-        let mut max_align = 0;\n-        let mut min_pack = 0;\n+        let mut max_align: Option<Align> = None;\n+        let mut min_pack: Option<Align> = None;\n         for attr in tcx.get_attrs(did).iter() {\n             for r in attr::find_repr_attrs(&tcx.sess.parse_sess, attr) {\n                 flags.insert(match r {\n                     attr::ReprC => ReprFlags::IS_C,\n                     attr::ReprPacked(pack) => {\n-                        min_pack = if min_pack > 0 {\n-                            cmp::min(pack, min_pack)\n+                        let pack = Align::from_bytes(pack as u64).unwrap();\n+                        min_pack = Some(if let Some(min_pack) = min_pack {\n+                            min_pack.min(pack)\n                         } else {\n                             pack\n-                        };\n+                        });\n                         ReprFlags::empty()\n                     },\n                     attr::ReprTransparent => ReprFlags::IS_TRANSPARENT,\n@@ -2094,7 +2103,7 @@ impl ReprOptions {\n                         ReprFlags::empty()\n                     },\n                     attr::ReprAlign(align) => {\n-                        max_align = cmp::max(align, max_align);\n+                        max_align = max_align.max(Some(Align::from_bytes(align as u64).unwrap()));\n                         ReprFlags::empty()\n                     },\n                 });\n@@ -2113,7 +2122,7 @@ impl ReprOptions {\n     #[inline]\n     pub fn c(&self) -> bool { self.flags.contains(ReprFlags::IS_C) }\n     #[inline]\n-    pub fn packed(&self) -> bool { self.pack > 0 }\n+    pub fn packed(&self) -> bool { self.pack.is_some() }\n     #[inline]\n     pub fn transparent(&self) -> bool { self.flags.contains(ReprFlags::IS_TRANSPARENT) }\n     #[inline]\n@@ -2133,8 +2142,12 @@ impl ReprOptions {\n     /// Returns `true` if this `#[repr()]` should inhibit struct field reordering\n     /// optimizations, such as with `repr(C)`, `repr(packed(1))`, or `repr(<int>)`.\n     pub fn inhibit_struct_field_reordering_opt(&self) -> bool {\n-        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.pack == 1 ||\n-            self.int.is_some()\n+        if let Some(pack) = self.pack {\n+            if pack.bytes() == 1 {\n+                return true;\n+            }\n+        }\n+        self.flags.intersects(ReprFlags::IS_UNOPTIMISABLE) || self.int.is_some()\n     }\n \n     /// Returns `true` if this `#[repr()]` should inhibit union ABI optimisations.\n@@ -2588,12 +2601,12 @@ impl<'tcx> ClosureKind {\n \n     pub fn trait_did(&self, tcx: TyCtxt<'tcx>) -> DefId {\n         match *self {\n-            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem),\n+            ClosureKind::Fn => tcx.require_lang_item(FnTraitLangItem, None),\n             ClosureKind::FnMut => {\n-                tcx.require_lang_item(FnMutTraitLangItem)\n+                tcx.require_lang_item(FnMutTraitLangItem, None)\n             }\n             ClosureKind::FnOnce => {\n-                tcx.require_lang_item(FnOnceTraitLangItem)\n+                tcx.require_lang_item(FnOnceTraitLangItem, None)\n             }\n         }\n     }\n@@ -2784,6 +2797,10 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n+    pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n+        self.hir().as_local_hir_id(def_id).and_then(|hir_id| self.hir().get(hir_id).ident())\n+    }\n+\n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssocItem> {\n         let is_associated_item = if let Some(hir_id) = self.hir().as_local_hir_id(def_id) {\n             match self.hir().get(hir_id) {\n@@ -2887,6 +2904,13 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn impls_are_allowed_to_overlap(self, def_id1: DefId, def_id2: DefId)\n                                         -> Option<ImplOverlapKind>\n     {\n+        // If either trait impl references an error, they're allowed to overlap,\n+        // as one of them essentially doesn't exist.\n+        if self.impl_trait_ref(def_id1).map_or(false, |tr| tr.references_error()) ||\n+            self.impl_trait_ref(def_id2).map_or(false, |tr| tr.references_error()) {\n+            return Some(ImplOverlapKind::Permitted);\n+        }\n+\n         let is_legit = if self.features().overlapping_marker_traits {\n             let trait1_is_empty = self.impl_trait_ref(def_id1)\n                 .map_or(false, |trait_ref| {\n@@ -3379,10 +3403,6 @@ impl SymbolName {\n             name: InternedString::intern(name)\n         }\n     }\n-\n-    pub fn as_str(&self) -> LocalInternedString {\n-        self.name.as_str()\n-    }\n }\n \n impl fmt::Display for SymbolName {"}, {"sha": "50789bf6213b6ffd23d1e8a93e18b0a93e89d46e", "filename": "src/librustc/ty/print/mod.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -27,7 +27,8 @@ pub trait Print<'tcx, P> {\n /// which the associated types allow passing through the methods.\n ///\n /// For pretty-printing/formatting in particular, see `PrettyPrinter`.\n-// FIXME(eddyb) find a better name, this is more general than \"printing\".\n+//\n+// FIXME(eddyb) find a better name; this is more general than \"printing\".\n pub trait Printer<'tcx>: Sized {\n     type Error;\n \n@@ -46,6 +47,7 @@ pub trait Printer<'tcx>: Sized {\n     ) -> Result<Self::Path, Self::Error> {\n         self.default_print_def_path(def_id, substs)\n     }\n+\n     fn print_impl_path(\n         self,\n         impl_def_id: DefId,\n@@ -80,6 +82,7 @@ pub trait Printer<'tcx>: Sized {\n         self,\n         cnum: CrateNum,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_qualified(\n         self,\n         self_ty: Ty<'tcx>,\n@@ -93,11 +96,13 @@ pub trait Printer<'tcx>: Sized {\n         self_ty: Ty<'tcx>,\n         trait_ref: Option<ty::TraitRef<'tcx>>,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_append(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n         disambiguated_data: &DisambiguatedDefPathData,\n     ) -> Result<Self::Path, Self::Error>;\n+\n     fn path_generic_args(\n         self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "d99580116e4ae30fe0394c12a012a0566c581d39", "filename": "src/librustc/ty/print/pretty.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint%2Fpretty.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -8,10 +8,11 @@ use crate::ty::{self, DefIdTree, ParamConst, Ty, TyCtxt, TypeFoldable};\n use crate::ty::subst::{Kind, Subst, UnpackedKind};\n use crate::ty::layout::{Integer, IntegerExt, Size};\n use crate::mir::interpret::{ConstValue, sign_extend, Scalar, truncate};\n-use syntax::ast;\n+\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc_target::spec::abi::Abi;\n+use syntax::ast;\n use syntax::attr::{SignedInt, UnsignedInt};\n use syntax::symbol::{kw, InternedString};\n \n@@ -194,7 +195,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.skip_binder().print(self)\n     }\n \n-    /// Print comma-separated elements.\n+    /// Prints comma-separated elements.\n     fn comma_sep<T>(mut self, mut elems: impl Iterator<Item = T>) -> Result<Self, Self::Error>\n     where\n         T: Print<'tcx, Self, Output = Self, Error = Self::Error>,\n@@ -209,14 +210,14 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n-    /// Print `<...>` around what `f` prints.\n+    /// Prints `<...>` around what `f` prints.\n     fn generic_delimiters(\n         self,\n         f: impl FnOnce(Self) -> Result<Self, Self::Error>,\n     ) -> Result<Self, Self::Error>;\n \n-    /// Return `true` if the region should be printed in\n-    /// optional positions, e.g. `&'a T` or `dyn Tr + 'b`.\n+    /// Returns `true` if the region should be printed in\n+    /// optional positions, e.g., `&'a T` or `dyn Tr + 'b`.\n     /// This is typically the case for all non-`'_` regions.\n     fn region_should_not_be_omitted(\n         &self,\n@@ -226,7 +227,7 @@ pub trait PrettyPrinter<'tcx>:\n     // Defaults (should not be overriden):\n \n     /// If possible, this returns a global path resolving to `def_id` that is visible\n-    /// from at least one local module and returns true. If the crate defining `def_id` is\n+    /// from at least one local module, and returns `true`. If the crate defining `def_id` is\n     /// declared with an `extern crate`, the path is guaranteed to use the `extern crate`.\n     fn try_print_visible_def_path(\n         self,\n@@ -267,11 +268,11 @@ pub trait PrettyPrinter<'tcx>:\n             // In local mode, when we encounter a crate other than\n             // LOCAL_CRATE, execution proceeds in one of two ways:\n             //\n-            // 1. for a direct dependency, where user added an\n+            // 1. For a direct dependency, where user added an\n             //    `extern crate` manually, we put the `extern\n             //    crate` as the parent. So you wind up with\n             //    something relative to the current crate.\n-            // 2. for an extern inferred from a path or an indirect crate,\n+            // 2. For an extern inferred from a path or an indirect crate,\n             //    where there is no explicit `extern crate`, we just prepend\n             //    the crate name.\n             match self.tcx().extern_crate(def_id) {\n@@ -304,13 +305,13 @@ pub trait PrettyPrinter<'tcx>:\n         let mut cur_def_key = self.tcx().def_key(def_id);\n         debug!(\"try_print_visible_def_path: cur_def_key={:?}\", cur_def_key);\n \n-        // For a constructor we want the name of its parent rather than <unnamed>.\n+        // For a constructor, we want the name of its parent rather than <unnamed>.\n         match cur_def_key.disambiguated_data.data {\n             DefPathData::Ctor => {\n                 let parent = DefId {\n                     krate: def_id.krate,\n                     index: cur_def_key.parent\n-                        .expect(\"DefPathData::Ctor/VariantData missing a parent\"),\n+                        .expect(\"`DefPathData::Ctor` / `VariantData` missing a parent\"),\n                 };\n \n                 cur_def_key = self.tcx().def_key(parent);\n@@ -630,7 +631,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -673,7 +674,7 @@ pub trait PrettyPrinter<'tcx>:\n                         sep = \", \";\n                     }\n                 } else {\n-                    // cross-crate closure types should only be\n+                    // Cross-crate closure types should only be\n                     // visible in codegen bug reports, I imagine.\n                     p!(write(\"@{:?}\", did));\n                     let mut sep = \" \";\n@@ -944,10 +945,16 @@ pub trait PrettyPrinter<'tcx>:\n                         .get_bytes(&self.tcx(), ptr, Size::from_bytes(n)).unwrap())\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Slice(t)) if *t == u8 => {\n-                    Some(&data.bytes[start..end])\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active slice reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    Some(data.inspect_with_undef_and_ptr_outside_interpreter(start..end))\n                 },\n                 (ConstValue::Slice { data, start, end }, ty::Str) => {\n-                    let slice = &data.bytes[start..end];\n+                    // The `inspect` here is okay since we checked the bounds, and there are no\n+                    // relocations (we have an active `str` reference here). We don't use this\n+                    // result to affect interpreter execution.\n+                    let slice = data.inspect_with_undef_and_ptr_outside_interpreter(start..end);\n                     let s = ::std::str::from_utf8(slice)\n                         .expect(\"non utf8 str from miri\");\n                     p!(write(\"{:?}\", s));\n@@ -1167,6 +1174,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         }\n         Ok(self)\n     }\n+\n     fn path_qualified(\n         mut self,\n         self_ty: Ty<'tcx>,\n@@ -1195,6 +1203,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n         self.empty_path = false;\n         Ok(self)\n     }\n+\n     fn path_append(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,\n@@ -1232,6 +1241,7 @@ impl<F: fmt::Write> Printer<'tcx> for FmtPrinter<'_, 'tcx, F> {\n \n         Ok(self)\n     }\n+\n     fn path_generic_args(\n         mut self,\n         print_prefix: impl FnOnce(Self) -> Result<Self::Path, Self::Error>,"}, {"sha": "c20e75868895991ac0871d418955a43f5c2204e6", "filename": "src/librustc/ty/query/on_disk_cache.rs", "status": "modified", "additions": 135, "deletions": 117, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,9 +5,6 @@ use crate::hir::map::definitions::DefPathHash;\n use crate::ich::{CachingSourceMapView, Fingerprint};\n use crate::mir::{self, interpret};\n use crate::mir::interpret::{AllocDecodingSession, AllocDecodingState};\n-use rustc_serialize::{Decodable, Decoder, Encodable, Encoder, opaque,\n-                      SpecializedDecoder, SpecializedEncoder,\n-                      UseSpecializedDecodable, UseSpecializedEncodable};\n use crate::session::{CrateDisambiguator, Session};\n use crate::ty::{self, Ty};\n use crate::ty::codec::{self as ty_codec, TyDecoder, TyEncoder};\n@@ -19,11 +16,15 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::thin_vec::ThinVec;\n use rustc_data_structures::sync::{Lrc, Lock, HashMapExt, Once};\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use rustc_serialize::{\n+    Decodable, Decoder, Encodable, Encoder, SpecializedDecoder, SpecializedEncoder,\n+    UseSpecializedDecodable, UseSpecializedEncodable, opaque,\n+};\n use std::mem;\n-use syntax::ast::NodeId;\n+use syntax::ast::{Ident, NodeId};\n use syntax::source_map::{SourceMap, StableSourceFileId};\n use syntax_pos::{BytePos, Span, DUMMY_SP, SourceFile};\n-use syntax_pos::hygiene::{ExpnId, SyntaxContext, ExpnData};\n+use syntax_pos::hygiene::{ExpnId, SyntaxContext};\n \n const TAG_FILE_FOOTER: u128 = 0xC0FFEE_C0FFEE_C0FFEE_C0FFEE_C0FFEE;\n \n@@ -37,17 +38,16 @@ const TAG_EXPN_DATA_INLINE: u8 = 2;\n const TAG_VALID_SPAN: u8 = 0;\n const TAG_INVALID_SPAN: u8 = 1;\n \n-/// `OnDiskCache` provides an interface to incr. comp. data cached from the\n+/// Provides an interface to incremental compilation data cached from the\n /// previous compilation session. This data will eventually include the results\n /// of a few selected queries (like `typeck_tables_of` and `mir_optimized`) and\n /// any diagnostics that have been emitted during a query.\n pub struct OnDiskCache<'sess> {\n-\n     // The complete cache data in serialized form.\n     serialized_data: Vec<u8>,\n \n-    // This field collects all Diagnostics emitted during the current\n-    // compilation session.\n+    // Collects all `Diagnostic`s emitted during the current compilation\n+    // session.\n     current_diagnostics: Lock<FxHashMap<DepNodeIndex, Vec<Diagnostic>>>,\n \n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n@@ -56,7 +56,7 @@ pub struct OnDiskCache<'sess> {\n     source_map: &'sess SourceMap,\n     file_index_to_stable_id: FxHashMap<SourceFileIndex, StableSourceFileId>,\n \n-    // These two fields caches that are populated lazily during decoding.\n+    // Caches that are populated lazily during decoding.\n     file_index_to_file: Lock<FxHashMap<SourceFileIndex, Lrc<SourceFile>>>,\n     synthetic_syntax_contexts: Lock<FxHashMap<AbsoluteBytePos, SyntaxContext>>,\n \n@@ -78,7 +78,7 @@ struct Footer {\n     prev_cnums: Vec<(u32, String, CrateDisambiguator)>,\n     query_result_index: EncodedQueryResultIndex,\n     diagnostics_index: EncodedQueryResultIndex,\n-    // the location of all allocations\n+    // The location of all allocations.\n     interpret_alloc_index: Vec<u32>,\n }\n \n@@ -104,28 +104,28 @@ impl AbsoluteBytePos {\n }\n \n impl<'sess> OnDiskCache<'sess> {\n-    /// Creates a new OnDiskCache instance from the serialized data in `data`.\n-    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> OnDiskCache<'sess> {\n+    /// Creates a new `OnDiskCache` instance from the serialized data in `data`.\n+    pub fn new(sess: &'sess Session, data: Vec<u8>, start_pos: usize) -> Self {\n         debug_assert!(sess.opts.incremental.is_some());\n \n-        // Wrapping in a scope so we can borrow `data`\n+        // Wrap in a scope so we can borrow `data`.\n         let footer: Footer = {\n             let mut decoder = opaque::Decoder::new(&data[..], start_pos);\n \n-            // Decode the *position* of the footer which can be found in the\n+            // Decode the *position* of the footer, which can be found in the\n             // last 8 bytes of the file.\n             decoder.set_position(data.len() - IntEncodedWithFixedSize::ENCODED_SIZE);\n-            let query_result_index_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n-                .expect(\"Error while trying to decode query result index position.\")\n+            let footer_pos = IntEncodedWithFixedSize::decode(&mut decoder)\n+                .expect(\"error while trying to decode footer position\")\n                 .0 as usize;\n \n-            // Decoder the file footer which contains all the lookup tables, etc.\n-            decoder.set_position(query_result_index_pos);\n+            // Decode the file footer, which contains all the lookup tables, etc.\n+            decoder.set_position(footer_pos);\n             decode_tagged(&mut decoder, TAG_FILE_FOOTER)\n-                .expect(\"Error while trying to decode query result index position.\")\n+                .expect(\"error while trying to decode footer position\")\n         };\n \n-        OnDiskCache {\n+        Self {\n             serialized_data: data,\n             file_index_to_stable_id: footer.file_index_to_stable_id,\n             file_index_to_file: Default::default(),\n@@ -140,8 +140,8 @@ impl<'sess> OnDiskCache<'sess> {\n         }\n     }\n \n-    pub fn new_empty(source_map: &'sess SourceMap) -> OnDiskCache<'sess> {\n-        OnDiskCache {\n+    pub fn new_empty(source_map: &'sess SourceMap) -> Self {\n+        Self {\n             serialized_data: Vec::new(),\n             file_index_to_stable_id: Default::default(),\n             file_index_to_file: Default::default(),\n@@ -158,11 +158,11 @@ impl<'sess> OnDiskCache<'sess> {\n \n     pub fn serialize<'tcx, E>(&self, tcx: TyCtxt<'tcx>, encoder: &mut E) -> Result<(), E::Error>\n     where\n-        E: ty_codec::TyEncoder,\n+        E: TyEncoder,\n     {\n-        // Serializing the DepGraph should not modify it:\n+        // Serializing the `DepGraph` should not modify it.\n         tcx.dep_graph.with_ignore(|| {\n-            // Allocate SourceFileIndices\n+            // Allocate `SourceFileIndex`es.\n             let (file_to_file_index, file_index_to_stable_id) = {\n                 let files = tcx.sess.source_map().files();\n                 let mut file_to_file_index = FxHashMap::with_capacity_and_hasher(\n@@ -197,7 +197,7 @@ impl<'sess> OnDiskCache<'sess> {\n             // be in memory, so this should be a cheap operation.\n             tcx.dep_graph.exec_cache_promotions(tcx);\n \n-            // Encode query results\n+            // Encode query results.\n             let mut query_result_index = EncodedQueryResultIndex::new();\n \n             time(tcx.sess, \"encode query results\", || {\n@@ -221,29 +221,28 @@ impl<'sess> OnDiskCache<'sess> {\n                 Ok(())\n             })?;\n \n-            // Encode diagnostics\n+            // Encode diagnostics.\n             let diagnostics_index: EncodedDiagnosticsIndex = self.current_diagnostics.borrow()\n                 .iter()\n-                .map(|(dep_node_index, diagnostics)|\n-            {\n-                let pos = AbsoluteBytePos::new(encoder.position());\n-                // Let's make sure we get the expected type here:\n-                let diagnostics: &EncodedDiagnostics = diagnostics;\n-                let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n-                encoder.encode_tagged(dep_node_index, diagnostics)?;\n-\n-                Ok((dep_node_index, pos))\n-            })\n-            .collect::<Result<_, _>>()?;\n+                .map(|(dep_node_index, diagnostics)| {\n+                    let pos = AbsoluteBytePos::new(encoder.position());\n+                    // Let's make sure we get the expected type here.\n+                    let diagnostics: &EncodedDiagnostics = diagnostics;\n+                    let dep_node_index = SerializedDepNodeIndex::new(dep_node_index.index());\n+                    encoder.encode_tagged(dep_node_index, diagnostics)?;\n+\n+                    Ok((dep_node_index, pos))\n+                })\n+                .collect::<Result<_, _>>()?;\n \n             let interpret_alloc_index = {\n                 let mut interpret_alloc_index = Vec::new();\n                 let mut n = 0;\n                 loop {\n                     let new_n = encoder.interpret_allocs_inverse.len();\n-                    // if we have found new ids, serialize those, too\n+                    // If we have found new IDs, serialize those too.\n                     if n == new_n {\n-                        // otherwise, abort\n+                        // Otherwise, abort.\n                         break;\n                     }\n                     interpret_alloc_index.reserve(new_n - n);\n@@ -263,13 +262,15 @@ impl<'sess> OnDiskCache<'sess> {\n             };\n \n             let sorted_cnums = sorted_cnums_including_local_crate(tcx);\n-            let prev_cnums: Vec<_> = sorted_cnums.iter().map(|&cnum| {\n-                let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n-                let crate_disambiguator = tcx.crate_disambiguator(cnum);\n-                (cnum.as_u32(), crate_name, crate_disambiguator)\n-            }).collect();\n-\n-            // Encode the file footer\n+            let prev_cnums: Vec<_> = sorted_cnums.iter()\n+                .map(|&cnum| {\n+                    let crate_name = tcx.original_crate_name(cnum).as_str().to_string();\n+                    let crate_disambiguator = tcx.crate_disambiguator(cnum);\n+                    (cnum.as_u32(), crate_name, crate_disambiguator)\n+                })\n+                .collect();\n+\n+            // Encode the file footer.\n             let footer_pos = encoder.position() as u64;\n             encoder.encode_tagged(TAG_FILE_FOOTER, &Footer {\n                 file_index_to_stable_id,\n@@ -371,7 +372,7 @@ impl<'sess> OnDiskCache<'sess> {\n     {\n         let pos = index.get(&dep_node_index).cloned()?;\n \n-        // Initialize the cnum_map using the value from the thread which finishes the closure first\n+        // Initialize `cnum_map` using the value from the thread that finishes the closure first.\n         self.cnum_map.init_nonlocking_same(|| {\n             Self::compute_cnum_map(tcx, &self.prev_cnums[..])\n         });\n@@ -381,25 +382,21 @@ impl<'sess> OnDiskCache<'sess> {\n             opaque: opaque::Decoder::new(&self.serialized_data[..], pos.to_usize()),\n             source_map: self.source_map,\n             cnum_map: self.cnum_map.get(),\n+            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             file_index_to_file: &self.file_index_to_file,\n             file_index_to_stable_id: &self.file_index_to_stable_id,\n-            synthetic_syntax_contexts: &self.synthetic_syntax_contexts,\n             alloc_decoding_session: self.alloc_decoding_state.new_decoding_session(),\n         };\n \n         match decode_tagged(&mut decoder, dep_node_index) {\n-            Ok(value) => {\n-                Some(value)\n-            }\n-            Err(e) => {\n-                bug!(\"Could not decode cached {}: {}\", debug_tag, e)\n-            }\n+            Ok(v) => Some(v),\n+            Err(e) => bug!(\"could not decode cached {}: {}\", debug_tag, e),\n         }\n     }\n \n-    // This function builds mapping from previous-session-CrateNum to\n-    // current-session-CrateNum. There might be CrateNums from the previous\n-    // Session that don't occur in the current one. For these, the mapping\n+    // This function builds mapping from previous-session-`CrateNum` to\n+    // current-session-`CrateNum`. There might be `CrateNum`s from the previous\n+    // `Session` that don't occur in the current one. For these, the mapping\n     // maps to None.\n     fn compute_cnum_map(\n         tcx: TyCtxt<'_>,\n@@ -432,9 +429,9 @@ impl<'sess> OnDiskCache<'sess> {\n \n //- DECODING -------------------------------------------------------------------\n \n-/// A decoder that can read the incr. comp. cache. It is similar to the one\n-/// we use for crate metadata decoding in that it can rebase spans and\n-/// eventually will also handle things that contain `Ty` instances.\n+/// A decoder that can read fro the incr. comp. cache. It is similar to the one\n+/// we use for crate metadata decoding in that it can rebase spans and eventually\n+/// will also handle things that contain `Ty` instances.\n struct CacheDecoder<'a, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     opaque: opaque::Decoder<'a>,\n@@ -458,7 +455,7 @@ impl<'a, 'tcx> CacheDecoder<'a, 'tcx> {\n         file_index_to_file.borrow_mut().entry(index).or_insert_with(|| {\n             let stable_id = file_index_to_stable_id[&index];\n             source_map.source_file_by_stable_id(stable_id)\n-                .expect(\"Failed to lookup SourceFile in new context.\")\n+                .expect(\"failed to lookup `SourceFile` in new context\")\n         }).clone()\n     }\n }\n@@ -479,7 +476,7 @@ impl<'a, 'tcx> DecoderWithPosition for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// Decode something that was encoded with encode_tagged() and verify that the\n+// Decodes something that was encoded with `encode_tagged()` and verify that the\n // tag matches and the correct amount of bytes was read.\n fn decode_tagged<D, T, V>(decoder: &mut D, expected_tag: T) -> Result<V, D::Error>\n where\n@@ -500,7 +497,7 @@ where\n     Ok(value)\n }\n \n-impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n+impl<'a, 'tcx> TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn tcx(&self) -> TyCtxt<'tcx> {\n         self.tcx\n@@ -534,7 +531,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n         }\n \n         let ty = or_insert_with(self)?;\n-        // This may overwrite the entry, but it should overwrite with the same value\n+        // This may overwrite the entry, but it should overwrite with the same value.\n         tcx.rcache.borrow_mut().insert_same(cache_key, ty);\n         Ok(ty)\n     }\n@@ -553,7 +550,7 @@ impl<'a, 'tcx> ty_codec::TyDecoder<'tcx> for CacheDecoder<'a, 'tcx> {\n \n     fn map_encoded_cnum_to_current(&self, cnum: CrateNum) -> CrateNum {\n         self.cnum_map[cnum].unwrap_or_else(|| {\n-            bug!(\"Could not find new CrateNum for {:?}\", cnum)\n+            bug!(\"could not find new `CrateNum` for {:?}\", cnum)\n         })\n     }\n }\n@@ -591,10 +588,11 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n         // FIXME(mw): This method does not restore `ExpnData::parent` or\n         // `SyntaxContextData::prev_ctxt` or `SyntaxContextData::opaque`. These things\n         // don't seem to be used after HIR lowering, so everything should be fine\n-        // as long as incremental compilation does not kick in before that.\n+        // until we want incremental compilation to serialize Spans that we need\n+        // full hygiene information for.\n         let location = || Span::with_root_ctxt(lo, hi);\n-        let recover_from_expn_data = |this: &Self, expn_data, pos| {\n-            let span = location().fresh_expansion(expn_data);\n+        let recover_from_expn_data = |this: &Self, expn_data, transparency, pos| {\n+            let span = location().fresh_expansion_with_transparency(expn_data, transparency);\n             this.synthetic_syntax_contexts.borrow_mut().insert(pos, span.ctxt());\n             span\n         };\n@@ -603,9 +601,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 location()\n             }\n             TAG_EXPN_DATA_INLINE => {\n-                let expn_data = Decodable::decode(self)?;\n+                let (expn_data, transparency) = Decodable::decode(self)?;\n                 recover_from_expn_data(\n-                    self, expn_data, AbsoluteBytePos::new(self.opaque.position())\n+                    self, expn_data, transparency, AbsoluteBytePos::new(self.opaque.position())\n                 )\n             }\n             TAG_EXPN_DATA_SHORTHAND => {\n@@ -614,9 +612,9 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n                 if let Some(ctxt) = cached_ctxt {\n                     Span::new(lo, hi, ctxt)\n                 } else {\n-                    let expn_data =\n-                        self.with_position(pos.to_usize(), |this| ExpnData::decode(this))?;\n-                    recover_from_expn_data(self, expn_data, pos)\n+                    let (expn_data, transparency) =\n+                        self.with_position(pos.to_usize(), |this| Decodable::decode(this))?;\n+                    recover_from_expn_data(self, expn_data, transparency, pos)\n                 }\n             }\n             _ => {\n@@ -626,26 +624,33 @@ impl<'a, 'tcx> SpecializedDecoder<Span> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n+impl<'a, 'tcx> SpecializedDecoder<Ident> for CacheDecoder<'a, 'tcx> {\n+    fn specialized_decode(&mut self) -> Result<Ident, Self::Error> {\n+        // FIXME: Handle hygiene in incremental\n+        bug!(\"Trying to decode Ident for incremental\");\n+    }\n+}\n+\n // This impl makes sure that we get a runtime error when we try decode a\n-// DefIndex that is not contained in a DefId. Such a case would be problematic\n-// because we would not know how to transform the DefIndex to the current\n+// `DefIndex` that is not contained in a `DefId`. Such a case would be problematic\n+// because we would not know how to transform the `DefIndex` to the current\n // context.\n impl<'a, 'tcx> SpecializedDecoder<DefIndex> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<DefIndex, Self::Error> {\n-        bug!(\"Trying to decode DefIndex outside the context of a DefId\")\n+        bug!(\"trying to decode `DefIndex` outside the context of a `DefId`\")\n     }\n }\n \n-// Both the CrateNum and the DefIndex of a DefId can change in between two\n-// compilation sessions. We use the DefPathHash, which is stable across\n-// sessions, to map the old DefId to the new one.\n+// Both the `CrateNum` and the `DefIndex` of a `DefId` can change in between two\n+// compilation sessions. We use the `DefPathHash`, which is stable across\n+// sessions, to map the old `DefId` to the new one.\n impl<'a, 'tcx> SpecializedDecoder<DefId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<DefId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefId as.\n+        // Load the `DefPathHash` which is was we encoded the `DefId` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Using the DefPathHash, we can lookup the new DefId\n+        // Using the `DefPathHash`, we can lookup the new `DefId`.\n         Ok(self.tcx().def_path_hash_to_def_id.as_ref().unwrap()[&def_path_hash])\n     }\n }\n@@ -659,21 +664,21 @@ impl<'a, 'tcx> SpecializedDecoder<LocalDefId> for CacheDecoder<'a, 'tcx> {\n \n impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     fn specialized_decode(&mut self) -> Result<hir::HirId, Self::Error> {\n-        // Load the DefPathHash which is was we encoded the DefIndex as.\n+        // Load the `DefPathHash` which is what we encoded the `DefIndex` as.\n         let def_path_hash = DefPathHash::decode(self)?;\n \n-        // Use the DefPathHash to map to the current DefId.\n+        // Use the `DefPathHash` to map to the current `DefId`.\n         let def_id = self.tcx()\n                          .def_path_hash_to_def_id\n                          .as_ref()\n                          .unwrap()[&def_path_hash];\n \n         debug_assert!(def_id.is_local());\n \n-        // The ItemLocalId needs no remapping.\n+        // The `ItemLocalId` needs no remapping.\n         let local_id = hir::ItemLocalId::decode(self)?;\n \n-        // Reconstruct the HirId and look up the corresponding NodeId in the\n+        // Reconstruct the `HirId` and look up the corresponding `NodeId` in the\n         // context of the current session.\n         Ok(hir::HirId {\n             owner: def_id.index,\n@@ -682,8 +687,8 @@ impl<'a, 'tcx> SpecializedDecoder<hir::HirId> for CacheDecoder<'a, 'tcx> {\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx> SpecializedDecoder<NodeId> for CacheDecoder<'a, 'tcx> {\n     #[inline]\n     fn specialized_decode(&mut self) -> Result<NodeId, Self::Error> {\n@@ -720,6 +725,7 @@ impl<'a, 'tcx, T: Decodable> SpecializedDecoder<mir::ClearCrossCrate<T>>\n \n //- ENCODING -------------------------------------------------------------------\n \n+/// An encoder that can write the incr. comp. cache.\n struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n@@ -734,7 +740,7 @@ struct CacheEncoder<'a, 'tcx, E: ty_codec::TyEncoder> {\n \n impl<'a, 'tcx, E> CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn source_file_index(&mut self, source_file: Lrc<SourceFile>) -> SourceFileIndex {\n         self.file_to_file_index[&(&*source_file as *const SourceFile)]\n@@ -745,11 +751,11 @@ where\n     /// encode the specified tag, then the given value, then the number of\n     /// bytes taken up by tag and value. On decoding, we can then verify that\n     /// we get the expected tag and read the expected number of bytes.\n-    fn encode_tagged<T: Encodable, V: Encodable>(&mut self,\n-                                                 tag: T,\n-                                                 value: &V)\n-                                                 -> Result<(), E::Error>\n-    {\n+    fn encode_tagged<T: Encodable, V: Encodable>(\n+        &mut self,\n+        tag: T,\n+        value: &V\n+    ) -> Result<(), E::Error> {\n         let start_pos = self.position();\n \n         tag.encode(self)?;\n@@ -762,7 +768,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<interpret::AllocId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n         use std::collections::hash_map::Entry;\n@@ -782,10 +788,9 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Span> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, span: &Span) -> Result<(), Self::Error> {\n-\n         if *span == DUMMY_SP {\n             return TAG_INVALID_SPAN.encode(self);\n         }\n@@ -819,23 +824,36 @@ where\n         if span_data.ctxt == SyntaxContext::root() {\n             TAG_NO_EXPN_DATA.encode(self)\n         } else {\n-            let (expn_id, expn_data) = span_data.ctxt.outer_expn_with_data();\n+            let (expn_id, transparency, expn_data) = span_data.ctxt.outer_mark_with_data();\n             if let Some(pos) = self.expn_data_shorthands.get(&expn_id).cloned() {\n                 TAG_EXPN_DATA_SHORTHAND.encode(self)?;\n                 pos.encode(self)\n             } else {\n                 TAG_EXPN_DATA_INLINE.encode(self)?;\n                 let pos = AbsoluteBytePos::new(self.position());\n                 self.expn_data_shorthands.insert(expn_id, pos);\n-                expn_data.encode(self)\n+                (expn_data, transparency).encode(self)\n             }\n         }\n     }\n }\n \n-impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+impl<'a, 'tcx, E> SpecializedEncoder<Ident> for CacheEncoder<'a, 'tcx, E>\n where\n     E: 'a + ty_codec::TyEncoder,\n+{\n+    fn specialized_encode(&mut self, _: &Ident) -> Result<(), Self::Error> {\n+        // We don't currently encode enough information to ensure hygiene works\n+        // with incremental, so panic rather than risk incremental bugs.\n+\n+        // FIXME: handle hygiene in incremental.\n+        bug!(\"trying to encode `Ident` for incremental\");\n+    }\n+}\n+\n+impl<'a, 'tcx, E> ty_codec::TyEncoder for CacheEncoder<'a, 'tcx, E>\n+where\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn position(&self) -> usize {\n@@ -845,7 +863,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<CrateNum> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, cnum: &CrateNum) -> Result<(), Self::Error> {\n@@ -855,7 +873,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<Ty<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, ty: &Ty<'tcx>) -> Result<(), Self::Error> {\n@@ -866,7 +884,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<ty::GenericPredicates<'tcx>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self,\n@@ -879,7 +897,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<hir::HirId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &hir::HirId) -> Result<(), Self::Error> {\n@@ -897,7 +915,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &DefId) -> Result<(), Self::Error> {\n@@ -908,7 +926,7 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<LocalDefId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, id: &LocalDefId) -> Result<(), Self::Error> {\n@@ -918,18 +936,18 @@ where\n \n impl<'a, 'tcx, E> SpecializedEncoder<DefIndex> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     fn specialized_encode(&mut self, _: &DefIndex) -> Result<(), Self::Error> {\n-        bug!(\"Encoding DefIndex without context.\")\n+        bug!(\"encoding `DefIndex` without context\");\n     }\n }\n \n-// NodeIds are not stable across compilation sessions, so we store them in their\n-// HirId representation. This allows use to map them to the current NodeId.\n+// `NodeId`s are not stable across compilation sessions, so we store them in their\n+// `HirId` representation. This allows use to map them to the current `NodeId`.\n impl<'a, 'tcx, E> SpecializedEncoder<NodeId> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     #[inline]\n     fn specialized_encode(&mut self, node_id: &NodeId) -> Result<(), Self::Error> {\n@@ -946,7 +964,7 @@ impl<'a, 'tcx> SpecializedEncoder<Fingerprint> for CacheEncoder<'a, 'tcx, opaque\n \n impl<'a, 'tcx, E, T> SpecializedEncoder<mir::ClearCrossCrate<T>> for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n     T: Encodable,\n {\n     #[inline]\n@@ -975,7 +993,7 @@ macro_rules! encoder_methods {\n \n impl<'a, 'tcx, E> Encoder for CacheEncoder<'a, 'tcx, E>\n where\n-    E: 'a + ty_codec::TyEncoder,\n+    E: 'a + TyEncoder,\n {\n     type Error = E::Error;\n \n@@ -1019,7 +1037,7 @@ impl UseSpecializedDecodable for IntEncodedWithFixedSize {}\n impl SpecializedEncoder<IntEncodedWithFixedSize> for opaque::Encoder {\n     fn specialized_encode(&mut self, x: &IntEncodedWithFixedSize) -> Result<(), Self::Error> {\n         let start_pos = self.position();\n-        for i in 0 .. IntEncodedWithFixedSize::ENCODED_SIZE {\n+        for i in 0..IntEncodedWithFixedSize::ENCODED_SIZE {\n             ((x.0 >> i * 8) as u8).encode(self)?;\n         }\n         let end_pos = self.position();\n@@ -1064,10 +1082,10 @@ where\n             if Q::cache_on_disk(tcx, key.clone(), Some(&entry.value)) {\n                 let dep_node = SerializedDepNodeIndex::new(entry.index.index());\n \n-                // Record position of the cache entry\n+                // Record position of the cache entry.\n                 query_result_index.push((dep_node, AbsoluteBytePos::new(encoder.position())));\n \n-                // Encode the type check tables with the SerializedDepNodeIndex\n+                // Encode the type check tables with the `SerializedDepNodeIndex`\n                 // as tag.\n                 encoder.encode_tagged(dep_node, &entry.value)?;\n             }"}, {"sha": "a1828bb5ab7a7cacbf6fb1692deb2e2da7bd8d21", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 58, "deletions": 55, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -61,7 +61,7 @@ impl<'tcx, M: QueryConfig<'tcx>> Default for QueryCache<'tcx, M> {\n     }\n }\n \n-// If enabled, send a message to the profile-queries thread\n+// If enabled, sends a message to the profile-queries thread.\n macro_rules! profq_msg {\n     ($tcx:expr, $msg:expr) => {\n         if cfg!(debug_assertions) {\n@@ -72,7 +72,7 @@ macro_rules! profq_msg {\n     }\n }\n \n-// If enabled, format a key using its debug string, which can be\n+// If enabled, formats a key using its debug string, which can be\n // expensive to compute (in terms of time).\n macro_rules! profq_query_msg {\n     ($query:expr, $tcx:expr, $key:expr) => {{\n@@ -98,7 +98,7 @@ pub(super) struct JobOwner<'a, 'tcx, Q: QueryDescription<'tcx>> {\n \n impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n     /// Either gets a `JobOwner` corresponding the query, allowing us to\n-    /// start executing the query, or it returns with the result of the query.\n+    /// start executing the query, or returns with the result of the query.\n     /// If the query is executing elsewhere, this will wait for it.\n     /// If the query panicked, this will silently panic.\n     ///\n@@ -215,38 +215,38 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> Drop for JobOwner<'a, 'tcx, Q> {\n     #[inline(never)]\n     #[cold]\n     fn drop(&mut self) {\n-        // Poison the query so jobs waiting on it panic\n+        // Poison the query so jobs waiting on it panic.\n         let shard = self.cache.get_shard_by_value(&self.key);\n         shard.lock().active.insert(self.key.clone(), QueryResult::Poisoned);\n         // Also signal the completion of the job, so waiters\n-        // will continue execution\n+        // will continue execution.\n         self.job.signal_complete();\n     }\n }\n \n #[derive(Clone)]\n pub struct CycleError<'tcx> {\n-    /// The query and related span which uses the cycle\n+    /// The query and related span that uses the cycle.\n     pub(super) usage: Option<(Span, Query<'tcx>)>,\n     pub(super) cycle: Vec<QueryInfo<'tcx>>,\n }\n \n-/// The result of `try_get_lock`\n+/// The result of `try_get_lock`.\n pub(super) enum TryGetJob<'a, 'tcx, D: QueryDescription<'tcx>> {\n     /// The query is not yet started. Contains a guard to the cache eventually used to start it.\n     NotYetStarted(JobOwner<'a, 'tcx, D>),\n \n     /// The query was already completed.\n-    /// Returns the result of the query and its dep node index\n-    /// if it succeeded or a cycle error if it failed\n+    /// Returns the result of the query and its dep-node index\n+    /// if it succeeded or a cycle error if it failed.\n     JobCompleted((D::Value, DepNodeIndex)),\n \n     /// Trying to execute the query resulted in a cycle.\n     Cycle(D::Value),\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n-    /// Executes a job by changing the ImplicitCtxt to point to the\n+    /// Executes a job by changing the `ImplicitCtxt` to point to the\n     /// new query job while it executes. It returns the diagnostics\n     /// captured during execution and the actual result.\n     #[inline(always)]\n@@ -259,11 +259,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         F: FnOnce(TyCtxt<'tcx>) -> R,\n     {\n-        // The TyCtxt stored in TLS has the same global interner lifetime\n+        // The `TyCtxt` stored in TLS has the same global interner lifetime\n         // as `self`, so we use `with_related_context` to relate the 'tcx lifetimes\n-        // when accessing the ImplicitCtxt\n+        // when accessing the `ImplicitCtxt`.\n         tls::with_related_context(self, move |current_icx| {\n-            // Update the ImplicitCtxt to point to our new query job\n+            // Update the `ImplicitCtxt` to point to our new query job.\n             let new_icx = tls::ImplicitCtxt {\n                 tcx: self.global_tcx(),\n                 query: Some(job),\n@@ -272,7 +272,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 task_deps: current_icx.task_deps,\n             };\n \n-            // Use the ImplicitCtxt while we execute the query\n+            // Use the `ImplicitCtxt` while we execute the query.\n             tls::enter_context(&new_icx, |_| {\n                 compute(self.global_tcx())\n             })\n@@ -330,14 +330,13 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let mut i = 0;\n \n                 while let Some(query) = current_query {\n-                    let mut db = DiagnosticBuilder::new(icx.tcx.sess.diagnostic(),\n-                        Level::FailureNote,\n+                    let mut diag = Diagnostic::new(Level::FailureNote,\n                         &format!(\"#{} [{}] {}\",\n                                  i,\n                                  query.info.query.name(),\n                                  query.info.query.describe(icx.tcx)));\n-                    db.set_span(icx.tcx.sess.source_map().def_span(query.info.span));\n-                    icx.tcx.sess.diagnostic().force_print_db(db);\n+                    diag.span = icx.tcx.sess.source_map().def_span(query.info.span).into();\n+                    icx.tcx.sess.diagnostic().force_print_diagnostic(diag);\n \n                     current_query = query.parent.clone();\n                     i += 1;\n@@ -372,7 +371,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         };\n \n         // Fast path for when incr. comp. is off. `to_dep_node` is\n-        // expensive for some DepKinds.\n+        // expensive for some `DepKind`s.\n         if !self.dep_graph.is_fully_enabled() {\n             let null_dep_node = DepNode::new_no_params(crate::dep_graph::DepKind::Null);\n             return self.force_query_with_job::<Q>(key, job, null_dep_node).0;\n@@ -410,7 +409,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if !Q::EVAL_ALWAYS {\n             // The diagnostics for this query will be\n             // promoted to the current session during\n-            // try_mark_green(), so we can ignore them here.\n+            // `try_mark_green()`, so we can ignore them here.\n             let loaded = self.start_query(job.job.clone(), None, |tcx| {\n                 let marked = tcx.dep_graph.try_mark_green_and_read(tcx, &dep_node);\n                 marked.map(|(prev_dep_node_index, dep_node_index)| {\n@@ -441,22 +440,22 @@ impl<'tcx> TyCtxt<'tcx> {\n         dep_node: &DepNode,\n     ) -> Q::Value {\n         // Note this function can be called concurrently from the same query\n-        // We must ensure that this is handled correctly\n+        // We must ensure that this is handled correctly.\n \n         debug_assert!(self.dep_graph.is_green(dep_node));\n \n-        // First we try to load the result from the on-disk cache\n+        // First we try to load the result from the on-disk cache.\n         let result = if Q::cache_on_disk(self.global_tcx(), key.clone(), None) &&\n                         self.sess.opts.debugging_opts.incremental_queries {\n             self.sess.profiler(|p| p.incremental_load_result_start(Q::NAME));\n             let result = Q::try_load_from_disk(self.global_tcx(), prev_dep_node_index);\n             self.sess.profiler(|p| p.incremental_load_result_end(Q::NAME));\n \n             // We always expect to find a cached result for things that\n-            // can be forced from DepNode.\n+            // can be forced from `DepNode`.\n             debug_assert!(!dep_node.kind.can_reconstruct_query_key() ||\n                           result.is_some(),\n-                          \"Missing on-disk cache entry for {:?}\",\n+                          \"missing on-disk cache entry for {:?}\",\n                           dep_node);\n             result\n         } else {\n@@ -475,8 +474,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             self.sess.profiler(|p| p.start_query(Q::NAME));\n \n-            // The dep-graph for this computation is already in\n-            // place\n+            // The dep-graph for this computation is already in-place.\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n@@ -485,7 +483,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             result\n         };\n \n-        // If -Zincremental-verify-ich is specified, re-hash results from\n+        // If `-Zincremental-verify-ich` is specified, re-hash results from\n         // the cache and make sure that they have the expected fingerprint.\n         if unlikely!(self.sess.opts.debugging_opts.incremental_verify_ich) {\n             self.incremental_verify_ich::<Q>(&result, dep_node, dep_node_index);\n@@ -508,10 +506,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) {\n         use crate::ich::Fingerprint;\n \n-        assert!(Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n+        assert!(\n+            Some(self.dep_graph.fingerprint_of(dep_node_index)) ==\n                 self.dep_graph.prev_fingerprint_of(dep_node),\n-                \"Fingerprint for green query instance not loaded \\\n-                    from cache: {:?}\", dep_node);\n+            \"fingerprint for green query instance not loaded from cache: {:?}\",\n+            dep_node,\n+        );\n \n         debug!(\"BEGIN verify_ich({:?})\", dep_node);\n         let mut hcx = self.create_stable_hashing_context();\n@@ -521,8 +521,11 @@ impl<'tcx> TyCtxt<'tcx> {\n \n         let old_hash = self.dep_graph.fingerprint_of(dep_node_index);\n \n-        assert!(new_hash == old_hash, \"Found unstable fingerprints \\\n-            for {:?}\", dep_node);\n+        assert!(\n+            new_hash == old_hash,\n+            \"found unstable fingerprints for {:?}\",\n+            dep_node,\n+        );\n     }\n \n     #[inline(always)]\n@@ -534,11 +537,11 @@ impl<'tcx> TyCtxt<'tcx> {\n     ) -> (Q::Value, DepNodeIndex) {\n         // If the following assertion triggers, it can have two reasons:\n         // 1. Something is wrong with DepNode creation, either here or\n-        //    in DepGraph::try_mark_green()\n-        // 2. Two distinct query keys get mapped to the same DepNode\n-        //    (see for example #48923)\n+        //    in `DepGraph::try_mark_green()`.\n+        // 2. Two distinct query keys get mapped to the same `DepNode`\n+        //    (see for example #48923).\n         assert!(!self.dep_graph.dep_node_exists(&dep_node),\n-                \"Forcing query with already existing DepNode.\\n\\\n+                \"forcing query with already existing `DepNode`\\n\\\n                  - query-key: {:?}\\n\\\n                  - dep-node: {:?}\",\n                 key, dep_node);\n@@ -584,7 +587,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Ensure that either this query has all green inputs or been executed.\n-    /// Executing query::ensure(D) is considered a read of the dep-node D.\n+    /// Executing `query::ensure(D)` is considered a read of the dep-node `D`.\n     ///\n     /// This function is particularly useful when executing passes for their\n     /// side-effects -- e.g., in order to report errors for erroneous programs.\n@@ -899,13 +902,13 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            // FIXME(eddyb) Get more valid Span's on queries.\n+            // FIXME(eddyb) Get more valid `Span`s on queries.\n             pub fn default_span(&self, tcx: TyCtxt<$tcx>, span: Span) -> Span {\n                 if !span.is_dummy() {\n                     return span;\n                 }\n-                // The def_span query is used to calculate default_span,\n-                // so exit to avoid infinite recursion\n+                // The `def_span` query is used to calculate `default_span`,\n+                // so exit to avoid infinite recursion.\n                 if let Query::def_span(..) = *self {\n                     return span\n                 }\n@@ -1116,7 +1119,7 @@ macro_rules! define_provider_struct {\n         impl<$tcx> Default for Providers<$tcx> {\n             fn default() -> Self {\n                 $(fn $name<$tcx>(_: TyCtxt<$tcx>, key: $K) -> $R {\n-                    bug!(\"tcx.{}({:?}) unsupported by its crate\",\n+                    bug!(\"`tcx.{}({:?})` unsupported by its crate\",\n                          stringify!($name), key);\n                 })*\n                 Providers { $($name),* }\n@@ -1128,26 +1131,26 @@ macro_rules! define_provider_struct {\n \n /// The red/green evaluation system will try to mark a specific DepNode in the\n /// dependency graph as green by recursively trying to mark the dependencies of\n-/// that DepNode as green. While doing so, it will sometimes encounter a DepNode\n+/// that `DepNode` as green. While doing so, it will sometimes encounter a `DepNode`\n /// where we don't know if it is red or green and we therefore actually have\n /// to recompute its value in order to find out. Since the only piece of\n-/// information that we have at that point is the DepNode we are trying to\n+/// information that we have at that point is the `DepNode` we are trying to\n /// re-evaluate, we need some way to re-run a query from just that. This is what\n /// `force_from_dep_node()` implements.\n ///\n-/// In the general case, a DepNode consists of a DepKind and an opaque\n+/// In the general case, a `DepNode` consists of a `DepKind` and an opaque\n /// GUID/fingerprint that will uniquely identify the node. This GUID/fingerprint\n /// is usually constructed by computing a stable hash of the query-key that the\n-/// DepNode corresponds to. Consequently, it is not in general possible to go\n+/// `DepNode` corresponds to. Consequently, it is not in general possible to go\n /// back from hash to query-key (since hash functions are not reversible). For\n /// this reason `force_from_dep_node()` is expected to fail from time to time\n-/// because we just cannot find out, from the DepNode alone, what the\n+/// because we just cannot find out, from the `DepNode` alone, what the\n /// corresponding query-key is and therefore cannot re-run the query.\n ///\n /// The system deals with this case letting `try_mark_green` fail which forces\n /// the root query to be re-evaluated.\n ///\n-/// Now, if force_from_dep_node() would always fail, it would be pretty useless.\n+/// Now, if `force_from_dep_node()` would always fail, it would be pretty useless.\n /// Fortunately, we can use some contextual information that will allow us to\n /// reconstruct query-keys for certain kinds of `DepNode`s. In particular, we\n /// enforce by construction that the GUID/fingerprint of certain `DepNode`s is a\n@@ -1171,9 +1174,9 @@ macro_rules! define_provider_struct {\n pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n     use crate::dep_graph::RecoverKey;\n \n-    // We must avoid ever having to call force_from_dep_node() for a\n-    // DepNode::codegen_unit:\n-    // Since we cannot reconstruct the query key of a DepNode::codegen_unit, we\n+    // We must avoid ever having to call `force_from_dep_node()` for a\n+    // `DepNode::codegen_unit`:\n+    // Since we cannot reconstruct the query key of a `DepNode::codegen_unit`, we\n     // would always end up having to evaluate the first caller of the\n     // `codegen_unit` query that *is* reconstructible. This might very well be\n     // the `compile_codegen_unit` query, thus re-codegenning the whole CGU just\n@@ -1196,7 +1199,7 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n             if let Some(def_id) = dep_node.extract_def_id(tcx) {\n                 def_id\n             } else {\n-                // return from the whole function\n+                // Return from the whole function.\n                 return false\n             }\n         }\n@@ -1224,20 +1227,20 @@ pub fn force_from_dep_node(tcx: TyCtxt<'_>, dep_node: &DepNode) -> bool {\n \n     rustc_dep_node_force!([dep_node, tcx]\n         // These are inputs that are expected to be pre-allocated and that\n-        // should therefore always be red or green already\n+        // should therefore always be red or green already.\n         DepKind::AllLocalTraitImpls |\n         DepKind::Krate |\n         DepKind::CrateMetadata |\n         DepKind::HirBody |\n         DepKind::Hir |\n \n-        // This are anonymous nodes\n+        // These are anonymous nodes.\n         DepKind::TraitSelect |\n \n         // We don't have enough information to reconstruct the query key of\n-        // these\n+        // these.\n         DepKind::CompileCodegenUnit => {\n-            bug!(\"force_from_dep_node() - Encountered {:?}\", dep_node)\n+            bug!(\"force_from_dep_node: encountered {:?}\", dep_node)\n         }\n \n         DepKind::Analysis => { force!(analysis, krate!()); }"}, {"sha": "565447dd7e1afd7fc0fc63aff0b9e401383b70b3", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 21, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -8,7 +8,7 @@ use crate::hir::def_id::DefId;\n use crate::ty::subst::{Kind, UnpackedKind, SubstsRef};\n use crate::ty::{self, Ty, TyCtxt, TypeFoldable};\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::mir::interpret::{ConstValue, Scalar, GlobalId};\n+use crate::mir::interpret::{ConstValue, Scalar};\n use std::rc::Rc;\n use std::iter;\n use rustc_target::spec::abi;\n@@ -551,26 +551,8 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n     let tcx = relation.tcx();\n \n     let eagerly_eval = |x: &'tcx ty::Const<'tcx>| {\n-        if let ConstValue::Unevaluated(def_id, substs) = x.val {\n-            // FIXME(eddyb) get the right param_env.\n-            let param_env = ty::ParamEnv::empty();\n-            if !substs.has_local_value() {\n-                let instance = ty::Instance::resolve(\n-                    tcx.global_tcx(),\n-                    param_env,\n-                    def_id,\n-                    substs,\n-                );\n-                if let Some(instance) = instance {\n-                    let cid = GlobalId {\n-                        instance,\n-                        promoted: None,\n-                    };\n-                    if let Ok(ct) = tcx.const_eval(param_env.and(cid)) {\n-                        return ct.val;\n-                    }\n-                }\n-            }\n+        if !x.val.has_local_value() {\n+            return x.eval(tcx, relation.param_env()).val;\n         }\n         x.val\n     };"}, {"sha": "ec7cf1a13c5964f81b47fa94aff9e807a12db82c", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -748,6 +748,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             Sorts(ref x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(ref x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(ref x) => return tcx.lift(x).map(ConstMismatch),\n+            IntrinsicCast => IntrinsicCast,\n         })\n     }\n }\n@@ -1338,6 +1339,7 @@ EnumTypeFoldableImpl! {\n         (ty::error::TypeError::Sorts)(x),\n         (ty::error::TypeError::ExistentialMismatch)(x),\n         (ty::error::TypeError::ConstMismatch)(x),\n+        (ty::error::TypeError::IntrinsicCast),\n     }\n }\n "}, {"sha": "e73a51e6f78e5272eee86659d566340f87a7567d", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -86,6 +86,7 @@ impl BoundRegion {\n /// AST structure in `libsyntax/ast.rs` as well.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash,\n          RustcEncodable, RustcDecodable, HashStable, Debug)]\n+#[cfg_attr(not(bootstrap), rustc_diagnostic_item = \"TyKind\")]\n pub enum TyKind<'tcx> {\n     /// The primitive boolean type. Written as `bool`.\n     Bool,\n@@ -385,7 +386,7 @@ impl<'tcx> ClosureSubsts<'tcx> {\n         let ty = self.closure_sig_ty(def_id, tcx);\n         match ty.sty {\n             ty::FnPtr(sig) => sig,\n-            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty),\n+            _ => bug!(\"closure_sig_ty is not a fn-ptr: {:?}\", ty.sty),\n         }\n     }\n }\n@@ -643,7 +644,7 @@ impl<'tcx> Binder<ExistentialPredicate<'tcx>> {\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for &'tcx List<ExistentialPredicate<'tcx>> {}\n \n impl<'tcx> List<ExistentialPredicate<'tcx>> {\n-    /// Returns the \"principal def id\" of this set of existential predicates.\n+    /// Returns the \"principal `DefId`\" of this set of existential predicates.\n     ///\n     /// A Rust trait object type consists (in addition to a lifetime bound)\n     /// of a set of trait bounds, which are separated into any number\n@@ -1051,7 +1052,7 @@ impl<'tcx> PolyGenSig<'tcx> {\n     }\n }\n \n-/// Signature of a function type, which I have arbitrarily\n+/// Signature of a function type, which we have arbitrarily\n /// decided to use to refer to the input/output types.\n ///\n /// - `inputs`: is the list of arguments and their modes.\n@@ -1075,7 +1076,8 @@ impl<'tcx> FnSig<'tcx> {\n         self.inputs_and_output[self.inputs_and_output.len() - 1]\n     }\n \n-    // Create a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible method\n+    // Creates a minimal `FnSig` to be used when encountering a `TyKind::Error` in a fallible\n+    // method.\n     fn fake() -> FnSig<'tcx> {\n         FnSig {\n             inputs_and_output: List::empty(),\n@@ -1117,7 +1119,6 @@ impl<'tcx> PolyFnSig<'tcx> {\n \n pub type CanonicalPolyFnSig<'tcx> = Canonical<'tcx, Binder<FnSig<'tcx>>>;\n \n-\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord,\n          Hash, RustcEncodable, RustcDecodable, HashStable)]\n pub struct ParamTy {\n@@ -2299,23 +2300,33 @@ impl<'tcx> Const<'tcx> {\n         assert_eq!(self.ty, ty);\n         // if `ty` does not depend on generic parameters, use an empty param_env\n         let size = tcx.layout_of(param_env.with_reveal_all().and(ty)).ok()?.size;\n+        self.eval(tcx, param_env).val.try_to_bits(size)\n+    }\n+\n+    #[inline]\n+    pub fn eval(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        param_env: ParamEnv<'tcx>,\n+    ) -> &Const<'tcx> {\n+        // FIXME(const_generics): this doesn't work right now,\n+        // because it tries to relate an `Infer` to a `Param`.\n         match self.val {\n-            // FIXME(const_generics): this doesn't work right now,\n-            // because it tries to relate an `Infer` to a `Param`.\n             ConstValue::Unevaluated(did, substs) => {\n                 // if `substs` has no unresolved components, use and empty param_env\n                 let (param_env, substs) = param_env.with_reveal_all().and(substs).into_parts();\n                 // try to resolve e.g. associated constants to their definition on an impl\n-                let instance = ty::Instance::resolve(tcx, param_env, did, substs)?;\n+                let instance = match ty::Instance::resolve(tcx, param_env, did, substs) {\n+                    Some(instance) => instance,\n+                    None => return self,\n+                };\n                 let gid = GlobalId {\n                     instance,\n                     promoted: None,\n                 };\n-                let evaluated = tcx.const_eval(param_env.and(gid)).ok()?;\n-                evaluated.val.try_to_bits(size)\n+                tcx.const_eval(param_env.and(gid)).unwrap_or(self)\n             },\n-            // otherwise just extract a `ConstValue`'s bits if possible\n-            _ => self.val.try_to_bits(size),\n+            _ => self,\n         }\n     }\n "}, {"sha": "78d94df4fa03be353a56fe6b7f6bceee41d60104", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -709,8 +709,10 @@ impl<'tcx> TyCtxt<'tcx> {\n                 substs: SubstsRef<'tcx>,\n             ) -> Option<Ty<'tcx>> {\n                 if self.found_recursion {\n-                    None\n-                } else if self.seen_opaque_tys.insert(def_id) {\n+                    return None;\n+                }\n+                let substs = substs.fold_with(self);\n+                if self.seen_opaque_tys.insert(def_id) {\n                     let generic_ty = self.tcx.type_of(def_id);\n                     let concrete_ty = generic_ty.subst(self.tcx, substs);\n                     let expanded_ty = self.fold_ty(concrete_ty);\n@@ -994,11 +996,29 @@ impl<'tcx> ty::TyS<'tcx> {\n         debug!(\"is_type_representable: {:?} is {:?}\", self, r);\n         r\n     }\n+\n+    /// Peel off all reference types in this type until there are none left.\n+    ///\n+    /// This method is idempotent, i.e. `ty.peel_refs().peel_refs() == ty.peel_refs()`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// - `u8` -> `u8`\n+    /// - `&'a mut u8` -> `u8`\n+    /// - `&'a &'b u8` -> `u8`\n+    /// - `&'a *const &'b u8 -> *const &'b u8`\n+    pub fn peel_refs(&'tcx self) -> Ty<'tcx> {\n+        let mut ty = self;\n+        while let Ref(_, inner_ty, _) = ty.sty {\n+            ty = inner_ty;\n+        }\n+        ty\n+    }\n }\n \n fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1011,7 +1031,7 @@ fn is_copy_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,\n@@ -1024,7 +1044,7 @@ fn is_sized_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n \n fn is_freeze_raw<'tcx>(tcx: TyCtxt<'tcx>, query: ty::ParamEnvAnd<'tcx, Ty<'tcx>>) -> bool {\n     let (param_env, ty) = query.into_parts();\n-    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n+    let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem, None);\n     tcx.infer_ctxt()\n         .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n             &infcx,"}, {"sha": "d6de217f79c29c7086a8dc86d6140ddd1122dcef", "filename": "src/librustc/ty/wf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Fty%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fwf.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -221,7 +221,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n-                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem),\n+                def_id: self.infcx.tcx.require_lang_item(lang_items::SizedTraitLangItem, None),\n                 substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n             };\n             self.out.push(traits::Obligation::new(cause, self.param_env, trait_ref.to_predicate()));"}, {"sha": "2475b93d95f32af84ee0ded0da2e2cc39f199347", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -5,17 +5,13 @@ use rustc_data_structures::{fx::FxHashMap, sync::Lock};\n use std::cell::{RefCell, Cell};\n use std::fmt::Debug;\n use std::hash::Hash;\n-use std::panic;\n-use std::env;\n use std::time::{Duration, Instant};\n \n use std::sync::mpsc::{Sender};\n use syntax_pos::{SpanData};\n use syntax::symbol::{Symbol, sym};\n use rustc_macros::HashStable;\n-use crate::ty::TyCtxt;\n use crate::dep_graph::{DepNode};\n-use lazy_static;\n use crate::session::Session;\n \n #[cfg(test)]\n@@ -31,39 +27,6 @@ pub struct ErrorReported;\n \n thread_local!(static TIME_DEPTH: Cell<usize> = Cell::new(0));\n \n-lazy_static! {\n-    static ref DEFAULT_HOOK: Box<dyn Fn(&panic::PanicInfo<'_>) + Sync + Send + 'static> = {\n-        let hook = panic::take_hook();\n-        panic::set_hook(Box::new(panic_hook));\n-        hook\n-    };\n-}\n-\n-fn panic_hook(info: &panic::PanicInfo<'_>) {\n-    (*DEFAULT_HOOK)(info);\n-\n-    let backtrace = env::var_os(\"RUST_BACKTRACE\").map(|x| &x != \"0\").unwrap_or(false);\n-\n-    if backtrace {\n-        TyCtxt::try_print_query_stack();\n-    }\n-\n-    #[cfg(windows)]\n-    unsafe {\n-        if env::var(\"RUSTC_BREAK_ON_ICE\").is_ok() {\n-            extern \"system\" {\n-                fn DebugBreak();\n-            }\n-            // Trigger a debugger if we crashed during bootstrap.\n-            DebugBreak();\n-        }\n-    }\n-}\n-\n-pub fn install_panic_hook() {\n-    lazy_static::initialize(&DEFAULT_HOOK);\n-}\n-\n /// Parameters to the `Dump` variant of type `ProfileQueriesMsg`.\n #[derive(Clone,Debug)]\n pub struct ProfQDumpParams {"}, {"sha": "18d968fbddd9b6b319798a369251ec85bab2bce0", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,13 +1,13 @@\n use crate::{Category, ExpInt, IEK_INF, IEK_NAN, IEK_ZERO};\n use crate::{Float, FloatConvert, ParseError, Round, Status, StatusAnd};\n \n+use core::cmp::{self, Ordering};\n+use core::convert::TryFrom;\n+use core::fmt::{self, Write};\n+use core::marker::PhantomData;\n+use core::mem;\n+use core::ops::Neg;\n use smallvec::{SmallVec, smallvec};\n-use std::cmp::{self, Ordering};\n-use std::convert::TryFrom;\n-use std::fmt::{self, Write};\n-use std::marker::PhantomData;\n-use std::mem;\n-use std::ops::Neg;\n \n #[must_use]\n pub struct IeeeFloat<S> {\n@@ -2287,8 +2287,8 @@ impl Loss {\n /// Implementation details of IeeeFloat significands, such as big integer arithmetic.\n /// As a rule of thumb, no functions in this module should dynamically allocate.\n mod sig {\n-    use std::cmp::Ordering;\n-    use std::mem;\n+    use core::cmp::Ordering;\n+    use core::mem;\n     use super::{ExpInt, Limb, LIMB_BITS, limbs_for_bits, Loss};\n \n     pub(super) fn is_all_zeros(limbs: &[Limb]) -> bool {"}, {"sha": "1190cea21acc3cf364b89018d7798462f9b7c4b2", "filename": "src/librustc_apfloat/lib.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -31,15 +31,19 @@\n //! This API is completely unstable and subject to change.\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n+#![no_std]\n #![forbid(unsafe_code)]\n \n #![feature(nll)]\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::{Neg, Add, Sub, Mul, Div, Rem};\n-use std::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n-use std::str::FromStr;\n+#[macro_use]\n+extern crate alloc;\n+\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::{Neg, Add, Sub, Mul, Div, Rem};\n+use core::ops::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n+use core::str::FromStr;\n \n bitflags::bitflags! {\n     /// IEEE-754R 7: Default exception handling.\n@@ -587,7 +591,7 @@ macro_rules! float_common_impls {\n             }\n         }\n \n-        impl<$t> ::std::str::FromStr for $ty<$t> where Self: Float {\n+        impl<$t> ::core::str::FromStr for $ty<$t> where Self: Float {\n             type Err = ParseError;\n             fn from_str(s: &str) -> Result<Self, ParseError> {\n                 Self::from_str_r(s, Round::NearestTiesToEven).map(|x| x.value)\n@@ -596,66 +600,66 @@ macro_rules! float_common_impls {\n \n         // Rounding ties to the nearest even, by default.\n \n-        impl<$t> ::std::ops::Add for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Add for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn add(self, rhs: Self) -> StatusAnd<Self> {\n                 self.add_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Sub for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Sub for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn sub(self, rhs: Self) -> StatusAnd<Self> {\n                 self.sub_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Mul for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Mul for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn mul(self, rhs: Self) -> StatusAnd<Self> {\n                 self.mul_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Div for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Div for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn div(self, rhs: Self) -> StatusAnd<Self> {\n                 self.div_r(rhs, Round::NearestTiesToEven)\n             }\n         }\n \n-        impl<$t> ::std::ops::Rem for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::Rem for $ty<$t> where Self: Float {\n             type Output = StatusAnd<Self>;\n             fn rem(self, rhs: Self) -> StatusAnd<Self> {\n                 self.c_fmod(rhs)\n             }\n         }\n \n-        impl<$t> ::std::ops::AddAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::AddAssign for $ty<$t> where Self: Float {\n             fn add_assign(&mut self, rhs: Self) {\n                 *self = (*self + rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::SubAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::SubAssign for $ty<$t> where Self: Float {\n             fn sub_assign(&mut self, rhs: Self) {\n                 *self = (*self - rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::MulAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::MulAssign for $ty<$t> where Self: Float {\n             fn mul_assign(&mut self, rhs: Self) {\n                 *self = (*self * rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::DivAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::DivAssign for $ty<$t> where Self: Float {\n             fn div_assign(&mut self, rhs: Self) {\n                 *self = (*self / rhs).value;\n             }\n         }\n \n-        impl<$t> ::std::ops::RemAssign for $ty<$t> where Self: Float {\n+        impl<$t> ::core::ops::RemAssign for $ty<$t> where Self: Float {\n             fn rem_assign(&mut self, rhs: Self) {\n                 *self = (*self % rhs).value;\n             }"}, {"sha": "8e2e390568e48261e5e0ea262dfd89a64ad07bc4", "filename": "src/librustc_apfloat/ppc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Fppc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_apfloat%2Fppc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fppc.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -1,9 +1,9 @@\n use crate::{Category, ExpInt, Float, FloatConvert, Round, ParseError, Status, StatusAnd};\n use crate::ieee;\n \n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::ops::Neg;\n+use core::cmp::Ordering;\n+use core::fmt;\n+use core::ops::Neg;\n \n #[must_use]\n #[derive(Copy, Clone, PartialEq, PartialOrd, Debug)]"}, {"sha": "645707ccc03388efebfbee407ef4411cf96ba0fe", "filename": "src/librustc_asan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_asan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_asan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_asan%2Fbuild.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,6 +4,10 @@ use build_helper::sanitizer_lib_boilerplate;\n use cmake::Config;\n \n fn main() {\n+    println!(\"cargo:rerun-if-env-changed=RUSTC_BUILD_SANITIZERS\");\n+    if env::var(\"RUSTC_BUILD_SANITIZERS\") != Ok(\"1\".to_string()) {\n+        return;\n+    }\n     if let Some(llvm_config) = env::var_os(\"LLVM_CONFIG\") {\n         build_helper::restore_library_path();\n "}, {"sha": "23d5480c60562b5811acf8baff6d091a1fea1fa8", "filename": "src/librustc_ast_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -9,7 +9,6 @@ use InteriorKind::*;\n \n use rustc::hir::HirId;\n use rustc::hir::Node;\n-use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::mem_categorization as mc;\n@@ -28,6 +27,7 @@ use log::debug;\n \n use rustc::hir;\n \n+use crate::cfg;\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n pub mod check_loans;"}, {"sha": "67d818161b1b5d2a6cde7ba12356049b46ebed02", "filename": "src/librustc_ast_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fborrowck%2Fmove_data.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "patch": "@@ -4,7 +4,7 @@\n use crate::dataflow::{DataFlowContext, BitwiseOperator, DataFlowOperator, KillFrom};\n \n use crate::borrowck::*;\n-use rustc::cfg;\n+use crate::cfg;\n use rustc::ty::{self, TyCtxt};\n use rustc::util::nodemap::FxHashMap;\n "}, {"sha": "0dc999083a91a93c88ffcf3f0419657ad0ddc408", "filename": "src/librustc_ast_borrowck/cfg/construct.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fconstruct.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "previous_filename": "src/librustc/cfg/construct.rs"}, {"sha": "99c6b49cad5d908f9529d0a5737016a9b8e3a23f", "filename": "src/librustc_ast_borrowck/cfg/graphviz.rs", "status": "renamed", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fgraphviz.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "previous_filename": "src/librustc/cfg/graphviz.rs"}, {"sha": "981199c91d513effe18b18fb911c4ecf593b9728", "filename": "src/librustc_ast_borrowck/cfg/mod.rs", "status": "renamed", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fcfg%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49", "previous_filename": "src/librustc/cfg/mod.rs"}, {"sha": "a8562901d99c5f3c0443db6b6dc6980580533998", "filename": "src/librustc_ast_borrowck/dataflow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fdataflow.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "c077dc828aba22b98fe898fee4bd92039bef9832", "filename": "src/librustc_ast_borrowck/graphviz.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Fgraphviz.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "aea97fea1a9fd67d5aeec911beb59e6775e17f5b", "filename": "src/librustc_ast_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_ast_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ast_borrowck%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "98efa6a5804bd352d4617912ecdaaf58f099df4a", "filename": "src/librustc_codegen_llvm/Cargo.toml", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "2ca517dc3b1a7e8319ece659d0e02c43db65bdf7", "filename": "src/librustc_codegen_llvm/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fabi.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "68d3f90cd3991160e18b6c656d1588a3dc771547", "filename": "src/librustc_codegen_llvm/back/archive.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Farchive.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "a43fbb68dbaed76d7d5d3d858c8c591fee5f50f7", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 41, "deletions": 45, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "423a01ad1f9374a6da0a7f61b914bbe6434f4a86", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 9, "deletions": 22, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "35d5107842d5b3464b2d7b6f8a86b6bffdb62f12", "filename": "src/librustc_codegen_llvm/callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcallee.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "6fbea9646b8a9fe524514000c23c70a6f3ee8f17", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "e71d1fc16924bb1ed966d99935c2b3114aa63059", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 58, "deletions": 16, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "58ce97039099e7bc7dc0477a84e483d82ac6d268", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "d0b607bd88ee4f9d5023b8d653d5b80b6768c694", "filename": "src/librustc_codegen_llvm/debuginfo/metadata.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmetadata.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "6dedf10f0ab837e41fb5f3094e02c757df62868a", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "042e51ed2ba7a4e95e0f4bacd7e16142947df71c", "filename": "src/librustc_codegen_llvm/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Ferror_codes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "3f3c5ac1460a315d17bc8ced0c0fd1ce271c5652", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 25, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "34e39af3c39fcda98ca756257ee78f3dfd9ea24f", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "b07214fdc03f3c22b4f93d2e462369ca87cd1bff", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "bc028d6624279b1ba44891167e3c3573f39fb7fd", "filename": "src/librustc_codegen_ssa/Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "8d2120a345a8d61ea8015b51408bf41c582022b9", "filename": "src/librustc_codegen_ssa/back/archive.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Farchive.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "2d84d67e3c85bd097a4dc8924005593711fac2bd", "filename": "src/librustc_codegen_ssa/back/command.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fcommand.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "9b044d9b45377c03d750082ab7da1b0d09689ae3", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "c42cd024926dc71f21444c13fab5e12865d9cb58", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 49, "deletions": 41, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "7e700e6819426c2ba29170df616edd1dd6be74fb", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1bba479c1fd5db7f0dc37aaf3fff25308c605e22", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "4acbe0356b47cb174cdbe581ce83071af9de4e86", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "9b5ad94ecd7cbbc145f9f31b8ab405752c7a98e4", "filename": "src/librustc_codegen_ssa/debuginfo/type_names.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fdebuginfo%2Ftype_names.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "8ff41c275a8f45283e387847e7d5861dd3abd94b", "filename": "src/librustc_codegen_ssa/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ferror_codes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1708d7235b45b1d56badb6b3d7288d32b2bca6f4", "filename": "src/librustc_codegen_ssa/lib.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "d192f2ffb6fba8bddd54076d55752fb9f30e2998", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1bb0ea5dae44b4c21676fee9955281a6e7490725", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "aa3971a1da81aa0f14c5df0e1c4395d73c4eeeed", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "daa25b2ea0591f572d82853cb20c7c980bf68bdd", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 34, "deletions": 37, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "a4b4cb53bb1fb883c4459e5108fefdaf47c597f5", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 40, "deletions": 32, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "f21836a953c223ff31c81c57394ad04faeac53cf", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "dab7dfc04175110b57b369126d2817c1d9bb34fe", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "5801963c101ef1079dc773e837b7ca58c50fa656", "filename": "src/librustc_codegen_ssa/mono_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmono_item.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1886701fb3a88d95e1c9d4c274c1afe2f64039b6", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "9c16b864ef21dce3b48d1c017b16cb8b885848ac", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "7c79cd6021031d7691328453e672272ffdb657b6", "filename": "src/librustc_codegen_ssa/traits/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fintrinsic.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "73c4c053979173449661ba4e0714b330f2d2ed4f", "filename": "src/librustc_codegen_ssa/traits/statics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fstatics.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1201446afb53128dddbd1b0a52134801ae72d6ff", "filename": "src/librustc_codegen_utils/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_utils%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_utils%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "51269be4e9f409f25f5165939b858adb677a894a", "filename": "src/librustc_codegen_utils/symbol_names_test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names_test.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "be9f79c83bb5a8416cf26cf41e73dff8b776dcc4", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "6e80b48a6856016dadab3a7eb46bb2add06f0d6c", "filename": "src/librustc_data_structures/indexed_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Findexed_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Findexed_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_vec.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "ddf89d99621cabccc5be65cef79e1d048888bd70", "filename": "src/librustc_data_structures/obligation_forest/graphviz.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fgraphviz.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "98ae1a58324476c5c1731d32a20b1d13f97a0bb3", "filename": "src/librustc_data_structures/obligation_forest/mod.rs", "status": "modified", "additions": 171, "deletions": 175, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fmod.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "69ea473e054618dabe8dc437e23c649f42517b5f", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=4dd4da97175b1c6cf15fc9505ec8f8afdaf71a24"}, {"sha": "ea771d9f20f8b69a60068870ba93060854736233", "filename": "src/librustc_data_structures/tiny_list.rs", "status": "modified", "additions": 16, "deletions": 40, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Ftiny_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Ftiny_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "0142631590cc9af411574dbf2ab8835b47852754", "filename": "src/librustc_data_structures/tiny_list/tests.rs", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftiny_list%2Ftests.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "25f67b30468ccdbe1f6f03e461813baae44fc065", "filename": "src/librustc_driver/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "0906d358badd49dcbd940e5fc6e2f59ccd817756", "filename": "src/librustc_driver/args.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fargs.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "f99e65b4494a7f136c7eb91c7994573cb1d8d66d", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 136, "deletions": 58, "changes": 194, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "fa9504e22019ebfe585ca78846509f892675f7f9", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1541845bb55f62f5a39a577e34e053967bee8d53", "filename": "src/librustc_errors/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "0281d10fd930ee1ac290f77a5848176e0201b52c", "filename": "src/librustc_errors/annotate_snippet_emitter_writer.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fannotate_snippet_emitter_writer.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "e85388bfea29c51aa60ecc282f756093fc7e6af7", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "fc441320e003919df9eef990995a6b4f3d0e4da6", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 552, "deletions": 232, "changes": 784, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1fe5b71d7b1cf51691f636ca7f2d1cdd59c662cd", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 233, "deletions": 165, "changes": 398, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "659c4c89fe33c41272a68b3e073eb1b1abfe7413", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "e08eeaf85758eefdc619566da445814892f73977", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "837aa9360c8953fcf8506987317740a987f486aa", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 21, "deletions": 6, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "f6293107a940eeee46d717d8a9c7d34eee375e20", "filename": "src/librustc_interface/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "79a343e0fee0bfcc2ce20a53e36fc92f822b0ec0", "filename": "src/librustc_interface/build.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fbuild.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "e8e8da67334712948bda3faf34b092e95e151bf9", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 39, "deletions": 43, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "b81f814de0f4a81b8c301a259ca06a0c4e905234", "filename": "src/librustc_interface/util.rs", "status": "modified", "additions": 119, "deletions": 83, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_interface%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Futil.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "950771f0a692710021dc7e29c18736fdbbe3ea0b", "filename": "src/librustc_lexer/Cargo.toml", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lexer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lexer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "30a5175d8cdb092d59dc19e16080f48e15df19f9", "filename": "src/librustc_lexer/src/lib.rs", "status": "modified", "additions": 72, "deletions": 70, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lexer%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lexer%2Fsrc%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "cf19a9eb147a8c1560bfa9d860a9d3cb58f6990f", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "ea2e1d9ecc53f46553207c643ec5eed7c560de96", "filename": "src/librustc_lint/error_codes.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ferror_codes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "0e054013cd779ed30eab29353d0dd4c1c7cc9b33", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "bb6119d0ff2aa0fbdb7eb701ebb148ea6d592456", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "40261f6d13739d0b04668b35cd0dc2f7dbfca596", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 85, "deletions": 32, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "2d4af2f606a2cc997f276861d254935e20fd237a", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 83, "deletions": 36, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "62a3757757b800f9ca77d60cdbe1ed62d7aba071", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "73720d8c2d64ec32b65855c84edfc2cbf240a6b7", "filename": "src/librustc_lsan/build.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lsan%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_lsan%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lsan%2Fbuild.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "5bf4067431f24a6b73a8e08ee4c2df3895377021", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "a1e3bbcbf8ea94d8205ca043e9fe7a0f780a9525", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "34c84b1d79d4b0030a418cb4328bb94bb407f952", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 76, "deletions": 51, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "f430f01542efe4f23fadf7677ec5dbeba013abb1", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 70, "deletions": 38, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "cd8e95e6c3a1101786cd08bc55fba6b8bc0c7a37", "filename": "src/librustc_metadata/error_codes.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Ferror_codes.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "e6104e629e9fbfefbec87db6c2dc3a602e2137e9", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "ada1a8c615d44743ac3d9ce3f5171c7322f8ae22", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1a5f0e17ba7ceebdd110b95321808718b9a6e004", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "0691390bead4beaeffd0053589277a192fd17788", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "db19cbc3175f8c60be5c0edbcdd637525134cc49", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "599a0ad0d0c52641d2daeee4d6575aca42bb614c", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "5bccd2835c980d32f6d75caee10ead5fa486e834", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 43, "deletions": 40, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}, {"sha": "1f17ab69f6660b722e613a46586df945aeb9a044", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/27532330e909ac7af1507d292621751dbe61cd49/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=27532330e909ac7af1507d292621751dbe61cd49"}]}