{"sha": "a64e886e3c1dd38473fd7711933557f1b97a9036", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2NGU4ODZlM2MxZGQzODQ3M2ZkNzcxMTkzMzU1N2YxYjk3YTkwMzY=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T07:32:36Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-06-10T13:02:55Z"}, "message": "std: remove str::contains in favour of the method", "tree": {"sha": "0213489226e402bc79a20331295ff3bec409ad70", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0213489226e402bc79a20331295ff3bec409ad70"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a64e886e3c1dd38473fd7711933557f1b97a9036", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a64e886e3c1dd38473fd7711933557f1b97a9036", "html_url": "https://github.com/rust-lang/rust/commit/a64e886e3c1dd38473fd7711933557f1b97a9036", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a64e886e3c1dd38473fd7711933557f1b97a9036/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "017450a6111a430eca86caf4ee6021ed654b552f", "url": "https://api.github.com/repos/rust-lang/rust/commits/017450a6111a430eca86caf4ee6021ed654b552f", "html_url": "https://github.com/rust-lang/rust/commit/017450a6111a430eca86caf4ee6021ed654b552f"}], "stats": {"total": 239, "additions": 104, "deletions": 135}, "files": [{"sha": "0a33eb6ab2a531f5fa6fd4e83d96d68dff580b79", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -802,20 +802,15 @@ Use declarations support a number of convenient shortcuts:\n An example of `use` declarations:\n \n ~~~~\n-use std::float::sin;\n-use std::str::{from_chars, contains};\n+use std::float::{sin, pow};\n use std::option::Some;\n \n fn main() {\n-    // Equivalent to 'info!(std::float::sin(1.0));'\n-    info!(sin(1.0));\n+    // Equivalent to 'info!(std::float::pow(std::float::sin(1.0), 2.0));'\n+    info!(pow(sin(1.0), 2.0));\n \n     // Equivalent to 'info!(std::option::Some(1.0));'\n     info!(Some(1.0));\n-\n-    // Equivalent to\n-    // 'info!(std::str::contains(std::str::from_chars(&['f','o','o']), \"oo\"));'\n-    info!(contains(from_chars(&['f','o','o']), \"oo\"));\n }\n ~~~~\n "}, {"sha": "d8562d725a709caa0d569aa8be501d20e76a780f", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -169,7 +169,7 @@ fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n }\n \n fn parse_name_directive(line: &str, directive: &str) -> bool {\n-    str::contains(line, directive)\n+    line.contains(directive)\n }\n \n fn parse_name_value_directive(line: &str,"}, {"sha": "d87101ffb8542962f8a2b13cd9cdac84ee4e88de", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -309,7 +309,7 @@ fn check_error_patterns(props: &TestProps,\n     let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     for ProcRes.stderr.line_iter().advance |line| {\n-        if str::contains(line, *next_err_pat) {\n+        if line.contains(*next_err_pat) {\n             debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == props.error_patterns.len() {\n@@ -365,8 +365,8 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                 debug!(\"prefix=%s ee.kind=%s ee.msg=%s line=%s\",\n                        prefixes[i], ee.kind, ee.msg, line);\n                 if (str::starts_with(line, prefixes[i]) &&\n-                    str::contains(line, ee.kind) &&\n-                    str::contains(line, ee.msg)) {\n+                    line.contains(ee.kind) &&\n+                    line.contains(ee.msg)) {\n                     found_flags[i] = true;\n                     was_expected = true;\n                     break;\n@@ -375,7 +375,7 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n         }\n \n         // ignore this msg which gets printed at the end\n-        if str::contains(line, \"aborting due to\") {\n+        if line.contains(\"aborting due to\") {\n             was_expected = true;\n         }\n "}, {"sha": "3ea085f5e86f10fce87023f4fc6fbb8c653decde", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -1597,8 +1597,8 @@ mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n     pub fn impl_gl_tcp_ipv4_get_peer_addr() {\n         let hl_loop = &uv::global_loop::get();\n@@ -1765,8 +1765,8 @@ mod test {\n                        expected_req, actual_req);\n         debug!(\"RESP: expected: '%s' actual: '%s'\",\n                        expected_resp, actual_resp);\n-        assert!(str::contains(actual_req, expected_req));\n-        assert!(str::contains(actual_resp, expected_resp));\n+        assert!(actual_req.contains(expected_req));\n+        assert!(actual_resp.contains(expected_resp));\n     }\n \n     pub fn impl_tcp_socket_impl_reader_handles_eof() {"}, {"sha": "406dfb086eaceb8d334ac3a290c68adaefd05afa", "filename": "src/libextra/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -514,7 +514,7 @@ pub fn filter_tests(\n \n         fn filter_fn(test: TestDescAndFn, filter_str: &str) ->\n             Option<TestDescAndFn> {\n-            if str::contains(test.desc.name.to_str(), filter_str) {\n+            if test.desc.name.to_str().contains(filter_str) {\n                 return option::Some(test);\n             } else { return option::None; }\n         }"}, {"sha": "187960b91016a9622a3f1036c722919a5f2ff969", "filename": "src/libextra/uv_ll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibextra%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuv_ll.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -1480,7 +1480,7 @@ mod test {\n \n                 let server_kill_msg = copy (*client_data).server_kill_msg;\n                 let write_req = (*client_data).server_write_req;\n-                if str::contains(request_str, server_kill_msg) {\n+                if request_str.contains(server_kill_msg) {\n                     debug!(~\"SERVER: client req contains kill_msg!\");\n                     debug!(~\"SERVER: sending response to client\");\n                     read_stop(client_stream_ptr);\n@@ -1753,8 +1753,8 @@ mod test {\n         let msg_from_client = server_port.recv();\n         let msg_from_server = client_port.recv();\n \n-        assert!(str::contains(msg_from_client, kill_server_msg));\n-        assert!(str::contains(msg_from_server, server_resp_msg));\n+        assert!(msg_from_client.contains(kill_server_msg));\n+        assert!(msg_from_server.contains(server_resp_msg));\n     }\n \n     // FIXME don't run on fbsd or linux 32 bit(#2064)"}, {"sha": "416fabb6d8f67443244165bc6b2f41c9d0f803ea", "filename": "src/libfuzzer/fuzzer.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibfuzzer%2Ffuzzer.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibfuzzer%2Ffuzzer.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfuzzer%2Ffuzzer.rc?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -57,7 +57,7 @@ pub fn write_file(filename: &Path, content: &str) {\n }\n \n pub fn contains(haystack: &str, needle: &str) -> bool {\n-    str::contains(haystack, needle)\n+    haystack.contains(needle)\n }\n \n pub fn find_rust_files(files: &mut ~[Path], path: &Path) {"}, {"sha": "5af47880c304365bc192205c87f258abf3e63a8f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -465,33 +465,33 @@ pub fn pretty_print_input(sess: Session, cfg: ast::crate_cfg, input: &input,\n }\n \n pub fn get_os(triple: &str) -> Option<session::os> {\n-    if str::contains(triple, \"win32\") ||\n-               str::contains(triple, \"mingw32\") {\n+    if triple.contains(\"win32\") ||\n+               triple.contains(\"mingw32\") {\n             Some(session::os_win32)\n-        } else if str::contains(triple, \"darwin\") {\n+        } else if triple.contains(\"darwin\") {\n             Some(session::os_macos)\n-        } else if str::contains(triple, \"android\") {\n+        } else if triple.contains(\"android\") {\n             Some(session::os_android)\n-        } else if str::contains(triple, \"linux\") {\n+        } else if triple.contains(\"linux\") {\n             Some(session::os_linux)\n-        } else if str::contains(triple, \"freebsd\") {\n+        } else if triple.contains(\"freebsd\") {\n             Some(session::os_freebsd)\n         } else { None }\n }\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n-    if str::contains(triple, \"i386\") ||\n-        str::contains(triple, \"i486\") ||\n-               str::contains(triple, \"i586\") ||\n-               str::contains(triple, \"i686\") ||\n-               str::contains(triple, \"i786\") {\n+    if triple.contains(\"i386\") ||\n+        triple.contains(\"i486\") ||\n+               triple.contains(\"i586\") ||\n+               triple.contains(\"i686\") ||\n+               triple.contains(\"i786\") {\n             Some(abi::X86)\n-        } else if str::contains(triple, \"x86_64\") {\n+        } else if triple.contains(\"x86_64\") {\n             Some(abi::X86_64)\n-        } else if str::contains(triple, \"arm\") ||\n-                      str::contains(triple, \"xscale\") {\n+        } else if triple.contains(\"arm\") ||\n+                      triple.contains(\"xscale\") {\n             Some(abi::Arm)\n-        } else if str::contains(triple, \"mips\") {\n+        } else if triple.contains(\"mips\") {\n             Some(abi::Mips)\n         } else { None }\n }"}, {"sha": "0f3a6c7629f1bbb44722fb5d5340f254727783e5", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -3099,7 +3099,7 @@ impl Resolver {\n         let import_count = imports.len();\n         if index != import_count {\n             let sn = self.session.codemap.span_to_snippet(imports[index].span);\n-            if str::contains(sn, \"::\") {\n+            if sn.contains(\"::\") {\n                 self.session.span_err(imports[index].span, \"unresolved import\");\n             } else {\n                 let err = fmt!(\"unresolved import (maybe you meant `%s::*`?)\","}, {"sha": "976344a1825cbdf4f147db0ea8081e5aa310006d", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 40, "deletions": 46, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -607,13 +607,13 @@ mod test {\n     #[test]\n     fn write_markdown_should_write_mod_headers() {\n         let markdown = render(~\"mod moo { }\");\n-        assert!(str::contains(markdown, \"# Module `moo`\"));\n+        assert!(markdown.contains(\"# Module `moo`\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_after_header() {\n         let markdown = render(~\"mod morp { }\");\n-        assert!(str::contains(markdown, \"Module `morp`\\n\\n\"));\n+        assert!(markdown.contains(\"Module `morp`\\n\\n\"));\n     }\n \n     #[test]\n@@ -669,10 +669,10 @@ mod test {\n             let (page, markdown) = po.recv();\n             match page {\n                 doc::CratePage(_) => {\n-                    assert!(str::contains(markdown, \"% Crate core\"));\n+                    assert!(markdown.contains(\"% Crate core\"));\n                 }\n                 doc::ItemPage(_) => {\n-                    assert!(str::contains(markdown, \"% Module a\"));\n+                    assert!(markdown.contains(\"% Module a\"));\n                 }\n             }\n         }\n@@ -681,7 +681,7 @@ mod test {\n     #[test]\n     fn should_write_full_path_to_mod() {\n         let markdown = render(~\"mod a { mod b { mod c { } } }\");\n-        assert!(str::contains(markdown, \"# Module `a::b::c`\"));\n+        assert!(markdown.contains(\"# Module `a::b::c`\"));\n     }\n \n     #[test]\n@@ -692,21 +692,20 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(markdown, \"#### Header\\n\\nBody\\n\\n\"));\n+        assert!(markdown.contains(\"#### Header\\n\\nBody\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_crate_description() {\n         let markdown = render(~\"#[doc = \\\"this is the crate\\\"];\");\n-        assert!(str::contains(markdown, \"this is the crate\"));\n+        assert!(markdown.contains(\"this is the crate\"));\n     }\n \n \n     #[test]\n     fn should_write_index() {\n         let markdown = render(~\"mod a { } mod b { }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n* [Module `a`](#module-a)\\n\\\n              * [Module `b`](#module-b)\\n\\n\"\n         ));\n@@ -715,20 +714,19 @@ mod test {\n     #[test]\n     fn should_write_index_brief() {\n         let markdown = render(~\"#[doc = \\\"test\\\"] mod a { }\");\n-        assert!(str::contains(markdown, \"(#module-a) - test\\n\"));\n+        assert!(markdown.contains(\"(#module-a) - test\\n\"));\n     }\n \n     #[test]\n     fn should_not_write_index_if_no_entries() {\n         let markdown = render(~\"\");\n-        assert!(!str::contains(markdown, \"\\n\\n\\n\"));\n+        assert!(!markdown.contains(\"\\n\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_index_for_foreign_mods() {\n         let markdown = render(~\"extern { fn a(); }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n* [Function `a`](#function-a)\\n\\n\"\n         ));\n     }\n@@ -737,32 +735,32 @@ mod test {\n     fn should_write_foreign_fns() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, \"test\"));\n+        assert!(markdown.contains(\"test\"));\n     }\n \n     #[test]\n     fn should_write_foreign_fn_headers() {\n         let markdown = render(\n             ~\"extern { #[doc = \\\"test\\\"] fn a(); }\");\n-        assert!(str::contains(markdown, \"## Function `a`\"));\n+        assert!(markdown.contains(\"## Function `a`\"));\n     }\n \n     #[test]\n     fn write_markdown_should_write_function_header() {\n         let markdown = render(~\"fn func() { }\");\n-        assert!(str::contains(markdown, \"## Function `func`\"));\n+        assert!(markdown.contains(\"## Function `func`\"));\n     }\n \n     #[test]\n     fn should_write_the_function_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, \"\\n    fn a()\\n\"));\n+        assert!(markdown.contains(\"\\n    fn a()\\n\"));\n     }\n \n     #[test]\n     fn should_insert_blank_line_after_fn_signature() {\n         let markdown = render(~\"#[doc = \\\"f\\\"] fn a() { }\");\n-        assert!(str::contains(markdown, \"fn a()\\n\\n\"));\n+        assert!(markdown.contains(\"fn a()\\n\\n\"));\n     }\n \n     #[test]\n@@ -783,39 +781,39 @@ mod test {\n             ]\n         };\n         let markdown = write_markdown_str(doc);\n-        assert!(str::contains(markdown, \"    line 1\\n    line 2\"));\n+        assert!(markdown.contains(\"    line 1\\n    line 2\"));\n     }\n \n     #[test]\n     fn should_leave_blank_line_between_fn_header_and_sig() {\n         let markdown = render(~\"fn a() { }\");\n-        assert!(str::contains(markdown, \"Function `a`\\n\\n    fn a()\"));\n+        assert!(markdown.contains(\"Function `a`\\n\\n    fn a()\"));\n     }\n \n     #[test]\n     fn should_write_const_header() {\n         let markdown = render(~\"static a: bool = true;\");\n-        assert!(str::contains(markdown, \"## Const `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Const `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_const_description() {\n         let markdown = render(\n             ~\"#[doc = \\\"b\\\"]\\\n               static a: bool = true;\");\n-        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_header() {\n         let markdown = render(~\"enum a { b }\");\n-        assert!(str::contains(markdown, \"## Enum `a`\\n\\n\"));\n+        assert!(markdown.contains(\"## Enum `a`\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_enum_description() {\n         let markdown = render(~\"#[doc = \\\"b\\\"] enum a { b }\");\n-        assert!(str::contains(markdown, \"\\n\\nb\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\nb\\n\\n\"));\n     }\n \n     #[test]\n@@ -824,8 +822,7 @@ mod test {\n             ~\"enum a { \\\n               #[doc = \\\"test\\\"] b, \\\n               #[doc = \\\"test\\\"] c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b` - test\\\n@@ -836,8 +833,7 @@ mod test {\n     #[test]\n     fn should_write_variant_list_without_descs() {\n         let markdown = render(~\"enum a { b, c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b`\\\n@@ -849,8 +845,7 @@ mod test {\n     fn should_write_variant_list_with_indent() {\n         let markdown = render(\n             ~\"enum a { #[doc = \\\"line 1\\\\n\\\\nline 2\\\"] b, c }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b` - line 1\\\n@@ -863,8 +858,7 @@ mod test {\n     #[test]\n     fn should_write_variant_list_with_signatures() {\n         let markdown = render(~\"enum a { b(int), #[doc = \\\"a\\\"] c(int) }\");\n-        assert!(str::contains(\n-            markdown,\n+        assert!(markdown.contains(\n             \"\\n\\n#### Variants\\n\\\n              \\n\\\n              \\n* `b(int)`\\\n@@ -875,89 +869,89 @@ mod test {\n     #[test]\n     fn should_write_trait_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"## Trait `i`\"));\n+        assert!(markdown.contains(\"## Trait `i`\"));\n     }\n \n     #[test]\n     fn should_write_trait_desc() {\n         let markdown = render(~\"#[doc = \\\"desc\\\"] trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"desc\"));\n+        assert!(markdown.contains(\"desc\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_header() {\n         let markdown = render(~\"trait i { fn a(); }\");\n-        assert!(str::contains(markdown, \"### Method `a`\"));\n+        assert!(markdown.contains(\"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_trait_method_signature() {\n         let markdown = render(~\"trait i { fn a(&self); }\");\n-        assert!(str::contains(markdown, \"\\n    fn a(&self)\"));\n+        assert!(markdown.contains(\"\\n    fn a(&self)\"));\n     }\n \n     #[test]\n     fn should_write_impl_header() {\n         let markdown = render(~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"## Implementation for `int`\"));\n+        assert!(markdown.contains(\"## Implementation for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_bounds() {\n         let markdown = render(~\"impl <T> int<T> { }\");\n-        assert!(str::contains(markdown, \"## Implementation for `int<T>` where `<T>`\"));\n+        assert!(markdown.contains(\"## Implementation for `int<T>` where `<T>`\"));\n     }\n \n     #[test]\n     fn should_write_impl_header_with_trait() {\n         let markdown = render(~\"impl j for int { fn a() { } }\");\n-        assert!(str::contains(markdown,\n+        assert!(markdown.contains(\n                               \"## Implementation of `j` for `int`\"));\n     }\n \n     #[test]\n     fn should_write_impl_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"desc\"));\n+        assert!(markdown.contains(\"desc\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_header() {\n         let markdown = render(\n             ~\"impl int { fn a() { } }\");\n-        assert!(str::contains(markdown, \"### Method `a`\"));\n+        assert!(markdown.contains(\"### Method `a`\"));\n     }\n \n     #[test]\n     fn should_write_impl_method_signature() {\n         let markdown = render(\n             ~\"impl int { fn a(&mut self) { } }\");\n-        assert!(str::contains(markdown, \"\\n    fn a(&mut self)\"));\n+        assert!(markdown.contains(\"\\n    fn a(&mut self)\"));\n     }\n \n     #[test]\n     fn should_write_type_header() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, \"## Type `t`\"));\n+        assert!(markdown.contains(\"## Type `t`\"));\n     }\n \n     #[test]\n     fn should_write_type_desc() {\n         let markdown = render(\n             ~\"#[doc = \\\"desc\\\"] type t = int;\");\n-        assert!(str::contains(markdown, \"\\n\\ndesc\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\ndesc\\n\\n\"));\n     }\n \n     #[test]\n     fn should_write_type_signature() {\n         let markdown = render(~\"type t = int;\");\n-        assert!(str::contains(markdown, \"\\n\\n    type t = int\\n\\n\"));\n+        assert!(markdown.contains(\"\\n\\n    type t = int\\n\\n\"));\n     }\n \n     #[test]\n     fn should_put_struct_header() {\n         let markdown = render(~\"struct S { field: () }\");\n-        assert!(str::contains(markdown, \"## Struct `S`\\n\\n\"));\n+        assert!(markdown.contains(\"## Struct `S`\\n\\n\"));\n     }\n }"}, {"sha": "ddc1b7dfe21e8dec18f65462bff7de59082fd0de", "filename": "src/librustdoc/sectionalize_pass.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustdoc%2Fsectionalize_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibrustdoc%2Fsectionalize_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fsectionalize_pass.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -191,9 +191,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(\n-            doc.cratemod().mods()[0].item.sections[0].header,\n-            \"Header\"));\n+        assert!(doc.cratemod().mods()[0].item.sections[0].header.contains(\"Header\"));\n     }\n \n     #[test]\n@@ -204,9 +202,7 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(str::contains(\n-            doc.cratemod().mods()[0].item.sections[0].body,\n-            \"Body\"));\n+        assert!(doc.cratemod().mods()[0].item.sections[0].body.contains(\"Body\"));\n     }\n \n     #[test]\n@@ -229,12 +225,8 @@ mod test {\n               Body\\\"]\\\n               mod a {\n }\");\n-        assert!(!str::contains(\n-            doc.cratemod().mods()[0].desc().get(),\n-            \"Header\"));\n-        assert!(!str::contains(\n-            doc.cratemod().mods()[0].desc().get(),\n-            \"Body\"));\n+        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Header\"));\n+        assert!(!doc.cratemod().mods()[0].desc().get().contains(\"Body\"));\n     }\n \n     #[test]"}, {"sha": "7ae59e524a0cec90a625e134c5600da99a7c0c0c", "filename": "src/libstd/str.rs", "status": "modified", "additions": 27, "deletions": 39, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a64e886e3c1dd38473fd7711933557f1b97a9036/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=a64e886e3c1dd38473fd7711933557f1b97a9036", "patch": "@@ -1167,30 +1167,6 @@ fn match_at<'a,'b>(haystack: &'a str, needle: &'b str, at: uint) -> bool {\n }\n \n \n-/**\n- * Returns true if one string contains another\n- *\n- * # Arguments\n- *\n- * * haystack - The string to look in\n- * * needle - The string to look for\n- */\n-pub fn contains<'a,'b>(haystack: &'a str, needle: &'b str) -> bool {\n-    haystack.find_str(needle).is_some()\n-}\n-\n-/**\n- * Returns true if a string contains a char.\n- *\n- * # Arguments\n- *\n- * * haystack - The string to look in\n- * * needle - The char to look for\n- */\n-pub fn contains_char(haystack: &str, needle: char) -> bool {\n-    haystack.find(needle).is_some()\n-}\n-\n /**\n  * Returns true if one string starts with another\n  *\n@@ -2019,15 +1995,27 @@ pub trait StrSlice<'self> {\n \n /// Extension methods for strings\n impl<'self> StrSlice<'self> for &'self str {\n-    /// Returns true if one string contains another\n+    /**\n+     * Returns true if one string contains another\n+     *\n+     * # Arguments\n+     *\n+     * * needle - The string to look for\n+     */\n     #[inline]\n     fn contains<'a>(&self, needle: &'a str) -> bool {\n-        contains(*self, needle)\n+        self.find_str(needle).is_some()\n     }\n-    /// Returns true if a string contains a char\n+    /**\n+     * Returns true if a string contains a char.\n+     *\n+     * # Arguments\n+     *\n+     * * needle - The char to look for\n+     */\n     #[inline]\n     fn contains_char(&self, needle: char) -> bool {\n-        contains_char(*self, needle)\n+        self.find(needle).is_some()\n     }\n \n     #[inline]\n@@ -3060,19 +3048,19 @@ mod tests {\n \n     #[test]\n     fn test_contains() {\n-        assert!(contains(\"abcde\", \"bcd\"));\n-        assert!(contains(\"abcde\", \"abcd\"));\n-        assert!(contains(\"abcde\", \"bcde\"));\n-        assert!(contains(\"abcde\", \"\"));\n-        assert!(contains(\"\", \"\"));\n-        assert!(!contains(\"abcde\", \"def\"));\n-        assert!(!contains(\"\", \"a\"));\n+        assert!(\"abcde\".contains(\"bcd\"));\n+        assert!(\"abcde\".contains(\"abcd\"));\n+        assert!(\"abcde\".contains(\"bcde\"));\n+        assert!(\"abcde\".contains(\"\"));\n+        assert!(\"\".contains(\"\"));\n+        assert!(!\"abcde\".contains(\"def\"));\n+        assert!(!\"\".contains(\"a\"));\n \n         let data = ~\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-        assert!(contains(data, \"\u0e1b\u0e23\u0e30\u0e40\"));\n-        assert!(contains(data, \"\u0e30\u0e40\"));\n-        assert!(contains(data, \"\u4e2d\u534e\"));\n-        assert!(!contains(data, \"\u0e44\u0e17\u534e\"));\n+        assert!(data.contains(\"\u0e1b\u0e23\u0e30\u0e40\"));\n+        assert!(data.contains(\"\u0e30\u0e40\"));\n+        assert!(data.contains(\"\u4e2d\u534e\"));\n+        assert!(!data.contains(\"\u0e44\u0e17\u534e\"));\n     }\n \n     #[test]"}]}