{"sha": "e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUwZjU5ODBlYWQ0Zjg4ZTc4YTQ3ZjRkODRkYTRkYzExNDcyZjY2YmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-30T07:57:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-30T07:57:14Z"}, "message": "Auto merge of #21351 - eddyb:x-coerce--a-new-hope, r=nikomatsakis\n\nCoercions will now attempt to autoderef as needed before reborrowing.\r\nThis includes overloaded `Deref`, e.g. `&Rc<T>` coerces to `&T`, and\r\n`DerefMut`, e.g. `&mut Vec<T>` coerces to `&mut [T]` (in addition to `&[T]`).\r\nCloses #21432.", "tree": {"sha": "cac24017a222a61c4f9e468c5689387475798853", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac24017a222a61c4f9e468c5689387475798853"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "html_url": "https://github.com/rust-lang/rust/commit/e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52c74e63dacd49017b19330e0cbecbac0a3fe62e", "url": "https://api.github.com/repos/rust-lang/rust/commits/52c74e63dacd49017b19330e0cbecbac0a3fe62e", "html_url": "https://github.com/rust-lang/rust/commit/52c74e63dacd49017b19330e0cbecbac0a3fe62e"}, {"sha": "ae076e1e3b037e557b613d97698a9f28a1683d8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/ae076e1e3b037e557b613d97698a9f28a1683d8b", "html_url": "https://github.com/rust-lang/rust/commit/ae076e1e3b037e557b613d97698a9f28a1683d8b"}], "stats": {"total": 636, "additions": 343, "deletions": 293}, "files": [{"sha": "1665966a5e5f519099389f6de3a654cd1768d73e", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 13, "deletions": 30, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -33,12 +33,10 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::codemap;\n use syntax::codemap::Span;\n-use util::common::indent;\n use util::nodemap::FnvHashMap;\n use util::ppaux::{ty_to_string};\n use util::ppaux::{Repr, UserString};\n \n-use self::coercion::Coerce;\n use self::combine::{Combine, Combineable, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n@@ -47,7 +45,6 @@ use self::lub::Lub;\n use self::unify::{UnificationTable, InferCtxtMethodsForSimplyUnifiableTypes};\n use self::error_reporting::ErrorReporting;\n \n-pub mod coercion;\n pub mod combine;\n pub mod doc;\n pub mod equate;\n@@ -68,7 +65,6 @@ pub type Bound<T> = Option<T>;\n pub type cres<'tcx, T> = Result<T,ty::type_err<'tcx>>; // \"combine result\"\n pub type ures<'tcx> = cres<'tcx, ()>; // \"unify result\"\n pub type fres<T> = Result<T, fixup_err>; // \"fixup result\"\n-pub type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n pub struct InferCtxt<'a, 'tcx: 'a> {\n     pub tcx: &'a ty::ctxt<'tcx>,\n@@ -409,24 +405,6 @@ fn expected_found<T>(a_is_expected: bool,\n     }\n }\n \n-pub fn mk_coercety<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                             a_is_expected: bool,\n-                             origin: TypeOrigin,\n-                             a: Ty<'tcx>,\n-                             b: Ty<'tcx>)\n-                             -> CoerceResult<'tcx> {\n-    debug!(\"mk_coercety({} -> {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    indent(|| {\n-        cx.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n-            Coerce(cx.combine_fields(a_is_expected, trace)).tys(a, b)\n-        })\n-    })\n-}\n-\n trait then<'tcx> {\n     fn then<T, F>(&self, f: F) -> Result<T, ty::type_err<'tcx>> where\n         T: Clone,\n@@ -689,10 +667,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     {\n         debug!(\"sub_types({} <: {})\", a.repr(self.tcx), b.repr(self.tcx));\n         self.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n+            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.sub(a_is_expected, trace).tys(a, b).to_ures()\n         })\n     }\n@@ -705,10 +680,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     -> ures<'tcx>\n     {\n         self.commit_if_ok(|| {\n-            let trace = TypeTrace {\n-                origin: origin,\n-                values: Types(expected_found(a_is_expected, a, b))\n-            };\n+            let trace = TypeTrace::types(origin, a_is_expected, a, b);\n             self.equate(a_is_expected, trace).tys(a, b).to_ures()\n         })\n     }\n@@ -1118,6 +1090,17 @@ impl<'tcx> TypeTrace<'tcx> {\n         self.origin.span()\n     }\n \n+    pub fn types(origin: TypeOrigin,\n+                 a_is_expected: bool,\n+                 a: Ty<'tcx>,\n+                 b: Ty<'tcx>)\n+                 -> TypeTrace<'tcx> {\n+        TypeTrace {\n+            origin: origin,\n+            values: Types(expected_found(a_is_expected, a, b))\n+        }\n+    }\n+\n     pub fn dummy(tcx: &ty::ctxt<'tcx>) -> TypeTrace<'tcx> {\n         TypeTrace {\n             origin: Misc(codemap::DUMMY_SP),"}, {"sha": "e37c1ab7f0cb7d77ce722276bc0d13bd12d7b5b8", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -21,6 +21,7 @@ use super::LvaluePreference;\n use super::method;\n use super::structurally_resolved_type;\n use super::TupleArgumentsFlag;\n+use super::UnresolvedTypeAction;\n use super::write_call;\n \n use middle::infer;\n@@ -77,6 +78,7 @@ pub fn check_call<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                   callee_expr.span,\n                   original_callee_ty,\n                   Some(callee_expr),\n+                  UnresolvedTypeAction::Error,\n                   LvaluePreference::NoPreference,\n                   |adj_ty, idx| {\n                       let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };"}, {"sha": "8bac89ac1843fb357d16e1957b57230c9ea105be", "filename": "src/librustc_typeck/check/coercion.rs", "status": "renamed", "additions": 126, "deletions": 202, "changes": 328, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -60,34 +60,49 @@\n //! sort of a minor point so I've opted to leave it for later---after all\n //! we may want to adjust precisely when coercions occur.\n \n-use super::{CoerceResult, Coercion};\n-use super::combine::{CombineFields, Combine};\n-use super::sub::Sub;\n+use check::{autoderef, FnCtxt, NoPreference, PreferMutLvalue, UnresolvedTypeAction};\n \n+use middle::infer::{self, cres, Coercion, TypeTrace};\n+use middle::infer::combine::Combine;\n+use middle::infer::sub::Sub;\n use middle::subst;\n use middle::ty::{AutoPtr, AutoDerefRef, AdjustDerefRef, AutoUnsize, AutoUnsafe};\n-use middle::ty::{mt};\n-use middle::ty::{self, Ty};\n+use middle::ty::{self, mt, Ty};\n+use util::common::indent;\n use util::ppaux;\n use util::ppaux::Repr;\n \n use syntax::ast;\n \n-// Note: Coerce is not actually a combiner, in that it does not\n-// conform to the same interface, though it performs a similar\n-// function.\n-pub struct Coerce<'f, 'tcx: 'f>(pub CombineFields<'f, 'tcx>);\n+struct Coerce<'a, 'tcx: 'a> {\n+    fcx: &'a FnCtxt<'a, 'tcx>,\n+    trace: TypeTrace<'tcx>\n+}\n+\n+type CoerceResult<'tcx> = cres<'tcx, Option<ty::AutoAdjustment<'tcx>>>;\n \n impl<'f, 'tcx> Coerce<'f, 'tcx> {\n-    pub fn get_ref<'a>(&'a self) -> &'a CombineFields<'f, 'tcx> {\n-        let Coerce(ref v) = *self; v\n+    fn tcx(&self) -> &ty::ctxt<'tcx> {\n+        self.fcx.tcx()\n     }\n \n-    fn tcx(&self) -> &ty::ctxt<'tcx> {\n-        self.get_ref().infcx.tcx\n+    fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+        let sub = Sub(self.fcx.infcx().combine_fields(false, self.trace.clone()));\n+        try!(sub.tys(a, b));\n+        Ok(None) // No coercion required.\n+    }\n+\n+    fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n+        F: FnOnce(Ty<'tcx>) -> T,\n+    {\n+        f(self.fcx.infcx().shallow_resolve(a))\n     }\n \n-    pub fn tys(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n+    fn coerce(&self,\n+              expr_a: &ast::Expr,\n+              a: Ty<'tcx>,\n+              b: Ty<'tcx>)\n+              -> CoerceResult<'tcx> {\n         debug!(\"Coerce.tys({} => {})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -106,57 +121,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // See above for details.\n         match b.sty {\n             ty::ty_ptr(mt_b) => {\n-                match mt_b.ty.sty {\n-                    ty::ty_str => {\n-                        return self.unpack_actual_value(a, |a| {\n-                            self.coerce_unsafe_ptr(a, b, ast::MutImmutable)\n-                        });\n-                    }\n-\n-                    ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |a| {\n-                            self.coerce_unsafe_object(a, b, mt_b.mutbl)\n-                        });\n-\n-                        match result {\n-                            Ok(t) => return Ok(t),\n-                            Err(..) => {}\n-                        }\n-                    }\n-\n-                    _ => {\n-                        return self.unpack_actual_value(a, |a| {\n-                            self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n-                        });\n-                    }\n-                };\n+                return self.unpack_actual_value(a, |a| {\n+                    self.coerce_unsafe_ptr(a, b, mt_b.mutbl)\n+                });\n             }\n \n             ty::ty_rptr(_, mt_b) => {\n-                match mt_b.ty.sty {\n-                    ty::ty_str => {\n-                        return self.unpack_actual_value(a, |a| {\n-                            self.coerce_borrowed_pointer(a, b, ast::MutImmutable)\n-                        });\n-                    }\n-\n-                    ty::ty_trait(..) => {\n-                        let result = self.unpack_actual_value(a, |a| {\n-                            self.coerce_borrowed_object(a, b, mt_b.mutbl)\n-                        });\n-\n-                        match result {\n-                            Ok(t) => return Ok(t),\n-                            Err(..) => {}\n-                        }\n-                    }\n-\n-                    _ => {\n-                        return self.unpack_actual_value(a, |a| {\n-                            self.coerce_borrowed_pointer(a, b, mt_b.mutbl)\n-                        });\n-                    }\n-                };\n+                return self.unpack_actual_value(a, |a| {\n+                    self.coerce_borrowed_pointer(expr_a, a, b, mt_b.mutbl)\n+                });\n             }\n \n             _ => {}\n@@ -178,25 +151,15 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn subtype(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> CoerceResult<'tcx> {\n-        match Sub(self.get_ref().clone()).tys(a, b) {\n-            Ok(_) => Ok(None),         // No coercion required.\n-            Err(ref e) => Err(*e)\n-        }\n-    }\n-\n-    pub fn unpack_actual_value<T, F>(&self, a: Ty<'tcx>, f: F) -> T where\n-        F: FnOnce(Ty<'tcx>) -> T,\n-    {\n-        f(self.get_ref().infcx.shallow_resolve(a))\n-    }\n-\n-    // ~T -> &T or &mut T -> &T (including where T = [U] or str)\n-    pub fn coerce_borrowed_pointer(&self,\n-                                   a: Ty<'tcx>,\n-                                   b: Ty<'tcx>,\n-                                   mutbl_b: ast::Mutability)\n-                                   -> CoerceResult<'tcx> {\n+    /// Reborrows `&mut A` to `&mut B` and `&(mut) A` to `&B`.\n+    /// To match `A` with `B`, autoderef will be performed,\n+    /// calling `deref`/`deref_mut` where necessary.\n+    fn coerce_borrowed_pointer(&self,\n+                               expr_a: &ast::Expr,\n+                               a: Ty<'tcx>,\n+                               b: Ty<'tcx>,\n+                               mutbl_b: ast::Mutability)\n+                               -> CoerceResult<'tcx> {\n         debug!(\"coerce_borrowed_pointer(a={}, b={})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -207,32 +170,62 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // to type check, we will construct the type that `&M*expr` would\n         // yield.\n \n-        let sub = Sub(self.get_ref().clone());\n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n-\n-        let inner_ty = match a.sty {\n-            ty::ty_uniq(_) => return Err(ty::terr_mismatch),\n+        match a.sty {\n             ty::ty_rptr(_, mt_a) => {\n                 if !can_coerce_mutbls(mt_a.mutbl, mutbl_b) {\n                     return Err(ty::terr_mutability);\n                 }\n-                mt_a.ty\n-            }\n-            _ => {\n-                return self.subtype(a, b);\n             }\n-        };\n+            _ => return self.subtype(a, b)\n+        }\n \n-        let a_borrowed = ty::mk_rptr(self.tcx(),\n-                                     self.tcx().mk_region(r_borrow),\n-                                     mt {ty: inner_ty, mutbl: mutbl_b});\n-        try!(sub.tys(a_borrowed, b));\n+        let coercion = Coercion(self.trace.clone());\n+        let r_borrow = self.fcx.infcx().next_region_var(coercion);\n+        let autoref = Some(AutoPtr(r_borrow, mutbl_b, None));\n \n-        Ok(Some(AdjustDerefRef(AutoDerefRef {\n-            autoderefs: 1,\n-            autoref: Some(AutoPtr(r_borrow, mutbl_b, None))\n-        })))\n+        let r_borrow = self.tcx().mk_region(r_borrow);\n+        let lvalue_pref = match mutbl_b {\n+            ast::MutMutable => PreferMutLvalue,\n+            ast::MutImmutable => NoPreference\n+        };\n+        let mut first_error = None;\n+        let (_, autoderefs, success) = autoderef(self.fcx,\n+                                                 expr_a.span,\n+                                                 a,\n+                                                 Some(expr_a),\n+                                                 UnresolvedTypeAction::Ignore,\n+                                                 lvalue_pref,\n+                                                 |inner_ty, autoderef| {\n+            if autoderef == 0 {\n+                // Don't let this pass, otherwise it would cause\n+                // &T to autoref to &&T.\n+                return None;\n+            }\n+            let ty = ty::mk_rptr(self.tcx(), r_borrow,\n+                                 mt {ty: inner_ty, mutbl: mutbl_b});\n+            if let Err(err) = self.fcx.infcx().try(|_| self.subtype(ty, b)) {\n+                if first_error.is_none() {\n+                    first_error = Some(err);\n+                }\n+                None\n+            } else {\n+                Some(())\n+            }\n+        });\n+\n+        match success {\n+            Some(_) => {\n+                Ok(Some(AdjustDerefRef(AutoDerefRef {\n+                    autoderefs: autoderefs,\n+                    autoref: autoref\n+                })))\n+            }\n+            None => {\n+                // Return original error as if overloaded deref was never\n+                // attempted, to avoid irrelevant/confusing error messages.\n+                Err(first_error.expect(\"coerce_borrowed_pointer failed with no error?\"))\n+            }\n+        }\n     }\n \n \n@@ -252,8 +245,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         // we can't unify [T] with U. But to properly support DST, we need to allow\n         // that, at which point we will need extra checks on b here.\n \n-        let sub = Sub(self.get_ref().clone());\n-\n         match (&a.sty, &b.sty) {\n             (&ty::ty_rptr(_, ty::mt{ty: t_a, mutbl: mutbl_a}), &ty::ty_rptr(_, mt_b)) => {\n                 self.unpack_actual_value(t_a, |a| {\n@@ -263,12 +254,12 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 return Err(ty::terr_mutability);\n                             }\n \n-                            let coercion = Coercion(self.get_ref().trace.clone());\n-                            let r_borrow = self.get_ref().infcx.next_region_var(coercion);\n+                            let coercion = Coercion(self.trace.clone());\n+                            let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                             let ty = ty::mk_rptr(self.tcx(),\n                                                  self.tcx().mk_region(r_borrow),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -291,7 +282,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n \n                             let ty = ty::mk_ptr(self.tcx(),\n                                                  ty::mt{ty: ty, mutbl: mt_b.mutbl});\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoPtr(AutoUnsize({:?})))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -309,7 +300,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     match self.unsize_ty(t_a, a, t_b) {\n                         Some((ty, kind)) => {\n                             let ty = ty::mk_uniq(self.tcx(), ty);\n-                            try!(self.get_ref().infcx.try(|_| sub.tys(ty, b)));\n+                            try!(self.fcx.infcx().try(|_| self.subtype(ty, b)));\n                             debug!(\"Success, coerced with AutoDerefRef(1, \\\n                                     AutoUnsizeUniq({:?}))\", kind);\n                             Ok(Some(AdjustDerefRef(AutoDerefRef {\n@@ -361,12 +352,10 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     let ty_substs_b = substs_b.types.get_slice(subst::TypeSpace);\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n-                    let sub = Sub(self.get_ref().clone());\n-\n                     let mut result = None;\n                     let mut tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n                     for (i, (tp_a, tp_b)) in tps {\n-                        if self.get_ref().infcx.try(|_| sub.tys(*tp_a, *tp_b)).is_ok() {\n+                        if self.fcx.infcx().try(|_| self.subtype(*tp_a, *tp_b)).is_ok() {\n                             continue;\n                         }\n                         match\n@@ -379,7 +368,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                                 let mut new_substs = substs_a.clone();\n                                 new_substs.types.get_mut_slice(subst::TypeSpace)[i] = new_tp;\n                                 let ty = ty::mk_struct(tcx, did_a, tcx.mk_substs(new_substs));\n-                                if self.get_ref().infcx.try(|_| sub.tys(ty, ty_b)).is_err() {\n+                                if self.fcx.infcx().try(|_| self.subtype(ty, ty_b)).is_err() {\n                                     debug!(\"Unsized type parameter '{}', but still \\\n                                             could not match types {} and {}\",\n                                            ppaux::ty_to_string(tcx, *tp_a),\n@@ -404,92 +393,6 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         )\n     }\n \n-    fn coerce_borrowed_object(&self,\n-                              a: Ty<'tcx>,\n-                              b: Ty<'tcx>,\n-                              b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        debug!(\"coerce_borrowed_object(a={}, b={}, b_mutbl={:?})\",\n-               a.repr(tcx),\n-               b.repr(tcx), b_mutbl);\n-\n-        let coercion = Coercion(self.get_ref().trace.clone());\n-        let r_a = self.get_ref().infcx.next_region_var(coercion);\n-\n-        self.coerce_object(a, b, b_mutbl,\n-                           |tr| ty::mk_rptr(tcx, tcx.mk_region(r_a),\n-                                            ty::mt{ mutbl: b_mutbl, ty: tr }),\n-                           || AutoPtr(r_a, b_mutbl, None))\n-    }\n-\n-    fn coerce_unsafe_object(&self,\n-                            a: Ty<'tcx>,\n-                            b: Ty<'tcx>,\n-                            b_mutbl: ast::Mutability) -> CoerceResult<'tcx>\n-    {\n-        let tcx = self.tcx();\n-\n-        debug!(\"coerce_unsafe_object(a={}, b={}, b_mutbl={:?})\",\n-               a.repr(tcx),\n-               b.repr(tcx), b_mutbl);\n-\n-        self.coerce_object(a, b, b_mutbl,\n-                           |tr| ty::mk_ptr(tcx, ty::mt{ mutbl: b_mutbl, ty: tr }),\n-                           || AutoUnsafe(b_mutbl, None))\n-    }\n-\n-    fn coerce_object<F, G>(&self,\n-                           a: Ty<'tcx>,\n-                           b: Ty<'tcx>,\n-                           b_mutbl: ast::Mutability,\n-                           mk_ty: F,\n-                           mk_adjust: G) -> CoerceResult<'tcx> where\n-        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n-        G: FnOnce() -> ty::AutoRef<'tcx>,\n-    {\n-        let tcx = self.tcx();\n-\n-        match a.sty {\n-            ty::ty_rptr(_, ty::mt{ty, mutbl}) => match ty.sty {\n-                ty::ty_trait(box ty::TyTrait { ref principal, ref bounds }) => {\n-                    debug!(\"mutbl={:?} b_mutbl={:?}\", mutbl, b_mutbl);\n-                    let tr = ty::mk_trait(tcx, principal.clone(), bounds.clone());\n-                    try!(self.subtype(mk_ty(tr), b));\n-                    Ok(Some(AdjustDerefRef(AutoDerefRef {\n-                        autoderefs: 1,\n-                        autoref: Some(mk_adjust())\n-                    })))\n-                }\n-                _ => {\n-                    self.subtype(a, b)\n-                }\n-            },\n-            _ => {\n-                self.subtype(a, b)\n-            }\n-        }\n-    }\n-\n-    pub fn coerce_borrowed_fn(&self,\n-                              a: Ty<'tcx>,\n-                              b: Ty<'tcx>)\n-                              -> CoerceResult<'tcx> {\n-        debug!(\"coerce_borrowed_fn(a={}, b={})\",\n-               a.repr(self.tcx()),\n-               b.repr(self.tcx()));\n-\n-        match a.sty {\n-            ty::ty_bare_fn(Some(a_def_id), f) => {\n-                self.coerce_from_fn_item(a, a_def_id, f, b)\n-            }\n-            _ => {\n-                self.subtype(a, b)\n-            }\n-        }\n-    }\n-\n     fn coerce_from_fn_item(&self,\n                            a: Ty<'tcx>,\n                            fn_def_id_a: ast::DefId,\n@@ -518,11 +421,11 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         })\n     }\n \n-    pub fn coerce_unsafe_ptr(&self,\n-                             a: Ty<'tcx>,\n-                             b: Ty<'tcx>,\n-                             mutbl_b: ast::Mutability)\n-                             -> CoerceResult<'tcx> {\n+    fn coerce_unsafe_ptr(&self,\n+                         a: Ty<'tcx>,\n+                         b: Ty<'tcx>,\n+                         mutbl_b: ast::Mutability)\n+                         -> CoerceResult<'tcx> {\n         debug!(\"coerce_unsafe_ptr(a={}, b={})\",\n                a.repr(self.tcx()),\n                b.repr(self.tcx()));\n@@ -551,6 +454,27 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n     }\n }\n \n+pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                             expr: &ast::Expr,\n+                             a: Ty<'tcx>,\n+                             b: Ty<'tcx>)\n+                             -> cres<'tcx, ()> {\n+    debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n+    let adjustment = try!(indent(|| {\n+        fcx.infcx().commit_if_ok(|| {\n+            let origin = infer::ExprAssignable(expr.span);\n+            Coerce {\n+                fcx: fcx,\n+                trace: infer::TypeTrace::types(origin, false, a, b)\n+            }.coerce(expr, a, b)\n+        })\n+    }));\n+    if let Some(adjustment) = adjustment {\n+        fcx.write_adjustment(expr.id, expr.span, adjustment);\n+    }\n+    Ok(())\n+}\n+\n fn can_coerce_mutbls(from_mutbl: ast::Mutability,\n                      to_mutbl: ast::Mutability)\n                      -> bool {", "previous_filename": "src/librustc/middle/infer/coercion.rs"}, {"sha": "6f2d0cb3667418023cc69a0d954305d84bab85cb", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use check::FnCtxt;\n+use check::{coercion, FnCtxt};\n use middle::ty::{self, Ty};\n use middle::infer;\n \n@@ -62,7 +62,7 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n            expr_ty.repr(fcx.ccx.tcx));\n     let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n     let expected = fcx.resolve_type_vars_if_possible(expected);\n-    match fcx.mk_assignty(expr, expr_ty, expected) {\n+    match coercion::mk_assignty(fcx, expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {\n         fcx.report_mismatched_types(sp, expected, expr_ty, err);"}, {"sha": "56a32186c9eac2040ad9c910ef275fb2e013cba7", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -11,6 +11,7 @@\n use super::probe;\n \n use check::{self, FnCtxt, NoPreference, PreferMutLvalue, callee, demand};\n+use check::UnresolvedTypeAction;\n use middle::mem_categorization::Typer;\n use middle::subst::{self};\n use middle::traits;\n@@ -141,10 +142,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Commit the autoderefs by calling `autoderef again, but this\n         // time writing the results into the various tables.\n-        let (autoderefd_ty, n, result) =\n-            check::autoderef(\n-                self.fcx, self.span, unadjusted_self_ty, Some(self.self_expr), NoPreference,\n-                |_, n| if n == auto_deref_ref.autoderefs { Some(()) } else { None });\n+        let (autoderefd_ty, n, result) = check::autoderef(self.fcx,\n+                                                          self.span,\n+                                                          unadjusted_self_ty,\n+                                                          Some(self.self_expr),\n+                                                          UnresolvedTypeAction::Error,\n+                                                          NoPreference,\n+                                                          |_, n| {\n+            if n == auto_deref_ref.autoderefs {\n+                Some(())\n+            } else {\n+                None\n+            }\n+        });\n         assert_eq!(n, auto_deref_ref.autoderefs);\n         assert_eq!(result, Some(()));\n \n@@ -302,15 +312,18 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // yield an object-type (e.g., `&Object` or `Box<Object>`\n         // etc).\n \n-        let (_, _, result) =\n-            check::autoderef(\n-                self.fcx, self.span, self_ty, None, NoPreference,\n-                |ty, _| {\n-                    match ty.sty {\n-                        ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n-                        _ => None,\n-                    }\n-                });\n+        let (_, _, result) = check::autoderef(self.fcx,\n+                                              self.span,\n+                                              self_ty,\n+                                              None,\n+                                              UnresolvedTypeAction::Error,\n+                                              NoPreference,\n+                                              |ty, _| {\n+            match ty.sty {\n+                ty::ty_trait(ref data) => Some(closure(self, ty, &**data)),\n+                _ => None,\n+            }\n+        });\n \n         match result {\n             Some(r) => r,\n@@ -517,6 +530,7 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n                                  expr.span,\n                                  self.fcx.expr_ty(expr),\n                                  Some(expr),\n+                                 UnresolvedTypeAction::Error,\n                                  PreferMutLvalue,\n                                  |_, autoderefs| {\n                                      if autoderefs == autoderef_count + 1 {"}, {"sha": "2e366f4450744b443485a6edf85d7599bc2ac672", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -14,7 +14,7 @@ use super::{CandidateSource,ImplSource,TraitSource};\n use super::suggest;\n \n use check;\n-use check::{FnCtxt, NoPreference};\n+use check::{FnCtxt, NoPreference, UnresolvedTypeAction};\n use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n@@ -169,16 +169,19 @@ fn create_steps<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                           -> Option<Vec<CandidateStep<'tcx>>> {\n     let mut steps = Vec::new();\n \n-    let (fully_dereferenced_ty, dereferences, _) =\n-        check::autoderef(\n-            fcx, span, self_ty, None, NoPreference,\n-            |t, d| {\n-                let adjustment = AutoDeref(d);\n-                steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n-                None::<()> // keep iterating until we can't anymore\n-            });\n-\n-    match fully_dereferenced_ty.sty {\n+    let (final_ty, dereferences, _) = check::autoderef(fcx,\n+                                                       span,\n+                                                       self_ty,\n+                                                       None,\n+                                                       UnresolvedTypeAction::Error,\n+                                                       NoPreference,\n+                                                       |t, d| {\n+        let adjustment = AutoDeref(d);\n+        steps.push(CandidateStep { self_ty: t, adjustment: adjustment });\n+        None::<()> // keep iterating until we can't anymore\n+    });\n+\n+    match final_ty.sty {\n         ty::ty_vec(elem_ty, Some(len)) => {\n             steps.push(CandidateStep {\n                 self_ty: ty::mk_vec(fcx.tcx(), elem_ty, None),"}, {"sha": "1f04cab572a4be2774f4b5fc2bee15cedff176a0", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 50, "deletions": 30, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -132,6 +132,7 @@ pub mod vtable;\n pub mod writeback;\n pub mod regionmanip;\n pub mod regionck;\n+pub mod coercion;\n pub mod demand;\n pub mod method;\n mod upvar;\n@@ -1725,25 +1726,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         infer::mk_subty(self.infcx(), a_is_expected, origin, sub, sup)\n     }\n \n-    pub fn mk_assignty(&self,\n-                       expr: &ast::Expr,\n-                       sub: Ty<'tcx>,\n-                       sup: Ty<'tcx>)\n-                       -> Result<(), ty::type_err<'tcx>> {\n-        match infer::mk_coercety(self.infcx(),\n-                                 false,\n-                                 infer::ExprAssignable(expr.span),\n-                                 sub,\n-                                 sup) {\n-            Ok(None) => Ok(()),\n-            Err(ref e) => Err((*e)),\n-            Ok(Some(adjustment)) => {\n-                self.write_adjustment(expr.id, expr.span, adjustment);\n-                Ok(())\n-            }\n-        }\n-    }\n-\n     pub fn mk_eqty(&self,\n                    a_is_expected: bool,\n                    origin: infer::TypeOrigin,\n@@ -1883,6 +1865,17 @@ pub enum LvaluePreference {\n     NoPreference\n }\n \n+/// Whether `autoderef` requires types to resolve.\n+#[derive(Copy, Show, PartialEq, Eq)]\n+pub enum UnresolvedTypeAction {\n+    /// Produce an error and return `ty_err` whenever a type cannot\n+    /// be resolved (i.e. it is `ty_infer`).\n+    Error,\n+    /// Go on without emitting any errors, and return the unresolved\n+    /// type. Useful for probing, e.g. in coercions.\n+    Ignore\n+}\n+\n /// Executes an autoderef loop for the type `t`. At each step, invokes `should_stop` to decide\n /// whether to terminate the loop. Returns the final type and number of derefs that it performed.\n ///\n@@ -1892,6 +1885,7 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                  sp: Span,\n                                  base_ty: Ty<'tcx>,\n                                  opt_expr: Option<&ast::Expr>,\n+                                 unresolved_type_action: UnresolvedTypeAction,\n                                  mut lvalue_pref: LvaluePreference,\n                                  mut should_stop: F)\n                                  -> (Ty<'tcx>, uint, Option<T>)\n@@ -1904,11 +1898,22 @@ pub fn autoderef<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n     let mut t = base_ty;\n     for autoderefs in 0..fcx.tcx().sess.recursion_limit.get() {\n-        let resolved_t = structurally_resolved_type(fcx, sp, t);\n-\n-        if ty::type_is_error(resolved_t) {\n-            return (resolved_t, autoderefs, None);\n-        }\n+        let resolved_t = match unresolved_type_action {\n+            UnresolvedTypeAction::Error => {\n+                let resolved_t = structurally_resolved_type(fcx, sp, t);\n+                if ty::type_is_error(resolved_t) {\n+                    return (resolved_t, autoderefs, None);\n+                }\n+                resolved_t\n+            }\n+            UnresolvedTypeAction::Ignore => {\n+                // We can continue even when the type cannot be resolved\n+                // (i.e. it is an inference variable) because `ty::deref`\n+                // and `try_overloaded_deref` both simply return `None`\n+                // in such a case without producing spurious errors.\n+                fcx.resolve_type_vars_if_possible(t)\n+            }\n+        };\n \n         match should_stop(resolved_t, autoderefs) {\n             Some(x) => return (resolved_t, autoderefs, Some(x)),\n@@ -2029,8 +2034,13 @@ fn autoderef_for_index<'a, 'tcx, T, F>(fcx: &FnCtxt<'a, 'tcx>,\n     // autoderef that normal method probing does. They could likely be\n     // consolidated.\n \n-    let (ty, autoderefs, final_mt) =\n-        autoderef(fcx, base_expr.span, base_ty, Some(base_expr), lvalue_pref, |adj_ty, idx| {\n+    let (ty, autoderefs, final_mt) = autoderef(fcx,\n+                                               base_expr.span,\n+                                               base_ty,\n+                                               Some(base_expr),\n+                                               UnresolvedTypeAction::Error,\n+                                               lvalue_pref,\n+                                               |adj_ty, idx| {\n             let autoderefref = ty::AutoDerefRef { autoderefs: idx, autoref: None };\n             step(adj_ty, autoderefref)\n         });\n@@ -3071,8 +3081,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expr_t = structurally_resolved_type(fcx, expr.span,\n                                                 fcx.expr_ty(base));\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n-        let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n+        let (_, autoderefs, field_ty) = autoderef(fcx,\n+                                                  expr.span,\n+                                                  expr_t,\n+                                                  Some(base),\n+                                                  UnresolvedTypeAction::Error,\n+                                                  lvalue_pref,\n+                                                  |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n@@ -3164,8 +3179,13 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                 fcx.expr_ty(base));\n         let mut tuple_like = false;\n         // FIXME(eddyb) #12808 Integrate privacy into this auto-deref loop.\n-        let (_, autoderefs, field_ty) =\n-            autoderef(fcx, expr.span, expr_t, Some(base), lvalue_pref, |base_t, _| {\n+        let (_, autoderefs, field_ty) = autoderef(fcx,\n+                                                  expr.span,\n+                                                  expr_t,\n+                                                  Some(base),\n+                                                  UnresolvedTypeAction::Error,\n+                                                  lvalue_pref,\n+                                                  |base_t, _| {\n                 match base_t.sty {\n                     ty::ty_struct(base_id, substs) => {\n                         tuple_like = ty::is_tuple_struct(tcx, base_id);"}, {"sha": "14fbc34c43bb491ab7aed4247ce64e7dc216bf1e", "filename": "src/test/compile-fail/coerce-overloaded-autoderef.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoerce-overloaded-autoderef.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -0,0 +1,40 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn borrow_mut<T>(x: &mut T) -> &mut T { x }\n+fn borrow<T>(x: &T) -> &T { x }\n+\n+fn borrow_mut2<T>(_: &mut T, _: &mut T) {}\n+fn borrow2<T>(_: &mut T, _: &T) {}\n+\n+fn double_mut_borrow<T>(x: &mut Box<T>) {\n+    let y = borrow_mut(x);\n+    let z = borrow_mut(x);\n+    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+}\n+\n+fn double_imm_borrow(x: &mut Box<i32>) {\n+    let y = borrow(x);\n+    let z = borrow(x);\n+    **x += 1;\n+    //~^ ERROR cannot assign to `**x` because it is borrowed\n+}\n+\n+fn double_mut_borrow2<T>(x: &mut Box<T>) {\n+    borrow_mut2(x, x);\n+    //~^ ERROR cannot borrow `*x` as mutable more than once at a time\n+}\n+\n+fn double_borrow2<T>(x: &mut Box<T>) {\n+    borrow2(x, x);\n+    //~^ ERROR cannot borrow `*x` as immutable because it is also borrowed as mutable\n+}\n+\n+pub fn main() {}"}, {"sha": "98b9e453889c1deb6cdf4dd425b25644e7e24de9", "filename": "src/test/compile-fail/method-self-arg-1.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-self-arg-1.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -23,11 +23,6 @@ fn main() {\n                  //~| found `Foo`\n                  //~| expected &-ptr\n                  //~| found struct `Foo`\n-    Foo::bar(&&x); //~  ERROR mismatched types\n-                   //~| expected `&Foo`\n-                   //~| found `&&Foo`\n-                   //~| expected struct `Foo`\n-                   //~| found &-ptr\n     Foo::bar(&42is); //~  ERROR mismatched types\n                      //~| expected `&Foo`\n                      //~| found `&isize`"}, {"sha": "ae4db40411553d4efb4f165f9e97218c76d25b5c", "filename": "src/test/run-pass/coerce-overloaded-autoderef.rs", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e0f5980ead4f88e78a47f4d84da4dc11472f66ba/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-overloaded-autoderef.rs?ref=e0f5980ead4f88e78a47f4d84da4dc11472f66ba", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::rc::Rc;\n+\n+// Examples from the \"deref coercions\" RFC, at rust-lang/rfcs#241.\n+\n+fn use_ref<T>(_: &T) {}\n+fn use_mut<T>(_: &mut T) {}\n+\n+fn use_rc<T>(t: Rc<T>) {\n+    use_ref(&*t);  // what you have to write today\n+    use_ref(&t);   // what you'd be able to write\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_mut_box<T>(mut t: &mut Box<T>) {\n+    use_mut(&mut *t); // what you have to write today\n+    use_mut(t);       // what you'd be able to write\n+    use_mut(&mut &mut &mut t);\n+\n+    use_ref(&*t);      // what you have to write today\n+    use_ref(t);        // what you'd be able to write\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_nested<T>(t: &Box<T>) {\n+    use_ref(&**t);  // what you have to write today\n+    use_ref(t);     // what you'd be able to write (note: recursive deref)\n+    use_ref(&&&&&&t);\n+    use_ref(&mut &&&&&t);\n+    use_ref(&&&mut &&&t);\n+}\n+\n+fn use_slice(_: &[u8]) {}\n+fn use_slice_mut(_: &mut [u8]) {}\n+\n+fn use_vec(mut v: Vec<u8>) {\n+    use_slice_mut(&mut v[]); // what you have to write today\n+    use_slice_mut(&mut v);   // what you'd be able to write\n+    use_slice_mut(&mut &mut &mut v);\n+\n+    use_slice(&v[]);    // what you have to write today\n+    use_slice(&v);      // what you'd be able to write\n+    use_slice(&&&&&&v);\n+    use_slice(&mut &&&&&v);\n+    use_slice(&&&mut &&&v);\n+}\n+\n+fn use_vec_ref(v: &Vec<u8>) {\n+    use_slice(&v[]);    // what you have to write today\n+    use_slice(v);       // what you'd be able to write\n+    use_slice(&&&&&&v);\n+    use_slice(&mut &&&&&v);\n+    use_slice(&&&mut &&&v);\n+}\n+\n+pub fn main() {}"}]}