{"sha": "f4dba956ecec4667e6153691a6245dbac4a5f072", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0ZGJhOTU2ZWNlYzQ2NjdlNjE1MzY5MWE2MjQ1ZGJhYzRhNWYwNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T23:39:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-11T23:39:43Z"}, "message": "auto merge of #5322 : brson/rust/4812, r=brson\n\nSupersedes #5013", "tree": {"sha": "2b85849db853691cb6d410c30ed7e23df8d129cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b85849db853691cb6d410c30ed7e23df8d129cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f4dba956ecec4667e6153691a6245dbac4a5f072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f4dba956ecec4667e6153691a6245dbac4a5f072", "html_url": "https://github.com/rust-lang/rust/commit/f4dba956ecec4667e6153691a6245dbac4a5f072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f4dba956ecec4667e6153691a6245dbac4a5f072/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "878a31066d9f5cbe7e81433c64cbd00e6b024551", "url": "https://api.github.com/repos/rust-lang/rust/commits/878a31066d9f5cbe7e81433c64cbd00e6b024551", "html_url": "https://github.com/rust-lang/rust/commit/878a31066d9f5cbe7e81433c64cbd00e6b024551"}, {"sha": "7e5995197fa41002fd0ea78bf08208247e20ad51", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e5995197fa41002fd0ea78bf08208247e20ad51", "html_url": "https://github.com/rust-lang/rust/commit/7e5995197fa41002fd0ea78bf08208247e20ad51"}], "stats": {"total": 531, "additions": 382, "deletions": 149}, "files": [{"sha": "7b12bae746716b2daf4e09ee85344c538375f0b6", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -58,6 +58,7 @@ Implicitly, all crates behave as if they included the following prologue:\n #[cfg(target_os = \"linux\")]\n pub mod linkhack {\n     #[link_args=\"-lrustrt -lrt\"]\n+    #[link_args = \"-lpthread\"]\n     extern {\n     }\n }"}, {"sha": "7f293b98e24a921e5b75e17a83af38c6d8ef9f25", "filename": "src/libcore/libc.rs", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flibc.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -534,6 +534,8 @@ pub mod types {\n \n                 pub type LPCWSTR = *WCHAR;\n                 pub type LPCSTR = *CHAR;\n+                pub type LPCTSTR = *CHAR;\n+                pub type LPTCH = *CHAR;\n \n                 pub type LPWSTR = *mut WCHAR;\n                 pub type LPSTR = *mut CHAR;\n@@ -792,6 +794,7 @@ pub mod consts {\n \n             pub const ERROR_SUCCESS : int = 0;\n             pub const ERROR_INSUFFICIENT_BUFFER : int = 122;\n+            pub const INVALID_HANDLE_VALUE: int = -1;\n         }\n     }\n \n@@ -1115,6 +1118,7 @@ pub mod funcs {\n         pub mod string {\n             use libc::types::common::c95::c_void;\n             use libc::types::os::arch::c95::{c_char, c_int, size_t};\n+            use libc::types::os::arch::c95::{wchar_t};\n \n             pub extern {\n                 unsafe fn strcpy(dst: *c_char, src: *c_char) -> *c_char;\n@@ -1138,6 +1142,7 @@ pub mod funcs {\n                 unsafe fn strtok(s: *c_char, t: *c_char) -> *c_char;\n                 unsafe fn strxfrm(s: *c_char, ct: *c_char, n: size_t)\n                                -> size_t;\n+                unsafe fn wcslen(buf: *wchar_t) -> size_t;\n \n                 // These are fine to execute on the Rust stack. They must be,\n                 // in fact, because LLVM generates calls to them!\n@@ -1381,9 +1386,28 @@ pub mod funcs {\n             use libc::types::os::arch::c95::{c_char, c_int, c_long};\n \n             pub extern {\n+                // default bindings for opendir and readdir in\n+                // non-macos unix\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"freebsd\")]\n                 unsafe fn opendir(dirname: *c_char) -> *DIR;\n-                unsafe fn closedir(dirp: *DIR) -> c_int;\n+                #[cfg(target_os = \"linux\")]\n+                #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"freebsd\")]\n                 unsafe fn readdir(dirp: *DIR) -> *dirent_t;\n+                // on OSX (particularly when running with a\n+                // 64bit kernel), we have an issue where there\n+                // are separate bindings for opendir and readdir,\n+                // which we have to explicitly link, as below.\n+                #[cfg(target_os = \"macos\")]\n+                #[link_name = \"opendir$INODE64\"]\n+                unsafe fn opendir(dirname: *c_char) -> *DIR;\n+                #[cfg(target_os = \"macos\")]\n+                #[link_name = \"readdir$INODE64\"]\n+                unsafe fn readdir(dirp: *DIR) -> *dirent_t;\n+\n+                unsafe fn closedir(dirp: *DIR) -> c_int;\n                 unsafe fn rewinddir(dirp: *DIR);\n                 unsafe fn seekdir(dirp: *DIR, loc: c_long);\n                 unsafe fn telldir(dirp: *DIR) -> c_long;\n@@ -1594,8 +1618,9 @@ pub mod funcs {\n \n         pub mod kernel32 {\n             use libc::types::os::arch::extra::{BOOL, DWORD, HMODULE};\n-            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR};\n+            use libc::types::os::arch::extra::{LPCWSTR, LPWSTR, LPTCH};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES};\n+            use libc::types::os::arch::extra::{HANDLE};\n \n             #[abi = \"stdcall\"]\n             pub extern {\n@@ -1605,6 +1630,8 @@ pub mod funcs {\n                                                -> DWORD;\n                 unsafe fn SetEnvironmentVariableW(n: LPCWSTR, v: LPCWSTR)\n                                                -> BOOL;\n+                unsafe fn GetEnvironmentStringsA() -> LPTCH;\n+                unsafe fn FreeEnvironmentStringsA(env_ptr: LPTCH) -> BOOL;\n \n                 unsafe fn GetModuleFileNameW(hModule: HMODULE,\n                                              lpFilename: LPWSTR,\n@@ -1623,6 +1650,13 @@ pub mod funcs {\n                 unsafe fn SetCurrentDirectoryW(lpPathName: LPCWSTR) -> BOOL;\n \n                 unsafe fn GetLastError() -> DWORD;\n+                unsafe fn FindFirstFileW(fileName: *u16,\n+                                        findFileData: HANDLE)\n+                    -> HANDLE;\n+                unsafe fn FindNextFileW(findFile: HANDLE,\n+                                       findFileData: HANDLE)\n+                    -> BOOL;\n+                unsafe fn FindClose(findFile: HANDLE) -> BOOL;\n             }\n         }\n "}, {"sha": "aa4a6feb76f7149d8a062f9a6e26dea808a91d6e", "filename": "src/libcore/os.rs", "status": "modified", "additions": 156, "deletions": 20, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fos.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -58,20 +58,25 @@ pub mod rustrt {\n     pub extern {\n         unsafe fn rust_get_argc() -> c_int;\n         unsafe fn rust_get_argv() -> **c_char;\n-        unsafe fn rust_getcwd() -> ~str;\n         unsafe fn rust_path_is_dir(path: *libc::c_char) -> c_int;\n         unsafe fn rust_path_exists(path: *libc::c_char) -> c_int;\n-        unsafe fn rust_list_files2(&&path: ~str) -> ~[~str];\n         unsafe fn rust_process_wait(handle: c_int) -> c_int;\n         unsafe fn rust_set_exit_status(code: libc::intptr_t);\n     }\n }\n \n pub const TMPBUF_SZ : uint = 1000u;\n+const BUF_BYTES : uint = 2048u;\n \n pub fn getcwd() -> Path {\n+    let buf = [0 as libc::c_char, ..BUF_BYTES];\n     unsafe {\n-        Path(rustrt::rust_getcwd())\n+        if(0 as *libc::c_char == libc::getcwd(\n+            &buf[0],\n+            BUF_BYTES as libc::size_t)) {\n+            fail!();\n+        }\n+        Path(str::raw::from_c_str(&buf[0]))\n     }\n }\n \n@@ -164,20 +169,68 @@ fn with_env_lock<T>(f: &fn() -> T) -> T {\n }\n \n pub fn env() -> ~[(~str,~str)] {\n-    extern {\n-        unsafe fn rust_env_pairs() -> ~[~str];\n-    }\n-\n     unsafe {\n-        do with_env_lock {\n+        #[cfg(windows)]\n+        unsafe fn get_env_pairs() -> ~[~str] {\n+            use libc::types::os::arch::extra::LPTCH;\n+            use libc::funcs::extra::kernel32::{\n+                GetEnvironmentStringsA,\n+                FreeEnvironmentStringsA\n+            };\n+            let ch = GetEnvironmentStringsA();\n+            if (ch as uint == 0) {\n+                fail!(fmt!(\"os::env() failure getting env string from OS: %s\",\n+                           os::last_os_error()));\n+            }\n+            let mut curr_ptr: uint = ch as uint;\n+            let mut result = ~[];\n+            while(*(curr_ptr as *libc::c_char) != 0 as libc::c_char) {\n+                let env_pair = str::raw::from_c_str(\n+                    curr_ptr as *libc::c_char);\n+                result.push(env_pair);\n+                curr_ptr +=\n+                    libc::strlen(curr_ptr as *libc::c_char) as uint\n+                    + 1;\n+            }\n+            FreeEnvironmentStringsA(ch);\n+            result\n+        }\n+        #[cfg(unix)]\n+        unsafe fn get_env_pairs() -> ~[~str] {\n+            extern mod rustrt {\n+                unsafe fn rust_env_pairs() -> **libc::c_char;\n+            }\n+            let environ = rustrt::rust_env_pairs();\n+            if (environ as uint == 0) {\n+                fail!(fmt!(\"os::env() failure getting env string from OS: %s\",\n+                           os::last_os_error()));\n+            }\n+            let mut result = ~[];\n+            ptr::array_each(environ, |e| {\n+                let env_pair = str::raw::from_c_str(e);\n+                log(debug, fmt!(\"get_env_pairs: %s\",\n+                                env_pair));\n+                result.push(env_pair);\n+            });\n+            result\n+        }\n+\n+        fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n             let mut pairs = ~[];\n-            for vec::each(rust_env_pairs()) |p| {\n-                let vs = str::splitn_char(*p, '=', 1u);\n-                fail_unless!(vec::len(vs) == 2u);\n+            for input.each |p| {\n+                let vs = str::splitn_char(*p, '=', 1);\n+                log(debug,\n+                    fmt!(\"splitting: len: %u\",\n+                    vs.len()));\n+                fail_unless!(vs.len() == 2);\n                 pairs.push((copy vs[0], copy vs[1]));\n             }\n             pairs\n         }\n+        do with_env_lock {\n+            let unparsed_environ = get_env_pairs();\n+            env_convert(unparsed_environ)\n+        }\n     }\n }\n \n@@ -615,13 +668,97 @@ pub fn make_dir(p: &Path, mode: c_int) -> bool {\n #[allow(non_implicitly_copyable_typarams)]\n pub fn list_dir(p: &Path) -> ~[~str] {\n     unsafe {\n-        #[cfg(unix)]\n-        fn star(p: &Path) -> Path { copy *p }\n-\n+        #[cfg(target_os = \"linux\")]\n+        #[cfg(target_os = \"android\")]\n+        #[cfg(target_os = \"freebsd\")]\n+        #[cfg(target_os = \"macos\")]\n+        unsafe fn get_list(p: &Path) -> ~[~str] {\n+            use libc::{DIR, dirent_t};\n+            use libc::{opendir, readdir, closedir};\n+            extern mod rustrt {\n+                unsafe fn rust_list_dir_val(ptr: *dirent_t)\n+                    -> *libc::c_char;\n+            }\n+            let input = p.to_str();\n+            let mut strings = ~[];\n+            let input_ptr = ::cast::transmute(&input[0]);\n+            log(debug, \"os::list_dir -- BEFORE OPENDIR\");\n+            let dir_ptr = opendir(input_ptr);\n+            if (dir_ptr as uint != 0) {\n+        log(debug, \"os::list_dir -- opendir() SUCCESS\");\n+                let mut entry_ptr = readdir(dir_ptr);\n+                while (entry_ptr as uint != 0) {\n+                    strings.push(\n+                        str::raw::from_c_str(\n+                            rustrt::rust_list_dir_val(\n+                                entry_ptr)));\n+                    entry_ptr = readdir(dir_ptr);\n+                }\n+                closedir(dir_ptr);\n+            }\n+            else {\n+        log(debug, \"os::list_dir -- opendir() FAILURE\");\n+            }\n+            log(debug,\n+                fmt!(\"os::list_dir -- AFTER -- #: %?\",\n+                     strings.len()));\n+            strings\n+        }\n         #[cfg(windows)]\n-        fn star(p: &Path) -> Path { p.push(\"*\") }\n-\n-        do rustrt::rust_list_files2(star(p).to_str()).filtered |filename| {\n+        unsafe fn get_list(p: &Path) -> ~[~str] {\n+            use libc::types::os::arch::extra::{LPCTSTR, HANDLE, BOOL};\n+            use libc::consts::os::extra::INVALID_HANDLE_VALUE;\n+            use libc::wcslen;\n+            use libc::funcs::extra::kernel32::{\n+                FindFirstFileW,\n+                FindNextFileW,\n+                FindClose,\n+            };\n+            use os::win32::{\n+                as_utf16_p\n+            };\n+            use unstable::exchange_alloc::{malloc_raw, free_raw};\n+            #[nolink]\n+            extern mod rustrt {\n+                unsafe fn rust_list_dir_wfd_size() -> libc::size_t;\n+                unsafe fn rust_list_dir_wfd_fp_buf(wfd: *libc::c_void)\n+                    -> *u16;\n+            }\n+            fn star(p: &Path) -> Path { p.push(\"*\") }\n+            do as_utf16_p(star(p).to_str()) |path_ptr| {\n+                let mut strings = ~[];\n+                let wfd_ptr = malloc_raw(\n+                    rustrt::rust_list_dir_wfd_size() as uint);\n+                let find_handle =\n+                    FindFirstFileW(\n+                        path_ptr,\n+                        ::cast::transmute(wfd_ptr));\n+                if find_handle as int != INVALID_HANDLE_VALUE {\n+                    let mut more_files = 1 as libc::c_int;\n+                    while more_files != 0 {\n+                        let fp_buf = rustrt::rust_list_dir_wfd_fp_buf(\n+                            wfd_ptr);\n+                        if fp_buf as uint == 0 {\n+                            fail!(~\"os::list_dir() failure:\"+\n+                                  ~\" got null ptr from wfd\");\n+                        }\n+                        else {\n+                            let fp_vec = vec::from_buf(\n+                                fp_buf, wcslen(fp_buf) as uint);\n+                            let fp_str = str::from_utf16(fp_vec);\n+                            strings.push(fp_str);\n+                        }\n+                        more_files = FindNextFileW(\n+                            find_handle,\n+                            ::cast::transmute(wfd_ptr));\n+                    }\n+                    FindClose(find_handle);\n+                    free_raw(wfd_ptr);\n+                }\n+                strings\n+            }\n+        }\n+        do get_list(p).filtered |filename| {\n             *filename != ~\".\" && *filename != ~\"..\"\n         }\n     }\n@@ -1274,9 +1411,8 @@ mod tests {\n         setenv(~\"USERPROFILE\", ~\"/home/PaloAlto\");\n         fail_unless!(os::homedir() == Some(Path(\"/home/MountainView\")));\n \n-        option::iter(&oldhome, |s| setenv(~\"HOME\", *s));\n-        option::iter(&olduserprofile,\n-                               |s| setenv(~\"USERPROFILE\", *s));\n+        oldhome.each(|s| {setenv(~\"HOME\", *s);true});\n+        olduserprofile.each(|s| {setenv(~\"USERPROFILE\", *s);true});\n     }\n \n     #[test]"}, {"sha": "ace70d7f061d32233aa60d338e06a2d6a66e4588", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -19,6 +19,8 @@ use sys;\n #[cfg(test)] use vec;\n #[cfg(test)] use str;\n #[cfg(notest)] use cmp::{Eq, Ord};\n+use debug;\n+use uint;\n \n pub mod libc_ {\n     use libc::c_void;\n@@ -181,6 +183,46 @@ pub pure fn ref_eq<T>(thing: &a/T, other: &b/T) -> bool {\n     to_uint(thing) == to_uint(other)\n }\n \n+/**\n+  Given a **T (pointer to an array of pointers),\n+  iterate through each *T, up to the provided `len`,\n+  passing to the provided callback function\n+\n+  SAFETY NOTE: Pointer-arithmetic. Dragons be here.\n+*/\n+pub unsafe fn array_each_with_len<T>(arr: **T, len: uint, cb: &fn(*T)) {\n+    log(debug, \"array_each_with_len: before iterate\");\n+    if (arr as uint == 0) {\n+        fail!(~\"ptr::array_each_with_len failure: arr input is null pointer\");\n+    }\n+    //let start_ptr = *arr;\n+    uint::iterate(0, len, |e| {\n+        let n = offset(arr, e);\n+        cb(*n);\n+        true\n+    });\n+    log(debug, \"array_each_with_len: after iterate\");\n+}\n+\n+/**\n+  Given a null-pointer-terminated **T (pointer to\n+  an array of pointers), iterate through each *T,\n+  passing to the provided callback function\n+\n+  SAFETY NOTE: This will only work with a null-terminated\n+  pointer array. Barely less-dodgey Pointer Arithmetic.\n+  Dragons be here.\n+*/\n+pub unsafe fn array_each<T>(arr: **T, cb: &fn(*T)) {\n+    if (arr as uint == 0) {\n+        fail!(~\"ptr::array_each_with_len failure: arr input is null pointer\");\n+    }\n+    let len = buf_len(arr);\n+    log(debug, fmt!(\"array_each inferred len: %u\",\n+                    len));\n+    array_each_with_len(arr, len, cb);\n+}\n+\n pub trait Ptr<T> {\n     pure fn is_null(&self) -> bool;\n     pure fn is_not_null(&self) -> bool;\n@@ -389,3 +431,95 @@ pub fn test_is_null() {\n    fail_unless!(!mq.is_null());\n    fail_unless!(mq.is_not_null());\n }\n+\n+#[cfg(test)]\n+pub mod ptr_tests {\n+    use debug;\n+    use ptr;\n+    use str;\n+    use libc;\n+    use vec;\n+    #[test]\n+    pub fn test_ptr_array_each_with_len() {\n+        unsafe {\n+            let one = ~\"oneOne\";\n+            let two = ~\"twoTwo\";\n+            let three = ~\"threeThree\";\n+            let arr: ~[*i8] = ~[\n+                ::cast::transmute(&one[0]),\n+                ::cast::transmute(&two[0]),\n+                ::cast::transmute(&three[0]),\n+            ];\n+            let expected_arr = [\n+                one, two, three\n+            ];\n+            let arr_ptr = &arr[0];\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            ptr::array_each_with_len(arr_ptr, vec::len(arr),\n+                |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = copy expected_arr[ctr];\n+                log(debug,\n+                    fmt!(\"test_ptr_array_each e: %s, a: %s\",\n+                         expected, actual));\n+                fail_unless!(actual == expected);\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+            fail_unless!(iteration_count == 3u);\n+        }\n+    }\n+    #[test]\n+    pub fn test_ptr_array_each() {\n+        unsafe {\n+            let one = ~\"oneOne\";\n+            let two = ~\"twoTwo\";\n+            let three = ~\"threeThree\";\n+            let arr: ~[*i8] = ~[\n+                ::cast::transmute(&one[0]),\n+                ::cast::transmute(&two[0]),\n+                ::cast::transmute(&three[0]),\n+                // fake a null terminator\n+                0 as *i8\n+            ];\n+            let expected_arr = [\n+                one, two, three\n+            ];\n+            let arr_ptr = &arr[0];\n+            let mut ctr = 0;\n+            let mut iteration_count = 0;\n+            ptr::array_each(arr_ptr, |e| {\n+                let actual = str::raw::from_c_str(e);\n+                let expected = copy expected_arr[ctr];\n+                log(debug,\n+                    fmt!(\"test_ptr_array_each e: %s, a: %s\",\n+                         expected, actual));\n+                fail_unless!(actual == expected);\n+                ctr += 1;\n+                iteration_count += 1;\n+            });\n+            fail_unless!(iteration_count == 3);\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn test_ptr_array_each_with_len_null_ptr() {\n+        unsafe {\n+            ptr::array_each_with_len(0 as **libc::c_char, 1, |e| {\n+                str::raw::from_c_str(e);\n+            });\n+        }\n+    }\n+    #[test]\n+    #[should_fail]\n+    #[ignore(cfg(windows))]\n+    pub fn test_ptr_array_each_null_ptr() {\n+        unsafe {\n+            ptr::array_each(0 as **libc::c_char, |e| {\n+                str::raw::from_c_str(e);\n+            });\n+        }\n+    }\n+}"}, {"sha": "3b4d86ba86b422ae6d60e04dcd3bb7c2ac0100e1", "filename": "src/libcore/unstable/exchange_alloc.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Funstable%2Fexchange_alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Fexchange_alloc.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -41,6 +41,17 @@ pub unsafe fn malloc(td: *TypeDesc, size: uint) -> *c_void {\n         return transmute(box);\n     }\n }\n+/**\n+Thin wrapper around libc::malloc, none of the box header\n+stuff in exchange_alloc::malloc\n+*/\n+pub unsafe fn malloc_raw(size: uint) -> *c_void {\n+    let p = c_malloc(size as size_t);\n+    if p.is_null() {\n+        fail!(~\"Failure in malloc_raw: result ptr is null\");\n+    }\n+    p\n+}\n \n pub unsafe fn free(ptr: *c_void) {\n     let exchange_count = &mut *rust_get_exchange_count_ptr();\n@@ -49,6 +60,10 @@ pub unsafe fn free(ptr: *c_void) {\n     fail_unless!(ptr.is_not_null());\n     c_free(ptr);\n }\n+///Thin wrapper around libc::free, as with exchange_alloc::malloc_raw\n+pub unsafe fn free_raw(ptr: *c_void) {\n+    c_free(ptr);\n+}\n \n fn get_box_size(body_size: uint, body_align: uint) -> uint {\n     let header_size = size_of::<BoxHeaderRepr>();"}, {"sha": "68dca608a480dab047c429f23e11d76a5f382a80", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -2692,6 +2692,7 @@ mod tests {\n \n     #[test]\n     #[should_fail]\n+    #[ignore(cfg(windows))]\n     fn test_last_empty() {\n         let a: ~[int] = ~[];\n         a.last();"}, {"sha": "a621d61cdf792ec75613784462f940d9fe8148cd", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 34, "deletions": 86, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -52,64 +52,18 @@ timegm(struct tm *tm)\n }\n #endif\n \n-extern \"C\" CDECL rust_str *\n-rust_getcwd() {\n-    rust_task *task = rust_get_current_task();\n-    LOG(task, task, \"rust_getcwd()\");\n-\n-    char cbuf[BUF_BYTES];\n-\n-#if defined(__WIN32__)\n-    if (!_getcwd(cbuf, sizeof(cbuf))) {\n-#else\n-        if (!getcwd(cbuf, sizeof(cbuf))) {\n-#endif\n-        task->fail();\n-        return NULL;\n-    }\n-\n-    return make_str(task->kernel, cbuf, strlen(cbuf), \"rust_str(getcwd)\");\n-}\n-\n #if defined(__WIN32__)\n-extern \"C\" CDECL rust_vec_box *\n+extern \"C\" CDECL char**\n rust_env_pairs() {\n-    rust_task *task = rust_get_current_task();\n-    size_t envc = 0;\n-    LPTCH ch = GetEnvironmentStringsA();\n-    LPTCH c;\n-    for (c = ch; *c; c += strlen(c) + 1) {\n-        ++envc;\n-    }\n-    c = ch;\n-    rust_vec_box *v = (rust_vec_box *)\n-        task->kernel->malloc(vec_size<rust_vec_box*>(envc),\n-                       \"str vec interior\");\n-    v->body.fill = v->body.alloc = sizeof(rust_vec*) * envc;\n-    for (size_t i = 0; i < envc; ++i) {\n-        size_t n = strlen(c);\n-        rust_str *str = make_str(task->kernel, c, n, \"str\");\n-        ((rust_str**)&v->body.data)[i] = str;\n-        c += n + 1;\n-    }\n-    if (ch) {\n-        FreeEnvironmentStrings(ch);\n-    }\n-    return v;\n+    return 0;\n }\n #else\n-extern \"C\" CDECL rust_vec_box *\n+extern \"C\" CDECL char**\n rust_env_pairs() {\n-    rust_task *task = rust_get_current_task();\n #ifdef __APPLE__\n     char **environ = *_NSGetEnviron();\n #endif\n-    char **e = environ;\n-    size_t envc = 0;\n-    while (*e) {\n-        ++envc; ++e;\n-    }\n-    return make_str_vec(task->kernel, envc, environ);\n+    return environ;\n }\n #endif\n \n@@ -293,49 +247,43 @@ debug_get_stk_seg() {\n     return task->stk;\n }\n \n-extern \"C\" CDECL rust_vec_box*\n-rust_list_files(rust_str *path) {\n-    rust_task *task = rust_get_current_task();\n-    array_list<rust_str*> strings;\n+extern \"C\" CDECL char*\n #if defined(__WIN32__)\n-    WIN32_FIND_DATA FindFileData;\n-    HANDLE hFind = FindFirstFile((char*)path->body.data, &FindFileData);\n-    if (hFind != INVALID_HANDLE_VALUE) {\n-        do {\n-            rust_str *str = make_str(task->kernel, FindFileData.cFileName,\n-                                     strlen(FindFileData.cFileName),\n-                                     \"list_files_str\");\n-            strings.push(str);\n-        } while (FindNextFile(hFind, &FindFileData));\n-        FindClose(hFind);\n-    }\n+rust_list_dir_val(WIN32_FIND_DATA* entry_ptr) {\n+    return entry_ptr->cFileName;\n+}\n #else\n-    DIR *dirp = opendir((char*)path->body.data);\n-  if (dirp) {\n-      struct dirent *dp;\n-      while ((dp = readdir(dirp))) {\n-          rust_vec_box *str = make_str(task->kernel, dp->d_name,\n-                                       strlen(dp->d_name),\n-                                       \"list_files_str\");\n-          strings.push(str);\n-      }\n-      closedir(dirp);\n-  }\n+rust_list_dir_val(dirent* entry_ptr) {\n+    return entry_ptr->d_name;\n+}\n #endif\n \n-  rust_vec_box *vec = (rust_vec_box *)\n-      task->kernel->malloc(vec_size<rust_vec_box*>(strings.size()),\n-                           \"list_files_vec\");\n-  size_t alloc_sz = sizeof(rust_vec*) * strings.size();\n-  vec->body.fill = vec->body.alloc = alloc_sz;\n-  memcpy(&vec->body.data[0], strings.data(), alloc_sz);\n-  return vec;\n+extern \"C\" CDECL size_t\n+#if defined(__WIN32__)\n+rust_list_dir_wfd_size() {\n+    return sizeof(WIN32_FIND_DATAW);\n+}\n+#else\n+rust_list_dir_wfd_size() {\n+    return 0;\n }\n+#endif\n \n-extern \"C\" CDECL rust_vec_box*\n-rust_list_files2(rust_str **path) {\n-    return rust_list_files(*path);\n+extern \"C\" CDECL void*\n+#if defined(__WIN32__)\n+rust_list_dir_wfd_fp_buf(WIN32_FIND_DATAW* wfd) {\n+    if(wfd == NULL) {\n+        return 0;\n+    }\n+    else {\n+        return wfd->cFileName;\n+    }\n+}\n+#else\n+rust_list_dir_wfd_fp_buf(void* wfd) {\n+    return 0;\n }\n+#endif\n \n extern \"C\" CDECL int\n rust_path_is_dir(char *path) {"}, {"sha": "101d04c8804752f80f8150e58d220486c78fab8b", "filename": "src/rt/rust_util.h", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -79,38 +79,6 @@ inline void reserve_vec_exact(rust_vec_box** vpp,\n \n typedef rust_vec_box rust_str;\n \n-inline rust_str *\n-make_str(rust_kernel* kernel, const char* c, size_t strlen,\n-         const char* name) {\n-    size_t str_fill = strlen + 1;\n-    size_t str_alloc = str_fill;\n-    rust_str *str = (rust_str *)\n-        kernel->malloc(vec_size<char>(str_fill), name);\n-    str->header.td = &str_body_tydesc;\n-    str->body.fill = str_fill;\n-    str->body.alloc = str_alloc;\n-    memcpy(&str->body.data, c, strlen);\n-    str->body.data[strlen] = '\\0';\n-    return str;\n-}\n-\n-inline rust_vec_box *\n-make_str_vec(rust_kernel* kernel, size_t nstrs, char **strs) {\n-    rust_vec_box *v = (rust_vec_box *)\n-        kernel->malloc(vec_size<rust_vec_box*>(nstrs),\n-                       \"str vec interior\");\n-    // FIXME: should have a real td (Issue #2639)\n-    v->header.td = NULL;\n-    v->body.fill = v->body.alloc = sizeof(rust_vec_box*) * nstrs;\n-    for (size_t i = 0; i < nstrs; ++i) {\n-        rust_str *str = make_str(kernel, strs[i],\n-                                 strlen(strs[i]),\n-                                 \"str\");\n-        ((rust_str**)&v->body.data)[i] = str;\n-    }\n-    return v;\n-}\n-\n inline size_t get_box_size(size_t body_size, size_t body_align) {\n     size_t header_size = sizeof(rust_opaque_box);\n     // FIXME (#2699): This alignment calculation is suspicious. Is it right?"}, {"sha": "284f827bc753a83b46a87e805343665b6092c507", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -29,12 +29,12 @@ rust_new_task_in_sched\n rust_num_threads\n rust_path_is_dir\n rust_path_exists\n-rust_getcwd\n rust_get_stdin\n rust_get_stdout\n rust_get_stderr\n-rust_list_files\n-rust_list_files2\n+rust_list_dir_val\n+rust_list_dir_wfd_size\n+rust_list_dir_wfd_fp_buf\n rust_log_console_on\n rust_log_console_off\n rust_process_wait\n@@ -43,7 +43,6 @@ rust_sched_current_nonlazy_threads\n rust_sched_threads\n rust_set_exit_status\n rust_start\n-rust_getcwd\n rust_env_pairs\n rust_task_yield\n rust_task_is_unwinding"}, {"sha": "fa6f59999f84c9721705e8aff43d362ce80db4d0", "filename": "src/test/run-pass/conditional-compile.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Ftest%2Frun-pass%2Fconditional-compile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconditional-compile.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -112,8 +112,8 @@ mod test_foreign_items {\n         #[abi = \"cdecl\"]\n         pub extern {\n             #[cfg(bogus)]\n-            pub fn rust_getcwd() -> ~str;\n-            pub fn rust_getcwd() -> ~str;\n+            pub fn rust_get_stdin() -> ~str;\n+            pub fn rust_get_stdin() -> ~str;\n         }\n     }\n }"}, {"sha": "7e0b4b47846e08a57f1ea81e45504a7b2d410276", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f4dba956ecec4667e6153691a6245dbac4a5f072/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=f4dba956ecec4667e6153691a6245dbac4a5f072", "patch": "@@ -17,7 +17,6 @@ mod rustrt {\n \n         pub fn rust_get_sched_id() -> libc::intptr_t;\n         pub fn rust_get_argc() -> libc::c_int;\n-        pub fn rust_getcwd() -> ~str;\n         pub fn get_task_id() -> libc::intptr_t;\n         pub fn rust_sched_threads();\n         pub fn rust_get_task();\n@@ -26,7 +25,6 @@ mod rustrt {\n \n fn calllink01() { unsafe { rustrt::rust_get_sched_id(); } }\n fn calllink02() { unsafe { rustrt::rust_get_argc(); } }\n-fn calllink03() { unsafe { rustrt::rust_getcwd(); } }\n fn calllink08() { unsafe { rustrt::get_task_id(); } }\n fn calllink09() { unsafe { rustrt::rust_sched_threads(); } }\n fn calllink10() { unsafe { rustrt::rust_get_task(); } }\n@@ -59,7 +57,6 @@ pub fn main() {\n     let fns = ~[\n         calllink01,\n         calllink02,\n-        calllink03,\n         calllink08,\n         calllink09,\n         calllink10"}]}