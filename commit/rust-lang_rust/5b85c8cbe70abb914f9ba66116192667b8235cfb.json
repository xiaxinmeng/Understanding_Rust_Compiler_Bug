{"sha": "5b85c8cbe70abb914f9ba66116192667b8235cfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViODVjOGNiZTcwYWJiOTE0ZjliYTY2MTE2MTkyNjY3YjgyMzVjZmI=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-07-28T18:33:06Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2014-08-01T15:45:22Z"}, "message": "librustc: Forbid pattern bindings after `@`s, for memory safety.\n\nThis is an alternative to upgrading the way rvalues are handled in the\nborrow check. Making rvalues handled more like lvalues in the borrow\ncheck caused numerous problems related to double mutable borrows and\nrvalue scopes. Rather than come up with more borrow check rules to try\nto solve these problems, I decided to just forbid pattern bindings after\n`@`. This affected fewer than 10 lines of code in the compiler and\nlibraries.\n\nThis breaks code like:\n\n    match x {\n        y @ z => { ... }\n    }\n\n    match a {\n        b @ Some(c) => { ... }\n    }\n\nChange this code to use nested `match` or `let` expressions. For\nexample:\n\n    match x {\n        y => {\n            let z = y;\n            ...\n        }\n    }\n\n    match a {\n        Some(c) => {\n            let b = Some(c);\n            ...\n        }\n    }\n\nCloses #14587.\n\n[breaking-change]", "tree": {"sha": "5c0cf5473084242abd986f078b6ed31e5485b527", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c0cf5473084242abd986f078b6ed31e5485b527"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b85c8cbe70abb914f9ba66116192667b8235cfb", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b85c8cbe70abb914f9ba66116192667b8235cfb", "html_url": "https://github.com/rust-lang/rust/commit/5b85c8cbe70abb914f9ba66116192667b8235cfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b85c8cbe70abb914f9ba66116192667b8235cfb/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd", "html_url": "https://github.com/rust-lang/rust/commit/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd"}], "stats": {"total": 232, "additions": 103, "deletions": 129}, "files": [{"sha": "7259588233ee5d5fcdb4661b02e54421ad4a93e9", "filename": "src/doc/rust.md", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -3309,7 +3309,12 @@ enum List { Nil, Cons(uint, Box<List>) }\n fn is_sorted(list: &List) -> bool {\n     match *list {\n         Nil | Cons(_, box Nil) => true,\n-        Cons(x, ref r @ box Cons(y, _)) => (x <= y) && is_sorted(&**r)\n+        Cons(x, ref r @ box Cons(_, _)) => {\n+            match *r {\n+                box Cons(y, _) => (x <= y) && is_sorted(&**r),\n+                _ => fail!()\n+            }\n+        }\n     }\n }\n "}, {"sha": "a0c92887c43ede6983c7e9c2d7ba961bf44a25b5", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -1724,7 +1724,7 @@ mod tests {\n             }\n         }\n \n-        let mut count_x @ mut count_y = 0;\n+        let (mut count_x, mut count_y) = (0, 0);\n         {\n             let mut tv = TwoVec {\n                 x: Vec::new(),"}, {"sha": "e3829892f7bff6d1f75b5cbd06af1e0c8d335930", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -630,8 +630,9 @@ impl LintPass for GatherNodeLevels {\n         match it.node {\n             ast::ItemEnum(..) => {\n                 let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCE);\n-                match cx.lints.get_level_source(lint_id) {\n-                    lvlsrc @ (lvl, _) if lvl != Allow => {\n+                let lvlsrc = cx.lints.get_level_source(lint_id);\n+                match lvlsrc {\n+                    (lvl, _) if lvl != Allow => {\n                         cx.node_levels.borrow_mut()\n                             .insert((it.id, lint_id), lvlsrc);\n                     },"}, {"sha": "da739faabad93b5ed93b074226dcd62c6d28f547", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -139,27 +139,36 @@ impl<'a> RestrictionsContext<'a> {\n                 Safe\n             }\n \n-            mc::cat_deref(cmt_base, _, pk @ mc::BorrowedPtr(ty::MutBorrow, lt)) |\n-            mc::cat_deref(cmt_base, _, pk @ mc::Implicit(ty::MutBorrow, lt)) => {\n-                // R-Deref-Mut-Borrowed\n-                if !self.bccx.is_subregion_of(self.loan_region, lt) {\n-                    self.bccx.report(\n-                        BckError {\n-                            span: self.span,\n-                            cause: self.cause,\n-                            cmt: cmt_base,\n-                            code: err_borrowed_pointer_too_short(\n-                                self.loan_region, lt)});\n-                    return Safe;\n+            mc::cat_deref(cmt_base, _, pk) => {\n+                match pk {\n+                    mc::BorrowedPtr(ty::MutBorrow, lt) |\n+                    mc::Implicit(ty::MutBorrow, lt) => {\n+                        // R-Deref-Mut-Borrowed\n+                        if !self.bccx.is_subregion_of(self.loan_region, lt) {\n+                            self.bccx.report(\n+                                BckError {\n+                                    span: self.span,\n+                                    cause: self.cause,\n+                                    cmt: cmt_base,\n+                                    code: err_borrowed_pointer_too_short(\n+                                        self.loan_region, lt)});\n+                            return Safe;\n+                        }\n+\n+                        let result = self.restrict(cmt_base);\n+                        self.extend(result, cmt.mutbl, LpDeref(pk))\n+                    }\n+                    mc::UnsafePtr(..) => {\n+                        // We are very trusting when working with unsafe\n+                        // pointers.\n+                        Safe\n+                    }\n+                    _ => {\n+                        self.bccx.tcx.sess.span_bug(self.span,\n+                                                    \"unhandled memcat in \\\n+                                                     cat_deref\")\n+                    }\n                 }\n-\n-                let result = self.restrict(cmt_base);\n-                self.extend(result, cmt.mutbl, LpDeref(pk))\n-            }\n-\n-            mc::cat_deref(_, _, mc::UnsafePtr(..)) => {\n-                // We are very trusting when working with unsafe pointers.\n-                Safe\n             }\n \n             mc::cat_discr(cmt_base, _) => {"}, {"sha": "21b9a3f90539142503fe20d9d8fa076d4876ffaf", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -145,6 +145,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n                                                 arm.pats.as_slice());\n+                for pat in arm.pats.iter() {\n+                    check_legality_of_bindings_in_at_patterns(cx, &**pat);\n+                }\n             }\n \n             // Second, if there is a guard on each arm, make sure it isn't\n@@ -200,6 +203,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n \n             // Check legality of move bindings.\n             check_legality_of_move_bindings(cx, false, [ *pat ]);\n+            check_legality_of_bindings_in_at_patterns(cx, &**pat);\n         }\n         _ => ()\n     }\n@@ -455,8 +459,12 @@ fn all_constructors(cx: &MatchCheckCtxt, left_ty: ty::t,\n \n // Note: is_useful doesn't work on empty types, as the paper notes.\n // So it assumes that v is non-empty.\n-fn is_useful(cx: &MatchCheckCtxt, matrix @ &Matrix(ref rows): &Matrix,\n-             v: &[Gc<Pat>], witness: WitnessPreference) -> Usefulness {\n+fn is_useful(cx: &MatchCheckCtxt,\n+             matrix: &Matrix,\n+             v: &[Gc<Pat>],\n+             witness: WitnessPreference)\n+             -> Usefulness {\n+    let &Matrix(ref rows) = matrix;\n     debug!(\"{:}\", matrix);\n     if rows.len() == 0u {\n         return match witness {\n@@ -819,8 +827,9 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n         None => ()\n     }\n \n-    // Check legality of move bindings.\n+    // Check legality of move bindings and `@` patterns.\n     check_legality_of_move_bindings(cx, false, [ loc.pat ]);\n+    check_legality_of_bindings_in_at_patterns(cx, &*loc.pat);\n }\n \n fn check_fn(cx: &mut MatchCheckCtxt,\n@@ -840,6 +849,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             None => ()\n         }\n         check_legality_of_move_bindings(cx, false, [input.pat]);\n+        check_legality_of_bindings_in_at_patterns(cx, &*input.pat);\n     }\n }\n \n@@ -856,7 +866,6 @@ fn is_refutable(cx: &MatchCheckCtxt, pat: Gc<Pat>) -> Option<Gc<Pat>> {\n }\n \n // Legality of move bindings checking\n-\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n                                    pats: &[Gc<Pat>]) {\n@@ -966,3 +975,32 @@ impl<'a> Delegate for MutationChecker<'a> {\n     }\n }\n \n+/// Forbids bindings in `@` patterns. This is necessary for memory safety,\n+/// because of the way rvalues are handled in the borrow check. (See issue\n+/// #14587.)\n+fn check_legality_of_bindings_in_at_patterns(cx: &MatchCheckCtxt, pat: &Pat) {\n+    let mut visitor = AtBindingPatternVisitor {\n+        cx: cx,\n+    };\n+    visitor.visit_pat(pat, true);\n+}\n+\n+struct AtBindingPatternVisitor<'a,'b> {\n+    cx: &'a MatchCheckCtxt<'b>,\n+}\n+\n+impl<'a,'b> Visitor<bool> for AtBindingPatternVisitor<'a,'b> {\n+    fn visit_pat(&mut self, pat: &Pat, bindings_allowed: bool) {\n+        if !bindings_allowed && pat_is_binding(&self.cx.tcx.def_map, pat) {\n+            self.cx.tcx.sess.span_err(pat.span,\n+                                      \"pattern bindings are not allowed \\\n+                                       after an `@`\");\n+        }\n+\n+        match pat.node {\n+            PatIdent(_, _, Some(_)) => visit::walk_pat(self, pat, false),\n+            _ => visit::walk_pat(self, pat, bindings_allowed),\n+        }\n+    }\n+}\n+"}, {"sha": "dc674da38af5b5bbbd75415430e4204114328024", "filename": "src/librustc/middle/typeck/infer/region_inference/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fmod.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -600,8 +600,9 @@ impl<'a> RegionVarBindings<'a> {\n                         b).as_slice());\n           }\n \n-          (f @ ReFree(ref fr), ReScope(s_id)) |\n-          (ReScope(s_id), f @ ReFree(ref fr)) => {\n+          (ReFree(ref fr), ReScope(s_id)) |\n+          (ReScope(s_id), ReFree(ref fr)) => {\n+            let f = ReFree(*fr);\n             // A \"free\" region can be interpreted as \"some region\n             // at least as big as the block fr.scope_id\".  So, we can\n             // reasonably compare free regions and scopes:\n@@ -706,8 +707,9 @@ impl<'a> RegionVarBindings<'a> {\n                             b).as_slice());\n             }\n \n-            (ReFree(ref fr), s @ ReScope(s_id)) |\n-            (s @ ReScope(s_id), ReFree(ref fr)) => {\n+            (ReFree(ref fr), ReScope(s_id)) |\n+            (ReScope(s_id), ReFree(ref fr)) => {\n+                let s = ReScope(s_id);\n                 // Free region is something \"at least as big as\n                 // `fr.scope_id`.\"  If we find that the scope `fr.scope_id` is bigger\n                 // than the scope `s_id`, then we can say that the GLB"}, {"sha": "a60348c4a3a675f261d91325821866df4af5ad46", "filename": "src/test/compile-fail/bind-by-move-neither-can-live-while-the-other-survives-1.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-neither-can-live-while-the-other-survives-1.rs?ref=51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct X { x: () }\n-\n-impl Drop for X {\n-    fn drop(&mut self) {\n-        println!(\"destructor runs\");\n-    }\n-}\n-\n-fn main() {\n-    let x = Some(X { x: () });\n-    match x {\n-        Some(ref _y @ _z) => { }, //~ ERROR cannot bind by-move and by-ref in the same pattern\n-        None => fail!()\n-    }\n-}"}, {"sha": "0e5b659f125e462a8b57f8c2d95f6aeda7451528", "filename": "src/test/compile-fail/bind-by-move-no-sub-bindings-fun-args.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings-fun-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings-fun-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-sub-bindings-fun-args.rs?ref=51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd", "patch": "@@ -1,21 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Issue #12534.\n-\n-struct A(Box<uint>);\n-\n-fn f(a @ A(u): A) -> Box<uint> {    //~ ERROR cannot bind by-move with sub-bindings\n-    drop(a);\n-    u\n-}\n-\n-fn main() {}\n-"}, {"sha": "9cd2d0d28b165167ef1672a8e646cc28323b07b1", "filename": "src/test/compile-fail/pattern-bindings-after-at.rs", "status": "renamed", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpattern-bindings-after-at.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,18 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct X { x: (), }\n-\n-impl Drop for X {\n-    fn drop(&mut self) {\n-        println!(\"destructor runs\");\n-    }\n+enum Option<T> {\n+    None,\n+    Some(T),\n }\n \n fn main() {\n-    let x = Some(X { x: () });\n-    match x {\n-        Some(_y @ ref _z) => { }, //~ ERROR cannot bind by-move with sub-bindings\n-        None => fail!()\n+    match &mut Some(1i) {\n+        ref mut z @ &Some(ref a) => {\n+        //~^ ERROR pattern bindings are not allowed after an `@`\n+            **z = None;\n+            println!(\"{}\", *a);\n+        }\n+        _ => ()\n     }\n }\n+", "previous_filename": "src/test/compile-fail/bind-by-move-no-sub-bindings.rs"}, {"sha": "e6ce94ec5d4aa1fd32efd91f53a67b1663cda337", "filename": "src/test/run-pass/match-pattern-bindings.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Ftest%2Frun-pass%2Fmatch-pattern-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b85c8cbe70abb914f9ba66116192667b8235cfb/src%2Ftest%2Frun-pass%2Fmatch-pattern-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmatch-pattern-bindings.rs?ref=5b85c8cbe70abb914f9ba66116192667b8235cfb", "patch": "@@ -15,24 +15,15 @@ fn main() {\n         ref b @ None => b\n     }, &Some(1i));\n     assert_eq!(match value {\n-        ref a @ ref _c @ Some(_) => a,\n-        ref b @ None => b\n-    }, &Some(1i));\n-    assert_eq!(match value {\n-        _a @ ref c @ Some(_) => c,\n+        ref c @ Some(_) => c,\n         ref b @ None => b\n     }, &Some(1i));\n     assert_eq!(match \"foobarbaz\" {\n-        _a @ b @ _ => b\n+        b @ _ => b\n     }, \"foobarbaz\");\n-\n-    let a @ b @ c = \"foobarbaz\";\n+    let a @ _ = \"foobarbaz\";\n     assert_eq!(a, \"foobarbaz\");\n-    assert_eq!(b, \"foobarbaz\");\n-    assert_eq!(c, \"foobarbaz\");\n     let value = Some(true);\n-    let ref a @ b @ ref c = value;\n+    let ref a @ _ = value;\n     assert_eq!(a, &Some(true));\n-    assert_eq!(b, Some(true));\n-    assert_eq!(c, &Some(true));\n }"}, {"sha": "08816d345b400563463233cb38bee09c5176e4ea", "filename": "src/test/run-pass/nested-patterns.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd/src%2Ftest%2Frun-pass%2Fnested-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnested-patterns.rs?ref=51ff6c075a61cb8219a1d6ce935ccb4cefc7a9fd", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-struct A { a: int, b: int }\n-struct B { a: int, b: C }\n-struct D { a: int, d: C }\n-struct C { c: int }\n-\n-pub fn main() {\n-    match (A {a: 10, b: 20}) {\n-        x@A {a, b: 20} => { assert!(x.a == 10); assert!(a == 10); }\n-        A {b: _b, ..} => { fail!(); }\n-    }\n-    let mut x@B {b, ..} = B {a: 10, b: C {c: 20}};\n-    x.b.c = 30;\n-    assert_eq!(b.c, 20);\n-    let mut y@D {d, ..} = D {a: 10, d: C {c: 20}};\n-    y.d.c = 30;\n-    assert_eq!(d.c, 20);\n-}"}]}