{"sha": "ca4fa6f567b5d8a01f7db864539a43457119a45c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNGZhNmY1NjdiNWQ4YTAxZjdkYjg2NDUzOWE0MzQ1NzExOWE0NWM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T15:06:32Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-11-04T15:06:32Z"}, "message": "Auto merge of #55393 - oli-obk:immediate_immediately, r=RalfJung\n\nRename `Value` to `Immediate` for miri\n\nr? @RalfJung", "tree": {"sha": "5b05aeaa9929bdc1375355fc08b2a78514ec4535", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b05aeaa9929bdc1375355fc08b2a78514ec4535"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca4fa6f567b5d8a01f7db864539a43457119a45c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4fa6f567b5d8a01f7db864539a43457119a45c", "html_url": "https://github.com/rust-lang/rust/commit/ca4fa6f567b5d8a01f7db864539a43457119a45c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca4fa6f567b5d8a01f7db864539a43457119a45c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac708826b0d97e105f91a4cde41bfe14cff032f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac708826b0d97e105f91a4cde41bfe14cff032f2", "html_url": "https://github.com/rust-lang/rust/commit/ac708826b0d97e105f91a4cde41bfe14cff032f2"}, {"sha": "400f997de3de3ae43d7f7675e8e08f29282273aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/400f997de3de3ae43d7f7675e8e08f29282273aa", "html_url": "https://github.com/rust-lang/rust/commit/400f997de3de3ae43d7f7675e8e08f29282273aa"}], "stats": {"total": 385, "additions": 196, "deletions": 189}, "files": [{"sha": "2658d7f59a07f40f240bb0f3ac694366cb0febe1", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -32,7 +32,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::{Span, DUMMY_SP};\n \n use interpret::{self,\n-    PlaceTy, MemPlace, OpTy, Operand, Value, Scalar, ConstValue, Pointer,\n+    PlaceTy, MemPlace, OpTy, Operand, Immediate, Scalar, ConstValue, Pointer,\n     EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n@@ -115,7 +115,7 @@ pub fn op_to_const<'tcx>(\n             _ => false,\n         };\n     let normalized_op = if normalize {\n-        ecx.try_read_value(op)?\n+        ecx.try_read_immediate(op)?\n     } else {\n         match op.op {\n             Operand::Indirect(mplace) => Err(mplace),\n@@ -137,9 +137,9 @@ pub fn op_to_const<'tcx>(\n             let alloc = ecx.tcx.intern_const_alloc(alloc);\n             ConstValue::ByRef(ptr.alloc_id, alloc, ptr.offset)\n         },\n-        Ok(Value::Scalar(x)) =>\n+        Ok(Immediate::Scalar(x)) =>\n             ConstValue::Scalar(x.not_undef()?),\n-        Ok(Value::ScalarPair(a, b)) =>\n+        Ok(Immediate::ScalarPair(a, b)) =>\n             ConstValue::ScalarPair(a.not_undef()?, b.not_undef()?),\n     };\n     Ok(ty::Const::from_const_value(ecx.tcx.tcx, val, op.layout.ty))"}, {"sha": "01dd995bbeec0fe53713bc68df2682d107207ca2", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -19,7 +19,7 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, Value};\n+use super::{EvalContext, Machine, PlaceTy, OpTy, Immediate};\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -45,7 +45,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             Misc => {\n                 let src_layout = src.layout;\n-                let src = self.read_value(src)?;\n+                let src = self.read_immediate(src)?;\n \n                 let src = if M::ENABLE_PTR_TRACKING_HOOKS && src_layout.ty.is_region_ptr() {\n                     // The only `Misc` casts on references are those creating raw pointers.\n@@ -61,14 +61,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 if self.type_is_fat_ptr(src_layout.ty) {\n                     match (src, self.type_is_fat_ptr(dest.layout.ty)) {\n                         // pointers to extern types\n-                        (Value::Scalar(_),_) |\n+                        (Immediate::Scalar(_),_) |\n                         // slices and trait objects to other slices/trait objects\n-                        (Value::ScalarPair(..), true) => {\n-                            // No change to value\n-                            self.write_value(src, dest)?;\n+                        (Immediate::ScalarPair(..), true) => {\n+                            // No change to immediate\n+                            self.write_immediate(src, dest)?;\n                         }\n                         // slices and trait objects to thin pointers (dropping the metadata)\n-                        (Value::ScalarPair(data, _), false) => {\n+                        (Immediate::ScalarPair(data, _), false) => {\n                             self.write_scalar(data, dest)?;\n                         }\n                     }\n@@ -118,11 +118,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             }\n \n             UnsafeFnPointer => {\n-                let src = self.read_value(src)?;\n+                let src = self.read_immediate(src)?;\n                 match dest.layout.ty.sty {\n                     ty::FnPtr(_) => {\n                         // No change to value\n-                        self.write_value(*src, dest)?;\n+                        self.write_immediate(*src, dest)?;\n                     }\n                     ref other => bug!(\"fn to unsafe fn cast on {:?}\", other),\n                 }\n@@ -144,8 +144,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                             ty::ClosureKind::FnOnce,\n                         );\n                         let fn_ptr = self.memory.create_fn_alloc(instance).with_default_tag();\n-                        let val = Value::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n-                        self.write_value(val, dest)?;\n+                        let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n+                        self.write_immediate(val, dest)?;\n                     }\n                     ref other => bug!(\"closure fn pointer on {:?}\", other),\n                 }\n@@ -326,24 +326,28 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n         match (&src_pointee_ty.sty, &dest_pointee_ty.sty) {\n             (&ty::Array(_, length), &ty::Slice(_)) => {\n-                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n+                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n                 // u64 cast is from usize to u64, which is always good\n-                let val = Value::new_slice(ptr, length.unwrap_usize(self.tcx.tcx), self.tcx.tcx);\n-                self.write_value(val, dest)\n+                let val = Immediate::new_slice(\n+                    ptr,\n+                    length.unwrap_usize(self.tcx.tcx),\n+                    self.tcx.tcx,\n+                );\n+                self.write_immediate(val, dest)\n             }\n             (&ty::Dynamic(..), &ty::Dynamic(..)) => {\n                 // For now, upcasts are limited to changes in marker\n                 // traits, and hence never actually require an actual\n                 // change to the vtable.\n-                let val = self.read_value(src)?;\n-                self.write_value(*val, dest)\n+                let val = self.read_immediate(src)?;\n+                self.write_immediate(*val, dest)\n             }\n             (_, &ty::Dynamic(ref data, _)) => {\n                 // Initial cast from sized to dyn trait\n                 let vtable = self.get_vtable(src_pointee_ty, data.principal())?;\n-                let ptr = self.read_value(src)?.to_scalar_ptr()?;\n-                let val = Value::new_dyn_trait(ptr, vtable);\n-                self.write_value(val, dest)\n+                let ptr = self.read_immediate(src)?.to_scalar_ptr()?;\n+                let val = Immediate::new_dyn_trait(ptr, vtable);\n+                self.write_immediate(val, dest)\n             }\n \n             _ => bug!(\"invalid unsizing {:?} -> {:?}\", src.layout.ty, dest.layout.ty),"}, {"sha": "8cb3f9d4d7481ea2d85ce4bf79d9de04f41e74b8", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -32,7 +32,7 @@ use rustc::mir::interpret::{\n use rustc_data_structures::fx::FxHashMap;\n \n use super::{\n-    Value, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n+    Immediate, Operand, MemPlace, MPlaceTy, Place, PlaceTy, ScalarMaybeUndef,\n     Memory, Machine\n };\n \n@@ -333,9 +333,9 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n         self.layout_of(local_ty)\n     }\n \n-    pub fn str_to_value(&mut self, s: &str) -> EvalResult<'tcx, Value<M::PointerTag>> {\n+    pub fn str_to_immediate(&mut self, s: &str) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n         let ptr = self.memory.allocate_static_bytes(s.as_bytes()).with_default_tag();\n-        Ok(Value::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n+        Ok(Immediate::new_slice(Scalar::Ptr(ptr), s.len() as u64, self.tcx.tcx))\n     }\n \n     /// Return the actual dynamic size and alignment of the place at the given type.\n@@ -457,11 +457,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n \n         // don't allocate at all for trivial constants\n         if mir.local_decls.len() > 1 {\n-            // We put some marker value into the locals that we later want to initialize.\n+            // We put some marker immediate into the locals that we later want to initialize.\n             // This can be anything except for LocalValue::Dead -- because *that* is the\n             // value we use for things that we know are initially dead.\n             let dummy =\n-                LocalValue::Live(Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)));\n+                LocalValue::Live(Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)));\n             let mut locals = IndexVec::from_elem(dummy, &mir.local_decls);\n             // Return place is handled specially by the `eval_place` functions, and the\n             // entry in `locals` should never be used. Make it dead, to be sure.\n@@ -652,13 +652,13 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tc\n                             ptr => write!(msg, \" by integral ref: {:?}\", ptr).unwrap(),\n                         }\n                     }\n-                    Ok(Operand::Immediate(Value::Scalar(val))) => {\n+                    Ok(Operand::Immediate(Immediate::Scalar(val))) => {\n                         write!(msg, \" {:?}\", val).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val {\n                             allocs.push(ptr.alloc_id);\n                         }\n                     }\n-                    Ok(Operand::Immediate(Value::ScalarPair(val1, val2))) => {\n+                    Ok(Operand::Immediate(Immediate::ScalarPair(val1, val2))) => {\n                         write!(msg, \" ({:?}, {:?})\", val1, val2).unwrap();\n                         if let ScalarMaybeUndef::Scalar(Scalar::Ptr(ptr)) = val1 {\n                             allocs.push(ptr.alloc_id);"}, {"sha": "bed938a534f4d0439e903e1fd6ee0d73de75d644", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -115,8 +115,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             | \"add_with_overflow\"\n             | \"sub_with_overflow\"\n             | \"mul_with_overflow\" => {\n-                let lhs = self.read_value(args[0])?;\n-                let rhs = self.read_value(args[1])?;\n+                let lhs = self.read_immediate(args[0])?;\n+                let rhs = self.read_immediate(args[1])?;\n                 let (bin_op, ignore_overflow) = match intrinsic_name {\n                     \"overflowing_add\" => (BinOp::Add, true),\n                     \"overflowing_sub\" => (BinOp::Sub, true),\n@@ -133,8 +133,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 }\n             }\n             \"unchecked_shl\" | \"unchecked_shr\" => {\n-                let l = self.read_value(args[0])?;\n-                let r = self.read_value(args[1])?;\n+                let l = self.read_immediate(args[0])?;\n+                let r = self.read_immediate(args[1])?;\n                 let bin_op = match intrinsic_name {\n                     \"unchecked_shl\" => BinOp::Shl,\n                     \"unchecked_shr\" => BinOp::Shr,\n@@ -172,8 +172,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         // Some fn calls are actually BinOp intrinsics\n         if let Some((op, oflo)) = self.tcx.is_binop_lang_item(def_id) {\n             let dest = dest.expect(\"128 lowerings can't diverge\");\n-            let l = self.read_value(args[0])?;\n-            let r = self.read_value(args[1])?;\n+            let l = self.read_immediate(args[0])?;\n+            let r = self.read_immediate(args[1])?;\n             if oflo {\n                 self.binop_with_overflow(op, l, r, dest)?;\n             } else {\n@@ -183,7 +183,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         } else if Some(def_id) == self.tcx.lang_items().panic_fn() {\n             assert!(args.len() == 1);\n             // &(&'static str, &'static str, u32, u32)\n-            let ptr = self.read_value(args[0])?;\n+            let ptr = self.read_immediate(args[0])?;\n             let place = self.ref_to_mplace(ptr)?;\n             let (msg, file, line, col) = (\n                 self.mplace_field(place, 0)?,\n@@ -192,9 +192,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 self.mplace_field(place, 3)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;\n@@ -203,17 +203,17 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             assert!(args.len() == 2);\n             // &'static str, &(&'static str, u32, u32)\n             let msg = args[0];\n-            let ptr = self.read_value(args[1])?;\n+            let ptr = self.read_immediate(args[1])?;\n             let place = self.ref_to_mplace(ptr)?;\n             let (file, line, col) = (\n                 self.mplace_field(place, 0)?,\n                 self.mplace_field(place, 1)?,\n                 self.mplace_field(place, 2)?,\n             );\n \n-            let msg_place = self.ref_to_mplace(self.read_value(msg.into())?)?;\n+            let msg_place = self.ref_to_mplace(self.read_immediate(msg.into())?)?;\n             let msg = Symbol::intern(self.read_str(msg_place)?);\n-            let file_place = self.ref_to_mplace(self.read_value(file.into())?)?;\n+            let file_place = self.ref_to_mplace(self.read_immediate(file.into())?)?;\n             let file = Symbol::intern(self.read_str(file_place)?);\n             let line = self.read_scalar(line.into())?.to_u32()?;\n             let col = self.read_scalar(col.into())?.to_u32()?;"}, {"sha": "6b31c675cc7d6a1a5ce9bfd881c8df696fc01372", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -36,6 +36,6 @@ pub use self::memory::{Memory, MemoryKind};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n \n-pub use self::operand::{ScalarMaybeUndef, Value, ValTy, Operand, OpTy};\n+pub use self::operand::{ScalarMaybeUndef, Immediate, ImmTy, Operand, OpTy};\n \n pub use self::validity::RefTracking;"}, {"sha": "0da0300944830f443bf3914d21bcd49d288b675b", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 76, "deletions": 73, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -144,34 +144,34 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n /// primitive values (`ScalarPair`). It allows Miri to avoid making allocations for checked binary\n /// operations and fat pointers. This idea was taken from rustc's codegen.\n /// In particular, thanks to `ScalarPair`, arithmetic operations and casts can be entirely\n-/// defined on `Value`, and do not have to work with a `Place`.\n+/// defined on `Immediate`, and do not have to work with a `Place`.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Value<Tag=(), Id=AllocId> {\n+pub enum Immediate<Tag=(), Id=AllocId> {\n     Scalar(ScalarMaybeUndef<Tag, Id>),\n     ScalarPair(ScalarMaybeUndef<Tag, Id>, ScalarMaybeUndef<Tag, Id>),\n }\n \n-impl Value {\n+impl Immediate {\n     #[inline]\n-    pub fn with_default_tag<Tag>(self) -> Value<Tag>\n+    pub fn with_default_tag<Tag>(self) -> Immediate<Tag>\n         where Tag: Default\n     {\n         match self {\n-            Value::Scalar(x) => Value::Scalar(x.with_default_tag()),\n-            Value::ScalarPair(x, y) =>\n-                Value::ScalarPair(x.with_default_tag(), y.with_default_tag()),\n+            Immediate::Scalar(x) => Immediate::Scalar(x.with_default_tag()),\n+            Immediate::ScalarPair(x, y) =>\n+                Immediate::ScalarPair(x.with_default_tag(), y.with_default_tag()),\n         }\n     }\n }\n \n-impl<'tcx, Tag> Value<Tag> {\n+impl<'tcx, Tag> Immediate<Tag> {\n     #[inline]\n-    pub fn erase_tag(self) -> Value\n+    pub fn erase_tag(self) -> Immediate\n     {\n         match self {\n-            Value::Scalar(x) => Value::Scalar(x.erase_tag()),\n-            Value::ScalarPair(x, y) =>\n-                Value::ScalarPair(x.erase_tag(), y.erase_tag()),\n+            Immediate::Scalar(x) => Immediate::Scalar(x.erase_tag()),\n+            Immediate::ScalarPair(x, y) =>\n+                Immediate::ScalarPair(x.erase_tag(), y.erase_tag()),\n         }\n     }\n \n@@ -180,18 +180,21 @@ impl<'tcx, Tag> Value<Tag> {\n         len: u64,\n         cx: impl HasDataLayout\n     ) -> Self {\n-        Value::ScalarPair(val.into(), Scalar::from_uint(len, cx.data_layout().pointer_size).into())\n+        Immediate::ScalarPair(\n+            val.into(),\n+            Scalar::from_uint(len, cx.data_layout().pointer_size).into(),\n+        )\n     }\n \n     pub fn new_dyn_trait(val: Scalar<Tag>, vtable: Pointer<Tag>) -> Self {\n-        Value::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n+        Immediate::ScalarPair(val.into(), Scalar::Ptr(vtable).into())\n     }\n \n     #[inline]\n     pub fn to_scalar_or_undef(self) -> ScalarMaybeUndef<Tag> {\n         match self {\n-            Value::Scalar(val) => val,\n-            Value::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n+            Immediate::Scalar(val) => val,\n+            Immediate::ScalarPair(..) => bug!(\"Got a fat pointer where a scalar was expected\"),\n         }\n     }\n \n@@ -203,18 +206,18 @@ impl<'tcx, Tag> Value<Tag> {\n     #[inline]\n     pub fn to_scalar_pair(self) -> EvalResult<'tcx, (Scalar<Tag>, Scalar<Tag>)> {\n         match self {\n-            Value::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n-            Value::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n+            Immediate::Scalar(..) => bug!(\"Got a thin pointer where a scalar pair was expected\"),\n+            Immediate::ScalarPair(a, b) => Ok((a.not_undef()?, b.not_undef()?))\n         }\n     }\n \n-    /// Convert the value into a pointer (or a pointer-sized integer).\n+    /// Convert the immediate into a pointer (or a pointer-sized integer).\n     /// Throws away the second half of a ScalarPair!\n     #[inline]\n     pub fn to_scalar_ptr(self) -> EvalResult<'tcx, Scalar<Tag>> {\n         match self {\n-            Value::Scalar(ptr) |\n-            Value::ScalarPair(ptr, _) => ptr.not_undef(),\n+            Immediate::Scalar(ptr) |\n+            Immediate::ScalarPair(ptr, _) => ptr.not_undef(),\n         }\n     }\n \n@@ -223,25 +226,25 @@ impl<'tcx, Tag> Value<Tag> {\n     #[inline]\n     pub fn to_meta(self) -> EvalResult<'tcx, Option<Scalar<Tag>>> {\n         Ok(match self {\n-            Value::Scalar(_) => None,\n-            Value::ScalarPair(_, meta) => Some(meta.not_undef()?),\n+            Immediate::Scalar(_) => None,\n+            Immediate::ScalarPair(_, meta) => Some(meta.not_undef()?),\n         })\n     }\n }\n \n-// ScalarPair needs a type to interpret, so we often have a value and a type together\n+// ScalarPair needs a type to interpret, so we often have an immediate and a type together\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n-pub struct ValTy<'tcx, Tag=()> {\n-    value: Value<Tag>,\n+pub struct ImmTy<'tcx, Tag=()> {\n+    immediate: Immediate<Tag>,\n     pub layout: TyLayout<'tcx>,\n }\n \n-impl<'tcx, Tag> ::std::ops::Deref for ValTy<'tcx, Tag> {\n-    type Target = Value<Tag>;\n+impl<'tcx, Tag> ::std::ops::Deref for ImmTy<'tcx, Tag> {\n+    type Target = Immediate<Tag>;\n     #[inline(always)]\n-    fn deref(&self) -> &Value<Tag> {\n-        &self.value\n+    fn deref(&self) -> &Immediate<Tag> {\n+        &self.immediate\n     }\n }\n \n@@ -250,7 +253,7 @@ impl<'tcx, Tag> ::std::ops::Deref for ValTy<'tcx, Tag> {\n /// memory and to avoid having to store arbitrary-sized data here.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Operand<Tag=(), Id=AllocId> {\n-    Immediate(Value<Tag, Id>),\n+    Immediate(Immediate<Tag, Id>),\n     Indirect(MemPlace<Tag, Id>),\n }\n \n@@ -288,11 +291,11 @@ impl<Tag> Operand<Tag> {\n     }\n \n     #[inline]\n-    pub fn to_immediate(self) -> Value<Tag>\n+    pub fn to_immediate(self) -> Immediate<Tag>\n         where Tag: ::std::fmt::Debug\n     {\n         match self {\n-            Operand::Immediate(val) => val,\n+            Operand::Immediate(imm) => imm,\n             _ => bug!(\"to_immediate: expected Operand::Immediate, got {:?}\", self),\n \n         }\n@@ -323,11 +326,11 @@ impl<'tcx, Tag: Copy> From<MPlaceTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     }\n }\n \n-impl<'tcx, Tag> From<ValTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n+impl<'tcx, Tag> From<ImmTy<'tcx, Tag>> for OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    fn from(val: ValTy<'tcx, Tag>) -> Self {\n+    fn from(val: ImmTy<'tcx, Tag>) -> Self {\n         OpTy {\n-            op: Operand::Immediate(val.value),\n+            op: Operand::Immediate(val.immediate),\n             layout: val.layout\n         }\n     }\n@@ -367,12 +370,12 @@ fn from_known_layout<'tcx>(\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n-    /// Try reading a value in memory; this is interesting particularly for ScalarPair.\n+    /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n     /// Return None if the layout does not permit loading this as a value.\n-    pub(super) fn try_read_value_from_mplace(\n+    pub(super) fn try_read_immediate_from_mplace(\n         &self,\n         mplace: MPlaceTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, Option<Value<M::PointerTag>>> {\n+    ) -> EvalResult<'tcx, Option<Immediate<M::PointerTag>>> {\n         if mplace.layout.is_unsized() {\n             // Don't touch unsized\n             return Ok(None);\n@@ -383,14 +386,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             // Not all ZSTs have a layout we would handle below, so just short-circuit them\n             // all here.\n             self.memory.check_align(ptr, ptr_align)?;\n-            return Ok(Some(Value::Scalar(Scalar::zst().into())));\n+            return Ok(Some(Immediate::Scalar(Scalar::zst().into())));\n         }\n \n         let ptr = ptr.to_ptr()?;\n         match mplace.layout.abi {\n             layout::Abi::Scalar(..) => {\n                 let scalar = self.memory.read_scalar(ptr, ptr_align, mplace.layout.size)?;\n-                Ok(Some(Value::Scalar(scalar)))\n+                Ok(Some(Immediate::Scalar(scalar)))\n             }\n             layout::Abi::ScalarPair(ref a, ref b) => {\n                 let (a, b) = (&a.value, &b.value);\n@@ -401,25 +404,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let b_ptr = ptr.offset(b_offset, self)?.into();\n                 let a_val = self.memory.read_scalar(a_ptr, ptr_align, a_size)?;\n                 let b_val = self.memory.read_scalar(b_ptr, ptr_align, b_size)?;\n-                Ok(Some(Value::ScalarPair(a_val, b_val)))\n+                Ok(Some(Immediate::ScalarPair(a_val, b_val)))\n             }\n             _ => Ok(None),\n         }\n     }\n \n-    /// Try returning an immediate value for the operand.\n-    /// If the layout does not permit loading this as a value, return where in memory\n+    /// Try returning an immediate for the operand.\n+    /// If the layout does not permit loading this as an immediate, return where in memory\n     /// we can find the data.\n     /// Note that for a given layout, this operation will either always fail or always\n     /// succeed!  Whether it succeeds depends on whether the layout can be represented\n-    /// in a `Value`, not on which data is stored there currently.\n-    pub(crate) fn try_read_value(\n+    /// in a `Immediate`, not on which data is stored there currently.\n+    pub(crate) fn try_read_immediate(\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n-    ) -> EvalResult<'tcx, Result<Value<M::PointerTag>, MemPlace<M::PointerTag>>> {\n+    ) -> EvalResult<'tcx, Result<Immediate<M::PointerTag>, MemPlace<M::PointerTag>>> {\n         Ok(match src.try_as_mplace() {\n             Ok(mplace) => {\n-                if let Some(val) = self.try_read_value_from_mplace(mplace)? {\n+                if let Some(val) = self.try_read_immediate_from_mplace(mplace)? {\n                     Ok(val)\n                 } else {\n                     Err(*mplace)\n@@ -429,14 +432,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         })\n     }\n \n-    /// Read a value from a place, asserting that that is possible with the given layout.\n+    /// Read an immediate from a place, asserting that that is possible with the given layout.\n     #[inline(always)]\n-    pub fn read_value(\n+    pub fn read_immediate(\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n-    ) -> EvalResult<'tcx, ValTy<'tcx, M::PointerTag>> {\n-        if let Ok(value) = self.try_read_value(op)? {\n-            Ok(ValTy { value, layout: op.layout })\n+    ) -> EvalResult<'tcx, ImmTy<'tcx, M::PointerTag>> {\n+        if let Ok(immediate) = self.try_read_immediate(op)? {\n+            Ok(ImmTy { immediate, layout: op.layout })\n         } else {\n             bug!(\"primitive read failed for type: {:?}\", op.layout.ty);\n         }\n@@ -447,10 +450,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         op: OpTy<'tcx, M::PointerTag>\n     ) -> EvalResult<'tcx, ScalarMaybeUndef<M::PointerTag>> {\n-        match *self.read_value(op)? {\n-            Value::ScalarPair(..) => bug!(\"got ScalarPair for type: {:?}\", op.layout.ty),\n-            Value::Scalar(val) => Ok(val),\n-        }\n+        Ok(self.read_immediate(op)?.to_scalar_or_undef())\n     }\n \n     // Turn the MPlace into a string (must already be dereferenced!)\n@@ -470,16 +470,16 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         layout: TyLayout<'tcx>\n     ) -> EvalResult<'tcx, Operand<M::PointerTag>> {\n         // This decides which types we will use the Immediate optimization for, and hence should\n-        // match what `try_read_value` and `eval_place_to_op` support.\n+        // match what `try_read_immediate` and `eval_place_to_op` support.\n         if layout.is_zst() {\n-            return Ok(Operand::Immediate(Value::Scalar(Scalar::zst().into())));\n+            return Ok(Operand::Immediate(Immediate::Scalar(Scalar::zst().into())));\n         }\n \n         Ok(match layout.abi {\n             layout::Abi::Scalar(..) =>\n-                Operand::Immediate(Value::Scalar(ScalarMaybeUndef::Undef)),\n+                Operand::Immediate(Immediate::Scalar(ScalarMaybeUndef::Undef)),\n             layout::Abi::ScalarPair(..) =>\n-                Operand::Immediate(Value::ScalarPair(\n+                Operand::Immediate(Immediate::ScalarPair(\n                     ScalarMaybeUndef::Undef,\n                     ScalarMaybeUndef::Undef,\n                 )),\n@@ -510,22 +510,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         let field = field.try_into().unwrap();\n         let field_layout = op.layout.field(self, field)?;\n         if field_layout.is_zst() {\n-            let val = Value::Scalar(Scalar::zst().into());\n-            return Ok(OpTy { op: Operand::Immediate(val), layout: field_layout });\n+            let immediate = Immediate::Scalar(Scalar::zst().into());\n+            return Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout });\n         }\n         let offset = op.layout.fields.offset(field);\n-        let value = match base {\n+        let immediate = match base {\n             // the field covers the entire type\n             _ if offset.bytes() == 0 && field_layout.size == op.layout.size => base,\n             // extract fields from types with `ScalarPair` ABI\n-            Value::ScalarPair(a, b) => {\n+            Immediate::ScalarPair(a, b) => {\n                 let val = if offset.bytes() == 0 { a } else { b };\n-                Value::Scalar(val)\n+                Immediate::Scalar(val)\n             },\n-            Value::Scalar(val) =>\n+            Immediate::Scalar(val) =>\n                 bug!(\"field access on non aggregate {:#?}, {:#?}\", val, op.layout),\n         };\n-        Ok(OpTy { op: Operand::Immediate(value), layout: field_layout })\n+        Ok(OpTy { op: Operand::Immediate(immediate), layout: field_layout })\n     }\n \n     pub fn operand_downcast(\n@@ -551,7 +551,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         &self,\n         src: OpTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let val = self.read_value(src)?;\n+        let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n         Ok(self.ref_to_mplace(val)?)\n     }\n@@ -568,7 +568,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             Deref => self.deref_operand(base)?.into(),\n             Subslice { .. } | ConstantIndex { .. } | Index(_) => if base.layout.is_zst() {\n                 OpTy {\n-                    op: Operand::Immediate(Value::Scalar(Scalar::zst().into())),\n+                    op: Operand::Immediate(Immediate::Scalar(Scalar::zst().into())),\n                     // the actual index doesn't matter, so we just pick a convenient one like 0\n                     layout: base.layout.field(self, 0)?,\n                 }\n@@ -682,9 +682,12 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 ).with_default_tag())\n             },\n             ConstValue::ScalarPair(a, b) =>\n-                Ok(Operand::Immediate(Value::ScalarPair(a.into(), b.into())).with_default_tag()),\n+                Ok(Operand::Immediate(Immediate::ScalarPair(\n+                    a.into(),\n+                    b.into(),\n+                )).with_default_tag()),\n             ConstValue::Scalar(x) =>\n-                Ok(Operand::Immediate(Value::Scalar(x.into())).with_default_tag()),\n+                Ok(Operand::Immediate(Immediate::Scalar(x.into())).with_default_tag()),\n         }\n     }\n     pub fn const_to_op(\n@@ -722,7 +725,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         }\n         // read raw discriminant value\n         let discr_op = self.operand_field(rval, 0)?;\n-        let discr_val = self.read_value(discr_op)?;\n+        let discr_val = self.read_immediate(discr_op)?;\n         let raw_discr = discr_val.to_scalar()?;\n         trace!(\"discr value: {:?}\", raw_discr);\n         // post-process"}, {"sha": "2c6b8732fdbb9213efcd04e5376db9788c82e8fc", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -15,7 +15,7 @@ use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, PlaceTy, Value, Machine, ValTy};\n+use super::{EvalContext, PlaceTy, Immediate, Machine, ImmTy};\n \n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -24,22 +24,22 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binop_with_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ValTy<'tcx, M::PointerTag>,\n-        right: ValTy<'tcx, M::PointerTag>,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (val, overflowed) = self.binary_op_val(op, left, right)?;\n-        let val = Value::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n-        self.write_value(val, dest)\n+        let val = Immediate::ScalarPair(val.into(), Scalar::from_bool(overflowed).into());\n+        self.write_immediate(val, dest)\n     }\n \n     /// Applies the binary operation `op` to the arguments and writes the result to the\n     /// destination.\n     pub fn binop_ignore_overflow(\n         &mut self,\n         op: mir::BinOp,\n-        left: ValTy<'tcx, M::PointerTag>,\n-        right: ValTy<'tcx, M::PointerTag>,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (val, _overflowed) = self.binary_op_val(op, left, right)?;\n@@ -288,8 +288,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     pub fn binary_op_val(\n         &self,\n         bin_op: mir::BinOp,\n-        left: ValTy<'tcx, M::PointerTag>,\n-        right: ValTy<'tcx, M::PointerTag>,\n+        left: ImmTy<'tcx, M::PointerTag>,\n+        right: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<M::PointerTag>, bool)> {\n         self.binary_op(\n             bin_op,"}, {"sha": "58e4e3ce96b0bdc1056ab14aaf5f61d8810c273a", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -25,7 +25,7 @@ use rustc::mir::interpret::{\n };\n use super::{\n     EvalContext, Machine, AllocMap,\n-    Value, ValTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n+    Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -201,10 +201,10 @@ impl<'tcx, Tag> MPlaceTy<'tcx, Tag> {\n \n impl<'tcx, Tag: ::std::fmt::Debug> OpTy<'tcx, Tag> {\n     #[inline(always)]\n-    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Value<Tag>> {\n+    pub fn try_as_mplace(self) -> Result<MPlaceTy<'tcx, Tag>, Immediate<Tag>> {\n         match self.op {\n             Operand::Indirect(mplace) => Ok(MPlaceTy { mplace, layout: self.layout }),\n-            Operand::Immediate(value) => Err(value),\n+            Operand::Immediate(imm) => Err(imm),\n         }\n     }\n \n@@ -269,7 +269,7 @@ where\n     /// Alignment is just based on the type.  This is the inverse of `create_ref`.\n     pub fn ref_to_mplace(\n         &self,\n-        val: ValTy<'tcx, M::PointerTag>,\n+        val: ImmTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let pointee_type = val.layout.ty.builtin_deref(true).unwrap().ty;\n         let layout = self.layout_of(pointee_type)?;\n@@ -304,7 +304,7 @@ where\n         &mut self,\n         place: MPlaceTy<'tcx, M::PointerTag>,\n         mutbl: Option<hir::Mutability>,\n-    ) -> EvalResult<'tcx, Value<M::PointerTag>> {\n+    ) -> EvalResult<'tcx, Immediate<M::PointerTag>> {\n         // Pointer tag tracking might want to adjust the tag\n         let place = if M::ENABLE_PTR_TRACKING_HOOKS {\n             let (size, _) = self.size_and_align_of_mplace(place)?\n@@ -315,8 +315,8 @@ where\n             *place\n         };\n         Ok(match place.meta {\n-            None => Value::Scalar(place.ptr.into()),\n-            Some(meta) => Value::ScalarPair(place.ptr.into(), meta.into()),\n+            None => Immediate::Scalar(place.ptr.into()),\n+            Some(meta) => Immediate::ScalarPair(place.ptr.into(), meta.into()),\n         })\n     }\n \n@@ -629,17 +629,17 @@ where\n         val: impl Into<ScalarMaybeUndef<M::PointerTag>>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        self.write_value(Value::Scalar(val.into()), dest)\n+        self.write_immediate(Immediate::Scalar(val.into()), dest)\n     }\n \n-    /// Write a value to a place\n+    /// Write an immediate to a place\n     #[inline(always)]\n-    pub fn write_value(\n+    pub fn write_immediate(\n         &mut self,\n-        src_val: Value<M::PointerTag>,\n+        src: Immediate<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n-        self.write_value_no_validate(src_val, dest)?;\n+        self.write_immediate_no_validate(src, dest)?;\n \n         if M::enforce_validity(self) {\n             // Data got changed, better make sure it matches the type!\n@@ -649,40 +649,40 @@ where\n         Ok(())\n     }\n \n-    /// Write a value to a place.\n+    /// Write an immediate to a place.\n     /// If you use this you are responsible for validating that things got copied at the\n     /// right type.\n-    fn write_value_no_validate(\n+    fn write_immediate_no_validate(\n         &mut self,\n-        src_val: Value<M::PointerTag>,\n+        src: Immediate<M::PointerTag>,\n         dest: PlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         if cfg!(debug_assertions) {\n             // This is a very common path, avoid some checks in release mode\n             assert!(!dest.layout.is_unsized(), \"Cannot write unsized data\");\n-            match src_val {\n-                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n+            match src {\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Ptr(_))) =>\n                     assert_eq!(self.pointer_size(), dest.layout.size,\n                         \"Size mismatch when writing pointer\"),\n-                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n+                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits { size, .. })) =>\n                     assert_eq!(Size::from_bytes(size.into()), dest.layout.size,\n                         \"Size mismatch when writing bits\"),\n-                Value::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size\n-                Value::ScalarPair(_, _) => {\n+                Immediate::Scalar(ScalarMaybeUndef::Undef) => {}, // undef can have any size\n+                Immediate::ScalarPair(_, _) => {\n                     // FIXME: Can we check anything here?\n                 }\n             }\n         }\n-        trace!(\"write_value: {:?} <- {:?}: {}\", *dest, src_val, dest.layout.ty);\n+        trace!(\"write_immediate: {:?} <- {:?}: {}\", *dest, src, dest.layout.ty);\n \n-        // See if we can avoid an allocation. This is the counterpart to `try_read_value`,\n+        // See if we can avoid an allocation. This is the counterpart to `try_read_immediate`,\n         // but not factored as a separate function.\n         let mplace = match dest.place {\n             Place::Local { frame, local } => {\n                 match *self.stack[frame].locals[local].access_mut()? {\n                     Operand::Immediate(ref mut dest_val) => {\n                         // Yay, we can just change the local directly.\n-                        *dest_val = src_val;\n+                        *dest_val = src;\n                         return Ok(());\n                     },\n                     Operand::Indirect(mplace) => mplace, // already in memory\n@@ -693,15 +693,15 @@ where\n         let dest = MPlaceTy { mplace, layout: dest.layout };\n \n         // This is already in memory, write there.\n-        self.write_value_to_mplace_no_validate(src_val, dest)\n+        self.write_immediate_to_mplace_no_validate(src, dest)\n     }\n \n-    /// Write a value to memory.\n+    /// Write an immediate to memory.\n     /// If you use this you are responsible for validating that things git copied at the\n     /// right type.\n-    fn write_value_to_mplace_no_validate(\n+    fn write_immediate_to_mplace_no_validate(\n         &mut self,\n-        value: Value<M::PointerTag>,\n+        value: Immediate<M::PointerTag>,\n         dest: MPlaceTy<'tcx, M::PointerTag>,\n     ) -> EvalResult<'tcx> {\n         let (ptr, ptr_align) = dest.to_scalar_ptr_align();\n@@ -721,21 +721,21 @@ where\n         // memory.  The code below is not sufficient, with enough padding it might not\n         // cover all the bytes!\n         match value {\n-            Value::Scalar(scalar) => {\n+            Immediate::Scalar(scalar) => {\n                 match dest.layout.abi {\n                     layout::Abi::Scalar(_) => {}, // fine\n-                    _ => bug!(\"write_value_to_mplace: invalid Scalar layout: {:#?}\",\n+                    _ => bug!(\"write_immediate_to_mplace: invalid Scalar layout: {:#?}\",\n                             dest.layout)\n                 }\n \n                 self.memory.write_scalar(\n                     ptr, ptr_align.min(dest.layout.align), scalar, dest.layout.size\n                 )\n             }\n-            Value::ScalarPair(a_val, b_val) => {\n+            Immediate::ScalarPair(a_val, b_val) => {\n                 let (a, b) = match dest.layout.abi {\n                     layout::Abi::ScalarPair(ref a, ref b) => (&a.value, &b.value),\n-                    _ => bug!(\"write_value_to_mplace: invalid ScalarPair layout: {:#?}\",\n+                    _ => bug!(\"write_immediate_to_mplace: invalid ScalarPair layout: {:#?}\",\n                               dest.layout)\n                 };\n                 let (a_size, b_size) = (a.size(&self), b.size(&self));\n@@ -788,10 +788,10 @@ where\n             \"Layout mismatch when copying!\\nsrc: {:#?}\\ndest: {:#?}\", src, dest);\n \n         // Let us see if the layout is simple so we take a shortcut, avoid force_allocation.\n-        let src = match self.try_read_value(src)? {\n+        let src = match self.try_read_immediate(src)? {\n             Ok(src_val) => {\n                 // Yay, we got a value that we can write directly.\n-                return self.write_value_no_validate(src_val, dest);\n+                return self.write_immediate_no_validate(src_val, dest);\n             }\n             Err(mplace) => mplace,\n         };\n@@ -873,7 +873,7 @@ where\n                         let ptr = self.allocate(local_layout, MemoryKind::Stack)?;\n                         // We don't have to validate as we can assume the local\n                         // was already valid for its type.\n-                        self.write_value_to_mplace_no_validate(value, ptr)?;\n+                        self.write_immediate_to_mplace_no_validate(value, ptr)?;\n                         let mplace = ptr.mplace;\n                         // Update the local\n                         *self.stack[frame].locals[local].access_mut()? ="}, {"sha": "0926ddb59665995aafc943f63d40e256fd205ee4", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -24,7 +24,7 @@ use syntax::ast::Mutability;\n use syntax::source_map::Span;\n \n use super::eval_context::{LocalValue, StackPopCleanup};\n-use super::{Frame, Memory, Operand, MemPlace, Place, Value, ScalarMaybeUndef};\n+use super::{Frame, Memory, Operand, MemPlace, Place, Immediate, ScalarMaybeUndef};\n use const_eval::CompileTimeInterpreter;\n \n #[derive(Default)]\n@@ -237,11 +237,11 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n-impl_stable_hash_for!(enum ::interpret::Value {\n+impl_stable_hash_for!(enum ::interpret::Immediate {\n     Scalar(x),\n     ScalarPair(x, y),\n });\n-impl_snapshot_for!(enum Value {\n+impl_snapshot_for!(enum Immediate {\n     Scalar(s),\n     ScalarPair(s, t),\n });"}, {"sha": "ea8fcfe260b79d471680e94d11be5ed0b2f5b303", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -159,9 +159,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             BinaryOp(bin_op, ref left, ref right) => {\n                 let layout = if binop_left_homogeneous(bin_op) { Some(dest.layout) } else { None };\n-                let left = self.read_value(self.eval_operand(left, layout)?)?;\n+                let left = self.read_immediate(self.eval_operand(left, layout)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.read_value(self.eval_operand(right, layout)?)?;\n+                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n                 self.binop_ignore_overflow(\n                     bin_op,\n                     left,\n@@ -172,9 +172,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             CheckedBinaryOp(bin_op, ref left, ref right) => {\n                 // Due to the extra boolean in the result, we can never reuse the `dest.layout`.\n-                let left = self.read_value(self.eval_operand(left, None)?)?;\n+                let left = self.read_immediate(self.eval_operand(left, None)?)?;\n                 let layout = if binop_right_homogeneous(bin_op) { Some(left.layout) } else { None };\n-                let right = self.read_value(self.eval_operand(right, layout)?)?;\n+                let right = self.read_immediate(self.eval_operand(right, layout)?)?;\n                 self.binop_with_overflow(\n                     bin_op,\n                     left,\n@@ -185,7 +185,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n \n             UnaryOp(un_op, ref operand) => {\n                 // The operand always has the same type as the result.\n-                let val = self.read_value(self.eval_operand(operand, Some(dest.layout))?)?;\n+                let val = self.read_immediate(self.eval_operand(operand, Some(dest.layout))?)?;\n                 let val = self.unary_op(un_op, val.to_scalar()?, dest.layout)?;\n                 self.write_scalar(val, dest)?;\n             }\n@@ -259,7 +259,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                         hir::MutImmutable,\n                 };\n                 let val = self.create_ref(val, Some(mutbl))?;\n-                self.write_value(val, dest)?;\n+                self.write_immediate(val, dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "44262aeae021484c2f3aeeeff522bb6c61afa9d7", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Value, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n+    EvalContext, Machine, Immediate, OpTy, PlaceTy, MPlaceTy, Operand, StackPopCleanup\n };\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n@@ -51,7 +51,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 ref targets,\n                 ..\n             } => {\n-                let discr = self.read_value(self.eval_operand(discr, None)?)?;\n+                let discr = self.read_immediate(self.eval_operand(discr, None)?)?;\n                 trace!(\"SwitchInt({:?})\", *discr);\n \n                 // Branch to the `otherwise` case by default, if no match is found.\n@@ -138,7 +138,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 target,\n                 ..\n             } => {\n-                let cond_val = self.read_value(self.eval_operand(cond, None)?)?\n+                let cond_val = self.read_immediate(self.eval_operand(cond, None)?)?\n                     .to_scalar()?.to_bool()?;\n                 if expected == cond_val {\n                     self.goto_block(Some(target))?;\n@@ -147,10 +147,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     use rustc::mir::interpret::EvalErrorKind::*;\n                     return match *msg {\n                         BoundsCheck { ref len, ref index } => {\n-                            let len = self.read_value(self.eval_operand(len, None)?)\n+                            let len = self.read_immediate(self.eval_operand(len, None)?)\n                                 .expect(\"can't eval len\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n-                            let index = self.read_value(self.eval_operand(index, None)?)\n+                            let index = self.read_immediate(self.eval_operand(index, None)?)\n                                 .expect(\"can't eval index\").to_scalar()?\n                                 .to_bits(self.memory().pointer_size())? as u64;\n                             err!(BoundsCheck { len, index })\n@@ -402,7 +402,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             ty::InstanceDef::Virtual(_, idx) => {\n                 let ptr_size = self.pointer_size();\n                 let ptr_align = self.tcx.data_layout.pointer_align;\n-                let ptr = self.ref_to_mplace(self.read_value(args[0])?)?;\n+                let ptr = self.ref_to_mplace(self.read_immediate(args[0])?)?;\n                 let vtable = ptr.vtable()?;\n                 let fn_ptr = self.memory.read_ptr_sized(\n                     vtable.offset(ptr_size * (idx as u64 + 3), &self)?,\n@@ -417,7 +417,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                 let pointee = args[0].layout.ty.builtin_deref(true).unwrap().ty;\n                 let fake_fat_ptr_ty = self.tcx.mk_mut_ptr(pointee);\n                 args[0].layout = self.layout_of(fake_fat_ptr_ty)?.field(&self, 0)?;\n-                args[0].op = Operand::Immediate(Value::Scalar(ptr.ptr.into())); // strip vtable\n+                args[0].op = Operand::Immediate(Immediate::Scalar(ptr.ptr.into())); // strip vtable\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)"}, {"sha": "4dbae3c8c3d280ab465ff57318951287f7b74b7b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -20,7 +20,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    ValTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n+    ImmTy, OpTy, MPlaceTy, Machine, EvalContext, ScalarMaybeUndef\n };\n \n macro_rules! validation_failure {\n@@ -144,7 +144,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     /// Make sure that `value` is valid for `ty`, *assuming* `ty` is a primitive type.\n     fn validate_primitive_type(\n         &self,\n-        value: ValTy<'tcx, M::PointerTag>,\n+        value: ImmTy<'tcx, M::PointerTag>,\n         path: &Vec<PathElem>,\n         ref_tracking: Option<&mut RefTracking<'tcx, M::PointerTag>>,\n         const_mode: bool,\n@@ -465,7 +465,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n             _ => dest.layout.ty.builtin_deref(true).is_some(),\n         };\n         if primitive {\n-            let value = try_validation!(self.read_value(dest),\n+            let value = try_validation!(self.read_immediate(dest),\n                 \"uninitialized or unrepresentable data\", path);\n             return self.validate_primitive_type(\n                 value,"}, {"sha": "24d9e761d97dbc53f035da4c9c29ad63290e4005", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -28,7 +28,7 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use interpret::{self, EvalContext, ScalarMaybeUndef, Value, OpTy, MemoryKind};\n+use interpret::{self, EvalContext, ScalarMaybeUndef, Immediate, OpTy, MemoryKind};\n use const_eval::{CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx};\n use transform::{MirPass, MirSource};\n \n@@ -354,7 +354,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n             Rvalue::NullaryOp(NullOp::SizeOf, ty) => {\n                 type_size_of(self.tcx, self.param_env, ty).and_then(|n| Some((\n                     OpTy {\n-                        op: interpret::Operand::Immediate(Value::Scalar(\n+                        op: interpret::Operand::Immediate(Immediate::Scalar(\n                             Scalar::Bits {\n                                 bits: n as u128,\n                                 size: self.tcx.data_layout.pointer_size.bytes() as u8,\n@@ -397,7 +397,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                     this.ecx.unary_op(op, prim, arg.layout)\n                 })?;\n                 let res = OpTy {\n-                    op: interpret::Operand::Immediate(Value::Scalar(val.into())),\n+                    op: interpret::Operand::Immediate(Immediate::Scalar(val.into())),\n                     layout: place_layout,\n                 };\n                 Some((res, span))\n@@ -418,7 +418,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n \n                 let r = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_value(right.0)\n+                    this.ecx.read_immediate(right.0)\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let left_ty = left.ty(self.mir, self.tcx);\n@@ -451,14 +451,14 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 }\n                 let left = self.eval_operand(left, source_info)?;\n                 let l = self.use_ecx(source_info, |this| {\n-                    this.ecx.read_value(left.0)\n+                    this.ecx.read_immediate(left.0)\n                 })?;\n                 trace!(\"const evaluating {:?} for {:?} and {:?}\", op, left, right);\n                 let (val, overflow) = self.use_ecx(source_info, |this| {\n                     this.ecx.binary_op_val(op, l, r)\n                 })?;\n                 let val = if let Rvalue::CheckedBinaryOp(..) = *rvalue {\n-                    Value::ScalarPair(\n+                    Immediate::ScalarPair(\n                         val.into(),\n                         Scalar::from_bool(overflow).into(),\n                     )\n@@ -468,7 +468,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                         let _: Option<()> = self.use_ecx(source_info, |_| Err(err));\n                         return None;\n                     }\n-                    Value::Scalar(val.into())\n+                    Immediate::Scalar(val.into())\n                 };\n                 let res = OpTy {\n                     op: interpret::Operand::Immediate(val),\n@@ -591,7 +591,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n         if let TerminatorKind::Assert { expected, msg, cond, .. } = kind {\n             if let Some(value) = self.eval_operand(cond, source_info) {\n                 trace!(\"assertion on {:?} should be {:?}\", value, expected);\n-                let expected = Value::Scalar(Scalar::from_bool(*expected).into());\n+                let expected = Immediate::Scalar(Scalar::from_bool(*expected).into());\n                 if expected != value.0.to_immediate() {\n                     // poison all places this operand references so that further code\n                     // doesn't use the invalid value\n@@ -629,7 +629,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                 .eval_operand(len, source_info)\n                                 .expect(\"len must be const\");\n                             let len = match len.0.to_immediate() {\n-                                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n                                 _ => bug!(\"const len not primitive: {:?}\", len),\n@@ -638,7 +638,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                                 .eval_operand(index, source_info)\n                                 .expect(\"index must be const\");\n                             let index = match index.0.to_immediate() {\n-                                Value::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n+                                Immediate::Scalar(ScalarMaybeUndef::Scalar(Scalar::Bits {\n                                     bits, ..\n                                 })) => bits,\n                                 _ => bug!(\"const index not primitive: {:?}\", index),"}, {"sha": "ca7e0224dc328bcbfd12e78843968fc42e214ce2", "filename": "src/tools/linkchecker/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Ftools%2Flinkchecker%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4fa6f567b5d8a01f7db864539a43457119a45c/src%2Ftools%2Flinkchecker%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Flinkchecker%2Fmain.rs?ref=ca4fa6f567b5d8a01f7db864539a43457119a45c", "patch": "@@ -133,7 +133,7 @@ fn check(cache: &mut Cache,\n     // whitelists to get this past `make check` today.\n     // FIXME(#32129)\n     if file.ends_with(\"std/string/struct.String.html\") ||\n-       file.ends_with(\"interpret/struct.ValTy.html\") ||\n+       file.ends_with(\"interpret/struct.ImmTy.html\") ||\n        file.ends_with(\"symbol/struct.InternedString.html\") ||\n        file.ends_with(\"ast/struct.ThinVec.html\") ||\n        file.ends_with(\"util/struct.ThinVec.html\") ||"}]}