{"sha": "78580651131c9daacd7e5e4669af819cdd719f09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc4NTgwNjUxMTMxYzlkYWFjZDdlNWU0NjY5YWY4MTljZGQ3MTlmMDk=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-09T21:58:32Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-03-13T20:23:29Z"}, "message": "std: Rename Chan/Port types and constructor\n\n* Chan<T> => Sender<T>\n* Port<T> => Receiver<T>\n* Chan::new() => channel()\n* constructor returns (Sender, Receiver) instead of (Receiver, Sender)\n* local variables named `port` renamed to `rx`\n* local variables named `chan` renamed to `tx`\n\nCloses #11765", "tree": {"sha": "6678663d25576f03f2a06d2f957738d8868fccd3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6678663d25576f03f2a06d2f957738d8868fccd3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78580651131c9daacd7e5e4669af819cdd719f09", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78580651131c9daacd7e5e4669af819cdd719f09", "html_url": "https://github.com/rust-lang/rust/commit/78580651131c9daacd7e5e4669af819cdd719f09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78580651131c9daacd7e5e4669af819cdd719f09/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e86e1d88b2842671123d0a072d00c94bd3f39264", "url": "https://api.github.com/repos/rust-lang/rust/commits/e86e1d88b2842671123d0a072d00c94bd3f39264", "html_url": "https://github.com/rust-lang/rust/commit/e86e1d88b2842671123d0a072d00c94bd3f39264"}], "stats": {"total": 3627, "additions": 1736, "deletions": 1891}, "files": [{"sha": "da062004cf15625a1d00e5a41304c024ed9c2634", "filename": "src/doc/guide-tasks.md", "status": "modified", "additions": 64, "deletions": 67, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Fdoc%2Fguide-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Fdoc%2Fguide-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-tasks.md?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -48,8 +48,8 @@ concurrency at this writing:\n * [`std::task`] - All code relating to tasks and task scheduling,\n * [`std::comm`] - The message passing interface,\n * [`sync::DuplexStream`] - An extension of `pipes::stream` that allows both sending and receiving,\n-* [`sync::SyncChan`] - An extension of `pipes::stream` that provides synchronous message sending,\n-* [`sync::SyncPort`] - An extension of `pipes::stream` that acknowledges each message received,\n+* [`sync::SyncSender`] - An extension of `pipes::stream` that provides synchronous message sending,\n+* [`sync::SyncReceiver`] - An extension of `pipes::stream` that acknowledges each message received,\n * [`sync::rendezvous`] - Creates a stream whose channel, upon sending a message, blocks until the\n     message is received.\n * [`sync::Arc`] - The Arc (atomically reference counted) type, for safely sharing immutable data,\n@@ -70,8 +70,8 @@ concurrency at this writing:\n [`std::task`]: std/task/index.html\n [`std::comm`]: std/comm/index.html\n [`sync::DuplexStream`]: sync/struct.DuplexStream.html\n-[`sync::SyncChan`]: sync/struct.SyncChan.html\n-[`sync::SyncPort`]: sync/struct.SyncPort.html\n+[`sync::SyncSender`]: sync/struct.SyncSender.html\n+[`sync::SyncReceiver`]: sync/struct.SyncReceiver.html\n [`sync::rendezvous`]: sync/fn.rendezvous.html\n [`sync::Arc`]: sync/struct.Arc.html\n [`sync::RWArc`]: sync/struct.RWArc.html\n@@ -141,118 +141,115 @@ receiving messages. Pipes are low-level communication building-blocks and so\n come in a variety of forms, each one appropriate for a different use case. In\n what follows, we cover the most commonly used varieties.\n \n-The simplest way to create a pipe is to use `Chan::new`\n-function to create a `(Port, Chan)` pair. In Rust parlance, a *channel*\n-is a sending endpoint of a pipe, and a *port* is the receiving\n+The simplest way to create a pipe is to use the `channel`\n+function to create a `(Sender, Receiver)` pair. In Rust parlance, a *sender*\n+is a sending endpoint of a pipe, and a *receiver* is the receiving\n endpoint. Consider the following example of calculating two results\n concurrently:\n \n ~~~~\n # use std::task::spawn;\n \n-let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n+let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n \n spawn(proc() {\n     let result = some_expensive_computation();\n-    chan.send(result);\n+    tx.send(result);\n });\n \n some_other_expensive_computation();\n-let result = port.recv();\n+let result = rx.recv();\n # fn some_expensive_computation() -> int { 42 }\n # fn some_other_expensive_computation() {}\n ~~~~\n \n Let's examine this example in detail. First, the `let` statement creates a\n stream for sending and receiving integers (the left-hand side of the `let`,\n-`(chan, port)`, is an example of a *destructuring let*: the pattern separates\n+`(tx, rx)`, is an example of a *destructuring let*: the pattern separates\n a tuple into its component parts).\n \n ~~~~\n-let (port, chan): (Port<int>, Chan<int>) = Chan::new();\n+let (tx, rx): (Sender<int>, Receiver<int>) = channel();\n ~~~~\n \n-The child task will use the channel to send data to the parent task,\n-which will wait to receive the data on the port. The next statement\n+The child task will use the sender to send data to the parent task,\n+which will wait to receive the data on the receiver. The next statement\n spawns the child task.\n \n ~~~~\n # use std::task::spawn;\n # fn some_expensive_computation() -> int { 42 }\n-# let (port, chan) = Chan::new();\n+# let (tx, rx) = channel();\n spawn(proc() {\n     let result = some_expensive_computation();\n-    chan.send(result);\n+    tx.send(result);\n });\n ~~~~\n \n-Notice that the creation of the task closure transfers `chan` to the child\n-task implicitly: the closure captures `chan` in its environment. Both `Chan`\n-and `Port` are sendable types and may be captured into tasks or otherwise\n+Notice that the creation of the task closure transfers `tx` to the child\n+task implicitly: the closure captures `tx` in its environment. Both `Sender`\n+and `Receiver` are sendable types and may be captured into tasks or otherwise\n transferred between them. In the example, the child task runs an expensive\n computation, then sends the result over the captured channel.\n \n Finally, the parent continues with some other expensive\n computation, then waits for the child's result to arrive on the\n-port:\n+receiver:\n \n ~~~~\n # fn some_other_expensive_computation() {}\n-# let (port, chan) = Chan::<int>::new();\n-# chan.send(0);\n+# let (tx, rx) = channel::<int>();\n+# tx.send(0);\n some_other_expensive_computation();\n-let result = port.recv();\n+let result = rx.recv();\n ~~~~\n \n-The `Port` and `Chan` pair created by `Chan::new` enables efficient\n+The `Sender` and `Receiver` pair created by `channel` enables efficient\n communication between a single sender and a single receiver, but multiple\n-senders cannot use a single `Chan`, and multiple receivers cannot use a single\n-`Port`.  What if our example needed to compute multiple results across a number\n-of tasks? The following program is ill-typed:\n+senders cannot use a single `Sender` value, and multiple receivers cannot use a\n+single `Receiver` value.  What if our example needed to compute multiple\n+results across a number of tasks? The following program is ill-typed:\n \n ~~~ {.ignore}\n-# use std::task::{spawn};\n # fn some_expensive_computation() -> int { 42 }\n-let (port, chan) = Chan::new();\n+let (tx, rx) = channel();\n \n spawn(proc() {\n-    chan.send(some_expensive_computation());\n+    tx.send(some_expensive_computation());\n });\n \n-// ERROR! The previous spawn statement already owns the channel,\n+// ERROR! The previous spawn statement already owns the sender,\n // so the compiler will not allow it to be captured again\n spawn(proc() {\n-    chan.send(some_expensive_computation());\n+    tx.send(some_expensive_computation());\n });\n ~~~\n \n-Instead we can clone the `chan`, which allows for multiple senders.\n+Instead we can clone the `tx`, which allows for multiple senders.\n \n ~~~\n-# use std::task::spawn;\n-\n-let (port, chan) = Chan::new();\n+let (tx, rx) = channel();\n \n for init_val in range(0u, 3) {\n     // Create a new channel handle to distribute to the child task\n-    let child_chan = chan.clone();\n+    let child_tx = tx.clone();\n     spawn(proc() {\n-        child_chan.send(some_expensive_computation(init_val));\n+        child_tx.send(some_expensive_computation(init_val));\n     });\n }\n \n-let result = port.recv() + port.recv() + port.recv();\n+let result = rx.recv() + rx.recv() + rx.recv();\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n-Cloning a `Chan` produces a new handle to the same channel, allowing multiple\n-tasks to send data to a single port. It also upgrades the channel internally in\n+Cloning a `Sender` produces a new handle to the same channel, allowing multiple\n+tasks to send data to a single receiver. It upgrades the channel internally in\n order to allow this functionality, which means that channels that are not\n cloned can avoid the overhead required to handle multiple senders. But this\n fact has no bearing on the channel's usage: the upgrade is transparent.\n \n Note that the above cloning example is somewhat contrived since\n-you could also simply use three `Chan` pairs, but it serves to\n+you could also simply use three `Sender` pairs, but it serves to\n illustrate the point. For reference, written with multiple streams, it\n might look like the example below.\n \n@@ -261,16 +258,16 @@ might look like the example below.\n # use std::vec;\n \n // Create a vector of ports, one for each child task\n-let ports = vec::from_fn(3, |init_val| {\n-    let (port, chan) = Chan::new();\n+let rxs = vec::from_fn(3, |init_val| {\n+    let (tx, rx) = channel();\n     spawn(proc() {\n-        chan.send(some_expensive_computation(init_val));\n+        tx.send(some_expensive_computation(init_val));\n     });\n-    port\n+    rx\n });\n \n // Wait on each port, accumulating the results\n-let result = ports.iter().fold(0, |accum, port| accum + port.recv() );\n+let result = rxs.iter().fold(0, |accum, rx| accum + rx.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n \n@@ -281,7 +278,7 @@ later.\n The basic example below illustrates this.\n \n ~~~\n-# extern crate sync;\n+extern crate sync;\n \n # fn main() {\n # fn make_a_sandwich() {};\n@@ -342,9 +339,10 @@ Here is a small example showing how to use Arcs. We wish to run concurrently sev\n a single large vector of floats. Each task needs the full vector to perform its duty.\n \n ~~~\n-# extern crate sync;\n- extern crate rand;\n-# use std::vec;\n+extern crate rand;\n+extern crate sync;\n+\n+use std::vec;\n use sync::Arc;\n \n fn pnorm(nums: &~[f64], p: uint) -> f64 {\n@@ -358,11 +356,11 @@ fn main() {\n     let numbers_arc = Arc::new(numbers);\n \n     for num in range(1u, 10) {\n-        let (port, chan)  = Chan::new();\n-        chan.send(numbers_arc.clone());\n+        let (tx, rx) = channel();\n+        tx.send(numbers_arc.clone());\n \n         spawn(proc() {\n-            let local_arc : Arc<~[f64]> = port.recv();\n+            let local_arc : Arc<~[f64]> = rx.recv();\n             let task_numbers = local_arc.get();\n             println!(\"{}-norm = {}\", num, pnorm(task_numbers, num));\n         });\n@@ -395,8 +393,8 @@ and a clone of it is sent to each task\n # fn main() {\n # let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc = Arc::new(numbers);\n-# let (port, chan)  = Chan::new();\n-chan.send(numbers_arc.clone());\n+# let (tx, rx) = channel();\n+tx.send(numbers_arc.clone());\n # }\n ~~~\n \n@@ -412,9 +410,9 @@ Each task recovers the underlying data by\n # fn main() {\n # let numbers=vec::from_fn(1000000, |_| rand::random::<f64>());\n # let numbers_arc=Arc::new(numbers);\n-# let (port, chan)  = Chan::new();\n-# chan.send(numbers_arc.clone());\n-# let local_arc : Arc<~[f64]> = port.recv();\n+# let (tx, rx) = channel();\n+# tx.send(numbers_arc.clone());\n+# let local_arc : Arc<~[f64]> = rx.recv();\n let task_numbers = local_arc.get();\n # }\n ~~~\n@@ -486,19 +484,18 @@ proceed).\n \n A very common thing to do is to spawn a child task where the parent\n and child both need to exchange messages with each other. The\n-function `sync::comm::DuplexStream()` supports this pattern.  We'll\n+function `sync::comm::duplex` supports this pattern.  We'll\n look briefly at how to use it.\n \n-To see how `DuplexStream()` works, we will create a child task\n+To see how `duplex` works, we will create a child task\n that repeatedly receives a `uint` message, converts it to a string, and sends\n the string in response.  The child terminates when it receives `0`.\n Here is the function that implements the child task:\n \n ~~~\n-# extern crate sync;\n+extern crate sync;\n # fn main() {\n-# use sync::DuplexStream;\n-    fn stringifier(channel: &DuplexStream<~str, uint>) {\n+    fn stringifier(channel: &sync::DuplexStream<~str, uint>) {\n         let mut value: uint;\n         loop {\n             value = channel.recv();\n@@ -520,10 +517,10 @@ response itself is simply the stringified version of the received value,\n Here is the code for the parent task:\n \n ~~~\n-# extern crate sync;\n+extern crate sync;\n # use std::task::spawn;\n # use sync::DuplexStream;\n-# fn stringifier(channel: &DuplexStream<~str, uint>) {\n+# fn stringifier(channel: &sync::DuplexStream<~str, uint>) {\n #     let mut value: uint;\n #     loop {\n #         value = channel.recv();\n@@ -533,7 +530,7 @@ Here is the code for the parent task:\n # }\n # fn main() {\n \n-let (from_child, to_child) = DuplexStream::new();\n+let (from_child, to_child) = sync::duplex();\n \n spawn(proc() {\n     stringifier(&to_child);"}, {"sha": "9c8e5b5d010869c8b4db82c9d395fbae34e2137f", "filename": "src/etc/vim/syntax/rust.vim", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -96,7 +96,7 @@ syn keyword rustTrait MutableVector MutableTotalOrdVector\n syn keyword rustTrait Vector VectorVector CloneableVector ImmutableVector\n \n \"syn keyword rustFunction stream\n-syn keyword rustTrait Port Chan\n+syn keyword rustTrait Sender Receiver\n \"syn keyword rustFunction spawn\n \n syn keyword   rustSelf        self"}, {"sha": "274258daf165138c44223d48c6c80f8378babab8", "filename": "src/libextra/workcache.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibextra%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibextra%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fworkcache.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -237,7 +237,7 @@ pub struct Exec {\n \n enum Work<'a, T> {\n     WorkValue(T),\n-    WorkFromTask(&'a Prep<'a>, Port<(Exec, T)>),\n+    WorkFromTask(&'a Prep<'a>, Receiver<(Exec, T)>),\n }\n \n fn json_encode<'a, T:Encodable<json::Encoder<'a>>>(t: &T) -> ~str {\n@@ -411,7 +411,7 @@ impl<'a> Prep<'a> {\n \n             _ => {\n                 debug!(\"Cache miss!\");\n-                let (port, chan) = Chan::new();\n+                let (tx, rx) = channel();\n                 let blk = bo.take_unwrap();\n \n                 // FIXME: What happens if the task fails?\n@@ -421,9 +421,9 @@ impl<'a> Prep<'a> {\n                         discovered_outputs: WorkMap::new(),\n                     };\n                     let v = blk(&mut exe);\n-                    chan.send((exe, v));\n+                    tx.send((exe, v));\n                 });\n-                Work::from_task(self, port)\n+                Work::from_task(self, rx)\n             }\n         }\n     }\n@@ -437,7 +437,7 @@ impl<'a, T:Send +\n     pub fn from_value(elt: T) -> Work<'a, T> {\n         WorkValue(elt)\n     }\n-    pub fn from_task(prep: &'a Prep<'a>, port: Port<(Exec, T)>)\n+    pub fn from_task(prep: &'a Prep<'a>, port: Receiver<(Exec, T)>)\n         -> Work<'a, T> {\n         WorkFromTask(prep, port)\n     }"}, {"sha": "ba12ca2e04fc524267ea4fde0b98b1844097503f", "filename": "src/libgreen/basic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fbasic.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -255,11 +255,11 @@ mod test {\n     #[test]\n     fn some_channels() {\n         run(proc() {\n-            let (p, c) = Chan::new();\n+            let (tx, rx) = channel();\n             spawn(proc() {\n-                c.send(());\n+                tx.send(());\n             });\n-            p.recv();\n+            rx.recv();\n         });\n     }\n \n@@ -272,11 +272,11 @@ mod test {\n \n         for _ in range(0, 20) {\n             pool.spawn(TaskOpts::new(), proc() {\n-                let (p, c) = Chan::new();\n+                let (tx, rx) = channel();\n                 spawn(proc() {\n-                    c.send(());\n+                    tx.send(());\n                 });\n-                p.recv();\n+                rx.recv();\n             });\n         }\n "}, {"sha": "93b7ec2aecf5d504988780ba892851f86fc83e13", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -258,15 +258,15 @@ pub fn run(main: proc()) -> int {\n     // Create a scheduler pool and spawn the main task into this pool. We will\n     // get notified over a channel when the main task exits.\n     let mut pool = SchedPool::new(PoolConfig::new());\n-    let (port, chan) = Chan::new();\n+    let (tx, rx) = channel();\n     let mut opts = TaskOpts::new();\n-    opts.notify_chan = Some(chan);\n+    opts.notify_chan = Some(tx);\n     opts.name = Some(\"<main>\".into_maybe_owned());\n     pool.spawn(opts, main);\n \n     // Wait for the main task to return, and set the process error code\n     // appropriately.\n-    if port.recv().is_err() {\n+    if rx.recv().is_err() {\n         os::set_exit_status(rt::DEFAULT_ERROR_CODE);\n     }\n \n@@ -309,7 +309,7 @@ pub struct SchedPool {\n     priv sleepers: SleeperList,\n     priv factory: fn() -> ~rtio::EventLoop,\n     priv task_state: TaskState,\n-    priv tasks_done: Port<()>,\n+    priv tasks_done: Receiver<()>,\n }\n \n /// This is an internal state shared among a pool of schedulers. This is used to\n@@ -318,7 +318,7 @@ pub struct SchedPool {\n #[deriving(Clone)]\n struct TaskState {\n     cnt: UnsafeArc<AtomicUint>,\n-    done: Chan<()>,\n+    done: Sender<()>,\n }\n \n impl SchedPool {\n@@ -471,11 +471,11 @@ impl SchedPool {\n }\n \n impl TaskState {\n-    fn new() -> (Port<()>, TaskState) {\n-        let (p, c) = Chan::new();\n-        (p, TaskState {\n+    fn new() -> (Receiver<()>, TaskState) {\n+        let (tx, rx) = channel();\n+        (rx, TaskState {\n             cnt: UnsafeArc::new(AtomicUint::new(0)),\n-            done: c,\n+            done: tx,\n         })\n     }\n "}, {"sha": "8508b8107a1aaa68c41be33d5fb5b6961802f59e", "filename": "src/libgreen/sched.rs", "status": "modified", "additions": 61, "deletions": 61, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Fsched.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Fsched.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Fsched.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -1091,25 +1091,25 @@ mod test {\n     fn test_home_sched() {\n         let mut pool = pool();\n \n-        let (dport, dchan) = Chan::new();\n+        let (dtx, drx) = channel();\n         {\n-            let (port, chan) = Chan::new();\n+            let (tx, rx) = channel();\n             let mut handle1 = pool.spawn_sched();\n             let mut handle2 = pool.spawn_sched();\n \n             handle1.send(TaskFromFriend(pool.task(TaskOpts::new(), proc() {\n-                chan.send(sched_id());\n+                tx.send(sched_id());\n             })));\n-            let sched1_id = port.recv();\n+            let sched1_id = rx.recv();\n \n             let mut task = pool.task(TaskOpts::new(), proc() {\n                 assert_eq!(sched_id(), sched1_id);\n-                dchan.send(());\n+                dtx.send(());\n             });\n             task.give_home(HomeSched(handle1));\n             handle2.send(TaskFromFriend(task));\n         }\n-        dport.recv();\n+        drx.recv();\n \n         pool.shutdown();\n     }\n@@ -1210,7 +1210,7 @@ mod test {\n             });\n \n             // Signal from the special task that we are done.\n-            let (port, chan) = Chan::<()>::new();\n+            let (tx, rx) = channel::<()>();\n \n             fn run(next: ~GreenTask) {\n                 let mut task = GreenTask::convert(Local::take());\n@@ -1221,7 +1221,7 @@ mod test {\n             let normal_task = GreenTask::new(&mut normal_sched.stack_pool, None, proc() {\n                 run(task2);\n                 run(task4);\n-                port.recv();\n+                rx.recv();\n                 let mut nh = normal_handle;\n                 nh.send(Shutdown);\n                 let mut sh = special_handle;\n@@ -1232,7 +1232,7 @@ mod test {\n             let special_task = GreenTask::new(&mut special_sched.stack_pool, None, proc() {\n                 run(task1);\n                 run(task3);\n-                chan.send(());\n+                tx.send(());\n             });\n             special_sched.enqueue_task(special_task);\n \n@@ -1280,24 +1280,24 @@ mod test {\n \n     #[test]\n     fn wakeup_across_scheds() {\n-        let (port1, chan1) = Chan::new();\n-        let (port2, chan2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n \n         let mut pool1 = pool();\n         let mut pool2 = pool();\n \n         pool1.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n-            chan1.send(());\n-            port2.recv();\n+            tx1.send(());\n+            rx2.recv();\n             assert_eq!(id, sched_id());\n         });\n \n         pool2.spawn(TaskOpts::new(), proc() {\n             let id = sched_id();\n-            port1.recv();\n+            rx1.recv();\n             assert_eq!(id, sched_id());\n-            chan2.send(());\n+            tx2.send(());\n         });\n \n         pool1.shutdown();\n@@ -1319,18 +1319,18 @@ mod test {\n     #[test]\n     fn multithreading() {\n         run(proc() {\n-            let mut ports = ~[];\n+            let mut rxs = ~[];\n             for _ in range(0, 10) {\n-                let (port, chan) = Chan::new();\n+                let (tx, rx) = channel();\n                 spawn(proc() {\n-                    chan.send(());\n+                    tx.send(());\n                 });\n-                ports.push(port);\n+                rxs.push(rx);\n             }\n \n             loop {\n-                match ports.pop() {\n-                    Some(port) => port.recv(),\n+                match rxs.pop() {\n+                    Some(rx) => rx.recv(),\n                     None => break,\n                 }\n             }\n@@ -1340,45 +1340,45 @@ mod test {\n      #[test]\n     fn thread_ring() {\n         run(proc() {\n-            let (end_port, end_chan) = Chan::new();\n+            let (end_tx, end_rx) = channel();\n \n             let n_tasks = 10;\n             let token = 2000;\n \n-            let (mut p, ch1) = Chan::new();\n-            ch1.send((token, end_chan));\n+            let (tx1, mut rx) = channel();\n+            tx1.send((token, end_tx));\n             let mut i = 2;\n             while i <= n_tasks {\n-                let (next_p, ch) = Chan::new();\n+                let (tx, next_rx) = channel();\n                 let imm_i = i;\n-                let imm_p = p;\n+                let imm_rx = rx;\n                 spawn(proc() {\n-                    roundtrip(imm_i, n_tasks, &imm_p, &ch);\n+                    roundtrip(imm_i, n_tasks, &imm_rx, &tx);\n                 });\n-                p = next_p;\n+                rx = next_rx;\n                 i += 1;\n             }\n-            let p = p;\n+            let rx = rx;\n             spawn(proc() {\n-                roundtrip(1, n_tasks, &p, &ch1);\n+                roundtrip(1, n_tasks, &rx, &tx1);\n             });\n \n-            end_port.recv();\n+            end_rx.recv();\n         });\n \n         fn roundtrip(id: int, n_tasks: int,\n-                     p: &Port<(int, Chan<()>)>,\n-                     ch: &Chan<(int, Chan<()>)>) {\n+                     rx: &Receiver<(int, Sender<()>)>,\n+                     tx: &Sender<(int, Sender<()>)>) {\n             loop {\n-                match p.recv() {\n-                    (1, end_chan) => {\n+                match rx.recv() {\n+                    (1, end_tx) => {\n                         debug!(\"{}\\n\", id);\n-                        end_chan.send(());\n+                        end_tx.send(());\n                         return;\n                     }\n-                    (token, end_chan) => {\n+                    (token, end_tx) => {\n                         debug!(\"thread: {}   got token: {}\", id, token);\n-                        ch.send((token - 1, end_chan));\n+                        tx.send((token - 1, end_tx));\n                         if token <= n_tasks {\n                             return;\n                         }\n@@ -1416,34 +1416,34 @@ mod test {\n             event_loop_factory: Some(basic::event_loop),\n         });\n         pool.spawn(TaskOpts::new(), proc() {\n-            let (port, chan) = Chan::new();\n+            let (tx, rx) = channel();\n \n             // This task should not be able to starve the sender;\n             // The sender should get stolen to another thread.\n             spawn(proc() {\n-                while port.try_recv() != comm::Data(()) { }\n+                while rx.try_recv() != comm::Data(()) { }\n             });\n \n-            chan.send(());\n+            tx.send(());\n         });\n         pool.shutdown();\n     }\n \n     #[test]\n     fn dont_starve_2() {\n         run(proc() {\n-            let (port, chan) = Chan::new();\n-            let (_port2, chan2) = Chan::new();\n+            let (tx1, rx1) = channel();\n+            let (tx2, _rx2) = channel();\n \n             // This task should not be able to starve the other task.\n             // The sends should eventually yield.\n             spawn(proc() {\n-                while port.try_recv() != comm::Data(()) {\n-                    chan2.send(());\n+                while rx1.try_recv() != comm::Data(()) {\n+                    tx2.send(());\n                 }\n             });\n \n-            chan.send(());\n+            tx1.send(());\n         });\n     }\n \n@@ -1466,47 +1466,47 @@ mod test {\n         // without affecting other schedulers\n         for _ in range(0, 20) {\n             let mut pool = pool();\n-            let (start_po, start_ch) = Chan::new();\n-            let (fin_po, fin_ch) = Chan::new();\n+            let (start_tx, start_rx) = channel();\n+            let (fin_tx, fin_rx) = channel();\n \n             let mut handle = pool.spawn_sched();\n             handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n                 unsafe {\n                     let mut guard = LOCK.lock();\n \n-                    start_ch.send(());\n+                    start_tx.send(());\n                     guard.wait();   // block the scheduler thread\n                     guard.signal(); // let them know we have the lock\n                 }\n \n-                fin_ch.send(());\n+                fin_tx.send(());\n             })));\n             drop(handle);\n \n             let mut handle = pool.spawn_sched();\n             handle.send(PinnedTask(pool.task(TaskOpts::new(), proc() {\n                 // Wait until the other task has its lock\n-                start_po.recv();\n+                start_rx.recv();\n \n-                fn pingpong(po: &Port<int>, ch: &Chan<int>) {\n+                fn pingpong(po: &Receiver<int>, ch: &Sender<int>) {\n                     let mut val = 20;\n                     while val > 0 {\n                         val = po.recv();\n                         ch.try_send(val - 1);\n                     }\n                 }\n \n-                let (setup_po, setup_ch) = Chan::new();\n-                let (parent_po, parent_ch) = Chan::new();\n+                let (setup_tx, setup_rx) = channel();\n+                let (parent_tx, parent_rx) = channel();\n                 spawn(proc() {\n-                    let (child_po, child_ch) = Chan::new();\n-                    setup_ch.send(child_ch);\n-                    pingpong(&child_po, &parent_ch);\n+                    let (child_tx, child_rx) = channel();\n+                    setup_tx.send(child_tx);\n+                    pingpong(&child_rx, &parent_tx);\n                 });\n \n-                let child_ch = setup_po.recv();\n-                child_ch.send(20);\n-                pingpong(&parent_po, &child_ch);\n+                let child_tx = setup_rx.recv();\n+                child_tx.send(20);\n+                pingpong(&parent_rx, &child_tx);\n                 unsafe {\n                     let mut guard = LOCK.lock();\n                     guard.signal();   // wakeup waiting scheduler\n@@ -1515,7 +1515,7 @@ mod test {\n             })));\n             drop(handle);\n \n-            fin_po.recv();\n+            fin_rx.recv();\n             pool.shutdown();\n         }\n         unsafe { LOCK.destroy(); }"}, {"sha": "c6608f0c9db89e29df19367121a50cee5473d072", "filename": "src/libgreen/task.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibgreen%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Ftask.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -500,77 +500,76 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n-            c.send(());\n+            tx.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn smoke_fail() {\n-        let (p, c) = Chan::<()>::new();\n+        let (tx, rx) = channel::<int>();\n         spawn_opts(TaskOpts::new(), proc() {\n-            let _c = c;\n+            let _tx = tx;\n             fail!()\n         });\n-        assert_eq!(p.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), None);\n     }\n \n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n-        let (p, c) = Chan::new();\n-        opts.notify_chan = Some(c);\n+        let (tx, rx) = channel();\n+        opts.notify_chan = Some(tx);\n         spawn_opts(opts, proc() {});\n-        assert!(p.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n     }\n \n     #[test]\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n-        let (p, c) = Chan::new();\n-        opts.notify_chan = Some(c);\n+        let (tx, rx) = channel();\n+        opts.notify_chan = Some(tx);\n         spawn_opts(opts, proc() { fail!() });\n-        assert!(p.recv().is_err());\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn yield_test() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n             for _ in range(0, 10) { task::deschedule(); }\n-            c.send(());\n+            tx.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn spawn_children() {\n-        let (p, c) = Chan::new();\n+        let (tx1, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n-            let (p, c2) = Chan::new();\n+            let (tx2, rx) = channel();\n             spawn(proc() {\n-                let (p, c3) = Chan::new();\n+                let (tx3, rx) = channel();\n                 spawn(proc() {\n-                    c3.send(());\n+                    tx3.send(());\n                 });\n-                p.recv();\n-                c2.send(());\n+                rx.recv();\n+                tx2.send(());\n             });\n-            p.recv();\n-            c.send(());\n+            rx.recv();\n+            tx1.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn spawn_inherits() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn_opts(TaskOpts::new(), proc() {\n-            let c = c;\n             spawn(proc() {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<GreenTask>() {\n@@ -580,9 +579,9 @@ mod tests {\n                     None => fail!(),\n                 }\n                 Local::put(task);\n-                c.send(());\n+                tx.send(());\n             });\n         });\n-        p.recv();\n+        rx.recv();\n     }\n }"}, {"sha": "ff1ff9a569d85d13d1a3752f624ef89afdc6be90", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -532,26 +532,24 @@ mod tests {\n     fn test_file_desc() {\n         // Run this test with some pipes so we don't have to mess around with\n         // opening or closing files.\n-        unsafe {\n-            let os::Pipe { input, out } = os::pipe();\n-            let mut reader = FileDesc::new(input, true);\n-            let mut writer = FileDesc::new(out, true);\n-\n-            writer.inner_write(bytes!(\"test\")).unwrap();\n-            let mut buf = [0u8, ..4];\n-            match reader.inner_read(buf) {\n-                Ok(4) => {\n-                    assert_eq!(buf[0], 't' as u8);\n-                    assert_eq!(buf[1], 'e' as u8);\n-                    assert_eq!(buf[2], 's' as u8);\n-                    assert_eq!(buf[3], 't' as u8);\n-                }\n-                r => fail!(\"invalid read: {:?}\", r)\n+        let os::Pipe { input, out } = os::pipe();\n+        let mut reader = FileDesc::new(input, true);\n+        let mut writer = FileDesc::new(out, true);\n+\n+        writer.inner_write(bytes!(\"test\")).unwrap();\n+        let mut buf = [0u8, ..4];\n+        match reader.inner_read(buf) {\n+            Ok(4) => {\n+                assert_eq!(buf[0], 't' as u8);\n+                assert_eq!(buf[1], 'e' as u8);\n+                assert_eq!(buf[2], 's' as u8);\n+                assert_eq!(buf[3], 't' as u8);\n             }\n-\n-            assert!(writer.inner_read(buf).is_err());\n-            assert!(reader.inner_write(buf).is_err());\n+            r => fail!(\"invalid read: {:?}\", r)\n         }\n+\n+        assert!(writer.inner_read(buf).is_err());\n+        assert!(reader.inner_write(buf).is_err());\n     }\n \n     #[test]"}, {"sha": "a054ee66391fa006411657a8278709eb30d2ad7c", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -336,7 +336,7 @@ impl rtio::IoFactory for IoFactory {\n             })\n         }\n     }\n-    fn signal(&mut self, _signal: Signum, _channel: Chan<Signum>)\n+    fn signal(&mut self, _signal: Signum, _channel: Sender<Signum>)\n         -> IoResult<~RtioSignal> {\n         Err(unimpl())\n     }"}, {"sha": "c5b6705ceaa8de3128d8c6a379419ef1d8d266df", "filename": "src/libnative/io/timer_helper.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_helper.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_helper.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_helper.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -33,28 +33,28 @@ use task;\n // only torn down after everything else has exited. This means that these\n // variables are read-only during use (after initialization) and both of which\n // are safe to use concurrently.\n-static mut HELPER_CHAN: *mut Chan<Req> = 0 as *mut Chan<Req>;\n+static mut HELPER_CHAN: *mut Sender<Req> = 0 as *mut Sender<Req>;\n static mut HELPER_SIGNAL: imp::signal = 0 as imp::signal;\n \n static mut TIMER_HELPER_EXIT: StaticNativeMutex = NATIVE_MUTEX_INIT;\n \n-pub fn boot(helper: fn(imp::signal, Port<Req>)) {\n+pub fn boot(helper: fn(imp::signal, Receiver<Req>)) {\n     static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n     static mut INITIALIZED: bool = false;\n \n     unsafe {\n         let mut _guard = LOCK.lock();\n         if !INITIALIZED {\n-            let (msgp, msgc) = Chan::new();\n+            let (tx, rx) = channel();\n             // promote this to a shared channel\n-            drop(msgc.clone());\n-            HELPER_CHAN = cast::transmute(~msgc);\n+            drop(tx.clone());\n+            HELPER_CHAN = cast::transmute(~tx);\n             let (receive, send) = imp::new();\n             HELPER_SIGNAL = send;\n \n             task::spawn(proc() {\n                 bookkeeping::decrement();\n-                helper(receive, msgp);\n+                helper(receive, rx);\n                 TIMER_HELPER_EXIT.lock().signal()\n             });\n \n@@ -86,8 +86,8 @@ fn shutdown() {\n     // Clean up after ther helper thread\n     unsafe {\n         imp::close(HELPER_SIGNAL);\n-        let _chan: ~Chan<Req> = cast::transmute(HELPER_CHAN);\n-        HELPER_CHAN = 0 as *mut Chan<Req>;\n+        let _chan: ~Sender<Req> = cast::transmute(HELPER_CHAN);\n+        HELPER_CHAN = 0 as *mut Sender<Req>;\n         HELPER_SIGNAL = 0 as imp::signal;\n     }\n }"}, {"sha": "edd7af312c802d3f33a08652969ec4b2a6ae9ae8", "filename": "src/libnative/io/timer_other.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_other.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_other.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_other.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -64,7 +64,7 @@ pub struct Timer {\n }\n \n struct Inner {\n-    chan: Option<Chan<()>>,\n+    tx: Option<Sender<()>>,\n     interval: u64,\n     repeat: bool,\n     target: u64,\n@@ -78,7 +78,7 @@ pub enum Req {\n \n     // Remove a timer based on its id and then send it back on the channel\n     // provided\n-    RemoveTimer(uint, Chan<~Inner>),\n+    RemoveTimer(uint, Sender<~Inner>),\n \n     // Shut down the loop and then ACK this channel once it's shut down\n     Shutdown,\n@@ -93,7 +93,7 @@ fn now() -> u64 {\n     }\n }\n \n-fn helper(input: libc::c_int, messages: Port<Req>) {\n+fn helper(input: libc::c_int, messages: Receiver<Req>) {\n     let mut set: imp::fd_set = unsafe { mem::init() };\n \n     let mut fd = FileDesc::new(input, true);\n@@ -118,13 +118,13 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n         let mut timer = match active.shift() {\n             Some(timer) => timer, None => return\n         };\n-        let chan = timer.chan.take_unwrap();\n-        if chan.try_send(()) && timer.repeat {\n-            timer.chan = Some(chan);\n+        let tx = timer.tx.take_unwrap();\n+        if tx.try_send(()) && timer.repeat {\n+            timer.tx = Some(tx);\n             timer.target += timer.interval;\n             insert(timer, active);\n         } else {\n-            drop(chan);\n+            drop(tx);\n             dead.push((timer.id, timer));\n         }\n     }\n@@ -208,7 +208,7 @@ impl Timer {\n         Ok(Timer {\n             id: id,\n             inner: Some(~Inner {\n-                chan: None,\n+                tx: None,\n                 interval: 0,\n                 target: 0,\n                 repeat: false,\n@@ -233,9 +233,9 @@ impl Timer {\n         match self.inner.take() {\n             Some(i) => i,\n             None => {\n-                let (p, c) = Chan::new();\n-                timer_helper::send(RemoveTimer(self.id, c));\n-                p.recv()\n+                let (tx, rx) = channel();\n+                timer_helper::send(RemoveTimer(self.id, tx));\n+                rx.recv()\n             }\n         }\n     }\n@@ -244,38 +244,38 @@ impl Timer {\n impl rtio::RtioTimer for Timer {\n     fn sleep(&mut self, msecs: u64) {\n         let mut inner = self.inner();\n-        inner.chan = None; // cancel any previous request\n+        inner.tx = None; // cancel any previous request\n         self.inner = Some(inner);\n \n         Timer::sleep(msecs);\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         inner.repeat = false;\n-        inner.chan = Some(c);\n+        inner.tx = Some(tx);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         timer_helper::send(NewTimer(inner));\n-        return p;\n+        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Port<()> {\n+    fn period(&mut self, msecs: u64) -> Receiver<()> {\n         let now = now();\n         let mut inner = self.inner();\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         inner.repeat = true;\n-        inner.chan = Some(c);\n+        inner.tx = Some(tx);\n         inner.interval = msecs;\n         inner.target = now + msecs;\n \n         timer_helper::send(NewTimer(inner));\n-        return p;\n+        return rx;\n     }\n }\n "}, {"sha": "1b0e08ca6fb97883f03c8cffe52a6a182e681126", "filename": "src/libnative/io/timer_timerfd.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_timerfd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_timerfd.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -46,12 +46,12 @@ pub struct Timer {\n \n #[allow(visible_private_types)]\n pub enum Req {\n-    NewTimer(libc::c_int, Chan<()>, bool, imp::itimerspec),\n-    RemoveTimer(libc::c_int, Chan<()>),\n+    NewTimer(libc::c_int, Sender<()>, bool, imp::itimerspec),\n+    RemoveTimer(libc::c_int, Sender<()>),\n     Shutdown,\n }\n \n-fn helper(input: libc::c_int, messages: Port<Req>) {\n+fn helper(input: libc::c_int, messages: Receiver<Req>) {\n     let efd = unsafe { imp::epoll_create(10) };\n     let _fd1 = FileDesc::new(input, true);\n     let _fd2 = FileDesc::new(efd, true);\n@@ -76,7 +76,7 @@ fn helper(input: libc::c_int, messages: Port<Req>) {\n \n     add(efd, input);\n     let events: [imp::epoll_event, ..16] = unsafe { mem::init() };\n-    let mut list: ~[(libc::c_int, Chan<()>, bool)] = ~[];\n+    let mut list: ~[(libc::c_int, Sender<()>, bool)] = ~[];\n     'outer: loop {\n         let n = match unsafe {\n             imp::epoll_wait(efd, events.as_ptr(),\n@@ -197,9 +197,9 @@ impl Timer {\n     fn remove(&mut self) {\n         if !self.on_worker { return }\n \n-        let (p, c) = Chan::new();\n-        timer_helper::send(RemoveTimer(self.fd.fd(), c));\n-        p.recv();\n+        let (tx, rx) = channel();\n+        timer_helper::send(RemoveTimer(self.fd.fd(), tx));\n+        rx.recv();\n         self.on_worker = false;\n     }\n }\n@@ -224,8 +224,8 @@ impl rtio::RtioTimer for Timer {\n     // before returning to guarantee the invariant that when oneshot() and\n     // period() return that the old port will never receive any more messages.\n \n-    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n-        let (p, c) = Chan::new();\n+    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+        let (tx, rx) = channel();\n \n         let new_value = imp::itimerspec {\n             it_interval: imp::timespec { tv_sec: 0, tv_nsec: 0 },\n@@ -234,26 +234,26 @@ impl rtio::RtioTimer for Timer {\n                 tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n             }\n         };\n-        timer_helper::send(NewTimer(self.fd.fd(), c, true, new_value));\n-        p.recv();\n+        timer_helper::send(NewTimer(self.fd.fd(), tx, true, new_value));\n+        rx.recv();\n         self.on_worker = true;\n \n-        return p;\n+        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Port<()> {\n-        let (p, c) = Chan::new();\n+    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+        let (tx, rx) = channel();\n \n         let spec = imp::timespec {\n             tv_sec: (msecs / 1000) as libc::time_t,\n             tv_nsec: ((msecs % 1000) * 1000000) as libc::c_long,\n         };\n         let new_value = imp::itimerspec { it_interval: spec, it_value: spec, };\n-        timer_helper::send(NewTimer(self.fd.fd(), c, false, new_value));\n-        p.recv();\n+        timer_helper::send(NewTimer(self.fd.fd(), tx, false, new_value));\n+        rx.recv();\n         self.on_worker = true;\n \n-        return p;\n+        return rx;\n     }\n }\n "}, {"sha": "cdfe2e0d033728c94213ef1781074a618df339be", "filename": "src/libnative/io/timer_win32.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_win32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Fio%2Ftimer_win32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_win32.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -34,12 +34,12 @@ pub struct Timer {\n }\n \n pub enum Req {\n-    NewTimer(libc::HANDLE, Chan<()>, bool),\n-    RemoveTimer(libc::HANDLE, Chan<()>),\n+    NewTimer(libc::HANDLE, Sender<()>, bool),\n+    RemoveTimer(libc::HANDLE, Sender<()>),\n     Shutdown,\n }\n \n-fn helper(input: libc::HANDLE, messages: Port<Req>) {\n+fn helper(input: libc::HANDLE, messages: Receiver<Req>) {\n     let mut objs = ~[input];\n     let mut chans = ~[];\n \n@@ -113,9 +113,9 @@ impl Timer {\n     fn remove(&mut self) {\n         if !self.on_worker { return }\n \n-        let (p, c) = Chan::new();\n-        timer_helper::send(RemoveTimer(self.obj, c));\n-        p.recv();\n+        let (tx, rx) = channel();\n+        timer_helper::send(RemoveTimer(self.obj, tx));\n+        rx.recv();\n \n         self.on_worker = false;\n     }\n@@ -136,9 +136,9 @@ impl rtio::RtioTimer for Timer {\n         let _ = unsafe { imp::WaitForSingleObject(self.obj, libc::INFINITE) };\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n         self.remove();\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n@@ -147,14 +147,14 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, c, true));\n+        timer_helper::send(NewTimer(self.obj, tx, true));\n         self.on_worker = true;\n-        return p;\n+        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Port<()> {\n+    fn period(&mut self, msecs: u64) -> Receiver<()> {\n         self.remove();\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // see above for the calculation\n         let due = -(msecs * 10000) as libc::LARGE_INTEGER;\n@@ -163,10 +163,10 @@ impl rtio::RtioTimer for Timer {\n                                   ptr::null(), ptr::mut_null(), 0)\n         }, 1);\n \n-        timer_helper::send(NewTimer(self.obj, c, false));\n+        timer_helper::send(NewTimer(self.obj, tx, false));\n         self.on_worker = true;\n \n-        return p;\n+        return rx;\n     }\n }\n "}, {"sha": "8510b50777abde50d1b5740d7e9a0baa95002488", "filename": "src/libnative/task.rs", "status": "modified", "additions": 27, "deletions": 28, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -262,77 +262,76 @@ mod tests {\n \n     #[test]\n     fn smoke() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            c.send(());\n+            tx.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn smoke_fail() {\n-        let (p, c) = Chan::<()>::new();\n+        let (tx, rx) = channel::<()>();\n         spawn(proc() {\n-            let _c = c;\n+            let _tx = tx;\n             fail!()\n         });\n-        assert_eq!(p.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), None);\n     }\n \n     #[test]\n     fn smoke_opts() {\n         let mut opts = TaskOpts::new();\n         opts.name = Some(\"test\".into_maybe_owned());\n         opts.stack_size = Some(20 * 4096);\n-        let (p, c) = Chan::new();\n-        opts.notify_chan = Some(c);\n+        let (tx, rx) = channel();\n+        opts.notify_chan = Some(tx);\n         spawn_opts(opts, proc() {});\n-        assert!(p.recv().is_ok());\n+        assert!(rx.recv().is_ok());\n     }\n \n     #[test]\n     fn smoke_opts_fail() {\n         let mut opts = TaskOpts::new();\n-        let (p, c) = Chan::new();\n-        opts.notify_chan = Some(c);\n+        let (tx, rx) = channel();\n+        opts.notify_chan = Some(tx);\n         spawn_opts(opts, proc() { fail!() });\n-        assert!(p.recv().is_err());\n+        assert!(rx.recv().is_err());\n     }\n \n     #[test]\n     fn yield_test() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n             for _ in range(0, 10) { task::deschedule(); }\n-            c.send(());\n+            tx.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn spawn_children() {\n-        let (p, c) = Chan::new();\n+        let (tx1, rx) = channel();\n         spawn(proc() {\n-            let (p, c2) = Chan::new();\n+            let (tx2, rx) = channel();\n             spawn(proc() {\n-                let (p, c3) = Chan::new();\n+                let (tx3, rx) = channel();\n                 spawn(proc() {\n-                    c3.send(());\n+                    tx3.send(());\n                 });\n-                p.recv();\n-                c2.send(());\n+                rx.recv();\n+                tx2.send(());\n             });\n-            p.recv();\n-            c.send(());\n+            rx.recv();\n+            tx1.send(());\n         });\n-        p.recv();\n+        rx.recv();\n     }\n \n     #[test]\n     fn spawn_inherits() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            let c = c;\n             spawn(proc() {\n                 let mut task: ~Task = Local::take();\n                 match task.maybe_take_runtime::<Ops>() {\n@@ -342,9 +341,9 @@ mod tests {\n                     None => fail!(),\n                 }\n                 Local::put(task);\n-                c.send(());\n+                tx.send(());\n             });\n         });\n-        p.recv();\n+        rx.recv();\n     }\n }"}, {"sha": "0b11cfb0ac60d6b568f90350c2363a7d69545b86", "filename": "src/librand/os.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Fos.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -149,13 +149,13 @@ mod test {\n     #[test]\n     fn test_os_rng_tasks() {\n \n-        let mut chans = ~[];\n+        let mut txs = ~[];\n         for _ in range(0, 20) {\n-            let (p, c) = Chan::new();\n-            chans.push(c);\n+            let (tx, rx) = channel();\n+            txs.push(tx);\n             task::spawn(proc() {\n                 // wait until all the tasks are ready to go.\n-                p.recv();\n+                rx.recv();\n \n                 // deschedule to attempt to interleave things as much\n                 // as possible (XXX: is this a good test?)\n@@ -175,8 +175,8 @@ mod test {\n         }\n \n         // start all the tasks\n-        for c in chans.iter() {\n-            c.send(())\n+        for tx in txs.iter() {\n+            tx.send(())\n         }\n     }\n }"}, {"sha": "764eba56dae7ea43b9395d8868205b0ed29270f1", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -379,9 +379,9 @@ pub fn monitor(f: proc()) {\n         task_builder.opts.stack_size = Some(STACK_SIZE);\n     }\n \n-    let (p, c) = Chan::new();\n-    let w = io::ChanWriter::new(c);\n-    let mut r = io::PortReader::new(p);\n+    let (tx, rx) = channel();\n+    let w = io::ChanWriter::new(tx);\n+    let mut r = io::ChanReader::new(rx);\n \n     match task_builder.try(proc() {\n         io::stdio::set_stderr(~w as ~io::Writer);"}, {"sha": "66dc9567e7531810892b1035ab412104d6e43a63", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -116,12 +116,12 @@ fn runtest(test: &str, cratename: &str, libs: HashSet<Path>, should_fail: bool,\n     //\n     // The basic idea is to not use a default_handler() for rustc, and then also\n     // not print things by default to the actual stderr.\n-    let (p, c) = Chan::new();\n-    let w1 = io::ChanWriter::new(c);\n+    let (tx, rx) = channel();\n+    let w1 = io::ChanWriter::new(tx);\n     let w2 = w1.clone();\n     let old = io::stdio::set_stderr(~w1);\n     spawn(proc() {\n-        let mut p = io::PortReader::new(p);\n+        let mut p = io::ChanReader::new(rx);\n         let mut err = old.unwrap_or(~io::stderr() as ~Writer);\n         io::util::copy(&mut p, &mut err).unwrap();\n     });"}, {"sha": "bda859afc0b9de1730ac08fdf5fd0f47a847508d", "filename": "src/librustuv/async.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fasync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fasync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fasync.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -135,7 +135,7 @@ mod test_remote {\n     // actually trigger what they say they will.\n     #[test]\n     fn smoke_test() {\n-        struct MyCallback(Option<Chan<int>>);\n+        struct MyCallback(Option<Sender<int>>);\n         impl Callback for MyCallback {\n             fn call(&mut self) {\n                 // this can get called more than once, but we only want to send\n@@ -147,8 +147,8 @@ mod test_remote {\n             }\n         }\n \n-        let (port, chan) = Chan::new();\n-        let cb = ~MyCallback(Some(chan));\n+        let (tx, rx) = channel();\n+        let cb = ~MyCallback(Some(tx));\n         let watcher = AsyncWatcher::new(&mut local_loop().loop_,\n                                         cb as ~Callback);\n \n@@ -157,7 +157,7 @@ mod test_remote {\n             watcher.fire();\n         });\n \n-        assert_eq!(port.recv(), 1);\n+        assert_eq!(rx.recv(), 1);\n         thread.join();\n     }\n }"}, {"sha": "a37d3fd249f9bb37a54b87d99d026b10913d904f", "filename": "src/librustuv/homing.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fhoming.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fhoming.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fhoming.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -164,19 +164,19 @@ mod test {\n     // thread, close itself, and then come back to the last thread.\n     #[test]\n     fn test_homing_closes_correctly() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 1,\n             event_loop_factory: None,\n         });\n \n         pool.spawn(TaskOpts::new(), proc() {\n             let listener = UdpWatcher::bind(local_loop(), next_test_ip4());\n-            chan.send(listener.unwrap());\n+            tx.send(listener.unwrap());\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n-            drop(port.recv());\n+            drop(rx.recv());\n         });\n         pool.spawn_sched().send(sched::TaskFromFriend(task));\n \n@@ -185,7 +185,7 @@ mod test {\n \n     #[test]\n     fn test_homing_read() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let mut pool = SchedPool::new(PoolConfig {\n             threads: 1,\n             event_loop_factory: None,\n@@ -195,13 +195,13 @@ mod test {\n             let addr1 = next_test_ip4();\n             let addr2 = next_test_ip4();\n             let listener = UdpWatcher::bind(local_loop(), addr2);\n-            chan.send((listener.unwrap(), addr1));\n+            tx.send((listener.unwrap(), addr1));\n             let mut listener = UdpWatcher::bind(local_loop(), addr1).unwrap();\n             listener.sendto([1, 2, 3, 4], addr2).unwrap();\n         });\n \n         let task = pool.task(TaskOpts::new(), proc() {\n-            let (mut watcher, addr) = port.recv();\n+            let (mut watcher, addr) = rx.recv();\n             let mut buf = [0, ..10];\n             assert_eq!(watcher.recvfrom(buf).unwrap(), (4, addr));\n         });"}, {"sha": "2ad40026cad985506efafe1049c4e7915bd8fbd7", "filename": "src/librustuv/net.rs", "status": "modified", "additions": 44, "deletions": 44, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fnet.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -167,8 +167,8 @@ pub struct TcpListener {\n     home: HomeHandle,\n     handle: *uvll::uv_pipe_t,\n     priv closing_task: Option<BlockedTask>,\n-    priv outgoing: Chan<Result<~rtio::RtioTcpStream, IoError>>,\n-    priv incoming: Port<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv outgoing: Sender<Result<~rtio::RtioTcpStream, IoError>>,\n+    priv incoming: Receiver<Result<~rtio::RtioTcpStream, IoError>>,\n }\n \n pub struct TcpAcceptor {\n@@ -329,13 +329,13 @@ impl TcpListener {\n         assert_eq!(unsafe {\n             uvll::uv_tcp_init(io.uv_loop(), handle)\n         }, 0);\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let l = ~TcpListener {\n             home: io.make_handle(),\n             handle: handle,\n             closing_task: None,\n-            outgoing: chan,\n-            incoming: port,\n+            outgoing: tx,\n+            incoming: rx,\n         };\n         let (addr, _len) = addr_to_sockaddr(address);\n         let res = unsafe {\n@@ -741,7 +741,7 @@ mod test {\n \n     #[test]\n     fn listen_ip4() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let addr = next_test_ip4();\n \n         spawn(proc() {\n@@ -751,7 +751,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.send(());\n+            tx.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -766,7 +766,7 @@ mod test {\n             }\n         });\n \n-        port.recv();\n+        rx.recv();\n         let mut w = match TcpWatcher::connect(local_loop(), addr) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n@@ -777,7 +777,7 @@ mod test {\n \n     #[test]\n     fn listen_ip6() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let addr = next_test_ip6();\n \n         spawn(proc() {\n@@ -787,7 +787,7 @@ mod test {\n             let mut w = match w.listen() {\n                 Ok(w) => w, Err(e) => fail!(\"{:?}\", e),\n             };\n-            chan.send(());\n+            tx.send(());\n             match w.accept() {\n                 Ok(mut stream) => {\n                     let mut buf = [0u8, ..10];\n@@ -802,7 +802,7 @@ mod test {\n             }\n         });\n \n-        port.recv();\n+        rx.recv();\n         let mut w = match TcpWatcher::connect(local_loop(), addr) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n@@ -813,14 +813,14 @@ mod test {\n \n     #[test]\n     fn udp_recv_ip4() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let client = next_test_ip4();\n         let server = next_test_ip4();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.send(());\n+                    tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -834,7 +834,7 @@ mod test {\n             }\n         });\n \n-        port.recv();\n+        rx.recv();\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n@@ -845,14 +845,14 @@ mod test {\n \n     #[test]\n     fn udp_recv_ip6() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let client = next_test_ip6();\n         let server = next_test_ip6();\n \n         spawn(proc() {\n             match UdpWatcher::bind(local_loop(), server) {\n                 Ok(mut w) => {\n-                    chan.send(());\n+                    tx.send(());\n                     let mut buf = [0u8, ..10];\n                     match w.recvfrom(buf) {\n                         Ok((10, addr)) => assert_eq!(addr, client),\n@@ -866,7 +866,7 @@ mod test {\n             }\n         });\n \n-        port.recv();\n+        rx.recv();\n         let mut w = match UdpWatcher::bind(local_loop(), client) {\n             Ok(w) => w, Err(e) => fail!(\"{:?}\", e)\n         };\n@@ -879,12 +879,12 @@ mod test {\n     fn test_read_read_read() {\n         let addr = next_test_ip4();\n         static MAX: uint = 5000;\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n             let listener = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut acceptor = listener.listen().unwrap();\n-            chan.send(());\n+            tx.send(());\n             let mut stream = acceptor.accept().unwrap();\n             let buf = [1, .. 2048];\n             let mut total_bytes_written = 0;\n@@ -895,7 +895,7 @@ mod test {\n             }\n         });\n \n-        port.recv();\n+        rx.recv();\n         let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n         let mut buf = [0, .. 2048];\n         let mut total_bytes_read = 0;\n@@ -914,17 +914,17 @@ mod test {\n     fn test_udp_twice() {\n         let server_addr = next_test_ip4();\n         let client_addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n             let mut client = UdpWatcher::bind(local_loop(), client_addr).unwrap();\n-            port.recv();\n+            rx.recv();\n             assert!(client.sendto([1], server_addr).is_ok());\n             assert!(client.sendto([2], server_addr).is_ok());\n         });\n \n         let mut server = UdpWatcher::bind(local_loop(), server_addr).unwrap();\n-        chan.send(());\n+        tx.send(());\n         let mut buf1 = [0];\n         let mut buf2 = [0];\n         let (nread1, src1) = server.recvfrom(buf1).unwrap();\n@@ -945,16 +945,16 @@ mod test {\n         let client_in_addr = next_test_ip4();\n         static MAX: uint = 500_000;\n \n-        let (p1, c1) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel::<()>();\n+        let (tx2, rx2) = channel::<()>();\n \n         spawn(proc() {\n             let l = local_loop();\n             let mut server_out = UdpWatcher::bind(l, server_out_addr).unwrap();\n             let mut server_in = UdpWatcher::bind(l, server_in_addr).unwrap();\n-            let (port, chan) = (p1, c2);\n-            chan.send(());\n-            port.recv();\n+            let (tx, rx) = (tx2, rx1);\n+            tx.send(());\n+            rx.recv();\n             let msg = [1, .. 2048];\n             let mut total_bytes_sent = 0;\n             let mut buf = [1];\n@@ -975,9 +975,9 @@ mod test {\n         let l = local_loop();\n         let mut client_out = UdpWatcher::bind(l, client_out_addr).unwrap();\n         let mut client_in = UdpWatcher::bind(l, client_in_addr).unwrap();\n-        let (port, chan) = (p2, c1);\n-        port.recv();\n-        chan.send(());\n+        let (tx, rx) = (tx1, rx2);\n+        rx.recv();\n+        tx.send(());\n         let mut total_bytes_recv = 0;\n         let mut buf = [0, .. 2048];\n         while total_bytes_recv < MAX {\n@@ -1000,23 +1000,23 @@ mod test {\n     #[test]\n     fn test_read_and_block() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::<Port<()>>::new();\n+        let (tx, rx) = channel::<Receiver<()>>();\n \n         spawn(proc() {\n-            let port2 = port.recv();\n+            let rx = rx.recv();\n             let mut stream = TcpWatcher::connect(local_loop(), addr).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            port2.recv();\n+            rx.recv();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n             stream.write([0, 1, 2, 3, 4, 5, 6, 7]).unwrap();\n-            port2.recv();\n+            rx.recv();\n         });\n \n         let listener = TcpListener::bind(local_loop(), addr).unwrap();\n         let mut acceptor = listener.listen().unwrap();\n-        let (port2, chan2) = Chan::new();\n-        chan.send(port2);\n+        let (tx2, rx2) = channel();\n+        tx.send(rx2);\n         let mut stream = acceptor.accept().unwrap();\n         let mut buf = [0, .. 2048];\n \n@@ -1033,7 +1033,7 @@ mod test {\n             }\n             reads += 1;\n \n-            chan2.try_send(());\n+            tx2.try_send(());\n         }\n \n         // Make sure we had multiple reads\n@@ -1073,16 +1073,16 @@ mod test {\n \n     #[should_fail] #[test]\n     fn tcp_stream_fail_cleanup() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let addr = next_test_ip4();\n \n         spawn(proc() {\n             let w = TcpListener::bind(local_loop(), addr).unwrap();\n             let mut w = w.listen().unwrap();\n-            chan.send(());\n+            tx.send(());\n             drop(w.accept().unwrap());\n         });\n-        port.recv();\n+        rx.recv();\n         let _w = TcpWatcher::connect(local_loop(), addr).unwrap();\n         fail!();\n     }\n@@ -1097,17 +1097,17 @@ mod test {\n     #[should_fail] #[test]\n     fn udp_fail_other_task() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // force the handle to be created on a different scheduler, failure in\n         // the original task will force a homing operation back to this\n         // scheduler.\n         spawn(proc() {\n             let w = UdpWatcher::bind(local_loop(), addr).unwrap();\n-            chan.send(w);\n+            tx.send(w);\n         });\n \n-        let _w = port.recv();\n+        let _w = rx.recv();\n         fail!();\n     }\n }"}, {"sha": "8d5e7c6f522e087f1bd068599b2335aa19ae7546", "filename": "src/librustuv/pipe.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fpipe.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -37,8 +37,8 @@ pub struct PipeWatcher {\n pub struct PipeListener {\n     home: HomeHandle,\n     pipe: *uvll::uv_pipe_t,\n-    priv outgoing: Chan<Result<~RtioPipe, IoError>>,\n-    priv incoming: Port<Result<~RtioPipe, IoError>>,\n+    priv outgoing: Sender<Result<~RtioPipe, IoError>>,\n+    priv incoming: Receiver<Result<~RtioPipe, IoError>>,\n }\n \n pub struct PipeAcceptor {\n@@ -182,12 +182,12 @@ impl PipeListener {\n                 // If successful, unwrap the PipeWatcher because we control how\n                 // we close the pipe differently. We can't rely on\n                 // StreamWatcher's default close method.\n-                let (port, chan) = Chan::new();\n+                let (tx, rx) = channel();\n                 let p = ~PipeListener {\n                     home: io.make_handle(),\n                     pipe: pipe.unwrap(),\n-                    incoming: port,\n-                    outgoing: chan,\n+                    incoming: rx,\n+                    outgoing: tx,\n                 };\n                 Ok(p.install())\n             }\n@@ -299,19 +299,19 @@ mod tests {\n     fn connect() {\n         let path = next_test_unix();\n         let path2 = path.clone();\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.send(());\n+            tx.send(());\n             let mut client = p.accept().unwrap();\n             let mut buf = [0];\n             assert!(client.read(buf).unwrap() == 1);\n             assert_eq!(buf[0], 1);\n             assert!(client.write([2]).is_ok());\n         });\n-        port.recv();\n+        rx.recv();\n         let mut c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n         assert!(c.write([1]).is_ok());\n         let mut buf = [0];\n@@ -323,15 +323,15 @@ mod tests {\n     fn connect_fail() {\n         let path = next_test_unix();\n         let path2 = path.clone();\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n             let p = PipeListener::bind(local_loop(), &path2.to_c_str()).unwrap();\n             let mut p = p.listen().unwrap();\n-            chan.send(());\n+            tx.send(());\n             drop(p.accept().unwrap());\n         });\n-        port.recv();\n+        rx.recv();\n         let _c = PipeWatcher::connect(local_loop(), &path.to_c_str()).unwrap();\n         fail!()\n "}, {"sha": "25cc8b8a8fbe8cf3453e4311e158a511ec22b290", "filename": "src/librustuv/signal.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fsignal.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -21,13 +21,13 @@ pub struct SignalWatcher {\n     handle: *uvll::uv_signal_t,\n     home: HomeHandle,\n \n-    channel: Chan<Signum>,\n+    channel: Sender<Signum>,\n     signal: Signum,\n }\n \n impl SignalWatcher {\n     pub fn new(io: &mut UvIoFactory, signum: Signum,\n-               channel: Chan<Signum>) -> Result<~SignalWatcher, UvError> {\n+               channel: Sender<Signum>) -> Result<~SignalWatcher, UvError> {\n         let s = ~SignalWatcher {\n             handle: UvHandle::alloc(None::<SignalWatcher>, uvll::UV_SIGNAL),\n             home: io.make_handle(),\n@@ -80,12 +80,12 @@ mod test {\n     #[test]\n     fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375, relates to timers as well.\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let _signal = SignalWatcher::new(local_loop(), signal::Interrupt,\n-                                         chan);\n+                                         tx);\n \n         spawn(proc() {\n-            let _ = port.recv_opt();\n+            let _ = rx.recv_opt();\n         });\n \n         // when we drop the SignalWatcher we're going to destroy the channel,"}, {"sha": "6cbba8e6fd452eaea47dec7f19d2498baaac6836", "filename": "src/librustuv/timer.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Ftimer.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -28,8 +28,8 @@ pub struct TimerWatcher {\n \n pub enum NextAction {\n     WakeTask,\n-    SendOnce(Chan<()>),\n-    SendMany(Chan<()>, uint),\n+    SendOnce(Sender<()>),\n+    SendMany(Sender<()>, uint),\n }\n \n impl TimerWatcher {\n@@ -97,8 +97,8 @@ impl RtioTimer for TimerWatcher {\n         self.stop();\n     }\n \n-    fn oneshot(&mut self, msecs: u64) -> Port<()> {\n-        let (port, chan) = Chan::new();\n+    fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n+        let (tx, rx) = channel();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n@@ -107,14 +107,14 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, 0);\n-            mem::replace(&mut self.action, Some(SendOnce(chan)))\n+            mem::replace(&mut self.action, Some(SendOnce(tx)))\n         };\n \n-        return port;\n+        return rx;\n     }\n \n-    fn period(&mut self, msecs: u64) -> Port<()> {\n-        let (port, chan) = Chan::new();\n+    fn period(&mut self, msecs: u64) -> Receiver<()> {\n+        let (tx, rx) = channel();\n \n         // similarly to the destructor, we must drop the previous action outside\n         // of the homing missile\n@@ -123,10 +123,10 @@ impl RtioTimer for TimerWatcher {\n             self.id += 1;\n             self.stop();\n             self.start(msecs, msecs);\n-            mem::replace(&mut self.action, Some(SendMany(chan, self.id)))\n+            mem::replace(&mut self.action, Some(SendMany(tx, self.id)))\n         };\n \n-        return port;\n+        return rx;\n     }\n }\n "}, {"sha": "e4326fe36bfed0bdb327a4736205d8df0948a802", "filename": "src/librustuv/uvio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fuvio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibrustuv%2Fuvio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustuv%2Fuvio.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -311,7 +311,7 @@ impl IoFactory for UvIoFactory {\n         }\n     }\n \n-    fn signal(&mut self, signum: Signum, channel: Chan<Signum>)\n+    fn signal(&mut self, signum: Signum, channel: Sender<Signum>)\n         -> Result<~rtio::RtioSignal, IoError> {\n         match SignalWatcher::new(self, signum, channel) {\n             Ok(s) => Ok(s as ~rtio::RtioSignal),"}, {"sha": "e25571dd246c83f7e4e4aff0ef63ab4d93fd4b27", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 306, "deletions": 306, "changes": 612, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -8,38 +8,38 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Communication primitives for concurrent tasks (`Chan` and `Port` types)\n+//! Communication primitives for concurrent tasks\n //!\n //! Rust makes it very difficult to share data among tasks to prevent race\n //! conditions and to improve parallelism, but there is often a need for\n //! communication between concurrent tasks. The primitives defined in this\n //! module are the building blocks for synchronization in rust.\n //!\n-//! This module currently provides two types:\n+//! This module provides message-based communication over channels, concretely\n+//! defined as two types:\n //!\n-//! * `Chan`\n-//! * `Port`\n+//! * `Sender`\n+//! * `Receiver`\n //!\n-//! `Chan` is used to send data to a `Port`. A `Chan` is clone-able such that\n-//! many tasks can send simultaneously to one receiving port. These\n-//! communication primitives are *task blocking*, not *thread blocking*. This\n-//! means that if one task is blocked on a channel, other tasks can continue to\n-//! make progress.\n+//! A `Sender` is used to send data to a `Receiver`. A `Sender` is clone-able\n+//! such that many tasks can send simultaneously to one receiver. These\n+//! channels are *task blocking*, not *thread blocking*. This means that if one\n+//! task is blocked on a channel, other tasks can continue to make progress.\n //!\n //! Rust channels can be used as if they have an infinite internal buffer. What\n-//! this means is that the `send` operation will never block. `Port`s, on the\n-//! other hand, will block the task if there is no data to be received.\n+//! this means is that the `send` operation will never block. `Receiver`s, on\n+//! the other hand, will block the task if there is no data to be received.\n //!\n //! ## Failure Propagation\n //!\n //! In addition to being a core primitive for communicating in rust, channels\n-//! and ports are the points at which failure is propagated among tasks.\n-//! Whenever the one half of channel is closed, the other half will have its\n-//! next operation `fail!`. The purpose of this is to allow propagation of\n-//! failure among tasks that are linked to one another via channels.\n+//! are the points at which failure is propagated among tasks.  Whenever the one\n+//! half of channel is closed, the other half will have its next operation\n+//! `fail!`. The purpose of this is to allow propagation of failure among tasks\n+//! that are linked to one another via channels.\n //!\n-//! There are methods on both of `Chan` and `Port` to perform their respective\n-//! operations without failing, however.\n+//! There are methods on both of `Sender` and `Receiver` to perform their\n+//! respective operations without failing, however.\n //!\n //! ## Outside the Runtime\n //!\n@@ -58,31 +58,31 @@\n //!\n //! ```rust,should_fail\n //! // Create a simple streaming channel\n-//! let (port, chan) = Chan::new();\n+//! let (tx, rx) = channel();\n //! spawn(proc() {\n-//!     chan.send(10);\n+//!     tx.send(10);\n //! });\n-//! assert_eq!(port.recv(), 10);\n+//! assert_eq!(rx.recv(), 10);\n //!\n //! // Create a shared channel which can be sent along from many tasks\n-//! let (port, chan) = Chan::new();\n+//! let (tx, rx) = channel();\n //! for i in range(0, 10) {\n-//!     let chan = chan.clone();\n+//!     let tx = tx.clone();\n //!     spawn(proc() {\n-//!         chan.send(i);\n+//!         tx.send(i);\n //!     })\n //! }\n //!\n //! for _ in range(0, 10) {\n-//!     let j = port.recv();\n+//!     let j = rx.recv();\n //!     assert!(0 <= j && j < 10);\n //! }\n //!\n //! // The call to recv() will fail!() because the channel has already hung\n //! // up (or been deallocated)\n-//! let (port, chan) = Chan::<int>::new();\n-//! drop(chan);\n-//! port.recv();\n+//! let (tx, rx) = channel::<int>();\n+//! drop(tx);\n+//! rx.recv();\n //! ```\n \n // A description of how Rust's channel implementation works\n@@ -118,7 +118,7 @@\n //\n // ## Concurrent queues\n //\n-// The basic idea of Rust's Chan/Port types is that send() never blocks, but\n+// The basic idea of Rust's Sender/Receiver types is that send() never blocks, but\n // recv() obviously blocks. This means that under the hood there must be some\n // shared and concurrent queue holding all of the actual data.\n //\n@@ -177,10 +177,9 @@\n //\n // ### The internal atomic counter\n //\n-// Every channel/port/shared channel have a shared counter with their\n-// counterparts to keep track of the size of the queue. This counter is used to\n-// abort descheduling by the receiver and to know when to wake up on the sending\n-// side.\n+// Every channel has a shared counter with each half to keep track of the size\n+// of the queue. This counter is used to abort descheduling by the receiver and\n+// to know when to wake up on the sending side.\n //\n // As seen in the pseudocode, senders will increment this count and receivers\n // will decrement the count. The theory behind this is that if a sender sees a\n@@ -195,7 +194,7 @@\n // it was actually appropriate to wake up a receiver.\n //\n // Instead, the \"steal count\" is kept track of separately (not atomically\n-// because it's only used by ports), and then the decrement() call when\n+// because it's only used by receivers), and then the decrement() call when\n // descheduling will lump in all of the recent steals into one large decrement.\n //\n // The implication of this is that if a sender sees a -1 count, then there's\n@@ -269,9 +268,9 @@ macro_rules! test (\n             $($a)* #[test] fn uv() { f() }\n             $($a)* #[test] fn native() {\n                 use native;\n-                let (p, c) = Chan::new();\n-                native::task::spawn(proc() { c.send(f()) });\n-                p.recv();\n+                let (tx, rx) = channel();\n+                native::task::spawn(proc() { tx.send(f()) });\n+                rx.recv();\n             }\n         }\n     )\n@@ -288,23 +287,23 @@ static RESCHED_FREQ: int = 256;\n \n /// The receiving-half of Rust's channel type. This half can only be owned by\n /// one task\n-pub struct Port<T> {\n+pub struct Receiver<T> {\n     priv inner: Flavor<T>,\n     priv receives: Cell<uint>,\n     // can't share in an arc\n     priv marker: marker::NoFreeze,\n }\n \n-/// An iterator over messages received on a port, this iterator will block\n+/// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n /// returned when the corresponding channel has hung up.\n pub struct Messages<'a, T> {\n-    priv port: &'a Port<T>\n+    priv rx: &'a Receiver<T>\n }\n \n /// The sending-half of Rust's channel type. This half can only be owned by one\n /// task\n-pub struct Chan<T> {\n+pub struct Sender<T> {\n     priv inner: Flavor<T>,\n     priv sends: Cell<uint>,\n     // can't share in an arc\n@@ -331,30 +330,30 @@ enum Flavor<T> {\n     Shared(UnsafeArc<shared::Packet<T>>),\n }\n \n-impl<T: Send> Chan<T> {\n-    /// Creates a new port/channel pair. All data send on the channel returned\n-    /// will become available on the port as well. See the documentation of\n-    /// `Port` and `Chan` to see what's possible with them.\n-    pub fn new() -> (Port<T>, Chan<T>) {\n-        let (a, b) = UnsafeArc::new2(oneshot::Packet::new());\n-        (Port::my_new(Oneshot(a)), Chan::my_new(Oneshot(b)))\n-    }\n+/// Creates a new channel, returning the sender/receiver halves. All data sent\n+/// on the sender will become available on the receiver. See the documentation\n+/// of `Receiver` and `Sender` to see what's possible with them.\n+pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n+    let (a, b) = UnsafeArc::new2(oneshot::Packet::new());\n+    (Sender::my_new(Oneshot(b)), Receiver::my_new(Oneshot(a)))\n+}\n \n-    fn my_new(inner: Flavor<T>) -> Chan<T> {\n-        Chan { inner: inner, sends: Cell::new(0), marker: marker::NoFreeze }\n+impl<T: Send> Sender<T> {\n+    fn my_new(inner: Flavor<T>) -> Sender<T> {\n+        Sender { inner: inner, sends: Cell::new(0), marker: marker::NoFreeze }\n     }\n \n     /// Sends a value along this channel to be received by the corresponding\n-    /// port.\n+    /// receiver.\n     ///\n     /// Rust channels are infinitely buffered so this method will never block.\n     ///\n     /// # Failure\n     ///\n     /// This function will fail if the other end of the channel has hung up.\n-    /// This means that if the corresponding port has fallen out of scope, this\n-    /// function will trigger a fail message saying that a message is being sent\n-    /// on a closed channel.\n+    /// This means that if the corresponding receiver has fallen out of scope,\n+    /// this function will trigger a fail message saying that a message is\n+    /// being sent on a closed channel.\n     ///\n     /// Note that if this function does *not* fail, it does not mean that the\n     /// data will be successfully received. All sends are placed into a queue,\n@@ -372,13 +371,13 @@ impl<T: Send> Chan<T> {\n     /// Attempts to send a value on this channel, returning whether it was\n     /// successfully sent.\n     ///\n-    /// A successful send occurs when it is determined that the other end of the\n-    /// channel has not hung up already. An unsuccessful send would be one where\n-    /// the corresponding port has already been deallocated. Note that a return\n-    /// value of `false` means that the data will never be received, but a\n-    /// return value of `true` does *not* mean that the data will be received.\n-    /// It is possible for the corresponding port to hang up immediately after\n-    /// this function returns `true`.\n+    /// A successful send occurs when it is determined that the other end of\n+    /// the channel has not hung up already. An unsuccessful send would be one\n+    /// where the corresponding receiver has already been deallocated. Note\n+    /// that a return value of `false` means that the data will never be\n+    /// received, but a return value of `true` does *not* mean that the data\n+    /// will be received.  It is possible for the corresponding receiver to\n+    /// hang up immediately after this function returns `true`.\n     ///\n     /// Like `send`, this method will never block. If the failure of send cannot\n     /// be tolerated, then this method should be used instead.\n@@ -406,7 +405,7 @@ impl<T: Send> Chan<T> {\n                         return (*p).send(t);\n                     } else {\n                         let (a, b) = UnsafeArc::new2(stream::Packet::new());\n-                        match (*p).upgrade(Port::my_new(Stream(b))) {\n+                        match (*p).upgrade(Receiver::my_new(Stream(b))) {\n                             oneshot::UpSuccess => {\n                                 (*a.get()).send(t);\n                                 (a, true)\n@@ -426,48 +425,48 @@ impl<T: Send> Chan<T> {\n         };\n \n         unsafe {\n-            let mut tmp = Chan::my_new(Stream(new_inner));\n+            let mut tmp = Sender::my_new(Stream(new_inner));\n             mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n         return ret;\n     }\n }\n \n-impl<T: Send> Clone for Chan<T> {\n-    fn clone(&self) -> Chan<T> {\n+impl<T: Send> Clone for Sender<T> {\n+    fn clone(&self) -> Sender<T> {\n         let (packet, sleeper) = match self.inner {\n             Oneshot(ref p) => {\n                 let (a, b) = UnsafeArc::new2(shared::Packet::new());\n-                match unsafe { (*p.get()).upgrade(Port::my_new(Shared(a))) } {\n+                match unsafe { (*p.get()).upgrade(Receiver::my_new(Shared(a))) } {\n                     oneshot::UpSuccess | oneshot::UpDisconnected => (b, None),\n                     oneshot::UpWoke(task) => (b, Some(task))\n                 }\n             }\n             Stream(ref p) => {\n                 let (a, b) = UnsafeArc::new2(shared::Packet::new());\n-                match unsafe { (*p.get()).upgrade(Port::my_new(Shared(a))) } {\n+                match unsafe { (*p.get()).upgrade(Receiver::my_new(Shared(a))) } {\n                     stream::UpSuccess | stream::UpDisconnected => (b, None),\n                     stream::UpWoke(task) => (b, Some(task)),\n                 }\n             }\n             Shared(ref p) => {\n                 unsafe { (*p.get()).clone_chan(); }\n-                return Chan::my_new(Shared(p.clone()));\n+                return Sender::my_new(Shared(p.clone()));\n             }\n         };\n \n         unsafe {\n             (*packet.get()).inherit_blocker(sleeper);\n \n-            let mut tmp = Chan::my_new(Shared(packet.clone()));\n+            let mut tmp = Sender::my_new(Shared(packet.clone()));\n             mem::swap(&mut cast::transmute_mut(self).inner, &mut tmp.inner);\n         }\n-        Chan::my_new(Shared(packet))\n+        Sender::my_new(Shared(packet))\n     }\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Chan<T> {\n+impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match self.inner {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n@@ -477,16 +476,16 @@ impl<T: Send> Drop for Chan<T> {\n     }\n }\n \n-impl<T: Send> Port<T> {\n-    fn my_new(inner: Flavor<T>) -> Port<T> {\n-        Port { inner: inner, receives: Cell::new(0), marker: marker::NoFreeze }\n+impl<T: Send> Receiver<T> {\n+    fn my_new(inner: Flavor<T>) -> Receiver<T> {\n+        Receiver { inner: inner, receives: Cell::new(0), marker: marker::NoFreeze }\n     }\n \n-    /// Blocks waiting for a value on this port\n+    /// Blocks waiting for a value on this receiver\n     ///\n     /// This function will block if necessary to wait for a corresponding send\n-    /// on the channel from its paired `Chan` structure. This port will be woken\n-    /// up when data is ready, and the data will be returned.\n+    /// on the channel from its paired `Sender` structure. This receiver will\n+    /// be woken up when data is ready, and the data will be returned.\n     ///\n     /// # Failure\n     ///\n@@ -500,22 +499,22 @@ impl<T: Send> Port<T> {\n     ///   when the other end hangs up\n     ///\n     /// * If blocking is not desired, then the `try_recv` method will attempt to\n-    ///   peek at a value on this port.\n+    ///   peek at a value on this receiver.\n     pub fn recv(&self) -> T {\n         match self.recv_opt() {\n             Some(t) => t,\n             None => fail!(\"receiving on a closed channel\"),\n         }\n     }\n \n-    /// Attempts to return a pending value on this port without blocking\n+    /// Attempts to return a pending value on this receiver without blocking\n     ///\n     /// This method will never block the caller in order to wait for data to\n     /// become available. Instead, this will always return immediately with a\n     /// possible option of pending data on the channel.\n     ///\n     /// This is useful for a flavor of \"optimistic check\" before deciding to\n-    /// block on a port.\n+    /// block on a receiver.\n     ///\n     /// This function cannot fail.\n     pub fn try_recv(&self) -> TryRecvResult<T> {\n@@ -537,15 +536,15 @@ impl<T: Send> Port<T> {\n                         Ok(t) => return Data(t),\n                         Err(oneshot::Empty) => return Empty,\n                         Err(oneshot::Disconnected) => return Disconnected,\n-                        Err(oneshot::Upgraded(port)) => port,\n+                        Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Stream(ref p) => {\n                     match unsafe { (*p.get()).try_recv() } {\n                         Ok(t) => return Data(t),\n                         Err(stream::Empty) => return Empty,\n                         Err(stream::Disconnected) => return Disconnected,\n-                        Err(stream::Upgraded(port)) => port,\n+                        Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Shared(ref p) => {\n@@ -563,18 +562,18 @@ impl<T: Send> Port<T> {\n         }\n     }\n \n-    /// Attempt to wait for a value on this port, but does not fail if the\n+    /// Attempt to wait for a value on this receiver, but does not fail if the\n     /// corresponding channel has hung up.\n     ///\n     /// This implementation of iterators for ports will always block if there is\n-    /// not data available on the port, but it will not fail in the case that\n-    /// the channel has been deallocated.\n+    /// not data available on the receiver, but it will not fail in the case\n+    /// that the channel has been deallocated.\n     ///\n     /// In other words, this function has the same semantics as the `recv`\n     /// method except for the failure aspect.\n     ///\n     /// If the channel has hung up, then `None` is returned. Otherwise `Some` of\n-    /// the value found on the port is returned.\n+    /// the value found on the receiver is returned.\n     pub fn recv_opt(&self) -> Option<T> {\n         loop {\n             let mut new_port = match self.inner {\n@@ -583,15 +582,15 @@ impl<T: Send> Port<T> {\n                         Ok(t) => return Some(t),\n                         Err(oneshot::Empty) => return unreachable!(),\n                         Err(oneshot::Disconnected) => return None,\n-                        Err(oneshot::Upgraded(port)) => port,\n+                        Err(oneshot::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Stream(ref p) => {\n                     match unsafe { (*p.get()).recv() } {\n                         Ok(t) => return Some(t),\n                         Err(stream::Empty) => return unreachable!(),\n                         Err(stream::Disconnected) => return None,\n-                        Err(stream::Upgraded(port)) => port,\n+                        Err(stream::Upgraded(rx)) => rx,\n                     }\n                 }\n                 Shared(ref p) => {\n@@ -612,11 +611,11 @@ impl<T: Send> Port<T> {\n     /// Returns an iterator which will block waiting for messages, but never\n     /// `fail!`. It will return `None` when the channel has hung up.\n     pub fn iter<'a>(&'a self) -> Messages<'a, T> {\n-        Messages { port: self }\n+        Messages { rx: self }\n     }\n }\n \n-impl<T: Send> select::Packet for Port<T> {\n+impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let mut new_port = match self.inner {\n@@ -650,14 +649,14 @@ impl<T: Send> select::Packet for Port<T> {\n                     match unsafe { (*p.get()).start_selection(task) } {\n                         oneshot::SelSuccess => return Ok(()),\n                         oneshot::SelCanceled(task) => return Err(task),\n-                        oneshot::SelUpgraded(t, port) => (t, port),\n+                        oneshot::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Stream(ref p) => {\n                     match unsafe { (*p.get()).start_selection(task) } {\n                         stream::SelSuccess => return Ok(()),\n                         stream::SelCanceled(task) => return Err(task),\n-                        stream::SelUpgraded(t, port) => (t, port),\n+                        stream::SelUpgraded(t, rx) => (t, rx),\n                     }\n                 }\n                 Shared(ref p) => {\n@@ -695,11 +694,11 @@ impl<T: Send> select::Packet for Port<T> {\n }\n \n impl<'a, T: Send> Iterator<T> for Messages<'a, T> {\n-    fn next(&mut self) -> Option<T> { self.port.recv_opt() }\n+    fn next(&mut self) -> Option<T> { self.rx.recv_opt() }\n }\n \n #[unsafe_destructor]\n-impl<T: Send> Drop for Port<T> {\n+impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match self.inner {\n             Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },\n@@ -725,510 +724,511 @@ mod test {\n     }\n \n     test!(fn smoke() {\n-        let (p, c) = Chan::new();\n-        c.send(1);\n-        assert_eq!(p.recv(), 1);\n+        let (tx, rx) = channel();\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn drop_full() {\n-        let (_p, c) = Chan::new();\n-        c.send(~1);\n+        let (tx, _rx) = channel();\n+        tx.send(~1);\n     })\n \n     test!(fn drop_full_shared() {\n-        let (_p, c) = Chan::new();\n-        c.send(~1);\n+        let (tx, _rx) = channel();\n+        drop(tx.clone());\n+        drop(tx.clone());\n+        tx.send(~1);\n     })\n \n     test!(fn smoke_shared() {\n-        let (p, c) = Chan::new();\n-        c.send(1);\n-        assert_eq!(p.recv(), 1);\n-        let c = c.clone();\n-        c.send(1);\n-        assert_eq!(p.recv(), 1);\n+        let (tx, rx) = channel();\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n+        let tx = tx.clone();\n+        tx.send(1);\n+        assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn smoke_threads() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            c.send(1);\n+            tx.send(1);\n         });\n-        assert_eq!(p.recv(), 1);\n+        assert_eq!(rx.recv(), 1);\n     })\n \n     test!(fn smoke_port_gone() {\n-        let (p, c) = Chan::new();\n-        drop(p);\n-        c.send(1);\n+        let (tx, rx) = channel();\n+        drop(rx);\n+        tx.send(1);\n     } #[should_fail])\n \n     test!(fn smoke_shared_port_gone() {\n-        let (p, c) = Chan::new();\n-        drop(p);\n-        c.send(1);\n+        let (tx, rx) = channel();\n+        drop(rx);\n+        tx.send(1);\n     } #[should_fail])\n \n     test!(fn smoke_shared_port_gone2() {\n-        let (p, c) = Chan::new();\n-        drop(p);\n-        let c2 = c.clone();\n-        drop(c);\n-        c2.send(1);\n+        let (tx, rx) = channel();\n+        drop(rx);\n+        let tx2 = tx.clone();\n+        drop(tx);\n+        tx2.send(1);\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            p.recv();\n+            rx.recv();\n         });\n-        loop { c.send(1) }\n+        loop { tx.send(1) }\n     } #[should_fail])\n \n     test!(fn port_gone_concurrent_shared() {\n-        let (p, c) = Chan::new();\n-        let c1 = c.clone();\n+        let (tx, rx) = channel();\n+        let tx2 = tx.clone();\n         spawn(proc() {\n-            p.recv();\n+            rx.recv();\n         });\n         loop {\n-            c.send(1);\n-            c1.send(1);\n+            tx.send(1);\n+            tx2.send(1);\n         }\n     } #[should_fail])\n \n     test!(fn smoke_chan_gone() {\n-        let (p, c) = Chan::<int>::new();\n-        drop(c);\n-        p.recv();\n+        let (tx, rx) = channel::<int>();\n+        drop(tx);\n+        rx.recv();\n     } #[should_fail])\n \n     test!(fn smoke_chan_gone_shared() {\n-        let (p, c) = Chan::<()>::new();\n-        let c2 = c.clone();\n-        drop(c);\n-        drop(c2);\n-        p.recv();\n+        let (tx, rx) = channel::<()>();\n+        let tx2 = tx.clone();\n+        drop(tx);\n+        drop(tx2);\n+        rx.recv();\n     } #[should_fail])\n \n     test!(fn chan_gone_concurrent() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            c.send(1);\n-            c.send(1);\n+            tx.send(1);\n+            tx.send(1);\n         });\n-        loop { p.recv(); }\n+        loop { rx.recv(); }\n     } #[should_fail])\n \n     test!(fn stress() {\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n-            for _ in range(0, 10000) { c.send(1); }\n+            for _ in range(0, 10000) { tx.send(1); }\n         });\n         for _ in range(0, 10000) {\n-            assert_eq!(p.recv(), 1);\n+            assert_eq!(rx.recv(), 1);\n         }\n     })\n \n     test!(fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n-        let (p, c) = Chan::<int>::new();\n-        let (p1, c1) = Chan::new();\n+        let (tx, rx) = channel::<int>();\n+        let (dtx, drx) = channel::<()>();\n \n         spawn(proc() {\n             for _ in range(0, AMT * NTHREADS) {\n-                assert_eq!(p.recv(), 1);\n+                assert_eq!(rx.recv(), 1);\n             }\n-            match p.try_recv() {\n+            match rx.try_recv() {\n                 Data(..) => fail!(),\n                 _ => {}\n             }\n-            c1.send(());\n+            dtx.send(());\n         });\n \n         for _ in range(0, NTHREADS) {\n-            let c = c.clone();\n+            let tx = tx.clone();\n             spawn(proc() {\n-                for _ in range(0, AMT) { c.send(1); }\n+                for _ in range(0, AMT) { tx.send(1); }\n             });\n         }\n-        p1.recv();\n+        drop(tx);\n+        drx.recv();\n     })\n \n     #[test]\n     fn send_from_outside_runtime() {\n-        let (p, c) = Chan::<int>::new();\n-        let (p1, c1) = Chan::new();\n-        let (port, chan) = Chan::new();\n-        let chan2 = chan.clone();\n+        let (tx1, rx1) = channel::<()>();\n+        let (tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n+        let tx4 = tx3.clone();\n         spawn(proc() {\n-            c1.send(());\n+            tx1.send(());\n             for _ in range(0, 40) {\n-                assert_eq!(p.recv(), 1);\n+                assert_eq!(rx2.recv(), 1);\n             }\n-            chan2.send(());\n+            tx3.send(());\n         });\n-        p1.recv();\n+        rx1.recv();\n         native::task::spawn(proc() {\n             for _ in range(0, 40) {\n-                c.send(1);\n+                tx2.send(1);\n             }\n-            chan.send(());\n+            tx4.send(());\n         });\n-        port.recv();\n-        port.recv();\n+        rx3.recv();\n+        rx3.recv();\n     }\n \n     #[test]\n     fn recv_from_outside_runtime() {\n-        let (p, c) = Chan::<int>::new();\n-        let (dp, dc) = Chan::new();\n+        let (tx, rx) = channel::<int>();\n+        let (dtx, drx) = channel();\n         native::task::spawn(proc() {\n             for _ in range(0, 40) {\n-                assert_eq!(p.recv(), 1);\n+                assert_eq!(rx.recv(), 1);\n             }\n-            dc.send(());\n+            dtx.send(());\n         });\n         for _ in range(0, 40) {\n-            c.send(1);\n+            tx.send(1);\n         }\n-        dp.recv();\n+        drx.recv();\n     }\n \n     #[test]\n     fn no_runtime() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, c2) = Chan::<int>::new();\n-        let (port, chan) = Chan::new();\n-        let chan2 = chan.clone();\n+        let (tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n+        let tx4 = tx3.clone();\n         native::task::spawn(proc() {\n-            assert_eq!(p1.recv(), 1);\n-            c2.send(2);\n-            chan2.send(());\n+            assert_eq!(rx1.recv(), 1);\n+            tx2.send(2);\n+            tx4.send(());\n         });\n         native::task::spawn(proc() {\n-            c1.send(1);\n-            assert_eq!(p2.recv(), 2);\n-            chan.send(());\n+            tx1.send(1);\n+            assert_eq!(rx2.recv(), 2);\n+            tx3.send(());\n         });\n-        port.recv();\n-        port.recv();\n+        rx3.recv();\n+        rx3.recv();\n     }\n \n     test!(fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        let (port, _chan) = Chan::<int>::new();\n-        { let _p = port; }\n+        let (_tx, rx) = channel::<int>();\n+        drop(rx);\n     })\n \n     test!(fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        let (_port, chan) = Chan::<int>::new();\n-        { let _c = chan; }\n+        let (tx, _rx) = channel::<int>();\n+        drop(tx);\n     })\n \n     test!(fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n-        let (port, chan) = Chan::<~int>::new();\n-        { let _p = port; }\n-        chan.send(~0);\n+        let (tx, rx) = channel::<~int>();\n+        drop(rx);\n+        tx.send(~0);\n     } #[should_fail])\n \n     test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will fail\n         let res = task::try(proc() {\n-            let (port, chan) = Chan::<~int>::new();\n-            { let _c = chan; }\n-            port.recv();\n+            let (tx, rx) = channel::<int>();\n+            drop(tx);\n+            rx.recv();\n         });\n         // What is our res?\n         assert!(res.is_err());\n     })\n \n     test!(fn oneshot_single_thread_send_then_recv() {\n-        let (port, chan) = Chan::<~int>::new();\n-        chan.send(~10);\n-        assert!(port.recv() == ~10);\n+        let (tx, rx) = channel::<~int>();\n+        tx.send(~10);\n+        assert!(rx.recv() == ~10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_open() {\n-        let (port, chan) = Chan::<int>::new();\n-        assert!(chan.try_send(10));\n-        assert!(port.recv() == 10);\n+        let (tx, rx) = channel::<int>();\n+        assert!(tx.try_send(10));\n+        assert!(rx.recv() == 10);\n     })\n \n     test!(fn oneshot_single_thread_try_send_closed() {\n-        let (port, chan) = Chan::<int>::new();\n-        { let _p = port; }\n-        assert!(!chan.try_send(10));\n+        let (tx, rx) = channel::<int>();\n+        drop(rx);\n+        assert!(!tx.try_send(10));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_open() {\n-        let (port, chan) = Chan::<int>::new();\n-        chan.send(10);\n-        assert!(port.recv_opt() == Some(10));\n+        let (tx, rx) = channel::<int>();\n+        tx.send(10);\n+        assert!(rx.recv_opt() == Some(10));\n     })\n \n     test!(fn oneshot_single_thread_try_recv_closed() {\n-        let (port, chan) = Chan::<int>::new();\n-        { let _c = chan; }\n-        assert!(port.recv_opt() == None);\n+        let (tx, rx) = channel::<int>();\n+        drop(tx);\n+        assert!(rx.recv_opt() == None);\n     })\n \n     test!(fn oneshot_single_thread_peek_data() {\n-        let (port, chan) = Chan::<int>::new();\n-        assert_eq!(port.try_recv(), Empty)\n-        chan.send(10);\n-        assert_eq!(port.try_recv(), Data(10));\n+        let (tx, rx) = channel::<int>();\n+        assert_eq!(rx.try_recv(), Empty)\n+        tx.send(10);\n+        assert_eq!(rx.try_recv(), Data(10));\n     })\n \n     test!(fn oneshot_single_thread_peek_close() {\n-        let (port, chan) = Chan::<int>::new();\n-        { let _c = chan; }\n-        assert_eq!(port.try_recv(), Disconnected);\n-        assert_eq!(port.try_recv(), Disconnected);\n+        let (tx, rx) = channel::<int>();\n+        drop(tx);\n+        assert_eq!(rx.try_recv(), Disconnected);\n+        assert_eq!(rx.try_recv(), Disconnected);\n     })\n \n     test!(fn oneshot_single_thread_peek_open() {\n-        let (port, _chan) = Chan::<int>::new();\n-        assert_eq!(port.try_recv(), Empty);\n+        let (_tx, rx) = channel::<int>();\n+        assert_eq!(rx.try_recv(), Empty);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_send() {\n-        let (port, chan) = Chan::<~int>::new();\n+        let (tx, rx) = channel::<~int>();\n         spawn(proc() {\n-            assert!(port.recv() == ~10);\n+            assert!(rx.recv() == ~10);\n         });\n \n-        chan.send(~10);\n+        tx.send(~10);\n     })\n \n     test!(fn oneshot_multi_task_recv_then_close() {\n-        let (port, chan) = Chan::<~int>::new();\n+        let (tx, rx) = channel::<~int>();\n         spawn(proc() {\n-            let _chan = chan;\n+            drop(tx);\n         });\n         let res = task::try(proc() {\n-            assert!(port.recv() == ~10);\n+            assert!(rx.recv() == ~10);\n         });\n         assert!(res.is_err());\n     })\n \n     test!(fn oneshot_multi_thread_close_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (port, chan) = Chan::<int>::new();\n+            let (tx, rx) = channel::<int>();\n             spawn(proc() {\n-                let _p = port;\n+                drop(rx);\n             });\n-            let _chan = chan;\n+            drop(tx);\n         }\n     })\n \n     test!(fn oneshot_multi_thread_send_close_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (port, chan) = Chan::<int>::new();\n+            let (tx, rx) = channel::<int>();\n             spawn(proc() {\n-                let _p = port;\n+                drop(rx);\n             });\n             let _ = task::try(proc() {\n-                chan.send(1);\n+                tx.send(1);\n             });\n         }\n     })\n \n     test!(fn oneshot_multi_thread_recv_close_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (port, chan) = Chan::<int>::new();\n+            let (tx, rx) = channel::<int>();\n             spawn(proc() {\n-                let port = port;\n                 let res = task::try(proc() {\n-                    port.recv();\n+                    rx.recv();\n                 });\n                 assert!(res.is_err());\n             });\n             spawn(proc() {\n-                let chan = chan;\n                 spawn(proc() {\n-                    let _chan = chan;\n+                    drop(tx);\n                 });\n             });\n         }\n     })\n \n     test!(fn oneshot_multi_thread_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (port, chan) = Chan::<~int>::new();\n+            let (tx, rx) = channel();\n             spawn(proc() {\n-                chan.send(~10);\n+                tx.send(~10);\n             });\n             spawn(proc() {\n-                assert!(port.recv() == ~10);\n+                assert!(rx.recv() == ~10);\n             });\n         }\n     })\n \n     test!(fn stream_send_recv_stress() {\n         for _ in range(0, stress_factor()) {\n-            let (port, chan) = Chan::<~int>::new();\n+            let (tx, rx) = channel();\n \n-            send(chan, 0);\n-            recv(port, 0);\n+            send(tx, 0);\n+            recv(rx, 0);\n \n-            fn send(chan: Chan<~int>, i: int) {\n+            fn send(tx: Sender<~int>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    chan.send(~i);\n-                    send(chan, i + 1);\n+                    tx.send(~i);\n+                    send(tx, i + 1);\n                 });\n             }\n \n-            fn recv(port: Port<~int>, i: int) {\n+            fn recv(rx: Receiver<~int>, i: int) {\n                 if i == 10 { return }\n \n                 spawn(proc() {\n-                    assert!(port.recv() == ~i);\n-                    recv(port, i + 1);\n+                    assert!(rx.recv() == ~i);\n+                    recv(rx, i + 1);\n                 });\n             }\n         }\n     })\n \n     test!(fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n-        let (port, chan) = Chan::new();\n-        for _ in range(0, 10000) { chan.send(()); }\n-        for _ in range(0, 10000) { port.recv(); }\n+        let (tx, rx) = channel();\n+        for _ in range(0, 10000) { tx.send(()); }\n+        for _ in range(0, 10000) { rx.recv(); }\n     })\n \n     test!(fn shared_chan_stress() {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let total = stress_factor() + 100;\n         for _ in range(0, total) {\n-            let chan_clone = chan.clone();\n+            let tx = tx.clone();\n             spawn(proc() {\n-                chan_clone.send(());\n+                tx.send(());\n             });\n         }\n \n         for _ in range(0, total) {\n-            port.recv();\n+            rx.recv();\n         }\n     })\n \n     test!(fn test_nested_recv_iter() {\n-        let (port, chan) = Chan::<int>::new();\n-        let (total_port, total_chan) = Chan::<int>::new();\n+        let (tx, rx) = channel::<int>();\n+        let (total_tx, total_rx) = channel::<int>();\n \n         spawn(proc() {\n             let mut acc = 0;\n-            for x in port.iter() {\n+            for x in rx.iter() {\n                 acc += x;\n             }\n-            total_chan.send(acc);\n+            total_tx.send(acc);\n         });\n \n-        chan.send(3);\n-        chan.send(1);\n-        chan.send(2);\n-        drop(chan);\n-        assert_eq!(total_port.recv(), 6);\n+        tx.send(3);\n+        tx.send(1);\n+        tx.send(2);\n+        drop(tx);\n+        assert_eq!(total_rx.recv(), 6);\n     })\n \n     test!(fn test_recv_iter_break() {\n-        let (port, chan) = Chan::<int>::new();\n-        let (count_port, count_chan) = Chan::<int>::new();\n+        let (tx, rx) = channel::<int>();\n+        let (count_tx, count_rx) = channel();\n \n         spawn(proc() {\n             let mut count = 0;\n-            for x in port.iter() {\n+            for x in rx.iter() {\n                 if count >= 3 {\n                     break;\n                 } else {\n                     count += x;\n                 }\n             }\n-            count_chan.send(count);\n+            count_tx.send(count);\n         });\n \n-        chan.send(2);\n-        chan.send(2);\n-        chan.send(2);\n-        chan.try_send(2);\n-        drop(chan);\n-        assert_eq!(count_port.recv(), 4);\n+        tx.send(2);\n+        tx.send(2);\n+        tx.send(2);\n+        tx.try_send(2);\n+        drop(tx);\n+        assert_eq!(count_rx.recv(), 4);\n     })\n \n     test!(fn try_recv_states() {\n-        let (p, c) = Chan::<int>::new();\n-        let (p1, c1) = Chan::<()>::new();\n-        let (p2, c2) = Chan::<()>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<()>();\n+        let (tx3, rx3) = channel::<()>();\n         spawn(proc() {\n-            p1.recv();\n-            c.send(1);\n-            c2.send(());\n-            p1.recv();\n-            drop(c);\n-            c2.send(());\n+            rx2.recv();\n+            tx1.send(1);\n+            tx3.send(());\n+            rx2.recv();\n+            drop(tx1);\n+            tx3.send(());\n         });\n \n-        assert_eq!(p.try_recv(), Empty);\n-        c1.send(());\n-        p2.recv();\n-        assert_eq!(p.try_recv(), Data(1));\n-        assert_eq!(p.try_recv(), Empty);\n-        c1.send(());\n-        p2.recv();\n-        assert_eq!(p.try_recv(), Disconnected);\n+        assert_eq!(rx1.try_recv(), Empty);\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Data(1));\n+        assert_eq!(rx1.try_recv(), Empty);\n+        tx2.send(());\n+        rx3.recv();\n+        assert_eq!(rx1.try_recv(), Disconnected);\n     })\n \n-    // This bug used to end up in a livelock inside of the Port destructor\n-    // because the internal state of the Shared port was corrupted\n+    // This bug used to end up in a livelock inside of the Receiver destructor\n+    // because the internal state of the Shared packet was corrupted\n     test!(fn destroy_upgraded_shared_port_when_sender_still_active() {\n-        let (p, c) = Chan::new();\n-        let (p1, c2) = Chan::new();\n+        let (tx, rx) = channel();\n+        let (tx2, rx2) = channel();\n         spawn(proc() {\n-            p.recv(); // wait on a oneshot port\n-            drop(p);  // destroy a shared port\n-            c2.send(());\n+            rx.recv(); // wait on a oneshot\n+            drop(rx);  // destroy a shared\n+            tx2.send(());\n         });\n         // make sure the other task has gone to sleep\n         for _ in range(0, 5000) { task::deschedule(); }\n \n         // upgrade to a shared chan and send a message\n-        let t = c.clone();\n-        drop(c);\n+        let t = tx.clone();\n+        drop(tx);\n         t.send(());\n \n         // wait for the child task to exit before we exit\n-        p1.recv();\n+        rx2.recv();\n     })\n \n     test!(fn sends_off_the_runtime() {\n         use rt::thread::Thread;\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         let t = Thread::start(proc() {\n             for _ in range(0, 1000) {\n-                c.send(());\n+                tx.send(());\n             }\n         });\n         for _ in range(0, 1000) {\n-            p.recv();\n+            rx.recv();\n         }\n         t.join();\n     })\n \n     test!(fn try_recvs_off_the_runtime() {\n         use rt::thread::Thread;\n \n-        let (p, c) = Chan::new();\n-        let (pdone, cdone) = Chan::new();\n+        let (tx, rx) = channel();\n+        let (cdone, pdone) = channel();\n         let t = Thread::start(proc() {\n             let mut hits = 0;\n             while hits < 10 {\n-                match p.try_recv() {\n+                match rx.try_recv() {\n                     Data(()) => { hits += 1; }\n                     Empty => { Thread::yield_now(); }\n                     Disconnected => return,\n@@ -1237,7 +1237,7 @@ mod test {\n             cdone.send(());\n         });\n         for _ in range(0, 10) {\n-            c.send(());\n+            tx.send(());\n         }\n         t.join();\n         pdone.recv();"}, {"sha": "1bc7349a70d0bebe71714a24c3b8b2c93db96e82", "filename": "src/libstd/comm/oneshot.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Foneshot.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -32,7 +32,7 @@\n /// The one caveat to consider is that when a port sees a disconnected channel\n /// it must check for data because there is no \"data plus upgrade\" state.\n \n-use comm::Port;\n+use comm::Receiver;\n use kinds::Send;\n use mem;\n use ops::Drop;\n@@ -60,7 +60,7 @@ pub struct Packet<T> {\n pub enum Failure<T> {\n     Empty,\n     Disconnected,\n-    Upgraded(Port<T>),\n+    Upgraded(Receiver<T>),\n }\n \n pub enum UpgradeResult {\n@@ -71,14 +71,14 @@ pub enum UpgradeResult {\n \n pub enum SelectionResult<T> {\n     SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Port<T>),\n+    SelUpgraded(BlockedTask, Receiver<T>),\n     SelSuccess,\n }\n \n enum MyUpgrade<T> {\n     NothingSent,\n     SendUsed,\n-    GoUp(Port<T>),\n+    GoUp(Receiver<T>),\n }\n \n impl<T: Send> Packet<T> {\n@@ -201,7 +201,7 @@ impl<T: Send> Packet<T> {\n     // Returns whether the upgrade was completed. If the upgrade wasn't\n     // completed, then the port couldn't get sent to the other half (it will\n     // never receive it).\n-    pub fn upgrade(&mut self, up: Port<T>) -> UpgradeResult {\n+    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n         let prev = match self.upgrade {\n             NothingSent => NothingSent,\n             SendUsed => SendUsed,\n@@ -259,7 +259,7 @@ impl<T: Send> Packet<T> {\n \n     // If Ok, the value is whether this port has data, if Err, then the upgraded\n     // port needs to be checked instead of this one.\n-    pub fn can_recv(&mut self) -> Result<bool, Port<T>> {\n+    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n         match self.state.load(atomics::SeqCst) {\n             EMPTY => Ok(false), // Welp, we tried\n             DATA => Ok(true),   // we have some un-acquired data\n@@ -318,7 +318,7 @@ impl<T: Send> Packet<T> {\n     // blocked task will no longer be visible to any other threads.\n     //\n     // The return value indicates whether there's data on this port.\n-    pub fn abort_selection(&mut self) -> Result<bool, Port<T>> {\n+    pub fn abort_selection(&mut self) -> Result<bool, Receiver<T>> {\n         let state = match self.state.load(atomics::SeqCst) {\n             // Each of these states means that no further activity will happen\n             // with regard to abortion selection"}, {"sha": "3e134b92493b252786e565816619075fa8558360", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 215, "deletions": 214, "changes": 429, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -8,38 +8,39 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Selection over an array of ports\n+//! Selection over an array of receivers\n //!\n //! This module contains the implementation machinery necessary for selecting\n-//! over a number of ports. One large goal of this module is to provide an\n-//! efficient interface to selecting over any port of any type.\n+//! over a number of receivers. One large goal of this module is to provide an\n+//! efficient interface to selecting over any receiver of any type.\n //!\n-//! This is achieved through an architecture of a \"port set\" in which ports are\n-//! added to a set and then the entire set is waited on at once. The set can be\n-//! waited on multiple times to prevent re-adding each port to the set.\n+//! This is achieved through an architecture of a \"receiver set\" in which\n+//! receivers are added to a set and then the entire set is waited on at once.\n+//! The set can be waited on multiple times to prevent re-adding each receiver\n+//! to the set.\n //!\n //! Usage of this module is currently encouraged to go through the use of the\n //! `select!` macro. This macro allows naturally binding of variables to the\n-//! received values of ports in a much more natural syntax then usage of the\n+//! received values of receivers in a much more natural syntax then usage of the\n //! `Select` structure directly.\n //!\n //! # Example\n //!\n-//! ```rust,ignore\n-//! let (mut p1, c1) = Chan::new();\n-//! let (mut p2, c2) = Chan::new();\n+//! ```rust\n+//! let (tx1, rx1) = channel();\n+//! let (tx2, rx2) = channel();\n //!\n-//! c1.send(1);\n-//! c2.send(2);\n+//! tx1.send(1);\n+//! tx2.send(2);\n //!\n-//! select! (\n-//!     val = p1.recv() => {\n+//! select! {\n+//!     val = rx1.recv() => {\n //!         assert_eq!(val, 1);\n-//!     }\n-//!     val = p2.recv() => {\n+//!     },\n+//!     val = rx2.recv() => {\n //!         assert_eq!(val, 2);\n //!     }\n-//! )\n+//! }\n //! ```\n \n #[allow(dead_code)];\n@@ -55,11 +56,11 @@ use ptr::RawPtr;\n use result::{Ok, Err, Result};\n use rt::local::Local;\n use rt::task::{Task, BlockedTask};\n-use super::Port;\n+use super::Receiver;\n use uint;\n \n-/// The \"port set\" of the select interface. This structure is used to manage a\n-/// set of ports which are being selected over.\n+/// The \"receiver set\" of the select interface. This structure is used to manage\n+/// a set of receivers which are being selected over.\n pub struct Select {\n     priv head: *mut Handle<'static, ()>,\n     priv tail: *mut Handle<'static, ()>,\n@@ -68,22 +69,22 @@ pub struct Select {\n     priv marker2: marker::NoFreeze,\n }\n \n-/// A handle to a port which is currently a member of a `Select` set of ports.\n-/// This handle is used to keep the port in the set as well as interact with the\n-/// underlying port.\n-pub struct Handle<'port, T> {\n+/// A handle to a receiver which is currently a member of a `Select` set of\n+/// receivers.  This handle is used to keep the receiver in the set as well as\n+/// interact with the underlying receiver.\n+pub struct Handle<'rx, T> {\n     /// The ID of this handle, used to compare against the return value of\n     /// `Select::wait()`\n     priv id: uint,\n-    priv selector: &'port Select,\n+    priv selector: &'rx Select,\n     priv next: *mut Handle<'static, ()>,\n     priv prev: *mut Handle<'static, ()>,\n     priv added: bool,\n-    priv packet: &'port Packet,\n+    priv packet: &'rx Packet,\n \n     // due to our fun transmutes, we be sure to place this at the end. (nothing\n     // previous relies on T)\n-    priv port: &'port Port<T>,\n+    priv rx: &'rx Receiver<T>,\n }\n \n struct Packets { cur: *mut Handle<'static, ()> }\n@@ -111,10 +112,10 @@ impl Select {\n         }\n     }\n \n-    /// Creates a new handle into this port set for a new port. Note that this\n-    /// does *not* add the port to the port set, for that you must call the\n-    /// `add` method on the handle itself.\n-    pub fn handle<'a, T: Send>(&'a self, port: &'a Port<T>) -> Handle<'a, T> {\n+    /// Creates a new handle into this receiver set for a new receiver. Note\n+    /// that this does *not* add the receiver to the receiver set, for that you\n+    /// must call the `add` method on the handle itself.\n+    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n         let id = self.next_id.get();\n         self.next_id.set(id + 1);\n         Handle {\n@@ -123,12 +124,12 @@ impl Select {\n             next: 0 as *mut Handle<'static, ()>,\n             prev: 0 as *mut Handle<'static, ()>,\n             added: false,\n-            port: port,\n-            packet: port,\n+            rx: rx,\n+            packet: rx,\n         }\n     }\n \n-    /// Waits for an event on this port set. The returned value is *not* an\n+    /// Waits for an event on this receiver set. The returned value is *not* an\n     /// index, but rather an id. This id can be queried against any active\n     /// `Handle` structures (each one has an `id` method). The handle with\n     /// the matching `id` will have some sort of event available on it. The\n@@ -141,24 +142,24 @@ impl Select {\n     /// Helper method for skipping the preflight checks during testing\n     fn wait2(&self, do_preflight_checks: bool) -> uint {\n         // Note that this is currently an inefficient implementation. We in\n-        // theory have knowledge about all ports in the set ahead of time, so\n-        // this method shouldn't really have to iterate over all of them yet\n-        // again. The idea with this \"port set\" interface is to get the\n+        // theory have knowledge about all receivers in the set ahead of time,\n+        // so this method shouldn't really have to iterate over all of them yet\n+        // again. The idea with this \"receiver set\" interface is to get the\n         // interface right this time around, and later this implementation can\n         // be optimized.\n         //\n         // This implementation can be summarized by:\n         //\n-        //      fn select(ports) {\n-        //          if any port ready { return ready index }\n+        //      fn select(receivers) {\n+        //          if any receiver ready { return ready index }\n         //          deschedule {\n-        //              block on all ports\n+        //              block on all receivers\n         //          }\n-        //          unblock on all ports\n+        //          unblock on all receivers\n         //          return ready index\n         //      }\n         //\n-        // Most notably, the iterations over all of the ports shouldn't be\n+        // Most notably, the iterations over all of the receivers shouldn't be\n         // necessary.\n         unsafe {\n             let mut amt = 0;\n@@ -176,7 +177,7 @@ impl Select {\n \n             // Acquire a number of blocking contexts, and block on each one\n             // sequentially until one fails. If one fails, then abort\n-            // immediately so we can go unblock on all the other ports.\n+            // immediately so we can go unblock on all the other receivers.\n             let task: ~Task = Local::take();\n             task.deschedule(amt, |task| {\n                 // Prepare for the block\n@@ -191,18 +192,18 @@ impl Select {\n                 }\n             });\n \n-            // Abort the selection process on each port. If the abort process\n-            // returns `true`, then that means that the port is ready to receive\n-            // some data. Note that this also means that the port may have yet\n-            // to have fully read the `to_wake` field and woken us up (although\n-            // the wakeup is guaranteed to fail).\n+            // Abort the selection process on each receiver. If the abort\n+            // process returns `true`, then that means that the receiver is\n+            // ready to receive some data. Note that this also means that the\n+            // receiver may have yet to have fully read the `to_wake` field and\n+            // woken us up (although the wakeup is guaranteed to fail).\n             //\n             // This situation happens in the window of where a sender invokes\n             // increment(), sees -1, and then decides to wake up the task. After\n             // all this is done, the sending thread will set `selecting` to\n             // `false`. Until this is done, we cannot return. If we were to\n-            // return, then a sender could wake up a port which has gone back to\n-            // sleep after this call to `select`.\n+            // return, then a sender could wake up a receiver which has gone\n+            // back to sleep after this call to `select`.\n             //\n             // Note that it is a \"fairly small window\" in which an increment()\n             // views that it should wake a thread up until the `selecting` bit\n@@ -226,20 +227,20 @@ impl Select {\n     fn iter(&self) -> Packets { Packets { cur: self.head } }\n }\n \n-impl<'port, T: Send> Handle<'port, T> {\n+impl<'rx, T: Send> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n     pub fn id(&self) -> uint { self.id }\n \n-    /// Receive a value on the underlying port. Has the same semantics as\n-    /// `Port.recv`\n-    pub fn recv(&mut self) -> T { self.port.recv() }\n-    /// Block to receive a value on the underlying port, returning `Some` on\n+    /// Receive a value on the underlying receiver. Has the same semantics as\n+    /// `Receiver.recv`\n+    pub fn recv(&mut self) -> T { self.rx.recv() }\n+    /// Block to receive a value on the underlying receiver, returning `Some` on\n     /// success or `None` if the channel disconnects. This function has the same\n-    /// semantics as `Port.recv_opt`\n-    pub fn recv_opt(&mut self) -> Option<T> { self.port.recv_opt() }\n+    /// semantics as `Receiver.recv_opt`\n+    pub fn recv_opt(&mut self) -> Option<T> { self.rx.recv_opt() }\n \n-    /// Adds this handle to the port set that the handle was created from. This\n+    /// Adds this handle to the receiver set that the handle was created from. This\n     /// method can be called multiple times, but it has no effect if `add` was\n     /// called previously.\n     ///\n@@ -300,7 +301,7 @@ impl Drop for Select {\n }\n \n #[unsafe_destructor]\n-impl<'port, T: Send> Drop for Handle<'port, T> {\n+impl<'rx, T: Send> Drop for Handle<'rx, T> {\n     fn drop(&mut self) {\n         unsafe { self.remove() }\n     }\n@@ -325,328 +326,328 @@ mod test {\n     use prelude::*;\n \n     test!(fn smoke() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, c2) = Chan::<int>::new();\n-        c1.send(1);\n+        let (tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<int>();\n+        tx1.send(1);\n         select! (\n-            foo = p1.recv() => { assert_eq!(foo, 1); },\n-            _bar = p2.recv() => { fail!() }\n+            foo = rx1.recv() => { assert_eq!(foo, 1); },\n+            _bar = rx2.recv() => { fail!() }\n         )\n-        c2.send(2);\n+        tx2.send(2);\n         select! (\n-            _foo = p1.recv() => { fail!() },\n-            bar = p2.recv() => { assert_eq!(bar, 2) }\n+            _foo = rx1.recv() => { fail!() },\n+            bar = rx2.recv() => { assert_eq!(bar, 2) }\n         )\n-        drop(c1);\n+        drop(tx1);\n         select! (\n-            foo = p1.recv_opt() => { assert_eq!(foo, None); },\n-            _bar = p2.recv() => { fail!() }\n+            foo = rx1.recv_opt() => { assert_eq!(foo, None); },\n+            _bar = rx2.recv() => { fail!() }\n         )\n-        drop(c2);\n+        drop(tx2);\n         select! (\n-            bar = p2.recv_opt() => { assert_eq!(bar, None); }\n+            bar = rx2.recv_opt() => { assert_eq!(bar, None); }\n         )\n     })\n \n     test!(fn smoke2() {\n-        let (p1, _c1) = Chan::<int>::new();\n-        let (p2, _c2) = Chan::<int>::new();\n-        let (p3, _c3) = Chan::<int>::new();\n-        let (p4, _c4) = Chan::<int>::new();\n-        let (p5, c5) = Chan::<int>::new();\n-        c5.send(4);\n+        let (_tx1, rx1) = channel::<int>();\n+        let (_tx2, rx2) = channel::<int>();\n+        let (_tx3, rx3) = channel::<int>();\n+        let (_tx4, rx4) = channel::<int>();\n+        let (tx5, rx5) = channel::<int>();\n+        tx5.send(4);\n         select! (\n-            _foo = p1.recv() => { fail!(\"1\") },\n-            _foo = p2.recv() => { fail!(\"2\") },\n-            _foo = p3.recv() => { fail!(\"3\") },\n-            _foo = p4.recv() => { fail!(\"4\") },\n-            foo = p5.recv() => { assert_eq!(foo, 4); }\n+            _foo = rx1.recv() => { fail!(\"1\") },\n+            _foo = rx2.recv() => { fail!(\"2\") },\n+            _foo = rx3.recv() => { fail!(\"3\") },\n+            _foo = rx4.recv() => { fail!(\"4\") },\n+            foo = rx5.recv() => { assert_eq!(foo, 4); }\n         )\n     })\n \n     test!(fn closed() {\n-        let (p1, _c1) = Chan::<int>::new();\n-        let (p2, c2) = Chan::<int>::new();\n-        drop(c2);\n+        let (_tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<int>();\n+        drop(tx2);\n \n         select! (\n-            _a1 = p1.recv_opt() => { fail!() },\n-            a2 = p2.recv_opt() => { assert_eq!(a2, None); }\n+            _a1 = rx1.recv_opt() => { fail!() },\n+            a2 = rx2.recv_opt() => { assert_eq!(a2, None); }\n         )\n     })\n \n     test!(fn unblocks() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, _c2) = Chan::<int>::new();\n-        let (p3, c3) = Chan::<int>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (_tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<int>();\n \n         spawn(proc() {\n             for _ in range(0, 20) { task::deschedule(); }\n-            c1.send(1);\n-            p3.recv();\n+            tx1.send(1);\n+            rx3.recv();\n             for _ in range(0, 20) { task::deschedule(); }\n         });\n \n         select! (\n-            a = p1.recv() => { assert_eq!(a, 1); },\n-            _b = p2.recv() => { fail!() }\n+            a = rx1.recv() => { assert_eq!(a, 1); },\n+            _b = rx2.recv() => { fail!() }\n         )\n-        c3.send(1);\n+        tx3.send(1);\n         select! (\n-            a = p1.recv_opt() => { assert_eq!(a, None); },\n-            _b = p2.recv() => { fail!() }\n+            a = rx1.recv_opt() => { assert_eq!(a, None); },\n+            _b = rx2.recv() => { fail!() }\n         )\n     })\n \n     test!(fn both_ready() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, c2) = Chan::<int>::new();\n-        let (p3, c3) = Chan::<()>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n \n         spawn(proc() {\n             for _ in range(0, 20) { task::deschedule(); }\n-            c1.send(1);\n-            c2.send(2);\n-            p3.recv();\n+            tx1.send(1);\n+            tx2.send(2);\n+            rx3.recv();\n         });\n \n         select! (\n-            a = p1.recv() => { assert_eq!(a, 1); },\n-            a = p2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a, 1); },\n+            a = rx2.recv() => { assert_eq!(a, 2); }\n         )\n         select! (\n-            a = p1.recv() => { assert_eq!(a, 1); },\n-            a = p2.recv() => { assert_eq!(a, 2); }\n+            a = rx1.recv() => { assert_eq!(a, 1); },\n+            a = rx2.recv() => { assert_eq!(a, 2); }\n         )\n-        assert_eq!(p1.try_recv(), Empty);\n-        assert_eq!(p2.try_recv(), Empty);\n-        c3.send(());\n+        assert_eq!(rx1.try_recv(), Empty);\n+        assert_eq!(rx2.try_recv(), Empty);\n+        tx3.send(());\n     })\n \n     test!(fn stress() {\n         static AMT: int = 10000;\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, c2) = Chan::<int>::new();\n-        let (p3, c3) = Chan::<()>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n \n         spawn(proc() {\n             for i in range(0, AMT) {\n                 if i % 2 == 0 {\n-                    c1.send(i);\n+                    tx1.send(i);\n                 } else {\n-                    c2.send(i);\n+                    tx2.send(i);\n                 }\n-                p3.recv();\n+                rx3.recv();\n             }\n         });\n \n         for i in range(0, AMT) {\n             select! (\n-                i1 = p1.recv() => { assert!(i % 2 == 0 && i == i1); },\n-                i2 = p2.recv() => { assert!(i % 2 == 1 && i == i2); }\n+                i1 = rx1.recv() => { assert!(i % 2 == 0 && i == i1); },\n+                i2 = rx2.recv() => { assert!(i % 2 == 1 && i == i2); }\n             )\n-            c3.send(());\n+            tx3.send(());\n         }\n     })\n \n     test!(fn cloning() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, _c2) = Chan::<int>::new();\n-        let (p3, c3) = Chan::<()>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (_tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n \n         spawn(proc() {\n-            p3.recv();\n-            c1.clone();\n-            assert_eq!(p3.try_recv(), Empty);\n-            c1.send(2);\n-            p3.recv();\n+            rx3.recv();\n+            tx1.clone();\n+            assert_eq!(rx3.try_recv(), Empty);\n+            tx1.send(2);\n+            rx3.recv();\n         });\n \n-        c3.send(());\n+        tx3.send(());\n         select!(\n-            _i1 = p1.recv() => {},\n-            _i2 = p2.recv() => fail!()\n+            _i1 = rx1.recv() => {},\n+            _i2 = rx2.recv() => fail!()\n         )\n-        c3.send(());\n+        tx3.send(());\n     })\n \n     test!(fn cloning2() {\n-        let (p1, c1) = Chan::<int>::new();\n-        let (p2, _c2) = Chan::<int>::new();\n-        let (p3, c3) = Chan::<()>::new();\n+        let (tx1, rx1) = channel::<int>();\n+        let (_tx2, rx2) = channel::<int>();\n+        let (tx3, rx3) = channel::<()>();\n \n         spawn(proc() {\n-            p3.recv();\n-            c1.clone();\n-            assert_eq!(p3.try_recv(), Empty);\n-            c1.send(2);\n-            p3.recv();\n+            rx3.recv();\n+            tx1.clone();\n+            assert_eq!(rx3.try_recv(), Empty);\n+            tx1.send(2);\n+            rx3.recv();\n         });\n \n-        c3.send(());\n+        tx3.send(());\n         select!(\n-            _i1 = p1.recv() => {},\n-            _i2 = p2.recv() => fail!()\n+            _i1 = rx1.recv() => {},\n+            _i2 = rx2.recv() => fail!()\n         )\n-        c3.send(());\n+        tx3.send(());\n     })\n \n     test!(fn cloning3() {\n-        let (p1, c1) = Chan::<()>::new();\n-        let (p2, c2) = Chan::<()>::new();\n-        let (p, c) = Chan::new();\n+        let (tx1, rx1) = channel::<()>();\n+        let (tx2, rx2) = channel::<()>();\n+        let (tx3, rx3) = channel::<()>();\n         spawn(proc() {\n             let s = Select::new();\n-            let mut h1 = s.handle(&p1);\n-            let mut h2 = s.handle(&p2);\n+            let mut h1 = s.handle(&rx1);\n+            let mut h2 = s.handle(&rx2);\n             unsafe { h2.add(); }\n             unsafe { h1.add(); }\n             assert_eq!(s.wait(), h2.id);\n-            c.send(());\n+            tx3.send(());\n         });\n \n         for _ in range(0, 1000) { task::deschedule(); }\n-        drop(c1.clone());\n-        c2.send(());\n-        p.recv();\n+        drop(tx1.clone());\n+        tx2.send(());\n+        rx3.recv();\n     })\n \n     test!(fn preflight1() {\n-        let (p, c) = Chan::new();\n-        c.send(());\n+        let (tx, rx) = channel();\n+        tx.send(());\n         select!(\n-            () = p.recv() => {}\n+            () = rx.recv() => {}\n         )\n     })\n \n     test!(fn preflight2() {\n-        let (p, c) = Chan::new();\n-        c.send(());\n-        c.send(());\n+        let (tx, rx) = channel();\n+        tx.send(());\n+        tx.send(());\n         select!(\n-            () = p.recv() => {}\n+            () = rx.recv() => {}\n         )\n     })\n \n     test!(fn preflight3() {\n-        let (p, c) = Chan::new();\n-        drop(c.clone());\n-        c.send(());\n+        let (tx, rx) = channel();\n+        drop(tx.clone());\n+        tx.send(());\n         select!(\n-            () = p.recv() => {}\n+            () = rx.recv() => {}\n         )\n     })\n \n     test!(fn preflight4() {\n-        let (p, c) = Chan::new();\n-        c.send(());\n+        let (tx, rx) = channel();\n+        tx.send(());\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn preflight5() {\n-        let (p, c) = Chan::new();\n-        c.send(());\n-        c.send(());\n+        let (tx, rx) = channel();\n+        tx.send(());\n+        tx.send(());\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn preflight6() {\n-        let (p, c) = Chan::new();\n-        drop(c.clone());\n-        c.send(());\n+        let (tx, rx) = channel();\n+        drop(tx.clone());\n+        tx.send(());\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn preflight7() {\n-        let (p, c) = Chan::<()>::new();\n-        drop(c);\n+        let (tx, rx) = channel::<()>();\n+        drop(tx);\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn preflight8() {\n-        let (p, c) = Chan::new();\n-        c.send(());\n-        drop(c);\n-        p.recv();\n+        let (tx, rx) = channel();\n+        tx.send(());\n+        drop(tx);\n+        rx.recv();\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn preflight9() {\n-        let (p, c) = Chan::new();\n-        drop(c.clone());\n-        c.send(());\n-        drop(c);\n-        p.recv();\n+        let (tx, rx) = channel();\n+        drop(tx.clone());\n+        tx.send(());\n+        drop(tx);\n+        rx.recv();\n         let s = Select::new();\n-        let mut h = s.handle(&p);\n+        let mut h = s.handle(&rx);\n         unsafe { h.add(); }\n         assert_eq!(s.wait2(false), h.id);\n     })\n \n     test!(fn oneshot_data_waiting() {\n-        let (p, c) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         spawn(proc() {\n             select! {\n-                () = p.recv() => {}\n+                () = rx1.recv() => {}\n             }\n-            c2.send(());\n+            tx2.send(());\n         });\n \n         for _ in range(0, 100) { task::deschedule() }\n-        c.send(());\n-        p2.recv();\n+        tx1.send(());\n+        rx2.recv();\n     })\n \n     test!(fn stream_data_waiting() {\n-        let (p, c) = Chan::new();\n-        let (p2, c2) = Chan::new();\n-        c.send(());\n-        c.send(());\n-        p.recv();\n-        p.recv();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        tx1.send(());\n+        tx1.send(());\n+        rx1.recv();\n+        rx1.recv();\n         spawn(proc() {\n             select! {\n-                () = p.recv() => {}\n+                () = rx1.recv() => {}\n             }\n-            c2.send(());\n+            tx2.send(());\n         });\n \n         for _ in range(0, 100) { task::deschedule() }\n-        c.send(());\n-        p2.recv();\n+        tx1.send(());\n+        rx2.recv();\n     })\n \n     test!(fn shared_data_waiting() {\n-        let (p, c) = Chan::new();\n-        let (p2, c2) = Chan::new();\n-        drop(c.clone());\n-        c.send(());\n-        p.recv();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n+        drop(tx1.clone());\n+        tx1.send(());\n+        rx1.recv();\n         spawn(proc() {\n             select! {\n-                () = p.recv() => {}\n+                () = rx1.recv() => {}\n             }\n-            c2.send(());\n+            tx2.send(());\n         });\n \n         for _ in range(0, 100) { task::deschedule() }\n-        c.send(());\n-        p2.recv();\n+        tx1.send(());\n+        rx2.recv();\n     })\n }"}, {"sha": "d386e97d5bf968f4cac47d1caf09701ff4007dc4", "filename": "src/libstd/comm/stream.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fcomm%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fstream.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -18,7 +18,7 @@\n /// module.\n \n use cmp;\n-use comm::Port;\n+use comm::Receiver;\n use int;\n use iter::Iterator;\n use kinds::Send;\n@@ -51,7 +51,7 @@ pub struct Packet<T> {\n pub enum Failure<T> {\n     Empty,\n     Disconnected,\n-    Upgraded(Port<T>),\n+    Upgraded(Receiver<T>),\n }\n \n pub enum UpgradeResult {\n@@ -63,14 +63,14 @@ pub enum UpgradeResult {\n pub enum SelectionResult<T> {\n     SelSuccess,\n     SelCanceled(BlockedTask),\n-    SelUpgraded(BlockedTask, Port<T>),\n+    SelUpgraded(BlockedTask, Receiver<T>),\n }\n \n // Any message could contain an \"upgrade request\" to a new shared port, so the\n // internal queue it's a queue of T, but rather Message<T>\n enum Message<T> {\n     Data(T),\n-    GoUp(Port<T>),\n+    GoUp(Receiver<T>),\n }\n \n impl<T: Send> Packet<T> {\n@@ -97,7 +97,7 @@ impl<T: Send> Packet<T> {\n             }\n         }\n     }\n-    pub fn upgrade(&mut self, up: Port<T>) -> UpgradeResult {\n+    pub fn upgrade(&mut self, up: Receiver<T>) -> UpgradeResult {\n         self.do_send(GoUp(up))\n     }\n \n@@ -328,7 +328,7 @@ impl<T: Send> Packet<T> {\n     // Tests to see whether this port can receive without blocking. If Ok is\n     // returned, then that's the answer. If Err is returned, then the returned\n     // port needs to be queried instead (an upgrade happened)\n-    pub fn can_recv(&mut self) -> Result<bool, Port<T>> {\n+    pub fn can_recv(&mut self) -> Result<bool, Receiver<T>> {\n         // We peek at the queue to see if there's anything on it, and we use\n         // this return value to determine if we should pop from the queue and\n         // upgrade this channel immediately. If it looks like we've got an\n@@ -384,7 +384,7 @@ impl<T: Send> Packet<T> {\n \n     // Removes a previous task from being blocked in this port\n     pub fn abort_selection(&mut self,\n-                           was_upgrade: bool) -> Result<bool, Port<T>> {\n+                           was_upgrade: bool) -> Result<bool, Receiver<T>> {\n         // If we're aborting selection after upgrading from a oneshot, then\n         // we're guarantee that no one is waiting. The only way that we could\n         // have seen the upgrade is if data was actually sent on the channel"}, {"sha": "f09555e93a017b00a43223b26ede7265a7e9d0d6", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 39, "deletions": 38, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -8,52 +8,53 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use prelude::*;\n-\n-use comm::{Port, Chan};\n+use clone::Clone;\n use cmp;\n+use container::Container;\n+use comm::{Sender, Receiver};\n use io;\n use option::{None, Option, Some};\n+use result::{Ok, Err};\n use super::{Reader, Writer, IoResult};\n use vec::{bytes, CloneableVector, MutableVector, ImmutableVector};\n \n-/// Allows reading from a port.\n+/// Allows reading from a rx.\n ///\n /// # Example\n ///\n /// ```\n-/// use std::io::PortReader;\n+/// use std::io::ChanReader;\n ///\n-/// let (port, chan) = Chan::new();\n-/// # drop(chan);\n-/// let mut reader = PortReader::new(port);\n+/// let (tx, rx) = channel();\n+/// # drop(tx);\n+/// let mut reader = ChanReader::new(rx);\n ///\n /// let mut buf = ~[0u8, ..100];\n /// match reader.read(buf) {\n ///     Ok(nread) => println!(\"Read {} bytes\", nread),\n ///     Err(e) => println!(\"read error: {}\", e),\n /// }\n /// ```\n-pub struct PortReader {\n+pub struct ChanReader {\n     priv buf: Option<~[u8]>,  // A buffer of bytes received but not consumed.\n     priv pos: uint,           // How many of the buffered bytes have already be consumed.\n-    priv port: Port<~[u8]>,   // The port to pull data from.\n-    priv closed: bool,        // Whether the pipe this port connects to has been closed.\n+    priv rx: Receiver<~[u8]>,   // The rx to pull data from.\n+    priv closed: bool,        // Whether the pipe this rx connects to has been closed.\n }\n \n-impl PortReader {\n-    /// Wraps a `Port` in a `PortReader` structure\n-    pub fn new(port: Port<~[u8]>) -> PortReader {\n-        PortReader {\n+impl ChanReader {\n+    /// Wraps a `Port` in a `ChanReader` structure\n+    pub fn new(rx: Receiver<~[u8]>) -> ChanReader {\n+        ChanReader {\n             buf: None,\n             pos: 0,\n-            port: port,\n+            rx: rx,\n             closed: false,\n         }\n     }\n }\n \n-impl Reader for PortReader {\n+impl Reader for ChanReader {\n     fn read(&mut self, buf: &mut [u8]) -> IoResult<uint> {\n         let mut num_read = 0;\n         loop {\n@@ -72,7 +73,7 @@ impl Reader for PortReader {\n                 break;\n             }\n             self.pos = 0;\n-            self.buf = self.port.recv_opt();\n+            self.buf = self.rx.recv_opt();\n             self.closed = self.buf.is_none();\n         }\n         if self.closed && num_read == 0 {\n@@ -83,39 +84,39 @@ impl Reader for PortReader {\n     }\n }\n \n-/// Allows writing to a chan.\n+/// Allows writing to a tx.\n ///\n /// # Example\n ///\n /// ```\n /// # #[allow(unused_must_use)];\n /// use std::io::ChanWriter;\n ///\n-/// let (port, chan) = Chan::new();\n-/// # drop(port);\n-/// let mut writer = ChanWriter::new(chan);\n+/// let (tx, rx) = channel();\n+/// # drop(rx);\n+/// let mut writer = ChanWriter::new(tx);\n /// writer.write(\"hello, world\".as_bytes());\n /// ```\n pub struct ChanWriter {\n-    priv chan: Chan<~[u8]>,\n+    priv tx: Sender<~[u8]>,\n }\n \n impl ChanWriter {\n     /// Wraps a channel in a `ChanWriter` structure\n-    pub fn new(chan: Chan<~[u8]>) -> ChanWriter {\n-        ChanWriter { chan: chan }\n+    pub fn new(tx: Sender<~[u8]>) -> ChanWriter {\n+        ChanWriter { tx: tx }\n     }\n }\n \n impl Clone for ChanWriter {\n     fn clone(&self) -> ChanWriter {\n-        ChanWriter { chan: self.chan.clone() }\n+        ChanWriter { tx: self.tx.clone() }\n     }\n }\n \n impl Writer for ChanWriter {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n-        if !self.chan.try_send(buf.to_owned()) {\n+        if !self.tx.try_send(buf.to_owned()) {\n             Err(io::IoError {\n                 kind: io::BrokenPipe,\n                 desc: \"Pipe closed\",\n@@ -136,17 +137,17 @@ mod test {\n     use task;\n \n     #[test]\n-    fn test_port_reader() {\n-        let (port, chan) = Chan::new();\n+    fn test_rx_reader() {\n+        let (tx, rx) = channel();\n         task::spawn(proc() {\n-          chan.send(~[1u8, 2u8]);\n-          chan.send(~[]);\n-          chan.send(~[3u8, 4u8]);\n-          chan.send(~[5u8, 6u8]);\n-          chan.send(~[7u8, 8u8]);\n+          tx.send(~[1u8, 2u8]);\n+          tx.send(~[]);\n+          tx.send(~[3u8, 4u8]);\n+          tx.send(~[5u8, 6u8]);\n+          tx.send(~[7u8, 8u8]);\n         });\n \n-        let mut reader = PortReader::new(port);\n+        let mut reader = ChanReader::new(rx);\n         let mut buf = ~[0u8, ..3];\n \n \n@@ -177,12 +178,12 @@ mod test {\n \n     #[test]\n     fn test_chan_writer() {\n-        let (port, chan) = Chan::new();\n-        let mut writer = ChanWriter::new(chan);\n+        let (tx, rx) = channel();\n+        let mut writer = ChanWriter::new(tx);\n         writer.write_be_u32(42).unwrap();\n \n         let wanted = ~[0u8, 0u8, 0u8, 42u8];\n-        let got = task::try(proc() { port.recv() }).unwrap();\n+        let got = task::try(proc() { rx.recv() }).unwrap();\n         assert_eq!(wanted, got);\n \n         match writer.write_u8(1) {"}, {"sha": "04f4aba5730cc7f0e34db72ba98cfc13d1ac9df6", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -245,7 +245,7 @@ pub use self::process::{Process, ProcessConfig};\n pub use self::mem::{MemReader, BufReader, MemWriter, BufWriter};\n pub use self::buffered::{BufferedReader, BufferedWriter, BufferedStream,\n                          LineBufferedWriter};\n-pub use self::comm_adapters::{PortReader, ChanWriter};\n+pub use self::comm_adapters::{ChanReader, ChanWriter};\n \n pub mod test;\n "}, {"sha": "edadbc7873ac04087f526c340e9c1b7ca7def208", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 48, "deletions": 89, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -195,16 +195,13 @@ mod test {\n \n     iotest!(fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n@@ -213,16 +210,13 @@ mod test {\n \n     iotest!(fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let mut stream = TcpStream::connect(addr);\n             stream.write([99]).unwrap();\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         stream.read(buf).unwrap();\n@@ -231,16 +225,13 @@ mod test {\n \n     iotest!(fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n@@ -249,16 +240,13 @@ mod test {\n \n     iotest!(fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n@@ -267,16 +255,13 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n@@ -293,16 +278,13 @@ mod test {\n \n     iotest!(fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let mut buf = [0];\n         let nread = stream.read(buf);\n@@ -319,16 +301,13 @@ mod test {\n \n     iotest!(fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n@@ -347,16 +326,13 @@ mod test {\n \n     iotest!(fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         let mut stream = acceptor.accept();\n         let buf = [0];\n         loop {\n@@ -376,18 +352,15 @@ mod test {\n     iotest!(fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n         let max = 10u;\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n             stream.read(buf).unwrap();\n@@ -398,18 +371,15 @@ mod test {\n     iotest!(fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n         let max = 10u;\n-        let (port, chan) = Chan::new();\n+        let mut acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            port.recv();\n             for _ in range(0, max) {\n                 let mut stream = TcpStream::connect(addr);\n                 stream.write([99]).unwrap();\n             }\n         });\n \n-        let mut acceptor = TcpListener::bind(addr).listen();\n-        chan.send(());\n         for ref mut stream in acceptor.incoming().take(max) {\n             let mut buf = [0];\n             stream.read(buf).unwrap();\n@@ -420,11 +390,10 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n-        let (port, chan) = Chan::new();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n                 spawn(proc() {\n@@ -437,7 +406,6 @@ mod test {\n             }\n         });\n \n-        port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n@@ -457,11 +425,10 @@ mod test {\n     iotest!(fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n-        let (port, chan) = Chan::<()>::new();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            let mut acceptor = acceptor;\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n                 // Start another task to handle the connection\n                 spawn(proc() {\n@@ -474,7 +441,6 @@ mod test {\n             }\n         });\n \n-        port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n@@ -492,13 +458,12 @@ mod test {\n     })\n \n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip4() {\n-        let addr = next_test_ip4();\n         static MAX: int = 10;\n-        let (port, chan) = Chan::new();\n+        let addr = next_test_ip4();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n                 spawn(proc() {\n@@ -511,7 +476,6 @@ mod test {\n             }\n         });\n \n-        port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n@@ -529,13 +493,12 @@ mod test {\n     })\n \n     iotest!(fn multiple_connect_interleaved_lazy_schedule_ip6() {\n-        let addr = next_test_ip6();\n         static MAX: int = 10;\n-        let (port, chan) = Chan::new();\n+        let addr = next_test_ip6();\n+        let acceptor = TcpListener::bind(addr).listen();\n \n         spawn(proc() {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            let mut acceptor = acceptor;\n             for stream in acceptor.incoming().take(MAX as uint) {\n                 // Start another task to handle the connection\n                 spawn(proc() {\n@@ -548,7 +511,6 @@ mod test {\n             }\n         });\n \n-        port.recv();\n         connect(0, addr);\n \n         fn connect(i: int, addr: SocketAddr) {\n@@ -576,15 +538,12 @@ mod test {\n     }\n \n     pub fn peer_name(addr: SocketAddr) {\n-        let (port, chan) = Chan::new();\n-\n+        let acceptor = TcpListener::bind(addr).listen();\n         spawn(proc() {\n-            let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            let mut acceptor = acceptor;\n             acceptor.accept().unwrap();\n         });\n \n-        port.recv();\n         let stream = TcpStream::connect(addr);\n \n         assert!(stream.is_ok());\n@@ -611,23 +570,23 @@ mod test {\n \n     iotest!(fn partial_read() {\n         let addr = next_test_ip4();\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n             let mut srv = TcpListener::bind(addr).listen().unwrap();\n-            c.send(());\n+            tx.send(());\n             let mut cl = srv.accept().unwrap();\n             cl.write([10]).unwrap();\n             let mut b = [0];\n             cl.read(b).unwrap();\n-            c.send(());\n+            tx.send(());\n         });\n \n-        p.recv();\n+        rx.recv();\n         let mut c = TcpStream::connect(addr).unwrap();\n         let mut b = [0, ..10];\n         assert_eq!(c.read(b), Ok(1));\n         c.write([1]).unwrap();\n-        p.recv();\n+        rx.recv();\n     })\n \n     iotest!(fn double_bind() {\n@@ -644,22 +603,22 @@ mod test {\n \n     iotest!(fn fast_rebind() {\n         let addr = next_test_ip4();\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n-            port.recv();\n+            rx.recv();\n             let _stream = TcpStream::connect(addr).unwrap();\n             // Close\n-            port.recv();\n+            rx.recv();\n         });\n \n         {\n             let mut acceptor = TcpListener::bind(addr).listen();\n-            chan.send(());\n+            tx.send(());\n             {\n                 let _stream = acceptor.accept().unwrap();\n                 // Close client\n-                chan.send(());\n+                tx.send(());\n             }\n             // Close listener\n         }\n@@ -681,50 +640,50 @@ mod test {\n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p1, c1) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            p1.recv();\n+            rx1.recv();\n             s2.write([1]).unwrap();\n-            c2.send(());\n+            tx2.send(());\n         });\n-        c1.send(());\n+        tx1.send(());\n         let mut buf = [0, 0];\n         assert_eq!(s1.read(buf), Ok(1));\n-        p2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn tcp_clone_two_read() {\n         let addr = next_test_ip6();\n         let mut acceptor = TcpListener::bind(addr).listen();\n-        let (p, c) = Chan::new();\n-        let c2 = c.clone();\n+        let (tx1, rx) = channel();\n+        let tx2 = tx1.clone();\n \n         spawn(proc() {\n             let mut s = TcpStream::connect(addr);\n             s.write([1]).unwrap();\n-            p.recv();\n+            rx.recv();\n             s.write([2]).unwrap();\n-            p.recv();\n+            rx.recv();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p, done) = Chan::new();\n+        let (done, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(buf).unwrap();\n-            c2.send(());\n+            tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n         s1.read(buf).unwrap();\n-        c.send(());\n+        tx1.send(());\n \n-        p.recv();\n+        rx.recv();\n     })\n \n     iotest!(fn tcp_clone_two_write() {\n@@ -741,15 +700,15 @@ mod test {\n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p, done) = Chan::new();\n+        let (done, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n             s2.write([1]).unwrap();\n             done.send(());\n         });\n         s1.write([2]).unwrap();\n \n-        p.recv();\n+        rx.recv();\n     })\n }\n "}, {"sha": "e262055632158636195ca34d8a335756f8dc483e", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 46, "deletions": 46, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -107,23 +107,23 @@ mod test {\n     iotest!(fn socket_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n-        let (port, chan) = Chan::new();\n-        let (port2, chan2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    port.recv();\n+                    rx1.recv();\n                     client.sendto([99], server_ip).unwrap()\n                 }\n                 Err(..) => fail!()\n             }\n-            chan2.send(());\n+            tx2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                chan.send(());\n+                tx1.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n                     Ok((nread, src)) => {\n@@ -136,18 +136,18 @@ mod test {\n             }\n             Err(..) => fail!()\n         }\n-        port2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn socket_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n-        let (port, chan) = Chan::<()>::new();\n+        let (tx, rx) = channel::<()>();\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(ref mut client) => {\n-                    port.recv();\n+                    rx.recv();\n                     client.sendto([99], server_ip).unwrap()\n                 }\n                 Err(..) => fail!()\n@@ -156,7 +156,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Ok(ref mut server) => {\n-                chan.send(());\n+                tx.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n                     Ok((nread, src)) => {\n@@ -174,27 +174,27 @@ mod test {\n     iotest!(fn stream_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n-        let (port, chan) = Chan::new();\n-        let (port2, chan2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n-                    port.recv();\n+                    rx1.recv();\n                     stream.write([99]).unwrap();\n                 }\n                 Err(..) => fail!()\n             }\n-            chan2.send(());\n+            tx2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n-                chan.send(());\n+                tx1.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n                     Ok(nread) => {\n@@ -206,33 +206,33 @@ mod test {\n             }\n             Err(..) => fail!()\n         }\n-        port2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn stream_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n-        let (port, chan) = Chan::new();\n-        let (port2, chan2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n \n         spawn(proc() {\n             match UdpSocket::bind(client_ip) {\n                 Ok(client) => {\n                     let client = ~client;\n                     let mut stream = client.connect(server_ip);\n-                    port.recv();\n+                    rx1.recv();\n                     stream.write([99]).unwrap();\n                 }\n                 Err(..) => fail!()\n             }\n-            chan2.send(());\n+            tx2.send(());\n         });\n \n         match UdpSocket::bind(server_ip) {\n             Ok(server) => {\n                 let server = ~server;\n                 let mut stream = server.connect(client_ip);\n-                chan.send(());\n+                tx1.send(());\n                 let mut buf = [0];\n                 match stream.read(buf) {\n                     Ok(nread) => {\n@@ -244,7 +244,7 @@ mod test {\n             }\n             Err(..) => fail!()\n         }\n-        port2.recv();\n+        rx2.recv();\n     })\n \n     pub fn socket_name(addr: SocketAddr) {\n@@ -284,51 +284,51 @@ mod test {\n \n         let sock3 = sock1.clone();\n \n-        let (p1, c1) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut sock3 = sock3;\n-            p1.recv();\n+            rx1.recv();\n             sock3.sendto([1], addr2).unwrap();\n-            c2.send(());\n+            tx2.send(());\n         });\n-        c1.send(());\n+        tx1.send(());\n         let mut buf = [0, 0];\n         assert_eq!(sock1.recvfrom(buf), Ok((1, addr2)));\n-        p2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn udp_clone_two_read() {\n         let addr1 = next_test_ip4();\n         let addr2 = next_test_ip4();\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n-        let (p, c) = Chan::new();\n-        let c2 = c.clone();\n+        let (tx1, rx) = channel();\n+        let tx2 = tx1.clone();\n \n         spawn(proc() {\n             let mut sock2 = sock2;\n             sock2.sendto([1], addr1).unwrap();\n-            p.recv();\n+            rx.recv();\n             sock2.sendto([2], addr1).unwrap();\n-            p.recv();\n+            rx.recv();\n         });\n \n         let sock3 = sock1.clone();\n \n-        let (p, done) = Chan::new();\n+        let (done, rx) = channel();\n         spawn(proc() {\n             let mut sock3 = sock3;\n             let mut buf = [0, 0];\n             sock3.recvfrom(buf).unwrap();\n-            c2.send(());\n+            tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n         sock1.recvfrom(buf).unwrap();\n-        c.send(());\n+        tx1.send(());\n \n-        p.recv();\n+        rx.recv();\n     })\n \n     iotest!(fn udp_clone_two_write() {\n@@ -337,40 +337,40 @@ mod test {\n         let mut sock1 = UdpSocket::bind(addr1).unwrap();\n         let sock2 = UdpSocket::bind(addr2).unwrap();\n \n-        let (p, c) = Chan::new();\n-        let (serv_port, serv_chan) = Chan::new();\n+        let (tx, rx) = channel();\n+        let (serv_tx, serv_rx) = channel();\n \n         spawn(proc() {\n             let mut sock2 = sock2;\n             let mut buf = [0, 1];\n \n-            p.recv();\n+            rx.recv();\n             match sock2.recvfrom(buf) {\n                 Ok(..) => {}\n                 Err(e) => fail!(\"failed receive: {}\", e),\n             }\n-            serv_chan.send(());\n+            serv_tx.send(());\n         });\n \n         let sock3 = sock1.clone();\n \n-        let (p, done) = Chan::new();\n-        let c2 = c.clone();\n+        let (done, rx) = channel();\n+        let tx2 = tx.clone();\n         spawn(proc() {\n             let mut sock3 = sock3;\n             match sock3.sendto([1], addr2) {\n-                Ok(..) => { let _ = c2.try_send(()); }\n+                Ok(..) => { let _ = tx2.try_send(()); }\n                 Err(..) => {}\n             }\n             done.send(());\n         });\n         match sock1.sendto([2], addr2) {\n-            Ok(..) => { let _ = c.try_send(()); }\n+            Ok(..) => { let _ = tx.try_send(()); }\n             Err(..) => {}\n         }\n-        drop(c);\n+        drop(tx);\n \n-        p.recv();\n-        serv_port.recv();\n+        rx.recv();\n+        serv_rx.recv();\n     })\n }"}, {"sha": "bd715858a01f0e53f5eb90468c8a61c6dabb7b72", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -224,10 +224,13 @@ mod tests {\n         let times = 10;\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n-        let (port, chan) = Chan::new();\n+\n+        let mut acceptor = match UnixListener::bind(&path1).listen() {\n+            Ok(a) => a,\n+            Err(e) => fail!(\"failed listen: {}\", e),\n+        };\n \n         spawn(proc() {\n-            port.recv();\n             for _ in range(0, times) {\n                 let mut stream = UnixStream::connect(&path2);\n                 match stream.write([100]) {\n@@ -237,11 +240,6 @@ mod tests {\n             }\n         });\n \n-        let mut acceptor = match UnixListener::bind(&path1).listen() {\n-            Ok(a) => a,\n-            Err(e) => fail!(\"failed listen: {}\", e),\n-        };\n-        chan.send(());\n         for _ in range(0, times) {\n             let mut client = acceptor.accept();\n             let mut buf = [0];\n@@ -278,54 +276,54 @@ mod tests {\n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p1, c1) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n-            p1.recv();\n+            rx1.recv();\n             debug!(\"writer writing\");\n             s2.write([1]).unwrap();\n             debug!(\"writer done\");\n-            c2.send(());\n+            tx2.send(());\n         });\n-        c1.send(());\n+        tx1.send(());\n         let mut buf = [0, 0];\n         debug!(\"reader reading\");\n         assert_eq!(s1.read(buf), Ok(1));\n         debug!(\"reader done\");\n-        p2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn unix_clone_two_read() {\n         let addr = next_test_unix();\n         let mut acceptor = UnixListener::bind(&addr).listen();\n-        let (p, c) = Chan::new();\n-        let c2 = c.clone();\n+        let (tx1, rx) = channel();\n+        let tx2 = tx1.clone();\n \n         spawn(proc() {\n             let mut s = UnixStream::connect(&addr);\n             s.write([1]).unwrap();\n-            p.recv();\n+            rx.recv();\n             s.write([2]).unwrap();\n-            p.recv();\n+            rx.recv();\n         });\n \n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p, done) = Chan::new();\n+        let (done, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n             let mut buf = [0, 0];\n             s2.read(buf).unwrap();\n-            c2.send(());\n+            tx2.send(());\n             done.send(());\n         });\n         let mut buf = [0, 0];\n         s1.read(buf).unwrap();\n-        c.send(());\n+        tx1.send(());\n \n-        p.recv();\n+        rx.recv();\n     })\n \n     iotest!(fn unix_clone_two_write() {\n@@ -342,14 +340,14 @@ mod tests {\n         let mut s1 = acceptor.accept().unwrap();\n         let s2 = s1.clone();\n \n-        let (p, done) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n             let mut s2 = s2;\n             s2.write([1]).unwrap();\n-            done.send(());\n+            tx.send(());\n         });\n         s1.write([2]).unwrap();\n \n-        p.recv();\n+        rx.recv();\n     })\n }"}, {"sha": "02dfaeb71645b9cf087b75ae066a0afe0ced2f68", "filename": "src/libstd/io/pipe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fpipe.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -77,15 +77,15 @@ mod test {\n         let os::Pipe { input, out } = os::pipe();\n         let out = PipeStream::open(out);\n         let mut input = PipeStream::open(input);\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         spawn(proc() {\n             let mut out = out;\n             out.write([10]).unwrap();\n-            p.recv(); // don't close the pipe until the other read has finished\n+            rx.recv(); // don't close the pipe until the other read has finished\n         });\n \n         let mut buf = [0, ..10];\n         input.read(buf).unwrap();\n-        c.send(());\n+        tx.send(());\n     })\n }"}, {"sha": "6afd1bbb27d6be5a7c0b13eadfd88867c0e3dd9d", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -379,16 +379,16 @@ impl Process {\n     /// The stdin handle to the child is closed before waiting.\n     pub fn wait_with_output(&mut self) -> ProcessOutput {\n         drop(self.stdin.take());\n-        fn read(stream: Option<io::PipeStream>) -> Port<IoResult<~[u8]>> {\n-            let (p, c) = Chan::new();\n+        fn read(stream: Option<io::PipeStream>) -> Receiver<IoResult<~[u8]>> {\n+            let (tx, rx) = channel();\n             match stream {\n                 Some(stream) => spawn(proc() {\n                     let mut stream = stream;\n-                    c.send(stream.read_to_end())\n+                    tx.send(stream.read_to_end())\n                 }),\n-                None => c.send(Ok(~[]))\n+                None => tx.send(Ok(~[]))\n             }\n-            p\n+            rx\n         }\n         let stdout = read(self.stdout.take());\n         let stderr = read(self.stderr.take());"}, {"sha": "c66fcd13917004ff99492e1040a423f41197e064", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -20,7 +20,7 @@ definitions for a number of signals.\n */\n \n use clone::Clone;\n-use comm::{Port, Chan};\n+use comm::{Sender, Receiver, channel};\n use io;\n use iter::Iterator;\n use mem::drop;\n@@ -56,7 +56,7 @@ pub enum Signum {\n     WindowSizeChange = 28i,\n }\n \n-/// Listener provides a port to listen for registered signals.\n+/// Listener provides a receiver to listen for registered signals.\n ///\n /// Listener automatically unregisters its handles once it is out of scope.\n /// However, clients can still unregister signums manually.\n@@ -71,7 +71,7 @@ pub enum Signum {\n ///\n /// spawn({\n ///     loop {\n-///         match listener.port.recv() {\n+///         match listener.rx.recv() {\n ///             Interrupt => println!(\"Got Interrupt'ed\"),\n ///             _ => (),\n ///         }\n@@ -82,24 +82,24 @@ pub enum Signum {\n pub struct Listener {\n     /// A map from signums to handles to keep the handles in memory\n     priv handles: ~[(Signum, ~RtioSignal)],\n-    /// chan is where all the handles send signums, which are received by\n-    /// the clients from port.\n-    priv chan: Chan<Signum>,\n+    /// This is where all the handles send signums, which are received by\n+    /// the clients from the receiver.\n+    priv tx: Sender<Signum>,\n \n-    /// Clients of Listener can `recv()` from this port. This is exposed to\n-    /// allow selection over this port as well as manipulation of the port\n+    /// Clients of Listener can `recv()` on this receiver. This is exposed to\n+    /// allow selection over it as well as manipulation of the receiver\n     /// directly.\n-    port: Port<Signum>,\n+    rx: Receiver<Signum>,\n }\n \n impl Listener {\n     /// Creates a new listener for signals. Once created, signals are bound via\n     /// the `register` method (otherwise nothing will ever be received)\n     pub fn new() -> Listener {\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         Listener {\n-            chan: chan,\n-            port: port,\n+            tx: tx,\n+            rx: rx,\n             handles: ~[],\n         }\n     }\n@@ -125,7 +125,7 @@ impl Listener {\n             return Ok(()); // self is already listening to signum, so succeed\n         }\n         match LocalIo::maybe_raise(|io| {\n-            io.signal(signum, self.chan.clone())\n+            io.signal(signum, self.tx.clone())\n         }) {\n             Ok(handle) => {\n                 self.handles.push((signum, handle));\n@@ -166,7 +166,7 @@ mod test_unix {\n         signal.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n-        match signal.port.recv() {\n+        match signal.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n@@ -180,11 +180,11 @@ mod test_unix {\n         s2.register(Interrupt).unwrap();\n         sigint();\n         timer::sleep(10);\n-        match s1.port.recv() {\n+        match s1.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n-        match s2.port.recv() {\n+        match s2.rx.recv() {\n             Interrupt => (),\n             s => fail!(\"Expected Interrupt, got {:?}\", s),\n         }\n@@ -199,7 +199,7 @@ mod test_unix {\n         s2.unregister(Interrupt);\n         sigint();\n         timer::sleep(10);\n-        assert_eq!(s2.port.try_recv(), Empty);\n+        assert_eq!(s2.rx.try_recv(), Empty);\n     }\n }\n "}, {"sha": "7c65e76ab47314331bba267498047da453aae77d", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -388,10 +388,10 @@ mod tests {\n     })\n \n     iotest!(fn capture_stdout() {\n-        use io::comm_adapters::{PortReader, ChanWriter};\n+        use io::{ChanReader, ChanWriter};\n \n-        let (p, c) = Chan::new();\n-        let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+        let (tx, rx) = channel();\n+        let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n             set_stdout(~w as ~Writer);\n             println!(\"hello!\");\n@@ -400,10 +400,10 @@ mod tests {\n     })\n \n     iotest!(fn capture_stderr() {\n-        use io::comm_adapters::{PortReader, ChanWriter};\n+        use io::{ChanReader, ChanWriter};\n \n-        let (p, c) = Chan::new();\n-        let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+        let (tx, rx) = channel();\n+        let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n         spawn(proc() {\n             set_stderr(~w as ~Writer);\n             fail!(\"my special message\");"}, {"sha": "a3e5bac89d6deba6eebff522f4468eab8f5e76e3", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -46,9 +46,9 @@ macro_rules! iotest (\n             $($a)* #[test] fn green() { f() }\n             $($a)* #[test] fn native() {\n                 use native;\n-                let (p, c) = Chan::new();\n-                native::task::spawn(proc() { c.send(f()) });\n-                p.recv();\n+                let (tx, rx) = channel();\n+                native::task::spawn(proc() { tx.send(f()) });\n+                rx.recv();\n             }\n         }\n     )"}, {"sha": "f64c36c611c47c182dc6ec97bba6206e2b01c341", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 56, "deletions": 56, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -13,19 +13,19 @@\n Synchronous Timers\n \n This module exposes the functionality to create timers, block the current task,\n-and create ports which will receive notifications after a period of time.\n+and create receivers which will receive notifications after a period of time.\n \n */\n \n-use comm::Port;\n+use comm::Receiver;\n use rt::rtio::{IoFactory, LocalIo, RtioTimer};\n use io::IoResult;\n \n /// A synchronous timer object\n ///\n /// Values of this type can be used to put the current task to sleep for a\n /// period of time. Handles to this timer can also be created in the form of\n-/// ports which will receive notifications over time.\n+/// receivers which will receive notifications over time.\n ///\n /// # Example\n ///\n@@ -83,33 +83,33 @@ impl Timer {\n \n     /// Blocks the current task for `msecs` milliseconds.\n     ///\n-    /// Note that this function will cause any other ports for this timer to be\n-    /// invalidated (the other end will be closed).\n+    /// Note that this function will cause any other receivers for this timer to\n+    /// be invalidated (the other end will be closed).\n     pub fn sleep(&mut self, msecs: u64) {\n         self.obj.sleep(msecs);\n     }\n \n-    /// Creates a oneshot port which will have a notification sent when `msecs`\n-    /// milliseconds has elapsed. This does *not* block the current task, but\n-    /// instead returns immediately.\n+    /// Creates a oneshot receiver which will have a notification sent when\n+    /// `msecs` milliseconds has elapsed. This does *not* block the current\n+    /// task, but instead returns immediately.\n     ///\n-    /// Note that this invalidates any previous port which has been created by\n-    /// this timer, and that the returned port will be invalidated once the\n-    /// timer is destroyed (when it falls out of scope).\n-    pub fn oneshot(&mut self, msecs: u64) -> Port<()> {\n+    /// Note that this invalidates any previous receiver which has been created\n+    /// by this timer, and that the returned receiver will be invalidated once\n+    /// the timer is destroyed (when it falls out of scope).\n+    pub fn oneshot(&mut self, msecs: u64) -> Receiver<()> {\n         self.obj.oneshot(msecs)\n     }\n \n-    /// Creates a port which will have a continuous stream of notifications\n+    /// Creates a receiver which will have a continuous stream of notifications\n     /// being sent every `msecs` milliseconds. This does *not* block the\n     /// current task, but instead returns immediately. The first notification\n     /// will not be received immediately, but rather after `msec` milliseconds\n     /// have passed.\n     ///\n-    /// Note that this invalidates any previous port which has been created by\n-    /// this timer, and that the returned port will be invalidated once the\n-    /// timer is destroyed (when it falls out of scope).\n-    pub fn periodic(&mut self, msecs: u64) -> Port<()> {\n+    /// Note that this invalidates any previous receiver which has been created\n+    /// by this timer, and that the returned receiver will be invalidated once\n+    /// the timer is destroyed (when it falls out of scope).\n+    pub fn periodic(&mut self, msecs: u64) -> Receiver<()> {\n         self.obj.period(msecs)\n     }\n }\n@@ -133,26 +133,26 @@ mod test {\n \n     iotest!(fn oneshot_twice() {\n         let mut timer = Timer::new().unwrap();\n-        let port1 = timer.oneshot(10000);\n-        let port = timer.oneshot(1);\n-        port.recv();\n-        assert_eq!(port1.recv_opt(), None);\n+        let rx1 = timer.oneshot(10000);\n+        let rx = timer.oneshot(1);\n+        rx.recv();\n+        assert_eq!(rx1.recv_opt(), None);\n     })\n \n     iotest!(fn test_io_timer_oneshot_then_sleep() {\n         let mut timer = Timer::new().unwrap();\n-        let port = timer.oneshot(100000000000);\n-        timer.sleep(1); // this should invalidate the port\n+        let rx = timer.oneshot(100000000000);\n+        timer.sleep(1); // this should inalidate rx\n \n-        assert_eq!(port.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), None);\n     })\n \n     iotest!(fn test_io_timer_sleep_periodic() {\n         let mut timer = Timer::new().unwrap();\n-        let port = timer.periodic(1);\n-        port.recv();\n-        port.recv();\n-        port.recv();\n+        let rx = timer.periodic(1);\n+        rx.recv();\n+        rx.recv();\n+        rx.recv();\n     })\n \n     iotest!(fn test_io_timer_sleep_periodic_forget() {\n@@ -167,33 +167,33 @@ mod test {\n     iotest!(fn oneshot() {\n         let mut timer = Timer::new().unwrap();\n \n-        let port = timer.oneshot(1);\n-        port.recv();\n-        assert!(port.recv_opt().is_none());\n+        let rx = timer.oneshot(1);\n+        rx.recv();\n+        assert!(rx.recv_opt().is_none());\n \n-        let port = timer.oneshot(1);\n-        port.recv();\n-        assert!(port.recv_opt().is_none());\n+        let rx = timer.oneshot(1);\n+        rx.recv();\n+        assert!(rx.recv_opt().is_none());\n     })\n \n     iotest!(fn override() {\n         let mut timer = Timer::new().unwrap();\n-        let oport = timer.oneshot(100);\n-        let pport = timer.periodic(100);\n+        let orx = timer.oneshot(100);\n+        let prx = timer.periodic(100);\n         timer.sleep(1);\n-        assert_eq!(oport.recv_opt(), None);\n-        assert_eq!(pport.recv_opt(), None);\n+        assert_eq!(orx.recv_opt(), None);\n+        assert_eq!(prx.recv_opt(), None);\n         timer.oneshot(1).recv();\n     })\n \n     iotest!(fn period() {\n         let mut timer = Timer::new().unwrap();\n-        let port = timer.periodic(1);\n-        port.recv();\n-        port.recv();\n-        let port2 = timer.periodic(1);\n-        port2.recv();\n-        port2.recv();\n+        let rx = timer.periodic(1);\n+        rx.recv();\n+        rx.recv();\n+        let rx2 = timer.periodic(1);\n+        rx2.recv();\n+        rx2.recv();\n     })\n \n     iotest!(fn sleep() {\n@@ -204,13 +204,13 @@ mod test {\n \n     iotest!(fn oneshot_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _port = timer.oneshot(1);\n+        let _rx = timer.oneshot(1);\n         fail!();\n     } #[should_fail])\n \n     iotest!(fn period_fail() {\n         let mut timer = Timer::new().unwrap();\n-        let _port = timer.periodic(1);\n+        let _rx = timer.periodic(1);\n         fail!();\n     } #[should_fail])\n \n@@ -222,10 +222,10 @@ mod test {\n     iotest!(fn closing_channel_during_drop_doesnt_kill_everything() {\n         // see issue #10375\n         let mut timer = Timer::new().unwrap();\n-        let timer_port = timer.periodic(1000);\n+        let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            timer_rx.recv_opt();\n         });\n \n         // when we drop the TimerWatcher we're going to destroy the channel,\n@@ -235,10 +235,10 @@ mod test {\n     iotest!(fn reset_doesnt_switch_tasks() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_port = timer.periodic(1000);\n+        let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            timer_rx.recv_opt();\n         });\n \n         timer.oneshot(1);\n@@ -247,29 +247,29 @@ mod test {\n     iotest!(fn reset_doesnt_switch_tasks2() {\n         // similar test to the one above.\n         let mut timer = Timer::new().unwrap();\n-        let timer_port = timer.periodic(1000);\n+        let timer_rx = timer.periodic(1000);\n \n         spawn(proc() {\n-            timer_port.recv_opt();\n+            timer_rx.recv_opt();\n         });\n \n         timer.sleep(1);\n     })\n \n     iotest!(fn sender_goes_away_oneshot() {\n-        let port = {\n+        let rx = {\n             let mut timer = Timer::new().unwrap();\n             timer.oneshot(1000)\n         };\n-        assert_eq!(port.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), None);\n     })\n \n     iotest!(fn sender_goes_away_period() {\n-        let port = {\n+        let rx = {\n             let mut timer = Timer::new().unwrap();\n             timer.periodic(1000)\n         };\n-        assert_eq!(port.recv_opt(), None);\n+        assert_eq!(rx.recv_opt(), None);\n     })\n \n     iotest!(fn receiver_goes_away_oneshot() {"}, {"sha": "ece9c1bfd20bd4ef3003d9d8e3056b877fdb60ef", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -387,17 +387,17 @@ macro_rules! vec(\n /// # Example\n ///\n /// ```\n-/// let (p1, c1) = Chan::new();\n-/// let (p2, c2) = Chan::new();\n+/// let (tx1, rx1) = channel();\n+/// let (tx2, rx2) = channel();\n /// # fn long_running_task() {}\n /// # fn calculate_the_answer() -> int { 42 }\n ///\n-/// spawn(proc() { long_running_task(); c1.send(()) });\n-/// spawn(proc() { c2.send(calculate_the_answer()) });\n+/// spawn(proc() { long_running_task(); tx1.send(()) });\n+/// spawn(proc() { tx2.send(calculate_the_answer()) });\n ///\n /// select! (\n-///     () = p1.recv() => println!(\"the long running task finished first\"),\n-///     answer = p2.recv() => {\n+///     () = rx1.recv() => println!(\"the long running task finished first\"),\n+///     answer = rx2.recv() => {\n ///         println!(\"the answer was: {}\", answer);\n ///     }\n /// )\n@@ -408,16 +408,16 @@ macro_rules! vec(\n #[experimental]\n macro_rules! select {\n     (\n-        $($name:pat = $port:ident.$meth:ident() => $code:expr),+\n+        $($name:pat = $rx:ident.$meth:ident() => $code:expr),+\n     ) => ({\n         use std::comm::Select;\n         let sel = Select::new();\n-        $( let mut $port = sel.handle(&$port); )+\n+        $( let mut $rx = sel.handle(&$rx); )+\n         unsafe {\n-            $( $port.add(); )+\n+            $( $rx.add(); )+\n         }\n         let ret = sel.wait();\n-        $( if ret == $port.id() { let $name = $port.$meth(); $code } else )+\n+        $( if ret == $rx.id() { let $name = $rx.$meth(); $code } else )+\n         { unreachable!() }\n     })\n }"}, {"sha": "a04b59ae601132590d8551328651e4868b4f001f", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -61,7 +61,7 @@ pub use vec::{MutableVector, MutableTotalOrdVector};\n pub use vec::{Vector, VectorVector, CloneableVector, ImmutableVector};\n \n // Reexported runtime types\n-pub use comm::{Port, Chan};\n+pub use comm::{channel, Sender, Receiver};\n pub use task::spawn;\n \n // Reexported statics"}, {"sha": "cd557f01834e935410566eb13dfeabec9aef71c8", "filename": "src/libstd/rt/rtio.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Frt%2Frtio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Frt%2Frtio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Frtio.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -10,7 +10,7 @@\n \n use c_str::CString;\n use cast;\n-use comm::{Chan, Port};\n+use comm::{Sender, Receiver};\n use libc::c_int;\n use libc;\n use ops::Drop;\n@@ -183,7 +183,7 @@ pub trait IoFactory {\n     fn pipe_open(&mut self, fd: c_int) -> Result<~RtioPipe, IoError>;\n     fn tty_open(&mut self, fd: c_int, readable: bool)\n             -> Result<~RtioTTY, IoError>;\n-    fn signal(&mut self, signal: Signum, channel: Chan<Signum>)\n+    fn signal(&mut self, signal: Signum, channel: Sender<Signum>)\n         -> Result<~RtioSignal, IoError>;\n }\n \n@@ -233,8 +233,8 @@ pub trait RtioUdpSocket : RtioSocket {\n \n pub trait RtioTimer {\n     fn sleep(&mut self, msecs: u64);\n-    fn oneshot(&mut self, msecs: u64) -> Port<()>;\n-    fn period(&mut self, msecs: u64) -> Port<()>;\n+    fn oneshot(&mut self, msecs: u64) -> Receiver<()>;\n+    fn period(&mut self, msecs: u64) -> Receiver<()>;\n }\n \n pub trait RtioFileStream {"}, {"sha": "86e69560e9d8b409c83c975f6a04afbdaa583f1f", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -17,7 +17,7 @@ use any::AnyOwnExt;\n use cast;\n use cleanup;\n use clone::Clone;\n-use comm::Chan;\n+use comm::Sender;\n use io::Writer;\n use iter::{Iterator, Take};\n use local_data;\n@@ -73,7 +73,7 @@ pub enum DeathAction {\n     /// until all its watched children exit before collecting the status.\n     Execute(proc(TaskResult)),\n     /// A channel to send the result of the task on when the task exits\n-    SendMessage(Chan<TaskResult>),\n+    SendMessage(Sender<TaskResult>),\n }\n \n /// Per-task state related to task death, killing, failure, etc.\n@@ -450,16 +450,16 @@ mod test {\n \n     #[test]\n     fn comm_stream() {\n-        let (port, chan) = Chan::new();\n-        chan.send(10);\n-        assert!(port.recv() == 10);\n+        let (tx, rx) = channel();\n+        tx.send(10);\n+        assert!(rx.recv() == 10);\n     }\n \n     #[test]\n     fn comm_shared_chan() {\n-        let (port, chan) = Chan::new();\n-        chan.send(10);\n-        assert!(port.recv() == 10);\n+        let (tx, rx) = channel();\n+        tx.send(10);\n+        assert!(rx.recv() == 10);\n     }\n \n     #[test]"}, {"sha": "ad0434c634a5375d9fb2a958417b0dda698c5300", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -172,24 +172,24 @@ mod tests {\n         let nmsgs = 1000u;\n         let mut q = Queue::with_capacity(nthreads*nmsgs);\n         assert_eq!(None, q.pop());\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         for _ in range(0, nthreads) {\n             let q = q.clone();\n-            let chan = chan.clone();\n+            let tx = tx.clone();\n             native::task::spawn(proc() {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n-                chan.send(());\n+                tx.send(());\n             });\n         }\n \n-        let mut completion_ports = ~[];\n+        let mut completion_rxs = ~[];\n         for _ in range(0, nthreads) {\n-            let (completion_port, completion_chan) = Chan::new();\n-            completion_ports.push(completion_port);\n+            let (tx, rx) = channel();\n+            completion_rxs.push(rx);\n             let q = q.clone();\n             native::task::spawn(proc() {\n                 let mut q = q;\n@@ -203,15 +203,15 @@ mod tests {\n                         }\n                     }\n                 }\n-                completion_chan.send(i);\n+                tx.send(i);\n             });\n         }\n \n-        for completion_port in completion_ports.mut_iter() {\n-            assert_eq!(nmsgs, completion_port.recv());\n+        for rx in completion_rxs.mut_iter() {\n+            assert_eq!(nmsgs, rx.recv());\n         }\n         for _ in range(0, nthreads) {\n-            port.recv();\n+            rx.recv();\n         }\n     }\n }"}, {"sha": "9d69f2b3b0891128f1977f5586d25ea9f544bf03", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -176,17 +176,17 @@ mod tests {\n             Empty => {}\n             Inconsistent | Data(..) => fail!()\n         }\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let q = UnsafeArc::new(q);\n \n         for _ in range(0, nthreads) {\n-            let chan = chan.clone();\n+            let tx = tx.clone();\n             let q = q.clone();\n             native::task::spawn(proc() {\n                 for i in range(0, nmsgs) {\n                     unsafe { (*q.get()).push(i); }\n                 }\n-                chan.send(());\n+                tx.send(());\n             });\n         }\n \n@@ -197,9 +197,9 @@ mod tests {\n                 Data(_) => { i += 1 }\n             }\n         }\n-        drop(chan);\n+        drop(tx);\n         for _ in range(0, nthreads) {\n-            port.recv();\n+            rx.recv();\n         }\n     }\n }"}, {"sha": "9277587e5872648e484e46e75e027f1cca780b13", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -273,7 +273,7 @@ mod test {\n \n         fn stress_bound(bound: uint) {\n             let (a, b) = UnsafeArc::new2(Queue::new(bound));\n-            let (port, chan) = Chan::new();\n+            let (tx, rx) = channel();\n             native::task::spawn(proc() {\n                 for _ in range(0, 100000) {\n                     loop {\n@@ -284,12 +284,12 @@ mod test {\n                         }\n                     }\n                 }\n-                chan.send(());\n+                tx.send(());\n             });\n             for _ in range(0, 100000) {\n                 unsafe { (*a.get()).push(1); }\n             }\n-            port.recv();\n+            rx.recv();\n         }\n     }\n }"}, {"sha": "19f41c6fa1cb16b23180aa25357b54543e8d39a5", "filename": "src/libstd/task.rs", "status": "modified", "additions": 40, "deletions": 43, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,34 +11,33 @@\n /*!\n  * Utilities for managing and scheduling tasks\n  *\n- * An executing Rust program consists of a tree of tasks, each with their own\n- * stack, and sole ownership of their allocated heap data. Tasks communicate\n- * with each other using ports and channels (see std::comm for more info\n- * about how communication works).\n+ * An executing Rust program consists of a collection of tasks, each with their\n+ * own stack, and sole ownership of their allocated heap data. Tasks communicate\n+ * with each other using channels (see `std::comm` for more info about how\n+ * communication works).\n  *\n- * Failure in one task does not propagate to any others (not to parent, not to child).\n- * Failure propagation is instead handled by using Chan.send() and Port.recv(), which\n- * will fail if the other end has hung up already.\n+ * Failure in one task does not propagate to any others (not to parent, not to\n+ * child).  Failure propagation is instead handled by using the channel send()\n+ * and recv() methods which will fail if the other end has hung up already.\n  *\n  * Task Scheduling:\n  *\n- * By default, every task is created in the same scheduler as its parent, where it\n- * is scheduled cooperatively with all other tasks in that scheduler. Some specialized\n- * applications may want more control over their scheduling, in which case they can be\n- * spawned into a new scheduler with the specific properties required. See TaskBuilder's\n- * documentation bellow for more information.\n+ * By default, every task is created with the same \"flavor\" as the calling task.\n+ * This flavor refers to the scheduling mode, with two possibilities currently\n+ * being 1:1 and M:N modes. Green (M:N) tasks are cooperatively scheduled and\n+ * native (1:1) tasks are scheduled by the OS kernel.\n  *\n  * # Example\n  *\n- * ```\n+ * ```rust\n  * spawn(proc() {\n  *     println!(\"Hello, World!\");\n  * })\n  * ```\n  */\n \n use any::Any;\n-use comm::{Chan, Port};\n+use comm::{Sender, Receiver, channel};\n use io::Writer;\n use kinds::{Send, marker};\n use logging::Logger;\n@@ -62,7 +61,7 @@ pub type TaskResult = Result<(), ~Any>;\n /// Task configuration options\n pub struct TaskOpts {\n     /// Enable lifecycle notifications on the given channel\n-    notify_chan: Option<Chan<TaskResult>>,\n+    notify_chan: Option<Sender<TaskResult>>,\n     /// A name for the task-to-be, for identification in failure messages\n     name: Option<SendStr>,\n     /// The size of the stack for the spawned task\n@@ -116,7 +115,7 @@ impl TaskBuilder {\n     ///\n     /// # Failure\n     /// Fails if a future_result was already set for this task.\n-    pub fn future_result(&mut self) -> Port<TaskResult> {\n+    pub fn future_result(&mut self) -> Receiver<TaskResult> {\n         // FIXME (#3725): Once linked failure and notification are\n         // handled in the library, I can imagine implementing this by just\n         // registering an arbitrary number of task::on_exit handlers and\n@@ -127,12 +126,12 @@ impl TaskBuilder {\n         }\n \n         // Construct the future and give it to the caller.\n-        let (notify_pipe_po, notify_pipe_ch) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // Reconfigure self to use a notify channel.\n-        self.opts.notify_chan = Some(notify_pipe_ch);\n+        self.opts.notify_chan = Some(tx);\n \n-        notify_pipe_po\n+        rx\n     }\n \n     /// Name the task-to-be. Currently the name is used for identification\n@@ -204,16 +203,16 @@ impl TaskBuilder {\n      * Fails if a future_result was already set for this task.\n      */\n     pub fn try<T:Send>(mut self, f: proc() -> T) -> Result<T, ~Any> {\n-        let (po, ch) = Chan::new();\n+        let (tx, rx) = channel();\n \n         let result = self.future_result();\n \n         self.spawn(proc() {\n-            ch.send(f());\n+            tx.send(f());\n         });\n \n         match result.recv() {\n-            Ok(())     => Ok(po.recv()),\n+            Ok(())     => Ok(rx.recv()),\n             Err(cause) => Err(cause)\n         }\n     }\n@@ -340,25 +339,24 @@ fn test_send_named_task() {\n \n #[test]\n fn test_run_basic() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     task().spawn(proc() {\n-        ch.send(());\n+        tx.send(());\n     });\n-    po.recv();\n+    rx.recv();\n }\n \n #[test]\n fn test_with_wrapper() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     task().with_wrapper(proc(body) {\n-        let ch = ch;\n         let result: proc() = proc() {\n             body();\n-            ch.send(());\n+            tx.send(());\n         };\n         result\n     }).spawn(proc() { });\n-    po.recv();\n+    rx.recv();\n }\n \n #[test]\n@@ -407,50 +405,49 @@ fn test_try_fail() {\n fn test_spawn_sched() {\n     use clone::Clone;\n \n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n \n-    fn f(i: int, ch: Chan<()>) {\n-        let ch = ch.clone();\n+    fn f(i: int, tx: Sender<()>) {\n+        let tx = tx.clone();\n         spawn(proc() {\n             if i == 0 {\n-                ch.send(());\n+                tx.send(());\n             } else {\n-                f(i - 1, ch);\n+                f(i - 1, tx);\n             }\n         });\n \n     }\n-    f(10, ch);\n-    po.recv();\n+    f(10, tx);\n+    rx.recv();\n }\n \n #[test]\n fn test_spawn_sched_childs_on_default_sched() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n \n     spawn(proc() {\n-        let ch = ch;\n         spawn(proc() {\n-            ch.send(());\n+            tx.send(());\n         });\n     });\n \n-    po.recv();\n+    rx.recv();\n }\n \n #[cfg(test)]\n fn avoid_copying_the_body(spawnfn: |v: proc()|) {\n-    let (p, ch) = Chan::<uint>::new();\n+    let (tx, rx) = channel::<uint>();\n \n     let x = ~1;\n     let x_in_parent = (&*x) as *int as uint;\n \n     spawnfn(proc() {\n         let x_in_child = (&*x) as *int as uint;\n-        ch.send(x_in_child);\n+        tx.send(x_in_child);\n     });\n \n-    let x_in_child = p.recv();\n+    let x_in_child = rx.recv();\n     assert_eq!(x_in_parent, x_in_child);\n }\n "}, {"sha": "de004f0af3e0c4d77c65033d5ecafba7ff1693dd", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -124,14 +124,14 @@ mod tests {\n \n             for _ in range(0u, num_tasks) {\n                 let total = total.clone();\n-                let (port, chan) = Chan::new();\n-                futures.push(port);\n+                let (tx, rx) = channel();\n+                futures.push(rx);\n \n                 task::spawn(proc() {\n                     for _ in range(0u, count) {\n                         total.with(|count| **count += 1);\n                     }\n-                    chan.send(());\n+                    tx.send(());\n                 });\n             };\n "}, {"sha": "faa7a9de5426e96f1f861ef100bae39f4bbd2c66", "filename": "src/libsync/arc.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Farc.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -20,19 +20,20 @@\n  * ```rust\n  * extern crate sync;\n  * extern crate rand;\n- * use sync::Arc;\n+ *\n  * use std::vec;\n+ * use sync::Arc;\n  *\n  * fn main() {\n  *     let numbers = vec::from_fn(100, |i| (i as f32) * rand::random());\n  *     let shared_numbers = Arc::new(numbers);\n  *\n  *     for _ in range(0, 10) {\n- *         let (port, chan) = Chan::new();\n- *         chan.send(shared_numbers.clone());\n+ *         let (tx, rx) = channel();\n+ *         tx.send(shared_numbers.clone());\n  *\n  *         spawn(proc() {\n- *             let shared_numbers = port.recv();\n+ *             let shared_numbers = rx.recv();\n  *             let local_numbers = shared_numbers.get();\n  *\n  *             // Work with the local numbers\n@@ -582,16 +583,16 @@ mod tests {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = Arc::new(v);\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n \n         task::spawn(proc() {\n-            let arc_v: Arc<~[int]> = p.recv();\n+            let arc_v: Arc<~[int]> = rx.recv();\n \n             let v = arc_v.get().clone();\n             assert_eq!(v[3], 4);\n         });\n \n-        c.send(arc_v.clone());\n+        tx.send(arc_v.clone());\n \n         assert_eq!(arc_v.get()[2], 3);\n         assert_eq!(arc_v.get()[4], 5);\n@@ -603,18 +604,18 @@ mod tests {\n     fn test_mutex_arc_condvar() {\n         let arc = ~MutexArc::new(false);\n         let arc2 = ~arc.clone();\n-        let (p,c) = Chan::new();\n+        let (tx, rx) = channel();\n         task::spawn(proc() {\n             // wait until parent gets in\n-            p.recv();\n+            rx.recv();\n             arc2.access_cond(|state, cond| {\n                 *state = true;\n                 cond.signal();\n             })\n         });\n \n         arc.access_cond(|state, cond| {\n-            c.send(());\n+            tx.send(());\n             assert!(!*state);\n             while !*state {\n                 cond.wait();\n@@ -626,10 +627,10 @@ mod tests {\n     fn test_arc_condvar_poison() {\n         let arc = ~MutexArc::new(1);\n         let arc2 = ~arc.clone();\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n-            let _ = p.recv();\n+            let _ = rx.recv();\n             arc2.access_cond(|one, cond| {\n                 cond.signal();\n                 // Parent should fail when it wakes up.\n@@ -638,7 +639,7 @@ mod tests {\n         });\n \n         arc.access_cond(|one, cond| {\n-            c.send(());\n+            tx.send(());\n             while *one == 1 {\n                 cond.wait();\n             }\n@@ -781,7 +782,7 @@ mod tests {\n     fn test_rw_arc() {\n         let arc = RWArc::new(0);\n         let arc2 = arc.clone();\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n \n         task::spawn(proc() {\n             arc2.write(|num| {\n@@ -791,7 +792,7 @@ mod tests {\n                     task::deschedule();\n                     *num = tmp + 1;\n                 }\n-                c.send(());\n+                tx.send(());\n             })\n         });\n \n@@ -814,7 +815,7 @@ mod tests {\n         }\n \n         // Wait for writer to finish\n-        p.recv();\n+        rx.recv();\n         arc.read(|num| {\n             assert_eq!(*num, 10);\n         })\n@@ -852,42 +853,42 @@ mod tests {\n         // Reader tasks\n         let mut reader_convos = ~[];\n         for _ in range(0, 10) {\n-            let ((rp1, rc1), (rp2, rc2)) = (Chan::new(), Chan::new());\n-            reader_convos.push((rc1, rp2));\n+            let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n+            reader_convos.push((tx1, rx2));\n             let arcn = arc.clone();\n             task::spawn(proc() {\n-                rp1.recv(); // wait for downgrader to give go-ahead\n+                rx1.recv(); // wait for downgrader to give go-ahead\n                 arcn.read(|state| {\n                     assert_eq!(*state, 31337);\n-                    rc2.send(());\n+                    tx2.send(());\n                 })\n             });\n         }\n \n         // Writer task\n         let arc2 = arc.clone();\n-        let ((wp1, wc1), (wp2, wc2)) = (Chan::new(), Chan::new());\n+        let ((tx1, rx1), (tx2, rx2)) = (channel(), channel());\n         task::spawn(proc() {\n-            wp1.recv();\n+            rx1.recv();\n             arc2.write_cond(|state, cond| {\n                 assert_eq!(*state, 0);\n                 *state = 42;\n                 cond.signal();\n             });\n-            wp1.recv();\n+            rx1.recv();\n             arc2.write(|state| {\n                 // This shouldn't happen until after the downgrade read\n                 // section, and all other readers, finish.\n                 assert_eq!(*state, 31337);\n                 *state = 42;\n             });\n-            wc2.send(());\n+            tx2.send(());\n         });\n \n         // Downgrader (us)\n         arc.write_downgrade(|mut write_mode| {\n             write_mode.write_cond(|state, cond| {\n-                wc1.send(()); // send to another writer who will wake us up\n+                tx1.send(()); // send to another writer who will wake us up\n                 while *state == 0 {\n                     cond.wait();\n                 }\n@@ -904,12 +905,12 @@ mod tests {\n                 for &(_, ref mut rp) in reader_convos.mut_iter() {\n                     rp.recv()\n                 }\n-                wc1.send(()); // tell writer to try again\n+                tx1.send(()); // tell writer to try again\n                 assert_eq!(*state, 31337);\n             });\n         });\n \n-        wp2.recv(); // complete handshake with writer\n+        rx2.recv(); // complete handshake with writer\n     }\n     #[cfg(test)]\n     fn test_rw_write_cond_downgrade_read_race_helper() {\n@@ -923,13 +924,13 @@ mod tests {\n         //     \"blk(&ArcCondvar { order: opt_lock, ..*cond })\"\n         // with just \"blk(cond)\".\n         let x = RWArc::new(true);\n-        let (wp, wc) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // writer task\n         let xw = x.clone();\n         task::spawn(proc() {\n             xw.write_cond(|state, c| {\n-                wc.send(()); // tell downgrader it's ok to go\n+                tx.send(()); // tell downgrader it's ok to go\n                 c.wait();\n                 // The core of the test is here: the condvar reacquire path\n                 // must involve order_lock, so that it cannot race with a reader\n@@ -938,7 +939,7 @@ mod tests {\n             })\n         });\n \n-        wp.recv(); // wait for writer to get in\n+        rx.recv(); // wait for writer to get in\n \n         x.write_downgrade(|mut write_mode| {\n             write_mode.write_cond(|state, c| {\n@@ -948,12 +949,12 @@ mod tests {\n             });\n             // make a reader task to trigger the \"reader cloud lock\" handoff\n             let xr = x.clone();\n-            let (rp, rc) = Chan::new();\n+            let (tx, rx) = channel();\n             task::spawn(proc() {\n-                rc.send(());\n+                tx.send(());\n                 xr.read(|_state| { })\n             });\n-            rp.recv(); // wait for reader task to exist\n+            rx.recv(); // wait for reader task to exist\n \n             let read_mode = x.downgrade(write_mode);\n             read_mode.read(|state| {"}, {"sha": "f713c13d94595aafc5eddc0b874006c0d86a6822", "filename": "src/libsync/comm.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fcomm.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -20,44 +20,45 @@ use std::comm;\n \n /// An extension of `pipes::stream` that allows both sending and receiving.\n pub struct DuplexStream<T, U> {\n-    priv chan: Chan<T>,\n-    priv port: Port<U>,\n+    priv tx: Sender<T>,\n+    priv rx: Receiver<U>,\n+}\n+\n+/// Creates a bidirectional stream.\n+pub fn duplex<T: Send, U: Send>() -> (DuplexStream<T, U>, DuplexStream<U, T>) {\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    (DuplexStream { tx: tx1, rx: rx2 },\n+     DuplexStream { tx: tx2, rx: rx1 })\n }\n \n // Allow these methods to be used without import:\n impl<T:Send,U:Send> DuplexStream<T, U> {\n-    /// Creates a bidirectional stream.\n-    pub fn new() -> (DuplexStream<T, U>, DuplexStream<U, T>) {\n-        let (p1, c2) = Chan::new();\n-        let (p2, c1) = Chan::new();\n-        (DuplexStream { chan: c1, port: p1 },\n-         DuplexStream { chan: c2, port: p2 })\n-    }\n     pub fn send(&self, x: T) {\n-        self.chan.send(x)\n+        self.tx.send(x)\n     }\n     pub fn try_send(&self, x: T) -> bool {\n-        self.chan.try_send(x)\n+        self.tx.try_send(x)\n     }\n     pub fn recv(&self) -> U {\n-        self.port.recv()\n+        self.rx.recv()\n     }\n     pub fn try_recv(&self) -> comm::TryRecvResult<U> {\n-        self.port.try_recv()\n+        self.rx.try_recv()\n     }\n     pub fn recv_opt(&self) -> Option<U> {\n-        self.port.recv_opt()\n+        self.rx.recv_opt()\n     }\n }\n \n /// An extension of `pipes::stream` that provides synchronous message sending.\n-pub struct SyncChan<T> { priv duplex_stream: DuplexStream<T, ()> }\n+pub struct SyncSender<T> { priv duplex_stream: DuplexStream<T, ()> }\n /// An extension of `pipes::stream` that acknowledges each message received.\n-pub struct SyncPort<T> { priv duplex_stream: DuplexStream<(), T> }\n+pub struct SyncReceiver<T> { priv duplex_stream: DuplexStream<(), T> }\n \n-impl<T: Send> SyncChan<T> {\n+impl<T: Send> SyncSender<T> {\n     pub fn send(&self, val: T) {\n-        assert!(self.try_send(val), \"SyncChan.send: receiving port closed\");\n+        assert!(self.try_send(val), \"SyncSender.send: receiving port closed\");\n     }\n \n     /// Sends a message, or report if the receiver has closed the connection\n@@ -67,9 +68,9 @@ impl<T: Send> SyncChan<T> {\n     }\n }\n \n-impl<T: Send> SyncPort<T> {\n+impl<T: Send> SyncReceiver<T> {\n     pub fn recv(&self) -> T {\n-        self.recv_opt().expect(\"SyncPort.recv: sending channel closed\")\n+        self.recv_opt().expect(\"SyncReceiver.recv: sending channel closed\")\n     }\n \n     pub fn recv_opt(&self) -> Option<T> {\n@@ -89,20 +90,20 @@ impl<T: Send> SyncPort<T> {\n \n /// Creates a stream whose channel, upon sending a message, blocks until the\n /// message is received.\n-pub fn rendezvous<T: Send>() -> (SyncPort<T>, SyncChan<T>) {\n-    let (chan_stream, port_stream) = DuplexStream::new();\n-    (SyncPort { duplex_stream: port_stream },\n-     SyncChan { duplex_stream: chan_stream })\n+pub fn rendezvous<T: Send>() -> (SyncReceiver<T>, SyncSender<T>) {\n+    let (chan_stream, port_stream) = duplex();\n+    (SyncReceiver { duplex_stream: port_stream },\n+     SyncSender { duplex_stream: chan_stream })\n }\n \n #[cfg(test)]\n mod test {\n-    use comm::{DuplexStream, rendezvous};\n+    use comm::{duplex, rendezvous};\n \n \n     #[test]\n     pub fn DuplexStream1() {\n-        let (left, right) = DuplexStream::new();\n+        let (left, right) = duplex();\n \n         left.send(~\"abc\");\n         right.send(123);"}, {"sha": "74a15dc9f0e120d2a0d2baa5b2ed57e252a15dc3", "filename": "src/libsync/future.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ffuture.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -104,7 +104,7 @@ impl<A> Future<A> {\n }\n \n impl<A:Send> Future<A> {\n-    pub fn from_port(port: Port<A>) -> Future<A> {\n+    pub fn from_receiver(rx: Receiver<A>) -> Future<A> {\n         /*!\n          * Create a future from a port\n          *\n@@ -113,7 +113,7 @@ impl<A:Send> Future<A> {\n          */\n \n         Future::from_fn(proc() {\n-            port.recv()\n+            rx.recv()\n         })\n     }\n \n@@ -125,13 +125,13 @@ impl<A:Send> Future<A> {\n          * value of the future.\n          */\n \n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         spawn(proc() {\n-            chan.send(blk());\n+            tx.send(blk());\n         });\n \n-        Future::from_port(port)\n+        Future::from_receiver(rx)\n     }\n }\n \n@@ -148,10 +148,10 @@ mod test {\n     }\n \n     #[test]\n-    fn test_from_port() {\n-        let (po, ch) = Chan::new();\n-        ch.send(~\"whale\");\n-        let mut f = Future::from_port(po);\n+    fn test_from_receiver() {\n+        let (tx, rx) = channel();\n+        tx.send(~\"whale\");\n+        let mut f = Future::from_receiver(rx);\n         assert_eq!(f.get(), ~\"whale\");\n     }\n "}, {"sha": "dd6ae7c77f5d2a696aea7a700e237799a6e38a11", "filename": "src/libsync/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Flib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -19,8 +19,8 @@\n \n pub use arc::{Arc, MutexArc, RWArc, RWWriteMode, RWReadMode, ArcCondvar, CowArc};\n pub use sync::{Mutex, RWLock, Condvar, Semaphore, RWLockWriteMode,\n-    RWLockReadMode, Barrier, one, mutex};\n-pub use comm::{DuplexStream, SyncChan, SyncPort, rendezvous};\n+               RWLockReadMode, Barrier, one, mutex};\n+pub use comm::{DuplexStream, SyncSender, SyncReceiver, rendezvous, duplex};\n pub use task_pool::TaskPool;\n pub use future::Future;\n "}, {"sha": "3bb60046b035ed3f2aa19d7deaa29b6cfd55eff5", "filename": "src/libsync/sync/mod.rs", "status": "modified", "additions": 72, "deletions": 169, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmod.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -37,17 +37,17 @@ mod mpsc_intrusive;\n \n // Each waiting task receives on one of these.\n #[doc(hidden)]\n-type WaitEnd = Port<()>;\n+type WaitEnd = Receiver<()>;\n #[doc(hidden)]\n-type SignalEnd = Chan<()>;\n+type SignalEnd = Sender<()>;\n // A doubly-ended queue of waiting tasks.\n #[doc(hidden)]\n-struct WaitQueue { head: Port<SignalEnd>,\n-                   tail: Chan<SignalEnd> }\n+struct WaitQueue { head: Receiver<SignalEnd>,\n+                   tail: Sender<SignalEnd> }\n \n impl WaitQueue {\n     fn new() -> WaitQueue {\n-        let (block_head, block_tail) = Chan::new();\n+        let (block_tail, block_head) = channel();\n         WaitQueue { head: block_head, tail: block_tail }\n     }\n \n@@ -83,7 +83,7 @@ impl WaitQueue {\n     }\n \n     fn wait_end(&self) -> WaitEnd {\n-        let (wait_end, signal_end) = Chan::new();\n+        let (signal_end, wait_end) = channel();\n         assert!(self.tail.try_send(signal_end));\n         wait_end\n     }\n@@ -797,46 +797,46 @@ mod tests {\n     #[test]\n     fn test_sem_as_cvar() {\n         /* Child waits and parent signals */\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         task::spawn(proc() {\n             s2.acquire();\n-            c.send(());\n+            tx.send(());\n         });\n         for _ in range(0, 5) { task::deschedule(); }\n         s.release();\n-        let _ = p.recv();\n+        let _ = rx.recv();\n \n         /* Parent waits and child signals */\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         let s = Semaphore::new(0);\n         let s2 = s.clone();\n         task::spawn(proc() {\n             for _ in range(0, 5) { task::deschedule(); }\n             s2.release();\n-            let _ = p.recv();\n+            let _ = rx.recv();\n         });\n         s.acquire();\n-        c.send(());\n+        tx.send(());\n     }\n     #[test]\n     fn test_sem_multi_resource() {\n         // Parent and child both get in the critical section at the same\n         // time, and shake hands.\n         let s = Semaphore::new(2);\n         let s2 = s.clone();\n-        let (p1,c1) = Chan::new();\n-        let (p2,c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         task::spawn(proc() {\n             s2.access(|| {\n-                let _ = p2.recv();\n-                c1.send(());\n+                let _ = rx2.recv();\n+                tx1.send(());\n             })\n         });\n         s.access(|| {\n-            c2.send(());\n-            let _ = p1.recv();\n+            tx2.send(());\n+            let _ = rx1.recv();\n         })\n     }\n     #[test]\n@@ -845,19 +845,19 @@ mod tests {\n         // When one blocks, it should schedule the other one.\n         let s = Semaphore::new(1);\n         let s2 = s.clone();\n-        let (p, c) = Chan::new();\n-        let mut child_data = Some((s2, c));\n+        let (tx, rx) = channel();\n+        let mut child_data = Some((s2, tx));\n         s.access(|| {\n-            let (s2, c) = child_data.take_unwrap();\n+            let (s2, tx) = child_data.take_unwrap();\n             task::spawn(proc() {\n-                c.send(());\n+                tx.send(());\n                 s2.access(|| { });\n-                c.send(());\n+                tx.send(());\n             });\n-            let _ = p.recv(); // wait for child to come alive\n+            let _ = rx.recv(); // wait for child to come alive\n             for _ in range(0, 5) { task::deschedule(); } // let the child contend\n         });\n-        let _ = p.recv(); // wait for child to be done\n+        let _ = rx.recv(); // wait for child to be done\n     }\n     /************************************************************************\n      * Mutex tests\n@@ -866,7 +866,7 @@ mod tests {\n     fn test_mutex_lock() {\n         // Unsafely achieve shared state, and do the textbook\n         // \"load tmp = move ptr; inc tmp; store ptr <- tmp\" dance.\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         let m = Mutex::new();\n         let m2 = m.clone();\n         let mut sharedstate = ~0;\n@@ -876,12 +876,12 @@ mod tests {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &m2, 10);\n-                c.send(());\n+                tx.send(());\n             });\n         }\n         {\n             access_shared(sharedstate, &m, 10);\n-            let _ = p.recv();\n+            let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n@@ -912,48 +912,48 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port,chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let m3 = m.clone();\n         task::spawn(proc() {\n             m3.lock_cond(|cond| {\n-                chan.send(());\n+                tx.send(());\n                 cond.wait();\n-                chan.send(());\n+                tx.send(());\n             })\n         });\n-        let _ = port.recv(); // Wait until child gets in the mutex\n+        let _ = rx.recv(); // Wait until child gets in the mutex\n         m.lock_cond(|cond| {\n             let woken = cond.signal();\n             assert!(woken);\n         });\n-        let _ = port.recv(); // Wait until child wakes up\n+        let _ = rx.recv(); // Wait until child wakes up\n     }\n     #[cfg(test)]\n     fn test_mutex_cond_broadcast_helper(num_waiters: uint) {\n         let m = Mutex::new();\n-        let mut ports = ~[];\n+        let mut rxs = ~[];\n \n         for _ in range(0, num_waiters) {\n             let mi = m.clone();\n-            let (port, chan) = Chan::new();\n-            ports.push(port);\n+            let (tx, rx) = channel();\n+            rxs.push(rx);\n             task::spawn(proc() {\n                 mi.lock_cond(|cond| {\n-                    chan.send(());\n+                    tx.send(());\n                     cond.wait();\n-                    chan.send(());\n+                    tx.send(());\n                 })\n             });\n         }\n \n         // wait until all children get in the mutex\n-        for port in ports.mut_iter() { let _ = port.recv(); }\n+        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n         m.lock_cond(|cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.mut_iter() { let _ = port.recv(); }\n+        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n     }\n     #[test]\n     fn test_mutex_cond_broadcast() {\n@@ -991,81 +991,6 @@ mod tests {\n         // child task must have finished by the time try returns\n         m.lock(|| { })\n     }\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn test_mutex_killed_cond() {\n-        use std::any::Any;\n-\n-        // Getting killed during cond wait must not corrupt the mutex while\n-        // unwinding (e.g. double unlock).\n-        let m = Mutex::new();\n-        let m2 = m.clone();\n-\n-        let result: result::Result<(), ~Any> = task::try(proc() {\n-            let (p, c) = Chan::new();\n-            task::spawn(proc() { // linked\n-                let _ = p.recv(); // wait for sibling to get in the mutex\n-                task::deschedule();\n-                fail!();\n-            });\n-            m2.lock_cond(|cond| {\n-                c.send(()); // tell sibling go ahead\n-                cond.wait(); // block forever\n-            })\n-        });\n-        assert!(result.is_err());\n-        // child task must have finished by the time try returns\n-        m.lock_cond(|cond| {\n-            let woken = cond.signal();\n-            assert!(!woken);\n-        })\n-    }\n-    #[ignore(reason = \"linked failure\")]\n-    #[test]\n-    fn test_mutex_killed_broadcast() {\n-        use std::any::Any;\n-        use std::unstable::finally::Finally;\n-\n-        let m = Mutex::new();\n-        let m2 = m.clone();\n-        let (p, c) = Chan::new();\n-\n-        let result: result::Result<(), ~Any> = task::try(proc() {\n-            let mut sibling_convos = ~[];\n-            for _ in range(0, 2) {\n-                let (p, c) = Chan::new();\n-                sibling_convos.push(p);\n-                let mi = m2.clone();\n-                // spawn sibling task\n-                task::spawn(proc() { // linked\n-                    mi.lock_cond(|cond| {\n-                        c.send(()); // tell sibling to go ahead\n-                        (|| {\n-                            cond.wait(); // block forever\n-                        }).finally(|| {\n-                            error!(\"task unwinding and sending\");\n-                            c.send(());\n-                            error!(\"task unwinding and done sending\");\n-                        })\n-                    })\n-                });\n-            }\n-            for p in sibling_convos.mut_iter() {\n-                let _ = p.recv(); // wait for sibling to get in the mutex\n-            }\n-            m2.lock(|| { });\n-            c.send(sibling_convos); // let parent wait on all children\n-            fail!();\n-        });\n-        assert!(result.is_err());\n-        // child task must have finished by the time try returns\n-        let mut r = p.recv();\n-        for p in r.mut_iter() { p.recv(); } // wait on all its siblings\n-        m.lock_cond(|cond| {\n-            let woken = cond.broadcast();\n-            assert_eq!(woken, 0);\n-        })\n-    }\n     #[test]\n     fn test_mutex_cond_signal_on_0() {\n         // Tests that signal_on(0) is equivalent to signal().\n@@ -1081,28 +1006,6 @@ mod tests {\n         })\n     }\n     #[test]\n-    #[ignore(reason = \"linked failure?\")]\n-    fn test_mutex_different_conds() {\n-        let result = task::try(proc() {\n-            let m = Mutex::new_with_condvars(2);\n-            let m2 = m.clone();\n-            let (p, c) = Chan::new();\n-            task::spawn(proc() {\n-                m2.lock_cond(|cond| {\n-                    c.send(());\n-                    cond.wait_on(1);\n-                })\n-            });\n-            let _ = p.recv();\n-            m.lock_cond(|cond| {\n-                if !cond.signal_on(0) {\n-                    fail!(); // success; punt sibling awake.\n-                }\n-            })\n-        });\n-        assert!(result.is_err());\n-    }\n-    #[test]\n     fn test_mutex_no_condvars() {\n         let result = task::try(proc() {\n             let m = Mutex::new_with_condvars(0);\n@@ -1143,11 +1046,11 @@ mod tests {\n     }\n     #[cfg(test)]\n     fn test_rwlock_exclusion(x: &RWLock,\n-                                 mode1: RWLockMode,\n-                                 mode2: RWLockMode) {\n+                             mode1: RWLockMode,\n+                             mode2: RWLockMode) {\n         // Test mutual exclusion between readers and writers. Just like the\n         // mutex mutual exclusion test, a ways above.\n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         let x2 = x.clone();\n         let mut sharedstate = ~0;\n         {\n@@ -1156,12 +1059,12 @@ mod tests {\n                 let sharedstate: &mut int =\n                     unsafe { cast::transmute(ptr) };\n                 access_shared(sharedstate, &x2, mode1, 10);\n-                c.send(());\n+                tx.send(());\n             });\n         }\n         {\n             access_shared(sharedstate, x, mode2, 10);\n-            let _ = p.recv();\n+            let _ = rx.recv();\n \n             assert_eq!(*sharedstate, 20);\n         }\n@@ -1198,29 +1101,29 @@ mod tests {\n                                  make_mode2_go_first: bool) {\n         // Much like sem_multi_resource.\n         let x2 = x.clone();\n-        let (p1, c1) = Chan::new();\n-        let (p2, c2) = Chan::new();\n+        let (tx1, rx1) = channel();\n+        let (tx2, rx2) = channel();\n         task::spawn(proc() {\n             if !make_mode2_go_first {\n-                let _ = p2.recv(); // parent sends to us once it locks, or ...\n+                let _ = rx2.recv(); // parent sends to us once it locks, or ...\n             }\n             lock_rwlock_in_mode(&x2, mode2, || {\n                 if make_mode2_go_first {\n-                    c1.send(()); // ... we send to it once we lock\n+                    tx1.send(()); // ... we send to it once we lock\n                 }\n-                let _ = p2.recv();\n-                c1.send(());\n+                let _ = rx2.recv();\n+                tx1.send(());\n             })\n         });\n         if make_mode2_go_first {\n-            let _ = p1.recv(); // child sends to us once it locks, or ...\n+            let _ = rx1.recv(); // child sends to us once it locks, or ...\n         }\n         lock_rwlock_in_mode(x, mode1, || {\n             if !make_mode2_go_first {\n-                c2.send(()); // ... we send to it once we lock\n+                tx2.send(()); // ... we send to it once we lock\n             }\n-            c2.send(());\n-            let _ = p1.recv();\n+            tx2.send(());\n+            let _ = rx1.recv();\n         })\n     }\n     #[test]\n@@ -1264,22 +1167,22 @@ mod tests {\n             cond.wait();\n         });\n         // Parent wakes up child\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n         let x3 = x.clone();\n         task::spawn(proc() {\n             x3.write_cond(|cond| {\n-                chan.send(());\n+                tx.send(());\n                 cond.wait();\n-                chan.send(());\n+                tx.send(());\n             })\n         });\n-        let _ = port.recv(); // Wait until child gets in the rwlock\n+        let _ = rx.recv(); // Wait until child gets in the rwlock\n         x.read(|| { }); // Must be able to get in as a reader in the meantime\n         x.write_cond(|cond| { // Or as another writer\n             let woken = cond.signal();\n             assert!(woken);\n         });\n-        let _ = port.recv(); // Wait until child wakes up\n+        let _ = rx.recv(); // Wait until child wakes up\n         x.read(|| { }); // Just for good measure\n     }\n     #[cfg(test)]\n@@ -1297,29 +1200,29 @@ mod tests {\n             }\n         }\n         let x = RWLock::new();\n-        let mut ports = ~[];\n+        let mut rxs = ~[];\n \n         for _ in range(0, num_waiters) {\n             let xi = x.clone();\n-            let (port, chan) = Chan::new();\n-            ports.push(port);\n+            let (tx, rx) = channel();\n+            rxs.push(rx);\n             task::spawn(proc() {\n                 lock_cond(&xi, dg1, |cond| {\n-                    chan.send(());\n+                    tx.send(());\n                     cond.wait();\n-                    chan.send(());\n+                    tx.send(());\n                 })\n             });\n         }\n \n         // wait until all children get in the mutex\n-        for port in ports.mut_iter() { let _ = port.recv(); }\n+        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n         lock_cond(&x, dg2, |cond| {\n             let num_woken = cond.broadcast();\n             assert_eq!(num_woken, num_waiters);\n         });\n         // wait until all children wake up\n-        for port in ports.mut_iter() { let _ = port.recv(); }\n+        for rx in rxs.mut_iter() { let _ = rx.recv(); }\n     }\n     #[test]\n     fn test_rwlock_cond_broadcast() {\n@@ -1400,28 +1303,28 @@ mod tests {\n     #[test]\n     fn test_barrier() {\n         let barrier = Barrier::new(10);\n-        let (port, chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         for _ in range(0, 9) {\n             let c = barrier.clone();\n-            let chan = chan.clone();\n+            let tx = tx.clone();\n             spawn(proc() {\n                 c.wait();\n-                chan.send(true);\n+                tx.send(true);\n             });\n         }\n \n         // At this point, all spawned tasks should be blocked,\n         // so we shouldn't get anything from the port\n-        assert!(match port.try_recv() {\n+        assert!(match rx.try_recv() {\n             Empty => true,\n             _ => false,\n         });\n \n         barrier.wait();\n         // Now, the barrier is cleared and we should get data.\n         for _ in range(0, 9) {\n-            port.recv();\n+            rx.recv();\n         }\n     }\n }"}, {"sha": "9901cda423bd9b73af512825c010f3d50cdb15bd", "filename": "src/libsync/sync/mutex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fmutex.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -532,17 +532,17 @@ mod test {\n             }\n         }\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         for _ in range(0, N) {\n-            let c2 = c.clone();\n-            native::task::spawn(proc() { inc(); c2.send(()); });\n-            let c2 = c.clone();\n-            spawn(proc() { inc(); c2.send(()); });\n+            let tx2 = tx.clone();\n+            native::task::spawn(proc() { inc(); tx2.send(()); });\n+            let tx2 = tx.clone();\n+            spawn(proc() { inc(); tx2.send(()); });\n         }\n \n-        drop(c);\n+        drop(tx);\n         for _ in range(0, 2 * N) {\n-            p.recv();\n+            rx.recv();\n         }\n         assert_eq!(unsafe {CNT}, M * N * 2);\n         unsafe {"}, {"sha": "c5e83bed0ed4c253c60c94262bda2141ce468b0b", "filename": "src/libsync/sync/one.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Fsync%2Fone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Fsync%2Fone.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -137,9 +137,9 @@ mod test {\n         static mut o: Once = ONCE_INIT;\n         static mut run: bool = false;\n \n-        let (p, c) = Chan::new();\n+        let (tx, rx) = channel();\n         for _ in range(0, 10) {\n-            let c = c.clone();\n+            let tx = tx.clone();\n             spawn(proc() {\n                 for _ in range(0, 4) { task::deschedule() }\n                 unsafe {\n@@ -149,7 +149,7 @@ mod test {\n                     });\n                     assert!(run);\n                 }\n-                c.send(());\n+                tx.send(());\n             });\n         }\n \n@@ -162,7 +162,7 @@ mod test {\n         }\n \n         for _ in range(0, 10) {\n-            p.recv();\n+            rx.recv();\n         }\n     }\n }"}, {"sha": "93487827200a60789b1928c243e466b6a4dfe859", "filename": "src/libsync/task_pool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsync%2Ftask_pool.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -23,7 +23,7 @@ enum Msg<T> {\n }\n \n pub struct TaskPool<T> {\n-    priv channels: ~[Chan<Msg<T>>],\n+    priv channels: ~[Sender<Msg<T>>],\n     priv next_index: uint,\n }\n \n@@ -48,13 +48,13 @@ impl<T> TaskPool<T> {\n         assert!(n_tasks >= 1);\n \n         let channels = vec::from_fn(n_tasks, |i| {\n-            let (port, chan) = Chan::<Msg<T>>::new();\n+            let (tx, rx) = channel::<Msg<T>>();\n             let init_fn = init_fn_factory();\n \n             let task_body: proc() = proc() {\n                 let local_data = init_fn(i);\n                 loop {\n-                    match port.recv() {\n+                    match rx.recv() {\n                         Execute(f) => f(&local_data),\n                         Quit => break\n                     }\n@@ -64,7 +64,7 @@ impl<T> TaskPool<T> {\n             // Run on this scheduler.\n             task::spawn(task_body);\n \n-            chan\n+            tx\n         });\n \n         return TaskPool { channels: channels, next_index: 0 };"}, {"sha": "44488f86ae4e42aee6c3babb46d32e4baae9edbc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -53,7 +53,7 @@ use std::f64;\n use std::fmt;\n use std::from_str::FromStr;\n use std::io::stdio::StdWriter;\n-use std::io::{File, PortReader, ChanWriter};\n+use std::io::{File, ChanReader, ChanWriter};\n use std::io;\n use std::os;\n use std::str;\n@@ -827,7 +827,7 @@ fn run_tests(opts: &TestOpts,\n     remaining.reverse();\n     let mut pending = 0;\n \n-    let (p, ch) = Chan::<MonitorMsg>::new();\n+    let (tx, rx) = channel::<MonitorMsg>();\n \n     while pending > 0 || !remaining.is_empty() {\n         while pending < concurrency && !remaining.is_empty() {\n@@ -838,11 +838,11 @@ fn run_tests(opts: &TestOpts,\n                 // that hang forever.\n                 try!(callback(TeWait(test.desc.clone(), test.testfn.padding())));\n             }\n-            run_test(!opts.run_tests, test, ch.clone());\n+            run_test(!opts.run_tests, test, tx.clone());\n             pending += 1;\n         }\n \n-        let (desc, result, stdout) = p.recv();\n+        let (desc, result, stdout) = rx.recv();\n         if concurrency != 1 {\n             try!(callback(TeWait(desc.clone(), PadNone)));\n         }\n@@ -854,8 +854,8 @@ fn run_tests(opts: &TestOpts,\n     // (this includes metric fns)\n     for b in filtered_benchs_and_metrics.move_iter() {\n         try!(callback(TeWait(b.desc.clone(), b.testfn.padding())));\n-        run_test(!opts.run_benchmarks, b, ch.clone());\n-        let (test, result, stdout) = p.recv();\n+        run_test(!opts.run_benchmarks, b, tx.clone());\n+        let (test, result, stdout) = rx.recv();\n         try!(callback(TeResult(test, result, stdout)));\n     }\n     Ok(())\n@@ -938,7 +938,7 @@ pub fn filter_tests(\n \n pub fn run_test(force_ignore: bool,\n                 test: TestDescAndFn,\n-                monitor_ch: Chan<MonitorMsg>) {\n+                monitor_ch: Sender<MonitorMsg>) {\n \n     let TestDescAndFn {desc, testfn} = test;\n \n@@ -948,13 +948,13 @@ pub fn run_test(force_ignore: bool,\n     }\n \n     fn run_test_inner(desc: TestDesc,\n-                      monitor_ch: Chan<MonitorMsg>,\n+                      monitor_ch: Sender<MonitorMsg>,\n                       testfn: proc()) {\n         spawn(proc() {\n-            let (p, c) = Chan::new();\n-            let mut reader = PortReader::new(p);\n-            let stdout = ChanWriter::new(c.clone());\n-            let stderr = ChanWriter::new(c);\n+            let (tx, rx) = channel();\n+            let mut reader = ChanReader::new(rx);\n+            let stdout = ChanWriter::new(tx.clone());\n+            let stderr = ChanWriter::new(tx);\n             let mut task = task::task().named(match desc.name {\n                 DynTestName(ref name) => name.clone().into_maybe_owned(),\n                 StaticTestName(name) => name.into_maybe_owned(),\n@@ -1321,9 +1321,9 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = Chan::new();\n-        run_test(false, desc, ch);\n-        let (_, res, _) = p.recv();\n+        let (tx, rx) = channel();\n+        run_test(false, desc, tx);\n+        let (_, res, _) = rx.recv();\n         assert!(res != TrOk);\n     }\n \n@@ -1338,9 +1338,9 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = Chan::new();\n-        run_test(false, desc, ch);\n-        let (_, res, _) = p.recv();\n+        let (tx, rx) = channel();\n+        run_test(false, desc, tx);\n+        let (_, res, _) = rx.recv();\n         assert!(res == TrIgnored);\n     }\n \n@@ -1355,9 +1355,9 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = Chan::new();\n-        run_test(false, desc, ch);\n-        let (_, res, _) = p.recv();\n+        let (tx, rx) = channel();\n+        run_test(false, desc, tx);\n+        let (_, res, _) = rx.recv();\n         assert!(res == TrOk);\n     }\n \n@@ -1372,9 +1372,9 @@ mod tests {\n             },\n             testfn: DynTestFn(proc() f()),\n         };\n-        let (p, ch) = Chan::new();\n-        run_test(false, desc, ch);\n-        let (_, res, _) = p.recv();\n+        let (tx, rx) = channel();\n+        run_test(false, desc, tx);\n+        let (_, res, _) = rx.recv();\n         assert!(res == TrFailed);\n     }\n "}, {"sha": "88692cf3f5e3c15f339bb2609eae598627859c15", "filename": "src/test/auxiliary/cci_capture_clause.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_capture_clause.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -10,10 +10,10 @@\n \n use std::task;\n \n-pub fn foo<T:Send + Clone>(x: T) -> Port<T> {\n-    let (p, c) = Chan::new();\n+pub fn foo<T:Send + Clone>(x: T) -> Receiver<T> {\n+    let (tx, rx) = channel();\n     task::spawn(proc() {\n-        c.send(x.clone());\n+        tx.send(x.clone());\n     });\n-    p\n+    rx\n }"}, {"sha": "bc729acbdf58b8f725dff526630d05ca1c2e6e60", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -33,7 +33,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: &Port<request>, responses: &Chan<uint>) {\n+fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut count = 0u;\n     let mut done = false;\n     while !done {\n@@ -52,8 +52,8 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = Chan::new();\n-    let (from_parent, to_child) = Chan::new();\n+    let (to_parent, from_child) = channel();\n+    let (to_child, from_parent) = channel();\n \n     let size = from_str::<uint>(args[1]).unwrap();\n     let workers = from_str::<uint>(args[2]).unwrap();"}, {"sha": "a24e830a98748a1b3af903825505e38622d97f73", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -28,7 +28,7 @@ enum request {\n     stop\n }\n \n-fn server(requests: &Port<request>, responses: &Chan<uint>) {\n+fn server(requests: &Receiver<request>, responses: &Sender<uint>) {\n     let mut count: uint = 0;\n     let mut done = false;\n     while !done {\n@@ -47,15 +47,15 @@ fn server(requests: &Port<request>, responses: &Chan<uint>) {\n }\n \n fn run(args: &[~str]) {\n-    let (from_child, to_parent) = Chan::new();\n+    let (to_parent, from_child) = channel();\n \n     let size = from_str::<uint>(args[1]).unwrap();\n     let workers = from_str::<uint>(args[2]).unwrap();\n     let num_bytes = 100;\n     let start = time::precise_time_s();\n     let mut worker_results = ~[];\n     let from_parent = if workers == 1 {\n-        let (from_parent, to_child) = Chan::new();\n+        let (to_child, from_parent) = channel();\n         let mut builder = task::task();\n         worker_results.push(builder.future_result());\n         builder.spawn(proc() {\n@@ -67,7 +67,7 @@ fn run(args: &[~str]) {\n         });\n         from_parent\n     } else {\n-        let (from_parent, to_child) = Chan::new();\n+        let (to_child, from_parent) = channel();\n         for _ in range(0u, workers) {\n             let to_child = to_child.clone();\n             let mut builder = task::task();"}, {"sha": "1e00915e3f594d82b8d7d489c1c58bcf4123e4b5", "filename": "src/test/bench/rt-messaging-ping-pong.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-messaging-ping-pong.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -32,25 +32,23 @@ fn ping_pong_bench(n: uint, m: uint) {\n     // Create pairs of tasks that pingpong back and forth.\n     fn run_pair(n: uint) {\n         // Create a stream A->B\n-        let (pa,ca) = Chan::<()>::new();\n+        let (atx, arx) = channel::<()>();\n         // Create a stream B->A\n-        let (pb,cb) = Chan::<()>::new();\n+        let (btx, brx) = channel::<()>();\n \n         spawn(proc() {\n-            let chan = ca;\n-            let port = pb;\n+            let (tx, rx) = (atx, brx);\n             for _ in range(0, n) {\n-                chan.send(());\n-                port.recv();\n+                tx.send(());\n+                rx.recv();\n             }\n         });\n \n         spawn(proc() {\n-            let chan = cb;\n-            let port = pa;\n+            let (tx, rx) = (btx, arx);\n             for _ in range(0, n) {\n-                port.recv();\n-                chan.send(());\n+                rx.recv();\n+                tx.send(());\n             }\n         });\n     }"}, {"sha": "b636554cffb65e85a35c8ba287720768d201d360", "filename": "src/test/bench/rt-parfib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Frt-parfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Frt-parfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Frt-parfib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -22,12 +22,12 @@ fn parfib(n: uint) -> uint {\n         return 1;\n     }\n \n-    let (port,chan) = Chan::new();\n+    let (tx, rx) = channel();\n     spawn(proc() {\n-        chan.send(parfib(n-1));\n+        tx.send(parfib(n-1));\n     });\n     let m2 = parfib(n-2);\n-    return (port.recv() + m2);\n+    return (rx.recv() + m2);\n }\n \n fn main() {"}, {"sha": "0dead2ca376ef2de7d5a1bd1fc01438373cfb030", "filename": "src/test/bench/shootout-chameneos-redux.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-chameneos-redux.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -99,9 +99,9 @@ fn transform(aa: color, bb: color) -> color {\n fn creature(\n     name: uint,\n     color: color,\n-    from_rendezvous: Port<Option<CreatureInfo>>,\n-    to_rendezvous: Chan<CreatureInfo>,\n-    to_rendezvous_log: Chan<~str>\n+    from_rendezvous: Receiver<Option<CreatureInfo>>,\n+    to_rendezvous: Sender<CreatureInfo>,\n+    to_rendezvous_log: Sender<~str>\n ) {\n     let mut color = color;\n     let mut creatures_met = 0;\n@@ -137,21 +137,21 @@ fn creature(\n fn rendezvous(nn: uint, set: ~[color]) {\n \n     // these ports will allow us to hear from the creatures\n-    let (from_creatures, to_rendezvous) = Chan::<CreatureInfo>::new();\n-    let (from_creatures_log, to_rendezvous_log) = Chan::<~str>::new();\n+    let (to_rendezvous, from_creatures) = channel::<CreatureInfo>();\n+    let (to_rendezvous_log, from_creatures_log) = channel::<~str>();\n \n     // these channels will be passed to the creatures so they can talk to us\n \n     // these channels will allow us to talk to each creature by 'name'/index\n-    let to_creature: ~[Chan<Option<CreatureInfo>>] =\n+    let to_creature: ~[Sender<Option<CreatureInfo>>] =\n         set.iter().enumerate().map(|(ii, col)| {\n             // create each creature as a listener with a port, and\n             // give us a channel to talk to each\n             let ii = ii;\n             let col = *col;\n             let to_rendezvous = to_rendezvous.clone();\n             let to_rendezvous_log = to_rendezvous_log.clone();\n-            let (from_rendezvous, to_creature) = Chan::new();\n+            let (to_creature, from_rendezvous) = channel();\n             task::spawn(proc() {\n                 creature(ii,\n                          col,"}, {"sha": "dc24e2cf64bca43f68f99095afc3eeab0b3b703d", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -111,8 +111,8 @@ fn windows_with_carry(bb: &[u8], nn: uint, it: |window: &[u8]|) -> ~[u8] {\n }\n \n fn make_sequence_processor(sz: uint,\n-                           from_parent: &Port<~[u8]>,\n-                           to_parent: &Chan<~str>) {\n+                           from_parent: &Receiver<~[u8]>,\n+                           to_parent: &Sender<~str>) {\n    let mut freqs: HashMap<~[u8], uint> = HashMap::new();\n    let mut carry: ~[u8] = ~[];\n    let mut total: uint = 0u;\n@@ -158,23 +158,23 @@ fn main() {\n \n     // initialize each sequence sorter\n     let sizes = ~[1u,2,3,4,6,12,18];\n-    let mut streams = vec::from_fn(sizes.len(), |_| Some(Chan::<~str>::new()));\n+    let mut streams = vec::from_fn(sizes.len(), |_| Some(channel::<~str>()));\n     let mut from_child = ~[];\n-    let to_child   = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n+    let to_child  = sizes.iter().zip(streams.mut_iter()).map(|(sz, stream_ref)| {\n         let sz = *sz;\n         let stream = replace(stream_ref, None);\n-        let (from_child_, to_parent_) = stream.unwrap();\n+        let (to_parent_, from_child_) = stream.unwrap();\n \n         from_child.push(from_child_);\n \n-        let (from_parent, to_child) = Chan::new();\n+        let (to_child, from_parent) = channel();\n \n         spawn(proc() {\n             make_sequence_processor(sz, &from_parent, &to_parent_);\n         });\n \n         to_child\n-    }).collect::<~[Chan<~[u8]>]>();\n+    }).collect::<~[Sender<~[u8]>]>();\n \n \n    // latch stores true after we've started"}, {"sha": "318bd16a8b22177ed79ed17d3ef0ce4f7498e063", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -27,24 +27,24 @@ use std::task;\n use std::uint;\n \n fn fib(n: int) -> int {\n-    fn pfib(c: &Chan<int>, n: int) {\n+    fn pfib(tx: &Sender<int>, n: int) {\n         if n == 0 {\n-            c.send(0);\n+            tx.send(0);\n         } else if n <= 2 {\n-            c.send(1);\n+            tx.send(1);\n         } else {\n-            let (pp, cc) = Chan::new();\n-            let ch = cc.clone();\n-            task::spawn(proc() pfib(&ch, n - 1));\n-            let ch = cc.clone();\n-            task::spawn(proc() pfib(&ch, n - 2));\n-            c.send(pp.recv() + pp.recv());\n+            let (tx1, rx) = channel();\n+            let tx2 = tx1.clone();\n+            task::spawn(proc() pfib(&tx2, n - 1));\n+            let tx2 = tx1.clone();\n+            task::spawn(proc() pfib(&tx2, n - 2));\n+            tx.send(rx.recv() + rx.recv());\n         }\n     }\n \n-    let (p, ch) = Chan::new();\n-    let _t = task::spawn(proc() pfib(&ch, n) );\n-    p.recv()\n+    let (tx, rx) = channel();\n+    spawn(proc() pfib(&tx, n) );\n+    rx.recv()\n }\n \n struct Config {"}, {"sha": "87b58023c6977cfd92f83241a31323386b7435ab", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -35,27 +35,27 @@ fn mult(v: RWArc<~[f64]>, out: RWArc<~[f64]>, f: fn(&~[f64], uint) -> f64) {\n     // tasks.  To do that, we give to each tasks a wait_chan that we\n     // drop at the end of the work.  At the end of this function, we\n     // wait until the channel hang up.\n-    let (wait_port, wait_chan) = Chan::new();\n+    let (tx, rx) = channel();\n \n     let len = out.read(|out| out.len());\n     let chunk = len / 100 + 1;\n     for chk in count(0, chunk) {\n         if chk >= len {break;}\n-        let w = wait_chan.clone();\n+        let tx = tx.clone();\n         let v = v.clone();\n         let out = out.clone();\n         spawn(proc() {\n             for i in range(chk, min(len, chk + chunk)) {\n                 let val = v.read(|v| f(v, i));\n                 out.write(|out| out[i] = val);\n             }\n-            drop(w)\n+            drop(tx)\n         });\n     }\n \n     // wait until the channel hang up (every task finished)\n-    drop(wait_chan);\n-    for () in wait_port.iter() {}\n+    drop(tx);\n+    for () in rx.iter() {}\n }\n \n fn mult_Av_impl(v: &~[f64], i: uint) -> f64 {"}, {"sha": "839ffe99e164995eaef4e7930fa03f547585da25", "filename": "src/test/bench/shootout-threadring.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Fshootout-threadring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-threadring.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -13,30 +13,27 @@\n use std::os;\n \n fn start(n_tasks: int, token: int) {\n-    let (p, ch1) = Chan::new();\n-    let mut p = p;\n-    let ch1 = ch1;\n-    ch1.send(token);\n+    let (tx, mut rx) = channel();\n+    tx.send(token);\n     //  XXX could not get this to work with a range closure\n     let mut i = 2;\n     while i <= n_tasks {\n-        let (next_p, ch) = Chan::new();\n+        let (tx, next_rx) = channel();\n         let imm_i = i;\n-        let imm_p = p;\n+        let imm_rx = rx;\n         spawn(proc() {\n-            roundtrip(imm_i, n_tasks, &imm_p, &ch);\n+            roundtrip(imm_i, n_tasks, &imm_rx, &tx);\n         });\n-        p = next_p;\n+        rx = next_rx;\n         i += 1;\n     }\n-    let imm_p = p;\n-    let imm_ch = ch1;\n+    let imm_rx = rx;\n     spawn(proc() {\n-        roundtrip(1, n_tasks, &imm_p, &imm_ch);\n+        roundtrip(1, n_tasks, &imm_rx, &tx);\n     });\n }\n \n-fn roundtrip(id: int, n_tasks: int, p: &Port<int>, ch: &Chan<int>) {\n+fn roundtrip(id: int, n_tasks: int, p: &Receiver<int>, ch: &Sender<int>) {\n     loop {\n         match p.recv() {\n           1 => {"}, {"sha": "0bad9b507f9d50e681ed2f19385ef655623ff821", "filename": "src/test/bench/task-perf-jargon-metal-smoke.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-jargon-metal-smoke.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -22,7 +22,7 @@ use std::os;\n use std::task;\n use std::uint;\n \n-fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n+fn child_generation(gens_left: uint, tx: comm::Sender<()>) {\n     // This used to be O(n^2) in the number of generations that ever existed.\n     // With this code, only as many generations are alive at a time as tasks\n     // alive at a time,\n@@ -31,9 +31,9 @@ fn child_generation(gens_left: uint, c: comm::Chan<()>) {\n             task::deschedule(); // shake things up a bit\n         }\n         if gens_left > 0 {\n-            child_generation(gens_left - 1, c); // recurse\n+            child_generation(gens_left - 1, tx); // recurse\n         } else {\n-            c.send(())\n+            tx.send(())\n         }\n     });\n }\n@@ -48,9 +48,9 @@ fn main() {\n         args.clone()\n     };\n \n-    let (p,c) = Chan::new();\n-    child_generation(from_str::<uint>(args[1]).unwrap(), c);\n-    if p.recv_opt().is_none() {\n+    let (tx, rx) = channel();\n+    child_generation(from_str::<uint>(args[1]).unwrap(), tx);\n+    if rx.recv_opt().is_none() {\n         fail!(\"it happened when we slumbered\");\n     }\n }"}, {"sha": "ff70dac2dde8cfd3e1bec2622995c2037b259f14", "filename": "src/test/bench/task-perf-one-million.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-one-million.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -17,24 +17,24 @@ use std::task;\n use std::uint;\n use std::vec;\n \n-fn calc(children: uint, parent_wait_chan: &Chan<Chan<Chan<int>>>) {\n+fn calc(children: uint, parent_wait_chan: &Sender<Sender<Sender<int>>>) {\n \n-    let wait_ports: ~[Port<Chan<Chan<int>>>] = vec::from_fn(children, |_| {\n-        let (wait_port, wait_chan) = stream::<Chan<Chan<int>>>();\n+    let wait_ports: ~[Receiver<Sender<Sender<int>>>] = vec::from_fn(children, |_| {\n+        let (wait_port, wait_chan) = stream::<Sender<Sender<int>>>();\n         task::spawn(proc() {\n             calc(children / 2, &wait_chan);\n         });\n         wait_port\n     });\n \n-    let child_start_chans: ~[Chan<Chan<int>>] =\n+    let child_start_chans: ~[Sender<Sender<int>>] =\n         wait_ports.move_iter().map(|port| port.recv()).collect();\n \n-    let (start_port, start_chan) = stream::<Chan<int>>();\n+    let (start_port, start_chan) = stream::<Sender<int>>();\n     parent_wait_chan.send(start_chan);\n-    let parent_result_chan: Chan<int> = start_port.recv();\n+    let parent_result_chan: Sender<int> = start_port.recv();\n \n-    let child_sum_ports: ~[Port<int>] =\n+    let child_sum_ports: ~[Receiver<int>] =\n         child_start_chans.move_iter().map(|child_start_chan| {\n             let (child_sum_port, child_sum_chan) = stream::<int>();\n             child_start_chan.send(child_sum_chan);"}, {"sha": "5602aff5cadcfd1b7441dd25b1cc9c8361b5b008", "filename": "src/test/compile-fail/bind-by-move-no-guards.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbind-by-move-no-guards.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -9,9 +9,9 @@\n // except according to those terms.\n \n fn main() {\n-    let (p,c) = Chan::new();\n-    let x = Some(p);\n-    c.send(false);\n+    let (tx, rx) = channel();\n+    let x = Some(rx);\n+    tx.send(false);\n     match x {\n         Some(z) if z.recv() => { fail!() }, //~ ERROR cannot bind by-move into a pattern guard\n         Some(z) => { assert!(!z.recv()); },"}, {"sha": "974fe3bc5d553f483de117e86c3074a6a2529f82", "filename": "src/test/compile-fail/borrowck-borrow-overloaded-deref-mut.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-overloaded-deref-mut.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -65,4 +65,4 @@ fn assign3<'a>(x: &'a mut Own<int>) {\n     **x = 3;\n }\n \n-pub fn main() {}\n\\ No newline at end of file\n+pub fn main() {}"}, {"sha": "074c5d7bb761a06fa7ca5a7c0e11ca68f0f1a0aa", "filename": "src/test/compile-fail/builtin-superkinds-self-type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbuiltin-superkinds-self-type.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -12,15 +12,15 @@\n // to use capabilities granted by builtin kinds as supertraits.\n \n trait Foo : Freeze {\n-    fn foo(self, mut chan: Chan<Self>) {\n+    fn foo(self, mut chan: Sender<Self>) {\n         chan.send(self); //~ ERROR does not fulfill `Send`\n     }\n }\n \n impl <T: Freeze> Foo for T { }\n \n fn main() {\n-    let (p,c) = Chan::new();\n-    1193182.foo(c);\n-    assert!(p.recv() == 1193182);\n+    let (tx, rx) = channel();\n+    1193182.foo(tx);\n+    assert!(rx.recv() == 1193182);\n }"}, {"sha": "b7b87b2826440d03c8111f789c6532b1aab37a9f", "filename": "src/test/compile-fail/comm-not-freeze.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-not-freeze.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,7 +11,7 @@\n fn test<T: Freeze>() {}\n \n fn main() {\n-    test::<Chan<int>>();        //~ ERROR: does not fulfill `Freeze`\n-    test::<Port<int>>();        //~ ERROR: does not fulfill `Freeze`\n-    test::<Chan<int>>();  //~ ERROR: does not fulfill `Freeze`\n+    test::<Sender<int>>();        //~ ERROR: does not fulfill `Freeze`\n+    test::<Receiver<int>>();        //~ ERROR: does not fulfill `Freeze`\n+    test::<Sender<int>>();  //~ ERROR: does not fulfill `Freeze`\n }"}, {"sha": "2a9cadf1f33ae5a85b3f20a179ce48fdad2221d1", "filename": "src/test/compile-fail/issue-10877.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fissue-10877.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Fissue-10877.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10877.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -21,4 +21,4 @@ extern {\n     fn this_is_actually_ok(a: uint);\n     fn and_so_is_this(_: uint);\n }\n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "4fbb4db44796cae1d1786d83175945725941e2d6", "filename": "src/test/compile-fail/unsendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsendable-class.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -27,6 +27,6 @@ fn foo(i:int, j: @~str) -> foo {\n \n fn main() {\n   let cat = ~\"kitty\";\n-  let (_, ch) = Chan::new(); //~ ERROR does not fulfill `Send`\n-  ch.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n+  let (tx, _) = channel(); //~ ERROR does not fulfill `Send`\n+  tx.send(foo(42, @(cat))); //~ ERROR does not fulfill `Send`\n }"}, {"sha": "e2a493e75e45f48c394d395316abc3de9b7ade95", "filename": "src/test/debug-info/simd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fdebug-info%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Fdebug-info%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebug-info%2Fsimd.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -67,4 +67,4 @@ fn main() {\n }\n \n #[inline(never)]\n-fn zzz() { () }\n\\ No newline at end of file\n+fn zzz() { () }"}, {"sha": "92133bd754872eb35cfdd03e96da1a5f26a87787", "filename": "src/test/run-pass/builtin-superkinds-capabilities-transitive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-transitive.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -20,12 +20,12 @@ trait Foo : Bar { }\n impl <T: Send> Foo for T { }\n impl <T: Send> Bar for T { }\n \n-fn foo<T: Foo>(val: T, chan: Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Sender<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n-    foo(31337, c);\n-    assert!(p.recv() == 31337);\n+    let (tx, rx) = channel();\n+    foo(31337, tx);\n+    assert!(rx.recv() == 31337);\n }"}, {"sha": "dc7a0ce4eba7c11f3613c80c9e74d350a4bc7933", "filename": "src/test/run-pass/builtin-superkinds-capabilities-xc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities-xc.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -24,12 +24,12 @@ struct X<T>(T);\n impl <T: Freeze> RequiresFreeze for X<T> { }\n impl <T: Freeze+Send> RequiresRequiresFreezeAndSend for X<T> { }\n \n-fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: Chan<T>) {\n+fn foo<T: RequiresRequiresFreezeAndSend>(val: T, chan: Sender<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n-    foo(X(31337), c);\n-    assert!(p.recv() == X(31337));\n+    let (tx, rx) = channel();\n+    foo(X(31337), tx);\n+    assert!(rx.recv() == X(31337));\n }"}, {"sha": "33e9f57ba962cd586cb1c314a55096f81b1bc837", "filename": "src/test/run-pass/builtin-superkinds-capabilities.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-capabilities.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,12 +16,12 @@ trait Foo : Send { }\n \n impl <T: Send> Foo for T { }\n \n-fn foo<T: Foo>(val: T, chan: Chan<T>) {\n+fn foo<T: Foo>(val: T, chan: Sender<T>) {\n     chan.send(val);\n }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n-    foo(31337, c);\n-    assert!(p.recv() == 31337);\n+    let (tx, rx) = channel();\n+    foo(31337, tx);\n+    assert!(rx.recv() == 31337);\n }"}, {"sha": "d0ccfe0e21d6b90de7e5408b10b462deed6c8962", "filename": "src/test/run-pass/builtin-superkinds-self-type.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbuiltin-superkinds-self-type.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -12,15 +12,15 @@\n // capabilities granted by builtin kinds as supertraits.\n \n trait Foo : Send {\n-    fn foo(self, chan: Chan<Self>) {\n-        chan.send(self);\n+    fn foo(self, tx: Sender<Self>) {\n+        tx.send(self);\n     }\n }\n \n impl <T: Send> Foo for T { }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n-    1193182.foo(c);\n-    assert!(p.recv() == 1193182);\n+    let (tx, rx) = channel();\n+    1193182.foo(tx);\n+    assert!(rx.recv() == 1193182);\n }"}, {"sha": "2113e5d0f4732eec699d0a6f25f651dcfd8a0937", "filename": "src/test/run-pass/capture_nil.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcapture_nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapture_nil.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -26,12 +26,12 @@\n \n use std::task;\n \n-fn foo(x: ()) -> Port<()> {\n-    let (p, c) = Chan::<()>::new();\n+fn foo(x: ()) -> Receiver<()> {\n+    let (tx, rx) = channel::<()>();\n     task::spawn(proc() {\n-        c.send(x);\n+        tx.send(x);\n     });\n-    p\n+    rx\n }\n \n pub fn main() {"}, {"sha": "ae98695cf7500a7815993724fedd4c00824926f6", "filename": "src/test/run-pass/capturing-logging.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcapturing-logging.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,7 +16,7 @@\n extern crate native;\n \n use std::fmt;\n-use std::io::{PortReader, ChanWriter};\n+use std::io::{ChanReader, ChanWriter};\n use std::logging::{set_logger, Logger};\n \n struct MyWriter(ChanWriter);\n@@ -36,8 +36,8 @@ fn start(argc: int, argv: **u8) -> int {\n }\n \n fn main() {\n-    let (p, c) = Chan::new();\n-    let (mut r, w) = (PortReader::new(p), ChanWriter::new(c));\n+    let (tx, rx) = channel();\n+    let (mut r, w) = (ChanReader::new(rx), ChanWriter::new(tx));\n     spawn(proc() {\n         set_logger(~MyWriter(w) as ~Logger);\n         debug!(\"debug\");"}, {"sha": "3c4b7236ad50fd61898b0fa7a275db9d11433214", "filename": "src/test/run-pass/closure-bounds-can-capture-chan.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-bounds-can-capture-chan.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,9 +15,9 @@ fn foo(blk: proc()) {\n }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n+    let (tx, rx) = channel();\n     foo(proc() {\n-        c.send(());\n+        tx.send(());\n     });\n-    p.recv();\n+    rx.recv();\n }"}, {"sha": "ad6c92c4925fb21e1d7b0d55c05a56ae0ec2b19c", "filename": "src/test/run-pass/comm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,15 +11,15 @@\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = Chan::new();\n-    let _t = task::spawn(proc() { child(&ch) });\n-    let y = p.recv();\n+    let (tx, rx) = channel();\n+    let _t = task::spawn(proc() { child(&tx) });\n+    let y = rx.recv();\n     error!(\"received\");\n     error!(\"{:?}\", y);\n     assert_eq!(y, 10);\n }\n \n-fn child(c: &Chan<int>) {\n+fn child(c: &Sender<int>) {\n     error!(\"sending\");\n     c.send(10);\n     error!(\"value sent\");"}, {"sha": "fe27eca773037a58a3e6955ba8149000e2214f26", "filename": "src/test/run-pass/hashmap-memory.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhashmap-memory.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -31,30 +31,30 @@ mod map_reduce {\n \n     pub type mapper = extern fn(~str, putter);\n \n-    enum ctrl_proto { find_reducer(~[u8], Chan<int>), mapper_done, }\n+    enum ctrl_proto { find_reducer(~[u8], Sender<int>), mapper_done, }\n \n-    fn start_mappers(ctrl: Chan<ctrl_proto>, inputs: ~[~str]) {\n+    fn start_mappers(ctrl: Sender<ctrl_proto>, inputs: ~[~str]) {\n         for i in inputs.iter() {\n             let ctrl = ctrl.clone();\n             let i = i.clone();\n             task::spawn(proc() map_task(ctrl.clone(), i.clone()) );\n         }\n     }\n \n-    fn map_task(ctrl: Chan<ctrl_proto>, input: ~str) {\n+    fn map_task(ctrl: Sender<ctrl_proto>, input: ~str) {\n         let mut intermediates = HashMap::new();\n \n         fn emit(im: &mut HashMap<~str, int>,\n-                ctrl: Chan<ctrl_proto>, key: ~str,\n+                ctrl: Sender<ctrl_proto>, key: ~str,\n                 _val: ~str) {\n             if im.contains_key(&key) {\n                 return;\n             }\n-            let (pp, cc) = Chan::new();\n+            let (tx, rx) = channel();\n             error!(\"sending find_reducer\");\n-            ctrl.send(find_reducer(key.as_bytes().to_owned(), cc));\n+            ctrl.send(find_reducer(key.as_bytes().to_owned(), tx));\n             error!(\"receiving\");\n-            let c = pp.recv();\n+            let c = rx.recv();\n             error!(\"{:?}\", c);\n             im.insert(key, c);\n         }\n@@ -65,7 +65,7 @@ mod map_reduce {\n     }\n \n     pub fn map_reduce(inputs: ~[~str]) {\n-        let (ctrl_port, ctrl_chan) = Chan::new();\n+        let (tx, rx) = channel();\n \n         // This task becomes the master control task. It spawns others\n         // to do the rest.\n@@ -74,12 +74,12 @@ mod map_reduce {\n \n         reducers = HashMap::new();\n \n-        start_mappers(ctrl_chan, inputs.clone());\n+        start_mappers(tx, inputs.clone());\n \n         let mut num_mappers = inputs.len() as int;\n \n         while num_mappers > 0 {\n-            match ctrl_port.recv() {\n+            match rx.recv() {\n               mapper_done => { num_mappers -= 1; }\n               find_reducer(k, cc) => {\n                 let mut c;"}, {"sha": "611af3cb36d02aa37e90693dd42e2f1cd63b25a0", "filename": "src/test/run-pass/issue-3609.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-3609.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3609.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -10,7 +10,6 @@\n \n extern crate extra;\n \n-use std::comm::Chan;\n use std::task;\n \n type RingBuffer = ~[f64];\n@@ -21,7 +20,7 @@ enum Msg\n     GetSamples(~str, SamplesFn), // sample set name, callback which receives samples\n }\n \n-fn foo(name: ~str, samples_chan: Chan<Msg>) {\n+fn foo(name: ~str, samples_chan: Sender<Msg>) {\n     task::spawn(proc() {\n         let mut samples_chan = samples_chan;\n         let callback: SamplesFn = proc(buffer) {"}, {"sha": "f74c30687ca8a0ddb22f039537e2d02e518ccc59", "filename": "src/test/run-pass/issue-4446.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-4446.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4446.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,11 +11,11 @@\n use std::io::println;\n \n pub fn main() {\n-    let (port, chan) = Chan::new();\n+    let (tx, rx) = channel();\n \n     spawn(proc() {\n-        println(port.recv());\n+        println(rx.recv());\n     });\n \n-    chan.send(\"hello, world\");\n+    tx.send(\"hello, world\");\n }"}, {"sha": "dda90ef1a0fbd0b8bf7463a60ee5047fc7cd50c7", "filename": "src/test/run-pass/issue-4448.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-4448.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4448.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,11 +11,11 @@\n use std::task;\n \n pub fn main() {\n-    let (port, chan) = Chan::<&'static str>::new();\n+    let (tx, rx) = channel::<&'static str>();\n \n     task::spawn(proc() {\n-        assert_eq!(port.recv(), \"hello, world\");\n+        assert_eq!(rx.recv(), \"hello, world\");\n     });\n \n-    chan.send(\"hello, world\");\n+    tx.send(\"hello, world\");\n }"}, {"sha": "2630057c988a064753db66c087cf5902f673f2ee", "filename": "src/test/run-pass/issue-9396.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fissue-9396.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-9396.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -12,14 +12,14 @@ use std::comm;\n use std::io::timer::Timer;\n \n pub fn main() {\n-    let (port, chan) = Chan::new();\n+    let (tx, rx) = channel();\n     spawn(proc (){\n         let mut timer = Timer::new().unwrap();\n         timer.sleep(10);\n-        chan.send(());\n+        tx.send(());\n     });\n     loop {\n-        match port.try_recv() {\n+        match rx.try_recv() {\n             comm::Data(()) => break,\n             comm::Empty => {}\n             comm::Disconnected => unreachable!()"}, {"sha": "bbfd136464abbd5e51600b74326d9aa31043a656", "filename": "src/test/run-pass/ivec-tag.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fivec-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fivec-tag.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -10,17 +10,17 @@\n \n use std::task;\n \n-fn producer(c: &Chan<~[u8]>) {\n-    c.send(\n+fn producer(tx: &Sender<~[u8]>) {\n+    tx.send(\n          ~[1u8, 2u8, 3u8, 4u8, 5u8, 6u8, 7u8, 8u8, 9u8, 10u8, 11u8, 12u8,\n           13u8]);\n }\n \n pub fn main() {\n-    let (p, ch) = Chan::<~[u8]>::new();\n+    let (tx, rx) = channel::<~[u8]>();\n     let _prod = task::spawn(proc() {\n-        producer(&ch)\n+        producer(&tx)\n     });\n \n-    let _data: ~[u8] = p.recv();\n+    let _data: ~[u8] = rx.recv();\n }"}, {"sha": "4913df823b4df0e6fc90d23c00c72eb990b476e8", "filename": "src/test/run-pass/logging-only-prints-once.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flogging-only-prints-once.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -26,13 +26,13 @@ impl fmt::Show for Foo {\n }\n \n pub fn main() {\n-    let (p,c) = Chan::new();\n+    let (tx, rx) = channel();\n     spawn(proc() {\n         let mut f = Foo(Cell::new(0));\n         debug!(\"{}\", f);\n         let Foo(ref mut f) = f;\n         assert!(f.get() == 1);\n-        c.send(());\n+        tx.send(());\n     });\n-    p.recv();\n+    rx.recv();\n }"}, {"sha": "64dfd3fdefc262b09e7398cbabf54e397078c489", "filename": "src/test/run-pass/preempt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -17,7 +17,7 @@ extern crate extra;\n use std::comm;\n use extra::comm;\n \n-fn starve_main(alive: Port<int>) {\n+fn starve_main(alive: Receiver<int>) {\n     info!(\"signalling main\");\n     alive.recv();\n     info!(\"starving main\");"}, {"sha": "e368116f26c3afcaf32a017478bcfff7c9ce4206", "filename": "src/test/run-pass/send-resource.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsend-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-resource.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -25,14 +25,14 @@ fn test(f: int) -> test {\n }\n \n pub fn main() {\n-    let (p, c) = Chan::new();\n+    let (tx, rx) = channel();\n \n     task::spawn(proc() {\n-        let (pp, cc) = Chan::new();\n-        c.send(cc);\n+        let (tx2, rx2) = channel();\n+        tx.send(tx2);\n \n-        let _r = pp.recv();\n+        let _r = rx2.recv();\n     });\n \n-    p.recv().send(test(42));\n+    rx.recv().send(test(42));\n }"}, {"sha": "508bd99d77d7c962fef69e236f52464716274254", "filename": "src/test/run-pass/send-type-inference.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsend-type-inference.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,8 +14,8 @@ struct Command<K, V> {\n     val: V\n }\n \n-fn cache_server<K:Send,V:Send>(mut c: Chan<Chan<Command<K, V>>>) {\n-    let (_ctrl_port, ctrl_chan) = Chan::new();\n-    c.send(ctrl_chan);\n+fn cache_server<K:Send,V:Send>(mut tx: Sender<Sender<Command<K, V>>>) {\n+    let (tx1, _rx) = channel();\n+    tx.send(tx1);\n }\n pub fn main() { }"}, {"sha": "007a83d2c88782dd921c27a93e1a3f2168d8cdb1", "filename": "src/test/run-pass/sendable-class.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fsendable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsendable-class.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -23,6 +23,6 @@ fn foo(i:int, j: char) -> foo {\n }\n \n pub fn main() {\n-    let (_po, ch) = Chan::new();\n-    ch.send(foo(42, 'c'));\n+    let (tx, rx) = channel();\n+    tx.send(foo(42, 'c'));\n }"}, {"sha": "52921244ddc91805e0fdecb837c68139836493ae", "filename": "src/test/run-pass/spawn-types.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Fspawn-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-types.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,13 +16,13 @@\n \n use std::task;\n \n-type ctx = Chan<int>;\n+type ctx = Sender<int>;\n \n-fn iotask(_cx: &ctx, ip: ~str) {\n+fn iotask(_tx: &ctx, ip: ~str) {\n     assert_eq!(ip, ~\"localhost\");\n }\n \n pub fn main() {\n-    let (_p, ch) = Chan::<int>::new();\n-    task::spawn(proc() iotask(&ch, ~\"localhost\") );\n+    let (tx, _rx) = channel::<int>();\n+    task::spawn(proc() iotask(&tx, ~\"localhost\") );\n }"}, {"sha": "9e5c6ba8e970b3883d2adc84410ae96e60976147", "filename": "src/test/run-pass/task-comm-0.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-0.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,23 +16,23 @@ use std::task;\n \n pub fn main() { test05(); }\n \n-fn test05_start(ch : &Chan<int>) {\n-    ch.send(10);\n+fn test05_start(tx : &Sender<int>) {\n+    tx.send(10);\n     error!(\"sent 10\");\n-    ch.send(20);\n+    tx.send(20);\n     error!(\"sent 20\");\n-    ch.send(30);\n+    tx.send(30);\n     error!(\"sent 30\");\n }\n \n fn test05() {\n-    let (po, ch) = Chan::new();\n-    task::spawn(proc() { test05_start(&ch) });\n-    let mut value: int = po.recv();\n+    let (tx, rx) = channel();\n+    task::spawn(proc() { test05_start(&tx) });\n+    let mut value: int = rx.recv();\n     error!(\"{}\", value);\n-    value = po.recv();\n+    value = rx.recv();\n     error!(\"{}\", value);\n-    value = po.recv();\n+    value = rx.recv();\n     error!(\"{}\", value);\n     assert_eq!(value, 30);\n }"}, {"sha": "5ea21422cd027819db6c04b3a092bb0a7d89a9bd", "filename": "src/test/run-pass/task-comm-10.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-10.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,25 +14,25 @@ extern crate extra;\n \n use std::task;\n \n-fn start(c: &Chan<Chan<~str>>) {\n-    let (p, ch) = Chan::new();\n-    c.send(ch);\n+fn start(tx: &Sender<Sender<~str>>) {\n+    let (tx2, rx) = channel();\n+    tx.send(tx2);\n \n     let mut a;\n     let mut b;\n-    a = p.recv();\n+    a = rx.recv();\n     assert!(a == ~\"A\");\n     error!(\"{:?}\", a);\n-    b = p.recv();\n+    b = rx.recv();\n     assert!(b == ~\"B\");\n     error!(\"{:?}\", b);\n }\n \n pub fn main() {\n-    let (p, ch) = Chan::new();\n-    let _child = task::spawn(proc() { start(&ch) });\n+    let (tx, rx) = channel();\n+    let _child = task::spawn(proc() { start(&tx) });\n \n-    let mut c = p.recv();\n+    let mut c = rx.recv();\n     c.send(~\"A\");\n     c.send(~\"B\");\n     task::deschedule();"}, {"sha": "d39d688a478c16e882413fb256f93c50b53cbaf2", "filename": "src/test/run-pass/task-comm-11.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-11.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,15 +14,15 @@ extern crate extra;\n \n use std::task;\n \n-fn start(c: &Chan<Chan<int>>) {\n-    let (_p, ch) = Chan::new();\n-    c.send(ch);\n+fn start(tx: &Sender<Sender<int>>) {\n+    let (tx2, _rx) = channel();\n+    tx.send(tx2);\n }\n \n pub fn main() {\n-    let (mut p, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let _child = task::spawn(proc() {\n-        start(&ch)\n+        start(&tx)\n     });\n-    let _c = p.recv();\n+    let _tx = rx.recv();\n }"}, {"sha": "bad03e8792efe34b4e9adbbbf6aa459829747b7d", "filename": "src/test/run-pass/task-comm-13.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-13.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,14 +14,14 @@ extern crate extra;\n \n use std::task;\n \n-fn start(c: &Chan<int>, start: int, number_of_messages: int) {\n+fn start(tx: &Sender<int>, start: int, number_of_messages: int) {\n     let mut i: int = 0;\n-    while i < number_of_messages { c.send(start + i); i += 1; }\n+    while i < number_of_messages { tx.send(start + i); i += 1; }\n }\n \n pub fn main() {\n     info!(\"Check that we don't deadlock.\");\n-    let (_p, ch) = Chan::new();\n-    task::try(proc() { start(&ch, 0, 10) });\n+    let (tx, rx) = channel();\n+    task::try(proc() { start(&tx, 0, 10) });\n     info!(\"Joined task\");\n }"}, {"sha": "799ee6093008bed925e8e3751f1f71c3752cf1d0", "filename": "src/test/run-pass/task-comm-14.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-14.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -13,14 +13,14 @@\n use std::task;\n \n pub fn main() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n \n     // Spawn 10 tasks each sending us back one int.\n     let mut i = 10;\n     while (i > 0) {\n         info!(\"{}\", i);\n-        let ch = ch.clone();\n-        task::spawn({let i = i; proc() { child(i, &ch) }});\n+        let tx = tx.clone();\n+        task::spawn({let i = i; proc() { child(i, &tx) }});\n         i = i - 1;\n     }\n \n@@ -30,14 +30,14 @@ pub fn main() {\n     i = 10;\n     while (i > 0) {\n         info!(\"{}\", i);\n-        po.recv();\n+        rx.recv();\n         i = i - 1;\n     }\n \n     info!(\"main thread exiting\");\n }\n \n-fn child(x: int, ch: &Chan<int>) {\n+fn child(x: int, tx: &Sender<int>) {\n     info!(\"{}\", x);\n-    ch.send(x);\n+    tx.send(x);\n }"}, {"sha": "6855a32ceb02c5d62a88d5a73ad119ad48ba87d7", "filename": "src/test/run-pass/task-comm-15.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-15.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,10 +14,10 @@ extern crate extra;\n \n use std::task;\n \n-fn start(c: &Chan<int>, i0: int) {\n+fn start(tx: &Sender<int>, i0: int) {\n     let mut i = i0;\n     while i > 0 {\n-        c.send(0);\n+        tx.send(0);\n         i = i - 1;\n     }\n }\n@@ -27,10 +27,9 @@ pub fn main() {\n     // is likely to terminate before the child completes, so from\n     // the child's point of view the receiver may die. We should\n     // drop messages on the floor in this case, and not crash!\n-    let (p, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     task::spawn(proc() {\n-        let mut ch = ch;\n-        start(&ch, 10)\n+        start(&tx, 10)\n     });\n-    p.recv();\n+    rx.recv();\n }"}, {"sha": "43fbfe8535235d7ff68155c2411e6dbdf029098b", "filename": "src/test/run-pass/task-comm-16.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-16.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,31 +14,31 @@ use std::cmp;\n fn test_rec() {\n     struct R {val0: int, val1: u8, val2: char}\n \n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let r0: R = R {val0: 0, val1: 1u8, val2: '2'};\n-    ch.send(r0);\n+    tx.send(r0);\n     let mut r1: R;\n-    r1 = po.recv();\n+    r1 = rx.recv();\n     assert_eq!(r1.val0, 0);\n     assert_eq!(r1.val1, 1u8);\n     assert_eq!(r1.val2, '2');\n }\n \n fn test_vec() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let v0: ~[int] = ~[0, 1, 2];\n-    ch.send(v0);\n-    let v1 = po.recv();\n+    tx.send(v0);\n+    let v1 = rx.recv();\n     assert_eq!(v1[0], 0);\n     assert_eq!(v1[1], 1);\n     assert_eq!(v1[2], 2);\n }\n \n fn test_str() {\n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let s0 = ~\"test\";\n-    ch.send(s0);\n-    let s1 = po.recv();\n+    tx.send(s0);\n+    let s1 = rx.recv();\n     assert_eq!(s1[0], 't' as u8);\n     assert_eq!(s1[1], 'e' as u8);\n     assert_eq!(s1[2], 's' as u8);\n@@ -80,29 +80,29 @@ impl cmp::Eq for t {\n }\n \n fn test_tag() {\n-    let (po, ch) = Chan::new();\n-    ch.send(tag1);\n-    ch.send(tag2(10));\n-    ch.send(tag3(10, 11u8, 'A'));\n+    let (tx, rx) = channel();\n+    tx.send(tag1);\n+    tx.send(tag2(10));\n+    tx.send(tag3(10, 11u8, 'A'));\n     let mut t1: t;\n-    t1 = po.recv();\n+    t1 = rx.recv();\n     assert_eq!(t1, tag1);\n-    t1 = po.recv();\n+    t1 = rx.recv();\n     assert_eq!(t1, tag2(10));\n-    t1 = po.recv();\n+    t1 = rx.recv();\n     assert_eq!(t1, tag3(10, 11u8, 'A'));\n }\n \n fn test_chan() {\n-    let (po, ch) = Chan::new();\n-    let (po0, ch0) = Chan::new();\n-    ch.send(ch0);\n-    let mut ch1 = po.recv();\n+    let (tx1, rx1) = channel();\n+    let (tx2, rx2) = channel();\n+    tx1.send(tx2);\n+    let tx2 = rx1.recv();\n     // Does the transmitted channel still work?\n \n-    ch1.send(10);\n+    tx2.send(10);\n     let mut i: int;\n-    i = po0.recv();\n+    i = rx2.recv();\n     assert_eq!(i, 10);\n }\n "}, {"sha": "c27e199b3778901b73fe3cf41357ec9597b40fce", "filename": "src/test/run-pass/task-comm-3.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-3.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,7 +16,7 @@ use std::task;\n \n pub fn main() { info!(\"===== WITHOUT THREADS =====\"); test00(); }\n \n-fn test00_start(ch: &Chan<int>, message: int, count: int) {\n+fn test00_start(ch: &Sender<int>, message: int, count: int) {\n     info!(\"Starting test00_start\");\n     let mut i: int = 0;\n     while i < count {\n@@ -33,21 +33,20 @@ fn test00() {\n \n     info!(\"Creating tasks\");\n \n-    let (po, ch) = Chan::new();\n+    let (tx, rx) = channel();\n \n     let mut i: int = 0;\n \n     // Create and spawn tasks...\n     let mut results = ~[];\n     while i < number_of_tasks {\n-        let ch = ch.clone();\n+        let tx = tx.clone();\n         let mut builder = task::task();\n         results.push(builder.future_result());\n         builder.spawn({\n-            let ch = ch;\n             let i = i;\n             proc() {\n-                test00_start(&ch, i, number_of_messages)\n+                test00_start(&tx, i, number_of_messages)\n             }\n         });\n         i = i + 1;\n@@ -58,7 +57,7 @@ fn test00() {\n     for _r in results.iter() {\n         i = 0;\n         while i < number_of_messages {\n-            let value = po.recv();\n+            let value = rx.recv();\n             sum += value;\n             i = i + 1;\n         }"}, {"sha": "411730dac7859fae7f9ca3fe3d3752486b448157", "filename": "src/test/run-pass/task-comm-4.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-4.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,37 +15,37 @@ pub fn main() { test00(); }\n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = Chan::new();\n-    c.send(1);\n-    c.send(2);\n-    c.send(3);\n-    c.send(4);\n-    r = p.recv();\n+    let (tx, rx) = channel();\n+    tx.send(1);\n+    tx.send(2);\n+    tx.send(3);\n+    tx.send(4);\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    c.send(5);\n-    c.send(6);\n-    c.send(7);\n-    c.send(8);\n-    r = p.recv();\n+    tx.send(5);\n+    tx.send(6);\n+    tx.send(7);\n+    tx.send(8);\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n-    r = p.recv();\n+    r = rx.recv();\n     sum += r;\n     info!(\"{}\", r);\n     assert_eq!(sum, 1 + 2 + 3 + 4 + 5 + 6 + 7 + 8);"}, {"sha": "64970bcd3feae0d964705a4cc1e6e90d2daf21c7", "filename": "src/test/run-pass/task-comm-5.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-5.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,11 +15,11 @@ pub fn main() { test00(); }\n fn test00() {\n     let _r: int = 0;\n     let mut sum: int = 0;\n-    let (p, c) = Chan::new();\n+    let (tx, rx) = channel();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n-    while i < number_of_messages { c.send(i + 0); i += 1; }\n+    while i < number_of_messages { tx.send(i + 0); i += 1; }\n     i = 0;\n-    while i < number_of_messages { sum += p.recv(); i += 1; }\n+    while i < number_of_messages { sum += rx.recv(); i += 1; }\n     assert_eq!(sum, number_of_messages * (number_of_messages - 1) / 2);\n }"}, {"sha": "4db258561162dbcf5dfdea9bf088ab813157d434", "filename": "src/test/run-pass/task-comm-6.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-6.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,29 +15,29 @@ pub fn main() { test00(); }\n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = Chan::new();\n-    let mut c0 = ch.clone();\n-    let mut c1 = ch.clone();\n-    let mut c2 = ch.clone();\n-    let mut c3 = ch.clone();\n+    let (tx, rx) = channel();\n+    let mut tx0 = tx.clone();\n+    let mut tx1 = tx.clone();\n+    let mut tx2 = tx.clone();\n+    let mut tx3 = tx.clone();\n     let number_of_messages: int = 1000;\n     let mut i: int = 0;\n     while i < number_of_messages {\n-        c0.send(i + 0);\n-        c1.send(i + 0);\n-        c2.send(i + 0);\n-        c3.send(i + 0);\n+        tx0.send(i + 0);\n+        tx1.send(i + 0);\n+        tx2.send(i + 0);\n+        tx3.send(i + 0);\n         i += 1;\n     }\n     i = 0;\n     while i < number_of_messages {\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "f61547ff688bae493ccd02071fe19046a4a817f2", "filename": "src/test/run-pass/task-comm-7.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-7.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -18,7 +18,7 @@ use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &Chan<int>, start: int,\n+fn test00_start(c: &Sender<int>, start: int,\n                 number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(start + i); i += 1; }\n@@ -27,35 +27,35 @@ fn test00_start(c: &Chan<int>, start: int,\n fn test00() {\n     let mut r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n-    let c = ch.clone();\n+    let tx2 = tx.clone();\n     task::spawn(proc() {\n-        test00_start(&c, number_of_messages * 0, number_of_messages);\n+        test00_start(&tx2, number_of_messages * 0, number_of_messages);\n     });\n-    let c = ch.clone();\n+    let tx2 = tx.clone();\n     task::spawn(proc() {\n-        test00_start(&c, number_of_messages * 1, number_of_messages);\n+        test00_start(&tx2, number_of_messages * 1, number_of_messages);\n     });\n-    let c = ch.clone();\n+    let tx2 = tx.clone();\n     task::spawn(proc() {\n-        test00_start(&c, number_of_messages * 2, number_of_messages);\n+        test00_start(&tx2, number_of_messages * 2, number_of_messages);\n     });\n-    let c = ch.clone();\n+    let tx2 = tx.clone();\n     task::spawn(proc() {\n-        test00_start(&c, number_of_messages * 3, number_of_messages);\n+        test00_start(&tx2, number_of_messages * 3, number_of_messages);\n     });\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n-        r = p.recv();\n+        r = rx.recv();\n         sum += r;\n         i += 1;\n     }"}, {"sha": "f4fee47fa744de0180a3149ca815e9d04803797d", "filename": "src/test/run-pass/task-comm-9.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-9.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -16,27 +16,26 @@ use std::task;\n \n pub fn main() { test00(); }\n \n-fn test00_start(c: &Chan<int>, number_of_messages: int) {\n+fn test00_start(c: &Sender<int>, number_of_messages: int) {\n     let mut i: int = 0;\n     while i < number_of_messages { c.send(i + 0); i += 1; }\n }\n \n fn test00() {\n     let r: int = 0;\n     let mut sum: int = 0;\n-    let (p, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let number_of_messages: int = 10;\n \n     let mut builder = task::task();\n     let result = builder.future_result();\n     builder.spawn(proc() {\n-        let mut ch = ch;\n-        test00_start(&mut ch, number_of_messages);\n+        test00_start(&tx, number_of_messages);\n     });\n \n     let mut i: int = 0;\n     while i < number_of_messages {\n-        sum += p.recv();\n+        sum += rx.recv();\n         info!(\"{:?}\", r);\n         i += 1;\n     }"}, {"sha": "713105df602c8c80623458b7454e6729bb39f1ac", "filename": "src/test/run-pass/task-comm-chan-nil.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm-chan-nil.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,8 +15,8 @@ extern crate extra;\n // any size, but rustc currently can because they do have size. Whether\n // or not this is desirable I don't know, but here's a regression test.\n pub fn main() {\n-    let (po, ch) = Chan::new();\n-    ch.send(());\n-    let n: () = po.recv();\n+    let (tx, rx) = channel();\n+    tx.send(());\n+    let n: () = rx.recv();\n     assert_eq!(n, ());\n }"}, {"sha": "18d7839652a7c469e1fa0e56217fb555db72af57", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -11,16 +11,16 @@\n use std::task;\n \n pub fn main() {\n-    let (p, ch) = Chan::<uint>::new();\n+    let (tx, rx) = channel::<uint>();\n \n     let x = ~1;\n     let x_in_parent = &(*x) as *int as uint;\n \n     task::spawn(proc() {\n         let x_in_child = &(*x) as *int as uint;\n-        ch.send(x_in_child);\n+        tx.send(x_in_child);\n     });\n \n-    let x_in_child = p.recv();\n+    let x_in_child = rx.recv();\n     assert_eq!(x_in_parent, x_in_child);\n }"}, {"sha": "2f3bbbd744d4b2e524be71fac03cf8e4ca9148f6", "filename": "src/test/run-pass/tempfile.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -38,14 +38,14 @@ fn test_tempdir() {\n }\n \n fn test_rm_tempdir() {\n-    let (rd, wr) = Chan::new();\n+    let (tx, rx) = channel();\n     let f: proc() = proc() {\n         let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        wr.send(tmp.path().clone());\n+        tx.send(tmp.path().clone());\n         fail!(\"fail to unwind past `tmp`\");\n     };\n     task::try(f);\n-    let path = rd.recv();\n+    let path = rx.recv();\n     assert!(!path.exists());\n \n     let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();"}, {"sha": "f157f8ea95c829476e69b1c33c7113134cd3f58d", "filename": "src/test/run-pass/trait-bounds-in-arc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-bounds-in-arc.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -69,18 +69,18 @@ pub fn main() {\n                          ~dogge1 as ~Pet:Freeze+Send,\n                          ~fishe  as ~Pet:Freeze+Send,\n                          ~dogge2 as ~Pet:Freeze+Send]);\n-    let (p1,c1) = Chan::new();\n+    let (tx1, rx1) = channel();\n     let arc1 = arc.clone();\n-    task::spawn(proc() { check_legs(arc1); c1.send(()); });\n-    let (p2,c2) = Chan::new();\n+    task::spawn(proc() { check_legs(arc1); tx1.send(()); });\n+    let (tx2, rx2) = channel();\n     let arc2 = arc.clone();\n-    task::spawn(proc() { check_names(arc2); c2.send(()); });\n-    let (p3,c3) = Chan::new();\n+    task::spawn(proc() { check_names(arc2); tx2.send(()); });\n+    let (tx3, rx3) = channel();\n     let arc3 = arc.clone();\n-    task::spawn(proc() { check_pedigree(arc3); c3.send(()); });\n-    p1.recv();\n-    p2.recv();\n-    p3.recv();\n+    task::spawn(proc() { check_pedigree(arc3); tx3.send(()); });\n+    rx1.recv();\n+    rx2.recv();\n+    rx3.recv();\n }\n \n fn check_legs(arc: Arc<~[~Pet:Freeze+Send]>) {"}, {"sha": "a9e2979f7dbcc04be8ed8f46196894de6c5b6ecf", "filename": "src/test/run-pass/trivial-message.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Ftrivial-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrivial-message.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -14,8 +14,8 @@\n  */\n \n pub fn main() {\n-    let (po, ch) = Chan::new();\n-    ch.send(42);\n-    let r = po.recv();\n+    let (tx, rx) = channel();\n+    tx.send(42);\n+    let r = rx.recv();\n     error!(\"{:?}\", r);\n }"}, {"sha": "eec68dae1082ddb4dde4c3c23afca00ea4d71901", "filename": "src/test/run-pass/unique-send-2.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funique-send-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send-2.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -10,25 +10,25 @@\n \n use std::task;\n \n-fn child(c: &Chan<~uint>, i: uint) {\n-    c.send(~i);\n+fn child(tx: &Sender<~uint>, i: uint) {\n+    tx.send(~i);\n }\n \n pub fn main() {\n-    let (p, ch) = Chan::new();\n+    let (tx, rx) = channel();\n     let n = 100u;\n     let mut expected = 0u;\n     for i in range(0u, n) {\n-        let ch = ch.clone();\n+        let tx = tx.clone();\n         task::spawn(proc() {\n-            child(&ch, i)\n+            child(&tx, i)\n         });\n         expected += i;\n     }\n \n     let mut actual = 0u;\n     for _ in range(0u, n) {\n-        let j = p.recv();\n+        let j = rx.recv();\n         actual += *j;\n     }\n "}, {"sha": "aced7a33da75fc18b3c2d2dbe75736242dc6965e", "filename": "src/test/run-pass/unique-send.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funique-send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funique-send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funique-send.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -9,8 +9,8 @@\n // except according to those terms.\n \n pub fn main() {\n-    let (p, c) = Chan::new();\n-    c.send(~100);\n-    let v = p.recv();\n+    let (tx, rx) = channel();\n+    tx.send(~100);\n+    let v = rx.recv();\n     assert_eq!(v, ~100);\n }"}, {"sha": "30bbca89905f053ec6a3413e01138a940e9bf408", "filename": "src/test/run-pass/unwind-resource.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78580651131c9daacd7e5e4669af819cdd719f09/src%2Ftest%2Frun-pass%2Funwind-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funwind-resource.rs?ref=78580651131c9daacd7e5e4669af819cdd719f09", "patch": "@@ -15,32 +15,32 @@ extern crate extra;\n use std::task;\n \n struct complainer {\n-  c: Chan<bool>,\n+    tx: Sender<bool>,\n }\n \n impl Drop for complainer {\n     fn drop(&mut self) {\n         error!(\"About to send!\");\n-        self.c.send(true);\n+        self.tx.send(true);\n         error!(\"Sent!\");\n     }\n }\n \n-fn complainer(c: Chan<bool>) -> complainer {\n+fn complainer(tx: Sender<bool>) -> complainer {\n     error!(\"Hello!\");\n     complainer {\n-        c: c\n+        tx: tx\n     }\n }\n \n-fn f(c: Chan<bool>) {\n-    let _c = complainer(c);\n+fn f(tx: Sender<bool>) {\n+    let _tx = complainer(tx);\n     fail!();\n }\n \n pub fn main() {\n-    let (p, c) = Chan::new();\n-    task::spawn(proc() f(c.clone()));\n+    let (tx, rx) = channel();\n+    task::spawn(proc() f(tx.clone()));\n     error!(\"hiiiiiiiii\");\n-    assert!(p.recv());\n+    assert!(rx.recv());\n }"}]}