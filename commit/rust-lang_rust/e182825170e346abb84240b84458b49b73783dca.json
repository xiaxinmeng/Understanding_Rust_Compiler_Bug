{"sha": "e182825170e346abb84240b84458b49b73783dca", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxODI4MjUxNzBlMzQ2YWJiODQyNDBiODQ0NThiNDliNzM3ODNkY2E=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-10-14T13:14:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-10-14T13:14:18Z"}, "message": "Merge #2006\n\n2006: Improvements around `Arc<[T]>` r=matklad a=sinkuu\n\nFirst commit tries to avoid cloning `Arc<[T]>` to a temporary `Vec` for mutating it, if there are no other strong references. Second commit utilizes [`FromIterator for Arc<[T]>`](https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-FromIterator%3CT%3E) instead of `.collect::<Vec<_>>().into()` to avoid allocation in `From<Vec<T>> for Arc<[T]>`.\n\nCo-authored-by: Shotaro Yamada <sinkuu@sinkuu.xyz>", "tree": {"sha": "899e18326f89571f835a0d9eb2f42a71f714f2df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/899e18326f89571f835a0d9eb2f42a71f714f2df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e182825170e346abb84240b84458b49b73783dca", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdpHSqCRBK7hj4Ov3rIwAAdHIIAILDkdU7I0lAX6E3BToNuku/\nO1MhTVXfYsjwFQkmzOxtaldfaf9UYHMslGA/oXGirfPpL1ihWXDYHsaothX0Cl3t\nxrXIpRGZIHESUS6LH3ctqQzjlZODCqGezWEd4oIdBxV1k0lbaBsudb2Uf9kKIBjZ\neivJa9CAfJwh5q4h5UeUysyqodWDguNqKIOcIvdGcGw71z7LA4VUsUb4ugyQ4AE2\nXEj520LYhL0PfeSBhOQXCvw1PwG8PNlyXYPVlLzmjZCXrIzzb8SHfNtsHb5rlrDJ\nmytOovgg7r92t4Ve70k7QpY3bJWamiU1Tr3KoYQNYMS+G0nTZHW3kK9e00UyN4I=\n=4Ztl\n-----END PGP SIGNATURE-----\n", "payload": "tree 899e18326f89571f835a0d9eb2f42a71f714f2df\nparent 1f4fbc0035a6a9ee1b599a3aa9f236989633a9f7\nparent 3a55b5bf01ddc581a3f00fa56db725db93a131c6\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1571058858 +0000\ncommitter GitHub <noreply@github.com> 1571058858 +0000\n\nMerge #2006\n\n2006: Improvements around `Arc<[T]>` r=matklad a=sinkuu\n\nFirst commit tries to avoid cloning `Arc<[T]>` to a temporary `Vec` for mutating it, if there are no other strong references. Second commit utilizes [`FromIterator for Arc<[T]>`](https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-FromIterator%3CT%3E) instead of `.collect::<Vec<_>>().into()` to avoid allocation in `From<Vec<T>> for Arc<[T]>`.\n\nCo-authored-by: Shotaro Yamada <sinkuu@sinkuu.xyz>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e182825170e346abb84240b84458b49b73783dca", "html_url": "https://github.com/rust-lang/rust/commit/e182825170e346abb84240b84458b49b73783dca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e182825170e346abb84240b84458b49b73783dca/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4fbc0035a6a9ee1b599a3aa9f236989633a9f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4fbc0035a6a9ee1b599a3aa9f236989633a9f7", "html_url": "https://github.com/rust-lang/rust/commit/1f4fbc0035a6a9ee1b599a3aa9f236989633a9f7"}, {"sha": "3a55b5bf01ddc581a3f00fa56db725db93a131c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a55b5bf01ddc581a3f00fa56db725db93a131c6", "html_url": "https://github.com/rust-lang/rust/commit/3a55b5bf01ddc581a3f00fa56db725db93a131c6"}], "stats": {"total": 99, "additions": 49, "deletions": 50}, "files": [{"sha": "ca261e8f541af71afbb3b7fb8ae57f7a8b27e173", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -51,6 +51,7 @@ mod lang_item;\n mod generics;\n mod resolve;\n pub mod diagnostics;\n+mod util;\n \n mod code_model;\n "}, {"sha": "cc9746f6d752fcbcbc4a1cc53815999c1b2abac6", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -17,8 +17,8 @@ use std::sync::Arc;\n use std::{fmt, iter, mem};\n \n use crate::{\n-    db::HirDatabase, expr::ExprId, type_ref::Mutability, Adt, Crate, DefWithBody, GenericParams,\n-    HasGenericParams, Name, Trait, TypeAlias,\n+    db::HirDatabase, expr::ExprId, type_ref::Mutability, util::make_mut_slice, Adt, Crate,\n+    DefWithBody, GenericParams, HasGenericParams, Name, Trait, TypeAlias,\n };\n use display::{HirDisplay, HirFormatter};\n \n@@ -308,12 +308,9 @@ impl Substs {\n     }\n \n     pub fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        // Without an Arc::make_mut_slice, we can't avoid the clone here:\n-        let mut v: Vec<_> = self.0.iter().cloned().collect();\n-        for t in &mut v {\n+        for t in make_mut_slice(&mut self.0) {\n             t.walk_mut(f);\n         }\n-        self.0 = v.into();\n     }\n \n     pub fn as_single(&self) -> &Ty {\n@@ -330,8 +327,7 @@ impl Substs {\n                 .params_including_parent()\n                 .into_iter()\n                 .map(|p| Ty::Param { idx: p.idx, name: p.name.clone() })\n-                .collect::<Vec<_>>()\n-                .into(),\n+                .collect(),\n         )\n     }\n \n@@ -342,8 +338,7 @@ impl Substs {\n                 .params_including_parent()\n                 .into_iter()\n                 .map(|p| Ty::Bound(p.idx))\n-                .collect::<Vec<_>>()\n-                .into(),\n+                .collect(),\n         )\n     }\n \n@@ -541,12 +536,9 @@ impl TypeWalk for FnSig {\n     }\n \n     fn walk_mut(&mut self, f: &mut impl FnMut(&mut Ty)) {\n-        // Without an Arc::make_mut_slice, we can't avoid the clone here:\n-        let mut v: Vec<_> = self.params_and_return.iter().cloned().collect();\n-        for t in &mut v {\n+        for t in make_mut_slice(&mut self.params_and_return) {\n             t.walk_mut(f);\n         }\n-        self.params_and_return = v.into();\n     }\n }\n \n@@ -756,11 +748,9 @@ impl TypeWalk for Ty {\n                 p_ty.parameters.walk_mut(f);\n             }\n             Ty::Dyn(predicates) | Ty::Opaque(predicates) => {\n-                let mut v: Vec<_> = predicates.iter().cloned().collect();\n-                for p in &mut v {\n+                for p in make_mut_slice(predicates) {\n                     p.walk_mut(f);\n                 }\n-                *predicates = v.into();\n             }\n             Ty::Param { .. } | Ty::Bound(_) | Ty::Infer(_) | Ty::Unknown => {}\n         }"}, {"sha": "014c7981fee609a21d35907f2a0c717960e120aa", "filename": "crates/ra_hir/src/ty/infer/unify.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer%2Funify.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -6,6 +6,7 @@ use crate::ty::{\n     Canonical, InEnvironment, InferTy, ProjectionPredicate, ProjectionTy, Substs, TraitRef, Ty,\n     TypeWalk,\n };\n+use crate::util::make_mut_slice;\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     pub(super) fn canonicalizer<'b>(&'b mut self) -> Canonicalizer<'a, 'b, D>\n@@ -74,10 +75,11 @@ where\n         })\n     }\n \n-    fn do_canonicalize_trait_ref(&mut self, trait_ref: TraitRef) -> TraitRef {\n-        let substs =\n-            trait_ref.substs.iter().map(|ty| self.do_canonicalize_ty(ty.clone())).collect();\n-        TraitRef { trait_: trait_ref.trait_, substs: Substs(substs) }\n+    fn do_canonicalize_trait_ref(&mut self, mut trait_ref: TraitRef) -> TraitRef {\n+        for ty in make_mut_slice(&mut trait_ref.substs.0) {\n+            *ty = self.do_canonicalize_ty(ty.clone());\n+        }\n+        trait_ref\n     }\n \n     fn into_canonicalized<T>(self, result: T) -> Canonicalized<T> {\n@@ -87,10 +89,11 @@ where\n         }\n     }\n \n-    fn do_canonicalize_projection_ty(&mut self, projection_ty: ProjectionTy) -> ProjectionTy {\n-        let params =\n-            projection_ty.parameters.iter().map(|ty| self.do_canonicalize_ty(ty.clone())).collect();\n-        ProjectionTy { associated_ty: projection_ty.associated_ty, parameters: Substs(params) }\n+    fn do_canonicalize_projection_ty(&mut self, mut projection_ty: ProjectionTy) -> ProjectionTy {\n+        for ty in make_mut_slice(&mut projection_ty.parameters.0) {\n+            *ty = self.do_canonicalize_ty(ty.clone());\n+        }\n+        projection_ty\n     }\n \n     fn do_canonicalize_projection_predicate("}, {"sha": "366556134b2a66c4fd318225973cba5b1d063968", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -22,6 +22,7 @@ use crate::{\n     resolve::{Resolver, TypeNs},\n     ty::Adt,\n     type_ref::{TypeBound, TypeRef},\n+    util::make_mut_slice,\n     BuiltinType, Const, Enum, EnumVariant, Function, ModuleDef, Path, Static, Struct, StructField,\n     Trait, TypeAlias, Union,\n };\n@@ -31,11 +32,11 @@ impl Ty {\n         match type_ref {\n             TypeRef::Never => Ty::simple(TypeCtor::Never),\n             TypeRef::Tuple(inner) => {\n-                let inner_tys =\n-                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n+                let inner_tys: Arc<[Ty]> =\n+                    inner.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect();\n                 Ty::apply(\n                     TypeCtor::Tuple { cardinality: inner_tys.len() as u16 },\n-                    Substs(inner_tys.into()),\n+                    Substs(inner_tys),\n                 )\n             }\n             TypeRef::Path(path) => Ty::from_hir_path(db, resolver, path),\n@@ -57,9 +58,7 @@ impl Ty {\n             }\n             TypeRef::Placeholder => Ty::Unknown,\n             TypeRef::Fn(params) => {\n-                let inner_tys =\n-                    params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect::<Vec<_>>();\n-                let sig = Substs(inner_tys.into());\n+                let sig = Substs(params.iter().map(|tr| Ty::from_hir(db, resolver, tr)).collect());\n                 Ty::apply(TypeCtor::FnPtr { num_args: sig.len() as u16 - 1 }, sig)\n             }\n             TypeRef::DynTrait(bounds) => {\n@@ -69,8 +68,8 @@ impl Ty {\n                     .flat_map(|b| {\n                         GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n                     })\n-                    .collect::<Vec<_>>();\n-                Ty::Dyn(predicates.into())\n+                    .collect();\n+                Ty::Dyn(predicates)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 let self_ty = Ty::Bound(0);\n@@ -79,8 +78,8 @@ impl Ty {\n                     .flat_map(|b| {\n                         GenericPredicate::from_type_bound(db, resolver, b, self_ty.clone())\n                     })\n-                    .collect::<Vec<_>>();\n-                Ty::Opaque(predicates.into())\n+                    .collect();\n+                Ty::Opaque(predicates)\n             }\n             TypeRef::Error => Ty::Unknown,\n         }\n@@ -392,10 +391,7 @@ impl TraitRef {\n     ) -> Self {\n         let mut substs = TraitRef::substs_from_path(db, resolver, segment, resolved);\n         if let Some(self_ty) = explicit_self_ty {\n-            // FIXME this could be nicer\n-            let mut substs_vec = substs.0.to_vec();\n-            substs_vec[0] = self_ty;\n-            substs.0 = substs_vec.into();\n+            make_mut_slice(&mut substs.0)[0] = self_ty;\n         }\n         TraitRef { trait_: resolved, substs }\n     }\n@@ -558,13 +554,12 @@ pub(crate) fn generic_predicates_for_param_query(\n     param_idx: u32,\n ) -> Arc<[GenericPredicate]> {\n     let resolver = def.resolver(db);\n-    let predicates = resolver\n+    resolver\n         .where_predicates_in_scope()\n         // we have to filter out all other predicates *first*, before attempting to lower them\n         .filter(|pred| Ty::from_hir_only_param(db, &resolver, &pred.type_ref) == Some(param_idx))\n         .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n-        .collect::<Vec<_>>();\n-    predicates.into()\n+        .collect()\n }\n \n pub(crate) fn trait_env(\n@@ -585,11 +580,10 @@ pub(crate) fn generic_predicates_query(\n     def: GenericDef,\n ) -> Arc<[GenericPredicate]> {\n     let resolver = def.resolver(db);\n-    let predicates = resolver\n+    resolver\n         .where_predicates_in_scope()\n         .flat_map(|pred| GenericPredicate::from_where_predicate(db, &resolver, pred))\n-        .collect::<Vec<_>>();\n-    predicates.into()\n+        .collect()\n }\n \n /// Resolve the default type params from generics\n@@ -603,9 +597,9 @@ pub(crate) fn generic_defaults_query(db: &impl HirDatabase, def: GenericDef) ->\n         .map(|p| {\n             p.default.as_ref().map_or(Ty::Unknown, |path| Ty::from_hir_path(db, &resolver, path))\n         })\n-        .collect::<Vec<_>>();\n+        .collect();\n \n-    Substs(defaults.into())\n+    Substs(defaults)\n }\n \n fn fn_sig_for_fn(db: &impl HirDatabase, def: Function) -> FnSig {"}, {"sha": "0cb5c37984b53f7e4636f08823215207f961a4a7", "filename": "crates/ra_hir/src/ty/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -89,7 +89,7 @@ pub(crate) fn impls_for_trait_query(\n     }\n     let crate_impl_blocks = db.impls_in_crate(krate);\n     impls.extend(crate_impl_blocks.lookup_impl_blocks_for_trait(trait_));\n-    impls.into_iter().collect::<Vec<_>>().into()\n+    impls.into_iter().collect()\n }\n \n /// A set of clauses that we assume to be true. E.g. if we are inside this function:"}, {"sha": "00aaf65d92a6bf5f85c63c80c62abbb56dfbe528", "filename": "crates/ra_hir/src/ty/traits/chalk.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftraits%2Fchalk.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -126,8 +126,7 @@ impl ToChalk for Substs {\n                 chalk_ir::Parameter(chalk_ir::ParameterKind::Ty(ty)) => from_chalk(db, ty),\n                 chalk_ir::Parameter(chalk_ir::ParameterKind::Lifetime(_)) => unimplemented!(),\n             })\n-            .collect::<Vec<_>>()\n-            .into();\n+            .collect();\n         Substs(tys)\n     }\n }"}, {"sha": "0095ee45d3c60fddf8a2db5f7892a4c219cc7e2e", "filename": "crates/ra_hir/src/util.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e182825170e346abb84240b84458b49b73783dca/crates%2Fra_hir%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Futil.rs?ref=e182825170e346abb84240b84458b49b73783dca", "patch": "@@ -0,0 +1,12 @@\n+//! Internal utility functions.\n+\n+use std::sync::Arc;\n+\n+/// Helper for mutating `Arc<[T]>` (i.e. `Arc::make_mut` for Arc slices).\n+/// The underlying values are cloned if there are other strong references.\n+pub(crate) fn make_mut_slice<T: Clone>(a: &mut Arc<[T]>) -> &mut [T] {\n+    if Arc::get_mut(a).is_none() {\n+        *a = a.iter().cloned().collect();\n+    }\n+    Arc::get_mut(a).unwrap()\n+}"}]}