{"sha": "436a24a85dd235743852359b990c66761ff3a4b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzNmEyNGE4NWRkMjM1NzQzODUyMzU5Yjk5MGM2Njc2MWZmM2E0YjE=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-27T14:51:48Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2019-07-27T14:52:00Z"}, "message": "Implement many more float intrinsics", "tree": {"sha": "83c93c13f828f0bb93b0ec2c6ca3b0e9329fbc21", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/83c93c13f828f0bb93b0ec2c6ca3b0e9329fbc21"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/436a24a85dd235743852359b990c66761ff3a4b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/436a24a85dd235743852359b990c66761ff3a4b1", "html_url": "https://github.com/rust-lang/rust/commit/436a24a85dd235743852359b990c66761ff3a4b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/436a24a85dd235743852359b990c66761ff3a4b1/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdf23c02018ec87f30a24dd98c8ad4a8bfbf15dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdf23c02018ec87f30a24dd98c8ad4a8bfbf15dd", "html_url": "https://github.com/rust-lang/rust/commit/bdf23c02018ec87f30a24dd98c8ad4a8bfbf15dd"}], "stats": {"total": 139, "additions": 72, "deletions": 67}, "files": [{"sha": "2a9df999559bfcd2bf2d247242a19a0e7d1e8a35", "filename": "example/std_example.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/436a24a85dd235743852359b990c66761ff3a4b1/example%2Fstd_example.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436a24a85dd235743852359b990c66761ff3a4b1/example%2Fstd_example.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/example%2Fstd_example.rs?ref=436a24a85dd235743852359b990c66761ff3a4b1", "patch": "@@ -30,6 +30,7 @@ fn main() {\n     println!(\"{}\", 2.3f32.ceil());\n     println!(\"{}\", 2.3f32.min(1.0));\n     println!(\"{}\", 2.3f32.max(1.0));\n+    println!(\"{}\", 2.3f32.powi(2));\n \n     assert_eq!(0b0000000000000000000000000010000010000000000000000000000000000000_0000000000100000000000000000000000001000000000000100000000000000u128.leading_zeros(), 26);\n     assert_eq!(0b0000000000000000000000000010000000000000000000000000000000000000_0000000000000000000000000000000000001000000000000000000010000000u128.trailing_zeros(), 7);"}, {"sha": "1f86b096e6309994bec82b5e865186a8264eddfd", "filename": "src/intrinsics.rs", "status": "modified", "additions": 71, "deletions": 67, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/436a24a85dd235743852359b990c66761ff3a4b1/src%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/436a24a85dd235743852359b990c66761ff3a4b1/src%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics.rs?ref=436a24a85dd235743852359b990c66761ff3a4b1", "patch": "@@ -59,6 +59,35 @@ macro_rules! intrinsic_match {\n     };\n }\n \n+macro_rules! call_intrinsic_match {\n+    ($fx:expr, $intrinsic:expr, $substs:expr, $ret:expr, $destination:expr, $args:expr, $(\n+        $name:ident($($arg:ident),*) -> $ty:ident => $func:ident,\n+    )*) => {\n+        match $intrinsic {\n+            $(\n+                stringify!($name) => {\n+                    assert!($substs.is_noop());\n+                    if let [$($arg),*] = *$args {\n+                        let res = $fx.easy_call(stringify!($func), &[$($arg),*], $fx.tcx.types.$ty);\n+                        $ret.write_cvalue($fx, res);\n+\n+                        if let Some((_, dest)) = $destination {\n+                            let ret_ebb = $fx.get_ebb(dest);\n+                            $fx.bcx.ins().jump(ret_ebb, &[]);\n+                            return;\n+                        } else {\n+                            unreachable!();\n+                        }\n+                    } else {\n+                        bug!(\"wrong number of args for intrinsic {:?}\", $intrinsic);\n+                    }\n+                }\n+            )*\n+            _ => {}\n+        }\n+    }\n+}\n+\n macro_rules! atomic_binop_return_old {\n     ($fx:expr, $op:ident<$T:ident>($ptr:ident, $src:ident) -> $ret:ident) => {\n         let clif_ty = $fx.clif_type($T).unwrap();\n@@ -117,6 +146,48 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n     let u64_layout = fx.layout_of(fx.tcx.types.u64);\n     let usize_layout = fx.layout_of(fx.tcx.types.usize);\n \n+    call_intrinsic_match! {\n+        fx, intrinsic, substs, ret, destination, args,\n+        expf32(flt) -> f32 => expf,\n+        expf64(flt) -> f64 => exp,\n+        exp2f32(flt) -> f32 => exp2f,\n+        exp2f64(flt) -> f64 => exp2,\n+        sqrtf32(flt) -> f32 => sqrtf,\n+        sqrtf64(flt) -> f64 => sqrt,\n+        powif32(a, x) -> f32 => __powisf2, // compiler-builtins\n+        powif64(a, x) -> f64 => __powidf2, // compiler-builtins\n+        logf32(flt) -> f32 => logf,\n+        logf64(flt) -> f64 => log,\n+        fabsf32(flt) -> f32 => fabsf,\n+        fabsf64(flt) -> f64 => fabs,\n+        fmaf32(x, y, z) -> f32 => fmaf,\n+        fmaf64(x, y, z) -> f64 => fma,\n+\n+        // rounding variants\n+        floorf32(flt) -> f32 => floorf,\n+        floorf64(flt) -> f64 => floor,\n+        ceilf32(flt) -> f32 => ceilf,\n+        ceilf64(flt) -> f64 => ceil,\n+        truncf32(flt) -> f32 => truncf,\n+        truncf64(flt) -> f64 => trunc,\n+        roundf32(flt) -> f32 => roundf,\n+        roundf64(flt) -> f64 => round,\n+\n+        // trigonometry\n+        sinf32(flt) -> f32 => sinf,\n+        sinf64(flt) -> f64 => sin,\n+        cosf32(flt) -> f32 => cosf,\n+        cosf64(flt) -> f64 => cos,\n+        tanf32(flt) -> f32 => tanf,\n+        tanf64(flt) -> f64 => tan,\n+\n+        // minmax\n+        minnumf32(a, b) -> f32 => fminf,\n+        minnumf64(a, b) -> f64 => fmin,\n+        maxnumf32(a, b) -> f32 => fmaxf,\n+        maxnumf64(a, b) -> f64 => fmax,\n+    }\n+\n     intrinsic_match! {\n         fx, intrinsic, substs, args,\n \n@@ -604,73 +675,6 @@ pub fn codegen_intrinsic_call<'a, 'tcx: 'a>(\n         _ if intrinsic.starts_with(\"atomic_umin\"), <T> (v ptr, v src) {\n             atomic_minmax!(fx, IntCC::UnsignedLessThan, <T> (ptr, src) -> ret);\n         };\n-\n-        expf32, (c flt) {\n-            let res = fx.easy_call(\"expf\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        expf64, (c flt) {\n-            let res = fx.easy_call(\"exp\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        exp2f32, (c flt) {\n-            let res = fx.easy_call(\"exp2f\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        exp2f64, (c flt) {\n-            let res = fx.easy_call(\"exp2\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        fabsf32, (c flt) {\n-            let res = fx.easy_call(\"fabsf\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        fabsf64, (c flt) {\n-            let res = fx.easy_call(\"fabs\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        sqrtf32, (c flt) {\n-            let res = fx.easy_call(\"sqrtf\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        sqrtf64, (c flt) {\n-            let res = fx.easy_call(\"sqrt\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        floorf32, (c flt) {\n-            let res = fx.easy_call(\"floorf\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        floorf64, (c flt) {\n-            let res = fx.easy_call(\"floor\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        ceilf32, (c flt) {\n-            let res = fx.easy_call(\"ceilf\", &[flt], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        ceilf64, (c flt) {\n-            let res = fx.easy_call(\"ceil\", &[flt], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-\n-        minnumf32, (c a, c b) {\n-            let res = fx.easy_call(\"fminf\", &[a, b], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        minnumf64, (c a, c b) {\n-            let res = fx.easy_call(\"fmin\", &[a, b], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-        maxnumf32, (c a, c b) {\n-            let res = fx.easy_call(\"fmaxf\", &[a, b], fx.tcx.types.f32);\n-            ret.write_cvalue(fx, res);\n-        };\n-        maxnumf64, (c a, c b) {\n-            let res = fx.easy_call(\"fmax\", &[a, b], fx.tcx.types.f64);\n-            ret.write_cvalue(fx, res);\n-        };\n-\n     }\n \n     if let Some((_, dest)) = destination {"}]}