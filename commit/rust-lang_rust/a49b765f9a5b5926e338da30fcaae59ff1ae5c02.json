{"sha": "a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0OWI3NjVmOWE1YjU5MjZlMzM4ZGEzMGZjYWFlNTlmZjFhZTVjMDI=", "commit": {"author": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-05-05T07:07:49Z"}, "committer": {"name": "Valerii Hiora", "email": "valerii.hiora@gmail.com", "date": "2014-06-12T18:15:14Z"}, "message": "Basic iOS support", "tree": {"sha": "489f1930d52ae1e9050e840940b3bcb1daedb615", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/489f1930d52ae1e9050e840940b3bcb1daedb615"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "html_url": "https://github.com/rust-lang/rust/commit/a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/comments", "author": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "committer": {"login": "vhbit", "id": 140199, "node_id": "MDQ6VXNlcjE0MDE5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/140199?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vhbit", "html_url": "https://github.com/vhbit", "followers_url": "https://api.github.com/users/vhbit/followers", "following_url": "https://api.github.com/users/vhbit/following{/other_user}", "gists_url": "https://api.github.com/users/vhbit/gists{/gist_id}", "starred_url": "https://api.github.com/users/vhbit/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vhbit/subscriptions", "organizations_url": "https://api.github.com/users/vhbit/orgs", "repos_url": "https://api.github.com/users/vhbit/repos", "events_url": "https://api.github.com/users/vhbit/events{/privacy}", "received_events_url": "https://api.github.com/users/vhbit/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c10c686824bf37084af87af84f338bcd2a7551a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c10c686824bf37084af87af84f338bcd2a7551a", "html_url": "https://github.com/rust-lang/rust/commit/0c10c686824bf37084af87af84f338bcd2a7551a"}], "stats": {"total": 526, "additions": 461, "deletions": 65}, "files": [{"sha": "9ed0d50a03e8aae811dc9384a4d8ed9d906353a8", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -278,10 +278,13 @@ pub use consts::os::extra::{MAP_STACK};\n pub use consts::os::bsd44::{TCP_KEEPIDLE};\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use consts::os::bsd44::{TCP_KEEPALIVE};\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use consts::os::extra::{F_FULLFSYNC};\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n pub use types::os::arch::extra::{mach_timebase_info};\n \n \n@@ -1286,6 +1289,7 @@ pub mod types {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod os {\n         pub mod common {\n             pub mod posix01 {\n@@ -3106,6 +3110,7 @@ pub mod consts {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod os {\n         pub mod c95 {\n             use types::os::arch::c95::{c_int, c_uint};\n@@ -3769,6 +3774,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix88 {\n         pub mod stat_ {\n@@ -3783,6 +3789,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn fstat(fildes: c_int, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -3795,6 +3802,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn stat(path: *c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -3967,6 +3975,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix01 {\n         pub mod stat_ {\n@@ -3977,6 +3986,7 @@ pub mod funcs {\n                 #[cfg(target_os = \"linux\")]\n                 #[cfg(target_os = \"freebsd\")]\n                 #[cfg(target_os = \"android\")]\n+                #[cfg(target_os = \"ios\")]\n                 pub fn lstat(path: *c_char, buf: *mut stat) -> c_int;\n \n                 #[cfg(target_os = \"macos\")]\n@@ -4076,6 +4086,7 @@ pub mod funcs {\n     #[cfg(target_os = \"linux\")]\n     #[cfg(target_os = \"android\")]\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod posix08 {\n         pub mod unistd {\n@@ -4156,6 +4167,7 @@ pub mod funcs {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     pub mod bsd44 {\n         use types::common::c95::{c_void};\n@@ -4209,6 +4221,7 @@ pub mod funcs {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub mod extra {\n         use types::os::arch::c95::{c_char, c_int};\n "}, {"sha": "70fd6310070da0e7cbaa19bd6ad4f3852a96b04f", "filename": "src/libnative/io/c_unix.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fc_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fc_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fc_unix.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -20,6 +20,7 @@ pub use self::signal::{SA_NODEFER, SA_NOCLDWAIT, SA_SIGINFO, SIGCHLD};\n use libc;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static FIONBIO: libc::c_ulong = 0x8004667e;\n #[cfg(target_os = \"linux\", not(target_arch = \"mips\"))]\n@@ -29,6 +30,7 @@ pub static FIONBIO: libc::c_ulong = 0x5421;\n pub static FIONBIO: libc::c_ulong = 0x667e;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static FIOCLEX: libc::c_ulong = 0x20006601;\n #[cfg(target_os = \"linux\", not(target_arch = \"mips\"))]\n@@ -38,6 +40,7 @@ pub static FIOCLEX: libc::c_ulong = 0x5451;\n pub static FIOCLEX: libc::c_ulong = 0x6601;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub static MSG_DONTWAIT: libc::c_int = 0x80;\n #[cfg(target_os = \"linux\")]\n@@ -75,6 +78,7 @@ extern {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n mod select {\n     pub static FD_SETSIZE: uint = 1024;\n \n@@ -187,6 +191,7 @@ mod signal {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n mod signal {\n     use libc;\n@@ -201,6 +206,7 @@ mod signal {\n     pub static SIGCHLD: libc::c_int = 20;\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub type sigset_t = u32;\n     #[cfg(target_os = \"freebsd\")]\n     pub struct sigset_t {\n@@ -219,6 +225,7 @@ mod signal {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     pub struct sigaction {\n         pub sa_handler: extern fn(libc::c_int),\n         sa_tramp: *mut libc::c_void,"}, {"sha": "f521934c0f9654056bba2036940f3e7758a82b44", "filename": "src/libnative/io/file_unix.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Ffile_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Ffile_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ffile_unix.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -133,14 +133,15 @@ impl rtio::RtioFileStream for FileDesc {\n         return super::mkerr_libc(os_datasync(self.fd()));\n \n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"ios\")]\n         fn os_datasync(fd: c_int) -> c_int {\n             unsafe { libc::fcntl(fd, libc::F_FULLFSYNC) }\n         }\n         #[cfg(target_os = \"linux\")]\n         fn os_datasync(fd: c_int) -> c_int {\n             retry(|| unsafe { libc::fdatasync(fd) })\n         }\n-        #[cfg(not(target_os = \"macos\"), not(target_os = \"linux\"))]\n+        #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(target_os = \"linux\"))]\n         fn os_datasync(fd: c_int) -> c_int {\n             retry(|| unsafe { libc::fsync(fd) })\n         }"}, {"sha": "6dc2482ab0c7df9b1e1ff58d0cf3a7eea72778fd", "filename": "src/libnative/io/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fmod.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -50,6 +50,7 @@ pub mod file;\n pub mod file;\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"linux\")]"}, {"sha": "30ea80a1296c7da6efcd237dc0b91561d6422aba", "filename": "src/libnative/io/net.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fnet.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -320,6 +320,7 @@ impl TcpStream {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn set_tcp_keepalive(&mut self, seconds: uint) -> IoResult<()> {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPALIVE,\n                    seconds as libc::c_int)\n@@ -329,7 +330,7 @@ impl TcpStream {\n         setsockopt(self.fd(), libc::IPPROTO_TCP, libc::TCP_KEEPIDLE,\n                    seconds as libc::c_int)\n     }\n-    #[cfg(not(target_os = \"macos\"), not(target_os = \"freebsd\"))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(target_os = \"freebsd\"))]\n     fn set_tcp_keepalive(&mut self, _seconds: uint) -> IoResult<()> {\n         Ok(())\n     }"}, {"sha": "f26d87ba1b52ff9f8853c7e54ef62b622768f5bc", "filename": "src/libnative/io/process.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Fprocess.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -769,6 +769,7 @@ fn translate_status(status: c_int) -> rtio::ProcessExit {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     mod imp {\n         pub fn WIFEXITED(status: i32) -> bool { (status & 0x7f) == 0 }"}, {"sha": "ca0a810890c277cbf29aee3ad61bea693f30e8bb", "filename": "src/libnative/io/timer_unix.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Ftimer_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibnative%2Fio%2Ftimer_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Fio%2Ftimer_unix.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -93,7 +93,20 @@ pub fn now() -> u64 {\n     }\n }\n \n-fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n+\n+// Note: although the last parameter isn't used there is no way now to\n+// convert it to unit type, because LLVM dies in SjLj preparation\n+// step (unfortunately iOS uses SjLJ exceptions)\n+//\n+// It's definitely a temporary workaround just to get it working.\n+// So far it looks like an LLVM issue and it was reported:\n+// http://llvm.org/bugs/show_bug.cgi?id=19855\n+// Actually this issue is pretty common while compiling for armv7 iOS\n+// and in most cases it is simply solved by using --opt-level=2 (or -O)\n+//\n+// For this specific case unfortunately turning optimizations wasn't\n+// enough.\n+fn helper(input: libc::c_int, messages: Receiver<Req>, _: int) {\n     let mut set: c::fd_set = unsafe { mem::zeroed() };\n \n     let mut fd = FileDesc::new(input, true);\n@@ -202,7 +215,9 @@ fn helper(input: libc::c_int, messages: Receiver<Req>, _: ()) {\n \n impl Timer {\n     pub fn new() -> IoResult<Timer> {\n-        unsafe { HELPER.boot(|| {}, helper); }\n+        // See notes above regarding using int return value\n+        // instead of ()\n+        unsafe { HELPER.boot(|| {0}, helper); }\n \n         static mut ID: atomics::AtomicUint = atomics::INIT_ATOMIC_UINT;\n         let id = unsafe { ID.fetch_add(1, atomics::Relaxed) };"}, {"sha": "7a944fd5abee2cfdaa076ea2a2b050698b9b1bf9", "filename": "src/librustc/back/arm.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Farm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Farm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Farm.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -34,6 +34,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a0:0:64-n32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"e-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\"}, {"sha": "ab4eda33d75b92d57d645a59008b83915c742337", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -114,6 +114,13 @@ pub mod write {\n     // which are *far* more efficient. This is obviously undesirable in some\n     // cases, so if any sort of target feature is specified we don't append v7\n     // to the feature list.\n+    //\n+    // On iOS only armv7 and newer are supported. So it is useful to\n+    // get all hardware potential via VFP3 (hardware floating point)\n+    // and NEON (SIMD) instructions supported by LLVM.\n+    // Note that without those flags various linking errors might\n+    // arise as some of intrinsicts are converted into function calls\n+    // and nobody provides implementations those functions\n     fn target_feature<'a>(sess: &'a Session) -> &'a str {\n         match sess.targ_cfg.os {\n             abi::OsAndroid => {\n@@ -122,7 +129,10 @@ pub mod write {\n                 } else {\n                     sess.opts.cg.target_feature.as_slice()\n                 }\n-            }\n+            },\n+            abi::OsiOS if sess.targ_cfg.arch == abi::Arm => {\n+                \"+v7,+thumb2,+vfp3,+neon\"\n+            },\n             _ => sess.opts.cg.target_feature.as_slice()\n         }\n     }\n@@ -827,15 +837,23 @@ pub fn filename_for_input(sess: &Session, crate_type: config::CrateType,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = match sess.targ_cfg.os {\n-                abi::OsWin32 => (loader::WIN32_DLL_PREFIX, loader::WIN32_DLL_SUFFIX),\n-                abi::OsMacos => (loader::MACOS_DLL_PREFIX, loader::MACOS_DLL_SUFFIX),\n-                abi::OsLinux => (loader::LINUX_DLL_PREFIX, loader::LINUX_DLL_SUFFIX),\n-                abi::OsAndroid => (loader::ANDROID_DLL_PREFIX, loader::ANDROID_DLL_SUFFIX),\n-                abi::OsFreebsd => (loader::FREEBSD_DLL_PREFIX, loader::FREEBSD_DLL_SUFFIX),\n-            };\n-            out_filename.with_filename(format!(\"{}{}{}\", prefix, libname,\n-                                               suffix))\n+            // There is no support of DyLibs on iOS\n+            if sess.targ_cfg.os == abi::OsiOS {\n+                out_filename.with_filename(format!(\"lib{}.a\", libname))\n+            } else {\n+                let (prefix, suffix) = match sess.targ_cfg.os {\n+                    abi::OsWin32 => (loader::WIN32_DLL_PREFIX, loader::WIN32_DLL_SUFFIX),\n+                    abi::OsMacos => (loader::MACOS_DLL_PREFIX, loader::MACOS_DLL_SUFFIX),\n+                    abi::OsLinux => (loader::LINUX_DLL_PREFIX, loader::LINUX_DLL_SUFFIX),\n+                    abi::OsAndroid => (loader::ANDROID_DLL_PREFIX, loader::ANDROID_DLL_SUFFIX),\n+                    abi::OsFreebsd => (loader::FREEBSD_DLL_PREFIX, loader::FREEBSD_DLL_SUFFIX),\n+                    abi::OsiOS => unreachable!(),\n+                };\n+                out_filename.with_filename(format!(\"{}{}{}\",\n+                                                   prefix,\n+                                                   libname,\n+                                                   suffix))\n+            }\n         }\n         config::CrateTypeStaticlib => {\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n@@ -886,7 +904,14 @@ fn link_binary_output(sess: &Session,\n             link_natively(sess, trans, false, &obj_filename, &out_filename);\n         }\n         config::CrateTypeDylib => {\n-            link_natively(sess, trans, true, &obj_filename, &out_filename);\n+            if sess.targ_cfg.os == abi::OsiOS {\n+                sess.warn(format!(\"No dylib for iOS -> saving static library {} to {}\",\n+                                  obj_filename.display(), out_filename.display()).as_slice());\n+                link_staticlib(sess, &obj_filename, &out_filename);\n+            }\n+            else {\n+                link_natively(sess, trans, true, &obj_filename, &out_filename);\n+            }\n         }\n     }\n \n@@ -991,7 +1016,7 @@ fn link_rlib<'a>(sess: &'a Session,\n             // symbol table of the archive. This currently dies on OSX (see\n             // #11162), and isn't necessary there anyway\n             match sess.targ_cfg.os {\n-                abi::OsMacos => {}\n+                abi::OsMacos | abi::OsiOS => {}\n                 _ => { a.update_symbols(); }\n             }\n         }\n@@ -1104,15 +1129,16 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // On OSX, debuggers need this utility to get run to do some munging of\n     // the symbols\n-    if sess.targ_cfg.os == abi::OsMacos && (sess.opts.debuginfo != NoDebugInfo) {\n-        match Command::new(\"dsymutil\").arg(out_filename).status() {\n-            Ok(..) => {}\n-            Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n-                sess.abort_if_errors();\n+    if (sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS)\n+        && (sess.opts.debuginfo != NoDebugInfo) {\n+            match Command::new(\"dsymutil\").arg(out_filename).status() {\n+                Ok(..) => {}\n+                Err(e) => {\n+                    sess.err(format!(\"failed to run dsymutil: {}\", e).as_slice());\n+                    sess.abort_if_errors();\n+                }\n             }\n         }\n-    }\n }\n \n fn link_args(cmd: &mut Command,\n@@ -1169,7 +1195,7 @@ fn link_args(cmd: &mut Command,\n     // already done the best it can do, and we also don't want to eliminate the\n     // metadata. If we're building an executable, however, --gc-sections drops\n     // the size of hello world from 1.8MB to 597K, a 67% reduction.\n-    if !dylib && sess.targ_cfg.os != abi::OsMacos {\n+    if !dylib && sess.targ_cfg.os != abi::OsMacos && sess.targ_cfg.os != abi::OsiOS {\n         cmd.arg(\"-Wl,--gc-sections\");\n     }\n \n@@ -1185,7 +1211,7 @@ fn link_args(cmd: &mut Command,\n            sess.opts.optimize == config::Aggressive {\n             cmd.arg(\"-Wl,-O1\");\n         }\n-    } else if sess.targ_cfg.os == abi::OsMacos {\n+    } else if sess.targ_cfg.os == abi::OsMacos || sess.targ_cfg.os == abi::OsiOS {\n         // The dead_strip option to the linker specifies that functions and data\n         // unreachable by the entry point will be removed. This is quite useful\n         // with Rust's compilation model of compiling libraries at a time into\n@@ -1348,7 +1374,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n     // For those that support this, we ensure we pass the option if the library\n     // was flagged \"static\" (most defaults are dynamic) to ensure that if\n     // libfoo.a and libfoo.so both exist that the right one is chosen.\n-    let takes_hints = sess.targ_cfg.os != abi::OsMacos;\n+    let takes_hints = sess.targ_cfg.os != abi::OsMacos && sess.targ_cfg.os != abi::OsiOS;\n \n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {"}, {"sha": "ea9879dbf492001a2683f6e68626628e053aac1d", "filename": "src/librustc/back/mips.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fmips.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fmips.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fmips.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -29,6 +29,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 -a0:0:64-n32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"E-p:32:32:32\\\n+                -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\\n+                -f32:32:32-f64:64:64\\\n+                -v64:64:64-v128:64:128\\\n+                -a0:0:64-n32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"E-p:32:32:32\\\n                 -i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64\\"}, {"sha": "a458cf22a5bdc3c545b2be4ab43899333c92e3e3", "filename": "src/librustc/back/rpath.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Frpath.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -122,7 +122,7 @@ pub fn get_rpath_relative_to_output(os: abi::Os,\n         abi::OsAndroid | abi::OsLinux | abi::OsFreebsd\n                           => \"$ORIGIN\",\n         abi::OsMacos => \"@loader_path\",\n-        abi::OsWin32 => unreachable!()\n+        abi::OsWin32 | abi::OsiOS => unreachable!()\n     };\n \n     let mut lib = fs::realpath(&os::make_absolute(lib)).unwrap();"}, {"sha": "90106e9e0304643318dc2ed31ac9e0794e78f34b", "filename": "src/librustc/back/x86.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fx86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fx86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -31,6 +31,14 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os)\n                 -n8:16:32\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16\\\n+                -i32:32:32-i64:32:64\\\n+                -f32:32:32-f64:32:64-v64:64:64\\\n+                -v128:128:128-a0:0:64-f80:128:128\\\n+                -n8:16:32\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string()\n           }"}, {"sha": "55b0eca7be70c013487ba588f758269c86cb9a38", "filename": "src/librustc/back/x86_64.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fx86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fback%2Fx86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Fx86_64.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -28,6 +28,12 @@ pub fn get_target_strs(target_triple: String, target_os: abi::Os) -> target_strs\n                 s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n           }\n \n+          abi::OsiOS => {\n+            \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\\n+                f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-\\\n+                s0:64:64-f80:128:128-n8:16:32:64\".to_string()\n+          }\n+\n           abi::OsWin32 => {\n             // FIXME: Test this. Copied from linux (#2398)\n             \"e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-\\"}, {"sha": "2f7dc136ef2ef680e9b8c97d5ae5dd9849d9fa4f", "filename": "src/librustc/driver/config.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fdriver%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fdriver%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fconfig.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -362,7 +362,8 @@ pub fn cfg_os_to_meta_os(os: abi::Os) -> metadata::loader::Os {\n         abi::OsLinux => loader::OsLinux,\n         abi::OsAndroid => loader::OsAndroid,\n         abi::OsMacos => loader::OsMacos,\n-        abi::OsFreebsd => loader::OsFreebsd\n+        abi::OsFreebsd => loader::OsFreebsd,\n+        abi::OsiOS => loader::OsiOS,\n     }\n }\n \n@@ -373,6 +374,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n         abi::OsLinux =>   InternedString::new(\"linux\"),\n         abi::OsAndroid => InternedString::new(\"android\"),\n         abi::OsFreebsd => InternedString::new(\"freebsd\"),\n+        abi::OsiOS =>     InternedString::new(\"ios\"),\n     };\n \n     // ARM is bi-endian, however using NDK seems to default\n@@ -438,7 +440,8 @@ static os_names : &'static [(&'static str, abi::Os)] = &'static [\n     (\"darwin\",  abi::OsMacos),\n     (\"android\", abi::OsAndroid),\n     (\"linux\",   abi::OsLinux),\n-    (\"freebsd\", abi::OsFreebsd)];\n+    (\"freebsd\", abi::OsFreebsd),\n+    (\"ios\",     abi::OsiOS)];\n \n pub fn get_arch(triple: &str) -> Option<abi::Architecture> {\n     for &(arch, abi) in architecture_abis.iter() {"}, {"sha": "bc22b3ca7e242ecae8ae31e7eb9baf8a483e8af6", "filename": "src/librustc/driver/session.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fdriver%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fdriver%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fsession.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -249,4 +249,3 @@ pub fn expect<T:Clone>(sess: &Session, opt: Option<T>, msg: || -> String)\n               -> T {\n     diagnostic::expect(sess.diagnostic(), opt, msg)\n }\n-"}, {"sha": "63b177b0eb7149af4162cfe30464dff26ba3ac43", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -215,7 +215,8 @@ fn visit_item(e: &Env, i: &ast::Item) {\n                             Some(k) => {\n                                 if k.equiv(&(\"static\")) {\n                                     cstore::NativeStatic\n-                                } else if e.sess.targ_cfg.os == abi::OsMacos &&\n+                                } else if (e.sess.targ_cfg.os == abi::OsMacos ||\n+                                           e.sess.targ_cfg.os == abi::OsiOS) &&\n                                           k.equiv(&(\"framework\")) {\n                                     cstore::NativeFramework\n                                 } else if k.equiv(&(\"framework\")) {"}, {"sha": "a674b6cf5a91c0b84f3a469e7a9e8eabdad876d9", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -39,6 +39,9 @@ use time;\n pub static MACOS_DLL_PREFIX: &'static str = \"lib\";\n pub static MACOS_DLL_SUFFIX: &'static str = \".dylib\";\n \n+pub static IOS_DLL_PREFIX: &'static str = \"lib\";\n+pub static IOS_DLL_SUFFIX: &'static str = \".dylib\";\n+\n pub static WIN32_DLL_PREFIX: &'static str = \"\";\n pub static WIN32_DLL_SUFFIX: &'static str = \".dll\";\n \n@@ -56,7 +59,8 @@ pub enum Os {\n     OsWin32,\n     OsLinux,\n     OsAndroid,\n-    OsFreebsd\n+    OsFreebsd,\n+    OsiOS\n }\n \n pub struct CrateMismatch {\n@@ -455,6 +459,7 @@ impl<'a> Context<'a> {\n             OsLinux => (LINUX_DLL_PREFIX, LINUX_DLL_SUFFIX),\n             OsAndroid => (ANDROID_DLL_PREFIX, ANDROID_DLL_SUFFIX),\n             OsFreebsd => (FREEBSD_DLL_PREFIX, FREEBSD_DLL_SUFFIX),\n+            OsiOS => (IOS_DLL_PREFIX, IOS_DLL_SUFFIX),\n         }\n     }\n \n@@ -593,6 +598,7 @@ fn get_metadata_section_imp(os: Os, filename: &Path) -> Result<MetadataBlob, Str\n pub fn meta_section_name(os: Os) -> &'static str {\n     match os {\n         OsMacos => \"__DATA,__note.rustc\",\n+        OsiOS => \"__DATA,__note.rustc\",\n         OsWin32 => \".note.rustc\",\n         OsLinux => \".note.rustc\",\n         OsAndroid => \".note.rustc\",\n@@ -603,6 +609,7 @@ pub fn meta_section_name(os: Os) -> &'static str {\n pub fn read_meta_section_name(os: Os) -> &'static str {\n     match os {\n         OsMacos => \"__note.rustc\",\n+        OsiOS => \"__note.rustc\",\n         OsWin32 => \".note.rustc\",\n         OsLinux => \".note.rustc\",\n         OsAndroid => \".note.rustc\","}, {"sha": "d10f6b72820d29c68b77c9e21e29edb009062728", "filename": "src/librustc/middle/trans/cabi_x86.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcabi_x86.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n \n-use syntax::abi::{OsWin32, OsMacos};\n+use syntax::abi::{OsWin32, OsMacos, OsiOS};\n use lib::llvm::*;\n use super::cabi::*;\n use super::common::*;\n@@ -36,7 +36,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n \n         enum Strategy { RetValue(Type), RetPointer }\n         let strategy = match ccx.sess().targ_cfg.os {\n-            OsWin32 | OsMacos => {\n+            OsWin32 | OsMacos | OsiOS => {\n                 match llsize_of_alloc(ccx, rty) {\n                     1 => RetValue(Type::i8(ccx)),\n                     2 => RetValue(Type::i16(ccx)),"}, {"sha": "24f30bae75a91fb762330adda0cea01b9bb50bc4", "filename": "src/librustc/middle/trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcleanup.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -680,7 +680,7 @@ impl<'a> CleanupHelperMethods<'a> for FunctionContext<'a> {\n                     Some(llpersonality) => llpersonality,\n                     None => {\n                         let fty = Type::variadic_func(&[], &Type::i32(self.ccx));\n-                        let f = base::decl_cdecl_fn(self.ccx.llmod,\n+                        let f = base::decl_cdecl_fn(self.ccx,\n                                                     \"rust_eh_personality\",\n                                                     fty,\n                                                     ty::mk_i32());"}, {"sha": "c50badac531a947efad87bae1c6bdf90d5ebe704", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -277,7 +277,8 @@ pub fn finalize(cx: &CrateContext) {\n         // instruct LLVM to emit an older version of dwarf, however,\n         // for OS X to understand. For more info see #11352\n         // This can be overridden using --llvm-opts -dwarf-version,N.\n-        if cx.sess().targ_cfg.os == abi::OsMacos {\n+        if cx.sess().targ_cfg.os == abi::OsMacos ||\n+            cx.sess().targ_cfg.os == abi::OsiOS {\n             \"Dwarf Version\".with_c_str(\n                 |s| llvm::LLVMRustAddModuleFlag(cx.llmod, s, 2));\n         } else {"}, {"sha": "800e7f065f1e604ef7422dd273629c89e93ae321", "filename": "src/librustdoc/flock.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustdoc%2Fflock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustdoc%2Fflock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fflock.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -64,6 +64,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     mod os {\n         use libc;\n "}, {"sha": "d6d4b18051bf3e54ffaad90c02f75cf67810ab99", "filename": "src/librustrt/args.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fargs.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -145,6 +145,7 @@ mod imp {\n }\n \n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"win32\")]\n mod imp {\n     use core::prelude::*;"}, {"sha": "e17a43322ba3732458e2e94080d650142f998b63", "filename": "src/librustrt/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flib.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -164,7 +164,7 @@ pub unsafe fn cleanup() {\n pub mod shouldnt_be_public {\n     #[cfg(not(test))]\n     pub use super::local_ptr::native::maybe_tls_key;\n-    #[cfg(not(windows), not(target_os = \"android\"))]\n+    #[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n     pub use super::local_ptr::compiled::RT_TLS_PTR;\n }\n "}, {"sha": "50c2aba2b5cb11abed98276e1d9d5c4f4a2254ff", "filename": "src/librustrt/libunwind.rs", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flibunwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flibunwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flibunwind.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -17,6 +17,7 @@\n use libc;\n \n #[cfg(not(target_arch = \"arm\"))]\n+#[cfg(target_os = \"ios\")]\n #[repr(C)]\n pub enum _Unwind_Action {\n     _UA_SEARCH_PHASE = 1,\n@@ -61,9 +62,12 @@ pub static unwinder_private_data_size: int = 5;\n #[cfg(target_arch = \"x86_64\")]\n pub static unwinder_private_data_size: int = 2;\n \n-#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"arm\", not(target_os = \"ios\"))]\n pub static unwinder_private_data_size: int = 20;\n \n+#[cfg(target_arch = \"arm\", target_os = \"ios\")]\n+pub static unwinder_private_data_size: int = 5;\n+\n #[cfg(target_arch = \"mips\")]\n pub static unwinder_private_data_size: int = 2;\n \n@@ -89,8 +93,27 @@ extern {}\n #[link(name = \"gcc\")]\n extern {}\n \n+\n extern \"C\" {\n+    // iOS on armv7 uses SjLj exceptions and requires to link\n+    // agains corresponding routine (..._SjLj_...)\n+    // So here we just skip linking for iOS\n+    #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     pub fn _Unwind_RaiseException(exception: *_Unwind_Exception)\n                 -> _Unwind_Reason_Code;\n     pub fn _Unwind_DeleteException(exception: *_Unwind_Exception);\n }\n+\n+// ... and now we just providing access to SjLj counterspart\n+// through a standard name to hide those details from others\n+// (see also comment above regarding _Unwind_RaiseException)\n+#[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+#[inline(always)]\n+pub unsafe fn _Unwind_RaiseException(exc: *_Unwind_Exception)\n+                                     -> _Unwind_Reason_Code {\n+    extern \"C\" {\n+        fn _Unwind_SjLj_RaiseException(e: *_Unwind_Exception)\n+                                       -> _Unwind_Reason_Code; }\n+\n+    _Unwind_SjLj_RaiseException(exc)\n+}"}, {"sha": "b6858be32b7ceb70fc0ee9f4da000dc9d8e18f09", "filename": "src/librustrt/local_ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_ptr.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -24,10 +24,11 @@ use alloc::owned::Box;\n \n #[cfg(windows)]               // mingw-w32 doesn't like thread_local things\n #[cfg(target_os = \"android\")] // see #10686\n+#[cfg(target_os = \"ios\")]\n pub use self::native::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                        unsafe_borrow, try_unsafe_borrow};\n \n-#[cfg(not(windows), not(target_os = \"android\"))]\n+#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n pub use self::compiled::{init, cleanup, put, take, try_take, unsafe_take, exists,\n                          unsafe_borrow, try_unsafe_borrow};\n \n@@ -81,7 +82,7 @@ pub unsafe fn borrow<T>() -> Borrowed<T> {\n /// implemented using LLVM's thread_local attribute which isn't necessarily\n /// working on all platforms. This implementation is faster, however, so we use\n /// it wherever possible.\n-#[cfg(not(windows), not(target_os = \"android\"))]\n+#[cfg(not(windows), not(target_os = \"android\"), not(target_os = \"ios\"))]\n pub mod compiled {\n     use core::prelude::*;\n "}, {"sha": "26359ff7f6e9a25d628f5b9477fc9b2c2a53623a", "filename": "src/librustrt/mutex.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fmutex.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -283,6 +283,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     mod os {\n         use libc;\n \n@@ -294,6 +295,10 @@ mod imp {\n         static __PTHREAD_MUTEX_SIZE__: uint = 40;\n         #[cfg(target_arch = \"x86\")]\n         static __PTHREAD_COND_SIZE__: uint = 24;\n+        #[cfg(target_arch = \"arm\")]\n+        static __PTHREAD_MUTEX_SIZE__: uint = 40;\n+        #[cfg(target_arch = \"arm\")]\n+        static __PTHREAD_COND_SIZE__: uint = 24;\n \n         static _PTHREAD_MUTEX_SIG_init: libc::c_long = 0x32AAABA7;\n         static _PTHREAD_COND_SIG_init: libc::c_long = 0x3CB0B1BB;"}, {"sha": "e6fa845bedc895aee2710029db29254dda429a88", "filename": "src/librustrt/stack.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fstack.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -173,7 +173,8 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     return target_record_sp_limit(limit);\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movq $$0x60+90*8, %rsi\n               movq $0, %gs:(%rsi)\" :: \"r\"(limit) : \"rsi\" : \"volatile\")\n@@ -195,7 +196,8 @@ pub unsafe fn record_sp_limit(limit: uint) {\n     }\n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_record_sp_limit(limit: uint) {\n         asm!(\"movl $$0x48+90*4, %eax\n               movl $0, %gs:(%eax)\" :: \"r\"(limit) : \"eax\" : \"volatile\")\n@@ -243,7 +245,8 @@ pub unsafe fn get_sp_limit() -> uint {\n     return target_get_sp_limit();\n \n     // x86-64\n-    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86_64\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movq $$0x60+90*8, %rsi\n@@ -270,7 +273,8 @@ pub unsafe fn get_sp_limit() -> uint {\n     }\n \n     // x86\n-    #[cfg(target_arch = \"x86\", target_os = \"macos\")] #[inline(always)]\n+    #[cfg(target_arch = \"x86\", target_os = \"macos\")]\n+    #[cfg(target_arch = \"x86\", target_os = \"ios\")] #[inline(always)]\n     unsafe fn target_get_sp_limit() -> uint {\n         let limit;\n         asm!(\"movl $$0x48+90*4, %eax"}, {"sha": "3dcd1c4a6f0d3bde6b7a16392d34a2fd773c1319", "filename": "src/librustrt/thread.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -276,7 +276,6 @@ mod imp {\n     }\n \n     pub unsafe fn yield_now() { assert_eq!(sched_yield(), 0); }\n-\n     // glibc >= 2.15 has a __pthread_get_minstack() function that returns\n     // PTHREAD_STACK_MIN plus however many bytes are needed for thread-local\n     // storage.  We need that information to avoid blowing up when a small stack\n@@ -345,4 +344,3 @@ mod tests {\n         assert_eq!(42, Thread::start_stack(1, proc () 42).join());\n     }\n }\n-"}, {"sha": "4a7be39e6b87a0b7e15891acb87cd58bdc604fbe", "filename": "src/librustrt/thread_local_storage.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Fthread_local_storage.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -37,13 +37,14 @@ pub unsafe fn destroy(key: Key) {\n     assert!(pthread_key_delete(key) == 0);\n }\n \n-#[cfg(target_os=\"macos\")]\n+#[cfg(target_os = \"macos\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_ulong;\n \n #[cfg(target_os=\"linux\")]\n #[cfg(target_os=\"freebsd\")]\n #[cfg(target_os=\"android\")]\n+#[cfg(target_os = \"ios\")]\n #[allow(non_camel_case_types)] // foreign type\n type pthread_key_t = ::libc::c_uint;\n "}, {"sha": "e60c50f0adb43b6d063177e1f60dce5b6cd9cc3a", "filename": "src/librustrt/unwind.rs", "status": "modified", "additions": 61, "deletions": 3, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibrustrt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Funwind.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -285,16 +285,74 @@ pub mod eabi {\n         }\n         else { // cleanup phase\n             unsafe {\n-                 __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                __gcc_personality_v0(version, actions, exception_class, ue_header,\n+                                     context)\n+            }\n+        }\n+    }\n+}\n+\n+// iOS on armv7 is using SjLj exceptions and therefore requires to use\n+// a specialized personality routine: __gcc_personality_sj0\n+\n+#[cfg(target_os = \"ios\", target_arch = \"arm\", not(test))]\n+#[doc(hidden)]\n+#[allow(visible_private_types)]\n+pub mod eabi {\n+    use uw = libunwind;\n+    use libc::c_int;\n+\n+    extern \"C\" {\n+        #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+        fn __gcc_personality_sj0(version: c_int,\n+                                actions: uw::_Unwind_Action,\n+                                exception_class: uw::_Unwind_Exception_Class,\n+                                ue_header: *uw::_Unwind_Exception,\n+                                context: *uw::_Unwind_Context)\n+            -> uw::_Unwind_Reason_Code;\n+    }\n+\n+    #[lang=\"eh_personality\"]\n+    #[no_mangle] // so we can reference it by name from middle/trans/base.rs\n+    pub extern \"C\" fn rust_eh_personality(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        unsafe {\n+            __gcc_personality_sj0(version, actions, exception_class, ue_header,\n+                                  context)\n+        }\n+    }\n+\n+    #[no_mangle] // referenced from rust_try.ll\n+    pub extern \"C\" fn rust_eh_personality_catch(\n+        version: c_int,\n+        actions: uw::_Unwind_Action,\n+        exception_class: uw::_Unwind_Exception_Class,\n+        ue_header: *uw::_Unwind_Exception,\n+        context: *uw::_Unwind_Context\n+    ) -> uw::_Unwind_Reason_Code\n+    {\n+        if (actions as c_int & uw::_UA_SEARCH_PHASE as c_int) != 0 { // search phase\n+            uw::_URC_HANDLER_FOUND // catch!\n+        }\n+        else { // cleanup phase\n+            unsafe {\n+                __gcc_personality_sj0(version, actions, exception_class, ue_header,\n                                       context)\n             }\n         }\n     }\n }\n \n+\n // ARM EHABI uses a slightly different personality routine signature,\n // but otherwise works the same.\n-#[cfg(target_arch = \"arm\", not(test))]\n+#[cfg(target_arch = \"arm\", not(test), not(target_os = \"ios\"))]\n #[allow(visible_private_types)]\n pub mod eabi {\n     use uw = libunwind;\n@@ -332,7 +390,7 @@ pub mod eabi {\n         }\n         else { // cleanup phase\n             unsafe {\n-                 __gcc_personality_v0(state, ue_header, context)\n+                __gcc_personality_v0(state, ue_header, context)\n             }\n         }\n     }"}, {"sha": "5dbed6844c35fb5d77184b9a50c67aabb82270e4", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -153,7 +153,7 @@ impl DynamicLibrary {\n     }\n }\n \n-#[cfg(test)]\n+#[cfg(test, not(target_os = \"ios\"))]\n mod test {\n     use super::*;\n     use prelude::*;\n@@ -205,6 +205,7 @@ mod test {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n #[cfg(target_os = \"freebsd\")]\n pub mod dl {\n     use prelude::*;"}, {"sha": "f6b1c04dd34c604b5beec2a99e601f5caadf62c3", "filename": "src/libstd/os.rs", "status": "modified", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -552,6 +552,7 @@ pub fn pipe() -> Pipe {\n \n /// Returns the proper dll filename for the given basename of a file\n /// as a String.\n+#[cfg(not(target_os=\"ios\"))]\n pub fn dll_filename(base: &str) -> String {\n     format!(\"{}{}{}\", consts::DLL_PREFIX, base, consts::DLL_SUFFIX)\n }\n@@ -608,6 +609,7 @@ pub fn self_exe_name() -> Option<Path> {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn load_self() -> Option<Vec<u8>> {\n         unsafe {\n             use libc::funcs::extra::_NSGetExecutablePath;\n@@ -802,6 +804,7 @@ pub fn change_dir(p: &Path) -> bool {\n /// Returns the platform-specific value of errno\n pub fn errno() -> int {\n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     #[cfg(target_os = \"freebsd\")]\n     fn errno_location() -> *c_int {\n         extern {\n@@ -850,6 +853,7 @@ pub fn error_string(errnum: uint) -> String {\n     #[cfg(unix)]\n     fn strerror(errnum: uint) -> String {\n         #[cfg(target_os = \"macos\")]\n+        #[cfg(target_os = \"ios\")]\n         #[cfg(target_os = \"android\")]\n         #[cfg(target_os = \"freebsd\")]\n         fn strerror_r(errnum: c_int, buf: *mut c_char, buflen: libc::size_t)\n@@ -995,6 +999,64 @@ fn real_args_as_bytes() -> Vec<Vec<u8>> {\n     }\n }\n \n+// As _NSGetArgc and _NSGetArgv aren't mentioned in iOS docs\n+// and use underscores in their names - they're most probably\n+// are considered private and therefore should be avoided\n+// Here is another way to get arguments using Objective C\n+// runtime\n+//\n+// In general it looks like:\n+// res = Vec::new()\n+// let args = [[NSProcessInfo processInfo] arguments]\n+// for i in range(0, [args count])\n+//      res.push([args objectAtIndex:i])\n+// res\n+#[cfg(target_os = \"ios\")]\n+fn real_args_as_bytes() -> Vec<Vec<u8>> {\n+    use c_str::CString;\n+    use iter::range;\n+    use mem;\n+\n+    #[link(name = \"objc\")]\n+    extern {\n+        fn sel_registerName(name: *libc::c_uchar) -> Sel;\n+        fn objc_msgSend(obj: NsId, sel: Sel, ...) -> NsId;\n+        fn objc_getClass(class_name: *libc::c_uchar) -> NsId;\n+    }\n+\n+    #[link(name = \"Foundation\", kind = \"framework\")]\n+    extern {}\n+\n+    type Sel = *libc::c_void;\n+    type NsId = *libc::c_void;\n+\n+    let mut res = Vec::new();\n+\n+    unsafe {\n+        let processInfoSel = sel_registerName(\"processInfo\\0\".as_ptr());\n+        let argumentsSel = sel_registerName(\"arguments\\0\".as_ptr());\n+        let utf8Sel = sel_registerName(\"UTF8String\\0\".as_ptr());\n+        let countSel = sel_registerName(\"count\\0\".as_ptr());\n+        let objectAtSel = sel_registerName(\"objectAtIndex:\\0\".as_ptr());\n+\n+        let klass = objc_getClass(\"NSProcessInfo\\0\".as_ptr());\n+        let info = objc_msgSend(klass, processInfoSel);\n+        let args = objc_msgSend(info, argumentsSel);\n+\n+        let cnt: int = mem::transmute(objc_msgSend(args, countSel));\n+        for i in range(0, cnt) {\n+            let tmp = objc_msgSend(args, objectAtSel, i);\n+            let utf_c_str: *libc::c_char = mem::transmute(objc_msgSend(tmp, utf8Sel));\n+            let s = CString::new(utf_c_str, false);\n+            if s.is_not_null() {\n+                res.push(Vec::from_slice(s.as_bytes_no_nul()))\n+            }\n+        }\n+    }\n+\n+    res\n+}\n+\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n@@ -1532,6 +1594,25 @@ pub mod consts {\n     pub static EXE_EXTENSION: &'static str = \"\";\n }\n \n+#[cfg(target_os = \"ios\")]\n+pub mod consts {\n+    pub use os::arch_consts::ARCH;\n+\n+    pub static FAMILY: &'static str = \"unix\";\n+\n+    /// A string describing the specific operating system in use: in this\n+    /// case, `ios`.\n+    pub static SYSNAME: &'static str = \"ios\";\n+\n+    /// Specifies the filename suffix used for executable binaries on this\n+    /// platform: in this case, the empty string.\n+    pub static EXE_SUFFIX: &'static str = \"\";\n+\n+    /// Specifies the file extension, if any, used for executable binaries\n+    /// on this platform: in this case, the empty string.\n+    pub static EXE_EXTENSION: &'static str = \"\";\n+}\n+\n #[cfg(target_os = \"freebsd\")]\n pub mod consts {\n     pub use os::arch_consts::ARCH;"}, {"sha": "f507011c2b955166e5863b85aee4aa306e8b7444", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -13,7 +13,7 @@\n \n pub use self::imp::OsRng;\n \n-#[cfg(unix)]\n+#[cfg(unix, not(target_os = \"ios\"))]\n mod imp {\n     use io::{IoResult, File};\n     use path::Path;\n@@ -28,7 +28,7 @@ mod imp {\n     ///   `/dev/urandom`.\n     /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n     ///   service provider with the `PROV_RSA_FULL` type.\n-    ///\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n     /// This does not block.\n     #[cfg(unix)]\n     pub struct OsRng {\n@@ -58,6 +58,71 @@ mod imp {\n     }\n }\n \n+#[cfg(target_os = \"ios\")]\n+mod imp {\n+    extern crate libc;\n+\n+    use collections::Collection;\n+    use io::{IoResult};\n+    use kinds::marker;\n+    use mem;\n+    use os;\n+    use rand::Rng;\n+    use result::{Ok};\n+    use self::libc::{c_int, size_t};\n+    use slice::MutableVector;\n+\n+    /// A random number generator that retrieves randomness straight from\n+    /// the operating system. Platform sources:\n+    ///\n+    /// - Unix-like systems (Linux, Android, Mac OSX): read directly from\n+    ///   `/dev/urandom`.\n+    /// - Windows: calls `CryptGenRandom`, using the default cryptographic\n+    ///   service provider with the `PROV_RSA_FULL` type.\n+    /// - iOS: calls SecRandomCopyBytes as /dev/(u)random is sandboxed\n+    /// This does not block.\n+    pub struct OsRng {\n+        marker: marker::NoCopy\n+    }\n+\n+    struct SecRandom;\n+\n+    static kSecRandomDefault: *SecRandom = 0 as *SecRandom;\n+\n+    #[link(name = \"Security\", kind = \"framework\")]\n+    extern \"C\" {\n+        fn SecRandomCopyBytes(rnd: *SecRandom, count: size_t, bytes: *mut u8) -> c_int;\n+    }\n+\n+    impl OsRng {\n+        /// Create a new `OsRng`.\n+        pub fn new() -> IoResult<OsRng> {\n+            Ok(OsRng {marker: marker::NoCopy} )\n+        }\n+    }\n+\n+    impl Rng for OsRng {\n+        fn next_u32(&mut self) -> u32 {\n+            let mut v = [0u8, .. 4];\n+            self.fill_bytes(v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn next_u64(&mut self) -> u64 {\n+            let mut v = [0u8, .. 8];\n+            self.fill_bytes(v);\n+            unsafe { mem::transmute(v) }\n+        }\n+        fn fill_bytes(&mut self, v: &mut [u8]) {\n+            let ret = unsafe {\n+                SecRandomCopyBytes(kSecRandomDefault, v.len() as size_t, v.as_mut_ptr())\n+            };\n+            if ret == -1 {\n+                fail!(\"couldn't generate random bytes: {}\", os::last_os_error());\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(windows)]\n mod imp {\n     extern crate libc;"}, {"sha": "16b598b3ae7b9dfbcee72f3db8764dab53b4010e", "filename": "src/libstd/rt/backtrace.rs", "status": "modified", "additions": 52, "deletions": 8, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frt%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frt%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fbacktrace.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -237,22 +237,58 @@ fn demangle(writer: &mut Writer, s: &str) -> IoResult<()> {\n #[cfg(unix)]\n mod imp {\n     use c_str::CString;\n-    use io::{IoResult, IoError, Writer};\n+    use io::{IoResult, Writer};\n     use libc;\n     use mem;\n     use option::{Some, None, Option};\n     use result::{Ok, Err};\n     use rt::mutex::{StaticNativeMutex, NATIVE_MUTEX_INIT};\n \n-    struct Context<'a> {\n-        idx: int,\n-        writer: &'a mut Writer,\n-        last_error: Option<IoError>,\n+    /// As always - iOS on arm uses SjLj exceptions and\n+    /// _Unwind_Backtrace is even not available there. Still,\n+    /// backtraces could be extracted using a backtrace function,\n+    /// which thanks god is public\n+    #[cfg(target_os = \"ios\", target_arch = \"arm\")]\n+    #[inline(never)]\n+    pub fn write(w: &mut Writer) -> IoResult<()> {\n+        use iter::{Iterator, range};\n+        use result;\n+        use slice::{MutableVector};\n+\n+        extern {\n+            fn backtrace(buf: *mut *libc::c_void, sz: libc::c_int) -> libc::c_int;\n+        }\n+\n+        // while it doesn't requires lock for work as everything is\n+        // local, it still displays much nicier backtraces when a\n+        // couple of tasks fail simultaneously\n+        static mut LOCK: StaticNativeMutex = NATIVE_MUTEX_INIT;\n+        let _g = unsafe { LOCK.lock() };\n+\n+        try!(writeln!(w, \"stack backtrace:\"));\n+        // 100 lines should be enough\n+        static size: libc::c_int = 100;\n+        let mut buf: [*libc::c_void, ..size] = unsafe {mem::zeroed()};\n+        let cnt = unsafe { backtrace(buf.as_mut_ptr(), size) as uint};\n+\n+        // skipping the first one as it is write itself\n+        result::fold_(range(1, cnt).map(|i| {\n+            print(w, i as int, buf[i])\n+        }))\n     }\n \n+    #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n     #[inline(never)] // if we know this is a function call, we can skip it when\n                      // tracing\n     pub fn write(w: &mut Writer) -> IoResult<()> {\n+        use io::IoError;\n+\n+        struct Context<'a> {\n+            idx: int,\n+            writer: &'a mut Writer,\n+            last_error: Option<IoError>,\n+        }\n+\n         // When using libbacktrace, we use some necessary global state, so we\n         // need to prevent more than one thread from entering this block. This\n         // is semi-reasonable in terms of printing anyway, and we know that all\n@@ -291,7 +327,7 @@ mod imp {\n             // instructions after it. This means that the return instruction\n             // pointer points *outside* of the calling function, and by\n             // unwinding it we go back to the original function.\n-            let ip = if cfg!(target_os = \"macos\") {\n+            let ip = if cfg!(target_os = \"macos\") || cfg!(target_os = \"ios\") {\n                 ip\n             } else {\n                 unsafe { uw::_Unwind_FindEnclosingFunction(ip) }\n@@ -323,6 +359,7 @@ mod imp {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n         use intrinsics;\n         #[repr(C)]\n@@ -347,7 +384,7 @@ mod imp {\n         }\n     }\n \n-    #[cfg(not(target_os = \"macos\"))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"))]\n     fn print(w: &mut Writer, idx: int, addr: *libc::c_void) -> IoResult<()> {\n         use collections::Collection;\n         use iter::Iterator;\n@@ -487,9 +524,14 @@ mod imp {\n \n     /// Unwind library interface used for backtraces\n     ///\n-    /// Note that the native libraries come from librustrt, not this module.\n+    /// Note that the native libraries come from librustrt, not this\n+    /// module.\n+    /// Note that dead code is allowed as here are just bindings\n+    /// iOS doesn't use all of them it but adding more\n+    /// platform-specific configs pollutes the code too much\n     #[allow(non_camel_case_types)]\n     #[allow(non_snake_case_functions)]\n+    #[allow(dead_code)]\n     mod uw {\n         use libc;\n \n@@ -514,6 +556,8 @@ mod imp {\n                           arg: *libc::c_void) -> _Unwind_Reason_Code;\n \n         extern {\n+            // No native _Unwind_Backtrace on iOS\n+            #[cfg(not(target_os = \"ios\", target_arch = \"arm\"))]\n             pub fn _Unwind_Backtrace(trace: _Unwind_Trace_Fn,\n                                      trace_argument: *libc::c_void)\n                         -> _Unwind_Reason_Code;"}, {"sha": "f8bfde52261632f1887ccffe786d263f9b4d45e3", "filename": "src/libstd/rtdeps.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frtdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibstd%2Frtdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frtdeps.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -39,3 +39,7 @@ extern {}\n #[cfg(target_os = \"macos\")]\n #[link(name = \"System\")]\n extern {}\n+\n+#[cfg(target_os = \"ios\")]\n+#[link(name = \"System\")]\n+extern {}"}, {"sha": "ec54a033e715321a14365a5dfd7533dd17818c37", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -11,7 +11,7 @@\n use std::fmt;\n \n #[deriving(PartialEq)]\n-pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, }\n+pub enum Os { OsWin32, OsMacos, OsLinux, OsAndroid, OsFreebsd, OsiOS, }\n \n #[deriving(PartialEq, Eq, Hash, Encodable, Decodable, Clone)]\n pub enum Abi {"}, {"sha": "b4a2e92cc1262a02660c2778f72a124c07783583", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a49b765f9a5b5926e338da30fcaae59ff1ae5c02/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=a49b765f9a5b5926e338da30fcaae59ff1ae5c02", "patch": "@@ -48,7 +48,7 @@ mod rustrt {\n     }\n }\n \n-#[cfg(unix, not(target_os = \"macos\"))]\n+#[cfg(unix, not(target_os = \"macos\"), not(target_os = \"ios\"))]\n mod imp {\n     use libc::{c_int, timespec};\n \n@@ -63,6 +63,7 @@ mod imp {\n \n }\n #[cfg(target_os = \"macos\")]\n+#[cfg(target_os = \"ios\")]\n mod imp {\n     use libc::{timeval, timezone, c_int, mach_timebase_info};\n \n@@ -123,14 +124,15 @@ pub fn get_time() -> Timespec {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     unsafe fn os_get_time() -> (i64, i32) {\n         use std::ptr;\n         let mut tv = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         imp::gettimeofday(&mut tv, ptr::mut_null());\n         (tv.tv_sec as i64, tv.tv_usec * 1000)\n     }\n \n-    #[cfg(not(target_os = \"macos\"), not(windows))]\n+    #[cfg(not(target_os = \"macos\"), not(target_os = \"ios\"), not(windows))]\n     unsafe fn os_get_time() -> (i64, i32) {\n         let mut tv = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n         imp::clock_gettime(libc::CLOCK_REALTIME, &mut tv);\n@@ -162,6 +164,7 @@ pub fn precise_time_ns() -> u64 {\n     }\n \n     #[cfg(target_os = \"macos\")]\n+    #[cfg(target_os = \"ios\")]\n     fn os_precise_time_ns() -> u64 {\n         static mut TIMEBASE: libc::mach_timebase_info = libc::mach_timebase_info { numer: 0,\n                                                                                    denom: 0 };\n@@ -175,7 +178,7 @@ pub fn precise_time_ns() -> u64 {\n         }\n     }\n \n-    #[cfg(not(windows), not(target_os = \"macos\"))]\n+    #[cfg(not(windows), not(target_os = \"macos\"), not(target_os = \"ios\"))]\n     fn os_precise_time_ns() -> u64 {\n         let mut ts = libc::timespec { tv_sec: 0, tv_nsec: 0 };\n         unsafe {"}]}