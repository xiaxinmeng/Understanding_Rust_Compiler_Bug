{"sha": "bc2b21cc4e2679191b14ade2511e9015e717da53", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjMmIyMWNjNGUyNjc5MTkxYjE0YWRlMjUxMWU5MDE1ZTcxN2RhNTM=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-19T12:59:08Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-07-20T03:26:33Z"}, "message": "proc_macro: move some implementation details to a rustc module.", "tree": {"sha": "e9c90f4bc50134ed7871acb2372c1a5196fa2295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e9c90f4bc50134ed7871acb2372c1a5196fa2295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bc2b21cc4e2679191b14ade2511e9015e717da53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bc2b21cc4e2679191b14ade2511e9015e717da53", "html_url": "https://github.com/rust-lang/rust/commit/bc2b21cc4e2679191b14ade2511e9015e717da53", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bc2b21cc4e2679191b14ade2511e9015e717da53/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e5e29d1a1976ff7d0b39ade8706ca0e3ddebe7a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e29d1a1976ff7d0b39ade8706ca0e3ddebe7a9", "html_url": "https://github.com/rust-lang/rust/commit/e5e29d1a1976ff7d0b39ade8706ca0e3ddebe7a9"}], "stats": {"total": 569, "additions": 305, "deletions": 264}, "files": [{"sha": "51e7647f36cc2f9673d49e27a1100182fe995f46", "filename": "src/libproc_macro/diagnostic.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Fdiagnostic.rs?ref=bc2b21cc4e2679191b14ade2511e9015e717da53", "patch": "@@ -116,15 +116,3 @@ impl Diagnostic {\n         });\n     }\n }\n-\n-impl Level {\n-    fn to_internal(self) -> errors::Level {\n-        match self {\n-            Level::Error => errors::Level::Error,\n-            Level::Warning => errors::Level::Warning,\n-            Level::Note => errors::Level::Note,\n-            Level::Help => errors::Level::Help,\n-            Level::__Nonexhaustive => unreachable!(\"Level::__Nonexhaustive\")\n-        }\n-    }\n-}"}, {"sha": "f63e3e0e4a6fb236556d912b627a3614b0033460", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 21, "deletions": 246, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=bc2b21cc4e2679191b14ade2511e9015e717da53", "patch": "@@ -44,6 +44,10 @@ extern crate syntax_pos;\n extern crate rustc_errors;\n extern crate rustc_data_structures;\n \n+#[unstable(feature = \"proc_macro_internals\", issue = \"27812\")]\n+#[doc(hidden)]\n+pub mod rustc;\n+\n mod diagnostic;\n \n #[unstable(feature = \"proc_macro_diagnostic\", issue = \"38356\")]\n@@ -54,12 +58,10 @@ use std::path::PathBuf;\n use rustc_data_structures::sync::Lrc;\n use std::str::FromStr;\n \n-use syntax::ast;\n use syntax::errors::DiagnosticBuilder;\n use syntax::parse::{self, token};\n-use syntax::symbol::{keywords, Symbol};\n+use syntax::symbol::Symbol;\n use syntax::tokenstream;\n-use syntax::parse::lexer::{self, comments};\n use syntax_pos::{FileMap, Pos, FileName};\n \n /// The main type provided by this crate, representing an abstract stream of\n@@ -784,6 +786,16 @@ impl !Send for Ident {}\n impl !Sync for Ident {}\n \n impl Ident {\n+    fn is_valid(string: &str) -> bool {\n+        let mut chars = string.chars();\n+        if let Some(start) = chars.next() {\n+            (start == '_' || start.is_xid_start())\n+                && chars.all(|cont| cont == '_' || cont.is_xid_continue())\n+        } else {\n+            false\n+        }\n+    }\n+\n     /// Creates a new `Ident` with the given `string` as well as the specified\n     /// `span`.\n     /// The `string` argument must be a valid identifier permitted by the\n@@ -805,26 +817,19 @@ impl Ident {\n     /// tokens, requires a `Span` to be specified at construction.\n     #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n     pub fn new(string: &str, span: Span) -> Ident {\n-        if !lexer::is_valid_ident(string) {\n+        if !Ident::is_valid(string) {\n             panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        Ident {\n-            sym: Symbol::intern(string),\n-            span,\n-            is_raw: false,\n-        }\n+        Ident::new_maybe_raw(string, span, false)\n     }\n \n     /// Same as `Ident::new`, but creates a raw identifier (`r#ident`).\n     #[unstable(feature = \"proc_macro_raw_ident\", issue = \"38356\")]\n     pub fn new_raw(string: &str, span: Span) -> Ident {\n-        let mut ident = Ident::new(string, span);\n-        if ident.sym == keywords::Underscore.name() ||\n-           ast::Ident::with_empty_ctxt(ident.sym).is_path_segment_keyword() {\n-            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        if !Ident::is_valid(string) {\n+            panic!(\"`{:?}` is not a valid identifier\", string)\n         }\n-        ident.is_raw = true;\n-        ident\n+        Ident::new_maybe_raw(string, span, true)\n     }\n \n     /// Returns the span of this `Ident`, encompassing the entire string returned\n@@ -861,7 +866,7 @@ impl fmt::Display for Ident {\n #[stable(feature = \"proc_macro_lib2\", since = \"1.29.0\")]\n pub struct Literal {\n     lit: token::Lit,\n-    suffix: Option<ast::Name>,\n+    suffix: Option<Symbol>,\n     span: Span,\n }\n \n@@ -1109,236 +1114,6 @@ impl fmt::Display for Literal {\n     }\n }\n \n-impl Delimiter {\n-    fn from_internal(delim: token::DelimToken) -> Delimiter {\n-        match delim {\n-            token::Paren => Delimiter::Parenthesis,\n-            token::Brace => Delimiter::Brace,\n-            token::Bracket => Delimiter::Bracket,\n-            token::NoDelim => Delimiter::None,\n-        }\n-    }\n-\n-    fn to_internal(self) -> token::DelimToken {\n-        match self {\n-            Delimiter::Parenthesis => token::Paren,\n-            Delimiter::Brace => token::Brace,\n-            Delimiter::Bracket => token::Bracket,\n-            Delimiter::None => token::NoDelim,\n-        }\n-    }\n-}\n-\n-impl TokenTree {\n-    fn from_internal(stream: tokenstream::TokenStream, stack: &mut Vec<TokenTree>)\n-                -> TokenTree {\n-        use syntax::parse::token::*;\n-\n-        let (tree, is_joint) = stream.as_tree();\n-        let (span, token) = match tree {\n-            tokenstream::TokenTree::Token(span, token) => (span, token),\n-            tokenstream::TokenTree::Delimited(span, delimed) => {\n-                let delimiter = Delimiter::from_internal(delimed.delim);\n-                let mut g = Group::new(delimiter, TokenStream(delimed.tts.into()));\n-                g.set_span(Span(span));\n-                return g.into()\n-            }\n-        };\n-\n-        let op_kind = if is_joint { Spacing::Joint } else { Spacing::Alone };\n-        macro_rules! tt {\n-            ($e:expr) => ({\n-                let mut x = TokenTree::from($e);\n-                x.set_span(Span(span));\n-                x\n-            })\n-        }\n-        macro_rules! op {\n-            ($a:expr) => (tt!(Punct::new($a, op_kind)));\n-            ($a:expr, $b:expr) => ({\n-                stack.push(tt!(Punct::new($b, op_kind)));\n-                tt!(Punct::new($a, Spacing::Joint))\n-            });\n-            ($a:expr, $b:expr, $c:expr) => ({\n-                stack.push(tt!(Punct::new($c, op_kind)));\n-                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n-                tt!(Punct::new($a, Spacing::Joint))\n-            })\n-        }\n-\n-        match token {\n-            Eq => op!('='),\n-            Lt => op!('<'),\n-            Le => op!('<', '='),\n-            EqEq => op!('=', '='),\n-            Ne => op!('!', '='),\n-            Ge => op!('>', '='),\n-            Gt => op!('>'),\n-            AndAnd => op!('&', '&'),\n-            OrOr => op!('|', '|'),\n-            Not => op!('!'),\n-            Tilde => op!('~'),\n-            BinOp(Plus) => op!('+'),\n-            BinOp(Minus) => op!('-'),\n-            BinOp(Star) => op!('*'),\n-            BinOp(Slash) => op!('/'),\n-            BinOp(Percent) => op!('%'),\n-            BinOp(Caret) => op!('^'),\n-            BinOp(And) => op!('&'),\n-            BinOp(Or) => op!('|'),\n-            BinOp(Shl) => op!('<', '<'),\n-            BinOp(Shr) => op!('>', '>'),\n-            BinOpEq(Plus) => op!('+', '='),\n-            BinOpEq(Minus) => op!('-', '='),\n-            BinOpEq(Star) => op!('*', '='),\n-            BinOpEq(Slash) => op!('/', '='),\n-            BinOpEq(Percent) => op!('%', '='),\n-            BinOpEq(Caret) => op!('^', '='),\n-            BinOpEq(And) => op!('&', '='),\n-            BinOpEq(Or) => op!('|', '='),\n-            BinOpEq(Shl) => op!('<', '<', '='),\n-            BinOpEq(Shr) => op!('>', '>', '='),\n-            At => op!('@'),\n-            Dot => op!('.'),\n-            DotDot => op!('.', '.'),\n-            DotDotDot => op!('.', '.', '.'),\n-            DotDotEq => op!('.', '.', '='),\n-            Comma => op!(','),\n-            Semi => op!(';'),\n-            Colon => op!(':'),\n-            ModSep => op!(':', ':'),\n-            RArrow => op!('-', '>'),\n-            LArrow => op!('<', '-'),\n-            FatArrow => op!('=', '>'),\n-            Pound => op!('#'),\n-            Dollar => op!('$'),\n-            Question => op!('?'),\n-            SingleQuote => op!('\\''),\n-\n-            Ident(ident, false) => {\n-                tt!(self::Ident::new(&ident.as_str(), Span(span)))\n-            }\n-            Ident(ident, true) => {\n-                tt!(self::Ident::new_raw(&ident.as_str(), Span(span)))\n-            }\n-            Lifetime(ident) => {\n-                let ident = ident.without_first_quote();\n-                stack.push(tt!(self::Ident::new(&ident.as_str(), Span(span))));\n-                tt!(Punct::new('\\'', Spacing::Joint))\n-            }\n-            Literal(lit, suffix) => tt!(self::Literal { lit, suffix, span: Span(span) }),\n-            DocComment(c) => {\n-                let style = comments::doc_comment_style(&c.as_str());\n-                let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n-                let stream = vec![\n-                    tt!(self::Ident::new(\"doc\", Span(span))),\n-                    tt!(Punct::new('=', Spacing::Alone)),\n-                    tt!(self::Literal::string(&stripped)),\n-                ].into_iter().collect();\n-                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n-                if style == ast::AttrStyle::Inner {\n-                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n-                }\n-                tt!(Punct::new('#', Spacing::Alone))\n-            }\n-\n-            Interpolated(_) => {\n-                __internal::with_sess(|sess, _| {\n-                    let tts = token.interpolated_to_tokenstream(sess, span);\n-                    tt!(Group::new(Delimiter::None, TokenStream(tts)))\n-                })\n-            }\n-\n-            DotEq => op!('.', '='),\n-            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n-            Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n-        }\n-    }\n-\n-    fn to_internal(self) -> tokenstream::TokenStream {\n-        use syntax::parse::token::*;\n-        use syntax::tokenstream::{TokenTree, Delimited};\n-\n-        let (ch, kind, span) = match self {\n-            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n-            self::TokenTree::Group(tt) => {\n-                return TokenTree::Delimited(tt.span.0, Delimited {\n-                    delim: tt.delimiter.to_internal(),\n-                    tts: tt.stream.0.into(),\n-                }).into();\n-            },\n-            self::TokenTree::Ident(tt) => {\n-                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n-                return TokenTree::Token(tt.span.0, token).into();\n-            }\n-            self::TokenTree::Literal(self::Literal {\n-                lit: Lit::Integer(ref a),\n-                suffix,\n-                span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n-                let minus = BinOp(BinOpToken::Minus);\n-                let integer = Symbol::intern(&a.as_str()[1..]);\n-                let integer = Literal(Lit::Integer(integer), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, integer);\n-                return vec![a, b].into_iter().collect()\n-            }\n-            self::TokenTree::Literal(self::Literal {\n-                lit: Lit::Float(ref a),\n-                suffix,\n-                span,\n-            })\n-                if a.as_str().starts_with(\"-\") =>\n-            {\n-                let minus = BinOp(BinOpToken::Minus);\n-                let float = Symbol::intern(&a.as_str()[1..]);\n-                let float = Literal(Lit::Float(float), suffix);\n-                let a = TokenTree::Token(span.0, minus);\n-                let b = TokenTree::Token(span.0, float);\n-                return vec![a, b].into_iter().collect()\n-            }\n-            self::TokenTree::Literal(tt) => {\n-                let token = Literal(tt.lit, tt.suffix);\n-                return TokenTree::Token(tt.span.0, token).into()\n-            }\n-        };\n-\n-        let token = match ch {\n-            '=' => Eq,\n-            '<' => Lt,\n-            '>' => Gt,\n-            '!' => Not,\n-            '~' => Tilde,\n-            '+' => BinOp(Plus),\n-            '-' => BinOp(Minus),\n-            '*' => BinOp(Star),\n-            '/' => BinOp(Slash),\n-            '%' => BinOp(Percent),\n-            '^' => BinOp(Caret),\n-            '&' => BinOp(And),\n-            '|' => BinOp(Or),\n-            '@' => At,\n-            '.' => Dot,\n-            ',' => Comma,\n-            ';' => Semi,\n-            ':' => Colon,\n-            '#' => Pound,\n-            '$' => Dollar,\n-            '?' => Question,\n-            '\\'' => SingleQuote,\n-            _ => unreachable!(),\n-        };\n-\n-        let tree = TokenTree::Token(span.0, token);\n-        match kind {\n-            Spacing::Alone => tree.into(),\n-            Spacing::Joint => tree.joint(),\n-        }\n-    }\n-}\n-\n /// Permanently unstable internal implementation details of this crate. This\n /// should not be used.\n ///"}, {"sha": "a54c695f6376fc0e817d42ea2c58fc9c0cb5067b", "filename": "src/libproc_macro/rustc.rs", "status": "added", "additions": 284, "deletions": 0, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibproc_macro%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Frustc.rs?ref=bc2b21cc4e2679191b14ade2511e9015e717da53", "patch": "@@ -0,0 +1,284 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use {Delimiter, Level, Spacing, Span, __internal};\n+use {Group, Ident, Literal, Punct, TokenTree};\n+\n+use rustc_errors as errors;\n+use syntax::ast;\n+use syntax::parse::lexer::comments;\n+use syntax::parse::token;\n+use syntax::tokenstream;\n+use syntax_pos::symbol::{keywords, Symbol};\n+\n+impl Ident {\n+    pub(crate) fn new_maybe_raw(string: &str, span: Span, is_raw: bool) -> Ident {\n+        let sym = Symbol::intern(string);\n+        if is_raw\n+            && (sym == keywords::Underscore.name()\n+                || ast::Ident::with_empty_ctxt(sym).is_path_segment_keyword())\n+        {\n+            panic!(\"`{:?}` is not a valid raw identifier\", string)\n+        }\n+        Ident { sym, span, is_raw }\n+    }\n+}\n+\n+impl Delimiter {\n+    pub(crate) fn from_internal(delim: token::DelimToken) -> Delimiter {\n+        match delim {\n+            token::Paren => Delimiter::Parenthesis,\n+            token::Brace => Delimiter::Brace,\n+            token::Bracket => Delimiter::Bracket,\n+            token::NoDelim => Delimiter::None,\n+        }\n+    }\n+\n+    pub(crate) fn to_internal(self) -> token::DelimToken {\n+        match self {\n+            Delimiter::Parenthesis => token::Paren,\n+            Delimiter::Brace => token::Brace,\n+            Delimiter::Bracket => token::Bracket,\n+            Delimiter::None => token::NoDelim,\n+        }\n+    }\n+}\n+\n+impl TokenTree {\n+    pub(crate) fn from_internal(\n+        stream: tokenstream::TokenStream,\n+        stack: &mut Vec<TokenTree>,\n+    ) -> TokenTree {\n+        use syntax::parse::token::*;\n+\n+        let (tree, is_joint) = stream.as_tree();\n+        let (span, token) = match tree {\n+            tokenstream::TokenTree::Token(span, token) => (span, token),\n+            tokenstream::TokenTree::Delimited(span, delimed) => {\n+                let delimiter = Delimiter::from_internal(delimed.delim);\n+                let mut g = Group::new(delimiter, ::TokenStream(delimed.tts.into()));\n+                g.set_span(Span(span));\n+                return g.into();\n+            }\n+        };\n+\n+        let op_kind = if is_joint {\n+            Spacing::Joint\n+        } else {\n+            Spacing::Alone\n+        };\n+        macro_rules! tt {\n+            ($e:expr) => {{\n+                let mut x = TokenTree::from($e);\n+                x.set_span(Span(span));\n+                x\n+            }};\n+        }\n+        macro_rules! op {\n+            ($a:expr) => {\n+                tt!(Punct::new($a, op_kind))\n+            };\n+            ($a:expr, $b:expr) => {{\n+                stack.push(tt!(Punct::new($b, op_kind)));\n+                tt!(Punct::new($a, Spacing::Joint))\n+            }};\n+            ($a:expr, $b:expr, $c:expr) => {{\n+                stack.push(tt!(Punct::new($c, op_kind)));\n+                stack.push(tt!(Punct::new($b, Spacing::Joint)));\n+                tt!(Punct::new($a, Spacing::Joint))\n+            }};\n+        }\n+\n+        match token {\n+            Eq => op!('='),\n+            Lt => op!('<'),\n+            Le => op!('<', '='),\n+            EqEq => op!('=', '='),\n+            Ne => op!('!', '='),\n+            Ge => op!('>', '='),\n+            Gt => op!('>'),\n+            AndAnd => op!('&', '&'),\n+            OrOr => op!('|', '|'),\n+            Not => op!('!'),\n+            Tilde => op!('~'),\n+            BinOp(Plus) => op!('+'),\n+            BinOp(Minus) => op!('-'),\n+            BinOp(Star) => op!('*'),\n+            BinOp(Slash) => op!('/'),\n+            BinOp(Percent) => op!('%'),\n+            BinOp(Caret) => op!('^'),\n+            BinOp(And) => op!('&'),\n+            BinOp(Or) => op!('|'),\n+            BinOp(Shl) => op!('<', '<'),\n+            BinOp(Shr) => op!('>', '>'),\n+            BinOpEq(Plus) => op!('+', '='),\n+            BinOpEq(Minus) => op!('-', '='),\n+            BinOpEq(Star) => op!('*', '='),\n+            BinOpEq(Slash) => op!('/', '='),\n+            BinOpEq(Percent) => op!('%', '='),\n+            BinOpEq(Caret) => op!('^', '='),\n+            BinOpEq(And) => op!('&', '='),\n+            BinOpEq(Or) => op!('|', '='),\n+            BinOpEq(Shl) => op!('<', '<', '='),\n+            BinOpEq(Shr) => op!('>', '>', '='),\n+            At => op!('@'),\n+            Dot => op!('.'),\n+            DotDot => op!('.', '.'),\n+            DotDotDot => op!('.', '.', '.'),\n+            DotDotEq => op!('.', '.', '='),\n+            Comma => op!(','),\n+            Semi => op!(';'),\n+            Colon => op!(':'),\n+            ModSep => op!(':', ':'),\n+            RArrow => op!('-', '>'),\n+            LArrow => op!('<', '-'),\n+            FatArrow => op!('=', '>'),\n+            Pound => op!('#'),\n+            Dollar => op!('$'),\n+            Question => op!('?'),\n+            SingleQuote => op!('\\''),\n+\n+            Ident(ident, false) => tt!(self::Ident::new(&ident.as_str(), Span(span))),\n+            Ident(ident, true) => tt!(self::Ident::new_raw(&ident.as_str(), Span(span))),\n+            Lifetime(ident) => {\n+                let ident = ident.without_first_quote();\n+                stack.push(tt!(self::Ident::new(&ident.as_str(), Span(span))));\n+                tt!(Punct::new('\\'', Spacing::Joint))\n+            }\n+            Literal(lit, suffix) => tt!(self::Literal {\n+                lit,\n+                suffix,\n+                span: Span(span)\n+            }),\n+            DocComment(c) => {\n+                let style = comments::doc_comment_style(&c.as_str());\n+                let stripped = comments::strip_doc_comment_decoration(&c.as_str());\n+                let stream = vec![\n+                    tt!(self::Ident::new(\"doc\", Span(span))),\n+                    tt!(Punct::new('=', Spacing::Alone)),\n+                    tt!(self::Literal::string(&stripped)),\n+                ].into_iter()\n+                    .collect();\n+                stack.push(tt!(Group::new(Delimiter::Bracket, stream)));\n+                if style == ast::AttrStyle::Inner {\n+                    stack.push(tt!(Punct::new('!', Spacing::Alone)));\n+                }\n+                tt!(Punct::new('#', Spacing::Alone))\n+            }\n+\n+            Interpolated(_) => __internal::with_sess(|sess, _| {\n+                let tts = token.interpolated_to_tokenstream(sess, span);\n+                tt!(Group::new(Delimiter::None, ::TokenStream(tts)))\n+            }),\n+\n+            DotEq => op!('.', '='),\n+            OpenDelim(..) | CloseDelim(..) => unreachable!(),\n+            Whitespace | Comment | Shebang(..) | Eof => unreachable!(),\n+        }\n+    }\n+\n+    pub(crate) fn to_internal(self) -> tokenstream::TokenStream {\n+        use syntax::parse::token::*;\n+        use syntax::tokenstream::{Delimited, TokenTree};\n+\n+        let (ch, kind, span) = match self {\n+            self::TokenTree::Punct(tt) => (tt.as_char(), tt.spacing(), tt.span()),\n+            self::TokenTree::Group(tt) => {\n+                return TokenTree::Delimited(\n+                    tt.span.0,\n+                    Delimited {\n+                        delim: tt.delimiter.to_internal(),\n+                        tts: tt.stream.0.into(),\n+                    },\n+                ).into();\n+            }\n+            self::TokenTree::Ident(tt) => {\n+                let token = Ident(ast::Ident::new(tt.sym, tt.span.0), tt.is_raw);\n+                return TokenTree::Token(tt.span.0, token).into();\n+            }\n+            self::TokenTree::Literal(self::Literal {\n+                lit: Lit::Integer(ref a),\n+                suffix,\n+                span,\n+            })\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let integer = Symbol::intern(&a.as_str()[1..]);\n+                let integer = Literal(Lit::Integer(integer), suffix);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, integer);\n+                return vec![a, b].into_iter().collect();\n+            }\n+            self::TokenTree::Literal(self::Literal {\n+                lit: Lit::Float(ref a),\n+                suffix,\n+                span,\n+            })\n+                if a.as_str().starts_with(\"-\") =>\n+            {\n+                let minus = BinOp(BinOpToken::Minus);\n+                let float = Symbol::intern(&a.as_str()[1..]);\n+                let float = Literal(Lit::Float(float), suffix);\n+                let a = TokenTree::Token(span.0, minus);\n+                let b = TokenTree::Token(span.0, float);\n+                return vec![a, b].into_iter().collect();\n+            }\n+            self::TokenTree::Literal(tt) => {\n+                let token = Literal(tt.lit, tt.suffix);\n+                return TokenTree::Token(tt.span.0, token).into();\n+            }\n+        };\n+\n+        let token = match ch {\n+            '=' => Eq,\n+            '<' => Lt,\n+            '>' => Gt,\n+            '!' => Not,\n+            '~' => Tilde,\n+            '+' => BinOp(Plus),\n+            '-' => BinOp(Minus),\n+            '*' => BinOp(Star),\n+            '/' => BinOp(Slash),\n+            '%' => BinOp(Percent),\n+            '^' => BinOp(Caret),\n+            '&' => BinOp(And),\n+            '|' => BinOp(Or),\n+            '@' => At,\n+            '.' => Dot,\n+            ',' => Comma,\n+            ';' => Semi,\n+            ':' => Colon,\n+            '#' => Pound,\n+            '$' => Dollar,\n+            '?' => Question,\n+            '\\'' => SingleQuote,\n+            _ => unreachable!(),\n+        };\n+\n+        let tree = TokenTree::Token(span.0, token);\n+        match kind {\n+            Spacing::Alone => tree.into(),\n+            Spacing::Joint => tree.joint(),\n+        }\n+    }\n+}\n+\n+impl Level {\n+    pub(crate) fn to_internal(self) -> errors::Level {\n+        match self {\n+            Level::Error => errors::Level::Error,\n+            Level::Warning => errors::Level::Warning,\n+            Level::Note => errors::Level::Note,\n+            Level::Help => errors::Level::Help,\n+            Level::__Nonexhaustive => unreachable!(\"Level::__Nonexhaustive\"),\n+        }\n+    }\n+}"}, {"sha": "9748e2947eebdc87307cff5f33317f6e1077e073", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bc2b21cc4e2679191b14ade2511e9015e717da53/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=bc2b21cc4e2679191b14ade2511e9015e717da53", "patch": "@@ -1775,12 +1775,6 @@ fn ident_continue(c: Option<char>) -> bool {\n     (c > '\\x7f' && c.is_xid_continue())\n }\n \n-// The string is a valid identifier or a lifetime identifier.\n-pub fn is_valid_ident(s: &str) -> bool {\n-    let mut chars = s.chars();\n-    ident_start(chars.next()) && chars.all(|ch| ident_continue(Some(ch)))\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}]}