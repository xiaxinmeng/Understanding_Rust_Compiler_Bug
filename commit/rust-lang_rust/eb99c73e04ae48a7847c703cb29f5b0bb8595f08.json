{"sha": "eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViOTljNzNlMDRhZTQ4YTc4NDdjNzAzY2IyOWY1YjBiYjg1OTVmMDg=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T10:36:56Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2019-11-12T15:02:00Z"}, "message": "Match constructor first in Constructor methods\n\nThis makes it easier to add new non-standard constructors, and this also\nensures that we don't forget cases when adding a new constructor.", "tree": {"sha": "56ac009db8920c5cd2c2b90b355e4e5ccc61e3cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/56ac009db8920c5cd2c2b90b355e4e5ccc61e3cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "html_url": "https://github.com/rust-lang/rust/commit/eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb99c73e04ae48a7847c703cb29f5b0bb8595f08/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e3d998492abd7d61aba12cfa058fce28c998a3ff", "url": "https://api.github.com/repos/rust-lang/rust/commits/e3d998492abd7d61aba12cfa058fce28c998a3ff", "html_url": "https://github.com/rust-lang/rust/commit/e3d998492abd7d61aba12cfa058fce28c998a3ff"}], "stats": {"total": 211, "additions": 105, "deletions": 106}, "files": [{"sha": "b19ddf7a77db8a180646014792ebf0566407ce23", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 105, "deletions": 106, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/eb99c73e04ae48a7847c703cb29f5b0bb8595f08/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb99c73e04ae48a7847c703cb29f5b0bb8595f08/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=eb99c73e04ae48a7847c703cb29f5b0bb8595f08", "patch": "@@ -781,65 +781,68 @@ impl<'tcx> Constructor<'tcx> {\n         ty: Ty<'tcx>,\n     ) -> Vec<Pat<'tcx>> {\n         debug!(\"wildcard_subpatterns({:#?}, {:?})\", self, ty);\n-        match ty.kind {\n-            ty::Tuple(ref fs) => {\n-                fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n-            }\n-            ty::Slice(ty) | ty::Array(ty, _) => match *self {\n-                FixedLenSlice(length) => (0..length).map(|_| Pat::wildcard_from_ty(ty)).collect(),\n-                VarLenSlice(prefix, suffix) => {\n-                    (0..prefix + suffix).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+\n+        match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => {\n+                    fs.into_iter().map(|t| t.expect_ty()).map(Pat::wildcard_from_ty).collect()\n                 }\n-                ConstantValue(..) => vec![],\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-            ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n-            ty::Adt(adt, substs) => {\n-                if adt.is_box() {\n-                    // Use T as the sub pattern type of Box<T>.\n-                    vec![Pat::wildcard_from_ty(substs.type_at(0))]\n-                } else {\n-                    let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n-                    let is_non_exhaustive =\n-                        variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n-                    variant\n-                        .fields\n-                        .iter()\n-                        .map(|field| {\n-                            let is_visible =\n-                                adt.is_enum() || field.vis.is_accessible_from(cx.module, cx.tcx);\n-                            let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n-                            match (is_visible, is_non_exhaustive, is_uninhabited) {\n-                                // Treat all uninhabited types in non-exhaustive variants as\n-                                // `TyErr`.\n-                                (_, true, true) => cx.tcx.types.err,\n-                                // Treat all non-visible fields as `TyErr`. They can't appear in\n-                                // any other pattern from this match (because they are private), so\n-                                // their type does not matter - but we don't want to know they are\n-                                // uninhabited.\n-                                (false, ..) => cx.tcx.types.err,\n-                                (true, ..) => {\n-                                    let ty = field.ty(cx.tcx, substs);\n-                                    match ty.kind {\n-                                        // If the field type returned is an array of an unknown\n-                                        // size return an TyErr.\n-                                        ty::Array(_, len)\n-                                            if len\n-                                                .try_eval_usize(cx.tcx, cx.param_env)\n-                                                .is_none() =>\n-                                        {\n-                                            cx.tcx.types.err\n+                ty::Ref(_, rty, _) => vec![Pat::wildcard_from_ty(rty)],\n+                ty::Adt(adt, substs) => {\n+                    if adt.is_box() {\n+                        // Use T as the sub pattern type of Box<T>.\n+                        vec![Pat::wildcard_from_ty(substs.type_at(0))]\n+                    } else {\n+                        let variant = &adt.variants[self.variant_index_for_adt(cx, adt)];\n+                        let is_non_exhaustive =\n+                            variant.is_field_list_non_exhaustive() && !cx.is_local(ty);\n+                        variant\n+                            .fields\n+                            .iter()\n+                            .map(|field| {\n+                                let is_visible = adt.is_enum()\n+                                    || field.vis.is_accessible_from(cx.module, cx.tcx);\n+                                let is_uninhabited = cx.is_uninhabited(field.ty(cx.tcx, substs));\n+                                match (is_visible, is_non_exhaustive, is_uninhabited) {\n+                                    // Treat all uninhabited types in non-exhaustive variants as\n+                                    // `TyErr`.\n+                                    (_, true, true) => cx.tcx.types.err,\n+                                    // Treat all non-visible fields as `TyErr`. They can't appear\n+                                    // in any other pattern from this match (because they are\n+                                    // private), so their type does not matter - but we don't want\n+                                    // to know they are uninhabited.\n+                                    (false, ..) => cx.tcx.types.err,\n+                                    (true, ..) => {\n+                                        let ty = field.ty(cx.tcx, substs);\n+                                        match ty.kind {\n+                                            // If the field type returned is an array of an unknown\n+                                            // size return an TyErr.\n+                                            ty::Array(_, len)\n+                                                if len\n+                                                    .try_eval_usize(cx.tcx, cx.param_env)\n+                                                    .is_none() =>\n+                                            {\n+                                                cx.tcx.types.err\n+                                            }\n+                                            _ => ty,\n                                         }\n-                                        _ => ty,\n                                     }\n                                 }\n-                            }\n-                        })\n-                        .map(Pat::wildcard_from_ty)\n-                        .collect()\n+                            })\n+                            .map(Pat::wildcard_from_ty)\n+                            .collect()\n+                    }\n                 }\n-            }\n-            _ => vec![],\n+                _ => vec![],\n+            },\n+            FixedLenSlice(_) | VarLenSlice(..) => match ty.kind {\n+                ty::Slice(ty) | ty::Array(ty, _) => {\n+                    let arity = self.arity(cx, ty);\n+                    (0..arity).map(|_| Pat::wildcard_from_ty(ty)).collect()\n+                }\n+                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+            },\n+            ConstantValue(..) | ConstantRange(..) => vec![],\n         }\n     }\n \n@@ -850,19 +853,19 @@ impl<'tcx> Constructor<'tcx> {\n     /// A struct pattern's arity is the number of fields it contains, etc.\n     fn arity<'a>(&self, cx: &MatchCheckCtxt<'a, 'tcx>, ty: Ty<'tcx>) -> u64 {\n         debug!(\"Constructor::arity({:#?}, {:?})\", self, ty);\n-        match ty.kind {\n-            ty::Tuple(ref fs) => fs.len() as u64,\n-            ty::Slice(..) | ty::Array(..) => match *self {\n-                FixedLenSlice(length) => length,\n-                VarLenSlice(prefix, suffix) => prefix + suffix,\n-                ConstantValue(..) => 0,\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+        match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Tuple(ref fs) => fs.len() as u64,\n+                ty::Slice(..) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n+                ty::Ref(..) => 1,\n+                ty::Adt(adt, _) => {\n+                    adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n+                }\n+                _ => 0,\n             },\n-            ty::Ref(..) => 1,\n-            ty::Adt(adt, _) => {\n-                adt.variants[self.variant_index_for_adt(cx, adt)].fields.len() as u64\n-            }\n-            _ => 0,\n+            FixedLenSlice(length) => *length,\n+            VarLenSlice(prefix, suffix) => prefix + suffix,\n+            ConstantValue(..) | ConstantRange(..) => 0,\n         }\n     }\n \n@@ -886,53 +889,49 @@ impl<'tcx> Constructor<'tcx> {\n         pats: impl IntoIterator<Item = Pat<'tcx>>,\n     ) -> Pat<'tcx> {\n         let mut subpatterns = pats.into_iter();\n-        let pat = match ty.kind {\n-            ty::Adt(..) | ty::Tuple(..) => {\n-                let subpatterns = subpatterns\n-                    .enumerate()\n-                    .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n-                    .collect();\n-\n-                if let ty::Adt(adt, substs) = ty.kind {\n-                    if adt.is_enum() {\n-                        PatKind::Variant {\n-                            adt_def: adt,\n-                            substs,\n-                            variant_index: self.variant_index_for_adt(cx, adt),\n-                            subpatterns,\n+\n+        let pat = match self {\n+            Single | Variant(_) => match ty.kind {\n+                ty::Adt(..) | ty::Tuple(..) => {\n+                    let subpatterns = subpatterns\n+                        .enumerate()\n+                        .map(|(i, p)| FieldPat { field: Field::new(i), pattern: p })\n+                        .collect();\n+\n+                    if let ty::Adt(adt, substs) = ty.kind {\n+                        if adt.is_enum() {\n+                            PatKind::Variant {\n+                                adt_def: adt,\n+                                substs,\n+                                variant_index: self.variant_index_for_adt(cx, adt),\n+                                subpatterns,\n+                            }\n+                        } else {\n+                            PatKind::Leaf { subpatterns }\n                         }\n                     } else {\n                         PatKind::Leaf { subpatterns }\n                     }\n-                } else {\n-                    PatKind::Leaf { subpatterns }\n                 }\n-            }\n-\n-            ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n-\n-            ty::Slice(_) | ty::Array(..) => match self {\n-                FixedLenSlice(_) => {\n-                    PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n-                }\n-                VarLenSlice(prefix_len, _suffix_len) => {\n-                    let prefix = subpatterns.by_ref().take(*prefix_len as usize).collect();\n-                    let suffix = subpatterns.collect();\n-                    let wild = Pat::wildcard_from_ty(ty);\n-                    PatKind::Slice { prefix, slice: Some(wild), suffix }\n-                }\n-                _ => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n-            },\n-\n-            _ => match *self {\n-                ConstantValue(value, _) => PatKind::Constant { value },\n-                ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n-                    lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n-                    hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n-                    end,\n-                }),\n+                ty::Ref(..) => PatKind::Deref { subpattern: subpatterns.nth(0).unwrap() },\n+                ty::Slice(_) | ty::Array(..) => bug!(\"bad slice pattern {:?} {:?}\", self, ty),\n                 _ => PatKind::Wild,\n             },\n+            FixedLenSlice(_) => {\n+                PatKind::Slice { prefix: subpatterns.collect(), slice: None, suffix: vec![] }\n+            }\n+            &VarLenSlice(prefix_len, _) => {\n+                let prefix = subpatterns.by_ref().take(prefix_len as usize).collect();\n+                let suffix = subpatterns.collect();\n+                let wild = Pat::wildcard_from_ty(ty);\n+                PatKind::Slice { prefix, slice: Some(wild), suffix }\n+            }\n+            &ConstantValue(value, _) => PatKind::Constant { value },\n+            &ConstantRange(lo, hi, ty, end, _) => PatKind::Range(PatRange {\n+                lo: ty::Const::from_bits(cx.tcx, lo, ty::ParamEnv::empty().and(ty)),\n+                hi: ty::Const::from_bits(cx.tcx, hi, ty::ParamEnv::empty().and(ty)),\n+                end,\n+            }),\n         };\n \n         Pat { ty, span: DUMMY_SP, kind: Box::new(pat) }"}]}