{"sha": "a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4Y2YzNDZiOTcyYjVlNzlhM2IxOGRlNWE3ZjcxZTQ5YTIyOGJlN2M=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-02-27T14:39:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-02-27T14:39:22Z"}, "message": "Merge #7566\n\n7566: Add benchmark tests for mbe r=matklad a=edwin0cheng\n\nThis PR add more real world tests dumped from `rust-analyzer analysis-stats .` to benchmark its performance.\r\n\r\ncc #7513\r\n\r\nr? @matklad \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "4a51bdb8a2d84cc0b02aa41ed1073a1a16c039b4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a51bdb8a2d84cc0b02aa41ed1073a1a16c039b4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgOlmaCRBK7hj4Ov3rIwAAdHIIADV3jD/ORMGglNqkPZwyTf7L\nsPiuZg9Oj29aRuRVqIs9up4LmfW89GXqxVsjFF4R8nkg5oGLDfCioImQceOy5UHr\noE4WmiNtLMQPMRxSC44dRWiWIx5FOLN+LS0NDPFoES0DdjCu1yvuQ2NmkP+iHz5m\nvOHckKYar130numbClggrIUtM07uzjjWXRMA7eS7qzycX+89yu4hi41PCTFHs9pv\nVCEzf0qH9BpVgrgp7CzYIh7HmcxPoN8Dx8355YTUhRzpegYj+9FL5A+jvuaeVGVP\nV3xUQ3m1G4wabdc39c+sJaqEr9/ufnaCITlSPvjGNk/djaCasmCLOZ/Oa18fa0Q=\n=SPQS\n-----END PGP SIGNATURE-----\n", "payload": "tree 4a51bdb8a2d84cc0b02aa41ed1073a1a16c039b4\nparent 4a24edd989720f1232d8f6a660d790ae77115964\nparent 23dbf36c7dfcbb43a0def2642287c2fb30864a07\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1614436762 +0000\ncommitter GitHub <noreply@github.com> 1614436762 +0000\n\nMerge #7566\n\n7566: Add benchmark tests for mbe r=matklad a=edwin0cheng\n\nThis PR add more real world tests dumped from `rust-analyzer analysis-stats .` to benchmark its performance.\r\n\r\ncc #7513\r\n\r\nr? @matklad \n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "html_url": "https://github.com/rust-lang/rust/commit/a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a24edd989720f1232d8f6a660d790ae77115964", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a24edd989720f1232d8f6a660d790ae77115964", "html_url": "https://github.com/rust-lang/rust/commit/4a24edd989720f1232d8f6a660d790ae77115964"}, {"sha": "23dbf36c7dfcbb43a0def2642287c2fb30864a07", "url": "https://api.github.com/repos/rust-lang/rust/commits/23dbf36c7dfcbb43a0def2642287c2fb30864a07", "html_url": "https://github.com/rust-lang/rust/commit/23dbf36c7dfcbb43a0def2642287c2fb30864a07"}], "stats": {"total": 783, "additions": 783, "deletions": 0}, "files": [{"sha": "dbd7a746ebe43b0a648d7d78c05525c009b68d8e", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "patch": "@@ -875,6 +875,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"log\",\n  \"parser\",\n+ \"profile\",\n  \"rustc-hash\",\n  \"smallvec\",\n  \"syntax\","}, {"sha": "bf89ed594f7070c5c234dea8d72afa0578d097e6", "filename": "bench_data/numerous_macro_rules", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/bench_data%2Fnumerous_macro_rules", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/bench_data%2Fnumerous_macro_rules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bench_data%2Fnumerous_macro_rules?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c"}, {"sha": "0abba35845965601ee963913d6eb46ae24a75736", "filename": "crates/mbe/Cargo.toml", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2FCargo.toml?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "patch": "@@ -19,3 +19,6 @@ parser = { path = \"../parser\", version = \"0.0.0\" }\n tt = { path = \"../tt\", version = \"0.0.0\" }\n test_utils = { path = \"../test_utils\", version = \"0.0.0\" }\n \n+[dev-dependencies]\n+profile = { path = \"../profile\", version = \"0.0.0\" }\n+"}, {"sha": "0d0acd58977e3810c758604215339d1a0d14642f", "filename": "crates/mbe/src/benchmark.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2Fsrc%2Fbenchmark.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fbenchmark.rs?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "patch": "@@ -0,0 +1,211 @@\n+//! This module add real world mbe example for benchmark tests\n+\n+use rustc_hash::FxHashMap;\n+use syntax::{\n+    ast::{self, NameOwner},\n+    AstNode, SmolStr,\n+};\n+use test_utils::{bench, bench_fixture, skip_slow_tests};\n+\n+use crate::{\n+    ast_to_token_tree,\n+    parser::{Op, RepeatKind, Separator},\n+    MacroRules,\n+};\n+\n+#[test]\n+fn benchmark_parse_macro_rules() {\n+    if skip_slow_tests() {\n+        return;\n+    }\n+    let rules = macro_rules_fixtures_tt();\n+    let hash: usize = {\n+        let _pt = bench(\"mbe parse macro rules\");\n+        rules.values().map(|it| MacroRules::parse(it).unwrap().rules.len()).sum()\n+    };\n+    assert_eq!(hash, 1144);\n+}\n+\n+#[test]\n+fn benchmark_expand_macro_rules() {\n+    if skip_slow_tests() {\n+        return;\n+    }\n+    let rules = macro_rules_fixtures();\n+    let invocations = invocation_fixtures(&rules);\n+\n+    let hash: usize = {\n+        let _pt = bench(\"mbe expand macro rules\");\n+        invocations\n+            .into_iter()\n+            .map(|(id, tt)| {\n+                let res = rules[&id].expand(&tt);\n+                if res.err.is_some() {\n+                    // FIXME:\n+                    // Currently `invocation_fixtures` will generate some correct invocations but\n+                    // cannot be expanded by mbe. We ignore errors here.\n+                    // See: https://github.com/rust-analyzer/rust-analyzer/issues/4777\n+                    eprintln!(\"err from {} {:?}\", id, res.err);\n+                }\n+                res.value.token_trees.len()\n+            })\n+            .sum()\n+    };\n+    assert_eq!(hash, 66995);\n+}\n+\n+fn macro_rules_fixtures() -> FxHashMap<String, MacroRules> {\n+    macro_rules_fixtures_tt()\n+        .into_iter()\n+        .map(|(id, tt)| (id, MacroRules::parse(&tt).unwrap()))\n+        .collect()\n+}\n+\n+fn macro_rules_fixtures_tt() -> FxHashMap<String, tt::Subtree> {\n+    let fixture = bench_fixture::numerous_macro_rules();\n+    let source_file = ast::SourceFile::parse(&fixture).ok().unwrap();\n+\n+    source_file\n+        .syntax()\n+        .descendants()\n+        .filter_map(ast::MacroRules::cast)\n+        .map(|rule| {\n+            let id = rule.name().unwrap().to_string();\n+            let (def_tt, _) = ast_to_token_tree(&rule.token_tree().unwrap()).unwrap();\n+            (id, def_tt)\n+        })\n+        .collect()\n+}\n+\n+// Generate random invocation fixtures from rules\n+fn invocation_fixtures(rules: &FxHashMap<String, MacroRules>) -> Vec<(String, tt::Subtree)> {\n+    let mut seed = 123456789;\n+    let mut res = Vec::new();\n+\n+    for (name, it) in rules {\n+        for rule in &it.rules {\n+            // Generate twice\n+            for _ in 0..2 {\n+                let mut subtree = tt::Subtree::default();\n+                for op in rule.lhs.iter() {\n+                    collect_from_op(op, &mut subtree, &mut seed);\n+                }\n+                res.push((name.clone(), subtree));\n+            }\n+        }\n+    }\n+    return res;\n+\n+    fn collect_from_op(op: &Op, parent: &mut tt::Subtree, seed: &mut usize) {\n+        return match op {\n+            Op::Var { kind, .. } => match kind.as_ref().map(|it| it.as_str()) {\n+                Some(\"ident\") => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(\"ty\") => parent.token_trees.push(make_ident(\"Foo\")),\n+                Some(\"tt\") => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(\"vis\") => parent.token_trees.push(make_ident(\"pub\")),\n+                Some(\"pat\") => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(\"path\") => parent.token_trees.push(make_ident(\"foo\")),\n+                Some(\"literal\") => parent.token_trees.push(make_literal(\"1\")),\n+                Some(\"expr\") => parent.token_trees.push(make_ident(\"foo\").into()),\n+                Some(\"lifetime\") => {\n+                    parent.token_trees.push(make_punct('\\''));\n+                    parent.token_trees.push(make_ident(\"a\"));\n+                }\n+                Some(\"block\") => {\n+                    parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None))\n+                }\n+                Some(\"item\") => {\n+                    parent.token_trees.push(make_ident(\"fn\"));\n+                    parent.token_trees.push(make_ident(\"foo\"));\n+                    parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n+                    parent.token_trees.push(make_subtree(tt::DelimiterKind::Brace, None));\n+                }\n+                Some(\"meta\") => {\n+                    parent.token_trees.push(make_ident(\"foo\"));\n+                    parent.token_trees.push(make_subtree(tt::DelimiterKind::Parenthesis, None));\n+                }\n+\n+                None => (),\n+                Some(kind) => panic!(\"Unhandled kind {}\", kind),\n+            },\n+            Op::Leaf(leaf) => parent.token_trees.push(leaf.clone().into()),\n+            Op::Repeat { tokens, kind, separator } => {\n+                let max = 10;\n+                let cnt = match kind {\n+                    RepeatKind::ZeroOrMore => rand(seed) % max,\n+                    RepeatKind::OneOrMore => 1 + rand(seed) % max,\n+                    RepeatKind::ZeroOrOne => rand(seed) % 2,\n+                };\n+                for i in 0..cnt {\n+                    for it in tokens.iter() {\n+                        collect_from_op(it, parent, seed);\n+                    }\n+                    if i + 1 != cnt {\n+                        if let Some(sep) = separator {\n+                            match sep {\n+                                Separator::Literal(it) => parent\n+                                    .token_trees\n+                                    .push(tt::Leaf::Literal(it.clone().into()).into()),\n+                                Separator::Ident(it) => parent\n+                                    .token_trees\n+                                    .push(tt::Leaf::Ident(it.clone().into()).into()),\n+                                Separator::Puncts(puncts) => {\n+                                    for it in puncts {\n+                                        parent\n+                                            .token_trees\n+                                            .push(tt::Leaf::Punct(it.clone().into()).into())\n+                                    }\n+                                }\n+                            };\n+                        }\n+                    }\n+                }\n+            }\n+            Op::Subtree { tokens, delimiter } => {\n+                let mut subtree =\n+                    tt::Subtree { delimiter: delimiter.clone(), token_trees: Vec::new() };\n+                tokens.iter().for_each(|it| {\n+                    collect_from_op(it, &mut subtree, seed);\n+                });\n+                parent.token_trees.push(subtree.into());\n+            }\n+        };\n+\n+        // Simple linear congruential generator for determistic result\n+        fn rand(seed: &mut usize) -> usize {\n+            let a = 1664525;\n+            let c = 1013904223;\n+            *seed = usize::wrapping_add(usize::wrapping_mul(*seed, a), c);\n+            return *seed;\n+        };\n+        fn make_ident(ident: &str) -> tt::TokenTree {\n+            tt::Leaf::Ident(tt::Ident { id: tt::TokenId::unspecified(), text: SmolStr::new(ident) })\n+                .into()\n+        }\n+        fn make_punct(char: char) -> tt::TokenTree {\n+            tt::Leaf::Punct(tt::Punct {\n+                id: tt::TokenId::unspecified(),\n+                char,\n+                spacing: tt::Spacing::Alone,\n+            })\n+            .into()\n+        }\n+        fn make_literal(lit: &str) -> tt::TokenTree {\n+            tt::Leaf::Literal(tt::Literal {\n+                id: tt::TokenId::unspecified(),\n+                text: SmolStr::new(lit),\n+            })\n+            .into()\n+        }\n+        fn make_subtree(\n+            kind: tt::DelimiterKind,\n+            token_trees: Option<Vec<tt::TokenTree>>,\n+        ) -> tt::TokenTree {\n+            tt::Subtree {\n+                delimiter: Some(tt::Delimiter { id: tt::TokenId::unspecified(), kind }),\n+                token_trees: token_trees.unwrap_or_default(),\n+            }\n+            .into()\n+        }\n+    }\n+}"}, {"sha": "6b4a4eb53e28b049407d4188b2626ed11fb1e6ea", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "patch": "@@ -12,6 +12,9 @@ mod subtree_source;\n #[cfg(test)]\n mod tests;\n \n+#[cfg(test)]\n+mod benchmark;\n+\n use std::fmt;\n \n use test_utils::mark;"}, {"sha": "d775e2cc9db3a68c5d834866ae9e1a60530da429", "filename": "crates/test_utils/src/bench_fixture.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Ftest_utils%2Fsrc%2Fbench_fixture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a8cf346b972b5e79a3b18de5a7f71e49a228be7c/crates%2Ftest_utils%2Fsrc%2Fbench_fixture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fbench_fixture.rs?ref=a8cf346b972b5e79a3b18de5a7f71e49a228be7c", "patch": "@@ -35,3 +35,8 @@ pub fn glorious_old_parser() -> String {\n     let path = project_dir().join(\"bench_data/glorious_old_parser\");\n     fs::read_to_string(&path).unwrap()\n }\n+\n+pub fn numerous_macro_rules() -> String {\n+    let path = project_dir().join(\"bench_data/numerous_macro_rules\");\n+    fs::read_to_string(&path).unwrap()\n+}"}]}