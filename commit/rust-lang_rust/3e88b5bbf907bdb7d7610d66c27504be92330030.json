{"sha": "3e88b5bbf907bdb7d7610d66c27504be92330030", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlODhiNWJiZjkwN2JkYjdkNzYxMGQ2NmMyNzUwNGJlOTIzMzAwMzA=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-11T15:28:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-12T18:29:51Z"}, "message": "Rote changes to fix fallout throughout the compiler from splitting the\npredicates and renaming some things.", "tree": {"sha": "5410d982cad54118f93fe1788a7158e3f754fef1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5410d982cad54118f93fe1788a7158e3f754fef1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e88b5bbf907bdb7d7610d66c27504be92330030", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e88b5bbf907bdb7d7610d66c27504be92330030", "html_url": "https://github.com/rust-lang/rust/commit/3e88b5bbf907bdb7d7610d66c27504be92330030", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e88b5bbf907bdb7d7610d66c27504be92330030/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3764699c83387df254f220b4c85121010413aeff", "url": "https://api.github.com/repos/rust-lang/rust/commits/3764699c83387df254f220b4c85121010413aeff", "html_url": "https://github.com/rust-lang/rust/commit/3764699c83387df254f220b4c85121010413aeff"}], "stats": {"total": 329, "additions": 180, "deletions": 149}, "files": [{"sha": "395e486059eff8f9f1337802f3578a15c1c78d9a", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -283,7 +283,7 @@ pub fn overlapping_impls(infcx: &InferCtxt,\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n-                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> PredicateObligations<'tcx>\n {\n     util::predicates_for_generics(tcx, cause, 0, generic_bounds)"}, {"sha": "b2701ae875c0cb51cc1b914236bda73260b64e1a", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -130,7 +130,10 @@ fn trait_has_sized_self<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // Search for a predicate like `Self : Sized` amongst the trait bounds.\n     let trait_def = ty::lookup_trait_def(tcx, trait_def_id);\n     let free_substs = ty::construct_free_substs(tcx, &trait_def.generics, ast::DUMMY_NODE_ID);\n-    let predicates = trait_def.generics.to_bounds(tcx, &free_substs).predicates.into_vec();\n+\n+    let trait_predicates = ty::lookup_predicates(tcx, trait_def_id);\n+    let predicates = trait_predicates.instantiate(tcx, &free_substs).predicates.into_vec();\n+\n     elaborate_predicates(tcx, predicates)\n         .any(|predicate| {\n             match predicate {"}, {"sha": "13f309e129ac9c9a63bd613cd9a5235211323bec", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -561,8 +561,8 @@ fn assemble_candidates_from_trait_def<'cx,'tcx>(\n     };\n \n     // If so, extract what we know from the trait and try to come up with a good answer.\n-    let trait_def = ty::lookup_trait_def(selcx.tcx(), trait_ref.def_id);\n-    let bounds = trait_def.generics.to_bounds(selcx.tcx(), trait_ref.substs);\n+    let trait_predicates = ty::lookup_predicates(selcx.tcx(), trait_ref.def_id);\n+    let bounds = trait_predicates.instantiate(selcx.tcx(), trait_ref.substs);\n     assemble_candidates_from_predicates(selcx, obligation, obligation_trait_ref,\n                                         candidate_set, bounds.predicates.into_vec());\n }"}, {"sha": "5f659aa303e90fd44f7d6d9acbc36dc3a7985191", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -923,8 +923,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 projection_trait_ref={}\",\n                projection_trait_ref.repr(self.tcx()));\n \n-        let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n-        let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+        let trait_predicates = ty::lookup_predicates(self.tcx(), projection_trait_ref.def_id);\n+        let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n         debug!(\"match_projection_obligation_against_bounds_from_trait: \\\n                 bounds={}\",\n                bounds.repr(self.tcx()));\n@@ -2314,8 +2314,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         snapshot: &infer::CombinedSnapshot)\n                         -> VecPerParamSpace<PredicateObligation<'tcx>>\n     {\n-        let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n-        let bounds = impl_generics.to_bounds(self.tcx(), impl_substs);\n+        let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+        let bounds = impl_bounds.instantiate(self.tcx(), impl_substs);\n         let normalized_bounds =\n             project::normalize_with_depth(self, cause.clone(), recursion_depth, &bounds);\n         let normalized_bounds ="}, {"sha": "6c54da1c134f5c63c01086e7090ecccab78c9806", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -290,7 +290,7 @@ impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                      cause: ObligationCause<'tcx>,\n                                      recursion_depth: uint,\n-                                     generic_bounds: &ty::GenericBounds<'tcx>)\n+                                     generic_bounds: &ty::InstantiatedPredicates<'tcx>)\n                                      -> VecPerParamSpace<PredicateObligation<'tcx>>\n {\n     debug!(\"predicates_for_generics(generic_bounds={})\","}, {"sha": "6026359ddace071f5091598c88b824b3c98a6d57", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 21, "deletions": 10, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -2153,10 +2153,12 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n+                                let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n                                     method.span,\n                                     method_generics,\n+                                    method_bounds,\n                                     method.pe_body().id)\n                             }\n                             TypeTraitItem(_) => {\n@@ -2188,10 +2190,12 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                         match ty::impl_or_trait_item(cx, method_def_id) {\n                             MethodTraitItem(ref method_ty) => {\n                                 let method_generics = &method_ty.generics;\n+                                let method_bounds = &method_ty.predicates;\n                                 construct_parameter_environment(\n                                     cx,\n                                     method.span,\n                                     method_generics,\n+                                    method_bounds,\n                                     method.pe_body().id)\n                             }\n                             TypeTraitItem(_) => {\n@@ -2214,11 +2218,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemFn(_, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = ast_util::local_def(id);\n-                        let fn_pty = ty::lookup_item_type(cx, fn_def_id);\n+                        let fn_scheme = lookup_item_type(cx, fn_def_id);\n+                        let fn_predicates = lookup_predicates(cx, fn_def_id);\n \n                         construct_parameter_environment(cx,\n                                                         item.span,\n-                                                        &fn_pty.generics,\n+                                                        &fn_scheme.generics,\n+                                                        &fn_predicates,\n                                                         body.id)\n                     }\n                     ast::ItemEnum(..) |\n@@ -2227,8 +2233,13 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                     ast::ItemConst(..) |\n                     ast::ItemStatic(..) => {\n                         let def_id = ast_util::local_def(id);\n-                        let pty = ty::lookup_item_type(cx, def_id);\n-                        construct_parameter_environment(cx, item.span, &pty.generics, id)\n+                        let scheme = lookup_item_type(cx, def_id);\n+                        let predicates = lookup_predicates(cx, def_id);\n+                        construct_parameter_environment(cx,\n+                                                        item.span,\n+                                                        &scheme.generics,\n+                                                        &predicates,\n+                                                        id)\n                     }\n                     _ => {\n                         cx.sess.span_bug(item.span,\n@@ -6320,7 +6331,7 @@ pub fn empty_parameter_environment<'a,'tcx>(cx: &'a ctxt<'tcx>) -> ParameterEnvi\n /// parameters in the same way, this only has an effect on regions.\n pub fn construct_free_substs<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n-    generics: &ty::Generics<'tcx>,\n+    generics: &Generics<'tcx>,\n     free_id: ast::NodeId)\n     -> Substs<'tcx>\n {\n@@ -6365,6 +6376,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     tcx: &'a ctxt<'tcx>,\n     span: Span,\n     generics: &ty::Generics<'tcx>,\n+    generic_predicates: &ty::GenericPredicates<'tcx>,\n     free_id: ast::NodeId)\n     -> ParameterEnvironment<'a, 'tcx>\n {\n@@ -6379,7 +6391,7 @@ pub fn construct_parameter_environment<'a,'tcx>(\n     // Compute the bounds on Self and the type parameters.\n     //\n \n-    let bounds = generics.to_bounds(tcx, &free_substs);\n+    let bounds = generic_predicates.instantiate(tcx, &free_substs);\n     let bounds = liberate_late_bound_regions(tcx, free_id_outlive, &ty::Binder(bounds));\n     let predicates = bounds.predicates.into_vec();\n \n@@ -7013,8 +7025,7 @@ impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n \n impl<'tcx> RegionEscape for TypeScheme<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n-        self.ty.has_regions_escaping_depth(depth) ||\n-            self.generics.has_regions_escaping_depth(depth)\n+        self.ty.has_regions_escaping_depth(depth)\n     }\n }\n \n@@ -7024,7 +7035,7 @@ impl RegionEscape for Region {\n     }\n }\n \n-impl<'tcx> RegionEscape for Generics<'tcx> {\n+impl<'tcx> RegionEscape for GenericPredicates<'tcx> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.predicates.has_regions_escaping_depth(depth)\n     }\n@@ -7133,7 +7144,7 @@ impl<'tcx> HasProjectionTypes for ClosureUpvar<'tcx> {\n     }\n }\n \n-impl<'tcx> HasProjectionTypes for ty::GenericBounds<'tcx> {\n+impl<'tcx> HasProjectionTypes for ty::InstantiatedPredicates<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.predicates.has_projection_types()\n     }"}, {"sha": "645a7ab9440b9908520a87f0920487ac181ae3a8", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -400,6 +400,13 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Generics<'tcx> {\n         ty::Generics {\n             types: self.types.fold_with(folder),\n             regions: self.regions.fold_with(folder),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericPredicates<'tcx> {\n+        ty::GenericPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }\n@@ -440,9 +447,9 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::GenericBounds<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::GenericBounds<'tcx> {\n-        ty::GenericBounds {\n+impl<'tcx> TypeFoldable<'tcx> for ty::InstantiatedPredicates<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::InstantiatedPredicates<'tcx> {\n+        ty::InstantiatedPredicates {\n             predicates: self.predicates.fold_with(folder),\n         }\n     }"}, {"sha": "3ea2743c63e6ce466c6417b8850a04838debe36c", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -467,8 +467,14 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n         }\n     };\n \n-    instantiate_path(pcx.fcx, path, ty::lookup_item_type(tcx, enum_def_id),\n-                     None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx,\n+                     path,\n+                     ty::lookup_item_type(tcx, enum_def_id),\n+                     &ty::lookup_predicates(tcx, enum_def_id),\n+                     None,\n+                     def,\n+                     pat.span,\n+                     pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n@@ -499,6 +505,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         .map_or_else(|| def.def_id(), |(enum_def, _)| enum_def);\n \n     let ctor_scheme = ty::lookup_item_type(tcx, enum_def);\n+    let ctor_predicates = ty::lookup_predicates(tcx, enum_def);\n     let path_scheme = if ty::is_fn_ty(ctor_scheme.ty) {\n         let fn_ret = ty::assert_no_late_bound_regions(tcx, &ty::ty_fn_ret(ctor_scheme.ty));\n         ty::TypeScheme {\n@@ -508,7 +515,7 @@ pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n     } else {\n         ctor_scheme\n     };\n-    instantiate_path(pcx.fcx, path, path_scheme, None, def, pat.span, pat.id);\n+    instantiate_path(pcx.fcx, path, path_scheme, &ctor_predicates, None, def, pat.span, pat.id);\n \n     let pat_ty = fcx.node_ty(pat.id);\n     demand::eqtype(fcx, pat.span, expected, pat_ty);"}, {"sha": "1e1d7e0926038ee833713e13e6f1ca8b7928bbae", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -205,7 +205,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // however, because we want to replace all late-bound regions with\n     // region variables.\n     let impl_bounds =\n-        impl_m.generics.to_bounds(tcx, impl_to_skol_substs);\n+        impl_m.predicates.instantiate(tcx, impl_to_skol_substs);\n \n     let (impl_bounds, _) =\n         infcx.replace_late_bound_regions_with_fresh_var(\n@@ -216,7 +216,7 @@ pub fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n            impl_bounds.repr(tcx));\n \n     // Normalize the associated types in the trait_bounds.\n-    let trait_bounds = trait_m.generics.to_bounds(tcx, &trait_to_skol_substs);\n+    let trait_bounds = trait_m.predicates.instantiate(tcx, &trait_to_skol_substs);\n \n     // Obtain the predicate split predicate sets for each.\n     let trait_pred = trait_bounds.predicates.split();"}, {"sha": "ce67369ca9dda132ecfa707b24b6c0ea8d9cc0be", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -131,8 +131,9 @@ fn iterate_over_potentially_unsafe_regions_in_type<'a, 'tcx>(\n \n             let dtor_typescheme = ty::lookup_item_type(rcx.tcx(), impl_did);\n             let dtor_generics = dtor_typescheme.generics;\n+            let dtor_predicates = ty::lookup_predicates(rcx.tcx(), impl_did);\n \n-            let has_pred_of_interest = dtor_generics.predicates.iter().any(|pred| {\n+            let has_pred_of_interest = dtor_predicates.predicates.iter().any(|pred| {\n                 // In `impl<T> Drop where ...`, we automatically\n                 // assume some predicate will be meaningful and thus\n                 // represents a type through which we could reach"}, {"sha": "dfbfc86c659704db316a77dc8f6cf8347126676a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -46,7 +46,7 @@ struct InstantiatedMethodSig<'tcx> {\n \n     /// Generic bounds on the method's parameters which must be added\n     /// as pending obligations.\n-    method_bounds: ty::GenericBounds<'tcx>,\n+    method_predicates: ty::InstantiatedPredicates<'tcx>,\n }\n \n pub fn confirm<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n@@ -99,15 +99,15 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n \n         // Create the final signature for the method, replacing late-bound regions.\n         let InstantiatedMethodSig {\n-            method_sig, all_substs, method_bounds\n+            method_sig, all_substs, method_predicates\n         } = self.instantiate_method_sig(&pick, all_substs);\n         let method_self_ty = method_sig.inputs[0];\n \n         // Unify the (adjusted) self type with what the method expects.\n         self.unify_receivers(self_ty, method_self_ty);\n \n         // Add any trait/regions obligations specified on the method's type parameters.\n-        self.add_obligations(&pick, &all_substs, &method_bounds);\n+        self.add_obligations(&pick, &all_substs, &method_predicates);\n \n         // Create the final `MethodCallee`.\n         let fty = ty::mk_bare_fn(self.tcx(), None, self.tcx().mk_bare_fn(ty::BareFnTy {\n@@ -416,18 +416,19 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         // that obligation is not necessarily satisfied. (In the\n         // future, it would be.) But we know that the true `Self` DOES implement\n         // the trait. So we just delete this requirement. Hack hack hack.\n-        let mut method_bounds = pick.method_ty.generics.to_bounds(self.tcx(), &all_substs);\n+        let mut method_predicates = pick.method_ty.predicates.instantiate(self.tcx(), &all_substs);\n         match pick.kind {\n             probe::ObjectPick(..) => {\n-                assert_eq!(method_bounds.predicates.get_slice(subst::SelfSpace).len(), 1);\n-                method_bounds.predicates.pop(subst::SelfSpace);\n+                assert_eq!(method_predicates.predicates.get_slice(subst::SelfSpace).len(), 1);\n+                method_predicates.predicates.pop(subst::SelfSpace);\n             }\n             _ => { }\n         }\n-        let method_bounds = self.fcx.normalize_associated_types_in(self.span, &method_bounds);\n+        let method_predicates = self.fcx.normalize_associated_types_in(self.span,\n+                                                                       &method_predicates);\n \n-        debug!(\"method_bounds after subst = {}\",\n-               method_bounds.repr(self.tcx()));\n+        debug!(\"method_predicates after subst = {}\",\n+               method_predicates.repr(self.tcx()));\n \n         // Instantiate late-bound regions and substitute the trait\n         // parameters into the method type to get the actual method type.\n@@ -446,22 +447,22 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n         InstantiatedMethodSig {\n             method_sig: method_sig,\n             all_substs: all_substs,\n-            method_bounds: method_bounds,\n+            method_predicates: method_predicates,\n         }\n     }\n \n     fn add_obligations(&mut self,\n                        pick: &probe::Pick<'tcx>,\n                        all_substs: &subst::Substs<'tcx>,\n-                       method_bounds: &ty::GenericBounds<'tcx>) {\n-        debug!(\"add_obligations: pick={} all_substs={} method_bounds={}\",\n+                       method_predicates: &ty::InstantiatedPredicates<'tcx>) {\n+        debug!(\"add_obligations: pick={} all_substs={} method_predicates={}\",\n                pick.repr(self.tcx()),\n                all_substs.repr(self.tcx()),\n-               method_bounds.repr(self.tcx()));\n+               method_predicates.repr(self.tcx()));\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::misc(self.span, self.fcx.body_id),\n-            method_bounds);\n+            method_predicates);\n \n         self.fcx.add_default_region_param_bounds(\n             all_substs,"}, {"sha": "55b4dae5b9eb1a4865aa9e38825bc5af4439ff04", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -221,7 +221,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     //\n     // Note that as the method comes from a trait, it should not have\n     // any late-bound regions appearing in its bounds.\n-    let method_bounds = fcx.instantiate_bounds(span, trait_ref.substs, &method_ty.generics);\n+    let method_bounds = fcx.instantiate_bounds(span, trait_ref.substs, &method_ty.predicates);\n     assert!(!method_bounds.has_escaping_regions());\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::misc(span, fcx.body_id),"}, {"sha": "82bd4ae87ffae8d9cecefac8af626982caa1c848", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -666,8 +666,9 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n                    projection_trait_ref.repr(self.tcx()));\n \n-            let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n-            let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+            let trait_predicates = ty::lookup_predicates(self.tcx(),\n+                                                         projection_trait_ref.def_id);\n+            let bounds = trait_predicates.instantiate(self.tcx(), projection_trait_ref.substs);\n             let predicates = bounds.predicates.into_vec();\n             debug!(\"assemble_projection_candidates: predicates={}\",\n                    predicates.repr(self.tcx()));\n@@ -943,8 +944,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     let cause = traits::ObligationCause::misc(self.span, self.fcx.body_id);\n \n                     // Check whether the impl imposes obligations we have to worry about.\n-                    let impl_generics = ty::lookup_item_type(self.tcx(), impl_def_id).generics;\n-                    let impl_bounds = impl_generics.to_bounds(self.tcx(), substs);\n+                    let impl_bounds = ty::lookup_predicates(self.tcx(), impl_def_id);\n+                    let impl_bounds = impl_bounds.instantiate(self.tcx(), substs);\n                     let traits::Normalized { value: impl_bounds,\n                                              obligations: norm_obligations } =\n                         traits::normalize(selcx, cause.clone(), &impl_bounds);"}, {"sha": "00bc3375fdd9f954bdea76576ac8575e37d57c5f", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 53, "deletions": 59, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -93,15 +93,15 @@ use middle::pat_util::{self, pat_id_map};\n use middle::region::{self, CodeExtent};\n use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n-use middle::ty::{FnSig, VariantInfo, TypeScheme};\n+use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n-use {CrateCtxt, lookup_def_ccx, no_params, require_same_types};\n+use {CrateCtxt, lookup_def_ccx, require_same_types};\n use TypeAndSubsts;\n use lint;\n use util::common::{block_query, indenter, loop_query};\n@@ -1446,11 +1446,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     fn instantiate_bounds(&self,\n                           span: Span,\n                           substs: &Substs<'tcx>,\n-                          generics: &ty::Generics<'tcx>)\n-                          -> ty::GenericBounds<'tcx>\n+                          bounds: &ty::GenericPredicates<'tcx>)\n+                          -> ty::InstantiatedPredicates<'tcx>\n     {\n-        ty::GenericBounds {\n-            predicates: self.instantiate_type_scheme(span, substs, &generics.predicates)\n+        ty::InstantiatedPredicates {\n+            predicates: self.instantiate_type_scheme(span, substs, &bounds.predicates)\n         }\n     }\n \n@@ -1561,12 +1561,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let type_scheme =\n             ty::lookup_item_type(self.tcx(), def_id);\n+        let type_predicates =\n+            ty::lookup_predicates(self.tcx(), def_id);\n         let substs =\n             self.infcx().fresh_substs_for_generics(\n                 span,\n                 &type_scheme.generics);\n         let bounds =\n-            self.instantiate_bounds(span, &substs, &type_scheme.generics);\n+            self.instantiate_bounds(span, &substs, &type_predicates);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n                 span,\n@@ -1594,7 +1596,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     {\n         let tcx = self.tcx();\n \n-        let ty::TypeScheme { generics, ty: decl_ty } = ty::lookup_item_type(tcx, did);\n+        let ty::TypeScheme { generics, ty: decl_ty } =\n+            ty::lookup_item_type(tcx, did);\n \n         let wants_params =\n             generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n@@ -1843,16 +1846,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// and `T`. This routine will add a region obligation `$1:'$0` and register it locally.\n     pub fn add_obligations_for_parameters(&self,\n                                           cause: traits::ObligationCause<'tcx>,\n-                                          generic_bounds: &ty::GenericBounds<'tcx>)\n+                                          predicates: &ty::InstantiatedPredicates<'tcx>)\n     {\n-        assert!(!generic_bounds.has_escaping_regions());\n+        assert!(!predicates.has_escaping_regions());\n \n-        debug!(\"add_obligations_for_parameters(generic_bounds={})\",\n-               generic_bounds.repr(self.tcx()));\n+        debug!(\"add_obligations_for_parameters(predicates={})\",\n+               predicates.repr(self.tcx()));\n \n         let obligations = traits::predicates_for_generics(self.tcx(),\n                                                           cause,\n-                                                          generic_bounds);\n+                                                          predicates);\n \n         obligations.map_move(|o| self.register_predicate(o));\n     }\n@@ -3616,8 +3619,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprPath(ref path) => {\n           let defn = lookup_def(fcx, path.span, id);\n-          let pty = type_scheme_for_def(fcx, expr.span, defn);\n-          instantiate_path(fcx, path, pty, None, defn, expr.span, expr.id);\n+          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n+          instantiate_path(fcx, path, scheme, &predicates, None, defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -3629,10 +3632,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           astconv::instantiate_trait_ref(fcx, fcx, &*qpath.trait_ref, Some(self_ty), None);\n \n           let defn = lookup_def(fcx, expr.span, id);\n-          let pty = type_scheme_for_def(fcx, expr.span, defn);\n+          let (scheme, predicates) = type_scheme_and_predicates_for_def(fcx, expr.span, defn);\n           let mut path = qpath.trait_ref.path.clone();\n           path.segments.push(qpath.item_path.clone());\n-          instantiate_path(fcx, &path, pty, Some(self_ty), defn, expr.span, expr.id);\n+          instantiate_path(fcx, &path, scheme, &predicates, Some(self_ty), defn, expr.span, expr.id);\n \n           // We always require that the type provided as the value for\n           // a type parameter outlives the moment of instantiation.\n@@ -4048,9 +4051,9 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 };\n \n                 if let Some(did) = did {\n-                    let polytype = ty::lookup_item_type(tcx, did);\n+                    let predicates = ty::lookup_predicates(tcx, did);\n                     let substs = Substs::new_type(vec![idx_type], vec![]);\n-                    let bounds = fcx.instantiate_bounds(expr.span, &substs, &polytype.generics);\n+                    let bounds = fcx.instantiate_bounds(expr.span, &substs, &predicates);\n                     fcx.add_obligations_for_parameters(\n                         traits::ObligationCause::new(expr.span,\n                                                      fcx.body_id,\n@@ -4631,46 +4634,36 @@ pub fn lookup_def(fcx: &FnCtxt, sp: Span, id: ast::NodeId) -> def::Def {\n }\n \n // Returns the type parameter count and the type for the given definition.\n-pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                     sp: Span,\n-                                     defn: def::Def)\n-                                     -> TypeScheme<'tcx> {\n+fn type_scheme_and_predicates_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                                sp: Span,\n+                                                defn: def::Def)\n+                                                -> (TypeScheme<'tcx>, GenericPredicates<'tcx>) {\n     match defn {\n-      def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n-          let typ = fcx.local_ty(sp, nid);\n-          return no_params(typ);\n-      }\n-      def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n-      def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n-      def::DefStruct(id) | def::DefConst(id) => {\n-        return ty::lookup_item_type(fcx.ccx.tcx, id);\n-      }\n-      def::DefTrait(_) |\n-      def::DefTy(..) |\n-      def::DefAssociatedTy(..) |\n-      def::DefAssociatedPath(..) |\n-      def::DefPrimTy(_) |\n-      def::DefTyParam(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type\");\n-      }\n-      def::DefMod(..) | def::DefForeignMod(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found module\");\n-      }\n-      def::DefUse(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found use\");\n-      }\n-      def::DefRegion(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found region\");\n-      }\n-      def::DefTyParamBinder(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found type parameter\");\n-      }\n-      def::DefLabel(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found label\");\n-      }\n-      def::DefSelfTy(..) => {\n-        fcx.ccx.tcx.sess.span_bug(sp, \"expected value, found self ty\");\n-      }\n+        def::DefLocal(nid) | def::DefUpvar(nid, _) => {\n+            let typ = fcx.local_ty(sp, nid);\n+            (ty::TypeScheme { generics: ty::Generics::empty(), ty: typ },\n+             ty::GenericPredicates::empty())\n+        }\n+        def::DefFn(id, _) | def::DefStaticMethod(id, _) | def::DefMethod(id, _, _) |\n+        def::DefStatic(id, _) | def::DefVariant(_, id, _) |\n+        def::DefStruct(id) | def::DefConst(id) => {\n+            (ty::lookup_item_type(fcx.tcx(), id), ty::lookup_predicates(fcx.tcx(), id))\n+        }\n+        def::DefTrait(_) |\n+        def::DefTy(..) |\n+        def::DefAssociatedTy(..) |\n+        def::DefAssociatedPath(..) |\n+        def::DefPrimTy(_) |\n+        def::DefTyParam(..) |\n+        def::DefMod(..) |\n+        def::DefForeignMod(..) |\n+        def::DefUse(..) |\n+        def::DefRegion(..) |\n+        def::DefTyParamBinder(..) |\n+        def::DefLabel(..) |\n+        def::DefSelfTy(..) => {\n+            fcx.ccx.tcx.sess.span_bug(sp, &format!(\"expected value, found {:?}\", defn));\n+        }\n     }\n }\n \n@@ -4679,6 +4672,7 @@ pub fn type_scheme_for_def<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   path: &ast::Path,\n                                   type_scheme: TypeScheme<'tcx>,\n+                                  type_predicates: &ty::GenericPredicates<'tcx>,\n                                   opt_self_ty: Option<Ty<'tcx>>,\n                                   def: def::Def,\n                                   span: Span,\n@@ -4864,7 +4858,7 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     // Add all the obligations that are required, substituting and\n     // normalized appropriately.\n-    let bounds = fcx.instantiate_bounds(span, &substs, &type_scheme.generics);\n+    let bounds = fcx.instantiate_bounds(span, &substs, &type_predicates);\n     fcx.add_obligations_for_parameters(\n         traits::ObligationCause::new(span, fcx.body_id, traits::ItemObligation(def.def_id())),\n         &bounds);"}, {"sha": "bcb2ba6231df361520c26e9fd700f1924540cf8b", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -1588,8 +1588,8 @@ fn projection_bounds<'a,'tcx>(rcx: &Rcx<'a, 'tcx>,\n     // ```\n     //\n     // we can thus deduce that `<T as SomeTrait<'a>>::SomeType : 'a`.\n-    let trait_def = ty::lookup_trait_def(tcx, projection_ty.trait_ref.def_id);\n-    let predicates = trait_def.generics.predicates.as_slice().to_vec();\n+    let trait_predicates = ty::lookup_predicates(tcx, projection_ty.trait_ref.def_id);\n+    let predicates = trait_predicates.predicates.as_slice().to_vec();\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|predicate| {\n             // we're only interesting in `T : 'a` style predicates:"}, {"sha": "94670305be7557edcb27a449161c37014b9edd00", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -107,12 +107,12 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 });\n             }\n             ast::ItemTrait(..) => {\n-                let trait_def =\n-                    ty::lookup_trait_def(ccx.tcx, local_def(item.id));\n+                let trait_predicates =\n+                    ty::lookup_predicates(ccx.tcx, local_def(item.id));\n                 reject_non_type_param_bounds(\n                     ccx.tcx,\n                     item.span,\n-                    &trait_def.generics);\n+                    &trait_predicates);\n             }\n             _ => {}\n         }\n@@ -124,11 +124,13 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n         let ccx = self.ccx;\n         let item_def_id = local_def(item.id);\n         let type_scheme = ty::lookup_item_type(ccx.tcx, item_def_id);\n-        reject_non_type_param_bounds(ccx.tcx, item.span, &type_scheme.generics);\n+        let type_predicates = ty::lookup_predicates(ccx.tcx, item_def_id);\n+        reject_non_type_param_bounds(ccx.tcx, item.span, &type_predicates);\n         let param_env =\n             ty::construct_parameter_environment(ccx.tcx,\n                                                 item.span,\n                                                 &type_scheme.generics,\n+                                                &type_predicates,\n                                                 item.id);\n         let inh = Inherited::new(ccx.tcx, param_env);\n         let fcx = blank_fn_ctxt(ccx, &inh, ty::FnConverging(type_scheme.ty), item.id);\n@@ -283,9 +285,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n // Reject any predicates that do not involve a type parameter.\n fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       span: Span,\n-                                      generics: &ty::Generics<'tcx>) {\n-\n-    for predicate in generics.predicates.iter() {\n+                                      predicates: &ty::GenericPredicates<'tcx>) {\n+    for predicate in predicates.predicates.iter() {\n         match predicate {\n             &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n                 let found_param = tr.input_types().iter()\n@@ -367,7 +368,7 @@ impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                         reject_non_type_param_bounds(\n                             self.ccx.tcx,\n                             method.span,\n-                            &ty_method.generics);\n+                            &ty_method.predicates);\n                         reject_shadowing_type_parameters(\n                             self.ccx.tcx,\n                             method.span,\n@@ -415,9 +416,11 @@ impl<'cx,'tcx> BoundsChecker<'cx,'tcx> {\n     /// Note that it does not (currently, at least) check that `A : Copy` (that check is delegated\n     /// to the point where impl `A : Trait<B>` is implemented).\n     pub fn check_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>) {\n-        let trait_def = ty::lookup_trait_def(self.fcx.tcx(), trait_ref.def_id);\n+        let trait_predicates = ty::lookup_predicates(self.fcx.tcx(), trait_ref.def_id);\n \n-        let bounds = self.fcx.instantiate_bounds(self.span, trait_ref.substs, &trait_def.generics);\n+        let bounds = self.fcx.instantiate_bounds(self.span,\n+                                                 trait_ref.substs,\n+                                                 &trait_predicates);\n \n         self.fcx.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n@@ -482,8 +485,9 @@ impl<'cx,'tcx> TypeFolder<'tcx> for BoundsChecker<'cx,'tcx> {\n         match t.sty{\n             ty::ty_struct(type_id, substs) |\n             ty::ty_enum(type_id, substs) => {\n-                let type_scheme = ty::lookup_item_type(self.fcx.tcx(), type_id);\n-                let bounds = self.fcx.instantiate_bounds(self.span, substs, &type_scheme.generics);\n+                let type_predicates = ty::lookup_predicates(self.fcx.tcx(), type_id);\n+                let bounds = self.fcx.instantiate_bounds(self.span, substs,\n+                                                         &type_predicates);\n \n                 if self.binding_count == 0 {\n                     self.fcx.add_obligations_for_parameters(\n@@ -603,10 +607,10 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         .collect()\n }\n \n-fn filter_to_trait_obligations<'tcx>(bounds: ty::GenericBounds<'tcx>)\n-                                     -> ty::GenericBounds<'tcx>\n+fn filter_to_trait_obligations<'tcx>(bounds: ty::InstantiatedPredicates<'tcx>)\n+                                     -> ty::InstantiatedPredicates<'tcx>\n {\n-    let mut result = ty::GenericBounds::empty();\n+    let mut result = ty::InstantiatedPredicates::empty();\n     for (space, _, predicate) in bounds.predicates.iter_enumerated() {\n         match *predicate {\n             ty::Predicate::Trait(..) |"}, {"sha": "1542e74ff81672769a7fc68b8397bfe4f523b409", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -247,6 +247,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             debug!(\"new_polytype={}\", new_polytype.repr(tcx));\n \n             tcx.tcache.borrow_mut().insert(new_did, new_polytype);\n+            tcx.predicates.borrow_mut().insert(new_did, new_method_ty.predicates.clone());\n             tcx.impl_or_trait_items\n                .borrow_mut()\n                .insert(new_did, ty::MethodTraitItem(new_method_ty));\n@@ -555,6 +556,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     debug!(\"subst_receiver_types_in_method_ty: combined_substs={}\",\n            combined_substs.repr(tcx));\n \n+    let method_predicates = method.predicates.subst(tcx, &combined_substs);\n     let mut method_generics = method.generics.subst(tcx, &combined_substs);\n \n     // replace the type parameters declared on the trait with those\n@@ -579,6 +581,7 @@ fn subst_receiver_types_in_method_ty<'tcx>(tcx: &ty::ctxt<'tcx>,\n     ty::Method::new(\n         method.name,\n         method_generics,\n+        method_predicates,\n         method_fty,\n         method.explicit_self,\n         method.vis,"}, {"sha": "ccfadaba2440b2ad7578b41bf5c8019c7f1ac73a", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -102,7 +102,6 @@ pub use rustc::util;\n use middle::def;\n use middle::infer;\n use middle::subst;\n-use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n use session::config;\n use util::common::time;\n@@ -177,17 +176,6 @@ fn lookup_def_ccx(ccx: &CrateCtxt, sp: Span, id: ast::NodeId)\n     lookup_def_tcx(ccx.tcx, sp, id)\n }\n \n-fn no_params<'tcx>(t: Ty<'tcx>) -> ty::TypeScheme<'tcx> {\n-    ty::TypeScheme {\n-        generics: ty::Generics {\n-            types: VecPerParamSpace::empty(),\n-            regions: VecPerParamSpace::empty(),\n-            predicates: VecPerParamSpace::empty(),\n-        },\n-        ty: t\n-    }\n-}\n-\n fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n                                    maybe_infcx: Option<&infer::InferCtxt<'a, 'tcx>>,\n                                    t1_is_expected: bool,"}, {"sha": "d1283d6f46bd842ed3a945f5ef3668df9af1e2d8", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -166,10 +166,11 @@ pub fn build_external_trait(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     });\n     let trait_def = ty::lookup_trait_def(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let bounds = trait_def.bounds.clean(cx);\n     clean::Trait {\n         unsafety: def.unsafety,\n-        generics: (&def.generics, subst::TypeSpace).clean(cx),\n+        generics: (&def.generics, &predicates, subst::TypeSpace).clean(cx),\n         items: items.collect(),\n         bounds: bounds,\n     }\n@@ -181,9 +182,10 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n         ty::ty_bare_fn(_, ref f) => ((did, &f.sig).clean(cx), f.unsafety),\n         _ => panic!(\"bad function\"),\n     };\n+    let predicates = ty::lookup_predicates(tcx, did);\n     clean::Function {\n         decl: decl,\n-        generics: (&t.generics, subst::FnSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n         unsafety: style,\n     }\n }\n@@ -192,6 +194,7 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n     use syntax::parse::token::special_idents::unnamed_field;\n \n     let t = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let fields = ty::lookup_struct_fields(tcx, did);\n \n     clean::Struct {\n@@ -201,18 +204,19 @@ fn build_struct(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::Stru\n             [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n             _ => doctree::Plain,\n         },\n-        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n         fields: fields.clean(cx),\n         fields_stripped: false,\n     }\n }\n \n fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEnum {\n     let t = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     match t.ty.sty {\n         ty::ty_enum(edid, _) if !csearch::is_typedef(&tcx.sess.cstore, did) => {\n             return clean::EnumItem(clean::Enum {\n-                generics: (&t.generics, subst::TypeSpace).clean(cx),\n+                generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n                 variants_stripped: false,\n                 variants: ty::enum_variants(tcx, edid).clean(cx),\n             })\n@@ -222,7 +226,7 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n \n     clean::TypedefItem(clean::Typedef {\n         type_: t.ty.clean(cx),\n-        generics: (&t.generics, subst::TypeSpace).clean(cx),\n+        generics: (&t.generics, &predicates, subst::TypeSpace).clean(cx),\n     })\n }\n \n@@ -293,6 +297,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n \n     let attrs = load_attrs(cx, tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n+    let predicates = ty::lookup_predicates(tcx, did);\n     let trait_items = csearch::get_impl_items(&tcx.sess.cstore, did)\n             .iter()\n             .filter_map(|did| {\n@@ -323,9 +328,10 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n             ty::TypeTraitItem(ref assoc_ty) => {\n                 let did = assoc_ty.def_id;\n                 let type_scheme = ty::lookup_item_type(tcx, did);\n+                let predicates = ty::lookup_predicates(tcx, did);\n                 // Not sure the choice of ParamSpace actually matters here, because an\n                 // associated type won't have generics on the LHS\n-                let typedef = (type_scheme, subst::ParamSpace::TypeSpace).clean(cx);\n+                let typedef = (type_scheme, predicates, subst::ParamSpace::TypeSpace).clean(cx);\n                 Some(clean::Item {\n                     name: Some(assoc_ty.name.clean(cx)),\n                     inner: clean::TypedefItem(typedef),\n@@ -349,7 +355,7 @@ fn build_impl(cx: &DocContext, tcx: &ty::ctxt,\n                 }\n             }),\n             for_: ty.ty.clean(cx),\n-            generics: (&ty.generics, subst::TypeSpace).clean(cx),\n+            generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,\n             polarity: polarity.map(|p| { p.clean(cx) }),\n         }),"}, {"sha": "6c3d2d8fa19d1f213a436bd747f68f638ae606c5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e88b5bbf907bdb7d7610d66c27504be92330030/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e88b5bbf907bdb7d7610d66c27504be92330030", "patch": "@@ -860,7 +860,9 @@ impl Clean<Generics> for ast::Generics {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n+impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n+                                    &'a ty::GenericPredicates<'tcx>,\n+                                    subst::ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Generics {\n         use std::collections::HashSet;\n         use syntax::ast::TraitBoundModifier as TBM;\n@@ -885,7 +887,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             false\n         }\n \n-        let (gens, space) = *self;\n+        let (gens, preds, space) = *self;\n+\n         // Bounds in the type_params and lifetimes fields are repeated in the predicates\n         // field (see rustc_typeck::collect::ty_generics), so remove them.\n         let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n@@ -899,7 +902,8 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             srp.clean(cx)\n         }).collect::<Vec<_>>();\n \n-        let where_predicates = gens.predicates.get_slice(space).to_vec().clean(cx);\n+        let where_predicates = preds.predicates.get_slice(space).to_vec().clean(cx);\n+\n         // Type parameters have a Sized bound by default unless removed with ?Sized.\n         // Scan through the predicates and mark any type parameter with a Sized\n         // bound, removing the bounds as we find them.\n@@ -913,6 +917,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>, subst::ParamSpace) {\n             }\n             Some(pred)\n         }).collect::<Vec<_>>();\n+\n         // Finally, run through the type parameters again and insert a ?Sized unbound for\n         // any we didn't find to be Sized.\n         for tp in &stripped_typarams {\n@@ -1303,7 +1308,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n             source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 unsafety: self.fty.unsafety,\n-                generics: (&self.generics, subst::FnSpace).clean(cx),\n+                generics: (&self.generics, &self.predicates, subst::FnSpace).clean(cx),\n                 self_: self_,\n                 decl: (self.def_id, &sig).clean(cx),\n                 abi: self.fty.abi\n@@ -2560,12 +2565,12 @@ impl Clean<Item> for ast::Typedef {\n     }\n }\n \n-impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ParamSpace) {\n+impl<'a> Clean<Typedef> for (ty::TypeScheme<'a>, ty::GenericPredicates<'a>, ParamSpace) {\n     fn clean(&self, cx: &DocContext) -> Typedef {\n-        let (ref ty_scheme, ps) = *self;\n+        let (ref ty_scheme, ref predicates, ps) = *self;\n         Typedef {\n             type_: ty_scheme.ty.clean(cx),\n-            generics: (&ty_scheme.generics, ps).clean(cx)\n+            generics: (&ty_scheme.generics, predicates, ps).clean(cx)\n         }\n     }\n }"}]}