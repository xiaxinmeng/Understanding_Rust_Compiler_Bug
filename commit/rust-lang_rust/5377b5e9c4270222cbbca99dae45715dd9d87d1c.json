{"sha": "5377b5e9c4270222cbbca99dae45715dd9d87d1c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNzdiNWU5YzQyNzAyMjJjYmJjYTk5ZGFlNDU3MTVkZDlkODdkMWM=", "commit": {"author": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-07-19T08:50:52Z"}, "committer": {"name": "Steven Fackler", "email": "sfackler@gmail.com", "date": "2016-11-26T18:07:39Z"}, "message": "Overload get{,_mut}{,_unchecked}", "tree": {"sha": "076978568963c1cd3ca00e54b8a6f52dbd20fbea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/076978568963c1cd3ca00e54b8a6f52dbd20fbea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5377b5e9c4270222cbbca99dae45715dd9d87d1c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5377b5e9c4270222cbbca99dae45715dd9d87d1c", "html_url": "https://github.com/rust-lang/rust/commit/5377b5e9c4270222cbbca99dae45715dd9d87d1c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5377b5e9c4270222cbbca99dae45715dd9d87d1c/comments", "author": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sfackler", "id": 1455697, "node_id": "MDQ6VXNlcjE0NTU2OTc=", "avatar_url": "https://avatars.githubusercontent.com/u/1455697?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sfackler", "html_url": "https://github.com/sfackler", "followers_url": "https://api.github.com/users/sfackler/followers", "following_url": "https://api.github.com/users/sfackler/following{/other_user}", "gists_url": "https://api.github.com/users/sfackler/gists{/gist_id}", "starred_url": "https://api.github.com/users/sfackler/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sfackler/subscriptions", "organizations_url": "https://api.github.com/users/sfackler/orgs", "repos_url": "https://api.github.com/users/sfackler/repos", "events_url": "https://api.github.com/users/sfackler/events{/privacy}", "received_events_url": "https://api.github.com/users/sfackler/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a31ad75bdedab55ca290332edda9acbd2d5a0157", "url": "https://api.github.com/repos/rust-lang/rust/commits/a31ad75bdedab55ca290332edda9acbd2d5a0157", "html_url": "https://github.com/rust-lang/rust/commit/a31ad75bdedab55ca290332edda9acbd2d5a0157"}], "stats": {"total": 589, "additions": 404, "deletions": 185}, "files": [{"sha": "08288b4de8bde9cfdfb5998cab75742d7637c141", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -54,6 +54,7 @@\n #![feature(trusted_len)]\n #![feature(unicode)]\n #![feature(unique)]\n+#![feature(slice_get_slice)]\n #![cfg_attr(test, feature(rand, test))]\n \n #![no_std]"}, {"sha": "e615e780d2b5cde6587455c2bd9d88f00d43fccd", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -118,6 +118,8 @@ pub use core::slice::{SplitMut, ChunksMut, Split};\n pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n+#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n+pub use core::slice::SliceIndex;\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -353,7 +355,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn get(&self, index: usize) -> Option<&T> {\n+    pub fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get(self, index)\n     }\n \n@@ -372,7 +376,9 @@ impl<T> [T] {\n     /// or `None` if the index is out of bounds\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n+    pub fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_mut(self, index)\n     }\n \n@@ -390,7 +396,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn get_unchecked(&self, index: usize) -> &T {\n+    pub unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_unchecked(self, index)\n     }\n \n@@ -410,7 +418,9 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n+    pub unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<T>\n+    {\n         core_slice::SliceExt::get_unchecked_mut(self, index)\n     }\n "}, {"sha": "a4a90e7a9da7a3bc80df580ea4b86bf25d054e5d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 331, "deletions": 168, "changes": 499, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -38,10 +38,14 @@ use cmp;\n use fmt;\n use intrinsics::assume;\n use iter::*;\n-use ops::{self, RangeFull};\n+use ops::{FnMut, self};\n+use option::Option;\n+use option::Option::{None, Some};\n+use result::Result;\n+use result::Result::{Ok, Err};\n use ptr;\n use mem;\n-use marker;\n+use marker::{Copy, Send, Sync, Sized, self};\n use iter_private::TrustedRandomAccess;\n \n #[repr(C)]\n@@ -80,7 +84,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn chunks(&self, size: usize) -> Chunks<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get(&self, index: usize) -> Option<&Self::Item>;\n+    fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn first(&self) -> Option<&Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -90,7 +95,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn last(&self) -> Option<&Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked(&self, index: usize) -> &Self::Item;\n+    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_ptr(&self) -> *const Self::Item;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -108,7 +114,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn is_empty(&self) -> bool { self.len() == 0 }\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut Self::Item>;\n+    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn iter_mut(&mut self) -> IterMut<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n@@ -137,7 +144,8 @@ pub trait SliceExt {\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn reverse(&mut self);\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut Self::Item;\n+    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<Self::Item>;\n     #[stable(feature = \"core\", since = \"1.6.0\")]\n     fn as_mut_ptr(&mut self) -> *mut Self::Item;\n \n@@ -258,8 +266,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get(&self, index: usize) -> Option<&T> {\n-        if index < self.len() { Some(&self[index]) } else { None }\n+    fn get<I>(&self, index: I) -> Option<&I::Output>\n+        where I: SliceIndex<T>\n+    {\n+        index.get(self)\n     }\n \n     #[inline]\n@@ -284,8 +294,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(&self, index: usize) -> &T {\n-        &*(self.as_ptr().offset(index as isize))\n+    unsafe fn get_unchecked<I>(&self, index: I) -> &I::Output\n+        where I: SliceIndex<T>\n+    {\n+        index.get_unchecked(self)\n     }\n \n     #[inline]\n@@ -323,8 +335,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn get_mut(&mut self, index: usize) -> Option<&mut T> {\n-        if index < self.len() { Some(&mut self[index]) } else { None }\n+    fn get_mut<I>(&mut self, index: I) -> Option<&mut I::Output>\n+        where I: SliceIndex<T>\n+    {\n+        index.get_mut(self)\n     }\n \n     #[inline]\n@@ -451,8 +465,10 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(&mut self, index: usize) -> &mut T {\n-        &mut *self.as_mut_ptr().offset(index as isize)\n+    unsafe fn get_unchecked_mut<I>(&mut self, index: I) -> &mut I::Output\n+        where I: SliceIndex<T>\n+    {\n+        index.get_unchecked_mut(self)\n     }\n \n     #[inline]\n@@ -515,23 +531,26 @@ impl<T> SliceExt for [T] {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<usize> for [T] {\n-    type Output = T;\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+impl<T, I> ops::Index<I> for [T]\n+    where I: SliceIndex<T>\n+{\n+    type Output = I::Output;\n \n-    fn index(&self, index: usize) -> &T {\n-        // NB built-in indexing\n-        &(*self)[index]\n+    #[inline]\n+    fn index(&self, index: I) -> &I::Output {\n+        index.index(self)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<usize> for [T] {\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+impl<T, I> ops::IndexMut<I> for [T]\n+    where I: SliceIndex<T>\n+{\n     #[inline]\n-    fn index_mut(&mut self, index: usize) -> &mut T {\n-        // NB built-in indexing\n-        &mut (*self)[index]\n+    fn index_mut(&mut self, index: I) -> &mut I::Output {\n+        index.index_mut(self)\n     }\n }\n \n@@ -547,205 +566,349 @@ fn slice_index_order_fail(index: usize, end: usize) -> ! {\n     panic!(\"slice index starts at {} but ends at {}\", index, end);\n }\n \n+/// A helper trait used for indexing operations.\n+#[unstable(feature = \"slice_get_slice\", issue = \"35729\")]\n+#[rustc_on_unimplemented = \"slice indices are of type `usize` or ranges of `usize`\"]\n+pub trait SliceIndex<T> {\n+    /// The output type returned by methods.\n+    type Output: ?Sized;\n \n-/// Implements slicing with syntax `&self[begin .. end]`.\n-///\n-/// Returns a slice of self for the index range [`begin`..`end`).\n-///\n-/// This operation is `O(1)`.\n-///\n-/// # Panics\n-///\n-/// Requires that `begin <= end` and `end <= self.len()`,\n-/// otherwise slicing will panic.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::Range<usize>> for [T] {\n+    /// Returns a shared reference to the output at this location, if in\n+    /// bounds.\n+    fn get(self, slice: &[T]) -> Option<&Self::Output>;\n+\n+    /// Returns a mutable reference to the output at this location, if in\n+    /// bounds.\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut Self::Output>;\n+\n+    /// Returns a shared reference to the output at this location, without\n+    /// performing any bounds checking.\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, without\n+    /// performing any bounds checking.\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+\n+    /// Returns a shared reference to the output at this location, panicking\n+    /// if out of bounds.\n+    fn index(self, slice: &[T]) -> &Self::Output;\n+\n+    /// Returns a mutable reference to the output at this location, panicking\n+    /// if out of bounds.\n+    fn index_mut(self, slice: &mut [T]) -> &mut Self::Output;\n+}\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for usize {\n+    type Output = T;\n+\n+    #[inline]\n+    fn get(self, slice: &[T]) -> Option<&T> {\n+        if self < slice.len() {\n+            unsafe {\n+                Some(self.get_unchecked(slice))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n+        if self < slice.len() {\n+            unsafe {\n+                Some(self.get_unchecked_mut(slice))\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n+        &*slice.as_ptr().offset(self as isize)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n+        &mut *slice.as_mut_ptr().offset(self as isize)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &T {\n+        // NB: use intrinsic indexing\n+        &(*slice)[self]\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut T {\n+        // NB: use intrinsic indexing\n+        &mut (*slice)[self]\n+    }\n+}\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for  ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::Range<usize>) -> &[T] {\n-        if index.start > index.end {\n-            slice_index_order_fail(index.start, index.end);\n-        } else if index.end > self.len() {\n-            slice_index_len_fail(index.end, self.len());\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.get_unchecked(slice))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        if self.start > self.end || self.end > slice.len() {\n+            None\n+        } else {\n+            unsafe {\n+                Some(self.get_unchecked_mut(slice))\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        from_raw_parts(slice.as_ptr().offset(self.start as isize), self.end - self.start)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        from_raw_parts_mut(slice.as_mut_ptr().offset(self.start as isize), self.end - self.start)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_index_len_fail(self.end, slice.len());\n+        }\n+        unsafe {\n+            self.get_unchecked(slice)\n+        }\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        if self.start > self.end {\n+            slice_index_order_fail(self.start, self.end);\n+        } else if self.end > slice.len() {\n+            slice_index_len_fail(self.end, slice.len());\n         }\n         unsafe {\n-            from_raw_parts (\n-                self.as_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n+            self.get_unchecked_mut(slice)\n         }\n     }\n }\n \n-/// Implements slicing with syntax `&self[.. end]`.\n-///\n-/// Returns a slice of self from the beginning until but not including\n-/// the index `end`.\n-///\n-/// Equivalent to `&self[0 .. end]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeTo<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeTo<usize>) -> &[T] {\n-        self.index(0 .. index.end)\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0..self.end).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0..self.end).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (0..self.end).get_unchecked(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..self.end).get_unchecked_mut(slice)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0..self.end).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0..self.end).index_mut(slice)\n     }\n }\n \n-/// Implements slicing with syntax `&self[begin ..]`.\n-///\n-/// Returns a slice of self from and including the index `begin` until the end.\n-///\n-/// Equivalent to `&self[begin .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeFrom<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeFrom<usize>) -> &[T] {\n-        self.index(index.start .. self.len())\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (self.start..slice.len()).get(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (self.start..slice.len()).get_mut(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (self.start..slice.len()).get_unchecked(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (self.start..slice.len()).get_unchecked_mut(slice)\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (self.start..slice.len()).index(slice)\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (self.start..slice.len()).index_mut(slice)\n     }\n }\n \n-/// Implements slicing with syntax `&self[..]`.\n-///\n-/// Returns a slice of the whole slice. This operation cannot panic.\n-///\n-/// Equivalent to `&self[0 .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::Index<RangeFull> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, _index: RangeFull) -> &[T] {\n-        self\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        Some(slice)\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        slice\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        slice\n     }\n }\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeInclusive<usize>> for [T] {\n+\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeInclusive<usize>) -> &[T] {\n-        match index {\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => Some(&[]),\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get(slice),\n+        }\n+    }\n+\n+    #[inline]\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => Some(&mut []),\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => None,\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_mut(slice),\n+        }\n+    }\n+\n+    #[inline]\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        match self {\n             ops::RangeInclusive::Empty { .. } => &[],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                panic!(\"attempted to index slice up to maximum usize\"),\n-            ops::RangeInclusive::NonEmpty { start, end } =>\n-                self.index(start .. end+1)\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).get_unchecked(slice),\n         }\n     }\n-}\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::Index<ops::RangeToInclusive<usize>> for [T] {\n-    type Output = [T];\n \n     #[inline]\n-    fn index(&self, index: ops::RangeToInclusive<usize>) -> &[T] {\n-        self.index(0...index.end)\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { start, end } => {\n+                (start..end + 1).get_unchecked_mut(slice)\n+            }\n+        }\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[begin .. end]`.\n-///\n-/// Returns a slice of self for the index range [`begin`..`end`).\n-///\n-/// This operation is `O(1)`.\n-///\n-/// # Panics\n-///\n-/// Requires that `begin <= end` and `end <= self.len()`,\n-/// otherwise slicing will panic.\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::Range<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::Range<usize>) -> &mut [T] {\n-        if index.start > index.end {\n-            slice_index_order_fail(index.start, index.end);\n-        } else if index.end > self.len() {\n-            slice_index_len_fail(index.end, self.len());\n+    fn index(self, slice: &[T]) -> &[T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &[],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n+                panic!(\"attempted to index slice up to maximum usize\");\n+            },\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index(slice),\n         }\n-        unsafe {\n-            from_raw_parts_mut(\n-                self.as_mut_ptr().offset(index.start as isize),\n-                index.end - index.start\n-            )\n+    }\n+\n+    #[inline]\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        match self {\n+            ops::RangeInclusive::Empty { .. } => &mut [],\n+            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() => {\n+                panic!(\"attempted to index slice up to maximum usize\");\n+            },\n+            ops::RangeInclusive::NonEmpty { start, end } => (start..end + 1).index_mut(slice),\n         }\n     }\n }\n \n-/// Implements mutable slicing with syntax `&mut self[.. end]`.\n-///\n-/// Returns a slice of self from the beginning until but not including\n-/// the index `end`.\n-///\n-/// Equivalent to `&mut self[0 .. end]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeTo<usize>> for [T] {\n+#[stable(feature = \"slice-get-slice-impls\", since = \"1.13.0\")]\n+impl<T> SliceIndex<T> for ops::RangeToInclusive<usize> {\n+    type Output = [T];\n+\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeTo<usize>) -> &mut [T] {\n-        self.index_mut(0 .. index.end)\n+    fn get(self, slice: &[T]) -> Option<&[T]> {\n+        (0...self.end).get(slice)\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[begin ..]`.\n-///\n-/// Returns a slice of self from and including the index `begin` until the end.\n-///\n-/// Equivalent to `&mut self[begin .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeFrom<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeFrom<usize>) -> &mut [T] {\n-        let len = self.len();\n-        self.index_mut(index.start .. len)\n+    fn get_mut(self, slice: &mut [T]) -> Option<&mut [T]> {\n+        (0...self.end).get_mut(slice)\n     }\n-}\n \n-/// Implements mutable slicing with syntax `&mut self[..]`.\n-///\n-/// Returns a slice of the whole slice. This operation can not panic.\n-///\n-/// Equivalent to `&mut self[0 .. self.len()]`\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> ops::IndexMut<RangeFull> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, _index: RangeFull) -> &mut [T] {\n-        self\n+    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+        (0...self.end).get_unchecked(slice)\n     }\n-}\n \n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeInclusive<usize>> for [T] {\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeInclusive<usize>) -> &mut [T] {\n-        match index {\n-            ops::RangeInclusive::Empty { .. } => &mut [],\n-            ops::RangeInclusive::NonEmpty { end, .. } if end == usize::max_value() =>\n-                panic!(\"attempted to index slice up to maximum usize\"),\n-            ops::RangeInclusive::NonEmpty { start, end } =>\n-                self.index_mut(start .. end+1)\n-        }\n+    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0...self.end).get_unchecked_mut(slice)\n     }\n-}\n-#[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n-#[rustc_on_unimplemented = \"slice indices are of type `usize`\"]\n-impl<T> ops::IndexMut<ops::RangeToInclusive<usize>> for [T] {\n+\n+    #[inline]\n+    fn index(self, slice: &[T]) -> &[T] {\n+        (0...self.end).index(slice)\n+    }\n+\n     #[inline]\n-    fn index_mut(&mut self, index: ops::RangeToInclusive<usize>) -> &mut [T] {\n-        self.index_mut(0...index.end)\n+    fn index_mut(self, slice: &mut [T]) -> &mut [T] {\n+        (0...self.end).index_mut(slice)\n     }\n }\n "}, {"sha": "ad39e6b081b425b7223a5b4d1459633caf0150f7", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -180,3 +180,47 @@ fn test_windows_last() {\n     let c2 = v2.windows(2);\n     assert_eq!(c2.last().unwrap()[0], 3);\n }\n+\n+#[test]\n+fn get_range() {\n+    let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+    assert_eq!(v.get(..), Some(&[0, 1, 2, 3, 4, 5][..]));\n+    assert_eq!(v.get(..2), Some(&[0, 1][..]));\n+    assert_eq!(v.get(2..), Some(&[2, 3, 4, 5][..]));\n+    assert_eq!(v.get(1..4), Some(&[1, 2, 3][..]));\n+    assert_eq!(v.get(7..), None);\n+    assert_eq!(v.get(7..10), None);\n+}\n+\n+#[test]\n+fn get_mut_range() {\n+    let mut v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+    assert_eq!(v.get_mut(..), Some(&mut [0, 1, 2, 3, 4, 5][..]));\n+    assert_eq!(v.get_mut(..2), Some(&mut [0, 1][..]));\n+    assert_eq!(v.get_mut(2..), Some(&mut [2, 3, 4, 5][..]));\n+    assert_eq!(v.get_mut(1..4), Some(&mut [1, 2, 3][..]));\n+    assert_eq!(v.get_mut(7..), None);\n+    assert_eq!(v.get_mut(7..10), None);\n+}\n+\n+#[test]\n+fn get_unchecked_range() {\n+    unsafe {\n+        let v: &[i32] = &[0, 1, 2, 3, 4, 5];\n+        assert_eq!(v.get_unchecked(..), &[0, 1, 2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked(..2), &[0, 1][..]);\n+        assert_eq!(v.get_unchecked(2..), &[2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked(1..4), &[1, 2, 3][..]);\n+    }\n+}\n+\n+#[test]\n+fn get_unchecked_mut_range() {\n+    unsafe {\n+        let v: &mut [i32] = &mut [0, 1, 2, 3, 4, 5];\n+        assert_eq!(v.get_unchecked_mut(..), &mut [0, 1, 2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked_mut(..2), &mut [0, 1][..]);\n+        assert_eq!(v.get_unchecked_mut(2..), &mut[2, 3, 4, 5][..]);\n+        assert_eq!(v.get_unchecked_mut(1..4), &mut [1, 2, 3][..]);\n+    }\n+}"}, {"sha": "1889d76c03c03d4f7a111d52a0493bf4f01cbe05", "filename": "src/test/compile-fail/indexing-requires-a-uint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Findexing-requires-a-uint.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -13,7 +13,7 @@\n \n fn main() {\n     fn bar<T>(_: T) {}\n-    [0][0u8]; //~ ERROR: `[{integer}]: std::ops::Index<u8>` is not satisfied\n+    [0][0u8]; //~ ERROR: the trait bound `u8: std::slice::SliceIndex<{integer}>` is not satisfied\n \n     [0][0]; // should infer to be a usize\n "}, {"sha": "1815d0e978a9478067c61a4b964a2d22a454b8cd", "filename": "src/test/compile-fail/integral-indexing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fintegral-indexing.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     v[3i32]; //~ERROR : std::ops::Index<i32>` is not satisfied\n     s.as_bytes()[3_usize];\n     s.as_bytes()[3];\n-    s.as_bytes()[3u8];  //~ERROR : std::ops::Index<u8>` is not satisfied\n-    s.as_bytes()[3i8];  //~ERROR : std::ops::Index<i8>` is not satisfied\n-    s.as_bytes()[3u32]; //~ERROR : std::ops::Index<u32>` is not satisfied\n-    s.as_bytes()[3i32]; //~ERROR : std::ops::Index<i32>` is not satisfied\n+    s.as_bytes()[3u8];  //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n+    s.as_bytes()[3i8];  //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n+    s.as_bytes()[3u32]; //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n+    s.as_bytes()[3i32]; //~ERROR : std::slice::SliceIndex<u8>` is not satisfied\n }"}, {"sha": "d28b823ddc14597099060f5ee4996c1a4b626e5f", "filename": "src/test/compile-fail/on-unimplemented/slice-index.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5377b5e9c4270222cbbca99dae45715dd9d87d1c/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fon-unimplemented%2Fslice-index.rs?ref=5377b5e9c4270222cbbca99dae45715dd9d87d1c", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n // Test new Index error message for slices\n+// ignore-tidy-linelength\n \n #![feature(rustc_attrs)]\n \n@@ -17,12 +18,12 @@ use std::ops::Index;\n #[rustc_error]\n fn main() {\n     let x = &[1, 2, 3] as &[i32];\n-    x[1i32];\n-    //~^ ERROR E0277\n-    //~| NOTE the trait `std::ops::Index<i32>` is not implemented for `[i32]`\n-    //~| NOTE slice indices are of type `usize`\n-    x[..1i32];\n-    //~^ ERROR E0277\n-    //~| NOTE the trait `std::ops::Index<std::ops::RangeTo<i32>>` is not implemented for `[i32]`\n-    //~| NOTE slice indices are of type `usize`\n+    x[1i32]; //~ ERROR E0277\n+             //~| NOTE slice indices are of type `usize` or ranges of `usize`\n+             //~| NOTE trait `std::slice::SliceIndex<i32>` is not implemented for `i32`\n+             //~| NOTE required because of the requirements on the impl of `std::ops::Index<i32>`\n+    x[..1i32]; //~ ERROR E0277\n+               //~| NOTE slice indices are of type `usize` or ranges of `usize`\n+               //~| NOTE trait `std::slice::SliceIndex<i32>` is not implemented for `std::ops::RangeTo<i32>`\n+               //~| NOTE requirements on the impl of `std::ops::Index<std::ops::RangeTo<i32>>`\n }"}]}