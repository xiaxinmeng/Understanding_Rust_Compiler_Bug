{"sha": "aa5382bb13690ff183f6e94065dadf0524ce1c6e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhNTM4MmJiMTM2OTBmZjE4M2Y2ZTk0MDY1ZGFkZjA1MjRjZTFjNmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-30T04:07:55Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2011-12-30T04:29:28Z"}, "message": "split proto from fn_decl, as not all fn_decls know the proto.\nthis will address the (crashing) new test added.", "tree": {"sha": "627037c40c72983b75572e1bc3d04c0b3ab3fde4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/627037c40c72983b75572e1bc3d04c0b3ab3fde4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa5382bb13690ff183f6e94065dadf0524ce1c6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa5382bb13690ff183f6e94065dadf0524ce1c6e", "html_url": "https://github.com/rust-lang/rust/commit/aa5382bb13690ff183f6e94065dadf0524ce1c6e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa5382bb13690ff183f6e94065dadf0524ce1c6e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6db9506f421ebc6a48cc101307c1f5dca92c53e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6db9506f421ebc6a48cc101307c1f5dca92c53e", "html_url": "https://github.com/rust-lang/rust/commit/d6db9506f421ebc6a48cc101307c1f5dca92c53e"}], "stats": {"total": 429, "additions": 229, "deletions": 200}, "files": [{"sha": "f8aa8bdac53d1ef7fd63506e2687745ef14a445b", "filename": "src/comp/front/test.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Ftest.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -190,8 +190,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n     let ret_ty = mk_test_desc_vec_ty(cx);\n \n     let decl: ast::fn_decl =\n-        {proto: ast::proto_bare,\n-         inputs: [],\n+        {inputs: [],\n          output: ret_ty,\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n@@ -322,7 +321,6 @@ fn mk_test_wrapper(cx: test_ctxt,\n         ast::stmt_expr(@call_expr, cx.sess.next_node_id()));\n \n     let wrapper_decl: ast::fn_decl = {\n-        proto: ast::proto_bare,\n         inputs: [],\n         output: @nospan(ast::ty_nil),\n         purity: ast::impure_fn,\n@@ -345,7 +343,8 @@ fn mk_test_wrapper(cx: test_ctxt,\n \n     let wrapper_expr: ast::expr = {\n         id: cx.sess.next_node_id(),\n-        node: ast::expr_fn(wrapper_decl, wrapper_body, wrapper_capture),\n+        node: ast::expr_fn(ast::proto_bare, wrapper_decl,\n+                           wrapper_body, wrapper_capture),\n         span: span\n     };\n \n@@ -366,8 +365,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n     let ret_ty = nospan(ast::ty_nil);\n \n     let decl: ast::fn_decl =\n-        {proto: ast::proto_bare,\n-         inputs: [args_arg],\n+        {inputs: [args_arg],\n          output: @ret_ty,\n          purity: ast::impure_fn,\n          cf: ast::return_val,"}, {"sha": "e3c91b3d52a43a561f0c43b317092ae44f59d345", "filename": "src/comp/middle/alias.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Falias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Falias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Falias.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -61,7 +61,7 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n                copy_map: std::map::new_int_hash(),\n                ref_map: std::map::new_int_hash(),\n                mutable silent: false};\n-    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _, _),\n+    let v = @{visit_fn: bind visit_fn(cx, _, _, _, _, _, _, _),\n               visit_expr: bind visit_expr(cx, _, _, _),\n               visit_block: bind visit_block(cx, _, _, _)\n               with *visit::default_visitor::<scope>()};\n@@ -71,8 +71,8 @@ fn check_crate(tcx: ty::ctxt, crate: @ast::crate) -> (copy_map, ref_map) {\n     ret (cx.copy_map, cx.ref_map);\n }\n \n-fn visit_fn(cx: @ctx, decl: ast::fn_decl, _ts: [ast::ty_param],\n-            body: ast::blk, sp: span, _name: ast::fn_ident,\n+fn visit_fn(cx: @ctx, _fk: visit::fn_kind, decl: ast::fn_decl,\n+            body: ast::blk, sp: span,\n             id: ast::node_id, sc: scope, v: vt<scope>) {\n     visit::visit_fn_decl(decl, sc, v);\n     let fty = ty::node_id_to_type(cx.tcx, id);"}, {"sha": "2d2ef2e4c17da8c7046309d9b5af298b0cb0597d", "filename": "src/comp/middle/ast_map.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fast_map.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -32,16 +32,16 @@ fn map_crate(c: crate) -> map {\n         (@{visit_item: bind map_item(cx, _),\n            visit_native_item: bind map_native_item(cx, _),\n            visit_expr: bind map_expr(cx, _),\n-           visit_fn: bind map_fn(cx, _, _, _, _, _, _),\n+           visit_fn: bind map_fn(cx, _, _, _, _, _),\n            visit_local: bind map_local(cx, _),\n            visit_arm: bind map_arm(cx, _)\n            with *visit::default_simple_visitor()});\n     visit::visit_crate(c, (), v_map);\n     ret cx.map;\n }\n \n-fn map_fn(cx: ctx, decl: fn_decl, _tps: [ty_param], _body: blk,\n-          _sp: codemap::span, _n: fn_ident, _id: node_id) {\n+fn map_fn(cx: ctx, _fk: visit::fn_kind, decl: fn_decl, _body: blk,\n+          _sp: codemap::span, _id: node_id) {\n     for a in decl.inputs {\n         cx.map.insert(a.id, node_arg(a, cx.local_id));\n         cx.local_id += 1u;"}, {"sha": "0cc6cc7b79ddbc669031e629ec5ee281243e7bd2", "filename": "src/comp/middle/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fdebuginfo.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -736,7 +736,7 @@ fn create_function(fcx: @fn_ctxt) -> @metadata<subprogram_md> {\n       }\n       ast_map::node_expr(expr) {\n         alt expr.node {\n-          ast::expr_fn(decl, _, _) {\n+          ast::expr_fn(_, decl, _, _) {\n             (dbg_cx.names.next(\"fn\"), decl.output, expr.id)\n           }\n           ast::expr_fn_block(decl, _) {"}, {"sha": "7b348a9c8a188cdb1f3b157f395193ad0f1a5390", "filename": "src/comp/middle/freevars.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ffreevars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffreevars.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -38,8 +38,8 @@ fn collect_freevars(def_map: resolve::def_map, blk: ast::blk)\n     let walk_expr =\n         lambda (expr: @ast::expr, &&depth: int, v: visit::vt<int>) {\n             alt expr.node {\n-              ast::expr_fn(decl, _, captures) {\n-                if decl.proto != ast::proto_bare {\n+              ast::expr_fn(proto, decl, _, captures) {\n+                if proto != ast::proto_bare {\n                     visit::visit_expr(expr, depth + 1, v);\n                 }\n               }\n@@ -82,9 +82,8 @@ fn annotate_freevars(def_map: resolve::def_map, crate: @ast::crate) ->\n    freevar_map {\n     let freevars = new_int_hash();\n \n-    let walk_fn = lambda (_decl: ast::fn_decl, _tps: [ast::ty_param],\n-                          blk: ast::blk, _sp: span, _nm: ast::fn_ident,\n-                          nid: ast::node_id) {\n+    let walk_fn = lambda (_fk: visit::fn_kind, _decl: ast::fn_decl,\n+                          blk: ast::blk, _sp: span, nid: ast::node_id) {\n         let vars = collect_freevars(def_map, blk);\n         freevars.insert(nid, vars);\n     };"}, {"sha": "f71112002c476c754c2488fb2c162fdd936a3646", "filename": "src/comp/middle/kind.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fkind.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -67,8 +67,8 @@ fn with_closure_check_fn(cx: ctx, id: node_id,\n \n // Check that the free variables used in a shared/sendable closure conform\n // to the copy/move kind bounds. Then recursively check the function body.\n-fn check_fn(decl: fn_decl, tps: [ty_param], body: blk, sp: span,\n-            i: fn_ident, id: node_id, cx: ctx, v: visit::vt<ctx>) {\n+fn check_fn(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+            id: node_id, cx: ctx, v: visit::vt<ctx>) {\n \n     // n.b.: This could be the body of either a fn decl or a fn expr.  In the\n     // former case, the prototype will be proto_bare and no check occurs.  In\n@@ -88,7 +88,7 @@ fn check_fn(decl: fn_decl, tps: [ty_param], body: blk, sp: span,\n         }\n     }\n \n-    visit::visit_fn(decl, tps, body, sp, i, id, cx, v);\n+    visit::visit_fn(fk, decl, body, sp, id, cx, v);\n }\n \n fn check_fn_cap_clause(cx: ctx,\n@@ -181,7 +181,7 @@ fn check_expr(e: @expr, cx: ctx, v: visit::vt<ctx>) {\n         }\n       }\n       expr_ternary(_, a, b) { maybe_copy(cx, a); maybe_copy(cx, b); }\n-      expr_fn(_, _, cap_clause) {\n+      expr_fn(_, _, _, cap_clause) {\n         check_fn_cap_clause(cx, e.id, *cap_clause);\n       }\n       _ { }"}, {"sha": "113e9a9c29979230de1f623283861def88db2a76", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -136,7 +136,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         for arg in args {\n             alt arg.node {\n               //NDM--register captured as uses\n-              expr_fn(_, _, captured) { fns += [arg]; }\n+              expr_fn(_, _, _, captured) { fns += [arg]; }\n               expr_fn_block(_, _) { fns += [arg]; }\n               _ {\n                 alt arg_ts[i].mode {\n@@ -153,19 +153,19 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     }\n }\n \n-fn visit_fn(decl: fn_decl, tps: [ty_param], body: blk,\n-            sp: span, nm: fn_ident, id: node_id,\n+fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n+            sp: span, id: node_id,\n             cx: ctx, v: visit::vt<ctx>) {\n     let fty = ty::node_id_to_type(cx.tcx, id);\n     let proto = ty::ty_fn_proto(cx.tcx, fty);\n     if proto == proto_block {\n         visit_block(func, cx, {||\n-            visit::visit_fn(decl, tps, body, sp, nm, id, cx, v);\n+            visit::visit_fn(fk, decl, body, sp, id, cx, v);\n         });\n     } else {\n         let old = nil;\n         cx.blocks <-> old;\n-        visit::visit_fn(decl, tps, body, sp, nm, id, cx, v);\n+        visit::visit_fn(fk, decl, body, sp, id, cx, v);\n         cx.blocks <-> old;\n         leave_fn(cx);\n     }"}, {"sha": "ca9887534cb76b60cd86684b5961f2641625280a", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -336,7 +336,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_expr: bind walk_expr(e, _, _, _),\n           visit_ty: bind walk_ty(e, _, _, _),\n           visit_constr: bind walk_constr(e, _, _, _, _, _),\n-          visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _, _)\n+          visit_fn: bind visit_fn_with_scope(e, _, _, _, _, _, _, _)\n           with *visit::default_visitor()};\n     visit::visit_crate(*c, cons(scope_crate, @nil), visit::mk_vt(v));\n     e.used_imports.track = false;\n@@ -350,7 +350,7 @@ fn resolve_names(e: @env, c: @ast::crate) {\n                          lookup_path_strict(*e, sc, exp.span, p.node,\n                                             ns_value));\n           }\n-          ast::expr_fn(_, _, cap_clause) {\n+          ast::expr_fn(_, _, _, cap_clause) {\n             let rci = bind resolve_capture_item(e, sc, _);\n             vec::iter(cap_clause.copies, rci);\n             vec::iter(cap_clause.moves, rci);\n@@ -403,8 +403,9 @@ fn visit_item_with_scope(i: @ast::item, sc: scopes, v: vt<scopes>) {\n         alt ifce { some(ty) { v.visit_ty(ty, sc, v); } _ {} }\n         v.visit_ty(sty, sc, v);\n         for m in methods {\n-            v.visit_fn(m.decl, tps + m.tps, m.body, m.span,\n-                       some(m.ident), m.id, sc, v);\n+            v.visit_fn(visit::fk_method(m.ident, tps + m.tps),\n+                       m.decl, m.body, m.span,\n+                       m.id, sc, v);\n         }\n       }\n       _ { visit::visit_item(i, sc, v); }\n@@ -416,30 +417,35 @@ fn visit_native_item_with_scope(ni: @ast::native_item, sc: scopes,\n     visit::visit_native_item(ni, cons(scope_native_item(ni), @sc), v);\n }\n \n-fn visit_fn_with_scope(e: @env, decl: ast::fn_decl, tp: [ast::ty_param],\n-                       body: ast::blk, sp: span, name: fn_ident,\n+fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n+                       body: ast::blk, sp: span,\n                        id: node_id, sc: scopes, v: vt<scopes>) {\n     // is this a main fn declaration?\n-    alt name {\n-      some(nm) {\n+    alt fk {\n+      visit::fk_item_fn(nm, _) {\n         if is_main_name([nm]) && !e.sess.building_library() {\n             // This is a main function -- set it in the session\n             // as the main ID\n             e.sess.set_main_id(id);\n         }\n       }\n-      _ { }\n+      _ { /* fallthrough */ }\n     }\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n     for c: @ast::constr in decl.constraints { resolve_constr(e, c, sc, v); }\n-    let scope = alt decl.proto {\n-      ast::proto_bare. { scope_bare_fn(decl, id, tp) }\n-      _ { scope_fn_expr(decl, id, tp) }\n+    let scope = alt fk {\n+      visit::fk_item_fn(_, tps) | visit::fk_method(_, tps) |\n+      visit::fk_res(_, tps) {\n+        scope_bare_fn(decl, id, tps)\n+      }\n+      visit::fk_anon(_) | visit::fk_fn_block. {\n+        scope_fn_expr(decl, id, [])\n+      }\n     };\n \n-    visit::visit_fn(decl, tp, body, sp, name, id, cons(scope, @sc), v);\n+    visit::visit_fn(fk, decl, body, sp, id, cons(scope, @sc), v);\n }\n \n fn visit_block_with_scope(b: ast::blk, sc: scopes, v: vt<scopes>) {"}, {"sha": "26a9a29b6857c922fba830c25eef760720f21327", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -3551,16 +3551,18 @@ fn trans_expr(bcx: @block_ctxt, e: @ast::expr, dest: dest) -> @block_ctxt {\n         assert op != ast::deref; // lvals are handled above\n         ret trans_unary(bcx, op, x, e.id, dest);\n       }\n-      ast::expr_fn(decl, body, cap_clause) {\n+      ast::expr_fn(proto, decl, body, cap_clause) {\n         ret trans_closure::trans_expr_fn(\n-            bcx, decl, body, e.span, e.id, *cap_clause, dest);\n+            bcx, proto, decl, body, e.span, e.id, *cap_clause, dest);\n       }\n       ast::expr_fn_block(decl, body) {\n         alt ty::struct(tcx, ty::expr_ty(tcx, e)) {\n           ty::ty_fn({proto, _}) {\n+            #debug(\"translating fn_block %s with type %s\",\n+                   expr_to_str(e), ty_to_str(tcx, ty::expr_ty(tcx, e)));\n             let cap_clause = { copies: [], moves: [] };\n             ret trans_closure::trans_expr_fn(\n-                bcx, decl, body, e.span, e.id, cap_clause, dest);\n+                bcx, proto, decl, body, e.span, e.id, cap_clause, dest);\n           }\n           _ {\n             fail \"Type of fn block is not a function!\";"}, {"sha": "7205dd27c1c42db3c725e217badef263e5b60f0c", "filename": "src/comp/middle/trans_closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_closure.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -372,6 +372,7 @@ fn load_environment(enclosing_cx: @block_ctxt,\n }\n \n fn trans_expr_fn(bcx: @block_ctxt,\n+                 proto: ast::proto,\n                  decl: ast::fn_decl,\n                  body: ast::blk,\n                  sp: span,\n@@ -390,15 +391,15 @@ fn trans_expr_fn(bcx: @block_ctxt,\n \n     let trans_closure_env = lambda(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n-            ccx.tcx, id, decl.proto, cap_clause);\n+            ccx.tcx, id, proto, cap_clause);\n         let {llbox, box_ty, bcx} = build_closure(bcx, cap_vars, ck);\n         trans_closure(sub_cx, sp, decl, body, llfn, no_self, [], id, {|fcx|\n             load_environment(bcx, fcx, box_ty, cap_vars, ck);\n         });\n         llbox\n     };\n \n-    let closure = alt decl.proto {\n+    let closure = alt proto {\n       ast::proto_block. { trans_closure_env(ty::closure_block) }\n       ast::proto_shared(_) { trans_closure_env(ty::closure_shared) }\n       ast::proto_send. { trans_closure_env(ty::closure_send) }"}, {"sha": "e5c4cd7192c566921c9c728f565eeb683670c1ca", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -56,16 +56,16 @@ fn visit_fn(ccx: crate_ctxt, num_constraints: uint, body: blk) {\n     init_vecs(ccx, node_id_vec, num_constraints);\n }\n \n-fn annotate_in_fn(ccx: crate_ctxt, _decl: fn_decl, _ts: [ty_param], body: blk,\n-                  _sp: span, _n: fn_ident, id: node_id) {\n+fn annotate_in_fn(ccx: crate_ctxt, _fk: visit::fn_kind, _decl: fn_decl,\n+                  body: blk, _sp: span, id: node_id) {\n     let f_info = get_fn_info(ccx, id);\n     visit_fn(ccx, num_constraints(f_info), body);\n }\n \n fn annotate_crate(ccx: crate_ctxt, crate: crate) {\n     let do_ann =\n         visit::mk_simple_visitor(\n-            @{visit_fn: bind annotate_in_fn(ccx, _, _, _, _, _, _)\n+            @{visit_fn: bind annotate_in_fn(ccx, _, _, _, _, _)\n               with *visit::default_simple_visitor()});\n     visit::visit_crate(crate, (), do_ann);\n }"}, {"sha": "5b12477d873cc727d21a3cbec7a34d7bcec96556", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -1008,8 +1008,8 @@ fn op_to_oper_ty(io: init_op) -> oper_type {\n }\n \n // default function visitor\n-fn do_nothing<T>(_decl: fn_decl, _ts: [ty_param], _body: blk,\n-                 _sp: span, _i: fn_ident, _id: node_id,\n+fn do_nothing<T>(_fk: visit::fn_kind, _decl: fn_decl, _body: blk,\n+                 _sp: span, _id: node_id,\n                  _t: T, _v: visit::vt<T>) {\n }\n "}, {"sha": "9f4d5949e01b094f4133639655e01e2dd0f06bd4", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -151,7 +151,7 @@ fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n           visit_stmt: relax_precond_stmt,\n           visit_item:\n               fn (_i: @item, _cx: relax_ctxt, _vt: visit::vt<relax_ctxt>) { },\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _, _)\n+          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n              with *visitor};\n     let v1 = visit::mk_vt(visitor);\n     v1.visit_block(b, cx, v1);"}, {"sha": "0ebf4bd0ccc38d5a59ab71b24bdbe44b51c39e1e", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -94,21 +94,20 @@ fn check_states_stmt(s: @stmt, fcx: fn_ctxt, v: visit::vt<fn_ctxt>) {\n }\n \n fn check_states_against_conditions(fcx: fn_ctxt,\n+                                   fk: visit::fn_kind,\n                                    f_decl: ast::fn_decl,\n                                    f_body: ast::blk,\n                                    sp: span,\n-                                   nm: fn_ident,\n                                    id: node_id) {\n     /* Postorder traversal instead of pre is important\n        because we want the smallest possible erroneous statement\n        or expression. */\n-\n     let visitor = visit::mk_vt(\n         @{visit_stmt: check_states_stmt,\n           visit_expr: check_states_expr,\n-          visit_fn: bind do_nothing::<fn_ctxt>(_, _, _, _, _, _, _, _)\n+          visit_fn: bind do_nothing::<fn_ctxt>(_, _, _, _, _, _, _)\n           with *visit::default_visitor::<fn_ctxt>()});\n-    visit::visit_fn(f_decl, [], f_body, sp, nm, id, fcx, visitor);\n+    visit::visit_fn(fk, f_decl, f_body, sp, id, fcx, visitor);\n \n     /* Check that the return value is initialized */\n     let post = aux::block_poststate(fcx.ccx, f_body);\n@@ -142,10 +141,10 @@ fn check_states_against_conditions(fcx: fn_ctxt,\n }\n \n fn check_fn_states(fcx: fn_ctxt,\n+                   fk: visit::fn_kind,\n                    f_decl: ast::fn_decl,\n                    f_body: ast::blk,\n                    sp: span,\n-                   nm: fn_ident,\n                    id: node_id) {\n     /* Compute the pre- and post-states for this function */\n \n@@ -155,20 +154,20 @@ fn check_fn_states(fcx: fn_ctxt,\n     /* Now compare each expr's pre-state to its precondition\n        and post-state to its postcondition */\n \n-    check_states_against_conditions(fcx, f_decl, f_body, sp, nm, id);\n+    check_states_against_conditions(fcx, fk, f_decl, f_body, sp, id);\n }\n \n-fn fn_states(f_decl: ast::fn_decl, tps: [ast::ty_param], f_body: ast::blk,\n-             sp: span, i: ast::fn_ident, id: node_id,\n+fn fn_states(fk: visit::fn_kind, f_decl: ast::fn_decl, f_body: ast::blk,\n+             sp: span, id: node_id,\n              ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-    visit::visit_fn(f_decl, tps, f_body, sp, i, id, ccx, v);\n+    visit::visit_fn(fk, f_decl, f_body, sp, id, ccx, v);\n     /* Look up the var-to-bit-num map for this function */\n \n     assert (ccx.fm.contains_key(id));\n     let f_info = ccx.fm.get(id);\n-    let name = option::from_maybe(\"anon\", i); // XXXX\n+    let name = visit::name_of_fn(fk);\n     let fcx = {enclosing: f_info, id: id, name: name, ccx: ccx};\n-    check_fn_states(fcx, f_decl, f_body, sp, i, id)\n+    check_fn_states(fcx, fk, f_decl, f_body, sp, id)\n }\n \n fn check_crate(cx: ty::ctxt, crate: @crate) {"}, {"sha": "60c7946858972d06600af100cf010ef1f329d49f", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -1,6 +1,5 @@\n import syntax::ast::*;\n import syntax::ast_util::*;\n-import util::ppaux::fn_ident_to_string;\n import option::*;\n import syntax::visit;\n import aux::*;\n@@ -45,22 +44,21 @@ fn collect_pred(e: @expr, cx: ctxt, v: visit::vt<ctxt>) {\n }\n \n fn find_locals(tcx: ty::ctxt,\n+               fk: visit::fn_kind,\n                f_decl: fn_decl,\n-               tps: [ty_param],\n                f_body: blk,\n                sp: span,\n-               n: fn_ident,\n                id: node_id) -> ctxt {\n     let cx: ctxt = {cs: @mutable [], tcx: tcx};\n     let visitor = visit::default_visitor::<ctxt>();\n \n     visitor =\n         @{visit_local: collect_local,\n           visit_expr: collect_pred,\n-          visit_fn: bind do_nothing(_, _, _, _, _, _, _, _)\n+          visit_fn: bind do_nothing(_, _, _, _, _, _, _)\n           with *visitor};\n-    visit::visit_fn(f_decl, tps, f_body, sp,\n-                    n, id, cx, visit::mk_vt(visitor));\n+    visit::visit_fn(fk, f_decl, f_body, sp,\n+                    id, cx, visit::mk_vt(visitor));\n     ret cx;\n }\n \n@@ -98,18 +96,16 @@ fn add_constraint(tcx: ty::ctxt, c: sp_constr, next: uint, tbl: constr_map) ->\n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(ccx: crate_ctxt,\n+              fk: visit::fn_kind,\n               f_decl: fn_decl,\n-              tps: [ty_param],\n               f_body: blk,\n               f_sp: span,\n-              f_name: fn_ident,\n               id: node_id) {\n-    let name = fn_ident_to_string(id, f_name);\n+    let name = visit::name_of_fn(fk);\n     let res_map = @new_def_hash::<constraint>();\n     let next: uint = 0u;\n \n-    let cx: ctxt = find_locals(ccx.tcx, f_decl, tps, f_body, f_sp,\n-                               f_name, id);\n+    let cx: ctxt = find_locals(ccx.tcx, fk, f_decl, f_body, f_sp, id);\n     /* now we have to add bit nums for both the constraints\n        and the variables... */\n \n@@ -167,7 +163,7 @@ fn mk_fn_info(ccx: crate_ctxt,\n fn mk_f_to_fn_info(ccx: crate_ctxt, c: @crate) {\n     let visitor =\n         visit::mk_simple_visitor(@{visit_fn:\n-                                       bind mk_fn_info(ccx, _, _, _, _, _, _)\n+                                       bind mk_fn_info(ccx, _, _, _, _, _)\n                                    with *visit::default_simple_visitor()});\n     visit::visit_crate(*c, (), visitor);\n }"}, {"sha": "fb1dd7564a85baad6de4e890d67a9159101d8df7", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -14,7 +14,6 @@ import syntax::visit;\n import util::common::{new_def_hash, log_expr, field_exprs,\n                       has_nonlocal_exits, log_stmt};\n import syntax::codemap::span;\n-import util::ppaux::fn_ident_to_string;\n \n fn find_pre_post_mod(_m: _mod) -> _mod {\n     #debug(\"implement find_pre_post_mod!\");\n@@ -346,7 +345,7 @@ fn find_pre_post_expr(fcx: fn_ctxt, e: @expr) {\n       expr_log(_, lvl, arg) {\n         find_pre_post_exprs(fcx, [lvl, arg], e.id);\n       }\n-      expr_fn(_, _, cap_clause) {\n+      expr_fn(_, _, _, cap_clause) {\n         find_pre_post_expr_fn_upvars(fcx, e);\n \n         let use_cap_item = lambda(&&cap_item: @capture_item) {\n@@ -727,15 +726,15 @@ fn find_pre_post_fn(fcx: fn_ctxt, body: blk) {\n     }\n }\n \n-fn fn_pre_post(decl: fn_decl, tps: [ty_param], body: blk, sp: span,\n-               i: fn_ident, id: node_id,\n+fn fn_pre_post(fk: visit::fn_kind, decl: fn_decl, body: blk, sp: span,\n+               id: node_id,\n                ccx: crate_ctxt, v: visit::vt<crate_ctxt>) {\n-    visit::visit_fn(decl, tps, body, sp, i, id, ccx, v);\n+    visit::visit_fn(fk, decl, body, sp, id, ccx, v);\n     assert (ccx.fm.contains_key(id));\n     let fcx =\n         {enclosing: ccx.fm.get(id),\n          id: id,\n-         name: fn_ident_to_string(id, i),\n+         name: visit::name_of_fn(fk),\n          ccx: ccx};\n     find_pre_post_fn(fcx, body);\n }"}, {"sha": "2652585f09b22cba167665806b22251f047083cf", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -371,7 +371,7 @@ fn find_pre_post_state_expr(fcx: fn_ctxt, pres: prestate, e: @expr) -> bool {\n       }\n       expr_mac(_) { fcx.ccx.tcx.sess.bug(\"unexpanded macro\"); }\n       expr_lit(l) { ret pure_exp(fcx.ccx, e.id, pres); }\n-      expr_fn(_, _, cap_clause) {\n+      expr_fn(_, _, _, cap_clause) {\n         ret find_pre_post_state_cap_clause(fcx, e.id, pres, *cap_clause);\n       }\n       expr_fn_block(_, _) { ret pure_exp(fcx.ccx, e.id, pres); }"}, {"sha": "5d65ce78049988970fcb18aa239adbdd19c3ebd8", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -333,8 +333,8 @@ fn ast_ty_to_ty(tcx: ty::ctxt, mode: mode, &&ast_ty: @ast::ty) -> ty::t {\n         }\n         typ = ty::mk_rec(tcx, flds);\n       }\n-      ast::ty_fn(decl) {\n-        typ = ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, decl));\n+      ast::ty_fn(proto, decl) {\n+        typ = ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, proto, decl));\n       }\n       ast::ty_path(path, id) {\n         alt tcx.def_map.find(id) {\n@@ -465,7 +465,8 @@ fn ty_of_arg(tcx: ty::ctxt, mode: mode, a: ast::arg) -> ty::arg {\n     let ty = ast_ty_to_ty(tcx, mode, a.ty);\n     {mode: default_arg_mode_for_ty(tcx, a.mode, ty), ty: ty}\n }\n-fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::fn_ty {\n+fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode,\n+                 proto: ast::proto, decl: ast::fn_decl) -> ty::fn_ty {\n     let input_tys = [];\n     for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n     let output_ty = ast_ty_to_ty(tcx, mode, decl.output);\n@@ -474,19 +475,20 @@ fn ty_of_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl) -> ty::fn_ty {\n     for constr: @ast::constr in decl.constraints {\n         out_constrs += [ty::ast_constr_to_constr(tcx, constr)];\n     }\n-    {proto: decl.proto, inputs: input_tys,\n+    {proto: proto, inputs: input_tys,\n      output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n }\n fn ty_of_fn(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n             ty_params: [ast::ty_param], def_id: ast::def_id)\n     -> ty::ty_param_bounds_and_ty {\n-    let tpt = @{bounds: ty_param_bounds(tcx, mode, ty_params),\n-               ty: ty::mk_fn(tcx, ty_of_fn_decl(tcx, mode, decl))};\n+    let bounds = ty_param_bounds(tcx, mode, ty_params);\n+    let tofd = ty_of_fn_decl(tcx, mode, ast::proto_bare, decl);\n+    let tpt = @{bounds: bounds, ty: ty::mk_fn(tcx, tofd)};\n     tcx.tcache.insert(def_id, tpt);\n     ret tpt;\n }\n fn ty_of_native_fn_decl(tcx: ty::ctxt, mode: mode, decl: ast::fn_decl,\n-                  ty_params: [ast::ty_param], def_id: ast::def_id)\n+                        ty_params: [ast::ty_param], def_id: ast::def_id)\n     -> ty::ty_param_bounds_and_ty {\n     let input_tys = [], bounds = ty_param_bounds(tcx, mode, ty_params);\n     for a: ast::arg in decl.inputs { input_tys += [ty_of_arg(tcx, mode, a)]; }\n@@ -524,12 +526,12 @@ fn ty_param_bounds(tcx: ty::ctxt, mode: mode, params: [ast::ty_param])\n }\n fn ty_of_method(tcx: ty::ctxt, mode: mode, m: @ast::method) -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, m.decl)}\n+     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl)}\n }\n fn ty_of_ty_method(tcx: ty::ctxt, mode: mode, m: ast::ty_method)\n     -> ty::method {\n     {ident: m.ident, tps: ty_param_bounds(tcx, mode, m.tps),\n-     fty: ty_of_fn_decl(tcx, mode, m.decl)}\n+     fty: ty_of_fn_decl(tcx, mode, ast::proto_bare, m.decl)}\n }\n fn ty_of_obj(tcx: ty::ctxt, mode: mode, id: ast::ident, ob: ast::_obj,\n         ty_params: [ast::ty_param]) -> ty::ty_param_bounds_and_ty {\n@@ -691,8 +693,9 @@ mod collect {\n             ty_param_bounds(cx.tcx, m_collect, tps);\n             for m in ms {\n                 let bounds = ty_param_bounds(cx.tcx, m_collect, m.tps);\n-                let ty = ty::mk_fn(cx.tcx, ty_of_fn_decl(cx.tcx, m_collect,\n-                                                         m.decl));\n+                let ty = ty::mk_fn(cx.tcx,\n+                                   ty_of_fn_decl(cx.tcx, m_collect,\n+                                                 ast::proto_bare, m.decl));\n                 cx.tcx.tcache.insert(local_def(m.id), @{bounds: bounds,\n                                                        ty: ty});\n                 write::ty_only(cx.tcx, m.id, ty);\n@@ -1005,7 +1008,7 @@ mod writeback {\n         if !wbcx.success { ret; }\n         resolve_type_vars_for_node(wbcx, e.span, e.id);\n         alt e.node {\n-          ast::expr_fn(decl, _, _) |\n+          ast::expr_fn(_, decl, _, _) |\n           ast::expr_fn_block(decl, _) {\n             for input in decl.inputs {\n                 resolve_type_vars_for_node(wbcx, e.span, input.id);\n@@ -1154,16 +1157,15 @@ fn gather_locals(ccx: @crate_ctxt,\n         };\n \n     // Don't descend into fns and items\n-    fn visit_fn<T>(_decl: ast::fn_decl, _ts: [ast::ty_param], _body: ast::blk,\n-                   _sp: span, _nm: ast::fn_ident, _id: ast::node_id,\n-                   _t: T, _v: visit::vt<T>) {\n+    fn visit_fn<T>(_fk: visit::fn_kind, _decl: ast::fn_decl, _body: ast::blk,\n+                   _sp: span, _id: ast::node_id, _t: T, _v: visit::vt<T>) {\n     }\n     fn visit_item<E>(_i: @ast::item, _e: E, _v: visit::vt<E>) { }\n \n     let visit =\n         @{visit_local: visit_local,\n           visit_pat: visit_pat,\n-          visit_fn: bind visit_fn(_, _, _, _, _, _, _, _),\n+          visit_fn: bind visit_fn(_, _, _, _, _, _, _),\n           visit_item: bind visit_item(_, _, _)\n               with *visit::default_visitor()};\n \n@@ -1510,13 +1512,15 @@ fn lookup_method(fcx: @fn_ctxt, isc: resolve::iscopes,\n \n fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n                               expr: @ast::expr,\n+                              proto: ast::proto,\n                               decl: ast::fn_decl,\n                               body: ast::blk,\n                               unify: unifier,\n                               expected: ty::t) {\n     let tcx = fcx.ccx.tcx;\n \n-    let fty = ty::mk_fn(tcx, ty_of_fn_decl(tcx, m_check_tyvar(fcx), decl));\n+    let fty = ty::mk_fn(tcx, ty_of_fn_decl(tcx, m_check_tyvar(fcx),\n+                                           proto, decl));\n \n     #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n            expr_to_str(expr),\n@@ -1530,7 +1534,7 @@ fn check_expr_fn_with_unifier(fcx: @fn_ctxt,\n     // record projection work on type inferred arguments.\n     unify(fcx, expr.span, expected, fty);\n \n-    check_fn(fcx.ccx, decl, body, expr.id, some(fcx));\n+    check_fn(fcx.ccx, proto, decl, body, expr.id, some(fcx));\n }\n \n fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n@@ -1964,10 +1968,10 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         if !arm_non_bot { result_ty = ty::mk_bot(tcx); }\n         write::ty_only_fixup(fcx, id, result_ty);\n       }\n-      ast::expr_fn(decl, body, captures) {\n-        check_expr_fn_with_unifier(fcx, expr, decl, body,\n+      ast::expr_fn(proto, decl, body, captures) {\n+        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n                                    unify, expected);\n-        capture::check_capture_clause(tcx, expr.id, decl.proto, *captures);\n+        capture::check_capture_clause(tcx, expr.id, proto, *captures);\n       }\n       ast::expr_fn_block(decl, body) {\n         // Take the prototype from the expected type, but default to block:\n@@ -1983,7 +1987,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt, expr: @ast::expr, unify: unifier,\n         #debug(\"checking expr_fn_block %s expected=%s\",\n                expr_to_str(expr),\n                ty_to_str(tcx, expected));\n-        check_expr_fn_with_unifier(fcx, expr, {proto: proto with decl}, body,\n+        check_expr_fn_with_unifier(fcx, expr, proto, decl, body,\n                                    unify, expected);\n         write::ty_only_fixup(fcx, id, expected);\n       }\n@@ -2602,10 +2606,11 @@ fn check_constraints(fcx: @fn_ctxt, cs: [@ast::constr], args: [ast::arg]) {\n }\n \n fn check_fn(ccx: @crate_ctxt,\n-             decl: ast::fn_decl,\n-             body: ast::blk,\n-             id: ast::node_id,\n-             old_fcx: option::t<@fn_ctxt>) {\n+            proto: ast::proto,\n+            decl: ast::fn_decl,\n+            body: ast::blk,\n+            id: ast::node_id,\n+            old_fcx: option::t<@fn_ctxt>) {\n     // If old_fcx is some(...), this is a block fn { |x| ... }.\n     // In that case, the purity is inherited from the context.\n     let purity = alt old_fcx {\n@@ -2618,7 +2623,7 @@ fn check_fn(ccx: @crate_ctxt,\n     let fcx: @fn_ctxt =\n         @{ret_ty: ty::ty_fn_ret(ccx.tcx, ty::node_id_to_type(ccx.tcx, id)),\n           purity: purity,\n-          proto: decl.proto,\n+          proto: proto,\n           var_bindings: gather_result.var_bindings,\n           locals: gather_result.locals,\n           next_var_id: gather_result.next_var_id,\n@@ -2655,15 +2660,17 @@ fn check_fn(ccx: @crate_ctxt,\n }\n \n fn check_method(ccx: @crate_ctxt, method: @ast::method) {\n-    check_fn(ccx, method.decl, method.body, method.id, none);\n+    check_fn(ccx, ast::proto_bare, method.decl, method.body, method.id, none);\n }\n \n fn check_item(ccx: @crate_ctxt, it: @ast::item) {\n     alt it.node {\n       ast::item_const(_, e) { check_const(ccx, it.span, e, it.id); }\n-      ast::item_fn(decl, _, body) { check_fn(ccx, decl, body, it.id, none); }\n+      ast::item_fn(decl, _, body) {\n+        check_fn(ccx, ast::proto_bare, decl, body, it.id, none);\n+      }\n       ast::item_res(decl, _, body, dtor_id, _) {\n-        check_fn(ccx, decl, body, dtor_id, none);\n+        check_fn(ccx, ast::proto_bare, decl, body, dtor_id, none);\n       }\n       ast::item_obj(ob, _, _) {\n         // We're entering an object, so gather up the info we need."}, {"sha": "b0d51b580402e7794cfafd43c8d7fabcf9ff3e89", "filename": "src/comp/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fast.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -202,7 +202,7 @@ tag expr_ {\n     expr_for(@local, @expr, blk);\n     expr_do_while(blk, @expr);\n     expr_alt(@expr, [arm]);\n-    expr_fn(fn_decl, blk, @capture_clause);\n+    expr_fn(proto, fn_decl, blk, @capture_clause);\n     expr_fn_block(fn_decl, blk);\n     expr_block(blk);\n \n@@ -317,7 +317,7 @@ tag ty_ {\n     ty_port(@ty);\n     ty_chan(@ty);\n     ty_rec([ty_field]);\n-    ty_fn(fn_decl);\n+    ty_fn(proto, fn_decl);\n     ty_obj([ty_method]);\n     ty_tup([@ty]);\n     ty_path(@path, node_id);\n@@ -368,8 +368,7 @@ type ty_constr = spanned<ty_constr_>;\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n type fn_decl =\n-    {proto: proto,\n-     inputs: [arg],\n+    {inputs: [arg],\n      output: @ty,\n      purity: purity,\n      cf: ret_style,"}, {"sha": "9313bbcdc5857f818ad2fc7de703a632b21171bf", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -143,8 +143,7 @@ fn fold_mac_(m: mac, fld: ast_fold) -> mac {\n }\n \n fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n-    ret {proto: decl.proto,\n-         inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n+    ret {inputs: vec::map(decl.inputs, bind fold_arg_(_, fld)),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n          cf: decl.cf,\n@@ -192,8 +191,7 @@ fn noop_fold_native_item(&&ni: @native_item, fld: ast_fold) -> @native_item {\n               alt ni.node {\n                 native_item_ty. { native_item_ty }\n                 native_item_fn(fdec, typms) {\n-                  native_item_fn({proto: fdec.proto,\n-                                  inputs: vec::map(fdec.inputs, fold_arg),\n+                  native_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n                                   cf: fdec.cf,\n@@ -398,8 +396,9 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_alt(expr, arms) {\n             expr_alt(fld.fold_expr(expr), vec::map(arms, fld.fold_arm))\n           }\n-          expr_fn(decl, body, captures) {\n-              expr_fn(fold_fn_decl(decl, fld), fld.fold_block(body), captures)\n+          expr_fn(proto, decl, body, captures) {\n+              expr_fn(proto, fold_fn_decl(decl, fld),\n+                      fld.fold_block(body), captures)\n           }\n           expr_fn_block(decl, body) {\n             expr_fn_block(fold_fn_decl(decl, fld), fld.fold_block(body))"}, {"sha": "dd6497792358e5606ad4639bac8ba1f67a90cabe", "filename": "src/comp/syntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fparse%2Fparser.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -280,21 +280,21 @@ fn parse_ty_fn(proto: ast::proto, p: parser) -> ast::ty_ {\n     //  auto constrs = parse_constrs(~[], p);\n     let constrs: [@ast::constr] = [];\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret ast::ty_fn({proto: proto, inputs: inputs.node, output: ret_ty,\n-                    purity: ast::impure_fn, cf: ret_style,\n-                    constraints: constrs});\n+    ret ast::ty_fn(proto, {inputs: inputs.node, output: ret_ty,\n+                           purity: ast::impure_fn, cf: ret_style,\n+                           constraints: constrs});\n }\n \n fn parse_ty_methods(p: parser, allow_tps: bool) -> [ast::ty_method] {\n     parse_seq(token::LBRACE, token::RBRACE, seq_sep_none(), {|p|\n         let flo = p.get_lo_pos();\n-        let proto: ast::proto = parse_method_proto(p);\n+        expect_word(p, \"fn\");\n         let ident = parse_value_ident(p);\n         let tps = allow_tps ? parse_ty_params(p) : [];\n-        let f = parse_ty_fn(proto, p), fhi = p.get_last_hi_pos();\n+        let f = parse_ty_fn(ast::proto_bare, p), fhi = p.get_last_hi_pos();\n         expect(p, token::SEMI);\n         alt f {\n-          ast::ty_fn(d) {\n+          ast::ty_fn(_, d) {\n             {ident: ident, decl: d, tps: tps,\n              span: ast_util::mk_sp(flo, fhi)}\n           }\n@@ -1284,10 +1284,10 @@ fn parse_capture_clause(p: parser) -> @ast::capture_clause {\n fn parse_fn_expr(p: parser, proto: ast::proto) -> @ast::expr {\n     let lo = p.get_last_lo_pos();\n     let capture_clause = parse_capture_clause(p);\n-    let decl = parse_fn_decl(p, proto, ast::impure_fn);\n+    let decl = parse_fn_decl(p, ast::impure_fn);\n     let body = parse_block(p);\n     ret mk_expr(p, lo, body.span.hi,\n-                ast::expr_fn(decl, body, capture_clause));\n+                ast::expr_fn(proto, decl, body, capture_clause));\n }\n \n fn parse_fn_block_expr(p: parser) -> @ast::expr {\n@@ -1738,7 +1738,7 @@ fn parse_ty_params(p: parser) -> [ast::ty_param] {\n     } else { [] }\n }\n \n-fn parse_fn_decl(p: parser, proto: ast::proto, purity: ast::purity)\n+fn parse_fn_decl(p: parser, purity: ast::purity)\n     -> ast::fn_decl {\n     let inputs: ast::spanned<[ast::arg]> =\n         parse_seq(token::LPAREN, token::RPAREN, seq_sep(token::COMMA),\n@@ -1752,8 +1752,7 @@ fn parse_fn_decl(p: parser, proto: ast::proto, purity: ast::purity)\n         constrs = parse_constrs({|x| parse_ty_constr(inputs.node, x) }, p);\n     }\n     let (ret_style, ret_ty) = parse_ret_ty(p);\n-    ret {proto: proto,\n-         inputs: inputs.node,\n+    ret {inputs: inputs.node,\n          output: ret_ty,\n          purity: purity,\n          cf: ret_style,\n@@ -1766,8 +1765,7 @@ fn parse_fn_block_decl(p: parser) -> ast::fn_decl {\n                   seq_sep(token::COMMA), parse_fn_block_arg, p).node;\n     let output = eat(p, token::RARROW) ? parse_ty(p, false) :\n         @spanned(p.get_lo_pos(), p.get_hi_pos(), ast::ty_infer);\n-    ret {proto: ast::proto_block,\n-         inputs: inputs,\n+    ret {inputs: inputs,\n          output: output,\n          purity: ast::impure_fn,\n          cf: ast::return_val,\n@@ -1789,11 +1787,11 @@ fn mk_item(p: parser, lo: uint, hi: uint, ident: ast::ident, node: ast::item_,\n           span: ast_util::mk_sp(lo, hi)};\n }\n \n-fn parse_item_fn(p: parser, purity: ast::purity, proto: ast::proto,\n+fn parse_item_fn(p: parser, purity: ast::purity,\n                  attrs: [ast::attribute]) -> @ast::item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, proto, purity);\n+    let decl = parse_fn_decl(p, purity);\n     let body = parse_block(p);\n     ret mk_item(p, lo, body.span.hi, t.ident,\n                 ast::item_fn(decl, t.tps, body), attrs);\n@@ -1819,10 +1817,10 @@ fn parse_anon_obj_field(p: parser) -> ast::anon_obj_field {\n \n fn parse_method(p: parser, allow_tps: bool) -> @ast::method {\n     let lo = p.get_lo_pos();\n-    let proto = parse_method_proto(p);\n+    expect_word(p, \"fn\");\n     let ident = parse_value_ident(p);\n     let tps = allow_tps ? parse_ty_params(p) : [];\n-    let decl = parse_fn_decl(p, proto, ast::impure_fn);\n+    let decl = parse_fn_decl(p, ast::impure_fn);\n     let body = parse_block(p);\n     @{ident: ident, tps: tps, decl: decl, body: body,\n       id: p.get_id(), span: ast_util::mk_sp(lo, body.span.hi)}\n@@ -1900,8 +1898,7 @@ fn parse_item_res(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     expect(p, token::RPAREN);\n     let dtor = parse_block_no_value(p);\n     let decl =\n-        {proto: ast::proto_bare,\n-         inputs:\n+        {inputs:\n              [{mode: ast::by_ref, ty: t, ident: arg_ident,\n                id: p.get_id()}],\n          output: @spanned(lo, lo, ast::ty_nil),\n@@ -1974,7 +1971,7 @@ fn parse_item_native_fn(p: parser, attrs: [ast::attribute],\n                         purity: ast::purity) -> @ast::native_item {\n     let lo = p.get_last_lo_pos();\n     let t = parse_fn_header(p);\n-    let decl = parse_fn_decl(p, ast::proto_bare, purity);\n+    let decl = parse_fn_decl(p, purity);\n     let hi = p.get_hi_pos();\n     expect(p, token::SEMI);\n     ret @{ident: t.ident,\n@@ -2107,10 +2104,6 @@ fn parse_item_tag(p: parser, attrs: [ast::attribute]) -> @ast::item {\n     ret mk_item(p, lo, hi, id, ast::item_tag(variants, ty_params), attrs);\n }\n \n-fn parse_fn_item_proto(_p: parser) -> ast::proto {\n-    ast::proto_bare\n-}\n-\n fn parse_fn_ty_proto(p: parser) -> ast::proto {\n     if p.peek() == token::AT {\n         p.bump();\n@@ -2120,32 +2113,22 @@ fn parse_fn_ty_proto(p: parser) -> ast::proto {\n     }\n }\n \n-fn parse_method_proto(p: parser) -> ast::proto {\n-    if eat_word(p, \"fn\") {\n-        ret ast::proto_bare;\n-    } else { unexpected(p, p.peek()); }\n-}\n-\n fn parse_item(p: parser, attrs: [ast::attribute]) -> option::t<@ast::item> {\n     if eat_word(p, \"const\") {\n         ret some(parse_item_const(p, attrs));\n     } else if eat_word(p, \"inline\") {\n         expect_word(p, \"fn\");\n-        let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::impure_fn, proto, attrs));\n+        ret some(parse_item_fn(p, ast::impure_fn, attrs));\n     } else if is_word(p, \"fn\") && p.look_ahead(1u) != token::LPAREN {\n         p.bump();\n-        let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::impure_fn, proto, attrs));\n+        ret some(parse_item_fn(p, ast::impure_fn, attrs));\n     } else if eat_word(p, \"pure\") {\n         expect_word(p, \"fn\");\n-        let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::pure_fn, proto, attrs));\n+        ret some(parse_item_fn(p, ast::pure_fn, attrs));\n     } else if is_word(p, \"unsafe\") && p.look_ahead(1u) != token::LBRACE {\n         p.bump();\n         expect_word(p, \"fn\");\n-        let proto = parse_fn_item_proto(p);\n-        ret some(parse_item_fn(p, ast::unsafe_fn, proto, attrs));\n+        ret some(parse_item_fn(p, ast::unsafe_fn, attrs));\n     } else if eat_word(p, \"mod\") {\n         ret some(parse_item_mod(p, attrs));\n     } else if eat_word(p, \"native\") {"}, {"sha": "c8f6b1b0a8755984c474f92c953b8f9a5b378085", "filename": "src/comp/syntax/print/pprust.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fprint%2Fpprust.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -305,8 +305,8 @@ fn print_type(s: ps, &&ty: @ast::ty) {\n         commasep(s, inconsistent, elts, print_type);\n         pclose(s);\n       }\n-      ast::ty_fn(d) {\n-        print_ty_fn(s, d, none::<str>);\n+      ast::ty_fn(proto, d) {\n+        print_ty_fn(s, proto, d, none::<str>);\n       }\n       ast::ty_obj(methods) {\n         head(s, \"obj\");\n@@ -519,7 +519,7 @@ fn print_ty_method(s: ps, m: ast::ty_method) {\n     hardbreak_if_not_bol(s);\n     cbox(s, indent_unit);\n     maybe_print_comment(s, m.span.lo);\n-    print_ty_fn(s, m.decl, some(m.ident));\n+    print_ty_fn(s, ast::proto_bare, m.decl, some(m.ident));\n     word(s.s, \";\");\n     end(s);\n }\n@@ -840,8 +840,8 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n         }\n         bclose_(s, expr.span, alt_indent_unit);\n       }\n-      ast::expr_fn(decl, body, captures) { // NDM captures\n-        head(s, proto_to_str(decl.proto));\n+      ast::expr_fn(proto, decl, body, captures) { // NDM captures\n+        head(s, proto_to_str(proto));\n         print_fn_args_and_ret(s, decl);\n         space(s.s);\n         print_block(s, body);\n@@ -1147,8 +1147,9 @@ fn print_pat(s: ps, &&pat: @ast::pat) {\n fn print_fn(s: ps, decl: ast::fn_decl, name: ast::ident,\n             typarams: [ast::ty_param]) {\n     alt decl.purity {\n-      ast::impure_fn. { head(s, proto_to_str(decl.proto)); }\n-      _ { head(s, \"pure fn\"); }\n+      ast::impure_fn. { head(s, \"fn\"); }\n+      ast::unsafe_fn. { head(s, \"unsafe fn\"); }\n+      ast::pure_fn. { head(s, \"pure fn\"); }\n     }\n     word(s.s, name);\n     print_type_params(s, typarams);\n@@ -1360,9 +1361,10 @@ fn print_mt(s: ps, mt: ast::mt) {\n     print_type(s, mt.ty);\n }\n \n-fn print_ty_fn(s: ps, decl: ast::fn_decl, id: option::t<ast::ident>) {\n+fn print_ty_fn(s: ps, proto: ast::proto,\n+               decl: ast::fn_decl, id: option::t<ast::ident>) {\n     ibox(s, indent_unit);\n-    word(s.s, proto_to_str(decl.proto));\n+    word(s.s, proto_to_str(proto));\n     alt id { some(id) { word(s.s, \" \"); word(s.s, id); } _ { } }\n     zerobreak(s.s);\n     popen(s);"}, {"sha": "e27671603029de1fbdeb6f0759422a29bfb5e703", "filename": "src/comp/syntax/visit.rs", "status": "modified", "additions": 49, "deletions": 28, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Fsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Fvisit.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -15,6 +15,28 @@ import codemap::span;\n // hold functions that take visitors. A vt tag is used to break the cycle.\n tag vt<E> { mk_vt(visitor<E>); }\n \n+tag fn_kind {\n+    fk_item_fn(ident, [ty_param]); //< an item declared with fn()\n+    fk_method(ident, [ty_param]);\n+    fk_res(ident, [ty_param]);\n+    fk_anon(proto);  //< an anonymous function like lambda(...)\n+    fk_fn_block;     //< a block {||...}\n+}\n+\n+fn name_of_fn(fk: fn_kind) -> ident {\n+    alt fk {\n+      fk_item_fn(name, _) | fk_method(name, _) | fk_res(name, _) { name }\n+      fk_anon(_) | fk_fn_block. { \"anon\" }\n+    }\n+}\n+\n+fn tps_of_fn(fk: fn_kind) -> [ty_param] {\n+    alt fk {\n+      fk_item_fn(_, tps) | fk_method(_, tps) | fk_res(_, tps) { tps }\n+      fk_anon(_) | fk_fn_block. { [] }\n+    }\n+}\n+\n type visitor<E> =\n     // takes the components so that one function can be\n     // generic over constr and ty_constr\n@@ -31,8 +53,7 @@ type visitor<E> =\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_ty: fn@(@ty, E, vt<E>),\n       visit_constr: fn@(@path, span, node_id, E, vt<E>),\n-      visit_fn: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id,\n-                    E, vt<E>)};\n+      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>)};\n \n fn default_visitor<E>() -> visitor<E> {\n     ret @{visit_mod: bind visit_mod::<E>(_, _, _, _),\n@@ -48,7 +69,7 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_expr: bind visit_expr::<E>(_, _, _),\n           visit_ty: bind skip_ty::<E>(_, _, _),\n           visit_constr: bind visit_constr::<E>(_, _, _, _, _),\n-          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _, _)};\n+          visit_fn: bind visit_fn::<E>(_, _, _, _, _, _, _)};\n }\n \n fn visit_crate<E>(c: crate, e: E, v: vt<E>) {\n@@ -85,7 +106,7 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n     alt i.node {\n       item_const(t, ex) { v.visit_ty(t, e, v); v.visit_expr(ex, e, v); }\n       item_fn(decl, tp, body) {\n-        v.visit_fn(decl, tp, body, i.span, some(i.ident), i.id, e, v);\n+        v.visit_fn(fk_item_fn(i.ident, tp), decl, body, i.span, i.id, e, v);\n       }\n       item_mod(m) { v.visit_mod(m, i.span, e, v); }\n       item_native_mod(nm) {\n@@ -94,8 +115,8 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n       }\n       item_ty(t, tps) { v.visit_ty(t, e, v); visit_ty_params(tps, e, v); }\n       item_res(decl, tps, body, dtor_id, _) {\n-        v.visit_fn(decl, tps, body, i.span, some(i.ident), dtor_id,\n-                   e, v);\n+        v.visit_fn(fk_res(i.ident, tps), decl, body, i.span,\n+                   dtor_id, e, v);\n       }\n       item_tag(variants, tps) {\n         visit_ty_params(tps, e, v);\n@@ -107,17 +128,17 @@ fn visit_item<E>(i: @item, e: E, v: vt<E>) {\n         visit_ty_params(tps, e, v);\n         for f: obj_field in ob.fields { v.visit_ty(f.ty, e, v); }\n         for m: @method in ob.methods {\n-            v.visit_fn(m.decl, m.tps, m.body, m.span,\n-                       some(m.ident), m.id, e, v);\n+            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n+                       m.id, e, v);\n         }\n       }\n       item_impl(tps, ifce, ty, methods) {\n         visit_ty_params(tps, e, v);\n         alt ifce { some(ty) { v.visit_ty(ty, e, v); } _ {} }\n         v.visit_ty(ty, e, v);\n         for m in methods {\n-            v.visit_fn(m.decl, m.tps, m.body, m.span,\n-                       some(m.ident), m.id, e, v);\n+            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n+                       m.id, e, v);\n         }\n       }\n       item_iface(tps, methods) {\n@@ -142,7 +163,7 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n         for f: ty_field in flds { v.visit_ty(f.node.mt.ty, e, v); }\n       }\n       ty_tup(ts) { for tt in ts { v.visit_ty(tt, e, v); } }\n-      ty_fn(decl) {\n+      ty_fn(_, decl) {\n         for a in decl.inputs { v.visit_ty(a.ty, e, v); }\n         for c: @constr in decl.constraints {\n             v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n@@ -222,10 +243,10 @@ fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     v.visit_ty(fd.output, e, v);\n }\n \n-fn visit_fn<E>(decl: fn_decl, tp: [ty_param], body: blk, _sp: span,\n-               _i: fn_ident, _id: node_id, e: E, v: vt<E>) {\n+fn visit_fn<E>(fk: fn_kind, decl: fn_decl, body: blk, _sp: span,\n+               _id: node_id, e: E, v: vt<E>) {\n     visit_fn_decl(decl, e, v);\n-    visit_ty_params(tp, e, v);\n+    visit_ty_params(tps_of_fn(fk), e, v);\n     v.visit_block(body, e, v);\n }\n \n@@ -314,11 +335,11 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n         v.visit_expr(x, e, v);\n         for a: arm in arms { v.visit_arm(a, e, v); }\n       }\n-      expr_fn(decl, body, _) {\n-        v.visit_fn(decl, [], body, ex.span, none, ex.id, e, v);\n+      expr_fn(proto, decl, body, _) {\n+        v.visit_fn(fk_anon(proto), decl, body, ex.span, ex.id, e, v);\n       }\n       expr_fn_block(decl, body) {\n-        v.visit_fn(decl, [], body, ex.span, none, ex.id, e, v);\n+        v.visit_fn(fk_fn_block, decl, body, ex.span, ex.id, e, v);\n       }\n       expr_block(b) { v.visit_block(b, e, v); }\n       expr_assign(a, b) { v.visit_expr(b, e, v); v.visit_expr(a, e, v); }\n@@ -361,8 +382,8 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n           some(ex) { v.visit_expr(ex, e, v); }\n         }\n         for m: @method in anon_obj.methods {\n-            v.visit_fn(m.decl, m.tps, m.body, m.span,\n-                       some(m.ident), m.id, e, v);\n+            v.visit_fn(fk_method(m.ident, m.tps), m.decl, m.body, m.span,\n+                       m.id, e, v);\n         }\n       }\n       expr_mac(mac) { visit_mac(mac, e, v); }\n@@ -394,7 +415,7 @@ type simple_visitor =\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n       visit_constr: fn@(@path, span, node_id),\n-      visit_fn: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id)};\n+      visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id)};\n \n fn simple_ignore_ty(_t: @ty) {}\n \n@@ -412,8 +433,8 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_expr: fn(_e: @expr) { },\n           visit_ty: simple_ignore_ty,\n           visit_constr: fn(_p: @path, _sp: span, _id: node_id) { },\n-          visit_fn: fn(_d: fn_decl, _tps: [ty_param], _b: blk, _sp: span,\n-                       _ident: fn_ident, _id: node_id) { }\n+          visit_fn: fn(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n+                       _id: node_id) { }\n          };\n }\n \n@@ -472,11 +493,11 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(pt, sp, id);\n         visit_constr(pt, sp, id, e, v);\n     }\n-    fn v_fn(f: fn@(fn_decl, [ty_param], blk, span, fn_ident, node_id),\n-            decl: fn_decl, tps: [ty_param], body: blk, sp: span,\n-            ident: fn_ident, id: node_id, &&e: (), v: vt<()>) {\n-        f(decl, tps, body, sp, ident, id);\n-        visit_fn(decl, tps, body, sp, ident, id, e, v);\n+    fn v_fn(f: fn@(fn_kind, fn_decl, blk, span, node_id),\n+            fk: fn_kind, decl: fn_decl, body: blk, sp: span,\n+            id: node_id, &&e: (), v: vt<()>) {\n+        f(fk, decl, body, sp, id);\n+        visit_fn(fk, decl, body, sp, id, e, v);\n     }\n     let visit_ty = if v.visit_ty == simple_ignore_ty {\n         bind skip_ty(_, _, _)\n@@ -497,7 +518,7 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_expr: bind v_expr(v.visit_expr, _, _, _),\n                 visit_ty: visit_ty,\n                 visit_constr: bind v_constr(v.visit_constr, _, _, _, _, _),\n-                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _, _)\n+                visit_fn: bind v_fn(v.visit_fn, _, _, _, _, _, _, _)\n                });\n }\n "}, {"sha": "ec1b90572c0b69a992d804c3596768db0d9499bb", "filename": "src/comp/util/ppaux.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Fcomp%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fppaux.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -23,10 +23,6 @@ fn mode_str_1(m: ty::mode) -> str {\n     alt m { ast::by_ref. { \"ref\" } _ { mode_str(m) } }\n }\n \n-fn fn_ident_to_string(id: ast::node_id, i: ast::fn_ident) -> str {\n-    ret alt i { none. { \"anon\" + int::str(id) } some(s) { s } };\n-}\n-\n fn ty_to_str(cx: ctxt, typ: t) -> str {\n     fn fn_input_to_str(cx: ctxt, input: {mode: middle::ty::mode, ty: t}) ->\n        str {"}, {"sha": "caef692060e667df5f8df69a1b8b4a50b815b540", "filename": "src/test/run-pass/block-arg-call-as.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aa5382bb13690ff183f6e94065dadf0524ce1c6e/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg-call-as.rs?ref=aa5382bb13690ff183f6e94065dadf0524ce1c6e", "patch": "@@ -0,0 +1,22 @@\n+use std;\n+\n+fn asSendfn( f : sendfn()->uint ) -> uint {\n+   ret f();\n+}\n+\n+fn asLambda( f : lambda()->uint ) -> uint {\n+   ret f();\n+}\n+\n+fn asBlock( f : block()->uint ) -> uint {\n+   ret f();\n+}\n+\n+fn main() {\n+   let x = asSendfn({|| 22u});\n+   assert(x == 22u);\n+   let x = asLambda({|| 22u});\n+   assert(x == 22u);\n+   let x = asBlock({|| 22u});\n+   assert(x == 22u);\n+}"}]}