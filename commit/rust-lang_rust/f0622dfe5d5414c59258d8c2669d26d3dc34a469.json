{"sha": "f0622dfe5d5414c59258d8c2669d26d3dc34a469", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYwNjIyZGZlNWQ1NDE0YzU5MjU4ZDhjMjY2OWQyNmQzZGMzNGE0Njk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-10T19:24:24Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-06-28T08:04:50Z"}, "message": "Use `Ident`s for associated item definitions in HIR\n\nRemove emulation of hygiene with gensyms", "tree": {"sha": "b03f6d2decf23f587659df808a7dae472d55b59d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b03f6d2decf23f587659df808a7dae472d55b59d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f0622dfe5d5414c59258d8c2669d26d3dc34a469", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f0622dfe5d5414c59258d8c2669d26d3dc34a469", "html_url": "https://github.com/rust-lang/rust/commit/f0622dfe5d5414c59258d8c2669d26d3dc34a469", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f0622dfe5d5414c59258d8c2669d26d3dc34a469/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c6ca1e4abdb9476d8aa68457414ef80c5249caee", "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ca1e4abdb9476d8aa68457414ef80c5249caee", "html_url": "https://github.com/rust-lang/rust/commit/c6ca1e4abdb9476d8aa68457414ef80c5249caee"}], "stats": {"total": 383, "additions": 176, "deletions": 207}, "files": [{"sha": "f792a24503a3e054f536ab86f46ebf6c16eb75f0", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -57,7 +57,7 @@ pub enum FnKind<'a> {\n     ItemFn(Name, &'a Generics, FnHeader, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n+    Method(Ident, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n     Closure(&'a [Attribute]),\n@@ -823,7 +823,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n }\n \n pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v TraitItem) {\n-    visitor.visit_name(trait_item.span, trait_item.name);\n+    visitor.visit_ident(trait_item.ident);\n     walk_list!(visitor, visit_attribute, &trait_item.attrs);\n     visitor.visit_generics(&trait_item.generics);\n     match trait_item.node {\n@@ -840,7 +840,7 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             }\n         }\n         TraitItemKind::Method(ref sig, TraitMethod::Provided(body_id)) => {\n-            visitor.visit_fn(FnKind::Method(trait_item.name,\n+            visitor.visit_fn(FnKind::Method(trait_item.ident,\n                                             sig,\n                                             None,\n                                             &trait_item.attrs),\n@@ -859,9 +859,9 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n \n pub fn walk_trait_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, trait_item_ref: &'v TraitItemRef) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let TraitItemRef { id, name, ref kind, span, ref defaultness } = *trait_item_ref;\n+    let TraitItemRef { id, ident, ref kind, span: _, ref defaultness } = *trait_item_ref;\n     visitor.visit_nested_trait_item(id);\n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);\n     visitor.visit_defaultness(defaultness);\n }\n@@ -871,16 +871,16 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n     let ImplItem {\n         id: _,\n         hir_id: _,\n-        name,\n+        ident,\n         ref vis,\n         ref defaultness,\n         ref attrs,\n         ref generics,\n         ref node,\n-        span\n+        span: _,\n     } = *impl_item;\n \n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);\n     walk_list!(visitor, visit_attribute, attrs);\n@@ -892,7 +892,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n             visitor.visit_nested_body(body);\n         }\n         ImplItemKind::Method(ref sig, body_id) => {\n-            visitor.visit_fn(FnKind::Method(impl_item.name,\n+            visitor.visit_fn(FnKind::Method(impl_item.ident,\n                                             sig,\n                                             Some(&impl_item.vis),\n                                             &impl_item.attrs),\n@@ -910,9 +910,9 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n \n pub fn walk_impl_item_ref<'v, V: Visitor<'v>>(visitor: &mut V, impl_item_ref: &'v ImplItemRef) {\n     // NB: Deliberately force a compilation error if/when new fields are added.\n-    let ImplItemRef { id, name, ref kind, span, ref vis, ref defaultness } = *impl_item_ref;\n+    let ImplItemRef { id, ident, ref kind, span: _, ref vis, ref defaultness } = *impl_item_ref;\n     visitor.visit_nested_impl_item(id);\n-    visitor.visit_name(span, name);\n+    visitor.visit_ident(ident);\n     visitor.visit_associated_item_kind(kind);\n     visitor.visit_vis(vis);\n     visitor.visit_defaultness(defaultness);"}, {"sha": "96f247f90d15351f64e60354be592d3b108fe08e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -52,7 +52,7 @@ use middle::cstore::CrateStore;\n use rustc_data_structures::indexed_vec::IndexVec;\n use session::Session;\n use util::common::FN_OUTPUT_NAME;\n-use util::nodemap::{DefIdMap, FxHashMap, NodeMap};\n+use util::nodemap::{DefIdMap, NodeMap};\n \n use std::collections::{BTreeMap, HashSet};\n use std::fmt::Debug;\n@@ -85,7 +85,6 @@ pub struct LoweringContext<'a> {\n     cstore: &'a CrateStore,\n \n     resolver: &'a mut Resolver,\n-    name_map: FxHashMap<Ident, Name>,\n \n     /// The items being lowered are collected here.\n     items: BTreeMap<NodeId, hir::Item>,\n@@ -210,7 +209,6 @@ pub fn lower_crate(\n         sess,\n         cstore,\n         resolver,\n-        name_map: FxHashMap(),\n         items: BTreeMap::new(),\n         trait_items: BTreeMap::new(),\n         impl_items: BTreeMap::new(),\n@@ -957,16 +955,6 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n-    fn lower_ident(&mut self, ident: Ident) -> Name {\n-        let ident = ident.modern();\n-        if ident.span.ctxt() == SyntaxContext::empty() {\n-            return ident.name;\n-        }\n-        *self.name_map\n-            .entry(ident)\n-            .or_insert_with(|| Symbol::from_ident(ident))\n-    }\n-\n     fn lower_label(&mut self, label: Option<Label>) -> Option<hir::Label> {\n         label.map(|label| hir::Label {\n             ident: label.ident,\n@@ -2962,7 +2950,7 @@ impl<'a> LoweringContext<'a> {\n         hir::TraitItem {\n             id: node_id,\n             hir_id,\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n             node,\n@@ -2988,7 +2976,7 @@ impl<'a> LoweringContext<'a> {\n         };\n         hir::TraitItemRef {\n             id: hir::TraitItemId { node_id: i.id },\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             span: i.span,\n             defaultness: self.lower_defaultness(Defaultness::Default, has_default),\n             kind,\n@@ -3054,7 +3042,7 @@ impl<'a> LoweringContext<'a> {\n         hir::ImplItem {\n             id: node_id,\n             hir_id,\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             attrs: self.lower_attrs(&i.attrs),\n             generics,\n             vis: self.lower_visibility(&i.vis, None),\n@@ -3069,7 +3057,7 @@ impl<'a> LoweringContext<'a> {\n     fn lower_impl_item_ref(&mut self, i: &ImplItem) -> hir::ImplItemRef {\n         hir::ImplItemRef {\n             id: hir::ImplItemId { node_id: i.id },\n-            name: self.lower_ident(i.ident),\n+            ident: i.ident,\n             span: i.span,\n             vis: self.lower_visibility(&i.vis, Some(i.id)),\n             defaultness: self.lower_defaultness(i.defaultness, true /* [1] */),"}, {"sha": "930db8b0ccc3f06bc0eec13c146562a069d665ce", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -25,7 +25,7 @@ use hir as ast;\n use hir::map::{self, Node};\n use hir::{Expr, FnDecl};\n use hir::intravisit::FnKind;\n-use syntax::ast::{Attribute, Name, NodeId};\n+use syntax::ast::{Attribute, Ident, Name, NodeId};\n use syntax_pos::Span;\n \n /// An FnLikeNode is a Node that is like a fn, in that it has a decl\n@@ -209,16 +209,16 @@ impl<'a> FnLikeNode<'a> {\n         let closure = |c: ClosureParts<'a>| {\n             FnKind::Closure(c.attrs)\n         };\n-        let method = |_, name: Name, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n-            FnKind::Method(name, sig, vis, attrs)\n+        let method = |_, ident: Ident, sig: &'a ast::MethodSig, vis, _, _, attrs| {\n+            FnKind::Method(ident, sig, vis, attrs)\n         };\n         self.handle(item, method, closure)\n     }\n \n     fn handle<A, I, M, C>(self, item_fn: I, method: M, closure: C) -> A where\n         I: FnOnce(ItemFnParts<'a>) -> A,\n         M: FnOnce(NodeId,\n-                  Name,\n+                  Ident,\n                   &'a ast::MethodSig,\n                   Option<&'a ast::Visibility>,\n                   ast::BodyId,\n@@ -245,14 +245,14 @@ impl<'a> FnLikeNode<'a> {\n             },\n             map::NodeTraitItem(ti) => match ti.node {\n                 ast::TraitItemKind::Method(ref sig, ast::TraitMethod::Provided(body)) => {\n-                    method(ti.id, ti.name, sig, None, body, ti.span, &ti.attrs)\n+                    method(ti.id, ti.ident, sig, None, body, ti.span, &ti.attrs)\n                 }\n                 _ => bug!(\"trait method FnLikeNode that is not fn-like\"),\n             },\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, body) => {\n-                        method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.id, ii.ident, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "2d3e9804835efa0c94c63a3ad101a43d2a854ec4", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -495,7 +495,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let TraitItemRef {\n             id,\n-            name: _,\n+            ident: _,\n             kind: _,\n             span: _,\n             defaultness: _,\n@@ -509,7 +509,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         // map the actual nodes, not the duplicate ones in the *Ref.\n         let ImplItemRef {\n             id,\n-            name: _,\n+            ident: _,\n             kind: _,\n             span: _,\n             vis: _,"}, {"sha": "5f390f20acaca1d911a9608615252d47bb949ec9", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -949,8 +949,8 @@ impl<'hir> Map<'hir> {\n         match self.get(id) {\n             NodeItem(i) => i.name,\n             NodeForeignItem(i) => i.name,\n-            NodeImplItem(ii) => ii.name,\n-            NodeTraitItem(ti) => ti.name,\n+            NodeImplItem(ii) => ii.ident.name,\n+            NodeTraitItem(ti) => ti.ident.name,\n             NodeVariant(v) => v.node.name,\n             NodeField(f) => f.ident.name,\n             NodeLifetime(lt) => lt.name.ident().name,\n@@ -1149,8 +1149,8 @@ impl Named for Item { fn name(&self) -> Name { self.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.name } }\n impl Named for Variant_ { fn name(&self) -> Name { self.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n-impl Named for TraitItem { fn name(&self) -> Name { self.name } }\n-impl Named for ImplItem { fn name(&self) -> Name { self.name } }\n+impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n+impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n \n \n pub fn map_crate<'hir>(sess: &::session::Session,\n@@ -1309,13 +1309,13 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n         Some(NodeImplItem(ii)) => {\n             match ii.node {\n                 ImplItemKind::Const(..) => {\n-                    format!(\"assoc const {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"assoc const {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n                 ImplItemKind::Method(..) => {\n-                    format!(\"method {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"method {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n                 ImplItemKind::Type(_) => {\n-                    format!(\"assoc type {} in {}{}\", ii.name, path_str(), id_str)\n+                    format!(\"assoc type {} in {}{}\", ii.ident, path_str(), id_str)\n                 }\n             }\n         }\n@@ -1326,7 +1326,7 @@ fn node_id_to_string(map: &Map, id: NodeId, include_id: bool) -> String {\n                 TraitItemKind::Type(..) => \"assoc type\",\n             };\n \n-            format!(\"{} {} in {}{}\", kind, ti.name, path_str(), id_str)\n+            format!(\"{} {} in {}{}\", kind, ti.ident, path_str(), id_str)\n         }\n         Some(NodeVariant(ref variant)) => {\n             format!(\"variant {} in {}{}\","}, {"sha": "e46c0ba6f119a29199fbe1fac4b7a8d7cd703506", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1536,7 +1536,7 @@ pub struct TraitItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItem {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub hir_id: HirId,\n     pub attrs: HirVec<Attribute>,\n     pub generics: Generics,\n@@ -1579,7 +1579,7 @@ pub struct ImplItemId {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItem {\n     pub id: NodeId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub hir_id: HirId,\n     pub vis: Visibility,\n     pub defaultness: Defaultness,\n@@ -2140,7 +2140,7 @@ impl Item_ {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct TraitItemRef {\n     pub id: TraitItemId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub defaultness: Defaultness,\n@@ -2155,7 +2155,7 @@ pub struct TraitItemRef {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct ImplItemRef {\n     pub id: ImplItemId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedItemKind,\n     pub span: Span,\n     pub vis: Visibility,"}, {"sha": "40dc9d04f21e40a2a4708f16e716e5babab15a4d", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -497,14 +497,14 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_const(&mut self,\n-                              name: ast::Name,\n+                              ident: ast::Ident,\n                               ty: &hir::Ty,\n                               default: Option<hir::BodyId>,\n                               vis: &hir::Visibility)\n                               -> io::Result<()> {\n         self.s.word(&visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n-        self.print_name(name)?;\n+        self.print_ident(ident)?;\n         self.word_space(\":\")?;\n         self.print_type(ty)?;\n         if let Some(expr) = default {\n@@ -516,12 +516,12 @@ impl<'a> State<'a> {\n     }\n \n     fn print_associated_type(&mut self,\n-                             name: ast::Name,\n+                             ident: ast::Ident,\n                              bounds: Option<&hir::GenericBounds>,\n                              ty: Option<&hir::Ty>)\n                              -> io::Result<()> {\n         self.word_space(\"type\")?;\n-        self.print_name(name)?;\n+        self.print_ident(ident)?;\n         if let Some(bounds) = bounds {\n             self.print_bounds(\":\", bounds)?;\n         }\n@@ -929,7 +929,7 @@ impl<'a> State<'a> {\n         Ok(())\n     }\n     pub fn print_method_sig(&mut self,\n-                            name: ast::Name,\n+                            ident: ast::Ident,\n                             m: &hir::MethodSig,\n                             generics: &hir::Generics,\n                             vis: &hir::Visibility,\n@@ -938,7 +938,7 @@ impl<'a> State<'a> {\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.header,\n-                      Some(name),\n+                      Some(ident.name),\n                       generics,\n                       vis,\n                       arg_names,\n@@ -952,24 +952,24 @@ impl<'a> State<'a> {\n         self.print_outer_attributes(&ti.attrs)?;\n         match ti.node {\n             hir::TraitItemKind::Const(ref ty, default) => {\n-                self.print_associated_const(ti.name, &ty, default, &hir::Inherited)?;\n+                self.print_associated_const(ti.ident, &ty, default, &hir::Inherited)?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Required(ref arg_names)) => {\n-                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, arg_names,\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, arg_names,\n                     None)?;\n                 self.s.word(\";\")?;\n             }\n             hir::TraitItemKind::Method(ref sig, hir::TraitMethod::Provided(body)) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ti.name, sig, &ti.generics, &hir::Inherited, &[],\n+                self.print_method_sig(ti.ident, sig, &ti.generics, &hir::Inherited, &[],\n                     Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::TraitItemKind::Type(ref bounds, ref default) => {\n-                self.print_associated_type(ti.name,\n+                self.print_associated_type(ti.ident,\n                                            Some(bounds),\n                                            default.as_ref().map(|ty| &**ty))?;\n             }\n@@ -986,18 +986,18 @@ impl<'a> State<'a> {\n \n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(expr), &ii.vis)?;\n+                self.print_associated_const(ii.ident, &ty, Some(expr), &ii.vis)?;\n             }\n             hir::ImplItemKind::Method(ref sig, body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, &ii.generics, &ii.vis, &[], Some(body))?;\n+                self.print_method_sig(ii.ident, sig, &ii.generics, &ii.vis, &[], Some(body))?;\n                 self.nbsp()?;\n                 self.end()?; // need to close a box\n                 self.end()?; // need to close a box\n                 self.ann.nested(self, Nested::Body(body))?;\n             }\n             hir::ImplItemKind::Type(ref ty) => {\n-                self.print_associated_type(ii.name, None, Some(ty))?;\n+                self.print_associated_type(ii.ident, None, Some(ty))?;\n             }\n         }\n         self.ann.post(self, NodeSubItem(ii.id))\n@@ -1615,7 +1615,7 @@ impl<'a> State<'a> {\n     }\n \n     pub fn print_name(&mut self, name: ast::Name) -> io::Result<()> {\n-        self.print_ident(name.to_ident())\n+        self.print_ident(ast::Ident::with_empty_ctxt(name))\n     }\n \n     pub fn print_for_decl(&mut self, loc: &hir::Local, coll: &hir::Expr) -> io::Result<()> {"}, {"sha": "9ab3acdce5e7e2302c2a03c6f4630f378b657d85", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -705,15 +705,15 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::TraitItem {\n         let hir::TraitItem {\n             id: _,\n             hir_id: _,\n-            name,\n+            ident,\n             ref attrs,\n             ref generics,\n             ref node,\n             span\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n-            name.hash_stable(hcx, hasher);\n+            ident.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n             generics.hash_stable(hcx, hasher);\n             node.hash_stable(hcx, hasher);\n@@ -740,7 +740,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n         let hir::ImplItem {\n             id: _,\n             hir_id: _,\n-            name,\n+            ident,\n             ref vis,\n             defaultness,\n             ref attrs,\n@@ -750,7 +750,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::ImplItem {\n         } = *self;\n \n         hcx.hash_hir_item_like(|hcx| {\n-            name.hash_stable(hcx, hasher);\n+            ident.hash_stable(hcx, hasher);\n             vis.hash_stable(hcx, hasher);\n             defaultness.hash_stable(hcx, hasher);\n             attrs.hash_stable(hcx, hasher);\n@@ -916,15 +916,15 @@ impl_stable_hash_for!(enum hir::Item_ {\n \n impl_stable_hash_for!(struct hir::TraitItemRef {\n     id,\n-    name,\n+    ident,\n     kind,\n     span,\n     defaultness\n });\n \n impl_stable_hash_for!(struct hir::ImplItemRef {\n     id,\n-    name,\n+    ident,\n     kind,\n     span,\n     vis,"}, {"sha": "e4214926b4ca5637a8d7a4badd4cf0c8b649076e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1133,7 +1133,7 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for ty::CratePredicatesMap<'\n \n impl_stable_hash_for!(struct ty::AssociatedItem {\n     def_id,\n-    name,\n+    ident,\n     kind,\n     vis,\n     defaultness,"}, {"sha": "482af9c005f32e42f39759d166b081daf5d65e4a", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1255,7 +1255,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             infer::LateBoundRegion(_, br, infer::AssocTypeProjection(def_id)) => format!(\n                 \" for lifetime parameter {}in trait containing associated type `{}`\",\n                 br_string(br),\n-                self.tcx.associated_item(def_id).name\n+                self.tcx.associated_item(def_id).ident\n             ),\n             infer::EarlyBoundRegion(_, name) => format!(\" for lifetime parameter `{}`\", name),\n             infer::BoundRegionInCoherence(name) => {"}, {"sha": "caf73096ebf5e88e506091eff7779fcb72732ef1", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -599,7 +599,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     self.warn_dead_code(impl_item.id,\n                                         impl_item.span,\n-                                        impl_item.name,\n+                                        impl_item.ident.name,\n                                         \"associated const\",\n                                         \"used\");\n                 }\n@@ -608,7 +608,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n             hir::ImplItemKind::Method(_, body_id) => {\n                 if !self.symbol_is_live(impl_item.id, None) {\n                     let span = self.tcx.sess.codemap().def_span(impl_item.span);\n-                    self.warn_dead_code(impl_item.id, span, impl_item.name, \"method\", \"used\");\n+                    self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }\n                 self.visit_nested_body(body_id)\n             }"}, {"sha": "a289a2c21ce7f421c3d2876a8284e118c46adf68", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -744,7 +744,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     for impl_item_ref in impl_item_refs {\n                         let impl_item = self.tcx.hir.impl_item(impl_item_ref.id);\n                         let trait_item_def_id = self.tcx.associated_items(trait_did)\n-                            .find(|item| item.name == impl_item.name).map(|item| item.def_id);\n+                            .find(|item| item.ident.name == impl_item.ident.name)\n+                            .map(|item| item.def_id);\n                         if let Some(def_id) = trait_item_def_id {\n                             // Pass `None` to skip deprecation warnings.\n                             self.tcx.check_stability(def_id, None, impl_item.span);"}, {"sha": "fe2965146cb7f80be1762f2657dedfa2aae4f4a1", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             .filter(|item| item.kind == ty::AssociatedKind::Method)\n             .filter_map(|item| {\n                 self.object_safety_violation_for_method(trait_def_id, &item)\n-                    .map(|code| ObjectSafetyViolation::Method(item.name, code))\n+                    .map(|code| ObjectSafetyViolation::Method(item.ident.name, code))\n             }).filter(|violation| {\n                 if let ObjectSafetyViolation::Method(_,\n                                 MethodViolationCode::WhereClauseReferencesSelf(span)) = violation {\n@@ -159,7 +159,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         violations.extend(self.associated_items(trait_def_id)\n             .filter(|item| item.kind == ty::AssociatedKind::Const)\n-            .map(|item| ObjectSafetyViolation::AssociatedConst(item.name)));\n+            .map(|item| ObjectSafetyViolation::AssociatedConst(item.ident.name)));\n \n         debug!(\"object_safety_violations_for_trait(trait_def_id={:?}) = {:?}\",\n                trait_def_id,"}, {"sha": "97b15048b48f6a2db8eed5fbdfec91d8c7f5aa38", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -32,7 +32,6 @@ use middle::const_val::ConstVal;\n use mir::interpret::{GlobalId};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use syntax::ast::Ident;\n-use syntax::symbol::Symbol;\n use ty::subst::{Subst, Substs};\n use ty::{self, ToPredicate, ToPolyTraitRef, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder};\n@@ -1350,10 +1349,10 @@ fn confirm_generator_candidate<'cx, 'gcx, 'tcx>(\n                                             obligation.predicate.self_ty(),\n                                             gen_sig)\n         .map_bound(|(trait_ref, yield_ty, return_ty)| {\n-            let name = tcx.associated_item(obligation.predicate.item_def_id).name;\n-            let ty = if name == Symbol::intern(\"Return\") {\n+            let name = tcx.associated_item(obligation.predicate.item_def_id).ident.name;\n+            let ty = if name == \"Return\" {\n                 return_ty\n-            } else if name == Symbol::intern(\"Yield\") {\n+            } else if name == \"Yield\" {\n                 yield_ty\n             } else {\n                 bug!()\n@@ -1509,7 +1508,7 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n         // checker method `check_impl_items_against_trait`, so here we\n         // just return TyError.\n         debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-               assoc_ty.item.name,\n+               assoc_ty.item.ident,\n                obligation.predicate);\n         tcx.types.err\n     } else {\n@@ -1534,7 +1533,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n     let tcx = selcx.tcx();\n-    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).name;\n+    let assoc_ty_name = tcx.associated_item(assoc_ty_def_id).ident;\n     let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n     let trait_def = tcx.trait_def(trait_def_id);\n \n@@ -1547,7 +1546,7 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     let impl_node = specialization_graph::Node::Impl(impl_def_id);\n     for item in impl_node.items(tcx) {\n         if item.kind == ty::AssociatedKind::Type &&\n-                tcx.hygienic_eq(item.name.to_ident(), assoc_ty_name.to_ident(), trait_def_id) {\n+                tcx.hygienic_eq(item.ident, assoc_ty_name, trait_def_id) {\n             return specialization_graph::NodeItem {\n                 node: specialization_graph::Node::Impl(impl_def_id),\n                 item,"}, {"sha": "f151f3b2531a682a65c6ea42a15d6b19de77cdf1", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -129,7 +129,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def = tcx.trait_def(trait_def_id);\n \n     let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n-    match ancestors.defs(tcx, item.name, item.kind, trait_def_id).next() {\n+    match ancestors.defs(tcx, item.ident, item.kind, trait_def_id).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt().enter(|infcx| {\n                 let param_env = ty::ParamEnv::reveal_all();"}, {"sha": "b64e4228be9d21abae26c245aca4e7ff23bd30fc", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -18,7 +18,7 @@ use traits;\n use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n use rustc_data_structures::sync::Lrc;\n-use syntax::ast::Name;\n+use syntax::ast::Ident;\n use util::captures::Captures;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -372,14 +372,14 @@ impl<'a, 'gcx, 'tcx> Ancestors {\n     pub fn defs(\n         self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-        trait_item_name: Name,\n+        trait_item_name: Ident,\n         trait_item_kind: ty::AssociatedKind,\n         trait_def_id: DefId,\n     ) -> impl Iterator<Item = NodeItem<ty::AssociatedItem>> + Captures<'gcx> + Captures<'tcx> + 'a {\n         self.flat_map(move |node| {\n             node.items(tcx).filter(move |impl_item| {\n                 impl_item.kind == trait_item_kind &&\n-                tcx.hygienic_eq(impl_item.name.to_ident(), trait_item_name.to_ident(), trait_def_id)\n+                tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id)\n             }).map(move |item| NodeItem { node: node, item: item })\n         })\n     }"}, {"sha": "d8fa978a6a07c89f4e9e46043bd0f4adec9ee2b5", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -177,7 +177,7 @@ pub struct ImplHeader<'tcx> {\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n pub struct AssociatedItem {\n     pub def_id: DefId,\n-    pub name: Name,\n+    pub ident: Ident,\n     pub kind: AssociatedKind,\n     pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n@@ -224,9 +224,9 @@ impl AssociatedItem {\n                 // regions just fine, showing `fn(&MyType)`.\n                 format!(\"{}\", tcx.fn_sig(self.def_id).skip_binder())\n             }\n-            ty::AssociatedKind::Type => format!(\"type {};\", self.name.to_string()),\n+            ty::AssociatedKind::Type => format!(\"type {};\", self.ident),\n             ty::AssociatedKind::Const => {\n-                format!(\"const {}: {:?};\", self.name.to_string(), tcx.type_of(self.def_id))\n+                format!(\"const {}: {:?};\", self.ident, tcx.type_of(self.def_id))\n             }\n         }\n     }\n@@ -2494,7 +2494,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         };\n \n         AssociatedItem {\n-            name: trait_item_ref.name,\n+            ident: trait_item_ref.ident,\n             kind,\n             // Visibility of trait items is inherited from their traits.\n             vis: Visibility::from_hir(parent_vis, trait_item_ref.id.node_id, self),\n@@ -2518,8 +2518,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             hir::AssociatedItemKind::Type => (ty::AssociatedKind::Type, false),\n         };\n \n-        ty::AssociatedItem {\n-            name: impl_item_ref.name,\n+        AssociatedItem {\n+            ident: impl_item_ref.ident,\n             kind,\n             // Visibility of trait impl items doesn't matter.\n             vis: ty::Visibility::from_hir(&impl_item_ref.vis, impl_item_ref.id.node_id, self),\n@@ -2544,10 +2544,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn associated_items(\n         self,\n         def_id: DefId,\n-    ) -> impl Iterator<Item = ty::AssociatedItem> + 'a {\n+    ) -> impl Iterator<Item = AssociatedItem> + 'a {\n         let def_ids = self.associated_item_def_ids(def_id);\n         Box::new((0..def_ids.len()).map(move |i| self.associated_item(def_ids[i])))\n-            as Box<dyn Iterator<Item = ty::AssociatedItem> + 'a>\n+            as Box<dyn Iterator<Item = AssociatedItem> + 'a>\n     }\n \n     /// Returns true if the impls are the same polarity and are implementing"}, {"sha": "186ebd73b4cc5acdae44f9f0a98b4560a8b199d5", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -857,7 +857,7 @@ impl<'a, 'tcx> ProjectionTy<'tcx> {\n     ) -> ProjectionTy<'tcx> {\n         let item_def_id = tcx.associated_items(trait_ref.def_id).find(|item| {\n             item.kind == ty::AssociatedKind::Type &&\n-            tcx.hygienic_eq(item_name, item.name.to_ident(), trait_ref.def_id)\n+            tcx.hygienic_eq(item_name, item.ident, trait_ref.def_id)\n         }).unwrap().def_id;\n \n         ProjectionTy {"}, {"sha": "ff6d711cef0c8a08ea2db8f5002ae71e8ff78863", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -429,7 +429,7 @@ impl PrintContext {\n             ty::tls::with(|tcx|\n                 print!(f, self,\n                        write(\"{}=\",\n-                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                             tcx.associated_item(projection.projection_ty.item_def_id).ident),\n                        print_display(projection.ty))\n             )?;\n         }\n@@ -1286,7 +1286,7 @@ define_print! {\n             //   parameterized(f, self.substs, self.item_def_id, &[])\n             // (which currently ICEs).\n             let (trait_ref, item_name) = ty::tls::with(|tcx|\n-                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).ident)\n             );\n             print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n         }"}, {"sha": "84f7b35d21f33c542ba2d01dd37d44bebb7c2557", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1075,7 +1075,7 @@ impl RustcDefaultCalls {\n                     let mut cfgs = Vec::new();\n                     for &(name, ref value) in sess.parse_sess.config.iter() {\n                         let gated_cfg = GatedCfg::gate(&ast::MetaItem {\n-                            ident: ast::Path::from_ident(name.to_ident()),\n+                            ident: ast::Path::from_ident(ast::Ident::with_empty_ctxt(name)),\n                             node: ast::MetaItemKind::Word,\n                             span: DUMMY_SP,\n                         });"}, {"sha": "6bc364b72618f9b5be97986c08baace2f534f599", "filename": "src/librustc_lint/bad_style.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_lint%2Fbad_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_lint%2Fbad_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbad_style.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -305,7 +305,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(ref pnames)) = item.node {\n             self.check_snake_case(cx,\n                                   \"trait method\",\n-                                  &item.name.as_str(),\n+                                  &item.ident.as_str(),\n                                   Some(item.span));\n             for param_name in pnames {\n                 self.check_snake_case(cx, \"variable\", &param_name.as_str(), Some(param_name.span));\n@@ -385,7 +385,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n         match ti.node {\n             hir::TraitItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ti.name, ti.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ti.ident.name, ti.span);\n             }\n             _ => {}\n         }\n@@ -394,7 +395,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n     fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n         match ii.node {\n             hir::ImplItemKind::Const(..) => {\n-                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", ii.name, ii.span);\n+                NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\",\n+                                                      ii.ident.name, ii.span);\n             }\n             _ => {}\n         }"}, {"sha": "b4dc5f9c85b0b78f6bd760daf8c7fe1b1c9973f9", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1078,7 +1078,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n                                 let container = ty::ImplContainer(vtable_impl.impl_def_id);\n                                 // It matches if it comes from the same impl,\n                                 // and has the same method name.\n-                                container == method.container && callee_item.name == method.name\n+                                container == method.container &&\n+                                callee_item.ident.name == method.ident.name\n                             }\n \n                             // There's no way to know if this call is"}, {"sha": "6eea4b2617cc282bc12f64bf8723c24557f1a8c2", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -817,7 +817,7 @@ impl<'a, 'tcx> CrateMetadata {\n         };\n \n         ty::AssociatedItem {\n-            name: name.as_symbol(),\n+            ident: Ident::from_interned_str(name),\n             kind,\n             vis: item.visibility.decode(self),\n             defaultness: container.defaultness(),"}, {"sha": "167e031fbeec1dd633ff82357f5c9a1c1c4622d9", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -235,7 +235,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         let method_name = Symbol::intern(method_name);\n         let substs = self.tcx.mk_substs_trait(self_ty, params);\n         for item in self.tcx.associated_items(trait_def_id) {\n-            if item.kind == ty::AssociatedKind::Method && item.name == method_name {\n+            if item.kind == ty::AssociatedKind::Method && item.ident.name == method_name {\n                 let method_ty = self.tcx.type_of(item.def_id);\n                 let method_ty = method_ty.subst(self.tcx, substs);\n                 return (method_ty,"}, {"sha": "c079b9d3dc4404f5b7dcb0fbc7049a528da973e1", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1115,10 +1115,10 @@ fn create_mono_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if let Some(trait_ref) = tcx.impl_trait_ref(impl_def_id) {\n                 let overridden_methods: FxHashSet<_> =\n                     impl_item_refs.iter()\n-                                  .map(|iiref| iiref.name)\n+                                  .map(|iiref| iiref.ident.modern())\n                                   .collect();\n                 for method in tcx.provided_trait_methods(trait_ref.def_id) {\n-                    if overridden_methods.contains(&method.name) {\n+                    if overridden_methods.contains(&method.ident.modern()) {\n                         continue;\n                     }\n "}, {"sha": "0428489fd8d78b06c831d1559a2b17740a8042be", "filename": "src/librustc_mir/monomorphize/item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fitem.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -441,7 +441,7 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n \n         for projection in projections {\n             let projection = projection.skip_binder();\n-            let name = &self.tcx.associated_item(projection.item_def_id).name.as_str();\n+            let name = &self.tcx.associated_item(projection.item_def_id).ident.as_str();\n             output.push_str(name);\n             output.push_str(\"=\");\n             self.push_type_name(projection.ty, output);"}, {"sha": "d3825ff49191a97891472d5a575fc8c9099d30b8", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -3505,7 +3505,7 @@ impl<'a> Resolver<'a> {\n \n         match path.get(1) {\n             // If this import looks like `crate::...` it's already good\n-            Some(name) if name.name == keywords::Crate.name() => return,\n+            Some(ident) if ident.name == keywords::Crate.name() => return,\n             // Otherwise go below to see if it's an extern crate\n             Some(_) => {}\n             // If the path has length one (and it's `CrateRoot` most likely)"}, {"sha": "311978ec248091709a905f9aecf82b49b920dc88", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -316,14 +316,14 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n         sig: &'l ast::MethodSig,\n         body: Option<&'l ast::Block>,\n         id: ast::NodeId,\n-        name: ast::Ident,\n+        ident: ast::Ident,\n         generics: &'l ast::Generics,\n         vis: ast::Visibility,\n         span: Span,\n     ) {\n-        debug!(\"process_method: {}:{}\", id, name);\n+        debug!(\"process_method: {}:{}\", id, ident);\n \n-        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, name.name, span) {\n+        if let Some(mut method_data) = self.save_ctxt.get_method_data(id, ident.name, span) {\n             let sig_str = ::make_signature(&sig.decl, &generics);\n             if body.is_some() {\n                 self.nest_tables(\n@@ -335,7 +335,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> DumpVisitor<'l, 'tcx, 'll, O> {\n             self.process_generic_params(&generics, span, &method_data.qualname, id);\n \n             method_data.value = sig_str;\n-            method_data.sig = sig::method_signature(id, name, generics, sig, &self.save_ctxt);\n+            method_data.sig = sig::method_signature(id, ident, generics, sig, &self.save_ctxt);\n             self.dumper.dump_def(&access_from!(self.save_ctxt, vis, id), method_data);\n         }\n "}, {"sha": "89d30fd666a883d88d67c80b9ff4c046cc68ff23", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -438,7 +438,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                                 qualname.push_str(&self.tcx.item_path_str(def_id));\n                                 self.tcx\n                                     .associated_items(def_id)\n-                                    .find(|item| item.name == name)\n+                                    .find(|item| item.ident.name == name)\n                                     .map(|item| decl_id = Some(item.def_id));\n                             }\n                             qualname.push_str(\">\");\n@@ -775,7 +775,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     let ti = self.tcx.associated_item(decl_id);\n                     self.tcx\n                         .associated_items(ti.container.id())\n-                        .find(|item| item.name == ti.name && item.defaultness.has_value())\n+                        .find(|item| item.ident.name == ti.ident.name &&\n+                                     item.defaultness.has_value())\n                         .map(|item| item.def_id)\n                 } else {\n                     None"}, {"sha": "214376b2e532b14a406e1d8854c23c4cb6d64241", "filename": "src/librustc_traits/lowering.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_traits%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_traits%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_traits%2Flowering.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -417,7 +417,7 @@ pub fn program_clauses_for_associated_type_value<'a, 'tcx>(\n     let hypotheses = vec![trait_implemented];\n \n     // `<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm>`\n-    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.name.to_ident());\n+    let projection_ty = ty::ProjectionTy::from_ref_and_name(tcx, trait_ref, item.ident);\n \n     // `Normalize(<A0 as Trait<A1..An>>::AssocType<Pn+1..Pm> -> T)`\n     let normalize_goal = DomainGoal::Normalize(ty::ProjectionPredicate { projection_ty, ty });"}, {"sha": "762dc5d26f5a4f3a02972740a0b3b8580f763c21", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -490,7 +490,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n     {\n         self.tcx().associated_items(trait_def_id).any(|item| {\n             item.kind == ty::AssociatedKind::Type &&\n-            self.tcx().hygienic_eq(assoc_name, item.name.to_ident(), trait_def_id)\n+            self.tcx().hygienic_eq(assoc_name, item.ident, trait_def_id)\n         })\n     }\n \n@@ -571,7 +571,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (assoc_ident, def_scope) =\n             tcx.adjust_ident(binding.item_name, candidate.def_id(), ref_id);\n         let assoc_ty = tcx.associated_items(candidate.def_id()).find(|i| {\n-            i.kind == ty::AssociatedKind::Type && i.name.to_ident() == assoc_ident\n+            i.kind == ty::AssociatedKind::Type && i.ident.modern() == assoc_ident\n         }).expect(\"missing associated type\");\n \n         if !assoc_ty.vis.is_accessible_from(def_scope, tcx) {\n@@ -711,10 +711,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             let trait_def_id = assoc_item.container.id();\n             struct_span_err!(tcx.sess, span, E0191,\n                 \"the value of the associated type `{}` (from the trait `{}`) must be specified\",\n-                        assoc_item.name,\n+                        assoc_item.ident,\n                         tcx.item_path_str(trait_def_id))\n                         .span_label(span, format!(\n-                            \"missing associated type `{}` value\", assoc_item.name))\n+                            \"missing associated type `{}` value\", assoc_item.ident))\n                         .emit();\n         }\n \n@@ -837,7 +837,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             for bound in bounds {\n                 let bound_span = self.tcx().associated_items(bound.def_id()).find(|item| {\n                     item.kind == ty::AssociatedKind::Type &&\n-                    self.tcx().hygienic_eq(assoc_name, item.name.to_ident(), bound.def_id())\n+                    self.tcx().hygienic_eq(assoc_name, item.ident, bound.def_id())\n                 })\n                 .and_then(|item| self.tcx().hir.span_if_local(item.def_id));\n \n@@ -925,7 +925,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         let (assoc_ident, def_scope) = tcx.adjust_ident(assoc_name, trait_did, ref_id);\n         let item = tcx.associated_items(trait_did).find(|i| {\n             Namespace::from(i.kind) == Namespace::Type &&\n-            i.name.to_ident() == assoc_ident\n+            i.ident.modern() == assoc_ident\n         })\n         .expect(\"missing associated type\");\n "}, {"sha": "383820a62bffe4e849b62c6c21efe64c517fb1f9", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -18,7 +18,7 @@ use rustc::{infer, traits};\n use rustc::ty::{self, TyCtxt, TypeFoldable, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoBorrowMutability};\n use rustc_target::spec::abi;\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n use syntax_pos::Span;\n \n use rustc::hir;\n@@ -157,9 +157,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                              MethodCallee<'tcx>)> {\n         // Try the options that are least restrictive on the caller first.\n         for &(opt_trait_def_id, method_name, borrow) in\n-            &[(self.tcx.lang_items().fn_trait(), Symbol::intern(\"call\"), true),\n-              (self.tcx.lang_items().fn_mut_trait(), Symbol::intern(\"call_mut\"), true),\n-              (self.tcx.lang_items().fn_once_trait(), Symbol::intern(\"call_once\"), false)] {\n+            &[(self.tcx.lang_items().fn_trait(), Ident::from_str(\"call\"), true),\n+              (self.tcx.lang_items().fn_mut_trait(), Ident::from_str(\"call_mut\"), true),\n+              (self.tcx.lang_items().fn_once_trait(), Ident::from_str(\"call_once\"), false)] {\n             let trait_def_id = match opt_trait_def_id {\n                 Some(def_id) => def_id,\n                 None => continue,"}, {"sha": "04c11d30d26791b10f81f88f64746953156a49ff", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -100,7 +100,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         span: impl_m_span,\n         body_id: impl_m_node_id,\n         code: ObligationCauseCode::CompareImplMethodObligation {\n-            item_name: impl_m.name,\n+            item_name: impl_m.ident.name,\n             impl_item_def_id: impl_m.def_id,\n             trait_item_def_id: trait_m.def_id,\n         },\n@@ -318,7 +318,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             cause.span(&tcx),\n                                             E0053,\n                                             \"method `{}` has an incompatible type for trait\",\n-                                            trait_m.name);\n+                                            trait_m.ident);\n \n             infcx.note_type_err(&mut diag,\n                                 &cause,\n@@ -383,7 +383,7 @@ fn check_region_bounds_on_impl_method<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0195,\n                                        \"lifetime parameters or bounds on method `{}` do not match \\\n                                         the trait declaration\",\n-                                       impl_m.name);\n+                                       impl_m.ident);\n         err.span_label(span, \"lifetimes do not match method in trait\");\n         if let Some(sp) = tcx.hir.span_if_local(trait_m.def_id) {\n             err.span_label(tcx.sess.codemap().def_span(sp),\n@@ -529,13 +529,13 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0185,\n                                            \"method `{}` has a `{}` declaration in the impl, but \\\n                                             not in the trait\",\n-                                           trait_m.name,\n+                                           trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"`{}` used in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"trait method declared without `{}`\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(),\n+                err.note_trait_signature(trait_m.ident.to_string(),\n                                          trait_m.signature(&tcx));\n             }\n             err.emit();\n@@ -549,13 +549,13 @@ fn compare_self_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            E0186,\n                                            \"method `{}` has a `{}` declaration in the trait, but \\\n                                             not in the impl\",\n-                                           trait_m.name,\n+                                           trait_m.ident,\n                                            self_descr);\n             err.span_label(impl_m_span, format!(\"expected `{}` in impl\", self_descr));\n             if let Some(span) = tcx.hir.span_if_local(trait_m.def_id) {\n                 err.span_label(span, format!(\"`{}` used in trait\", self_descr));\n             } else {\n-                err.note_trait_signature(trait_m.name.to_string(),\n+                err.note_trait_signature(trait_m.ident.to_string(),\n                                          trait_m.signature(&tcx));\n             }\n             err.emit();\n@@ -590,7 +590,7 @@ fn compare_number_of_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0049,\n                                        \"method `{}` has {} type parameter{} but its trait \\\n                                         declaration has {} type parameter{}\",\n-                                       trait_m.name,\n+                                       trait_m.ident,\n                                        num_impl_m_type_params,\n                                        if num_impl_m_type_params == 1 { \"\" } else { \"s\" },\n                                        num_trait_m_type_params,\n@@ -681,7 +681,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        E0050,\n                                        \"method `{}` has {} parameter{} but the declaration in \\\n                                         trait `{}` has {}\",\n-                                       trait_m.name,\n+                                       trait_m.ident,\n                                        impl_number_args,\n                                        if impl_number_args == 1 { \"\" } else { \"s\" },\n                                        tcx.item_path_str(trait_m.def_id),\n@@ -695,7 +695,7 @@ fn compare_number_of_method_arguments<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         format!(\"{} parameter\", trait_number_args)\n                                     }));\n         } else {\n-            err.note_trait_signature(trait_m.name.to_string(),\n+            err.note_trait_signature(trait_m.ident.to_string(),\n                                      trait_m.signature(&tcx));\n         }\n         err.span_label(impl_span,\n@@ -748,7 +748,7 @@ fn compare_synthetic_generics<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_span,\n                                            E0643,\n                                            \"method `{}` has incompatible signature for trait\",\n-                                           trait_m.name);\n+                                           trait_m.ident);\n             err.span_label(trait_span, \"declaration in trait here\");\n             match (impl_synthetic, trait_synthetic) {\n                 // The case where the impl method uses `impl Trait` but the trait method uses\n@@ -948,7 +948,7 @@ pub fn compare_const_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                             E0326,\n                                             \"implemented const `{}` has an incompatible type for \\\n                                              trait\",\n-                                            trait_c.name);\n+                                            trait_c.ident);\n \n             let trait_c_node_id = tcx.hir.as_local_node_id(trait_c.def_id);\n             let trait_c_span = trait_c_node_id.map(|trait_c_node_id| {"}, {"sha": "8582eb3fbd87cf2fb230bd96b3c078ad4ea4918f", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             let methods = self.get_conversion_methods(expr.span, expected, checked_ty);\n             if let Ok(expr_text) = self.tcx.sess.codemap().span_to_snippet(expr.span) {\n                 let suggestions = iter::repeat(expr_text).zip(methods.iter())\n-                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.name))\n+                    .map(|(receiver, method)| format!(\"{}.{}()\", receiver, method.ident))\n                     .collect::<Vec<_>>();\n                 if !suggestions.is_empty() {\n                     err.span_suggestions(expr.span,"}, {"sha": "04c32fa88271ad24c7a4c45bafeac4c63c222951", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -244,7 +244,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     /// of this method is basically the same as confirmation.\n     pub fn lookup_method_in_trait(&self,\n                                   span: Span,\n-                                  m_name: ast::Name,\n+                                  m_name: ast::Ident,\n                                   trait_def_id: DefId,\n                                   self_ty: Ty<'tcx>,\n                                   opt_input_types: Option<&[Ty<'tcx>]>)\n@@ -290,7 +290,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // type parameters or early-bound regions.\n         let tcx = self.tcx;\n         let method_item =\n-            self.associated_item(trait_def_id, m_name.to_ident(), Namespace::Value).unwrap();\n+            self.associated_item(trait_def_id, m_name, Namespace::Value).unwrap();\n         let def_id = method_item.def_id;\n         let generics = tcx.generics_of(def_id);\n         assert_eq!(generics.params.len(), 0);\n@@ -390,7 +390,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                            -> Option<ty::AssociatedItem> {\n         self.tcx.associated_items(def_id).find(|item| {\n             Namespace::from(item.kind) == ns &&\n-            self.tcx.hygienic_eq(item_name, item.name.to_ident(), def_id)\n+            self.tcx.hygienic_eq(item_name, item.ident, def_id)\n         })\n     }\n }"}, {"sha": "0aff322a29a6debf58dbfeea5b82b86f0d1e80fa", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -810,7 +810,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                     true\n                 }\n             })\n-            .map(|candidate| candidate.item.name.to_ident())\n+            .map(|candidate| candidate.item.ident)\n             .filter(|&name| set.insert(name))\n             .collect();\n \n@@ -1309,14 +1309,14 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 Ok(None)\n             } else {\n                 let best_name = {\n-                    let names = applicable_close_candidates.iter().map(|cand| &cand.name);\n+                    let names = applicable_close_candidates.iter().map(|cand| &cand.ident.name);\n                     find_best_match_for_name(names,\n                                              &self.method_name.unwrap().as_str(),\n                                              None)\n                 }.unwrap();\n                 Ok(applicable_close_candidates\n                    .into_iter()\n-                   .find(|method| method.name == best_name))\n+                   .find(|method| method.ident.name == best_name))\n             }\n         })\n     }\n@@ -1456,7 +1456,7 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let max_dist = max(name.as_str().len(), 3) / 3;\n                 self.tcx.associated_items(def_id)\n                     .filter(|x| {\n-                        let dist = lev_distance(&*name.as_str(), &x.name.as_str());\n+                        let dist = lev_distance(&*name.as_str(), &x.ident.as_str());\n                         Namespace::from(x.kind) == Namespace::Value && dist > 0\n                         && dist <= max_dist\n                     })"}, {"sha": "35d237d94de8251a12a5a3295d31f43ab507a019", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -444,7 +444,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 }\n \n                 if let Some(lev_candidate) = lev_candidate {\n-                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.name));\n+                    err.help(&format!(\"did you mean `{}`?\", lev_candidate.ident));\n                 }\n                 err.emit();\n             }"}, {"sha": "f42366e5dbee99f35c328382260cde534e7eaf1d", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 18, "deletions": 20, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1333,15 +1333,15 @@ fn report_forbidden_specialization<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         tcx.sess, impl_item.span, E0520,\n         \"`{}` specializes an item from a parent `impl`, but \\\n          that item is not marked `default`\",\n-        impl_item.name);\n+        impl_item.ident);\n     err.span_label(impl_item.span, format!(\"cannot specialize default item `{}`\",\n-                                            impl_item.name));\n+                                            impl_item.ident));\n \n     match tcx.span_of_impl(parent_impl) {\n         Ok(span) => {\n             err.span_label(span, \"parent `impl` is here\");\n             err.note(&format!(\"to specialize, `{}` in the parent `impl` must be marked `default`\",\n-                              impl_item.name));\n+                              impl_item.ident));\n         }\n         Err(cname) => {\n             err.note(&format!(\"parent implementation is in crate `{}`\", cname));\n@@ -1365,7 +1365,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         hir::ImplItemKind::Type(_) => ty::AssociatedKind::Type\n     };\n \n-    let parent = ancestors.defs(tcx, trait_item.name, kind, trait_def.def_id).skip(1).next()\n+    let parent = ancestors.defs(tcx, trait_item.ident, kind, trait_def.def_id).skip(1).next()\n         .map(|node_item| node_item.map(|parent| parent.defaultness));\n \n     if let Some(parent) = parent {\n@@ -1400,13 +1400,11 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let ty_impl_item = tcx.associated_item(tcx.hir.local_def_id(impl_item.id));\n         let ty_trait_item = tcx.associated_items(impl_trait_ref.def_id)\n             .find(|ac| Namespace::from(&impl_item.node) == Namespace::from(ac.kind) &&\n-                         tcx.hygienic_eq(ty_impl_item.name.to_ident(), ac.name.to_ident(),\n-                                         impl_trait_ref.def_id))\n+                       tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n             .or_else(|| {\n                 // Not compatible, but needed for the error message\n                 tcx.associated_items(impl_trait_ref.def_id)\n-                   .find(|ac| tcx.hygienic_eq(ty_impl_item.name.to_ident(), ac.name.to_ident(),\n-                                              impl_trait_ref.def_id))\n+                   .find(|ac| tcx.hygienic_eq(ty_impl_item.ident, ac.ident, impl_trait_ref.def_id))\n             });\n \n         // Check that impl definition matches trait definition\n@@ -1424,7 +1422,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                          let mut err = struct_span_err!(tcx.sess, impl_item.span, E0323,\n                                   \"item `{}` is an associated const, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          // We can only get the spans from local trait definition\n@@ -1448,7 +1446,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0324,\n                                   \"item `{}` is an associated method, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n@@ -1466,7 +1464,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                         let mut err = struct_span_err!(tcx.sess, impl_item.span, E0325,\n                                   \"item `{}` is an associated type, \\\n                                   which doesn't match its trait `{}`\",\n-                                  ty_impl_item.name,\n+                                  ty_impl_item.ident,\n                                   impl_trait_ref);\n                          err.span_label(impl_item.span, \"does not match trait\");\n                          if let Some(trait_span) = tcx.hir.span_if_local(ty_trait_item.def_id) {\n@@ -1487,7 +1485,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n         let is_implemented = trait_def.ancestors(tcx, impl_id)\n-            .defs(tcx, trait_item.name, trait_item.kind, impl_trait_ref.def_id)\n+            .defs(tcx, trait_item.ident, trait_item.kind, impl_trait_ref.def_id)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())\n             .unwrap_or(false);\n@@ -1496,7 +1494,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             if !trait_item.defaultness.has_value() {\n                 missing_items.push(trait_item);\n             } else if associated_type_overridden {\n-                invalidated_items.push(trait_item.name);\n+                invalidated_items.push(trait_item.ident);\n             }\n         }\n     }\n@@ -1505,17 +1503,17 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let mut err = struct_span_err!(tcx.sess, impl_span, E0046,\n             \"not all trait items implemented, missing: `{}`\",\n             missing_items.iter()\n-                  .map(|trait_item| trait_item.name.to_string())\n+                  .map(|trait_item| trait_item.ident.to_string())\n                   .collect::<Vec<_>>().join(\"`, `\"));\n         err.span_label(impl_span, format!(\"missing `{}` in implementation\",\n                 missing_items.iter()\n-                    .map(|trait_item| trait_item.name.to_string())\n+                    .map(|trait_item| trait_item.ident.to_string())\n                     .collect::<Vec<_>>().join(\"`, `\")));\n         for trait_item in missing_items {\n             if let Some(span) = tcx.hir.span_if_local(trait_item.def_id) {\n-                err.span_label(span, format!(\"`{}` from trait\", trait_item.name));\n+                err.span_label(span, format!(\"`{}` from trait\", trait_item.ident));\n             } else {\n-                err.note_trait_signature(trait_item.name.to_string(),\n+                err.note_trait_signature(trait_item.ident.to_string(),\n                                          trait_item.signature(&tcx));\n             }\n         }\n@@ -1527,7 +1525,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         span_err!(tcx.sess, invalidator.span, E0399,\n                   \"the following trait items need to be reimplemented \\\n                    as `{}` was overridden: `{}`\",\n-                  invalidator.name,\n+                  invalidator.ident,\n                   invalidated_items.iter()\n                                    .map(|name| name.to_string())\n                                    .collect::<Vec<_>>().join(\"`, `\"))\n@@ -2470,7 +2468,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         None\n     }\n \n-    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, Symbol) {\n+    fn resolve_place_op(&self, op: PlaceOp, is_mut: bool) -> (Option<DefId>, ast::Ident) {\n         let (tr, name) = match (op, is_mut) {\n             (PlaceOp::Deref, false) =>\n                 (self.tcx.lang_items().deref_trait(), \"deref\"),\n@@ -2481,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             (PlaceOp::Index, true) =>\n                 (self.tcx.lang_items().index_mut_trait(), \"index_mut\"),\n         };\n-        (tr, Symbol::intern(name))\n+        (tr, ast::Ident::from_str(name))\n     }\n \n     fn try_overloaded_place_op(&self,"}, {"sha": "0a33252d4cd01b27f727dee3217b3c34099b022e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::adjustment::{Adjustment, Adjust, AllowTwoPhase, AutoBorrow, AutoB\n use rustc::infer::type_variable::TypeVariableOrigin;\n use errors;\n use syntax_pos::Span;\n-use syntax::symbol::Symbol;\n+use syntax::ast::Ident;\n use rustc::hir;\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n@@ -564,7 +564,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                trait_did);\n \n         let method = trait_did.and_then(|trait_did| {\n-            let opname = Symbol::intern(opname);\n+            let opname = Ident::from_str(opname);\n             self.lookup_method_in_trait(span, opname, trait_did, lhs_ty, Some(other_tys))\n         });\n "}, {"sha": "6a346b02b7943f4596a0521b06d5bf4452dec3da", "filename": "src/librustc_typeck/coherence/inherent_impls_overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls_overlap.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -35,7 +35,7 @@ impl<'a, 'tcx> InherentOverlapChecker<'a, 'tcx> {\n \n         let name_and_namespace = |def_id| {\n             let item = self.tcx.associated_item(def_id);\n-            (item.name, Namespace::from(item.kind))\n+            (item.ident, Namespace::from(item.kind))\n         };\n \n         let impl_items1 = self.tcx.associated_item_def_ids(impl1);"}, {"sha": "b57bb1fccfb5781f6f0ef90b518ea276cef98a78", "filename": "src/librustc_typeck/impl_wf_check.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustc_typeck%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -184,14 +184,14 @@ fn enforce_impl_items_are_distinct<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             hir::ImplItemKind::Type(_) => &mut seen_type_items,\n             _                    => &mut seen_value_items,\n         };\n-        match seen_items.entry(impl_item.name) {\n+        match seen_items.entry(impl_item.ident.modern()) {\n             Occupied(entry) => {\n                 let mut err = struct_span_err!(tcx.sess, impl_item.span, E0201,\n                                                \"duplicate definitions with name `{}`:\",\n-                                               impl_item.name);\n+                                               impl_item.ident);\n                 err.span_label(*entry.get(),\n                                format!(\"previous definition of `{}` here\",\n-                                        impl_item.name));\n+                                        impl_item.ident));\n                 err.span_label(impl_item.span, \"duplicate definition\");\n                 err.emit();\n             }"}, {"sha": "7677ccf8bf40c4ffd2007e71c69ef0d38a10a483", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -391,7 +391,7 @@ pub fn build_impl(cx: &DocContext, did: DefId, ret: &mut Vec<clean::Item>) {\n     let provided = trait_.def_id().map(|did| {\n         tcx.provided_trait_methods(did)\n            .into_iter()\n-           .map(|meth| meth.name.to_string())\n+           .map(|meth| meth.ident.to_string())\n            .collect()\n     }).unwrap_or(FxHashSet());\n "}, {"sha": "c4729ce67d8a0fb0e46a798748dc368d04f2a90b", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -1146,7 +1146,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             Def::Struct(did) | Def::Union(did) | Def::Enum(did) | Def::TyAlias(did) => {\n                 let item = cx.tcx.inherent_impls(did).iter()\n                                  .flat_map(|imp| cx.tcx.associated_items(*imp))\n-                                 .find(|item| item.name == item_name);\n+                                 .find(|item| item.ident.name == item_name);\n                 if let Some(item) = item {\n                     let out = match item.kind {\n                         ty::AssociatedKind::Method if is_val => \"method\",\n@@ -1181,7 +1181,7 @@ fn resolve(cx: &DocContext, path_str: &str, is_val: bool) -> Result<(Def, Option\n             Def::Trait(did) => {\n                 let item = cx.tcx.associated_item_def_ids(did).iter()\n                              .map(|item| cx.tcx.associated_item(*item))\n-                             .find(|item| item.name == item_name);\n+                             .find(|item| item.ident.name == item_name);\n                 if let Some(item) = item {\n                     let kind = match item.kind {\n                         ty::AssociatedKind::Const if is_val => \"associatedconstant\",\n@@ -1823,7 +1823,7 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n             GenericBound::Outlives(_) => panic!(\"cleaning a trait got a lifetime\"),\n         };\n         Type::QPath {\n-            name: cx.tcx.associated_item(self.item_def_id).name.clean(cx),\n+            name: cx.tcx.associated_item(self.item_def_id).ident.name.clean(cx),\n             self_type: box self.self_ty().clean(cx),\n             trait_: box trait_\n         }\n@@ -2360,7 +2360,7 @@ impl Clean<Item> for hir::TraitItem {\n             }\n         };\n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2388,7 +2388,7 @@ impl Clean<Item> for hir::ImplItem {\n             }, true),\n         };\n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             source: self.span.clean(cx),\n             attrs: self.attrs.clean(cx),\n             def_id: cx.tcx.hir.local_def_id(self.id),\n@@ -2474,7 +2474,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n                 }\n             }\n             ty::AssociatedKind::Type => {\n-                let my_name = self.name.clean(cx);\n+                let my_name = self.ident.name.clean(cx);\n \n                 if let ty::TraitContainer(did) = self.container {\n                     // When loading a cross-crate associated type, the bounds for this type\n@@ -2537,7 +2537,7 @@ impl<'tcx> Clean<Item> for ty::AssociatedItem {\n         };\n \n         Item {\n-            name: Some(self.name.clean(cx)),\n+            name: Some(self.ident.name.clean(cx)),\n             visibility,\n             stability: get_stability(cx, self.def_id),\n             deprecation: get_deprecation(cx, self.def_id),\n@@ -3099,7 +3099,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     let mut bindings = vec![];\n                     for pb in obj.projection_bounds() {\n                         bindings.push(TypeBinding {\n-                            name: cx.tcx.associated_item(pb.item_def_id()).name.clean(cx),\n+                            name: cx.tcx.associated_item(pb.item_def_id()).ident.name.clean(cx),\n                             ty: pb.skip_binder().ty.clean(cx)\n                         });\n                     }\n@@ -3156,7 +3156,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                             if proj.projection_ty.trait_ref(cx.tcx) == *trait_ref.skip_binder() {\n                                 Some(TypeBinding {\n                                     name: cx.tcx.associated_item(proj.projection_ty.item_def_id)\n-                                                .name.clean(cx),\n+                                                .ident.name.clean(cx),\n                                     ty: proj.ty.clean(cx),\n                                 })\n                             } else {\n@@ -3823,7 +3823,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n         let provided = trait_.def_id().map(|did| {\n             cx.tcx.provided_trait_methods(did)\n                   .into_iter()\n-                  .map(|meth| meth.name.to_string())\n+                  .map(|meth| meth.ident.to_string())\n                   .collect()\n         }).unwrap_or(FxHashSet());\n "}, {"sha": "53032b9b98c5d79fa7305720637c76025a310071", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -718,13 +718,13 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem) {\n-        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem) {\n-        self.visit_testable(item.name.to_string(), &item.attrs, |this| {\n+        self.visit_testable(item.ident.to_string(), &item.attrs, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }"}, {"sha": "99d8b1b172d24505aaa6cc54c29a0d0c6774b306", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f0622dfe5d5414c59258d8c2669d26d3dc34a469/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=f0622dfe5d5414c59258d8c2669d26d3dc34a469", "patch": "@@ -18,7 +18,7 @@\n use GLOBALS;\n use Span;\n use edition::Edition;\n-use symbol::{Ident, Symbol};\n+use symbol::Symbol;\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n use std::collections::HashMap;\n@@ -190,7 +190,6 @@ pub struct HygieneData {\n     marks: Vec<MarkData>,\n     syntax_contexts: Vec<SyntaxContextData>,\n     markings: HashMap<(SyntaxContext, Mark), SyntaxContext>,\n-    gensym_to_ctxt: HashMap<Symbol, Span>,\n     default_edition: Edition,\n }\n \n@@ -211,7 +210,6 @@ impl HygieneData {\n                 modern: SyntaxContext(0),\n             }],\n             markings: HashMap::new(),\n-            gensym_to_ctxt: HashMap::new(),\n             default_edition: Edition::Edition2015,\n         }\n     }\n@@ -559,22 +557,3 @@ impl Decodable for SyntaxContext {\n         Ok(SyntaxContext::empty()) // FIXME(jseyfried) intercrate hygiene\n     }\n }\n-\n-impl Symbol {\n-    pub fn from_ident(ident: Ident) -> Symbol {\n-        HygieneData::with(|data| {\n-            let gensym = ident.name.gensymed();\n-            data.gensym_to_ctxt.insert(gensym, ident.span);\n-            gensym\n-        })\n-    }\n-\n-    pub fn to_ident(self) -> Ident {\n-        HygieneData::with(|data| {\n-            match data.gensym_to_ctxt.get(&self) {\n-                Some(&span) => Ident::new(self.interned(), span),\n-                None => Ident::with_empty_ctxt(self),\n-            }\n-        })\n-    }\n-}"}]}