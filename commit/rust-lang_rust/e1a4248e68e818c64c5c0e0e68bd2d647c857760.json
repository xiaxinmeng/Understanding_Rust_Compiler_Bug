{"sha": "e1a4248e68e818c64c5c0e0e68bd2d647c857760", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxYTQyNDhlNjhlODE4YzY0YzVjMGUwZTY4YmQyZDY0N2M4NTc3NjA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-22T06:43:56Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-08-22T06:43:56Z"}, "message": "Merge pull request #215 from birkenfeld/type_improvements\n\nType improvements", "tree": {"sha": "573b3d0b15b843c27a5b477f3957dec97f03ec62", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/573b3d0b15b843c27a5b477f3957dec97f03ec62"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1a4248e68e818c64c5c0e0e68bd2d647c857760", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a4248e68e818c64c5c0e0e68bd2d647c857760", "html_url": "https://github.com/rust-lang/rust/commit/e1a4248e68e818c64c5c0e0e68bd2d647c857760", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1a4248e68e818c64c5c0e0e68bd2d647c857760/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ffe1ed3372860b7dfaa2609c7c2c9eaa5ca4041", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ffe1ed3372860b7dfaa2609c7c2c9eaa5ca4041", "html_url": "https://github.com/rust-lang/rust/commit/6ffe1ed3372860b7dfaa2609c7c2c9eaa5ca4041"}, {"sha": "8a10440641f7ec89236b1f40129738426ad4d702", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a10440641f7ec89236b1f40129738426ad4d702", "html_url": "https://github.com/rust-lang/rust/commit/8a10440641f7ec89236b1f40129738426ad4d702"}], "stats": {"total": 207, "additions": 87, "deletions": 120}, "files": [{"sha": "df8e35d98fbcc14c19bf1166e0f60669d88bba7a", "filename": "src/methods.rs", "status": "modified", "additions": 15, "deletions": 28, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -2,7 +2,8 @@ use syntax::ast::*;\n use rustc::lint::*;\n use rustc::middle::ty;\n \n-use utils::{span_lint, match_def_path, walk_ptrs_ty};\n+use utils::{span_lint, match_type, walk_ptrs_ty};\n+use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n \n #[derive(Copy,Clone)]\n pub struct MethodsPass;\n@@ -16,45 +17,31 @@ declare_lint!(pub STR_TO_STRING, Warn,\n declare_lint!(pub STRING_TO_STRING, Warn,\n               \"calling `String.to_string()` which is a no-op\");\n \n-#[allow(unused_imports)]\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED, RESULT_UNWRAP_USED, STR_TO_STRING, STRING_TO_STRING)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n-        {\n-            // In case stuff gets moved around\n-            use core::option::Option;\n-            use core::result::Result;\n-            use collections::string::String;\n-        }\n         if let ExprMethodCall(ref ident, _, ref args) = expr.node {\n-            let ref obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0])).sty;\n+            let obj_ty = walk_ptrs_ty(cx.tcx.expr_ty(&*args[0]));\n             if ident.node.name == \"unwrap\" {\n-                if let ty::TyEnum(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"core\", \"option\", \"Option\"]) {\n-                        span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on an Option value. If you don't want \\\n-                                   to handle the None case gracefully, consider using\n-                                   expect() to provide a better panic message\");\n-                    }\n-                    else if match_def_path(cx, did.did, &[\"core\", \"result\", \"Result\"]) {\n-                        span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n-                                  \"used unwrap() on a Result value. Graceful handling \\\n-                                   of Err values is preferred\");\n-                    }\n+                if match_type(cx, obj_ty, &OPTION_PATH) {\n+                    span_lint(cx, OPTION_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on an Option value. If you don't want \\\n+                               to handle the None case gracefully, consider using \\\n+                               expect() to provide a better panic message\");\n+                } else if match_type(cx, obj_ty, &RESULT_PATH) {\n+                    span_lint(cx, RESULT_UNWRAP_USED, expr.span,\n+                              \"used unwrap() on a Result value. Graceful handling \\\n+                               of Err values is preferred\");\n                 }\n             }\n             else if ident.node.name == \"to_string\" {\n-                if let ty::TyStr = *obj_ty {\n+                if obj_ty.sty == ty::TyStr {\n                     span_lint(cx, STR_TO_STRING, expr.span, \"`str.to_owned()` is faster\");\n-                }\n-                else if let ty::TyStruct(did, _) = *obj_ty {\n-                    if match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"]) {\n-                        span_lint(cx, STRING_TO_STRING, expr.span,\n-                                  \"`String.to_string()` is a no-op\")\n-                    }\n+                } else if match_type(cx, obj_ty, &STRING_PATH) {\n+                    span_lint(cx, STRING_TO_STRING, expr.span, \"`String.to_string()` is a no-op\");\n                 }\n             }\n         }"}, {"sha": "f0a0592f5e2c5ad9c8b642ec0cc0243318d137d6", "filename": "src/ptr_arg.rs", "status": "modified", "additions": 18, "deletions": 19, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fptr_arg.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -4,10 +4,10 @@\n \n use rustc::lint::*;\n use syntax::ast::*;\n-use syntax::codemap::Span;\n+use rustc::middle::ty;\n \n-use types::match_ty_unwrap;\n-use utils::span_lint;\n+use utils::{span_lint, match_type};\n+use utils::{STRING_PATH, VEC_PATH};\n \n declare_lint! {\n     pub PTR_ARG,\n@@ -45,22 +45,21 @@ impl LintPass for PtrArg {\n \n fn check_fn(cx: &Context, decl: &FnDecl) {\n     for arg in &decl.inputs {\n-        match &arg.ty.node {\n-            &TyPtr(ref p) | &TyRptr(_, ref p) =>\n-                check_ptr_subtype(cx, arg.ty.span, &p.ty),\n-            _ => ()\n+        if arg.ty.node == TyInfer {  // \"self\" arguments\n+            continue;\n+        }\n+        let ref sty = cx.tcx.pat_ty(&*arg.pat).sty;\n+        if let &ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = sty {\n+            if match_type(cx, ty, &VEC_PATH) {\n+                span_lint(cx, PTR_ARG, arg.ty.span,\n+                          \"writing `&Vec<_>` instead of `&[_]` involves one more reference \\\n+                           and cannot be used with non-Vec-based slices. Consider changing \\\n+                           the type to `&[...]`\");\n+            } else if match_type(cx, ty, &STRING_PATH) {\n+                span_lint(cx, PTR_ARG, arg.ty.span,\n+                          \"writing `&String` instead of `&str` involves a new object \\\n+                           where a slice will do. Consider changing the type to `&str`\");\n+            }\n         }\n     }\n }\n-\n-fn check_ptr_subtype(cx: &Context, span: Span, ty: &Ty) {\n-    match_ty_unwrap(ty, &[\"Vec\"]).map_or_else(|| match_ty_unwrap(ty,\n-        &[\"String\"]).map_or((), |_| {\n-            span_lint(cx, PTR_ARG, span,\n-                      \"writing `&String` instead of `&str` involves a new object \\\n-                       where a slice will do. Consider changing the type to `&str`\")\n-        }), |_| span_lint(cx, PTR_ARG, span,\n-                          \"writing `&Vec<_>` instead of \\\n-                           `&[_]` involves one more reference and cannot be used with \\\n-                           non-Vec-based slices. Consider changing the type to `&[...]`\"))\n-}"}, {"sha": "d1a0a7e702e4ba0d63e4b40e034a48566f8dee88", "filename": "src/ranges.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Franges.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -1,8 +1,7 @@\n use rustc::lint::{Context, LintArray, LintPass};\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n-use utils::{match_def_path};\n+use utils::match_type;\n \n declare_lint! {\n     pub RANGE_STEP_BY_ZERO, Warn,\n@@ -34,11 +33,9 @@ impl LintPass for StepByZero {\n fn is_range(cx: &Context, expr: &Expr) -> bool {\n     // No need for walk_ptrs_ty here because step_by moves self, so it\n     // can't be called on a borrowed range.\n-    if let TyStruct(did, _) = cx.tcx.expr_ty(expr).sty {\n-        // Note: RangeTo and RangeFull don't have step_by\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"Range\"]) ||\n-        match_def_path(cx, did.did, &[\"core\", \"ops\", \"RangeFrom\"])\n-    } else { false }\n+    let ty = cx.tcx.expr_ty(expr);\n+    // Note: RangeTo and RangeFull don't have step_by\n+    match_type(cx, ty, &[\"core\", \"ops\", \"Range\"]) || match_type(cx, ty, &[\"core\", \"ops\", \"RangeFrom\"])\n }\n \n fn is_lit_zero(expr: &Expr) -> bool {"}, {"sha": "64d18eeb26d5b897b4dc25cc8400b47227fa2d2b", "filename": "src/strings.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -4,12 +4,12 @@\n //! disable the subsumed lint unless it has a higher level\n \n use rustc::lint::*;\n-use rustc::middle::ty::TypeVariants::TyStruct;\n use syntax::ast::*;\n use syntax::codemap::Spanned;\n \n use eq_op::is_exp_equal;\n-use utils::{match_def_path, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::STRING_PATH;\n \n declare_lint! {\n     pub STRING_ADD_ASSIGN,\n@@ -61,10 +61,7 @@ impl LintPass for StringAdd {\n }\n \n fn is_string(cx: &Context, e: &Expr) -> bool {\n-    let ty = walk_ptrs_ty(cx.tcx.expr_ty(e));\n-    if let TyStruct(did, _) = ty.sty {\n-        match_def_path(cx, did.did, &[\"collections\", \"string\", \"String\"])\n-    } else { false }\n+    match_type(cx, walk_ptrs_ty(cx.tcx.expr_ty(e)), &STRING_PATH)\n }\n \n fn is_add(cx: &Context, src: &Expr, target: &Expr) -> bool {"}, {"sha": "622f733f8122c809793c2f4f7058d06ef9dedc2d", "filename": "src/types.rs", "status": "modified", "additions": 17, "deletions": 52, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -2,11 +2,11 @@ use rustc::lint::*;\n use syntax::ast;\n use syntax::ast::*;\n use syntax::ast_util::{is_comparison_binop, binop_to_string};\n-use syntax::ptr::P;\n use rustc::middle::ty;\n use syntax::codemap::ExpnInfo;\n \n-use utils::{in_macro, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{in_macro, match_type, snippet, span_lint, span_help_and_lint, in_external_macro};\n+use utils::{LL_PATH, VEC_PATH};\n \n /// Handles all the linting of funky types\n #[allow(missing_copy_implementations)]\n@@ -18,61 +18,26 @@ declare_lint!(pub LINKEDLIST, Warn,\n               \"usage of LinkedList, usually a vector is faster, or a more specialized data \\\n                structure like a RingBuf\");\n \n-/// Matches a type with a provided string, and returns its type parameters if successful\n-pub fn match_ty_unwrap<'a>(ty: &'a Ty, segments: &[&str]) -> Option<&'a [P<Ty>]> {\n-    match ty.node {\n-        TyPath(_, Path {segments: ref seg, ..}) => {\n-            // So ast::Path isn't the full path, just the tokens that were provided.\n-            // I could muck around with the maps and find the full path\n-            // however the more efficient way is to simply reverse the iterators and zip them\n-            // which will compare them in reverse until one of them runs out of segments\n-            if seg.iter().rev().zip(segments.iter().rev()).all(|(a,b)| a.identifier.name == b) {\n-                match seg[..].last() {\n-                    Some(&PathSegment {parameters: AngleBracketedParameters(ref a), ..}) => {\n-                        Some(&a.types[..])\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            }\n-        },\n-        _ => None\n-    }\n-}\n-\n-#[allow(unused_imports)]\n impl LintPass for TypePass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(BOX_VEC, LINKEDLIST)\n     }\n \n-    fn check_ty(&mut self, cx: &Context, ty: &ast::Ty) {\n-        {\n-            // In case stuff gets moved around\n-            use std::boxed::Box;\n-            use std::vec::Vec;\n-        }\n-        match_ty_unwrap(ty, &[\"std\", \"boxed\", \"Box\"]).and_then(|t| t.first())\n-          .and_then(|t| match_ty_unwrap(&**t, &[\"std\", \"vec\", \"Vec\"]))\n-          .map(|_| {\n-            span_help_and_lint(cx, BOX_VEC, ty.span,\n-                              \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n-                              \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n-          });\n-        {\n-            // In case stuff gets moved around\n-            use collections::linked_list::LinkedList as DL1;\n-            use std::collections::linked_list::LinkedList as DL2;\n-        }\n-        let dlists = [vec![\"std\",\"collections\",\"linked_list\",\"LinkedList\"],\n-                      vec![\"collections\",\"linked_list\",\"LinkedList\"]];\n-        for path in &dlists {\n-            if match_ty_unwrap(ty, &path[..]).is_some() {\n-                span_help_and_lint(cx, LINKEDLIST, ty.span,\n-                                   \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                   \"a RingBuf might work\");\n-                return;\n+    fn check_ty(&mut self, cx: &Context, ast_ty: &ast::Ty) {\n+        if let Some(ty) = cx.tcx.ast_ty_to_ty_cache.borrow().get(&ast_ty.id) {\n+            if let ty::TyBox(ref inner) = ty.sty {\n+                if match_type(cx, inner, &VEC_PATH) {\n+                    span_help_and_lint(\n+                        cx, BOX_VEC, ast_ty.span,\n+                        \"you seem to be trying to use `Box<Vec<T>>`. Did you mean to use `Vec<T>`?\",\n+                        \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation\");\n+                }\n+            }\n+            else if match_type(cx, ty, &LL_PATH) {\n+                span_help_and_lint(\n+                    cx, LINKEDLIST, ast_ty.span,\n+                    \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                    \"a RingBuf might work\");\n             }\n         }\n     }"}, {"sha": "4fd36fb91d4174b32f75aee5ae61c2c0edbfbba2", "filename": "src/utils.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -6,6 +6,13 @@ use rustc::ast_map::Node::NodeExpr;\n use rustc::middle::ty;\n use std::borrow::Cow;\n \n+// module DefPaths for certain structs/enums we check for\n+pub const OPTION_PATH: [&'static str; 3] = [\"core\", \"option\", \"Option\"];\n+pub const RESULT_PATH: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n+pub const STRING_PATH: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n+pub const VEC_PATH:    [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];\n+pub const LL_PATH:     [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n+\n /// returns true if the macro that expanded the crate was outside of\n /// the current crate or was a compiler plugin\n pub fn in_macro(cx: &Context, opt_info: Option<&ExpnInfo>) -> bool {\n@@ -37,6 +44,18 @@ pub fn match_def_path(cx: &Context, def_id: DefId, path: &[&str]) -> bool {\n         .zip(path.iter()).all(|(nm, p)| nm == p))\n }\n \n+/// check if type is struct or enum type with given def path\n+pub fn match_type(cx: &Context, ty: ty::Ty, path: &[&str]) -> bool {\n+    match ty.sty {\n+        ty::TyEnum(ref adt, _) | ty::TyStruct(ref adt, _) => {\n+            match_def_path(cx, adt.did, path)\n+        }\n+        _ => {\n+            false\n+        }\n+    }\n+}\n+\n /// match a Path against a slice of segment string literals, e.g.\n /// `match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])`\n pub fn match_path(path: &Path, segments: &[&str]) -> bool {"}, {"sha": "a800c045a502a8e6843792e30fab3b3d4b3bca73", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -12,4 +12,4 @@ pub fn test(foo: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n \n fn main(){\n     test(LinkedList::new());\n-}\n\\ No newline at end of file\n+}"}, {"sha": "d0615be492b01e4d49d5ff0e8524c5cde46566e0", "filename": "tests/compile-fail/ptr_arg.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1a4248e68e818c64c5c0e0e68bd2d647c857760/tests%2Fcompile-fail%2Fptr_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1a4248e68e818c64c5c0e0e68bd2d647c857760/tests%2Fcompile-fail%2Fptr_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_arg.rs?ref=e1a4248e68e818c64c5c0e0e68bd2d647c857760", "patch": "@@ -1,20 +1,23 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n+#![allow(unused)]\n+#![deny(ptr_arg)]\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n fn do_vec(x: &Vec<i64>) { //~ERROR writing `&Vec<_>` instead of `&[_]`\n     //Nothing here\n }\n \n-#[deny(ptr_arg)]\n-#[allow(unused)]\n+fn do_vec_mut(x: &mut Vec<i64>) { // no error here\n+    //Nothing here\n+}\n+\n fn do_str(x: &String) { //~ERROR writing `&String` instead of `&str`\n     //Nothing here either\n }\n \n+fn do_str_mut(x: &mut String) { // no error here\n+    //Nothing here either\n+}\n+\n fn main() {\n-    let x = vec![1i64, 2, 3];\n-    do_vec(&x);\n-    do_str(&\"hello\".to_owned());\n }"}]}