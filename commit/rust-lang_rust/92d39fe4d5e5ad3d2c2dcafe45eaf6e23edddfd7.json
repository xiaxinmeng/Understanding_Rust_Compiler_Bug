{"sha": "92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZDM5ZmU0ZDVlNWFkM2QyYzJkY2FmZTQ1ZWFmNmUyM2VkZGRmZDc=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-12T04:25:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-14T16:24:43Z"}, "message": "syntax: Remove #[allow(vecs_implicitly_copyable)]", "tree": {"sha": "817ebba2489c228d8494662b4ce188e0782b321a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/817ebba2489c228d8494662b4ce188e0782b321a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "html_url": "https://github.com/rust-lang/rust/commit/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2951527528b39dbf47c02b3d329129d677ddcdfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/2951527528b39dbf47c02b3d329129d677ddcdfd", "html_url": "https://github.com/rust-lang/rust/commit/2951527528b39dbf47c02b3d329129d677ddcdfd"}], "stats": {"total": 475, "additions": 239, "deletions": 236}, "files": [{"sha": "e9f15c0a8f5ceda338e0846cff844bd49a6319c0", "filename": "src/libsyntax/ast_map.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -60,12 +60,12 @@ pub fn path_to_str_with_sep(p: &[path_elt], sep: ~str, itr: @ident_interner)\n     str::connect(strs, sep)\n }\n \n-pub fn path_ident_to_str(p: path, i: ident, itr: @ident_interner) -> ~str {\n-    if vec::is_empty(p) {\n+pub fn path_ident_to_str(p: &path, i: ident, itr: @ident_interner) -> ~str {\n+    if vec::is_empty(*p) {\n         //FIXME /* FIXME (#2543) */ copy *i\n         copy *itr.get(i)\n     } else {\n-        fmt!(\"%s::%s\", path_to_str(p, itr), *itr.get(i))\n+        fmt!(\"%s::%s\", path_to_str(*p, itr), *itr.get(i))\n     }\n }\n \n@@ -338,7 +338,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n         fmt!(\"unknown node (id=%d)\", id)\n       }\n       Some(&node_item(item, path)) => {\n-        let path_str = path_ident_to_str(*path, item.ident, itr);\n+        let path_str = path_ident_to_str(path, item.ident, itr);\n         let item_str = match item.node {\n           item_const(*) => ~\"const\",\n           item_fn(*) => ~\"fn\",\n@@ -355,7 +355,7 @@ pub fn node_id_to_str(map: map, id: node_id, itr: @ident_interner) -> ~str {\n       }\n       Some(&node_foreign_item(item, abi, _, path)) => {\n         fmt!(\"foreign item %s with abi %? (id=%?)\",\n-             path_ident_to_str(*path, item.ident, itr), abi, id)\n+             path_ident_to_str(path, item.ident, itr), abi, id)\n       }\n       Some(&node_method(m, _, path)) => {\n         fmt!(\"method %s in %s (id=%?)\","}, {"sha": "6b2aa2416f8c73db12e00f092e7955a3d4bcbf8d", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -184,7 +184,7 @@ fn diagnosticcolor(lvl: level) -> u8 {\n     }\n }\n \n-fn print_diagnostic(topic: ~str, lvl: level, msg: &str) {\n+fn print_diagnostic(topic: &str, lvl: level, msg: &str) {\n     let use_color = term::color_supported() &&\n         io::stderr().get_type() == io::Screen;\n     if !topic.is_empty() {"}, {"sha": "97c5797cf57d24e9237bd81ada5b0e3a6b94ceaa", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -119,13 +119,13 @@ pub fn expand_asm(cx: @ext_ctxt, sp: span, tts: &[ast::token_tree])\n                 cons = str::connect(clobs, \",\");\n             }\n             Options => {\n-                let option = *p.parse_str();\n+                let option = p.parse_str();\n \n-                if option == ~\"volatile\" {\n+                if \"volatile\" == *option {\n                     volatile = true;\n-                } else if option == ~\"alignstack\" {\n+                } else if \"alignstack\" == *option {\n                     alignstack = true;\n-                } else if option == ~\"intel\" {\n+                } else if \"intel\" == *option {\n                     dialect = ast::asm_intel;\n                 }\n "}, {"sha": "ac86d266d736b8ee00486b72946bd2d91d5c6dba", "filename": "src/libsyntax/ext/auto_encode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fauto_encode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_encode.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -836,7 +836,7 @@ fn mk_struct_deser_impl(\n     cx: @ext_ctxt,\n     span: span,\n     ident: ast::ident,\n-    fields: ~[@ast::struct_field],\n+    fields: &[@ast::struct_field],\n     generics: &ast::Generics\n ) -> @ast::item {\n     let fields = do mk_struct_fields(fields).mapi |idx, field| {\n@@ -1120,7 +1120,7 @@ fn mk_enum_deser_body(\n     ext_cx: @ext_ctxt,\n     span: span,\n     name: ast::ident,\n-    variants: ~[ast::variant]\n+    variants: &[ast::variant]\n ) -> @ast::expr {\n     let expr_arm_names = build::mk_base_vec_e(\n         ext_cx,"}, {"sha": "605ba65b51a9df5ee7fe471cb1ec27d88e8970f9", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -509,7 +509,7 @@ pub fn mk_unreachable(cx: @ext_ctxt, span: span) -> @ast::expr {\n         ],\n         ~[\n             mk_base_str(cx, span, ~\"internal error: entered unreachable code\"),\n-            mk_base_str(cx, span, loc.file.name),\n+            mk_base_str(cx, span, copy loc.file.name),\n             mk_uint(cx, span, loc.line),\n         ]\n     )"}, {"sha": "2151e9529c415b85cf7f2c699457cf4dcf4b8b87", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -60,19 +60,19 @@ fn cs_clone(cx: @ext_ctxt, span: span,\n         build::mk_method_call(cx, span, field, clone_ident, ~[]);\n \n     match *substr.fields {\n-        Struct(af) => {\n+        Struct(ref af) => {\n             ctor_ident = ~[ substr.type_ident ];\n             all_fields = af;\n         }\n-        EnumMatching(_, variant, af) => {\n+        EnumMatching(_, variant, ref af) => {\n             ctor_ident = ~[ variant.node.name ];\n             all_fields = af;\n         },\n         EnumNonMatching(*) => cx.span_bug(span, \"Non-matching enum variants in `deriving(Clone)`\"),\n         StaticEnum(*) | StaticStruct(*) => cx.span_bug(span, \"Static method in `deriving(Clone)`\")\n     }\n \n-    match all_fields {\n+    match *all_fields {\n         [(None, _, _), .. _] => {\n             // enum-like\n             let subcalls = all_fields.map(|&(_, self_f, _)| subcall(self_f));"}, {"sha": "cdb9f620301489653fe7dedf1461e566d5b696ab", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -65,8 +65,6 @@ fn cs_ord(less: bool, equal: bool,\n     let false_blk_expr = build::mk_block(cx, span,\n                                          ~[], ~[],\n                                          Some(build::mk_bool(cx, span, false)));\n-    let true_blk = build::mk_simple_block(cx, span,\n-                                          build::mk_bool(cx, span, true));\n     let base = build::mk_bool(cx, span, equal);\n \n     cs_fold(\n@@ -108,6 +106,8 @@ fn cs_ord(less: bool, equal: bool,\n \n             let cmp = build::mk_method_call(cx, span,\n                                             self_f, binop, other_fs.to_owned());\n+            let true_blk = build::mk_simple_block(cx, span,\n+                                                  build::mk_bool(cx, span, true));\n             let if_ = expr_if(cmp, true_blk, Some(elseif));\n \n             build::mk_expr(cx, span, if_)"}, {"sha": "5ec4e028454fb88c721c8db6b4c9dd36dec37100", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -55,15 +55,16 @@ pub fn ordering_const(cx: @ext_ctxt, span: span, cnst: Ordering) -> @expr {\n \n pub fn cs_cmp(cx: @ext_ctxt, span: span,\n               substr: &Substructure) -> @expr {\n-    let lexical_ord = ~[cx.ident_of(\"core\"),\n-                        cx.ident_of(\"cmp\"),\n-                        cx.ident_of(\"lexical_ordering\")];\n \n     cs_same_method_fold(\n         // foldr (possibly) nests the matches in lexical_ordering better\n         false,\n         |cx, span, old, new| {\n-            build::mk_call_global(cx, span, lexical_ord, ~[old, new])\n+            build::mk_call_global(cx, span,\n+                                  ~[cx.ident_of(\"core\"),\n+                                    cx.ident_of(\"cmp\"),\n+                                    cx.ident_of(\"lexical_ordering\")],\n+                                  ~[old, new])\n         },\n         ordering_const(cx, span, Equal),\n         |cx, span, list, _| {"}, {"sha": "be2cc6dd25e06653b7e1950d83860caeb10674a8", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 63, "deletions": 62, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -259,14 +259,14 @@ pub enum SubstructureFields<'self> {\n     fields: `(field ident, self, [others])`, where the field ident is\n     only non-`None` in the case of a struct variant.\n     */\n-    EnumMatching(uint, ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n+    EnumMatching(uint, &'self ast::variant, ~[(Option<ident>, @expr, ~[@expr])]),\n \n     /**\n     non-matching variants of the enum, [(variant index, ast::variant,\n     [field ident, fields])] (i.e. all fields for self are in the\n     first tuple, for other1 are in the second tuple, etc.)\n     */\n-    EnumNonMatching(~[(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n+    EnumNonMatching(&'self [(uint, ast::variant, ~[(Option<ident>, @expr)])]),\n \n     /// A static method where Self is a struct\n     StaticStruct(&'self ast::struct_def, Either<uint, ~[ident]>),\n@@ -290,7 +290,7 @@ representing each variant: (variant index, ast::variant instance,\n */\n pub type EnumNonMatchFunc<'self> =\n     &'self fn(@ext_ctxt, span,\n-              ~[(uint, ast::variant,\n+              &[(uint, ast::variant,\n                  ~[(Option<ident>, @expr)])],\n               &[@expr]) -> @expr;\n \n@@ -416,8 +416,9 @@ impl<'self> MethodDef<'self> {\n         let mut nonstatic = false;\n \n         match self.self_ty {\n-            Some(self_ptr) => {\n-                let (self_expr, self_ty) = ty::get_explicit_self(cx, span, self_ptr);\n+            Some(ref self_ptr) => {\n+                let (self_expr, self_ty) = ty::get_explicit_self(cx, span,\n+                                                                 self_ptr);\n \n                 ast_self_ty = self_ty;\n                 self_args.push(self_expr);\n@@ -616,9 +617,10 @@ impl<'self> MethodDef<'self> {\n                                self_args: &[@expr],\n                                nonself_args: &[@expr])\n         -> @expr {\n+        let mut matches = ~[];\n         self.build_enum_match(cx, span, enum_def, type_ident,\n                               self_args, nonself_args,\n-                              None, ~[], 0)\n+                              None, &mut matches, 0)\n     }\n \n \n@@ -650,58 +652,57 @@ impl<'self> MethodDef<'self> {\n                         self_args: &[@expr],\n                         nonself_args: &[@expr],\n                         matching: Option<uint>,\n-                        matches_so_far: ~[(uint, ast::variant,\n-                                           ~[(Option<ident>, @expr)])],\n+                        matches_so_far: &mut ~[(uint, ast::variant,\n+                                              ~[(Option<ident>, @expr)])],\n                         match_count: uint) -> @expr {\n         if match_count == self_args.len() {\n             // we've matched against all arguments, so make the final\n             // expression at the bottom of the match tree\n-            match matches_so_far {\n-                [] => cx.span_bug(span, ~\"no self match on an enum in generic `deriving`\"),\n-                _ => {\n-                    // we currently have a vec of vecs, where each\n-                    // subvec is the fields of one of the arguments,\n-                    // but if the variants all match, we want this as\n-                    // vec of tuples, where each tuple represents a\n-                    // field.\n-\n-                    let substructure;\n-\n-                    // most arms don't have matching variants, so do a\n-                    // quick check to see if they match (even though\n-                    // this means iterating twice) instead of being\n-                    // optimistic and doing a pile of allocations etc.\n-                    match matching {\n-                        Some(variant_index) => {\n-                            // `ref` inside let matches is buggy. Causes havoc wih rusc.\n-                            // let (variant_index, ref self_vec) = matches_so_far[0];\n-                            let (variant, self_vec) = match matches_so_far[0] {\n-                                (_, v, ref s) => (v, s)\n-                            };\n-\n-                            let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n-\n-                            for matches_so_far.tail().each |&(_, _, other_fields)| {\n-                                for other_fields.eachi |i, &(_, other_field)| {\n-                                    enum_matching_fields[i].push(other_field);\n-                                }\n-                            }\n-                            let field_tuples =\n-                                do vec::map_zip(*self_vec,\n-                                             enum_matching_fields) |&(id, self_f), &other| {\n-                                (id, self_f, other)\n-                            };\n-                            substructure = EnumMatching(variant_index, variant, field_tuples);\n-                        }\n-                        None => {\n-                            substructure = EnumNonMatching(matches_so_far);\n+            if matches_so_far.len() == 0 {\n+                cx.span_bug(span, ~\"no self match on an enum in generic \\\n+                                    `deriving`\");\n+            }\n+            // we currently have a vec of vecs, where each\n+            // subvec is the fields of one of the arguments,\n+            // but if the variants all match, we want this as\n+            // vec of tuples, where each tuple represents a\n+            // field.\n+\n+            let substructure;\n+\n+            // most arms don't have matching variants, so do a\n+            // quick check to see if they match (even though\n+            // this means iterating twice) instead of being\n+            // optimistic and doing a pile of allocations etc.\n+            match matching {\n+                Some(variant_index) => {\n+                    // `ref` inside let matches is buggy. Causes havoc wih rusc.\n+                    // let (variant_index, ref self_vec) = matches_so_far[0];\n+                    let (variant, self_vec) = match matches_so_far[0] {\n+                        (_, ref v, ref s) => (v, s)\n+                    };\n+\n+                    let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n+\n+                    for matches_so_far.tail().each |&(_, _, other_fields)| {\n+                        for other_fields.eachi |i, &(_, other_field)| {\n+                            enum_matching_fields[i].push(other_field);\n                         }\n                     }\n-                    self.call_substructure_method(cx, span, type_ident,\n-                                                  self_args, nonself_args,\n-                                                  &substructure)\n+                    let field_tuples =\n+                        do vec::map_zip(*self_vec,\n+                                     enum_matching_fields) |&(id, self_f), &other| {\n+                        (id, self_f, other)\n+                    };\n+                    substructure = EnumMatching(variant_index, variant, field_tuples);\n+                }\n+                None => {\n+                    substructure = EnumNonMatching(*matches_so_far);\n                 }\n             }\n+            self.call_substructure_method(cx, span, type_ident,\n+                                          self_args, nonself_args,\n+                                          &substructure)\n \n         } else {  // there are still matches to create\n             let current_match_str = if match_count == 0 {\n@@ -712,9 +713,6 @@ impl<'self> MethodDef<'self> {\n \n             let mut arms = ~[];\n \n-            // this is used as a stack\n-            let mut matches_so_far = matches_so_far;\n-\n             // the code for nonmatching variants only matters when\n             // we've seen at least one other variant already\n             if self.const_nonmatching && match_count > 0 {\n@@ -732,7 +730,7 @@ impl<'self> MethodDef<'self> {\n                                                                     current_match_str,\n                                                                     ast::m_imm);\n \n-                matches_so_far.push((index, *variant, idents));\n+                matches_so_far.push((index, /*bad*/ copy *variant, idents));\n                 let arm_expr = self.build_enum_match(cx, span,\n                                                      enum_def,\n                                                      type_ident,\n@@ -744,9 +742,10 @@ impl<'self> MethodDef<'self> {\n                 arms.push(build::mk_arm(cx, span, ~[ pattern ], arm_expr));\n \n                 if enum_def.variants.len() > 1 {\n+                    let e = &EnumNonMatching(&[]);\n                     let wild_expr = self.call_substructure_method(cx, span, type_ident,\n                                                                   self_args, nonself_args,\n-                                                                  &EnumNonMatching(~[]));\n+                                                                  e);\n                     let wild_arm = build::mk_arm(cx, span,\n                                                  ~[ build::mk_pat_wild(cx, span) ],\n                                                  wild_expr);\n@@ -760,7 +759,7 @@ impl<'self> MethodDef<'self> {\n                                                                        current_match_str,\n                                                                        ast::m_imm);\n \n-                    matches_so_far.push((index, *variant, idents));\n+                    matches_so_far.push((index, /*bad*/ copy *variant, idents));\n                     let new_matching =\n                         match matching {\n                             _ if match_count == 0 => Some(index),\n@@ -850,7 +849,7 @@ pub fn cs_fold(use_foldl: bool,\n                cx: @ext_ctxt, span: span,\n                substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n-        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             if use_foldl {\n                 do all_fields.foldl(base) |&old, &(_, self_f, other_fs)| {\n                     f(cx, span, old, self_f, other_fs)\n@@ -861,8 +860,9 @@ pub fn cs_fold(use_foldl: bool,\n                 }\n             }\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n-                                                      all_enums, substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+                                                          *all_enums,\n+                                                          substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n             cx.span_bug(span, \"Static function in `deriving`\")\n         }\n@@ -885,7 +885,7 @@ pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n                       cx: @ext_ctxt, span: span,\n                       substructure: &Substructure) -> @expr {\n     match *substructure.fields {\n-        EnumMatching(_, _, all_fields) | Struct(all_fields) => {\n+        EnumMatching(_, _, ref all_fields) | Struct(ref all_fields) => {\n             // call self_n.method(other_1_n, other_2_n, ...)\n             let called = do all_fields.map |&(_, self_field, other_fields)| {\n                 build::mk_method_call(cx, span,\n@@ -896,8 +896,9 @@ pub fn cs_same_method(f: &fn(@ext_ctxt, span, ~[@expr]) -> @expr,\n \n             f(cx, span, called)\n         },\n-        EnumNonMatching(all_enums) => enum_nonmatch_f(cx, span,\n-                                                      all_enums, substructure.nonself_args),\n+        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, span,\n+                                                          *all_enums,\n+                                                          substructure.nonself_args),\n         StaticEnum(*) | StaticStruct(*) => {\n             cx.span_bug(span, \"Static function in `deriving`\")\n         }"}, {"sha": "ba1f4e3ebb208a574641a68bde45c9fc5c04b899", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -59,15 +59,15 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n     use ast::{meta_list, meta_name_value, meta_word};\n \n     match mitem.node {\n-        meta_name_value(_, l) => {\n+        meta_name_value(_, ref l) => {\n             cx.span_err(l.span, ~\"unexpected value in `deriving`\");\n             in_items\n         }\n         meta_word(_) | meta_list(_, []) => {\n             cx.span_warn(mitem.span, ~\"empty trait list in `deriving`\");\n             in_items\n         }\n-        meta_list(_, titems) => {\n+        meta_list(_, ref titems) => {\n             do titems.foldr(in_items) |&titem, in_items| {\n                 match titem.node {\n                     meta_name_value(tname, _) |\n@@ -92,9 +92,9 @@ pub fn expand_meta_deriving(cx: @ext_ctxt,\n \n                             ~\"ToStr\" => expand!(to_str::expand_deriving_to_str),\n \n-                            tname => {\n+                            ref tname => {\n                                 cx.span_err(titem.span, fmt!(\"unknown \\\n-                                    `deriving` trait: `%s`\", tname));\n+                                    `deriving` trait: `%s`\", *tname));\n                                 in_items\n                             }\n                         }"}, {"sha": "768ac7458d673c7ad905d250c03a04df7bf92b25", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -63,7 +63,7 @@ pub impl Path {\n     fn to_path(&self, cx: @ext_ctxt, span: span,\n                self_ty: ident, self_generics: &Generics) -> @ast::Path {\n         let idents = self.path.map(|s| cx.ident_of(*s) );\n-        let lt = mk_lifetime(cx, span, self.lifetime);\n+        let lt = mk_lifetime(cx, span, &self.lifetime);\n         let tys = self.params.map(|t| t.to_ty(cx, span, self_ty, self_generics));\n \n         if self.global {\n@@ -106,9 +106,9 @@ pub fn nil_ty() -> Ty {\n     Tuple(~[])\n }\n \n-fn mk_lifetime(cx: @ext_ctxt, span: span, lt: Option<~str>) -> Option<@ast::Lifetime> {\n-    match lt {\n-        Some(s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(s))),\n+fn mk_lifetime(cx: @ext_ctxt, span: span, lt: &Option<~str>) -> Option<@ast::Lifetime> {\n+    match *lt {\n+        Some(ref s) => Some(@build::mk_lifetime(cx, span, cx.ident_of(*s))),\n         None => None\n     }\n }\n@@ -123,10 +123,10 @@ pub impl Ty {\n                     Owned => {\n                         build::mk_ty_uniq(cx, span, raw_ty)\n                     }\n-                    Managed(copy mutbl) => {\n+                    Managed(mutbl) => {\n                         build::mk_ty_box(cx, span, raw_ty, mutbl)\n                     }\n-                    Borrowed(copy lt, copy mutbl) => {\n+                    Borrowed(ref lt, mutbl) => {\n                         let lt = mk_lifetime(cx, span, lt);\n                         build::mk_ty_rptr(cx, span, raw_ty, lt, mutbl)\n                     }\n@@ -216,20 +216,20 @@ pub impl LifetimeBounds {\n }\n \n \n-pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: Option<PtrTy>)\n+pub fn get_explicit_self(cx: @ext_ctxt, span: span, self_ptr: &Option<PtrTy>)\n     -> (@expr, ast::self_ty) {\n     let self_path = build::make_self(cx, span);\n-    match self_ptr {\n+    match *self_ptr {\n         None => {\n             (self_path, respan(span, ast::sty_value))\n         }\n-        Some(ptr) => {\n+        Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n-                match ptr {\n+                match *ptr {\n                     Owned => ast::sty_uniq(ast::m_imm),\n                     Managed(mutbl) => ast::sty_box(mutbl),\n-                    Borrowed(lt, mutbl) => {\n+                    Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| @build::mk_lifetime(cx, span,\n                                                                 cx.ident_of(*s)));\n                         ast::sty_region(lt, mutbl)"}, {"sha": "26b3178a91110203b0aad867c9f72b9e2d9441cc", "filename": "src/libsyntax/ext/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -62,7 +62,7 @@ fn pieces_to_expr(cx: @ext_ctxt, sp: span,\n     // which tells the RT::conv* functions how to perform the conversion\n \n     fn make_rt_conv_expr(cx: @ext_ctxt, sp: span, cnv: &Conv) -> @ast::expr {\n-        fn make_flags(cx: @ext_ctxt, sp: span, flags: ~[Flag]) -> @ast::expr {\n+        fn make_flags(cx: @ext_ctxt, sp: span, flags: &[Flag]) -> @ast::expr {\n             let mut tmp_expr = make_rt_path_expr(cx, sp, \"flag_none\");\n             for flags.each |f| {\n                 let fstr = match *f {"}, {"sha": "f897eb787e5665dafc0d2d5cb5a25ae633cdbe8e", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -154,14 +154,14 @@ pub struct protocol_ {\n \n pub impl protocol_ {\n     /// Get a state.\n-    fn get_state(&self, name: ~str) -> state {\n-        self.states.find(|i| i.name == name).get()\n+    fn get_state(&self, name: &str) -> state {\n+        self.states.find(|i| name == i.name).get()\n     }\n \n     fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n-    fn has_state(&self, name: ~str) -> bool {\n-        self.states.find(|i| i.name == name).is_some()\n+    fn has_state(&self, name: &str) -> bool {\n+        self.states.find(|i| name == i.name).is_some()\n     }\n \n     fn filename(&self) -> ~str {"}, {"sha": "f4227cd2f2c74eb133aacd61ac130c51db6e0e8f", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -452,9 +452,9 @@ fn mk_binop(cx: @ext_ctxt, sp: span, bop: token::binop) -> @ast::expr {\n                    ids_ext(cx, ~[name.to_owned()]))\n }\n \n-fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n+fn mk_token(cx: @ext_ctxt, sp: span, tok: &token::Token) -> @ast::expr {\n \n-    match tok {\n+    match *tok {\n         BINOP(binop) => {\n             return build::mk_call(cx, sp,\n                                   ids_ext(cx, ~[~\"BINOP\"]),\n@@ -561,7 +561,7 @@ fn mk_token(cx: @ext_ctxt, sp: span, tok: token::Token) -> @ast::expr {\n         _ => ()\n     }\n \n-    let name = match tok {\n+    let name = match *tok {\n         EQ => \"EQ\",\n         LT => \"LT\",\n         LE => \"LE\",\n@@ -612,7 +612,7 @@ fn mk_tt(cx: @ext_ctxt, sp: span, tt: &ast::token_tree)\n             let e_tok =\n                 build::mk_call(cx, sp,\n                                ids_ext(cx, ~[~\"tt_tok\"]),\n-                               ~[e_sp, mk_token(cx, sp, *tok)]);\n+                               ~[e_sp, mk_token(cx, sp, tok)]);\n             let e_push =\n                 build::mk_method_call(cx, sp,\n                                       build::mk_path(cx, sp, ids_ext(cx, ~[~\"tt\"])),"}, {"sha": "aa211973f1c52b19992d1ac8180e0e501ef6a4c3", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 20, "deletions": 21, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -130,7 +130,6 @@ pub fn count_names(ms: &[matcher]) -> uint {\n         }})\n }\n \n-#[allow(non_implicitly_copyable_typarams)]\n pub fn initial_matcher_pos(ms: ~[matcher], sep: Option<Token>, lo: BytePos)\n                         -> ~MatcherPos {\n     let mut match_idx_hi = 0u;\n@@ -184,15 +183,15 @@ pub enum named_match {\n \n pub type earley_item = ~MatcherPos;\n \n-pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n+pub fn nameize(p_s: @mut ParseSess, ms: &[matcher], res: &[@named_match])\n             -> HashMap<ident,@named_match> {\n-    fn n_rec(p_s: @mut ParseSess, m: matcher, res: ~[@named_match],\n+    fn n_rec(p_s: @mut ParseSess, m: &matcher, res: &[@named_match],\n              ret_val: &mut HashMap<ident, @named_match>) {\n-        match m {\n+        match *m {\n           codemap::spanned {node: match_tok(_), _} => (),\n           codemap::spanned {node: match_seq(ref more_ms, _, _, _, _), _} => {\n-            for (*more_ms).each() |next_m| {\n-                n_rec(p_s, *next_m, res, ret_val)\n+            for more_ms.each |next_m| {\n+                n_rec(p_s, next_m, res, ret_val)\n             };\n           }\n           codemap::spanned {\n@@ -207,7 +206,7 @@ pub fn nameize(p_s: @mut ParseSess, ms: ~[matcher], res: ~[@named_match])\n         }\n     }\n     let mut ret_val = HashMap::new();\n-    for ms.each() |m| { n_rec(p_s, *m, res, &mut ret_val) }\n+    for ms.each |m| { n_rec(p_s, m, res, &mut ret_val) }\n     return ret_val;\n }\n \n@@ -234,10 +233,10 @@ pub fn parse(\n     sess: @mut ParseSess,\n     cfg: ast::crate_cfg,\n     rdr: @reader,\n-    ms: ~[matcher]\n+    ms: &[matcher]\n ) -> parse_result {\n     let mut cur_eis = ~[];\n-    cur_eis.push(initial_matcher_pos(copy ms, None, rdr.peek().sp.lo));\n+    cur_eis.push(initial_matcher_pos(ms.to_owned(), None, rdr.peek().sp.lo));\n \n     loop {\n         let mut bb_eis = ~[]; // black-box parsed by parser.rs\n@@ -277,7 +276,7 @@ pub fn parse(\n \n                         // Only touch the binders we have actually bound\n                         for uint::range(ei.match_lo, ei.match_hi) |idx| {\n-                            let sub = ei.matches[idx];\n+                            let sub = copy ei.matches[idx];\n                             new_pos.matches[idx]\n                                 .push(@matched_seq(sub,\n                                                    mk_sp(ei.sp_lo,\n@@ -410,31 +409,31 @@ pub fn parse(\n     }\n }\n \n-pub fn parse_nt(p: &Parser, name: ~str) -> nonterminal {\n+pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n     match name {\n-      ~\"item\" => match p.parse_item(~[]) {\n+      \"item\" => match p.parse_item(~[]) {\n         Some(i) => token::nt_item(i),\n         None => p.fatal(~\"expected an item keyword\")\n       },\n-      ~\"block\" => token::nt_block(p.parse_block()),\n-      ~\"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n-      ~\"pat\" => token::nt_pat(p.parse_pat(true)),\n-      ~\"expr\" => token::nt_expr(p.parse_expr()),\n-      ~\"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n+      \"block\" => token::nt_block(p.parse_block()),\n+      \"stmt\" => token::nt_stmt(p.parse_stmt(~[])),\n+      \"pat\" => token::nt_pat(p.parse_pat(true)),\n+      \"expr\" => token::nt_expr(p.parse_expr()),\n+      \"ty\" => token::nt_ty(p.parse_ty(false /* no need to disambiguate*/)),\n       // this could be handled like a token, since it is one\n-      ~\"ident\" => match *p.token {\n+      \"ident\" => match *p.token {\n         token::IDENT(sn,b) => { p.bump(); token::nt_ident(sn,b) }\n         _ => p.fatal(~\"expected ident, found \"\n                      + token::to_str(p.reader.interner(), &copy *p.token))\n       },\n-      ~\"path\" => token::nt_path(p.parse_path_with_tps(false)),\n-      ~\"tt\" => {\n+      \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n+      \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());\n         *p.quote_depth -= 1u;\n         res\n       }\n-      ~\"matchers\" => token::nt_matchers(p.parse_matchers()),\n+      \"matchers\" => token::nt_matchers(p.parse_matchers()),\n       _ => p.fatal(~\"Unsupported builtin nonterminal parser: \" + name)\n     }\n }"}, {"sha": "be6cc7a846ad35751fa6ad9cecc56b37dddc9a2d", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -63,19 +63,19 @@ pub fn add_new_extension(cx: @ext_ctxt,\n \n     // Extract the arguments:\n     let lhses = match *argument_map.get(&lhs_nm) {\n-        @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+        @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n         _ => cx.span_bug(sp, ~\"wrong-structured lhs\")\n     };\n \n     let rhses = match *argument_map.get(&rhs_nm) {\n-      @matched_seq(ref s, _) => /* FIXME (#2543) */ copy *s,\n+      @matched_seq(ref s, _) => /* FIXME (#2543) */ @copy *s,\n       _ => cx.span_bug(sp, ~\"wrong-structured rhs\")\n     };\n \n     // Given `lhses` and `rhses`, this is the new macro we create\n     fn generic_extension(cx: @ext_ctxt, sp: span, name: ident,\n                          arg: &[ast::token_tree],\n-                         lhses: ~[@named_match], rhses: ~[@named_match])\n+                         lhses: &[@named_match], rhses: &[@named_match])\n     -> MacResult {\n \n         if cx.trace_macros() {\n@@ -93,7 +93,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n         let s_d = cx.parse_sess().span_diagnostic;\n         let itr = cx.parse_sess().interner;\n \n-        for lhses.eachi() |i, lhs| { // try each arm's matchers\n+        for lhses.eachi |i, lhs| { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating\n@@ -103,7 +103,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n                     None,\n                     vec::to_owned(arg)\n                 ) as @reader;\n-                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, (*mtcs)) {\n+                match parse(cx.parse_sess(), cx.cfg(), arg_rdr, *mtcs) {\n                   success(named_matches) => {\n                     let rhs = match rhses[i] {\n                         // okay, what's your transcriber?\n@@ -146,7 +146,7 @@ pub fn add_new_extension(cx: @ext_ctxt,\n     }\n \n     let exp: @fn(@ext_ctxt, span, &[ast::token_tree]) -> MacResult =\n-        |cx, sp, arg| generic_extension(cx, sp, name, arg, lhses, rhses);\n+        |cx, sp, arg| generic_extension(cx, sp, name, arg, *lhses, *rhses);\n \n     return MRDef(MacroDef{\n         name: copy *cx.parse_sess().interner.get(name),"}, {"sha": "438efb2326c7a0a4c9ba28dbeeab934bee8b3902", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -91,11 +91,11 @@ pub fn dup_tt_reader(r: @mut TtReader) -> @mut TtReader {\n         sp_diag: r.sp_diag,\n         interner: r.interner,\n         stack: dup_tt_frame(r.stack),\n-        interpolations: r.interpolations,\n         repeat_idx: copy r.repeat_idx,\n         repeat_len: copy r.repeat_len,\n         cur_tok: copy r.cur_tok,\n-        cur_span: r.cur_span\n+        cur_span: r.cur_span,\n+        interpolations: copy r.interpolations,\n     }\n }\n \n@@ -127,7 +127,7 @@ enum lis {\n     lis_unconstrained, lis_constraint(uint, ident), lis_contradiction(~str)\n }\n \n-fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n+fn lockstep_iter_size(t: &token_tree, r: &mut TtReader) -> lis {\n     fn lis_merge(lhs: lis, rhs: lis, r: &mut TtReader) -> lis {\n         match lhs {\n           lis_unconstrained => copy rhs,\n@@ -146,10 +146,10 @@ fn lockstep_iter_size(t: token_tree, r: &mut TtReader) -> lis {\n           }\n         }\n     }\n-    match t {\n+    match *t {\n       tt_delim(ref tts) | tt_seq(_, ref tts, _, _) => {\n-        vec::foldl(lis_unconstrained, (*tts), |lis, tt| {\n-            let lis2 = lockstep_iter_size(*tt, r);\n+        vec::foldl(lis_unconstrained, *tts, |lis, tt| {\n+            let lis2 = lockstep_iter_size(tt, r);\n             lis_merge(lis, lis2, r)\n         })\n       }\n@@ -230,7 +230,7 @@ pub fn tt_next_token(r: &mut TtReader) -> TokenAndSpan {\n           }\n           tt_seq(sp, copy tts, copy sep, zerok) => {\n             let t = tt_seq(sp, copy tts, copy sep, zerok);\n-            match lockstep_iter_size(t, r) {\n+            match lockstep_iter_size(&t, r) {\n               lis_unconstrained => {\n                 r.sp_diag.span_fatal(\n                     sp, /* blame macro writer */"}, {"sha": "6ed8994ed3319566a7b4d95ed48c07a4b3206596", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -44,7 +44,7 @@ pub trait ast_fold {\n pub struct AstFoldFns {\n     //unlike the others, item_ is non-trivial\n     fold_crate: @fn(&crate_, span, @ast_fold) -> (crate_, span),\n-    fold_view_item: @fn(view_item_, @ast_fold) -> view_item_,\n+    fold_view_item: @fn(&view_item_, @ast_fold) -> view_item_,\n     fold_foreign_item: @fn(@foreign_item, @ast_fold) -> @foreign_item,\n     fold_item: @fn(@item, @ast_fold) -> Option<@item>,\n     fold_struct_field: @fn(@struct_field, @ast_fold) -> @struct_field,\n@@ -112,7 +112,7 @@ fn fold_arg_(a: arg, fld: @ast_fold) -> arg {\n     }\n }\n //used in noop_fold_expr, and possibly elsewhere in the future\n-fn fold_mac_(m: mac, fld: @ast_fold) -> mac {\n+fn fold_mac_(m: &mac, fld: @ast_fold) -> mac {\n     spanned {\n         node: match m.node { mac_invoc_tt(*) => copy m.node },\n         span: fld.new_span(m.span),\n@@ -174,8 +174,8 @@ pub fn noop_fold_crate(c: &crate_, fld: @ast_fold) -> crate_ {\n     }\n }\n \n-fn noop_fold_view_item(vi: view_item_, _fld: @ast_fold) -> view_item_ {\n-    return /* FIXME (#2543) */ copy vi;\n+fn noop_fold_view_item(vi: &view_item_, _fld: @ast_fold) -> view_item_ {\n+    return /* FIXME (#2543) */ copy *vi;\n }\n \n \n@@ -351,7 +351,7 @@ fn noop_fold_stmt(s: &stmt_, fld: @ast_fold) -> stmt_ {\n         stmt_decl(d, nid) => stmt_decl(fld.fold_decl(d), fld.new_id(nid)),\n         stmt_expr(e, nid) => stmt_expr(fld.fold_expr(e), fld.new_id(nid)),\n         stmt_semi(e, nid) => stmt_semi(fld.fold_expr(e), fld.new_id(nid)),\n-        stmt_mac(ref mac, semi) => stmt_mac(fold_mac((*mac)), semi)\n+        stmt_mac(ref mac, semi) => stmt_mac(fold_mac(mac), semi)\n     }\n }\n \n@@ -540,14 +540,14 @@ pub fn noop_fold_expr(e: &expr_, fld: @ast_fold) -> expr_ {\n                 fld.fold_expr(e)\n             )\n         }\n-        expr_inline_asm(a) => {\n+        expr_inline_asm(ref a) => {\n             expr_inline_asm(inline_asm {\n                 inputs: a.inputs.map(|&(c, in)| (c, fld.fold_expr(in))),\n                 outputs: a.outputs.map(|&(c, out)| (c, fld.fold_expr(out))),\n-                .. a\n+                .. copy *a\n             })\n         }\n-        expr_mac(ref mac) => expr_mac(fold_mac((*mac))),\n+        expr_mac(ref mac) => expr_mac(fold_mac(mac)),\n         expr_struct(path, ref fields, maybe_expr) => {\n             expr_struct(\n                 fld.fold_path(path),\n@@ -590,12 +590,12 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 region: f.region,\n                 onceness: f.onceness,\n                 decl: fold_fn_decl(&f.decl, fld),\n-                lifetimes: f.lifetimes,\n+                lifetimes: copy f.lifetimes,\n             })\n         }\n         ty_bare_fn(ref f) => {\n             ty_bare_fn(@TyBareFn {\n-                lifetimes: f.lifetimes,\n+                lifetimes: copy f.lifetimes,\n                 purity: f.purity,\n                 abis: f.abis,\n                 decl: fold_fn_decl(&f.decl, fld)\n@@ -609,7 +609,7 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n                 fld.fold_expr(e)\n             )\n         }\n-        ty_mac(ref mac) => ty_mac(fold_mac(*mac))\n+        ty_mac(ref mac) => ty_mac(fold_mac(mac))\n     }\n }\n \n@@ -740,7 +740,7 @@ impl ast_fold for AstFoldFns {\n     fn fold_view_item(@self, x: @view_item) ->\n        @view_item {\n         @ast::view_item {\n-            node: (self.fold_view_item)(x.node, self as @ast_fold),\n+            node: (self.fold_view_item)(&x.node, self as @ast_fold),\n             attrs: vec::map(x.attrs, |a|\n                   fold_attribute_(*a, self as @ast_fold)),\n             vis: x.vis,"}, {"sha": "fa91b968f696f7b4204fa3a74306ad19dac11095", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -192,7 +192,7 @@ fn read_line_comments(rdr: @mut StringReader, code_to_the_left: bool,\n \n // FIXME #3961: This is not the right way to convert string byte\n // offsets to characters.\n-fn all_whitespace(s: ~str, begin: uint, end: uint) -> bool {\n+fn all_whitespace(s: &str, begin: uint, end: uint) -> bool {\n     let mut i: uint = begin;\n     while i != end {\n         if !is_whitespace(s[i] as char) { return false; } i += 1u;"}, {"sha": "211d123e8872db251ce136698552ddb17524d3f0", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -253,17 +253,17 @@ pub impl Parser {\n         }\n     }\n \n-    fn token_is_obsolete_ident(&self, ident: &str, token: Token) -> bool {\n-        match token {\n-            token::IDENT(copy sid, _) => {\n+    fn token_is_obsolete_ident(&self, ident: &str, token: &Token) -> bool {\n+        match *token {\n+            token::IDENT(sid, _) => {\n                 str::eq_slice(*self.id_to_str(sid), ident)\n             }\n             _ => false\n         }\n     }\n \n     fn is_obsolete_ident(&self, ident: &str) -> bool {\n-        self.token_is_obsolete_ident(ident, *self.token)\n+        self.token_is_obsolete_ident(ident, self.token)\n     }\n \n     fn eat_obsolete_ident(&self, ident: &str) -> bool {\n@@ -289,7 +289,7 @@ pub impl Parser {\n     fn try_parse_obsolete_with(&self) -> bool {\n         if *self.token == token::COMMA\n             && self.token_is_obsolete_ident(\"with\",\n-                                            self.look_ahead(1u)) {\n+                                            &self.look_ahead(1u)) {\n             self.bump();\n         }\n         if self.eat_obsolete_ident(\"with\") {\n@@ -301,13 +301,13 @@ pub impl Parser {\n         }\n     }\n \n-    fn try_parse_obsolete_priv_section(&self, attrs: ~[attribute]) -> bool {\n+    fn try_parse_obsolete_priv_section(&self, attrs: &[attribute]) -> bool {\n         if self.is_keyword(&~\"priv\") && self.look_ahead(1) == token::LBRACE {\n             self.obsolete(copy *self.span, ObsoletePrivSection);\n             self.eat_keyword(&~\"priv\");\n             self.bump();\n             while *self.token != token::RBRACE {\n-                self.parse_single_struct_field(ast::private, attrs);\n+                self.parse_single_struct_field(ast::private, attrs.to_owned());\n             }\n             self.bump();\n             true"}, {"sha": "2a7af36f6f2a7743dcaa3d79b84c28f418dc7663", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -708,7 +708,7 @@ pub impl Parser {\n             self.obsolete(*self.last_span, ObsoleteBareFnType);\n             result\n         } else if *self.token == token::MOD_SEP\n-            || is_ident_or_path(&*self.token) {\n+            || is_ident_or_path(self.token) {\n             // NAMED TYPE\n             let path = self.parse_path_with_tps(false);\n             ty_path(path, self.get_id())\n@@ -1556,9 +1556,12 @@ pub impl Parser {\n                         |p| p.parse_token_tree()\n                     );\n                     let (s, z) = p.parse_sep_and_zerok();\n+                    let seq = match seq {\n+                        spanned { node, _ } => node,\n+                    };\n                     tt_seq(\n-                        mk_sp(sp.lo ,p.span.hi),\n-                        seq.node,\n+                        mk_sp(sp.lo, p.span.hi),\n+                        seq,\n                         s,\n                         z\n                     )\n@@ -1624,9 +1627,9 @@ pub impl Parser {\n             token::LBRACE | token::LPAREN | token::LBRACKET => {\n                 self.parse_matcher_subseq(\n                     name_idx,\n-                    *self.token,\n+                    copy *self.token,\n                     // tjc: not sure why we need a copy\n-                    token::flip_delimiter(&*self.token)\n+                    token::flip_delimiter(self.token)\n                 )\n             }\n             _ => self.fatal(~\"expected open delimiter\")\n@@ -1986,22 +1989,23 @@ pub impl Parser {\n         // them as the lambda arguments\n         let e = self.parse_expr_res(RESTRICT_NO_BAR_OR_DOUBLEBAR_OP);\n         match e.node {\n-            expr_call(f, args, NoSugar) => {\n+            expr_call(f, /*bad*/ copy args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi, expr_call(f, args, sugar))\n             }\n-            expr_method_call(f, i, tps, args, NoSugar) => {\n+            expr_method_call(f, i, /*bad*/ copy tps,\n+                             /*bad*/ copy args, NoSugar) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n                 let args = vec::append(args, ~[last_arg]);\n                 self.mk_expr(lo.lo, block.span.hi,\n                              expr_method_call(f, i, tps, args, sugar))\n             }\n-            expr_field(f, i, tps) => {\n+            expr_field(f, i, /*bad*/ copy tps) => {\n                 let block = self.parse_lambda_block_expr();\n                 let last_arg = self.mk_expr(block.span.lo, block.span.hi,\n                                             ctor(block));\n@@ -2259,7 +2263,7 @@ pub impl Parser {\n         let lo = self.span.lo;\n         let mut hi = self.span.hi;\n         let pat;\n-        match *self.token {\n+        match /*bad*/ copy *self.token {\n             // parse _\n           token::UNDERSCORE => { self.bump(); pat = pat_wild; }\n             // parse @pat\n@@ -2373,8 +2377,8 @@ pub impl Parser {\n             self.expect(&token::RBRACKET);\n             pat = ast::pat_vec(before, slice, after);\n           }\n-          tok => {\n-            if !is_ident_or_path(&tok)\n+          ref tok => {\n+            if !is_ident_or_path(tok)\n                 || self.is_keyword(&~\"true\")\n                 || self.is_keyword(&~\"false\")\n             {\n@@ -2897,7 +2901,7 @@ pub impl Parser {\n                 loop;\n             }\n \n-            if is_ident_or_path(&*self.token) {\n+            if is_ident_or_path(self.token) {\n                 self.obsolete(*self.span,\n                               ObsoleteTraitBoundSeparator);\n             }\n@@ -3531,6 +3535,7 @@ pub impl Parser {\n     fn parse_item_mod(&self, outer_attrs: ~[ast::attribute]) -> item_info {\n         let id_span = *self.span;\n         let id = self.parse_ident();\n+        let merge = ::attr::first_attr_value_str_by_name(outer_attrs, \"merge\");\n         let info_ = if *self.token == token::SEMI {\n             self.bump();\n             // This mod is in an external file. Let's go get it!\n@@ -3550,7 +3555,7 @@ pub impl Parser {\n         // (int-template, iter-trait). If there's a 'merge' attribute\n         // on the mod, then we'll go and suck in another file and merge\n         // its contents\n-        match ::attr::first_attr_value_str_by_name(outer_attrs, ~\"merge\") {\n+        match merge {\n             Some(path) => {\n                 let prefix = Path(\n                     self.sess.cm.span_to_filename(*self.span));\n@@ -3636,10 +3641,7 @@ pub impl Parser {\n             new_sub_parser_from_file(self.sess, copy self.cfg,\n                                      &full_path, id_sp);\n         let (inner, next) = p0.parse_inner_attrs_and_next();\n-        let mod_attrs = vec::append(\n-            /*bad*/ copy outer_attrs,\n-            inner\n-        );\n+        let mod_attrs = vec::append(outer_attrs, inner);\n         let first_item_outer_attrs = next;\n         let m0 = p0.parse_mod_items(token::EOF, first_item_outer_attrs);\n         return (ast::item_mod(m0), mod_attrs);\n@@ -4105,7 +4107,8 @@ pub impl Parser {\n         }\n         if self.eat_keyword(&~\"mod\") {\n             // MODULE ITEM\n-            let (ident, item_, extra_attrs) = self.parse_item_mod(attrs);\n+            let (ident, item_, extra_attrs) =\n+                self.parse_item_mod(/*bad*/ copy attrs);\n             return iovi_item(self.mk_item(lo, self.last_span.hi, ident, item_,\n                                           visibility,\n                                           maybe_append(attrs, extra_attrs)));"}, {"sha": "7944469cb963fcc48a25043282eb43d818041d43", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -457,9 +457,9 @@ pub impl Printer {\n             }\n         }\n     }\n-    fn print_str(&mut self, s: ~str) {\n+    fn print_str(&mut self, s: &str) {\n         while self.pending_indentation > 0 {\n-            (*self.out).write_str(~\" \");\n+            (*self.out).write_str(\" \");\n             self.pending_indentation -= 1;\n         }\n         (*self.out).write_str(s);\n@@ -562,16 +562,16 @@ pub fn end(p: @mut Printer) { p.pretty_print(END); }\n \n pub fn eof(p: @mut Printer) { p.pretty_print(EOF); }\n \n-pub fn word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, wrd.len() as int));\n+pub fn word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), wrd.len() as int));\n }\n \n-pub fn huge_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, size_infinity));\n+pub fn huge_word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), size_infinity));\n }\n \n-pub fn zero_word(p: @mut Printer, wrd: ~str) {\n-    p.pretty_print(STRING(@/*bad*/ copy wrd, 0));\n+pub fn zero_word(p: @mut Printer, wrd: &str) {\n+    p.pretty_print(STRING(@/*bad*/ wrd.to_owned(), 0));\n }\n \n pub fn spaces(p: @mut Printer, n: uint) { break_offset(p, n, 0); }"}, {"sha": "1e94c16f87ab254e8589d46404563579dcfdd4e7", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 41, "deletions": 41, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -156,7 +156,7 @@ pub fn lifetime_to_str(e: &ast::Lifetime, intr: @ident_interner) -> ~str {\n }\n \n pub fn tt_to_str(tt: ast::token_tree, intr: @ident_interner) -> ~str {\n-    to_str(tt, print_tt, intr)\n+    to_str(&tt, print_tt, intr)\n }\n \n pub fn tts_to_str(tts: &[ast::token_tree], intr: @ident_interner) -> ~str {\n@@ -213,7 +213,7 @@ pub fn attribute_to_str(attr: ast::attribute, intr: @ident_interner) -> ~str {\n     to_str(attr, print_attribute, intr)\n }\n \n-pub fn variant_to_str(var: ast::variant, intr: @ident_interner) -> ~str {\n+pub fn variant_to_str(var: &ast::variant, intr: @ident_interner) -> ~str {\n     to_str(var, print_variant, intr)\n }\n \n@@ -229,9 +229,9 @@ pub fn box(s: @ps, u: uint, b: pp::breaks) {\n \n pub fn nbsp(s: @ps) { word(s.s, ~\" \"); }\n \n-pub fn word_nbsp(s: @ps, w: ~str) { word(s.s, w); nbsp(s); }\n+pub fn word_nbsp(s: @ps, w: &str) { word(s.s, w); nbsp(s); }\n \n-pub fn word_space(s: @ps, w: ~str) { word(s.s, w); space(s.s); }\n+pub fn word_space(s: @ps, w: &str) { word(s.s, w); space(s.s); }\n \n pub fn popen(s: @ps) { word(s.s, ~\"(\"); }\n \n@@ -346,7 +346,7 @@ pub fn commasep_exprs(s: @ps, b: breaks, exprs: &[@ast::expr]) {\n     commasep_cmnt(s, b, exprs, print_expr, expr_span);\n }\n \n-pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n+pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for _mod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n@@ -355,7 +355,7 @@ pub fn print_mod(s: @ps, _mod: &ast::_mod, attrs: ~[ast::attribute]) {\n }\n \n pub fn print_foreign_mod(s: @ps, nmod: &ast::foreign_mod,\n-                         attrs: ~[ast::attribute]) {\n+                         attrs: &[ast::attribute]) {\n     print_inner_attributes(s, attrs);\n     for nmod.view_items.each |vitem| {\n         print_view_item(s, *vitem);\n@@ -539,7 +539,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n       ast::item_enum(ref enum_definition, ref params) => {\n         print_enum_def(\n             s,\n-            *enum_definition,\n+            enum_definition,\n             params,\n             item.ident,\n             item.span,\n@@ -621,7 +621,7 @@ fn print_trait_ref(s: @ps, t: &ast::trait_ref) {\n     print_path(s, t.path, false);\n }\n \n-pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n+pub fn print_enum_def(s: @ps, enum_definition: &ast::enum_def,\n                       generics: &ast::Generics, ident: ast::ident,\n                       span: codemap::span, visibility: ast::visibility) {\n     head(s, visibility_qualified(visibility, ~\"enum\"));\n@@ -632,15 +632,15 @@ pub fn print_enum_def(s: @ps, enum_definition: ast::enum_def,\n }\n \n pub fn print_variants(s: @ps,\n-                      variants: ~[ast::variant],\n+                      variants: &[ast::variant],\n                       span: codemap::span) {\n     bopen(s);\n     for variants.each |v| {\n         space_if_not_bol(s);\n         maybe_print_comment(s, v.span.lo);\n         print_outer_attributes(s, v.node.attrs);\n         ibox(s, indent_unit);\n-        print_variant(s, *v);\n+        print_variant(s, v);\n         word(s.s, ~\",\");\n         end(s);\n         maybe_print_trailing_comment(s, v.span, None);\n@@ -727,15 +727,15 @@ pub fn print_struct(s: @ps,\n /// appropriate macro, transcribe back into the grammar we just parsed from,\n /// and then pretty-print the resulting AST nodes (so, e.g., we print\n /// expression arguments as expressions). It can be done! I think.\n-pub fn print_tt(s: @ps, tt: ast::token_tree) {\n-    match tt {\n+pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n+    match *tt {\n       ast::tt_delim(ref tts) => print_tts(s, *tts),\n       ast::tt_tok(_, ref tk) => {\n           word(s.s, parse::token::to_str(s.intr, tk));\n       }\n       ast::tt_seq(_, ref tts, ref sep, zerok) => {\n         word(s.s, ~\"$(\");\n-        for (*tts).each() |tt_elt| { print_tt(s, *tt_elt); }\n+        for (*tts).each() |tt_elt| { print_tt(s, tt_elt); }\n         word(s.s, ~\")\");\n         match (*sep) {\n           Some(ref tk) => word(s.s, parse::token::to_str(s.intr, tk)),\n@@ -756,12 +756,12 @@ pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n         if i != 0 {\n             space(s.s);\n         }\n-        print_tt(s, *tt);\n+        print_tt(s, tt);\n     }\n     end(s);\n }\n \n-pub fn print_variant(s: @ps, v: ast::variant) {\n+pub fn print_variant(s: @ps, v: &ast::variant) {\n     print_visibility(s, v.node.vis);\n     match v.node.kind {\n         ast::tuple_variant_kind(ref args) => {\n@@ -819,7 +819,7 @@ pub fn print_method(s: @ps, meth: @ast::method) {\n     print_block_with_attrs(s, &meth.body, meth.attrs);\n }\n \n-pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n+pub fn print_outer_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -830,7 +830,7 @@ pub fn print_outer_attributes(s: @ps, attrs: ~[ast::attribute]) {\n     if count > 0 { hardbreak_if_not_bol(s); }\n }\n \n-pub fn print_inner_attributes(s: @ps, attrs: ~[ast::attribute]) {\n+pub fn print_inner_attributes(s: @ps, attrs: &[ast::attribute]) {\n     let mut count = 0;\n     for attrs.each |attr| {\n         match attr.node.style {\n@@ -879,7 +879,7 @@ pub fn print_stmt(s: @ps, st: &ast::stmt) {\n       }\n       ast::stmt_mac(ref mac, semi) => {\n         space_if_not_bol(s);\n-        print_mac(s, (*mac));\n+        print_mac(s, mac);\n         if semi { word(s.s, ~\";\"); }\n       }\n     }\n@@ -892,18 +892,18 @@ pub fn print_block(s: @ps, blk: &ast::blk) {\n }\n \n pub fn print_block_unclosed(s: @ps, blk: &ast::blk) {\n-    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, ~[],\n+    print_possibly_embedded_block_(s, blk, block_normal, indent_unit, &[],\n                                  false);\n }\n \n pub fn print_block_unclosed_indent(s: @ps, blk: &ast::blk, indented: uint) {\n-    print_possibly_embedded_block_(s, blk, block_normal, indented, ~[],\n+    print_possibly_embedded_block_(s, blk, block_normal, indented, &[],\n                                    false);\n }\n \n pub fn print_block_with_attrs(s: @ps,\n                               blk: &ast::blk,\n-                              attrs: ~[ast::attribute]) {\n+                              attrs: &[ast::attribute]) {\n     print_possibly_embedded_block_(s, blk, block_normal, indent_unit, attrs,\n                                   true);\n }\n@@ -915,14 +915,14 @@ pub fn print_possibly_embedded_block(s: @ps,\n                                      embedded: embed_type,\n                                      indented: uint) {\n     print_possibly_embedded_block_(\n-        s, blk, embedded, indented, ~[], true);\n+        s, blk, embedded, indented, &[], true);\n }\n \n pub fn print_possibly_embedded_block_(s: @ps,\n                                       blk: &ast::blk,\n                                       embedded: embed_type,\n                                       indented: uint,\n-                                      attrs: ~[ast::attribute],\n+                                      attrs: &[ast::attribute],\n                                       close_box: bool) {\n     match blk.node.rules {\n       ast::unsafe_blk => word_space(s, ~\"unsafe\"),\n@@ -994,7 +994,7 @@ pub fn print_if(s: @ps, test: @ast::expr, blk: &ast::blk,\n     do_else(s, elseopt);\n }\n \n-pub fn print_mac(s: @ps, m: ast::mac) {\n+pub fn print_mac(s: @ps, m: &ast::mac) {\n     match m.node {\n       ast::mac_invoc_tt(pth, ref tts) => {\n         print_path(s, pth, false);\n@@ -1387,7 +1387,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_expr(s, expr);\n         pclose(s);\n       }\n-      ast::expr_inline_asm(a) => {\n+      ast::expr_inline_asm(ref a) => {\n         if a.volatile {\n             word(s.s, ~\"__volatile__ asm!\");\n         } else {\n@@ -1415,7 +1415,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         print_string(s, *a.clobbers);\n         pclose(s);\n       }\n-      ast::expr_mac(ref m) => print_mac(s, (*m)),\n+      ast::expr_mac(ref m) => print_mac(s, m),\n       ast::expr_paren(e) => {\n           popen(s);\n           print_expr(s, e);\n@@ -1559,7 +1559,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n           }\n         }\n       }\n-      ast::pat_struct(path, fields, etc) => {\n+      ast::pat_struct(path, ref fields, etc) => {\n         print_path(s, path, true);\n         word(s.s, ~\"{\");\n         fn print_field(s: @ps, f: ast::field_pat, refutable: bool) {\n@@ -1570,18 +1570,18 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             end(s);\n         }\n         fn get_span(f: ast::field_pat) -> codemap::span { return f.pat.span; }\n-        commasep_cmnt(s, consistent, fields,\n+        commasep_cmnt(s, consistent, *fields,\n                       |s, f| print_field(s,f,refutable),\n                       get_span);\n         if etc {\n-            if vec::len(fields) != 0u { word_space(s, ~\",\"); }\n+            if fields.len() != 0u { word_space(s, ~\",\"); }\n             word(s.s, ~\"_\");\n         }\n         word(s.s, ~\"}\");\n       }\n-      ast::pat_tup(elts) => {\n+      ast::pat_tup(ref elts) => {\n         popen(s);\n-        commasep(s, inconsistent, elts, |s, p| print_pat(s, p, refutable));\n+        commasep(s, inconsistent, *elts, |s, p| print_pat(s, p, refutable));\n         if elts.len() == 1 {\n             word(s.s, ~\",\");\n         }\n@@ -1606,9 +1606,9 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n         word(s.s, ~\"..\");\n         print_expr(s, end);\n       }\n-      ast::pat_vec(before, slice, after) => {\n+      ast::pat_vec(ref before, slice, ref after) => {\n         word(s.s, ~\"[\");\n-        do commasep(s, inconsistent, before) |s, p| {\n+        do commasep(s, inconsistent, *before) |s, p| {\n             print_pat(s, p, refutable);\n         }\n         for slice.each |&p| {\n@@ -1617,7 +1617,7 @@ pub fn print_pat(s: @ps, pat: @ast::pat, refutable: bool) {\n             print_pat(s, p, refutable);\n             if !after.is_empty() { word_space(s, ~\",\"); }\n         }\n-        do commasep(s, inconsistent, after) |s, p| {\n+        do commasep(s, inconsistent, *after) |s, p| {\n             print_pat(s, p, refutable);\n         }\n         word(s.s, ~\"]\");\n@@ -1832,12 +1832,12 @@ pub fn print_view_item(s: @ps, item: @ast::view_item) {\n     print_outer_attributes(s, item.attrs);\n     print_visibility(s, item.vis);\n     match item.node {\n-        ast::view_item_extern_mod(id, mta, _) => {\n+        ast::view_item_extern_mod(id, ref mta, _) => {\n             head(s, ~\"extern mod\");\n             print_ident(s, id);\n             if !mta.is_empty() {\n                 popen(s);\n-                commasep(s, consistent, mta, print_meta_item);\n+                commasep(s, consistent, *mta, print_meta_item);\n                 pclose(s);\n             }\n         }\n@@ -1960,7 +1960,7 @@ pub fn maybe_print_trailing_comment(s: @ps, span: codemap::span,\n         match next_pos { None => (), Some(p) => next = p }\n         if span.hi < (*cmnt).pos && (*cmnt).pos < next &&\n                span_line.line == comment_line.line {\n-            print_comment(s, (*cmnt));\n+            print_comment(s, cmnt);\n             s.cur_cmnt_and_lit.cur_cmnt += 1u;\n         }\n       }\n@@ -1975,7 +1975,7 @@ pub fn print_remaining_comments(s: @ps) {\n     loop {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n-            print_comment(s, (*cmnt));\n+            print_comment(s, cmnt);\n             s.cur_cmnt_and_lit.cur_cmnt += 1u;\n           }\n           _ => break\n@@ -2055,7 +2055,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n         match next_comment(s) {\n           Some(ref cmnt) => {\n             if (*cmnt).pos < pos {\n-                print_comment(s, (*cmnt));\n+                print_comment(s, cmnt);\n                 s.cur_cmnt_and_lit.cur_cmnt += 1u;\n             } else { break; }\n           }\n@@ -2064,7 +2064,7 @@ pub fn maybe_print_comment(s: @ps, pos: BytePos) {\n     }\n }\n \n-pub fn print_comment(s: @ps, cmnt: comments::cmnt) {\n+pub fn print_comment(s: @ps, cmnt: &comments::cmnt) {\n     match cmnt.style {\n       comments::mixed => {\n         assert!((vec::len(cmnt.lines) == 1u));\n@@ -2274,7 +2274,7 @@ mod test {\n             vis: ast::public,\n         });\n \n-        let varstr = variant_to_str(var,mock_interner);\n+        let varstr = variant_to_str(&var,mock_interner);\n         assert_eq!(&varstr,&~\"pub principal_skinner\");\n     }\n }"}, {"sha": "8deca72779e5159adb57791e071fdfd66a411492", "filename": "src/libsyntax/syntax.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fsyntax.rc", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fsyntax.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fsyntax.rc?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -20,7 +20,6 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n #[deny(deprecated_pattern)];\n "}, {"sha": "4cfd54256f82e043efc72e9c394271f92e20c146", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=92d39fe4d5e5ad3d2c2dcafe45eaf6e23edddfd7", "patch": "@@ -179,7 +179,7 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n         item_enum(ref enum_definition, ref tps) => {\n             (v.visit_generics)(tps, e, v);\n             visit_enum_def(\n-                *enum_definition,\n+                enum_definition,\n                 tps,\n                 e,\n                 v\n@@ -206,11 +206,11 @@ pub fn visit_item<E: Copy>(i: @item, e: E, v: vt<E>) {\n                 (v.visit_trait_method)(m, e, v);\n             }\n         }\n-        item_mac(ref m) => visit_mac((*m), e, v)\n+        item_mac(ref m) => visit_mac(m, e, v)\n     }\n }\n \n-pub fn visit_enum_def<E: Copy>(enum_definition: ast::enum_def,\n+pub fn visit_enum_def<E: Copy>(enum_definition: &ast::enum_def,\n                                tps: &Generics,\n                                e: E,\n                                v: vt<E>) {\n@@ -422,7 +422,7 @@ pub fn visit_stmt<E>(s: @stmt, e: E, v: vt<E>) {\n       stmt_decl(d, _) => (v.visit_decl)(d, e, v),\n       stmt_expr(ex, _) => (v.visit_expr)(ex, e, v),\n       stmt_semi(ex, _) => (v.visit_expr)(ex, e, v),\n-      stmt_mac(ref mac, _) => visit_mac((*mac), e, v)\n+      stmt_mac(ref mac, _) => visit_mac(mac, e, v)\n     }\n }\n \n@@ -445,7 +445,7 @@ pub fn visit_exprs<E: Copy>(exprs: &[@expr], e: E, v: vt<E>) {\n     for exprs.each |ex| { (v.visit_expr)(*ex, e, v); }\n }\n \n-pub fn visit_mac<E>(_m: mac, _e: E, _v: vt<E>) {\n+pub fn visit_mac<E>(_m: &mac, _e: E, _v: vt<E>) {\n     /* no user-serviceable parts inside */\n }\n \n@@ -537,7 +537,7 @@ pub fn visit_expr<E: Copy>(ex: @expr, e: E, v: vt<E>) {\n             (v.visit_expr)(lv, e, v);\n             (v.visit_expr)(x, e, v);\n         }\n-        expr_mac(ref mac) => visit_mac((*mac), e, v),\n+        expr_mac(ref mac) => visit_mac(mac, e, v),\n         expr_paren(x) => (v.visit_expr)(x, e, v),\n         expr_inline_asm(ref a) => {\n             for a.inputs.each |&(_, in)| {"}]}