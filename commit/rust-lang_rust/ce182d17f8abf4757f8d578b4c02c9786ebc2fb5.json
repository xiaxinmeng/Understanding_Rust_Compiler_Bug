{"sha": "ce182d17f8abf4757f8d578b4c02c9786ebc2fb5", "node_id": "C_kwDOAAsO6NoAKGNlMTgyZDE3ZjhhYmY0NzU3ZjhkNTc4YjRjMDJjOTc4NmViYzJmYjU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-11-20T04:51:19Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2021-11-23T18:34:16Z"}, "message": "Elaborate trait generics and associated types", "tree": {"sha": "4bfdd45248b491f896fce1c557b58bc0c16a45d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4bfdd45248b491f896fce1c557b58bc0c16a45d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5", "html_url": "https://github.com/rust-lang/rust/commit/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c969b1dea0f523d604a7a6bd7eeb698bc5be3696", "url": "https://api.github.com/repos/rust-lang/rust/commits/c969b1dea0f523d604a7a6bd7eeb698bc5be3696", "html_url": "https://github.com/rust-lang/rust/commit/c969b1dea0f523d604a7a6bd7eeb698bc5be3696"}], "stats": {"total": 284, "additions": 210, "deletions": 74}, "files": [{"sha": "5a8fc943f9a6c9e54aa18ca8b37a18f3660e49b1", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 210, "deletions": 74, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce182d17f8abf4757f8d578b4c02c9786ebc2fb5/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=ce182d17f8abf4757f8d578b4c02c9786ebc2fb5", "patch": "@@ -643,81 +643,8 @@ pub trait PrettyPrinter<'tcx>:\n                         }\n                         return Ok(self);\n                     }\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let bounds = self.tcx().explicit_item_bounds(def_id);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    let mut is_future = false;\n-                    let mut future_output_ty = None;\n-\n-                    p!(\"impl\");\n-                    for (predicate, _) in bounds {\n-                        let predicate = predicate.subst(self.tcx(), substs);\n-                        let bound_predicate = predicate.kind();\n-\n-                        match bound_predicate.skip_binder() {\n-                            ty::PredicateKind::Projection(projection_predicate) => {\n-                                let Some(future_trait) = self.tcx().lang_items().future_trait() else { continue };\n-                                let future_output_def_id =\n-                                    self.tcx().associated_item_def_ids(future_trait)[0];\n-\n-                                if projection_predicate.projection_ty.item_def_id\n-                                    == future_output_def_id\n-                                {\n-                                    // We don't account for multiple `Future::Output = Ty` contraints.\n-                                    is_future = true;\n-                                    future_output_ty = Some(projection_predicate.ty);\n-                                }\n-                            }\n-                            ty::PredicateKind::Trait(pred) => {\n-                                let trait_ref = bound_predicate.rebind(pred.trait_ref);\n-                                // Don't print +Sized, but rather +?Sized if absent.\n-                                if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait()\n-                                {\n-                                    is_sized = true;\n-                                    continue;\n-                                }\n-\n-                                if Some(trait_ref.def_id())\n-                                    == self.tcx().lang_items().future_trait()\n-                                {\n-                                    is_future = true;\n-                                    continue;\n-                                }\n-\n-                                p!(\n-                                    write(\"{}\", if first { \" \" } else { \" + \" }),\n-                                    print(trait_ref.print_only_trait_path())\n-                                );\n-\n-                                first = false;\n-                            }\n-                            _ => {}\n-                        }\n-                    }\n \n-                    if is_future {\n-                        p!(write(\"{}Future\", if first { \" \" } else { \" + \" }));\n-                        first = false;\n-\n-                        if let Some(future_output_ty) = future_output_ty {\n-                            // Don't print projection types, which we (unfortunately) see often\n-                            // in the error outputs involving async blocks.\n-                            if !matches!(future_output_ty.kind(), ty::Projection(_)) {\n-                                p!(\"<Output = \", print(future_output_ty), \">\");\n-                            }\n-                        }\n-                    }\n-\n-                    if !is_sized {\n-                        p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n-                    } else if first {\n-                        p!(\" Sized\");\n-                    }\n-\n-                    Ok(self)\n+                    self.pretty_print_opaque_impl_type(def_id, substs)\n                 });\n             }\n             ty::Str => p!(\"str\"),\n@@ -826,6 +753,208 @@ pub trait PrettyPrinter<'tcx>:\n         Ok(self)\n     }\n \n+    fn pretty_print_opaque_impl_type(\n+        mut self,\n+        def_id: DefId,\n+        substs: &'tcx ty::List<ty::GenericArg<'tcx>>,\n+    ) -> Result<Self::Type, Self::Error> {\n+        define_scoped_cx!(self);\n+\n+        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+        // by looking up the projections associated with the def_id.\n+        let bounds = self.tcx().explicit_item_bounds(def_id);\n+\n+        let mut traits = BTreeMap::new();\n+        let mut fn_traits = BTreeMap::new();\n+        let mut is_sized = false;\n+\n+        for (predicate, _) in bounds {\n+            let predicate = predicate.subst(self.tcx(), substs);\n+            let bound_predicate = predicate.kind();\n+\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Trait(pred) => {\n+                    let trait_ref = bound_predicate.rebind(pred.trait_ref);\n+\n+                    // Don't print + Sized, but rather + ?Sized if absent.\n+                    if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                        is_sized = true;\n+                        continue;\n+                    }\n+\n+                    self.insert_trait_and_projection(trait_ref, None, &mut traits, &mut fn_traits);\n+                }\n+                ty::PredicateKind::Projection(pred) => {\n+                    let proj_ref = bound_predicate.rebind(pred);\n+                    let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n+\n+                    // Projection type entry -- the def-id for naming, and the ty.\n+                    let proj_ty = (proj_ref.projection_def_id(), proj_ref.ty());\n+\n+                    self.insert_trait_and_projection(\n+                        trait_ref,\n+                        Some(proj_ty),\n+                        &mut traits,\n+                        &mut fn_traits,\n+                    );\n+                }\n+                _ => {}\n+            }\n+        }\n+\n+        let mut first = true;\n+        // Insert parenthesis around (Fn(A, B) -> C) if the opaque ty has more than one other trait\n+        let paren_needed = fn_traits.len() > 1 || traits.len() > 0 || !is_sized;\n+\n+        p!(\"impl\");\n+\n+        for (fn_once_trait_ref, entry) in fn_traits {\n+            // Get the (single) generic ty (the args) of this FnOnce trait ref.\n+            let generics = self.generic_args_to_print(\n+                self.tcx().generics_of(fn_once_trait_ref.def_id()),\n+                fn_once_trait_ref.skip_binder().substs,\n+            );\n+\n+            match (entry.return_ty, generics[0].expect_ty()) {\n+                // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n+                // a return type.\n+                (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n+                    let name = if entry.fn_trait_ref.is_some() {\n+                        \"Fn\"\n+                    } else if entry.fn_mut_trait_ref.is_some() {\n+                        \"FnMut\"\n+                    } else {\n+                        \"FnOnce\"\n+                    };\n+\n+                    p!(\n+                        write(\"{}\", if first { \" \" } else { \" + \" }),\n+                        write(\"{}{}(\", if paren_needed { \"(\" } else { \"\" }, name)\n+                    );\n+\n+                    for (idx, ty) in arg_tys.tuple_fields().enumerate() {\n+                        if idx > 0 {\n+                            p!(\", \");\n+                        }\n+                        p!(print(ty));\n+                    }\n+\n+                    p!(\") -> \", print(return_ty), write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n+\n+                    first = false;\n+                }\n+                // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n+                // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n+                _ => {\n+                    traits.entry(fn_once_trait_ref).or_default().extend(\n+                        // Group the return ty with its def id, if we had one.\n+                        entry\n+                            .return_ty\n+                            .map(|ty| (self.tcx().lang_items().fn_once_output().unwrap(), ty)),\n+                    );\n+                    if let Some(trait_ref) = entry.fn_mut_trait_ref {\n+                        traits.entry(trait_ref).or_default();\n+                    }\n+                    if let Some(trait_ref) = entry.fn_trait_ref {\n+                        traits.entry(trait_ref).or_default();\n+                    }\n+                }\n+            }\n+        }\n+\n+        // Print the rest of the trait types (that aren't Fn* family of traits)\n+        for (trait_ref, assoc_items) in traits {\n+            p!(\n+                write(\"{}\", if first { \" \" } else { \" + \" }),\n+                print(trait_ref.skip_binder().print_only_trait_name())\n+            );\n+\n+            let generics = self.generic_args_to_print(\n+                self.tcx().generics_of(trait_ref.def_id()),\n+                trait_ref.skip_binder().substs,\n+            );\n+\n+            if !generics.is_empty() || !assoc_items.is_empty() {\n+                p!(\"<\");\n+                let mut first = true;\n+\n+                for ty in generics {\n+                    if !first {\n+                        p!(\", \");\n+                    }\n+                    p!(print(trait_ref.rebind(*ty)));\n+                    first = false;\n+                }\n+\n+                for (assoc_item_def_id, ty) in assoc_items {\n+                    if !first {\n+                        p!(\", \");\n+                    }\n+                    p!(\n+                        write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).ident),\n+                        print(ty)\n+                    );\n+                    first = false;\n+                }\n+\n+                p!(\">\");\n+            }\n+\n+            first = false;\n+        }\n+\n+        if !is_sized {\n+            p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n+        } else if first {\n+            p!(\" Sized\");\n+        }\n+\n+        Ok(self)\n+    }\n+\n+    /// Insert the trait ref and optionally a projection type associated with it into either the\n+    /// traits map or fn_traits map, depending on if the trait is in the Fn* family of traits.\n+    fn insert_trait_and_projection(\n+        &mut self,\n+        trait_ref: ty::PolyTraitRef<'tcx>,\n+        proj_ty: Option<(DefId, ty::Binder<'tcx, Ty<'tcx>>)>,\n+        traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, BTreeMap<DefId, ty::Binder<'tcx, Ty<'tcx>>>>,\n+        fn_traits: &mut BTreeMap<ty::PolyTraitRef<'tcx>, OpaqueFnEntry<'tcx>>,\n+    ) {\n+        let trait_def_id = trait_ref.def_id();\n+\n+        // If our trait_ref is FnOnce or any of its children, project it onto the parent FnOnce\n+        // super-trait ref and record it there.\n+        if let Some(fn_once_trait) = self.tcx().lang_items().fn_once_trait() {\n+            // If we have a FnOnce, then insert it into\n+            if trait_def_id == fn_once_trait {\n+                let entry = fn_traits.entry(trait_ref).or_default();\n+                // Optionally insert the return_ty as well.\n+                if let Some((_, ty)) = proj_ty {\n+                    entry.return_ty = Some(ty);\n+                }\n+                return;\n+            } else if Some(trait_def_id) == self.tcx().lang_items().fn_mut_trait() {\n+                let super_trait_ref = crate::traits::util::supertraits(self.tcx(), trait_ref)\n+                    .find(|super_trait_ref| super_trait_ref.def_id() == fn_once_trait)\n+                    .unwrap();\n+\n+                fn_traits.entry(super_trait_ref).or_default().fn_mut_trait_ref = Some(trait_ref);\n+                return;\n+            } else if Some(trait_def_id) == self.tcx().lang_items().fn_trait() {\n+                let super_trait_ref = crate::traits::util::supertraits(self.tcx(), trait_ref)\n+                    .find(|super_trait_ref| super_trait_ref.def_id() == fn_once_trait)\n+                    .unwrap();\n+\n+                fn_traits.entry(super_trait_ref).or_default().fn_trait_ref = Some(trait_ref);\n+                return;\n+            }\n+        }\n+\n+        // Otherwise, just group our traits and projection types.\n+        traits.entry(trait_ref).or_default().extend(proj_ty);\n+    }\n+\n     fn pretty_print_bound_var(\n         &mut self,\n         debruijn: ty::DebruijnIndex,\n@@ -2553,3 +2682,10 @@ fn trimmed_def_paths(tcx: TyCtxt<'_>, (): ()) -> FxHashMap<DefId, Symbol> {\n pub fn provide(providers: &mut ty::query::Providers) {\n     *providers = ty::query::Providers { trimmed_def_paths, ..*providers };\n }\n+\n+#[derive(Default)]\n+pub struct OpaqueFnEntry<'tcx> {\n+    fn_mut_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n+    fn_trait_ref: Option<ty::PolyTraitRef<'tcx>>,\n+    return_ty: Option<ty::Binder<'tcx, Ty<'tcx>>>,\n+}"}]}