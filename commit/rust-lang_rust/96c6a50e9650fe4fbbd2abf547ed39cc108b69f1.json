{"sha": "96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "node_id": "C_kwDOAAsO6NoAKDk2YzZhNTBlOTY1MGZlNGZiYmQyYWJmNTQ3ZWQzOWNjMTA4YjY5ZjE", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2021-12-18T12:07:58Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-01-09T01:22:04Z"}, "message": "rustc_metadata: Optimize and document module children decoding", "tree": {"sha": "3b5a74ad2162b79caff01b243fb8026a35b883ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b5a74ad2162b79caff01b243fb8026a35b883ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "html_url": "https://github.com/rust-lang/rust/commit/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23ce5fc4655ed546f74a85fc8836e95bec0c64fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/23ce5fc4655ed546f74a85fc8836e95bec0c64fd", "html_url": "https://github.com/rust-lang/rust/commit/23ce5fc4655ed546f74a85fc8836e95bec0c64fd"}], "stats": {"total": 88, "additions": 50, "deletions": 38}, "files": [{"sha": "dd025eeac9e609f5021692b1f3f36f49d32dda3b", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "patch": "@@ -1075,15 +1075,16 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    /// Iterates over each child of the given item.\n+    /// Iterates over all named children of the given module,\n+    /// including both proper items and reexports.\n+    /// Module here is understood in name resolution sense - it can be a `mod` item,\n+    /// or a crate root, or an enum, or a trait.\n     fn each_child_of_item(&self, id: DefIndex, mut callback: impl FnMut(Export), sess: &Session) {\n         if let Some(data) = &self.root.proc_macro_data {\n-            /* If we are loading as a proc macro, we want to return the view of this crate\n-             * as a proc macro crate.\n-             */\n+            // If we are loading as a proc macro, we want to return\n+            // the view of this crate as a proc macro crate.\n             if id == CRATE_DEF_INDEX {\n-                let macros = data.macros.decode(self);\n-                for def_index in macros {\n+                for def_index in data.macros.decode(self) {\n                     let raw_macro = self.raw_proc_macro(def_index);\n                     let res = Res::Def(\n                         DefKind::Macro(macro_kind(raw_macro)),\n@@ -1096,12 +1097,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             return;\n         }\n \n-        // Find the item.\n-        let kind = match self.maybe_kind(id) {\n-            None => return,\n-            Some(kind) => kind,\n-        };\n-\n         // Iterate over all children.\n         if let Some(children) = self.root.tables.children.get(self, id) {\n             for child_index in children.decode((self, sess)) {\n@@ -1162,10 +1157,14 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         }\n \n-        if let EntryKind::Mod(exports) = kind {\n-            for exp in exports.decode((self, sess)) {\n-                callback(exp);\n+        match self.kind(id) {\n+            EntryKind::Mod(exports) => {\n+                for exp in exports.decode((self, sess)) {\n+                    callback(exp);\n+                }\n             }\n+            EntryKind::Enum(..) | EntryKind::Trait(..) => {}\n+            _ => bug!(\"`each_child_of_item` is called on a non-module: {:?}\", self.def_kind(id)),\n         }\n     }\n "}, {"sha": "ba0e76d2f5ec914fb25800a22a3cab11ddc1a281", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "patch": "@@ -4,7 +4,7 @@ use crate::native_libs;\n \n use rustc_ast as ast;\n use rustc_data_structures::stable_map::FxHashMap;\n-use rustc_hir::def::{CtorKind, DefKind};\n+use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n use rustc_middle::hir::exports::Export;\n@@ -309,28 +309,33 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 bfs_queue.push_back(DefId { krate: cnum, index: CRATE_DEF_INDEX });\n             }\n \n-            let mut add_child = |bfs_queue: &mut VecDeque<_>, export: &Export, parent: DefId| {\n-                if !export.vis.is_public() {\n+            let mut add_child = |bfs_queue: &mut VecDeque<_>, child: &Export, parent: DefId| {\n+                if !child.vis.is_public() {\n                     return;\n                 }\n \n-                if let Some(child) = export.res.opt_def_id() {\n-                    if export.ident.name == kw::Underscore {\n-                        fallback_map.insert(child, parent);\n+                if let Some(def_id) = child.res.opt_def_id() {\n+                    if child.ident.name == kw::Underscore {\n+                        fallback_map.insert(def_id, parent);\n                         return;\n                     }\n \n-                    match visible_parent_map.entry(child) {\n+                    match visible_parent_map.entry(def_id) {\n                         Entry::Occupied(mut entry) => {\n                             // If `child` is defined in crate `cnum`, ensure\n                             // that it is mapped to a parent in `cnum`.\n-                            if child.is_local() && entry.get().is_local() {\n+                            if def_id.is_local() && entry.get().is_local() {\n                                 entry.insert(parent);\n                             }\n                         }\n                         Entry::Vacant(entry) => {\n                             entry.insert(parent);\n-                            bfs_queue.push_back(child);\n+                            if matches!(\n+                                child.res,\n+                                Res::Def(DefKind::Mod | DefKind::Enum | DefKind::Trait, _)\n+                            ) {\n+                                bfs_queue.push_back(def_id);\n+                            }\n                         }\n                     }\n                 }"}, {"sha": "47fb254da9ab5b8fd3a1c28a52d049011ff7cf39", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "patch": "@@ -1104,7 +1104,6 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         record!(self.tables.kind[def_id] <- EntryKind::Mod(reexports));\n         if self.is_proc_macro {\n-            record!(self.tables.children[def_id] <- &[]);\n             // Encode this here because we don't do it in encode_def_ids.\n             record!(self.tables.expn_that_defined[def_id] <- tcx.expn_that_defined(local_def_id));\n         } else {"}, {"sha": "f7a2cc126ce519192b5291a3de59522296f93811", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "patch": "@@ -2615,7 +2615,9 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n                         collect_fn(&child.ident, ns, def_id);\n                     }\n \n-                    if seen_defs.insert(def_id) {\n+                    if matches!(defkind, DefKind::Mod | DefKind::Enum | DefKind::Trait)\n+                        && seen_defs.insert(def_id)\n+                    {\n                         queue.push(def_id);\n                     }\n                 }"}, {"sha": "bd6851d1fbba24917ba5fcf60c2694b306ff6dda", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96c6a50e9650fe4fbbd2abf547ed39cc108b69f1/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=96c6a50e9650fe4fbbd2abf547ed39cc108b69f1", "patch": "@@ -82,7 +82,6 @@ use rustc_hir::{\n     TraitItemKind, TraitRef, TyKind, UnOp, ArrayLen\n };\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n-use rustc_middle::hir::exports::Export;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::place::PlaceBase;\n use rustc_middle::ty as rustc_ty;\n@@ -523,10 +522,21 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n             }\n         };\n     }\n-    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<&'tcx Export> {\n-        tcx.item_children(def_id)\n-            .iter()\n-            .find(|item| item.ident.name.as_str() == name)\n+    fn item_child_by_name<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, name: &str) -> Option<Res> {\n+        match tcx.def_kind(def_id) {\n+            DefKind::Mod | DefKind::Enum | DefKind::Trait => tcx\n+                .item_children(def_id)\n+                .iter()\n+                .find(|item| item.ident.name.as_str() == name)\n+                .map(|child| child.res.expect_non_local()),\n+            DefKind::Impl => tcx\n+                .associated_item_def_ids(def_id)\n+                .iter()\n+                .copied()\n+                .find(|assoc_def_id| tcx.item_name(*assoc_def_id).as_str() == name)\n+                .map(|assoc_def_id| Res::Def(tcx.def_kind(assoc_def_id), assoc_def_id)),\n+            _ => None,\n+        }\n     }\n \n     let (krate, first, path) = match *path {\n@@ -543,15 +553,12 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n     let last = path\n         .iter()\n         .copied()\n-        // `get_def_path` seems to generate these empty segments for extern blocks.\n-        // We can just ignore them.\n-        .filter(|segment| !segment.is_empty())\n         // for each segment, find the child item\n-        .try_fold(first, |item, segment| {\n-            let def_id = item.res.def_id();\n+        .try_fold(first, |res, segment| {\n+            let def_id = res.def_id();\n             if let Some(item) = item_child_by_name(tcx, def_id, segment) {\n                 Some(item)\n-            } else if matches!(item.res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n+            } else if matches!(res, Res::Def(DefKind::Enum | DefKind::Struct, _)) {\n                 // it is not a child item so check inherent impl items\n                 tcx.inherent_impls(def_id)\n                     .iter()\n@@ -560,7 +567,7 @@ pub fn path_to_res(cx: &LateContext<'_>, path: &[&str]) -> Res {\n                 None\n             }\n         });\n-    try_res!(last).res.expect_non_local()\n+    try_res!(last).expect_non_local()\n }\n \n /// Convenience function to get the `DefId` of a trait by path."}]}