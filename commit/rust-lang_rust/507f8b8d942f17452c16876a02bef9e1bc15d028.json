{"sha": "507f8b8d942f17452c16876a02bef9e1bc15d028", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwN2Y4YjhkOTQyZjE3NDUyYzE2ODc2YTAyYmVmOWUxYmMxNWQwMjg=", "commit": {"author": {"name": "Kelvin Ly", "email": "kelvin.ly1618@gmail.com", "date": "2015-05-15T00:45:18Z"}, "committer": {"name": "Kelvin Ly", "email": "kelvin.ly1618@gmail.com", "date": "2015-05-15T00:45:18Z"}, "message": "Fix merge conflict and also add markdown formatting", "tree": {"sha": "ec1924346cc4537d10a5b55eaca4f1620436f87e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec1924346cc4537d10a5b55eaca4f1620436f87e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/507f8b8d942f17452c16876a02bef9e1bc15d028", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/507f8b8d942f17452c16876a02bef9e1bc15d028", "html_url": "https://github.com/rust-lang/rust/commit/507f8b8d942f17452c16876a02bef9e1bc15d028", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/507f8b8d942f17452c16876a02bef9e1bc15d028/comments", "author": {"login": "cactorium", "id": 1513183, "node_id": "MDQ6VXNlcjE1MTMxODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1513183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cactorium", "html_url": "https://github.com/cactorium", "followers_url": "https://api.github.com/users/cactorium/followers", "following_url": "https://api.github.com/users/cactorium/following{/other_user}", "gists_url": "https://api.github.com/users/cactorium/gists{/gist_id}", "starred_url": "https://api.github.com/users/cactorium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cactorium/subscriptions", "organizations_url": "https://api.github.com/users/cactorium/orgs", "repos_url": "https://api.github.com/users/cactorium/repos", "events_url": "https://api.github.com/users/cactorium/events{/privacy}", "received_events_url": "https://api.github.com/users/cactorium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cactorium", "id": 1513183, "node_id": "MDQ6VXNlcjE1MTMxODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1513183?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cactorium", "html_url": "https://github.com/cactorium", "followers_url": "https://api.github.com/users/cactorium/followers", "following_url": "https://api.github.com/users/cactorium/following{/other_user}", "gists_url": "https://api.github.com/users/cactorium/gists{/gist_id}", "starred_url": "https://api.github.com/users/cactorium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cactorium/subscriptions", "organizations_url": "https://api.github.com/users/cactorium/orgs", "repos_url": "https://api.github.com/users/cactorium/repos", "events_url": "https://api.github.com/users/cactorium/events{/privacy}", "received_events_url": "https://api.github.com/users/cactorium/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9e76ae5fe6a3104c265b43dcb5705b5ccd2743", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9e76ae5fe6a3104c265b43dcb5705b5ccd2743", "html_url": "https://github.com/rust-lang/rust/commit/6e9e76ae5fe6a3104c265b43dcb5705b5ccd2743"}, {"sha": "571f371b3fce3e023fb1b41a1682de260c943222", "url": "https://api.github.com/repos/rust-lang/rust/commits/571f371b3fce3e023fb1b41a1682de260c943222", "html_url": "https://github.com/rust-lang/rust/commit/571f371b3fce3e023fb1b41a1682de260c943222"}], "stats": {"total": 2207, "additions": 1293, "deletions": 914}, "files": [{"sha": "4e763f7613977df5b5036b0d8406493d4e7ce93d", "filename": "configure", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/configure", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -106,8 +106,8 @@ probe() {\n         T=$(command -v $P 2>&1)\n         if [ $? -eq 0 ]\n         then\n-            VER0=$($P --version 2>/dev/null | head -1 \\\n-                |  sed -e 's/[^0-9]*\\([vV]\\?[0-9.]\\+[^ ]*\\).*/\\1/' )\n+            VER0=$($P --version 2>/dev/null \\\n+                |  grep -o '[vV]\\?[0-9][0-9.][a-z0-9.-]*' | head -1 )\n             if [ $? -eq 0 -a \"x${VER0}\" != \"x\" ]\n             then\n               VER=\"($VER0)\"\n@@ -711,6 +711,20 @@ else\n     probe_need CFG_GIT     git\n fi\n \n+# Use `md5sum` on GNU platforms, or `md5 -q` on BSD\n+probe CFG_MD5              md5\n+probe CFG_MD5SUM           md5sum\n+if [ -n \"$CFG_MD5\" ]\n+then\n+    CFG_HASH_COMMAND=\"$CFG_MD5 -q | head -c 8\"\n+elif [ -n \"$CFG_MD5SUM\" ]\n+then\n+    CFG_HASH_COMMAND=\"$CFG_MD5SUM | head -c 8\"\n+else\n+    err 'could not find one of: md5 md5sum'\n+fi\n+putvar CFG_HASH_COMMAND\n+\n probe CFG_CLANG            clang++\n probe CFG_CCACHE           ccache\n probe CFG_GCC              gcc"}, {"sha": "964153e4494d3f1000b0add0f16758ec5dd5e9f5", "filename": "mk/main.mk", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -20,7 +20,9 @@ CFG_RELEASE_NUM=1.1.0\n # versions (section 9)\n CFG_PRERELEASE_VERSION=.1\n \n-CFG_FILENAME_EXTRA=4e7c5e5c\n+# Append a version-dependent hash to each library, so we can install different\n+# versions in the same place\n+CFG_FILENAME_EXTRA=$(shell printf '%s' $(CFG_RELEASE) | $(CFG_HASH_COMMAND))\n \n ifeq ($(CFG_RELEASE_CHANNEL),stable)\n # This is the normal semver version string, e.g. \"0.12.0\", \"0.12.0-nightly\""}, {"sha": "21e9be59ebbdf372c6b194a8bbf521de567f306b", "filename": "src/doc/reference.md", "status": "modified", "additions": 62, "deletions": 7, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -1346,6 +1346,8 @@ vtable when the trait is used as a [trait object](#trait-objects).\n Traits are implemented for specific types through separate\n [implementations](#implementations).\n \n+Consider the following trait:\n+\n ```\n # type Surface = i32;\n # type BoundingBox = i32;\n@@ -1360,6 +1362,20 @@ This defines a trait with two methods. All values that have\n `draw` and `bounding_box` methods called, using `value.bounding_box()`\n [syntax](#method-call-expressions).\n \n+Traits can include default implementations of methods, as in:\n+\n+```\n+trait Foo {\n+    fn bar(&self);\n+\n+    fn baz(&self) { println!(\"We called baz.\"); }\n+}\n+```\n+\n+Here the `baz` method has a default implementation, so types that implement\n+`Foo` need only implement `bar`. It is also possible for implementing types\n+to override a method that has a default implementation.\n+\n Type parameters can be specified for a trait to make it generic. These appear\n after the trait name, using the same syntax used in [generic\n functions](#generic-functions).\n@@ -1372,6 +1388,35 @@ trait Seq<T> {\n }\n ```\n \n+It is also possible to define associated types for a trait. Consider the\n+following example of a `Container` trait. Notice how the type is available\n+for use in the method signatures:\n+\n+```\n+trait Container {\n+    type E;\n+    fn empty() -> Self;\n+    fn insert(&mut self, Self::E);\n+}\n+```\n+\n+In order for a type to implement this trait, it must not only provide\n+implementations for every method, but it must specify the type `E`. Here's\n+an implementation of `Container` for the standard library type `Vec`:\n+\n+```\n+# trait Container {\n+#     type E;\n+#     fn empty() -> Self;\n+#     fn insert(&mut self, Self::E);\n+# }\n+impl<T> Container for Vec<T> {\n+    type E = T;\n+    fn empty() -> Vec<T> { Vec::new() }\n+    fn insert(&mut self, x: T) { self.push(x); }\n+}\n+```\n+\n Generic functions may use traits as _bounds_ on their type parameters. This\n will have two effects: only types that have the trait may instantiate the\n parameter, and within the generic function, the methods of the trait can be\n@@ -3470,13 +3515,23 @@ more of the closure traits:\n \n ### Trait objects\n \n-Every trait item (see [traits](#traits)) defines a type with the same name as\n-the trait. This type is called the _trait object_ of the trait. Trait objects\n-permit \"late binding\" of methods, dispatched using _virtual method tables_\n-(\"vtables\"). Whereas most calls to trait methods are \"early bound\" (statically\n-resolved) to specific implementations at compile time, a call to a method on an\n-trait objects is only resolved to a vtable entry at compile time. The actual\n-implementation for each vtable entry can vary on an object-by-object basis.\n+In Rust, a type like `&SomeTrait` or `Box<SomeTrait>` is called a _trait object_.\n+Each instance of a trait object includes:\n+\n+ - a pointer to an instance of a type `T` that implements `SomeTrait`\n+ - a _virtual method table_, often just called a _vtable_, which contains, for\n+   each method of `SomeTrait` that `T` implements, a pointer to `T`'s\n+   implementation (i.e. a function pointer).\n+\n+The purpose of trait objects is to permit \"late binding\" of methods. A call to\n+a method on a trait object is only resolved to a vtable entry at compile time.\n+The actual implementation for each vtable entry can vary on an object-by-object\n+basis.\n+\n+Note that for a trait object to be instantiated, the trait must be\n+_object-safe_. Object safety rules are defined in [RFC 255].\n+\n+[RFC 255]: https://github.com/rust-lang/rfcs/blob/master/text/0255-object-safety.md\n \n Given a pointer-typed expression `E` of type `&T` or `Box<T>`, where `T`\n implements trait `R`, casting `E` to the corresponding pointer type `&R` or"}, {"sha": "9ca5de2b50a4d6898e4bde1ab7e69e3e2af55853", "filename": "src/doc/trpl/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2FREADME.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -175,7 +175,7 @@ data, we call the `clone()` method. In this example, `y` is no longer a referenc\n to the vector stored in `x`, but a copy of its first element, `\"Hello\"`. Now\n that we don\u2019t have a reference, our `push()` works just fine.\n \n-[move]: move-semantics.html\n+[move]: ownership.html#move-semantics\n \n If we truly want a reference, we need the other option: ensure that our reference\n goes out of scope before we try to do the mutation. That looks like this:"}, {"sha": "81280e8920ca9419df1b2f7fd8e2a0564728a6f4", "filename": "src/doc/trpl/dining-philosophers.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fdining-philosophers.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -450,7 +450,7 @@ which blocks execution until the thread has completed execution. This ensures\n that the threads complete their work before the program exits.\n \n If you run this program, you\u2019ll see that the philosophers eat out of order!\n-We have mult-threading!\n+We have multi-threading!\n \n ```text\n Gilles Deleuze is eating."}, {"sha": "dcaf698fd3c9d2d34377a8ba2fca5fb49d1981e7", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -181,6 +181,8 @@ match version {\n This function makes use of an enum, `ParseError`, to enumerate the various\n errors that can occur.\n \n+The [`Debug`](../std/fmt/trait.Debug.html) trait is what lets us print the enum value using the `{:?}` format operation.\n+\n # Non-recoverable errors with `panic!`\n \n In the case of an error that is unexpected and not recoverable, the `panic!`"}, {"sha": "a93f622e9c529699e0ec03d6c6c0a9aeca5775f0", "filename": "src/doc/trpl/iterators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fiterators.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fiterators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fiterators.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -42,7 +42,7 @@ loop is just a handy way to write this `loop`/`match`/`break` construct.\n `for` loops aren't the only thing that uses iterators, however. Writing your\n own iterator involves implementing the `Iterator` trait. While doing that is\n outside of the scope of this guide, Rust provides a number of useful iterators\n-to accomplish various threads. Before we talk about those, we should talk about a\n+to accomplish various tasks. Before we talk about those, we should talk about a\n Rust anti-pattern. And that's using ranges like this.\n \n Yes, we just talked about how ranges are cool. But ranges are also very"}, {"sha": "9622a92303f1e05b78d579bb29aadf0fd8b96f67", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -80,15 +80,15 @@ This memory is kind of like a giant array: addresses start at zero and go\n up to the final number. So here\u2019s a diagram of our first stack frame:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n We\u2019ve got `x` located at address `0`, with the value `42`.\n \n When `foo()` is called, a new stack frame is allocated:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 2       | z    | 100   |\n | 1       | y    | 5     |\n | 0       | x    | 42    |\n@@ -107,7 +107,7 @@ value being stored.\n After `foo()` is over, its frame is deallocated:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n And then, after `main()`, even this last value goes away. Easy!\n@@ -142,13 +142,13 @@ fn main() {\n Okay, first, we call `main()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n Next up, `main()` calls `foo()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n | 1       | a    | 5     |\n@@ -157,7 +157,7 @@ Next up, `main()` calls `foo()`:\n And then `foo()` calls `bar()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 4       | i    | 6     |\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n@@ -170,7 +170,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n `main()`:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | c    | 1     |\n | 2       | b    | 100   |\n | 1       | a    | 5     |\n@@ -179,7 +179,7 @@ After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n And then `foo()` ends, leaving just `main()`\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 0       | x    | 42    |\n \n And then we\u2019re done. Getting the hang of it? It\u2019s like piling up dishes: you\n@@ -206,7 +206,7 @@ fn main() {\n Here\u2019s what happens in memory when `main()` is called:\n \n | Address | Name | Value  |\n-+---------+------+--------+\n+|---------|------|--------|\n | 1       | y    | 42     |\n | 0       | x    | ?????? |\n \n@@ -218,7 +218,7 @@ it allocates some memory for the heap, and puts `5` there. The memory now looks\n like this:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 5              |\n | ...             | ...  | ...            |\n | 1               | y    | 42             |\n@@ -243,7 +243,7 @@ layout of a program which has been running for a while now:\n \n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n | 2<sup>30</sup>       |      | 5                    |\n | (2<sup>30</sup>) - 1 |      |                      |\n | (2<sup>30</sup>) - 2 |      |                      |\n@@ -266,13 +266,13 @@ Rust programs use [jemalloc][jemalloc] for this purpose.\n Anyway, back to our example. Since this memory is on the heap, it can stay\n alive longer than the function which allocates the box. In this case, however,\n it doesn\u2019t.[^moving] When the function is over, we need to free the stack frame\n-for `main()`. `Box<T>`, though, has a trick up its sleve: [Drop][drop]. The\n+for `main()`. `Box<T>`, though, has a trick up its sleeve: [Drop][drop]. The\n implementation of `Drop` for `Box` deallocates the memory that was allocated\n when it was created. Great! So when `x` goes away, it first frees the memory\n allocated on the heap:\n \n | Address | Name | Value  |\n-+---------+------+--------+\n+|---------|------|--------|\n | 1       | y    | 42     |\n | 0       | x    | ?????? |\n \n@@ -305,7 +305,7 @@ fn main() {\n When we enter `main()`, memory looks like this:\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 1       | y    | 0     |\n | 0       | x    | 5     |\n \n@@ -315,7 +315,7 @@ memory location that `x` lives at, which in this case is `0`.\n What about when we call `foo()`, passing `y` as an argument?\n \n | Address | Name | Value |\n-+---------+------+-------+\n+|---------|------|-------|\n | 3       | z    | 42    |\n | 2       | i    | 0     |\n | 1       | y    | 0     |\n@@ -367,7 +367,7 @@ fn main() {\n First, we call `main()`:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 2               | j    | 0              |\n@@ -380,7 +380,7 @@ value pointing there.\n Next, at the end of `main()`, `foo()` gets called:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -397,7 +397,7 @@ since `j` points at `h`.\n Next, `foo()` calls `baz()`, passing `z`:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 7               | g    | 100            |\n@@ -413,7 +413,7 @@ We\u2019ve allocated memory for `f` and `g`. `baz()` is very short, so when it\u2019s\n over, we get rid of its stack frame:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n | 2<sup>30</sup>  |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -426,7 +426,7 @@ over, we get rid of its stack frame:\n Next, `foo()` calls `bar()` with `x` and `z`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -449,7 +449,7 @@ case, we set up the variables as usual.\n At the end of `bar()`, it calls `baz()`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -473,7 +473,7 @@ far.\n After `baz()` is over, we get rid of `f` and `g`:\n \n | Address              | Name | Value                |\n-+----------------------+------+----------------------+\n+|----------------------|------|----------------------|\n |  2<sup>30</sup>      |      | 20                   |\n | (2<sup>30</sup>) - 1 |      | 5                    |\n | ...                  | ...  | ...                  |\n@@ -493,7 +493,7 @@ Next, we return from `bar()`. `d` in this case is a `Box<T>`, so it also frees\n what it points to: (2<sup>30</sup>) - 1.\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n |  2<sup>30</sup> |      | 20             |\n | ...             | ...  | ...            |\n | 5               | z    | 4              |\n@@ -506,7 +506,7 @@ what it points to: (2<sup>30</sup>) - 1.\n And after that, `foo()` returns:\n \n | Address         | Name | Value          |\n-+-----------------+------+----------------+\n+|-----------------|------|----------------|\n |  2<sup>30</sup> |      | 20             |\n | ...             | ...  | ...            |\n | 2               | j    | 0              |"}, {"sha": "e35d81d3996b359e1e3a90f849b465105fcaa26d", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -18,39 +18,41 @@\n //! You can explicitly create a `Vec<T>` with `new()`:\n //!\n //! ```\n-//! let xs: Vec<i32> = Vec::new();\n+//! let v: Vec<i32> = Vec::new();\n //! ```\n //!\n //! ...or by using the `vec!` macro:\n //!\n //! ```\n-//! let ys: Vec<i32> = vec![];\n+//! let v: Vec<i32> = vec![];\n //!\n-//! let zs = vec![1i32, 2, 3, 4, 5];\n+//! let v = vec![1, 2, 3, 4, 5];\n+//!\n+//! let v = vec![0; 10]; // ten zeroes\n //! ```\n //!\n //! You can `push` values onto the end of a vector (which will grow the vector as needed):\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut v = vec![1, 2];\n //!\n-//! xs.push(3);\n+//! v.push(3);\n //! ```\n //!\n //! Popping values works in much the same way:\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2];\n+//! let mut v = vec![1, 2];\n //!\n-//! let two = xs.pop();\n+//! let two = v.pop();\n //! ```\n //!\n //! Vectors also support indexing (through the `Index` and `IndexMut` traits):\n //!\n //! ```\n-//! let mut xs = vec![1i32, 2, 3];\n-//! let three = xs[2];\n-//! xs[1] = xs[1] + 5;\n+//! let mut v = vec![1, 2, 3];\n+//! let three = v[2];\n+//! v[1] = v[1] + 5;\n //! ```\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "64eb75ea530f10f7f5d349a5660c764c4ef9e4b4", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -167,7 +167,7 @@ macro_rules! try {\n     })\n }\n \n-/// Use the `format!` syntax to write data into a buffer of type `&mut Writer`.\n+/// Use the `format!` syntax to write data into a buffer of type `&mut Write`.\n /// See `std::fmt` for more information.\n ///\n /// # Examples"}, {"sha": "e9f4860f4514e12049c0ee554de37ae08794fa63", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -427,8 +427,8 @@ be taken.\n \n E0271: r##\"\n This is because of a type mismatch between the associated type of some\n-trait (e.g. T::Bar, where T implements trait Quux { type Bar; })\n-and another type U that is required to be equal to T::Bar, but is not.\n+trait (e.g. `T::Bar`, where `T` implements `trait Quux { type Bar; }`)\n+and another type `U` that is required to be equal to `T::Bar`, but is not.\n Examples follow.\n \n Here is a basic example:"}, {"sha": "12d6fcd0303ec0d1f1b31ffa555bdc29710e7053", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -30,6 +30,8 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(core)]\n+#![feature(duration)]\n+#![feature(duration_span)]\n #![feature(fs_canonicalize)]\n #![feature(hash)]\n #![feature(into_cow)]"}, {"sha": "9a95120ee686fd5747253818361d1c77dd768c03", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -720,8 +720,7 @@ fn get_metadata_section(is_osx: bool, filename: &Path) -> Result<MetadataBlob, S\n     let dur = Duration::span(|| {\n         ret = Some(get_metadata_section_imp(is_osx, filename));\n     });\n-    info!(\"reading {:?} => {}ms\", filename.file_name().unwrap(),\n-          dur.num_milliseconds());\n+    info!(\"reading {:?} => {}\", filename.file_name().unwrap(), dur);\n     return ret.unwrap();;\n }\n "}, {"sha": "111cf68726c61b61d47ee21222dda8ab0adab60e", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -129,11 +129,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                                                       .probe(v)\n                                                       .map(|v| v.to_type(tcx)),\n                     ty::FloatVar(v),\n-                    ty::FreshIntTy)\n+                    ty::FreshFloatTy)\n             }\n \n             ty::ty_infer(ty::FreshTy(c)) |\n-            ty::ty_infer(ty::FreshIntTy(c)) => {\n+            ty::ty_infer(ty::FreshIntTy(c)) |\n+            ty::ty_infer(ty::FreshFloatTy(c)) => {\n                 if c >= self.freshen_count {\n                     tcx.sess.bug(\n                         &format!(\"Encountered a freshend type with id {} \\"}, {"sha": "8011d296263151b23785e570e3e75a02482b0a11", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -1773,7 +1773,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_err => ok_if(Vec::new()),\n \n             ty::ty_infer(ty::FreshTy(_))\n-            | ty::ty_infer(ty::FreshIntTy(_)) => {\n+            | ty::ty_infer(ty::FreshIntTy(_))\n+            | ty::ty_infer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1835,7 +1836,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             ty::ty_projection(..) |\n             ty::ty_infer(ty::TyVar(_)) |\n             ty::ty_infer(ty::FreshTy(_)) |\n-            ty::ty_infer(ty::FreshIntTy(_)) => {\n+            ty::ty_infer(ty::FreshIntTy(_)) |\n+            ty::ty_infer(ty::FreshFloatTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble constituent types of unexpected type: {}\","}, {"sha": "e988423ac5774bbb177bcdc820a210826a81bf3e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -1697,11 +1697,8 @@ pub enum InferTy {\n     /// unbound type variable. This is convenient for caching etc. See\n     /// `middle::infer::freshen` for more details.\n     FreshTy(u32),\n-\n-    // FIXME -- once integral fallback is impl'd, we should remove\n-    // this type. It's only needed to prevent spurious errors for\n-    // integers whose type winds up never being constrained.\n     FreshIntTy(u32),\n+    FreshFloatTy(u32)\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Debug, Copy)]\n@@ -1773,6 +1770,7 @@ impl fmt::Debug for InferTy {\n             FloatVar(ref v) => v.fmt(f),\n             FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n             FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+            FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n         }\n     }\n }\n@@ -3775,7 +3773,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             // Scalar and unique types are sendable, and durable\n-            ty_infer(ty::FreshIntTy(_)) |\n+            ty_infer(ty::FreshIntTy(_)) | ty_infer(ty::FreshFloatTy(_)) |\n             ty_bool | ty_int(_) | ty_uint(_) | ty_float(_) |\n             ty_bare_fn(..) | ty::ty_char => {\n                 TC::None\n@@ -4325,6 +4323,7 @@ pub fn type_is_fresh(ty: Ty) -> bool {\n     match ty.sty {\n       ty_infer(FreshTy(_)) => true,\n       ty_infer(FreshIntTy(_)) => true,\n+      ty_infer(FreshFloatTy(_)) => true,\n       _ => false\n     }\n }\n@@ -5026,6 +5025,7 @@ pub fn ty_sort_string<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> String {\n         ty_infer(FloatVar(_)) => \"floating-point variable\".to_string(),\n         ty_infer(FreshTy(_)) => \"skolemized type\".to_string(),\n         ty_infer(FreshIntTy(_)) => \"skolemized integral type\".to_string(),\n+        ty_infer(FreshFloatTy(_)) => \"skolemized floating-point type\".to_string(),\n         ty_projection(_) => \"associated type\".to_string(),\n         ty_param(ref p) => {\n             if p.space == subst::SelfSpace {"}, {"sha": "526ad0ec1c9d2d4b6f3ff3c1420ac0b71d2b7720", "filename": "src/librustc/middle/ty_match.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Fmiddle%2Fty_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_match.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -67,7 +67,8 @@ impl<'a, 'tcx> TypeRelation<'a, 'tcx> for Match<'a, 'tcx> {\n \n         match (&a.sty, &b.sty) {\n             (_, &ty::ty_infer(ty::FreshTy(_))) |\n-            (_, &ty::ty_infer(ty::FreshIntTy(_))) => {\n+            (_, &ty::ty_infer(ty::FreshIntTy(_))) |\n+            (_, &ty::ty_infer(ty::FreshFloatTy(_))) => {\n                 Ok(a)\n             }\n "}, {"sha": "5a5567c48adeec4b52d56e5b032abe05c17ba3f6", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -55,8 +55,8 @@ pub fn time<T, U, F>(do_it: bool, what: &str, u: U, f: F) -> T where\n     };\n     let rv = rv.unwrap();\n \n-    println!(\"{}time: {}.{:03} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n-             dur.num_seconds(), dur.num_milliseconds() % 1000, what);\n+    println!(\"{}time: {} \\t{}\", repeat(\"  \").take(old).collect::<String>(),\n+             dur, what);\n     DEPTH.with(|slot| slot.set(old));\n \n     rv"}, {"sha": "cf2911ab182efd9eb8316c0f20461f2c751fb15b", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -349,7 +349,8 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FloatVar(ref vid) if print_var_ids => vid.repr(cx),\n             ty::TyVar(_) | ty::IntVar(_) | ty::FloatVar(_) => format!(\"_\"),\n             ty::FreshTy(v) => format!(\"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v)\n+            ty::FreshIntTy(v) => format!(\"FreshIntTy({})\", v),\n+            ty::FreshFloatTy(v) => format!(\"FreshFloatTy({})\", v)\n         }\n     }\n "}, {"sha": "cad1522ee1344b22b81a7382d18fe7104c83be49", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -306,6 +306,21 @@ impl<'a> ArchiveBuilder<'a> {\n             if filename.contains(\".SYMDEF\") { continue }\n             if skip(filename) { continue }\n \n+            // Archives on unix systems typically do not have slashes in\n+            // filenames as the `ar` utility generally only uses the last\n+            // component of a path for the filename list in the archive. On\n+            // Windows, however, archives assembled with `lib.exe` will preserve\n+            // the full path to the file that was placed in the archive,\n+            // including path separators.\n+            //\n+            // The code below is munging paths so it'll go wrong pretty quickly\n+            // if there's some unexpected slashes in the filename, so here we\n+            // just chop off everything but the filename component. Note that\n+            // this can cause duplicate filenames, but that's also handled below\n+            // as well.\n+            let filename = Path::new(filename).file_name().unwrap()\n+                                              .to_str().unwrap();\n+\n             // An archive can contain files of the same name multiple times, so\n             // we need to be sure to not have them overwrite one another when we\n             // extract them. Consequently we need to find a truly unique file"}, {"sha": "15ddcbc80749cb38dd430dd2f50aa6833f45d522", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 89, "deletions": 6, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -20,6 +20,7 @@ Imports (`use` statements) are not allowed after non-item statements, such as\n variable declarations and expression statements.\n \n Here is an example that demonstrates the error:\n+\n ```\n fn f() {\n     // Variable declaration before import\n@@ -33,6 +34,7 @@ The solution is to declare the imports at the top of the block, function, or\n file.\n \n Here is the previous example again, with the correct order:\n+\n ```\n fn f() {\n     use std::io::Read;\n@@ -47,11 +49,94 @@ about what constitutes an Item declaration and what does not:\n http://doc.rust-lang.org/reference.html#statements\n \"##,\n \n+E0251: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::*; // error, do `use foo::baz as quux` instead on the previous line\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0252: r##\"\n+Two items of the same name cannot be imported without rebinding one of the\n+items under a new local name.\n+\n+An example of this error:\n+\n+```\n+use foo::baz;\n+use bar::baz; // error, do `use bar::baz as quux` instead\n+\n+fn main() {}\n+\n+mod foo {\n+    pub struct baz;\n+}\n+\n+mod bar {\n+    pub mod baz {}\n+}\n+```\n+\"##,\n+\n+E0255: r##\"\n+You can't import a value whose name is the same as another value defined in the\n+module.\n+\n+An example of this error:\n+\n+```\n+use bar::foo; // error, do `use bar::foo as baz` instead\n+\n+fn foo() {}\n+\n+mod bar {\n+     pub fn foo() {}\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n+E0256: r##\"\n+You can't import a type or module when the name of the item being imported is\n+the same as another type or submodule defined in the module.\n+\n+An example of this error:\n+\n+```\n+use foo::Bar; // error\n+\n+type Bar = u32;\n+\n+mod foo {\n+    pub mod Bar { }\n+}\n+\n+fn main() {}\n+```\n+\"##,\n+\n E0259: r##\"\n The name chosen for an external crate conflicts with another external crate that\n has been imported into the current module.\n \n Wrong example:\n+\n ```\n extern crate a;\n extern crate crate_a as a;\n@@ -61,6 +146,7 @@ The solution is to choose a different name that doesn't conflict with any\n external crate imported into the current module.\n \n Correct example:\n+\n ```\n extern crate a;\n extern crate crate_a as other_name;\n@@ -71,6 +157,7 @@ E0260: r##\"\n The name for an item declaration conflicts with an external crate's name.\n \n For instance,\n+\n ```\n extern crate abc;\n \n@@ -117,14 +204,10 @@ http://doc.rust-lang.org/reference.html#types\n register_diagnostics! {\n     E0157,\n     E0153,\n-    E0251, // a named type or value has already been imported in this module\n-    E0252, // a named type or value has already been imported in this module\n     E0253, // not directly importable\n     E0254, // import conflicts with imported crate in this module\n-    E0255, // import conflicts with value in this module\n-    E0256, // import conflicts with type in this module\n-    E0257, // inherent implementations are only allowed on types defined in the current module\n-    E0258, // import conflicts with existing submodule\n+    E0257,\n+    E0258,\n     E0364, // item is private\n     E0365  // item is private\n }"}, {"sha": "38ab0a8c5ed0d1740163f3400ac9a2673f81d513", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -2528,15 +2528,18 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // If anything ends up here entirely resolved,\n                                 // it's an error. If anything ends up here\n                                 // partially resolved, that's OK, because it may\n-                                // be a `T::CONST` that typeck will resolve to\n-                                // an inherent impl.\n+                                // be a `T::CONST` that typeck will resolve.\n                                 if path_res.depth == 0 {\n                                     self.resolve_error(\n                                         path.span,\n                                         &format!(\"`{}` is not an enum variant, struct or const\",\n                                                  token::get_ident(\n                                                      path.segments.last().unwrap().identifier)));\n                                 } else {\n+                                    let const_name = path.segments.last().unwrap()\n+                                                         .identifier.name;\n+                                    let traits = self.get_traits_containing_item(const_name);\n+                                    self.trait_map.insert(pattern.id, traits);\n                                     self.record_def(pattern.id, path_res);\n                                 }\n                             }"}, {"sha": "89cda6d785f07f7a8f4a540d6b2ddd88cd8dc6ee", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -520,12 +520,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let qualname = format!(\"::{}\", self.analysis.ty_cx.map.path_to_string(item.id));\n \n         // If the variable is immutable, save the initialising expression.\n-        let value = match mt {\n-            ast::MutMutable => String::from_str(\"<mutable>\"),\n-            ast::MutImmutable => self.span.snippet(expr.span),\n+        let (value, keyword) = match mt {\n+            ast::MutMutable => (String::from_str(\"<mutable>\"), keywords::Mut),\n+            ast::MutImmutable => (self.span.snippet(expr.span), keywords::Static),\n         };\n \n-        let sub_span = self.span.sub_span_after_keyword(item.span, keywords::Static);\n+        let sub_span = self.span.sub_span_after_keyword(item.span, keyword);\n         self.fmt.static_str(item.span,\n                             sub_span,\n                             item.id,"}, {"sha": "90df0b853a083bca91097986ed2b8229e85bd9ce", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 36, "deletions": 37, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -16,12 +16,10 @@ use middle::def;\n use middle::privacy::{AllPublic, DependsOn, LastPrivate, LastMod};\n use middle::subst;\n use middle::traits;\n-use middle::ty::*;\n-use middle::ty;\n+use middle::ty::{self, AsPredicate, ToPolyTraitRef};\n use middle::infer;\n use util::ppaux::Repr;\n \n-use std::rc::Rc;\n use syntax::ast::DefId;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -39,7 +37,7 @@ pub enum MethodError {\n     // Did not find an applicable method, but we did find various\n     // static methods that may apply, as well as a list of\n     // not-in-scope traits which may work.\n-    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>),\n+    NoMatch(Vec<CandidateSource>, Vec<ast::DefId>, probe::Mode),\n \n     // Multiple methods might apply.\n     Ambiguity(Vec<CandidateSource>),\n@@ -62,7 +60,7 @@ type ItemIndex = usize; // just for doc purposes\n pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n                         method_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n+                        self_ty: ty::Ty<'tcx>,\n                         call_expr_id: ast::NodeId)\n                         -> bool\n {\n@@ -92,11 +90,11 @@ pub fn exists<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn lookup<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                         span: Span,\n                         method_name: ast::Name,\n-                        self_ty: Ty<'tcx>,\n-                        supplied_method_types: Vec<Ty<'tcx>>,\n+                        self_ty: ty::Ty<'tcx>,\n+                        supplied_method_types: Vec<ty::Ty<'tcx>>,\n                         call_expr: &'tcx ast::Expr,\n                         self_expr: &'tcx ast::Expr)\n-                        -> Result<MethodCallee<'tcx>, MethodError>\n+                        -> Result<ty::MethodCallee<'tcx>, MethodError>\n {\n     debug!(\"lookup(method_name={}, self_ty={}, call_expr={}, self_expr={})\",\n            method_name.repr(fcx.tcx()),\n@@ -115,9 +113,9 @@ pub fn lookup_in_trait<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                  self_expr: Option<&ast::Expr>,\n                                  m_name: ast::Name,\n                                  trait_def_id: DefId,\n-                                 self_ty: Ty<'tcx>,\n-                                 opt_input_types: Option<Vec<Ty<'tcx>>>)\n-                                 -> Option<MethodCallee<'tcx>>\n+                                 self_ty: ty::Ty<'tcx>,\n+                                 opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                 -> Option<ty::MethodCallee<'tcx>>\n {\n     lookup_in_trait_adjusted(fcx, span, self_expr, m_name, trait_def_id,\n                              0, false, self_ty, opt_input_types)\n@@ -139,9 +137,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                           trait_def_id: DefId,\n                                           autoderefs: usize,\n                                           unsize: bool,\n-                                          self_ty: Ty<'tcx>,\n-                                          opt_input_types: Option<Vec<Ty<'tcx>>>)\n-                                          -> Option<MethodCallee<'tcx>>\n+                                          self_ty: ty::Ty<'tcx>,\n+                                          opt_input_types: Option<Vec<ty::Ty<'tcx>>>)\n+                                          -> Option<ty::MethodCallee<'tcx>>\n {\n     debug!(\"lookup_in_trait_adjusted(self_ty={}, self_expr={}, m_name={}, trait_def_id={})\",\n            self_ty.repr(fcx.tcx()),\n@@ -186,7 +184,9 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // Trait must have a method named `m_name` and it should not have\n     // type parameters or early-bound regions.\n     let tcx = fcx.tcx();\n-    let (method_num, method_ty) = trait_method(tcx, trait_def_id, m_name).unwrap();\n+    let (method_num, method_ty) = trait_item(tcx, trait_def_id, m_name)\n+            .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+            .unwrap();\n     assert_eq!(method_ty.generics.types.len(subst::FnSpace), 0);\n     assert_eq!(method_ty.generics.regions.len(subst::FnSpace), 0);\n \n@@ -288,10 +288,10 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n-    let callee = MethodCallee {\n-        origin: MethodTypeParam(MethodParam{trait_ref: trait_ref.clone(),\n-                                            method_num: method_num,\n-                                            impl_def_id: None}),\n+    let callee = ty::MethodCallee {\n+        origin: ty::MethodTypeParam(ty::MethodParam{trait_ref: trait_ref.clone(),\n+                                                    method_num: method_num,\n+                                                    impl_def_id: None}),\n         ty: fty,\n         substs: trait_ref.substs.clone()\n     };\n@@ -304,7 +304,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               method_name: ast::Name,\n-                              self_ty: Ty<'tcx>,\n+                              self_ty: ty::Ty<'tcx>,\n                               expr_id: ast::NodeId)\n                               -> Result<(def::Def, LastPrivate), MethodError>\n {\n@@ -322,41 +322,40 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         _ => def::FromTrait(pick.item.container().id())\n     };\n     let def_result = match pick.item {\n-        ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n-        ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n-        ImplOrTraitItem::TypeTraitItem(..) => {\n+        ty::ImplOrTraitItem::MethodTraitItem(..) => def::DefMethod(def_id, provenance),\n+        ty::ImplOrTraitItem::ConstTraitItem(..) => def::DefAssociatedConst(def_id, provenance),\n+        ty::ImplOrTraitItem::TypeTraitItem(..) => {\n             fcx.tcx().sess.span_bug(span, \"resolve_ufcs: probe picked associated type\");\n         }\n     };\n     Ok((def_result, lp))\n }\n \n \n-/// Find method with name `method_name` defined in `trait_def_id` and return it, along with its\n-/// index (or `None`, if no such method).\n-fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                      trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n-                      -> Option<(usize, Rc<ty::Method<'tcx>>)>\n+/// Find item with name `item_name` defined in `trait_def_id` and return it, along with its\n+/// index (or `None`, if no such item).\n+fn trait_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                    trait_def_id: ast::DefId,\n+                    item_name: ast::Name)\n+                    -> Option<(usize, ty::ImplOrTraitItem<'tcx>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items\n         .iter()\n         .enumerate()\n-        .find(|&(_, ref item)| item.name() == method_name)\n-        .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))\n+        .find(|&(_, ref item)| item.name() == item_name)\n+        .map(|(num, item)| (num, (*item).clone()))\n }\n \n-fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                     impl_def_id: ast::DefId,\n-                     method_name: ast::Name)\n-                     -> Option<Rc<ty::Method<'tcx>>>\n+fn impl_item<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                   impl_def_id: ast::DefId,\n+                   item_name: ast::Name)\n+                   -> Option<ty::ImplOrTraitItem<'tcx>>\n {\n     let impl_items = tcx.impl_items.borrow();\n     let impl_items = impl_items.get(&impl_def_id).unwrap();\n     impl_items\n         .iter()\n         .map(|&did| ty::impl_or_trait_item(tcx, did.def_id()))\n-        .find(|m| m.name() == method_name)\n-        .and_then(|item| item.as_opt_method())\n+        .find(|m| m.name() == item_name)\n }"}, {"sha": "2eca855d5960b08bfaff09be483c57cf402f9047", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -136,7 +136,7 @@ pub fn probe<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let steps = if mode == Mode::MethodCall {\n         match create_steps(fcx, span, self_ty) {\n             Some(steps) => steps,\n-            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new())),\n+            None => return Err(MethodError::NoMatch(Vec::new(), Vec::new(), mode)),\n         }\n     } else {\n         vec![CandidateStep {\n@@ -866,7 +866,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                     }\n                 }\n             }).collect(),\n-            Some(Err(MethodError::NoMatch(_, others))) => {\n+            Some(Err(MethodError::NoMatch(_, others, _))) => {\n                 assert!(others.is_empty());\n                 vec![]\n             }\n@@ -877,7 +877,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             None => vec![],\n         };\n \n-        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits))\n+        Err(MethodError::NoMatch(static_candidates, out_of_scope_traits, self.mode))\n     }\n \n     fn pick_core(&mut self) -> Option<PickResult<'tcx>> {"}, {"sha": "93239df60e16499b15536c39c252f514ffc0631d", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 37, "deletions": 34, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Give useful errors and suggestions to users when a method can't be\n+//! Give useful errors and suggestions to users when an item can't be\n //! found or is otherwise invalid.\n \n use CrateCtxt;\n@@ -27,12 +27,13 @@ use syntax::print::pprust;\n use std::cell;\n use std::cmp::Ordering;\n \n-use super::{MethodError, CandidateSource, impl_method, trait_method};\n+use super::{MethodError, CandidateSource, impl_item, trait_item};\n+use super::probe::Mode;\n \n pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                               span: Span,\n                               rcvr_ty: Ty<'tcx>,\n-                              method_name: ast::Name,\n+                              item_name: ast::Name,\n                               rcvr_expr: Option<&ast::Expr>,\n                               error: MethodError)\n {\n@@ -42,28 +43,30 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n     match error {\n-        MethodError::NoMatch(static_sources, out_of_scope_traits) => {\n+        MethodError::NoMatch(static_sources, out_of_scope_traits, mode) => {\n             let cx = fcx.tcx();\n-            let method_ustring = method_name.user_string(cx);\n+            let item_ustring = item_name.user_string(cx);\n \n             fcx.type_error_message(\n                 span,\n                 |actual| {\n-                    format!(\"type `{}` does not implement any \\\n-                             method in scope named `{}`\",\n-                            actual,\n-                            method_ustring)\n+                    format!(\"no {} named `{}` found for type `{}` \\\n+                             in the current scope\",\n+                            if mode == Mode::MethodCall { \"method\" }\n+                            else { \"associated item\" },\n+                            item_ustring,\n+                            actual)\n                 },\n                 rcvr_ty,\n                 None);\n \n-            // If the method has the name of a field, give a help note\n+            // If the item has the name of a field, give a help note\n             if let (&ty::ty_struct(did, _), Some(_)) = (&rcvr_ty.sty, rcvr_expr) {\n                 let fields = ty::lookup_struct_fields(cx, did);\n-                if fields.iter().any(|f| f.name == method_name) {\n+                if fields.iter().any(|f| f.name == item_name) {\n                     cx.sess.span_note(span,\n                         &format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                                 function stored in the `{0}` field\", method_ustring));\n+                                 function stored in the `{0}` field\", item_ustring));\n                 }\n             }\n \n@@ -72,25 +75,25 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     span,\n                     \"found defined static methods, maybe a `self` is missing?\");\n \n-                report_candidates(fcx, span, method_name, static_sources);\n+                report_candidates(fcx, span, item_name, static_sources);\n             }\n \n-            suggest_traits_to_import(fcx, span, rcvr_ty, method_name,\n+            suggest_traits_to_import(fcx, span, rcvr_ty, item_name,\n                                      rcvr_expr, out_of_scope_traits)\n         }\n \n         MethodError::Ambiguity(sources) => {\n             span_err!(fcx.sess(), span, E0034,\n-                      \"multiple applicable methods in scope\");\n+                      \"multiple applicable items in scope\");\n \n-            report_candidates(fcx, span, method_name, sources);\n+            report_candidates(fcx, span, item_name, sources);\n         }\n \n         MethodError::ClosureAmbiguity(trait_def_id) => {\n             let msg = format!(\"the `{}` method from the `{}` trait cannot be explicitly \\\n                                invoked on this closure as we have not yet inferred what \\\n                                kind of closure it is\",\n-                               method_name.user_string(fcx.tcx()),\n+                               item_name.user_string(fcx.tcx()),\n                                ty::item_path_str(fcx.tcx(), trait_def_id));\n             let msg = if let Some(callee) = rcvr_expr {\n                 format!(\"{}; use overloaded call notation instead (e.g., `{}()`)\",\n@@ -104,19 +107,19 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n     fn report_candidates(fcx: &FnCtxt,\n                          span: Span,\n-                         method_name: ast::Name,\n+                         item_name: ast::Name,\n                          mut sources: Vec<CandidateSource>) {\n         sources.sort();\n         sources.dedup();\n \n         for (idx, source) in sources.iter().enumerate() {\n             match *source {\n                 CandidateSource::ImplSource(impl_did) => {\n-                    // Provide the best span we can. Use the method, if local to crate, else\n-                    // the impl, if local to crate (method may be defaulted), else the call site.\n-                    let method = impl_method(fcx.tcx(), impl_did, method_name).unwrap();\n+                    // Provide the best span we can. Use the item, if local to crate, else\n+                    // the impl, if local to crate (item may be defaulted), else the call site.\n+                    let item = impl_item(fcx.tcx(), impl_did, item_name).unwrap();\n                     let impl_span = fcx.tcx().map.def_id_span(impl_did, span);\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, impl_span);\n+                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), impl_span);\n \n                     let impl_ty = check::impl_self_ty(fcx, span, impl_did).ty;\n \n@@ -127,16 +130,16 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                                                      trait_ref.def_id)),\n                     };\n \n-                    span_note!(fcx.sess(), method_span,\n+                    span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in an impl{} for the type `{}`\",\n                                idx + 1,\n                                insertion,\n                                impl_ty.user_string(fcx.tcx()));\n                 }\n                 CandidateSource::TraitSource(trait_did) => {\n-                    let (_, method) = trait_method(fcx.tcx(), trait_did, method_name).unwrap();\n-                    let method_span = fcx.tcx().map.def_id_span(method.def_id, span);\n-                    span_note!(fcx.sess(), method_span,\n+                    let (_, item) = trait_item(fcx.tcx(), trait_did, item_name).unwrap();\n+                    let item_span = fcx.tcx().map.def_id_span(item.def_id(), span);\n+                    span_note!(fcx.sess(), item_span,\n                                \"candidate #{} is defined in the trait `{}`\",\n                                idx + 1,\n                                ty::item_path_str(fcx.tcx(), trait_did));\n@@ -152,19 +155,19 @@ pub type AllTraitsVec = Vec<TraitInfo>;\n fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                       span: Span,\n                                       rcvr_ty: Ty<'tcx>,\n-                                      method_name: ast::Name,\n+                                      item_name: ast::Name,\n                                       rcvr_expr: Option<&ast::Expr>,\n                                       valid_out_of_scope_traits: Vec<ast::DefId>)\n {\n     let tcx = fcx.tcx();\n-    let method_ustring = method_name.user_string(tcx);\n+    let item_ustring = item_name.user_string(tcx);\n \n     if !valid_out_of_scope_traits.is_empty() {\n         let mut candidates = valid_out_of_scope_traits;\n         candidates.sort();\n         candidates.dedup();\n         let msg = format!(\n-            \"methods from traits can only be called if the trait is in scope; \\\n+            \"items from traits can only be used if the trait is in scope; \\\n              the following {traits_are} implemented but not in scope, \\\n              perhaps add a `use` for {one_of_them}:\",\n             traits_are = if candidates.len() == 1 {\"trait is\"} else {\"traits are\"},\n@@ -185,7 +188,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let type_is_local = type_derefs_to_local(fcx, span, rcvr_ty, rcvr_expr);\n \n     // there's no implemented traits, so lets suggest some traits to\n-    // implement, by finding ones that have the method name, and are\n+    // implement, by finding ones that have the item name, and are\n     // legal to implement.\n     let mut candidates = all_traits(fcx.ccx)\n         .filter(|info| {\n@@ -196,7 +199,7 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // implementing a trait would be legal but is rejected\n             // here).\n             (type_is_local || ast_util::is_local(info.def_id))\n-                && trait_method(tcx, info.def_id, method_name).is_some()\n+                && trait_item(tcx, info.def_id, item_name).is_some()\n         })\n         .collect::<Vec<_>>();\n \n@@ -209,12 +212,12 @@ fn suggest_traits_to_import<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // of a type parameter: suggest adding a trait bound rather\n         // than implementing.\n         let msg = format!(\n-            \"methods from traits can only be called if the trait is implemented and in scope; \\\n-             the following {traits_define} a method `{name}`, \\\n+            \"items from traits can only be used if the trait is implemented and in scope; \\\n+             the following {traits_define} an item `{name}`, \\\n              perhaps you need to implement {one_of_them}:\",\n             traits_define = if candidates.len() == 1 {\"trait defines\"} else {\"traits define\"},\n             one_of_them = if candidates.len() == 1 {\"it\"} else {\"one of them\"},\n-            name = method_ustring);\n+            name = item_ustring);\n \n         fcx.sess().fileline_help(span, &msg[..]);\n "}, {"sha": "3cdbaec15284b7e488e423ae208e1aa8b2191781", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -3082,8 +3082,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           let mut checked = false;\n           opt_place.as_ref().map(|place| match place.node {\n               ast::ExprPath(None, ref path) => {\n-                  // FIXME(pcwalton): For now we hardcode the two permissible\n-                  // places: the exchange heap and the managed heap.\n+                  // FIXME(pcwalton): For now we hardcode the only permissible\n+                  // place: the exchange heap.\n                   let definition = lookup_full_def(tcx, path.span, place.id);\n                   let def_id = definition.def_id();\n                   let referent_ty = fcx.expr_ty(&**subexpr);\n@@ -3097,7 +3097,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n \n           if !checked {\n               span_err!(tcx.sess, expr.span, E0066,\n-                  \"only the managed heap and exchange heap are currently supported\");\n+                  \"only the exchange heap is currently supported\");\n               fcx.write_ty(id, tcx.types.err);\n           }\n       }\n@@ -3317,7 +3317,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if let Err(_) = fcx.mk_eqty(false, infer::Misc(expr.span),\n                                                     result_type, ty::mk_nil(fcx.tcx())) {\n                             span_err!(tcx.sess, expr.span, E0069,\n-                                \"`return;` in function returning non-nil\");\n+                                \"`return;` in a function whose return type is \\\n+                                 not `()`\");\n                         },\n                     Some(ref e) => {\n                         check_expr_coercable_to_type(fcx, &**e, result_type);"}, {"sha": "10d23c36c80583719e9fd70fa38fd2ca469be3ad", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 279, "deletions": 12, "changes": 291, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -19,6 +19,88 @@ methods that do not have default implementations), as well as any required\n trait items like associated types or constants.\n \"##,\n \n+E0049: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of type parameters.\n+\n+For example, the trait below has a method `foo` with a type parameter `T`,\n+but the implementation of `foo` for the type `Bar` is missing this parameter:\n+\n+```\n+trait Foo {\n+    fn foo<T: Default>(x: T) -> Self;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 0 type parameters but its trait declaration has 1\n+// type parameter\n+impl Foo for Bar {\n+    fn foo(x: bool) -> Self { Bar }\n+}\n+```\n+\"##,\n+\n+E0050: r##\"\n+This error indicates that an attempted implementation of a trait method\n+has the wrong number of function parameters.\n+\n+For example, the trait below has a method `foo` with two function parameters\n+(`&self` and `u8`), but the implementation of `foo` for the type `Bar` omits\n+the `u8` parameter:\n+\n+```\n+trait Foo {\n+    fn foo(&self, x: u8) -> bool;\n+}\n+\n+struct Bar;\n+\n+// error: method `foo` has 1 parameter but the declaration in trait `Foo::foo`\n+// has 2\n+impl Foo for Bar {\n+    fn foo(&self) -> bool { true }\n+}\n+```\n+\"##,\n+\n+E0053: r##\"\n+For any given method of a trait, the mutabilities of the parameters must match\n+between the trait definition and the implementation.\n+\n+Here's an example where the mutability of the `self` parameter is wrong:\n+\n+```\n+trait Foo { fn foo(&self); }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the signature should be `fn foo(&self)` instead\n+    fn foo(&mut self) { }\n+}\n+\n+fn main() {}\n+```\n+\n+Here's another example, this time for a non-`self` parameter:\n+\n+```\n+trait Foo { fn foo(x: &mut bool) -> bool; }\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    // error, the type of `x` should be `&mut bool` instead\n+    fn foo(x: &bool) -> bool { *x }\n+}\n+\n+fn main() {}\n+```\n+\n+\n+\"##,\n+\n E0054: r##\"\n It is not allowed to cast to a bool. If you are trying to cast a numeric type\n to a bool, you can compare it with zero instead:\n@@ -46,6 +128,16 @@ enum variant, one of the fields was not provided. Each field should be specified\n exactly once.\n \"##,\n \n+E0066: r##\"\n+Box placement expressions (like C++'s \"placement new\") do not yet support any\n+place expression except the exchange heap (i.e. `std::boxed::HEAP`).\n+Furthermore, the syntax is changing to use `in` instead of `box`. See [RFC 470]\n+and [RFC 809] for more details.\n+\n+[RFC 470]: https://github.com/rust-lang/rfcs/pull/470\n+[RFC 809]: https://github.com/rust-lang/rfcs/pull/809\n+\"##,\n+\n E0067: r##\"\n The left-hand side of an assignment operator must be an lvalue expression. An\n lvalue expression represents a memory location and includes item paths (ie,\n@@ -63,6 +155,21 @@ LinkedList::new() += 1;\n ```\n \"##,\n \n+E0069: r##\"\n+The compiler found a function whose body contains a `return;` statement but\n+whose return type is not `()`. An example of this is:\n+\n+```\n+// error\n+fn foo() -> u8 {\n+    return;\n+}\n+```\n+\n+Since `return;` is just like `return ();`, there is a mismatch between the\n+function's return type and the value being returned.\n+\"##,\n+\n E0081: r##\"\n Enum discriminants are used to differentiate enum variants stored in memory.\n This error indicates that the same value was used for two or more variants,\n@@ -138,6 +245,88 @@ enum Empty {}\n ```\n \"##,\n \n+E0106: r##\"\n+This error indicates that a lifetime is missing from a type. If it is an error\n+inside a function signature, the problem may be with failing to adhere to the\n+lifetime elision rules (see below).\n+\n+Here are some simple examples of where you'll run into this error:\n+\n+```\n+struct Foo { x: &bool }        // error\n+struct Foo<'a> { x: &'a bool } // correct\n+\n+enum Bar { A(u8), B(&bool), }        // error\n+enum Bar<'a> { A(u8), B(&'a bool), } // correct\n+\n+type MyStr = &str;        // error\n+type MyStr<'a> = &'a str; //correct\n+\n+```\n+\n+Lifetime elision is a special, limited kind of inference for lifetimes in\n+function signatures which allows you to leave out lifetimes in certain cases.\n+For more background on lifetime elision see [the book][book-le].\n+\n+The lifetime elision rules require that any function signature with an elided\n+output lifetime must either have\n+\n+ - exactly one input lifetime\n+ - or, multiple input lifetimes, but the function must also be a method with a\n+   `&self` or `&mut self` receiver\n+\n+In the first case, the output lifetime is inferred to be the same as the unique\n+input lifetime. In the second case, the lifetime is instead inferred to be the\n+same as the lifetime on `&self` or `&mut self`.\n+\n+Here are some examples of elision errors:\n+\n+```\n+// error, no input lifetimes\n+fn foo() -> &str { ... }\n+\n+// error, `x` and `y` have distinct lifetimes inferred\n+fn bar(x: &str, y: &str) -> &str { ... }\n+\n+// error, `y`'s lifetime is inferred to be distinct from `x`'s\n+fn baz<'a>(x: &'a str, y: &str) -> &str { ... }\n+```\n+\n+[book-le]: http://doc.rust-lang.org/nightly/book/lifetimes.html#lifetime-elision\n+\"##,\n+\n+E0107: r##\"\n+This error means that an incorrect number of lifetime parameters were provided\n+for a type (like a struct or enum) or trait.\n+\n+Some basic examples include:\n+\n+```\n+struct Foo<'a>(&'a str);\n+enum Bar { A, B, C }\n+\n+struct Baz<'a> {\n+    foo: Foo,     // error: expected 1, found 0\n+    bar: Bar<'a>, // error: expected 0, found 1\n+}\n+```\n+\n+Here's an example that is currently an error, but may work in a future version\n+of Rust:\n+\n+```\n+struct Foo<'a>(&'a str);\n+\n+trait Quux { }\n+impl Quux for Foo { } // error: expected 1, found 0\n+```\n+\n+Lifetime elision in implementation headers was part of the lifetime elision\n+RFC. It is, however, [currently unimplemented][iss15872].\n+\n+[iss15872]: https://github.com/rust-lang/rust/issues/15872\n+\"##,\n+\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n@@ -152,6 +341,20 @@ fn(isize, *const *const u8) -> isize\n ```\n \"##,\n \n+E0166: r##\"\n+This error means that the compiler found a return expression in a function\n+marked as diverging. A function diverges if it has `!` in the place of the\n+return type in its signature. For example:\n+\n+```\n+fn foo() -> ! { return; } // error\n+```\n+\n+For a function that diverges, every control path in the function must never\n+return, for example with a `loop` that never breaks or a call to another\n+diverging function (such as `panic!()`).\n+\"##,\n+\n E0184: r##\"\n Explicitly implementing both Drop and Copy for a type is currently disallowed.\n This feature can make some sense in theory, but the current implementation is\n@@ -167,12 +370,14 @@ methods associated with a type) are always safe because they are not\n implementing an unsafe trait. Removing the unsafe keyword from the inherent\n implementation will resolve this error.\n \n+```\n struct Foo;\n \n // this will cause this error\n unsafe impl Foo { }\n // converting it to this will fix it\n impl Foo { }\n+```\n \n \"##,\n \n@@ -182,12 +387,14 @@ particular trait. Not being able to use a trait is always a safe operation,\n so negative implementations are always safe and never need to be marked as\n unsafe.\n \n+```\n struct Foo;\n \n // unsafe is unnecessary\n unsafe impl !Clone for Foo { }\n // this will compile\n impl !Clone for Foo { }\n+```\n \n \"##,\n \n@@ -196,6 +403,7 @@ Safe traits should not have unsafe implementations, therefore marking an\n implementation for a safe trait unsafe will cause a compiler error. Removing the\n unsafe marker on the trait noted in the error will resolve this problem.\n \n+```\n struct Foo;\n \n trait Bar { }\n@@ -204,6 +412,7 @@ trait Bar { }\n unsafe impl Bar for Foo { }\n // this will compile\n impl Bar for Foo { }\n+```\n \n \"##,\n \n@@ -212,6 +421,7 @@ Unsafe traits must have unsafe implementations. This error occurs when an\n implementation for an unsafe trait isn't marked as unsafe. This may be resolved\n by marking the unsafe implementation as unsafe.\n \n+```\n struct Foo;\n \n unsafe trait Bar { }\n@@ -220,9 +430,28 @@ unsafe trait Bar { }\n impl Bar for Foo { }\n // this will compile\n unsafe impl Bar for Foo { }\n+```\n \n \"##,\n \n+E0201: r##\"\n+It is an error to define a method--a trait method or an inherent method--more\n+than once.\n+\n+For example,\n+\n+```\n+struct Foo(u8);\n+\n+impl Foo {\n+    fn bar() {}\n+\n+    // error: duplicate method\n+    fn bar(&self) -> bool { self.0 > 5 }\n+}\n+```\n+\"##,\n+\n E0204: r##\"\n An attempt to implement the `Copy` trait for a struct failed because one of the\n fields does not implement `Copy`. To fix this, you must implement `Copy` for the\n@@ -354,6 +583,55 @@ const B: [u32; foo()] = [];\n use std::{f64, u8};\n const C: [u32; u8::MAX + f64::EPSILON] = [];\n ```\n+\"##,\n+\n+E0322: r##\"\n+The `Sized` trait is a special trait built-in to the compiler for types with a\n+constant size known at compile-time. This trait is automatically implemented\n+for types as needed by the compiler, and it is currently disallowed to\n+explicitly implement it for a type.\n+\"##,\n+\n+E0368: r##\"\n+This error indicates that a binary assignment operator like `+=` or `^=` was\n+applied to the wrong types.\n+\n+A couple examples of this are as follows:\n+\n+```\n+let mut x: u16 = 5;\n+x ^= true; // error, `^=` cannot be applied to types `u16` and `bool`\n+x += ();   // error, `+=` cannot be applied to types `u16` and `()`\n+```\n+\n+Another problem you might be facing is this: suppose you've overloaded the `+`\n+operator for some type `Foo` by implementing the `std::ops::Add` trait for\n+`Foo`, but you find that using `+=` does not work, as in this example:\n+\n+```\n+use std::ops::Add;\n+\n+struct Foo(u32);\n+\n+impl Add for Foo {\n+    type Output = Foo;\n+\n+    fn add(self, rhs: Foo) -> Foo {\n+        Foo(self.0 + rhs.0)\n+    }\n+}\n+\n+fn main() {\n+    let mut x: Foo = Foo(5);\n+    x += Foo(7); // error, `+= cannot be applied to types `Foo` and `Foo`\n+}\n+```\n+\n+This is because the binary assignment operators currently do not work off of\n+traits, so it is not possible to overload them. See [RFC 953] for a proposal\n+to change this.\n+\n+[RFC 953]: https://github.com/rust-lang/rfcs/pull/953\n \"##\n \n }\n@@ -374,17 +652,12 @@ register_diagnostics! {\n     E0040, // explicit use of destructor method\n     E0044, // foreign items may not have type parameters\n     E0045, // variadic function must have C calling convention\n-    E0049,\n-    E0050,\n-    E0053,\n     E0055, // method has an incompatible type for trait\n     E0057, // method has an incompatible type for trait\n     E0059,\n     E0060,\n     E0061,\n-    E0066,\n     E0068,\n-    E0069,\n     E0070,\n     E0071,\n     E0072,\n@@ -407,8 +680,6 @@ register_diagnostics! {\n     E0102,\n     E0103,\n     E0104,\n-    E0106,\n-    E0107,\n     E0116,\n     E0117,\n     E0118,\n@@ -426,7 +697,6 @@ register_diagnostics! {\n     E0159,\n     E0163,\n     E0164,\n-    E0166,\n     E0167,\n     E0168,\n     E0172,\n@@ -448,7 +718,6 @@ register_diagnostics! {\n     E0194,\n     E0195, // lifetime parameters or bounds on method do not match the trait declaration\n     E0196, // cannot determine a type for this closure\n-    E0201, // duplicate method in trait impl\n     E0202, // associated items are not allowed in inherent impls\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n@@ -479,7 +748,7 @@ register_diagnostics! {\n     E0231, // only named substitution parameters are allowed\n     E0232, // this attribute must have a value\n     E0233,\n-    E0234, // `for` loop expression has type which does not implement the `Iterator` trait\n+    E0234,\n     E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n@@ -496,7 +765,6 @@ register_diagnostics! {\n     E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n-    E0322, // cannot implement Sized explicitly\n     E0323, // implemented an associated const when another trait item expected\n     E0324, // implemented a method when another trait item expected\n     E0325, // implemented an associated type when another trait item expected\n@@ -505,7 +773,6 @@ register_diagnostics! {\n     E0328, // cannot implement Unsize explicitly\n     E0366, // dropck forbid specialization to concrete type or region\n     E0367, // dropck forbid specialization to predicate not in struct/enum\n-    E0368, // binary operation `<op>=` cannot be applied to types\n     E0369, // binary operation `<op>` cannot be applied to types\n     E0371, // impl Trait for Trait is illegal\n     E0372, // impl Trait for Trait where Trait is not object safe"}, {"sha": "126ef38b9188fc657c3ca386a28a704239d1d866", "filename": "src/libstd/env.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -243,6 +243,17 @@ impl Error for VarError {\n /// Sets the environment variable `k` to the value `v` for the currently running\n /// process.\n ///\n+/// Note that while concurrent access to environment variables is safe in Rust,\n+/// some platforms only expose inherently unsafe non-threadsafe APIs for\n+/// inspecting the environment. As a result extra care needs to be taken when\n+/// auditing calls to unsafe external FFI functions to ensure that any external\n+/// environment accesses are properly synchronized with accesses in Rust.\n+///\n+/// Discussion of this unsafety on Unix may be found in:\n+///\n+///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n+///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n+///\n /// # Examples\n ///\n /// ```\n@@ -260,6 +271,17 @@ pub fn set_var<K: AsRef<OsStr>, V: AsRef<OsStr>>(k: K, v: V) {\n \n /// Removes an environment variable from the environment of the currently running process.\n ///\n+/// Note that while concurrent access to environment variables is safe in Rust,\n+/// some platforms only expose inherently unsafe non-threadsafe APIs for\n+/// inspecting the environment. As a result extra care needs to be taken when\n+/// auditing calls to unsafe external FFI functions to ensure that any external\n+/// environment accesses are properly synchronized with accesses in Rust.\n+///\n+/// Discussion of this unsafety on Unix may be found in:\n+///\n+///  - [Austin Group Bugzilla](http://austingroupbugs.net/view.php?id=188)\n+///  - [GNU C library Bugzilla](https://sourceware.org/bugzilla/show_bug.cgi?id=15607#c2)\n+///\n /// # Examples\n ///\n /// ```"}, {"sha": "220a0ba5755f0c0e5584ab0c744ae6c2c045b099", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -28,7 +28,7 @@\n //!\n //! The standard library is minimal, a set of battle-tested\n //! core types and shared abstractions for the [broader Rust\n-//! ecosystem][https://crates.io] to build on.\n+//! ecosystem](https://crates.io) to build on.\n //!\n //! The [primitive types](#primitives), though not defined in the\n //! standard library, are documented here, as are the predefined"}, {"sha": "8da917916e5cd5945ba82471ba2dd82c90765994", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -69,20 +69,20 @@ pub struct Condvar { inner: Box<StaticCondvar> }\n /// # Examples\n ///\n /// ```\n-/// # #![feature(std_misc)]\n+/// # #![feature(static_condvar)]\n /// use std::sync::{StaticCondvar, CONDVAR_INIT};\n ///\n /// static CVAR: StaticCondvar = CONDVAR_INIT;\n /// ```\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n pub struct StaticCondvar {\n     inner: sys::Condvar,\n     mutex: AtomicUsize,\n }\n \n /// Constant initializer for a statically allocated condition variable.\n-#[unstable(feature = \"std_misc\",\n+#[unstable(feature = \"static_condvar\",\n            reason = \"may be merged with Condvar in the future\")]\n pub const CONDVAR_INIT: StaticCondvar = StaticCondvar {\n     inner: sys::CONDVAR_INIT,\n@@ -161,6 +161,30 @@ impl Condvar {\n         }\n     }\n \n+    /// Waits on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// The semantics of this function are equivalent to `wait()` except that\n+    /// the thread will be blocked for roughly no longer than `dur`. This\n+    /// method should not be used for precise timing due to anomalies such as\n+    /// preemption or platform differences that may not cause the maximum\n+    /// amount of time waited to be precisely `dur`.\n+    ///\n+    /// The returned boolean is `false` only if the timeout is known\n+    /// to have elapsed.\n+    ///\n+    /// Like `wait`, the lock specified will be re-acquired when this function\n+    /// returns, regardless of whether the timeout elapsed or not.\n+    #[unstable(feature = \"wait_timeout\", reason = \"waiting for Duration\")]\n+    pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n+                               dur: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        unsafe {\n+            let me: &'static Condvar = &*(self as *const _);\n+            me.inner.wait_timeout(guard, dur)\n+        }\n+    }\n+\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n@@ -214,7 +238,7 @@ impl StaticCondvar {\n     /// notification.\n     ///\n     /// See `Condvar::wait`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait<'a, T>(&'static self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n@@ -235,14 +259,27 @@ impl StaticCondvar {\n     /// specified duration.\n     ///\n     /// See `Condvar::wait_timeout`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_ms<'a, T>(&'static self, guard: MutexGuard<'a, T>, ms: u32)\n                                   -> LockResult<(MutexGuard<'a, T>, bool)> {\n+        self.wait_timeout(guard, Duration::from_millis(ms as u64))\n+    }\n+\n+    /// Waits on this condition variable for a notification, timing out after a\n+    /// specified duration.\n+    ///\n+    /// See `Condvar::wait_timeout`.\n+    #[unstable(feature = \"static_condvar\",\n+               reason = \"may be merged with Condvar in the future\")]\n+    pub fn wait_timeout<'a, T>(&'static self,\n+                               guard: MutexGuard<'a, T>,\n+                               timeout: Duration)\n+                               -> LockResult<(MutexGuard<'a, T>, bool)> {\n         let (poisoned, success) = unsafe {\n             let lock = mutex::guard_lock(&guard);\n             self.verify(lock);\n-            let success = self.inner.wait_timeout(lock, Duration::milliseconds(ms as i64));\n+            let success = self.inner.wait_timeout(lock, timeout);\n             (mutex::guard_poison(&guard).get(), success)\n         };\n         if poisoned {\n@@ -259,15 +296,16 @@ impl StaticCondvar {\n     /// passed and the function returns `false`.\n     ///\n     /// See `Condvar::wait_timeout_with`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn wait_timeout_with<'a, T, F>(&'static self,\n                                        guard: MutexGuard<'a, T>,\n                                        dur: Duration,\n                                        mut f: F)\n                                        -> LockResult<(MutexGuard<'a, T>, bool)>\n             where F: FnMut(LockResult<&mut T>) -> bool {\n-        // This could be made more efficient by pushing the implementation into sys::condvar\n+        // This could be made more efficient by pushing the implementation into\n+        // sys::condvar\n         let start = SteadyTime::now();\n         let mut guard_result: LockResult<MutexGuard<'a, T>> = Ok(guard);\n         while !f(guard_result\n@@ -277,12 +315,15 @@ impl StaticCondvar {\n             let now = SteadyTime::now();\n             let consumed = &now - &start;\n             let guard = guard_result.unwrap_or_else(|e| e.into_inner());\n-            let res = self.wait_timeout_ms(guard, (dur - consumed).num_milliseconds() as u32);\n-            let (new_guard_result, no_timeout) = match res {\n-                Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n-                Err(err) => {\n-                    let (new_guard, no_timeout) = err.into_inner();\n-                    (Err(PoisonError::new(new_guard)), no_timeout)\n+            let (new_guard_result, no_timeout) = if consumed > dur {\n+                (Ok(guard), false)\n+            } else {\n+                match self.wait_timeout(guard, dur - consumed) {\n+                    Ok((new_guard, no_timeout)) => (Ok(new_guard), no_timeout),\n+                    Err(err) => {\n+                        let (new_guard, no_timeout) = err.into_inner();\n+                        (Err(PoisonError::new(new_guard)), no_timeout)\n+                    }\n                 }\n             };\n             guard_result = new_guard_result;\n@@ -301,14 +342,14 @@ impl StaticCondvar {\n     /// Wakes up one blocked thread on this condvar.\n     ///\n     /// See `Condvar::notify_one`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_one(&'static self) { unsafe { self.inner.notify_one() } }\n \n     /// Wakes up all blocked threads on this condvar.\n     ///\n     /// See `Condvar::notify_all`.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub fn notify_all(&'static self) { unsafe { self.inner.notify_all() } }\n \n@@ -318,7 +359,7 @@ impl StaticCondvar {\n     /// active users of the condvar, and this also doesn't prevent any future\n     /// users of the condvar. This method is required to be called to not leak\n     /// memory on all platforms.\n-    #[unstable(feature = \"std_misc\",\n+    #[unstable(feature = \"static_condvar\",\n                reason = \"may be merged with Condvar in the future\")]\n     pub unsafe fn destroy(&'static self) {\n         self.inner.destroy()\n@@ -447,7 +488,9 @@ mod tests {\n         static S: AtomicUsize = ATOMIC_USIZE_INIT;\n \n         let g = M.lock().unwrap();\n-        let (g, success) = C.wait_timeout_with(g, Duration::nanoseconds(1000), |_| false).unwrap();\n+        let (g, success) = C.wait_timeout_with(g, Duration::new(0, 1000), |_| {\n+            false\n+        }).unwrap();\n         assert!(!success);\n \n         let (tx, rx) = channel();\n@@ -471,7 +514,8 @@ mod tests {\n         });\n \n         let mut state = 0;\n-        let (_g, success) = C.wait_timeout_with(g, Duration::days(1), |_| {\n+        let day = 24 * 60 * 60;\n+        let (_g, success) = C.wait_timeout_with(g, Duration::new(day, 0), |_| {\n             assert_eq!(state, S.load(Ordering::SeqCst));\n             tx.send(()).unwrap();\n             state += 1;"}, {"sha": "29a13cc6be731549a86f4c29e8ee553981f1b806", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 9, "deletions": 13, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -57,25 +57,20 @@ impl Condvar {\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/src/condition_variable.cpp#L46\n     // https://github.com/llvm-mirror/libcxx/blob/release_35/include/__mutex_base#L367\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n-        if dur <= Duration::zero() {\n-            return false;\n-        }\n-\n-        // First, figure out what time it currently is, in both system and stable time.\n-        // pthread_cond_timedwait uses system time, but we want to report timeout based on stable\n-        // time.\n+        // First, figure out what time it currently is, in both system and\n+        // stable time.  pthread_cond_timedwait uses system time, but we want to\n+        // report timeout based on stable time.\n         let mut sys_now = libc::timeval { tv_sec: 0, tv_usec: 0 };\n         let stable_now = time::SteadyTime::now();\n         let r = ffi::gettimeofday(&mut sys_now, ptr::null_mut());\n         debug_assert_eq!(r, 0);\n \n-        let seconds = dur.num_seconds() as libc::time_t;\n+        let seconds = dur.secs() as libc::time_t;\n         let timeout = match sys_now.tv_sec.checked_add(seconds) {\n             Some(sec) => {\n                 libc::timespec {\n                     tv_sec: sec,\n-                    tv_nsec: (dur - Duration::seconds(dur.num_seconds()))\n-                        .num_nanoseconds().unwrap() as libc::c_long,\n+                    tv_nsec: dur.extra_nanos() as libc::c_long,\n                 }\n             }\n             None => {\n@@ -87,11 +82,12 @@ impl Condvar {\n         };\n \n         // And wait!\n-        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex), &timeout);\n+        let r = ffi::pthread_cond_timedwait(self.inner.get(), mutex::raw(mutex),\n+                                            &timeout);\n         debug_assert!(r == libc::ETIMEDOUT || r == 0);\n \n-        // ETIMEDOUT is not a totally reliable method of determining timeout due to clock shifts,\n-        // so do the check ourselves\n+        // ETIMEDOUT is not a totally reliable method of determining timeout due\n+        // to clock shifts, so do the check ourselves\n         &time::SteadyTime::now() - &stable_now < dur\n     }\n "}, {"sha": "0cb5a06e6b62f04544193bea70316bc7001e7d7a", "filename": "src/libstd/sys/unix/thread.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fthread.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -129,14 +129,9 @@ impl Thread {\n     }\n \n     pub fn sleep(dur: Duration) {\n-        if dur < Duration::zero() {\n-            return Thread::yield_now()\n-        }\n-        let seconds = dur.num_seconds();\n-        let ns = dur - Duration::seconds(seconds);\n         let mut ts = libc::timespec {\n-            tv_sec: seconds as libc::time_t,\n-            tv_nsec: ns.num_nanoseconds().unwrap() as libc::c_long,\n+            tv_sec: dur.secs() as libc::time_t,\n+            tv_nsec: dur.extra_nanos() as libc::c_long,\n         };\n \n         // If we're awoken with a signal then the return value will be -1 and"}, {"sha": "16dfd3eebd02e5f9ccc98502441fa7a34947af8e", "filename": "src/libstd/sys/unix/time.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftime.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,12 +10,15 @@\n \n pub use self::inner::SteadyTime;\n \n+const NSEC_PER_SEC: u64 = 1_000_000_000;\n+\n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n     use sync::{Once, ONCE_INIT};\n+    use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n         t: u64\n@@ -32,11 +35,6 @@ mod inner {\n                 t: unsafe { mach_absolute_time() },\n             }\n         }\n-\n-        pub fn ns(&self) -> u64 {\n-            let info = info();\n-            self.t * info.numer as u64 / info.denom as u64\n-        }\n     }\n \n     fn info() -> &'static libc::mach_timebase_info {\n@@ -59,8 +57,9 @@ mod inner {\n \n         fn sub(self, other: &SteadyTime) -> Duration {\n             let info = info();\n-            let diff = self.t as i64 - other.t as i64;\n-            Duration::nanoseconds(diff * info.numer as i64 / info.denom as i64)\n+            let diff = self.t as u64 - other.t as u64;\n+            let nanos = diff * info.numer as u64 / info.denom as u64;\n+            Duration::new(nanos / NSEC_PER_SEC, (nanos % NSEC_PER_SEC) as u32)\n         }\n     }\n }\n@@ -70,8 +69,7 @@ mod inner {\n     use libc;\n     use time::Duration;\n     use ops::Sub;\n-\n-    const NSEC_PER_SEC: i64 = 1_000_000_000;\n+    use super::NSEC_PER_SEC;\n \n     pub struct SteadyTime {\n         t: libc::timespec,\n@@ -104,23 +102,19 @@ mod inner {\n             }\n             t\n         }\n-\n-        pub fn ns(&self) -> u64 {\n-            self.t.tv_sec as u64 * NSEC_PER_SEC as u64 + self.t.tv_nsec as u64\n-        }\n     }\n \n     impl<'a> Sub for &'a SteadyTime {\n         type Output = Duration;\n \n         fn sub(self, other: &SteadyTime) -> Duration {\n             if self.t.tv_nsec >= other.t.tv_nsec {\n-                Duration::seconds(self.t.tv_sec as i64 - other.t.tv_sec as i64) +\n-                    Duration::nanoseconds(self.t.tv_nsec as i64 - other.t.tv_nsec as i64)\n+                Duration::new(self.t.tv_sec as u64 - other.t.tv_sec as u64,\n+                              self.t.tv_nsec as u32 - other.t.tv_nsec as u32)\n             } else {\n-                Duration::seconds(self.t.tv_sec as i64 - 1 - other.t.tv_sec as i64) +\n-                    Duration::nanoseconds(self.t.tv_nsec as i64 + NSEC_PER_SEC -\n-                                          other.t.tv_nsec as i64)\n+                Duration::new(self.t.tv_sec as u64 - 1 - other.t.tv_sec as u64,\n+                              self.t.tv_nsec as u32 + (NSEC_PER_SEC as u32) -\n+                                          other.t.tv_nsec as u32)\n             }\n         }\n     }"}, {"sha": "8bb2326e4d6b9dc52d713a0a3347d4f3f22d085a", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -42,7 +42,7 @@ impl Condvar {\n     pub unsafe fn wait_timeout(&self, mutex: &Mutex, dur: Duration) -> bool {\n         let r = ffi::SleepConditionVariableSRW(self.inner.get(),\n                                                mutex::raw(mutex),\n-                                               dur.num_milliseconds() as DWORD,\n+                                               super::dur2timeout(dur),\n                                                0);\n         if r == 0 {\n             const ERROR_TIMEOUT: DWORD = 0x5B4;"}, {"sha": "6b7bff2c1c6f82929df83458d5ad68be66bd54a3", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -20,6 +20,7 @@ use libc;\n use num::Zero;\n use os::windows::ffi::{OsStrExt, OsStringExt};\n use path::PathBuf;\n+use time::Duration;\n \n pub mod backtrace;\n pub mod c;\n@@ -151,6 +152,27 @@ fn cvt<I: PartialEq + Zero>(i: I) -> io::Result<I> {\n     }\n }\n \n+fn dur2timeout(dur: Duration) -> libc::DWORD {\n+    // Note that a duration is a (u64, u32) (seconds, nanoseconds) pair, and the\n+    // timeouts in windows APIs are typically u32 milliseconds. To translate, we\n+    // have two pieces to take care of:\n+    //\n+    // * Nanosecond precision is rounded up\n+    // * Greater than u32::MAX milliseconds (50 days) is rounded up to INFINITE\n+    //   (never time out).\n+    dur.secs().checked_mul(1000).and_then(|ms| {\n+        ms.checked_add((dur.extra_nanos() as u64) / 1_000_000)\n+    }).and_then(|ms| {\n+        ms.checked_add(if dur.extra_nanos() % 1_000_000 > 0 {1} else {0})\n+    }).map(|ms| {\n+        if ms > <libc::DWORD>::max_value() as u64 {\n+            libc::INFINITE\n+        } else {\n+            ms as libc::DWORD\n+        }\n+    }).unwrap_or(libc::INFINITE)\n+}\n+\n fn ms_to_filetime(ms: u64) -> libc::FILETIME {\n     // A FILETIME is a count of 100 nanosecond intervals, so we multiply by\n     // 10000 b/c there are 10000 intervals in 1 ms"}, {"sha": "50dfee4ab1011d6a58581404da327ac151c123d9", "filename": "src/libstd/sys/windows/thread.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fthread.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -80,15 +80,7 @@ impl Thread {\n \n     pub fn sleep(dur: Duration) {\n         unsafe {\n-            if dur < Duration::zero() {\n-                return Thread::yield_now()\n-            }\n-            let ms = dur.num_milliseconds();\n-            // if we have a fractional number of milliseconds then add an extra\n-            // millisecond to sleep for\n-            let extra = dur - Duration::milliseconds(ms);\n-            let ms = ms + if extra.is_zero() {0} else {1};\n-            c::Sleep(ms as DWORD);\n+            c::Sleep(super::dur2timeout(dur))\n         }\n     }\n }"}, {"sha": "e64df54a0fa035bc7285e3a08323430cac480d95", "filename": "src/libstd/sys/windows/time.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftime.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -12,7 +12,7 @@ use ops::Sub;\n use time::Duration;\n use sync::{Once, ONCE_INIT};\n \n-const NANOS_PER_SEC: i64 = 1_000_000_000;\n+const NANOS_PER_SEC: u64 = 1_000_000_000;\n \n pub struct SteadyTime {\n     t: libc::LARGE_INTEGER,\n@@ -24,10 +24,6 @@ impl SteadyTime {\n         unsafe { libc::QueryPerformanceCounter(&mut t.t); }\n         t\n     }\n-\n-    pub fn ns(&self) -> u64 {\n-        mul_div_i64(self.t as i64, NANOS_PER_SEC, frequency() as i64) as u64\n-    }\n }\n \n fn frequency() -> libc::LARGE_INTEGER {\n@@ -46,15 +42,16 @@ impl<'a> Sub for &'a SteadyTime {\n     type Output = Duration;\n \n     fn sub(self, other: &SteadyTime) -> Duration {\n-        let diff = self.t as i64 - other.t as i64;\n-        Duration::nanoseconds(mul_div_i64(diff, NANOS_PER_SEC, frequency() as i64))\n+        let diff = self.t as u64 - other.t as u64;\n+        let nanos = mul_div_u64(diff, NANOS_PER_SEC, frequency() as u64);\n+        Duration::new(nanos / NANOS_PER_SEC, (nanos % NANOS_PER_SEC) as u32)\n     }\n }\n \n // Computes (value*numer)/denom without overflow, as long as both\n // (numer*denom) and the overall result fit into i64 (which is the case\n // for our time conversions).\n-fn mul_div_i64(value: i64, numer: i64, denom: i64) -> i64 {\n+fn mul_div_u64(value: u64, numer: u64, denom: u64) -> u64 {\n     let q = value / denom;\n     let r = value % denom;\n     // Decompose value as (value/denom*denom + value%denom),\n@@ -65,9 +62,6 @@ fn mul_div_i64(value: i64, numer: i64, denom: i64) -> i64 {\n \n #[test]\n fn test_muldiv() {\n-    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64(-1_000_000_000_001, 1_000_000_000, 1_000_000), -1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64(-1_000_000_000_001,-1_000_000_000, 1_000_000),  1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64( 1_000_000_000_001, 1_000_000_000,-1_000_000), -1_000_000_000_001_000);\n-    assert_eq!(mul_div_i64( 1_000_000_000_001,-1_000_000_000,-1_000_000),  1_000_000_000_001_000);\n+    assert_eq!(mul_div_u64( 1_000_000_000_001, 1_000_000_000, 1_000_000),\n+               1_000_000_000_001_000);\n }"}, {"sha": "7c8cb5b01c1088bfe9f176a6f738d812f5cf1e73", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -482,7 +482,23 @@ pub fn catch_panic<F, R>(f: F) -> Result<R>\n /// spurious wakeup.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn sleep_ms(ms: u32) {\n-    imp::Thread::sleep(Duration::milliseconds(ms as i64))\n+    sleep(Duration::from_millis(ms as u64))\n+}\n+\n+/// Puts the current thread to sleep for the specified amount of time.\n+///\n+/// The thread may sleep longer than the duration specified due to scheduling\n+/// specifics or platform-dependent functionality.\n+///\n+/// # Platform behavior\n+///\n+/// On Unix platforms this function will not return early due to a\n+/// signal being received or a spurious wakeup. Platforms which do not support\n+/// nanosecond precision for sleeping will have `dur` rounded up to the nearest\n+/// granularity of time they can sleep for.\n+#[unstable(feature = \"thread_sleep\", reason = \"waiting on Duration\")]\n+pub fn sleep(dur: Duration) {\n+    imp::Thread::sleep(dur)\n }\n \n /// Blocks unless or until the current thread's token is made available (may wake spuriously).\n@@ -508,18 +524,38 @@ pub fn park() {\n /// the specified duration has been reached (may wake spuriously).\n ///\n /// The semantics of this function are equivalent to `park()` except that the\n-/// thread will be blocked for roughly no longer than *duration*. This method\n+/// thread will be blocked for roughly no longer than *ms*. This method\n /// should not be used for precise timing due to anomalies such as\n /// preemption or platform differences that may not cause the maximum\n-/// amount of time waited to be precisely *duration* long.\n+/// amount of time waited to be precisely *ms* long.\n ///\n /// See the module doc for more detail.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn park_timeout_ms(ms: u32) {\n+    park_timeout(Duration::from_millis(ms as u64))\n+}\n+\n+/// Blocks unless or until the current thread's token is made available or\n+/// the specified duration has been reached (may wake spuriously).\n+///\n+/// The semantics of this function are equivalent to `park()` except that the\n+/// thread will be blocked for roughly no longer than *dur*. This method\n+/// should not be used for precise timing due to anomalies such as\n+/// preemption or platform differences that may not cause the maximum\n+/// amount of time waited to be precisely *dur* long.\n+///\n+/// See the module doc for more detail.\n+///\n+/// # Platform behavior\n+///\n+/// Platforms which do not support nanosecond precision for sleeping will have\n+/// `dur` rounded up to the nearest granularity of time they can sleep for.\n+#[unstable(feature = \"park_timeout\", reason = \"waiting on Duration\")]\n+pub fn park_timeout(dur: Duration) {\n     let thread = current();\n     let mut guard = thread.inner.lock.lock().unwrap();\n     if !*guard {\n-        let (g, _) = thread.inner.cvar.wait_timeout_ms(guard, ms).unwrap();\n+        let (g, _) = thread.inner.cvar.wait_timeout(guard, dur).unwrap();\n         guard = g;\n     }\n     *guard = false;"}, {"sha": "8001df29d1fc725c4ba4f646057edf0129dc7d1a", "filename": "src/libstd/time/duration.rs", "status": "modified", "additions": 170, "deletions": 494, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Ftime%2Fduration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Ftime%2Fduration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fduration.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,589 +10,265 @@\n \n //! Temporal quantification\n \n-#![unstable(feature = \"std_misc\")]\n+#![unstable(feature = \"duration\", reason = \"recently added API per RFC 1040\")]\n \n use prelude::v1::*;\n \n-use {fmt, i64};\n-use ops::{Add, Sub, Mul, Div, Neg};\n-\n-/// The number of nanoseconds in a microsecond.\n-const NANOS_PER_MICRO: i32 = 1000;\n-/// The number of nanoseconds in a millisecond.\n-const NANOS_PER_MILLI: i32 = 1000_000;\n-/// The number of nanoseconds in seconds.\n-const NANOS_PER_SEC: i32 = 1_000_000_000;\n-/// The number of microseconds per second.\n-const MICROS_PER_SEC: i64 = 1000_000;\n-/// The number of milliseconds per second.\n-const MILLIS_PER_SEC: i64 = 1000;\n-/// The number of seconds in a minute.\n-const SECS_PER_MINUTE: i64 = 60;\n-/// The number of seconds in an hour.\n-const SECS_PER_HOUR: i64 = 3600;\n-/// The number of (non-leap) seconds in days.\n-const SECS_PER_DAY: i64 = 86400;\n-/// The number of (non-leap) seconds in a week.\n-const SECS_PER_WEEK: i64 = 604800;\n-\n-macro_rules! try_opt {\n-    ($e:expr) => (match $e { Some(v) => v, None => return None })\n-}\n-\n-\n-/// ISO 8601 time duration with nanosecond precision.\n-/// This also allows for the negative duration; see individual methods for details.\n-#[unstable(feature = \"std_misc\")]\n+use fmt;\n+use ops::{Add, Sub, Mul, Div};\n+use sys::time::SteadyTime;\n+\n+const NANOS_PER_SEC: u32 = 1_000_000_000;\n+const NANOS_PER_MILLI: u32 = 1_000_000;\n+const MILLIS_PER_SEC: u64 = 1_000;\n+\n+/// A duration type to represent a span of time, typically used for system\n+/// timeouts.\n+///\n+/// Each duration is composed of a number of seconds and nanosecond precision.\n+/// APIs binding a system timeout will typically round up the nanosecond\n+/// precision if the underlying system does not support that level of precision.\n+///\n+/// Durations implement many common traits, including `Add`, `Sub`, and other\n+/// ops traits. Currently a duration may only be inspected for its number of\n+/// seconds and its nanosecond precision.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// #![feature(duration)]\n+/// use std::time::Duration;\n+///\n+/// let five_seconds = Duration::new(5, 0);\n+/// let five_seconds_and_five_nanos = five_seconds + Duration::new(0, 5);\n+///\n+/// assert_eq!(five_seconds_and_five_nanos.secs(), 5);\n+/// assert_eq!(five_seconds_and_five_nanos.extra_nanos(), 5);\n+///\n+/// let ten_millis = Duration::from_millis(10);\n+/// ```\n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n pub struct Duration {\n-    secs: i64,\n-    nanos: i32, // Always 0 <= nanos < NANOS_PER_SEC\n+    secs: u64,\n+    nanos: u32, // Always 0 <= nanos < NANOS_PER_SEC\n }\n \n-/// The minimum possible `Duration`: `i64::MIN` milliseconds.\n-#[unstable(feature = \"std_misc\")]\n-pub const MIN: Duration = Duration {\n-    secs: i64::MIN / MILLIS_PER_SEC - 1,\n-    nanos: NANOS_PER_SEC + (i64::MIN % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n-};\n-\n-/// The maximum possible `Duration`: `i64::MAX` milliseconds.\n-#[unstable(feature = \"std_misc\")]\n-pub const MAX: Duration = Duration {\n-    secs: i64::MAX / MILLIS_PER_SEC,\n-    nanos: (i64::MAX % MILLIS_PER_SEC) as i32 * NANOS_PER_MILLI\n-};\n-\n impl Duration {\n-    /// Makes a new `Duration` with given number of weeks.\n-    /// Equivalent to `Duration::seconds(weeks * 7 * 24 * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn weeks(weeks: i64) -> Duration {\n-        let secs = weeks.checked_mul(SECS_PER_WEEK).expect(\"Duration::weeks out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of days.\n-    /// Equivalent to `Duration::seconds(days * 24 * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn days(days: i64) -> Duration {\n-        let secs = days.checked_mul(SECS_PER_DAY).expect(\"Duration::days out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of hours.\n-    /// Equivalent to `Duration::seconds(hours * 60 * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn hours(hours: i64) -> Duration {\n-        let secs = hours.checked_mul(SECS_PER_HOUR).expect(\"Duration::hours ouf of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of minutes.\n-    /// Equivalent to `Duration::seconds(minutes * 60)` with overflow checks.\n-    /// Panics when the duration is out of bounds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn minutes(minutes: i64) -> Duration {\n-        let secs = minutes.checked_mul(SECS_PER_MINUTE).expect(\"Duration::minutes out of bounds\");\n-        Duration::seconds(secs)\n-    }\n-\n-    /// Makes a new `Duration` with given number of seconds.\n-    /// Panics when the duration is more than `i64::MAX` milliseconds\n-    /// or less than `i64::MIN` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn seconds(seconds: i64) -> Duration {\n-        let d = Duration { secs: seconds, nanos: 0 };\n-        if d < MIN || d > MAX {\n-            panic!(\"Duration::seconds out of bounds\");\n-        }\n-        d\n-    }\n-\n-    /// Makes a new `Duration` with given number of milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn milliseconds(milliseconds: i64) -> Duration {\n-        let (secs, millis) = div_mod_floor_64(milliseconds, MILLIS_PER_SEC);\n-        let nanos = millis as i32 * NANOS_PER_MILLI;\n+    /// Crates a new `Duration` from the specified number of seconds and\n+    /// additional nanosecond precision.\n+    ///\n+    /// If the nanoseconds is greater than 1 billion (the number of nanoseconds\n+    /// in a second), then it will carry over into the seconds provided.\n+    pub fn new(secs: u64, nanos: u32) -> Duration {\n+        let secs = secs + (nanos / NANOS_PER_SEC) as u64;\n+        let nanos = nanos % NANOS_PER_SEC;\n         Duration { secs: secs, nanos: nanos }\n     }\n \n-    /// Makes a new `Duration` with given number of microseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn microseconds(microseconds: i64) -> Duration {\n-        let (secs, micros) = div_mod_floor_64(microseconds, MICROS_PER_SEC);\n-        let nanos = micros as i32 * NANOS_PER_MICRO;\n-        Duration { secs: secs, nanos: nanos }\n-    }\n-\n-    /// Makes a new `Duration` with given number of nanoseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn nanoseconds(nanos: i64) -> Duration {\n-        let (secs, nanos) = div_mod_floor_64(nanos, NANOS_PER_SEC as i64);\n-        Duration { secs: secs, nanos: nanos as i32 }\n-    }\n-\n     /// Runs a closure, returning the duration of time it took to run the\n     /// closure.\n-    #[unstable(feature = \"std_misc\")]\n+    #[unstable(feature = \"duration_span\",\n+               reason = \"unsure if this is the right API or whether it should \\\n+                         wait for a more general \\\"moment in time\\\" \\\n+                         abstraction\")]\n     pub fn span<F>(f: F) -> Duration where F: FnOnce() {\n-        let before = super::precise_time_ns();\n+        let start = SteadyTime::now();\n         f();\n-        Duration::nanoseconds((super::precise_time_ns() - before) as i64)\n-    }\n-\n-    /// Returns the total number of whole weeks in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_weeks(&self) -> i64 {\n-        self.num_days() / 7\n-    }\n-\n-    /// Returns the total number of whole days in the duration.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_days(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_DAY\n-    }\n-\n-    /// Returns the total number of whole hours in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_hours(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_HOUR\n-    }\n-\n-    /// Returns the total number of whole minutes in the duration.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_minutes(&self) -> i64 {\n-        self.num_seconds() / SECS_PER_MINUTE\n-    }\n-\n-    /// Returns the total number of whole seconds in the duration.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_seconds(&self) -> i64 {\n-        // If secs is negative, nanos should be subtracted from the duration.\n-        if self.secs < 0 && self.nanos > 0 {\n-            self.secs + 1\n-        } else {\n-            self.secs\n-        }\n-    }\n-\n-    /// Returns the number of nanoseconds such that\n-    /// `nanos_mod_sec() + num_seconds() * NANOS_PER_SEC` is the total number of\n-    /// nanoseconds in the duration.\n-    fn nanos_mod_sec(&self) -> i32 {\n-        if self.secs < 0 && self.nanos > 0 {\n-            self.nanos - NANOS_PER_SEC\n-        } else {\n-            self.nanos\n-        }\n-    }\n-\n-    /// Returns the total number of whole milliseconds in the duration,\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_milliseconds(&self) -> i64 {\n-        // A proper Duration will not overflow, because MIN and MAX are defined\n-        // such that the range is exactly i64 milliseconds.\n-        let secs_part = self.num_seconds() * MILLIS_PER_SEC;\n-        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MILLI;\n-        secs_part + nanos_part as i64\n-    }\n-\n-    /// Returns the total number of whole microseconds in the duration,\n-    /// or `None` on overflow (exceeding 2^63 microseconds in either direction).\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_microseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(MICROS_PER_SEC));\n-        let nanos_part = self.nanos_mod_sec() / NANOS_PER_MICRO;\n-        secs_part.checked_add(nanos_part as i64)\n+        &SteadyTime::now() - &start\n     }\n \n-    /// Returns the total number of whole nanoseconds in the duration,\n-    /// or `None` on overflow (exceeding 2^63 nanoseconds in either direction).\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn num_nanoseconds(&self) -> Option<i64> {\n-        let secs_part = try_opt!(self.num_seconds().checked_mul(NANOS_PER_SEC as i64));\n-        let nanos_part = self.nanos_mod_sec();\n-        secs_part.checked_add(nanos_part as i64)\n+    /// Creates a new `Duration` from the specified number of seconds.\n+    pub fn from_secs(secs: u64) -> Duration {\n+        Duration { secs: secs, nanos: 0 }\n     }\n \n-    /// Add two durations, returning `None` if overflow occurred.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn checked_add(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_add(rhs.secs));\n-        let mut nanos = self.nanos + rhs.nanos;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_add(1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-\n-    /// Subtract two durations, returning `None` if overflow occurred.\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn checked_sub(&self, rhs: &Duration) -> Option<Duration> {\n-        let mut secs = try_opt!(self.secs.checked_sub(rhs.secs));\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs = try_opt!(secs.checked_sub(1));\n-        }\n-        let d = Duration { secs: secs, nanos: nanos };\n-        // Even if d is within the bounds of i64 seconds,\n-        // it might still overflow i64 milliseconds.\n-        if d < MIN || d > MAX { None } else { Some(d) }\n-    }\n-\n-    /// The minimum possible `Duration`: `i64::MIN` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn min_value() -> Duration { MIN }\n-\n-    /// The maximum possible `Duration`: `i64::MAX` milliseconds.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn max_value() -> Duration { MAX }\n-\n-    /// A duration where the stored seconds and nanoseconds are equal to zero.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn zero() -> Duration {\n-        Duration { secs: 0, nanos: 0 }\n-    }\n-\n-    /// Returns `true` if the duration equals `Duration::zero()`.\n-    #[inline]\n-    #[unstable(feature = \"std_misc\")]\n-    pub fn is_zero(&self) -> bool {\n-        self.secs == 0 && self.nanos == 0\n+    /// Creates a new `Duration` from the specified number of milliseconds.\n+    pub fn from_millis(millis: u64) -> Duration {\n+        let secs = millis / MILLIS_PER_SEC;\n+        let nanos = ((millis % MILLIS_PER_SEC) as u32) * NANOS_PER_MILLI;\n+        Duration { secs: secs, nanos: nanos }\n     }\n-}\n \n-#[unstable(feature = \"std_misc\")]\n-impl Neg for Duration {\n-    type Output = Duration;\n+    /// Returns the number of whole seconds represented by this duration.\n+    ///\n+    /// The extra precision represented by this duration is ignored (e.g. extra\n+    /// nanoseconds are not represented in the returned value).\n+    pub fn secs(&self) -> u64 { self.secs }\n \n-    #[inline]\n-    fn neg(self) -> Duration {\n-        if self.nanos == 0 {\n-            Duration { secs: -self.secs, nanos: 0 }\n-        } else {\n-            Duration { secs: -self.secs - 1, nanos: NANOS_PER_SEC - self.nanos }\n-        }\n-    }\n+    /// Returns the nanosecond precision represented by this duration.\n+    ///\n+    /// This method does **not** return the length of the duration when\n+    /// represented by nanoseconds. The returned number always represents a\n+    /// fractional portion of a second (e.g. it is less than one billion).\n+    pub fn extra_nanos(&self) -> u32 { self.nanos }\n }\n \n-#[unstable(feature = \"std_misc\")]\n impl Add for Duration {\n     type Output = Duration;\n \n     fn add(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs + rhs.secs;\n+        let mut secs = self.secs.checked_add(rhs.secs)\n+                           .expect(\"overflow when adding durations\");\n         let mut nanos = self.nanos + rhs.nanos;\n         if nanos >= NANOS_PER_SEC {\n             nanos -= NANOS_PER_SEC;\n-            secs += 1;\n+            secs = secs.checked_add(1).expect(\"overflow when adding durations\");\n         }\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n impl Sub for Duration {\n     type Output = Duration;\n \n     fn sub(self, rhs: Duration) -> Duration {\n-        let mut secs = self.secs - rhs.secs;\n-        let mut nanos = self.nanos - rhs.nanos;\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n+        let mut secs = self.secs.checked_sub(rhs.secs)\n+                           .expect(\"overflow when subtracting durations\");\n+        let nanos = if self.nanos >= rhs.nanos {\n+            self.nanos - rhs.nanos\n+        } else {\n+            secs = secs.checked_sub(1)\n+                       .expect(\"overflow when subtracting durations\");\n+            self.nanos + NANOS_PER_SEC - rhs.nanos\n+        };\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n-impl Mul<i32> for Duration {\n+impl Mul<u32> for Duration {\n     type Output = Duration;\n \n-    fn mul(self, rhs: i32) -> Duration {\n-        // Multiply nanoseconds as i64, because it cannot overflow that way.\n-        let total_nanos = self.nanos as i64 * rhs as i64;\n-        let (extra_secs, nanos) = div_mod_floor_64(total_nanos, NANOS_PER_SEC as i64);\n-        let secs = self.secs * rhs as i64 + extra_secs;\n-        Duration { secs: secs, nanos: nanos as i32 }\n+    fn mul(self, rhs: u32) -> Duration {\n+        // Multiply nanoseconds as u64, because it cannot overflow that way.\n+        let total_nanos = self.nanos as u64 * rhs as u64;\n+        let extra_secs = total_nanos / (NANOS_PER_SEC as u64);\n+        let nanos = (total_nanos % (NANOS_PER_SEC as u64)) as u32;\n+        let secs = self.secs.checked_mul(rhs as u64)\n+                       .and_then(|s| s.checked_add(extra_secs))\n+                       .expect(\"overflow when multiplying duration\");\n+        debug_assert!(nanos < NANOS_PER_SEC);\n+        Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[unstable(feature = \"std_misc\")]\n-impl Div<i32> for Duration {\n+impl Div<u32> for Duration {\n     type Output = Duration;\n \n-    fn div(self, rhs: i32) -> Duration {\n-        let mut secs = self.secs / rhs as i64;\n-        let carry = self.secs - secs * rhs as i64;\n-        let extra_nanos = carry * NANOS_PER_SEC as i64 / rhs as i64;\n-        let mut nanos = self.nanos / rhs + extra_nanos as i32;\n-        if nanos >= NANOS_PER_SEC {\n-            nanos -= NANOS_PER_SEC;\n-            secs += 1;\n-        }\n-        if nanos < 0 {\n-            nanos += NANOS_PER_SEC;\n-            secs -= 1;\n-        }\n+    fn div(self, rhs: u32) -> Duration {\n+        let secs = self.secs / (rhs as u64);\n+        let carry = self.secs - secs * (rhs as u64);\n+        let extra_nanos = carry * (NANOS_PER_SEC as u64) / (rhs as u64);\n+        let nanos = self.nanos / rhs + (extra_nanos as u32);\n+        debug_assert!(nanos < NANOS_PER_SEC);\n         Duration { secs: secs, nanos: nanos }\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Duration {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // technically speaking, negative duration is not valid ISO 8601,\n-        // but we need to print it anyway.\n-        let (abs, sign) = if self.secs < 0 { (-*self, \"-\") } else { (*self, \"\") };\n-\n-        let days = abs.secs / SECS_PER_DAY;\n-        let secs = abs.secs - days * SECS_PER_DAY;\n-        let hasdate = days != 0;\n-        let hastime = (secs != 0 || abs.nanos != 0) || !hasdate;\n-\n-        try!(write!(f, \"{}P\", sign));\n-\n-        if hasdate {\n-            try!(write!(f, \"{}D\", days));\n-        }\n-        if hastime {\n-            if abs.nanos == 0 {\n-                try!(write!(f, \"T{}S\", secs));\n-            } else if abs.nanos % NANOS_PER_MILLI == 0 {\n-                try!(write!(f, \"T{}.{:03}S\", secs, abs.nanos / NANOS_PER_MILLI));\n-            } else if abs.nanos % NANOS_PER_MICRO == 0 {\n-                try!(write!(f, \"T{}.{:06}S\", secs, abs.nanos / NANOS_PER_MICRO));\n-            } else {\n-                try!(write!(f, \"T{}.{:09}S\", secs, abs.nanos));\n-            }\n+        match (self.secs, self.nanos) {\n+            (s, 0) => write!(f, \"{}s\", s),\n+            (0, n) if n % NANOS_PER_MILLI == 0 => write!(f, \"{}ms\",\n+                                                         n / NANOS_PER_MILLI),\n+            (0, n) if n % 1_000 == 0 => write!(f, \"{}\u00b5s\", n / 1_000),\n+            (0, n) => write!(f, \"{}ns\", n),\n+            (s, n) => write!(f, \"{}.{}s\", s,\n+                             format!(\"{:09}\", n).trim_right_matches('0'))\n         }\n-        Ok(())\n-    }\n-}\n-\n-// Copied from libnum\n-#[inline]\n-fn div_mod_floor_64(this: i64, other: i64) -> (i64, i64) {\n-    (div_floor_64(this, other), mod_floor_64(this, other))\n-}\n-\n-#[inline]\n-fn div_floor_64(this: i64, other: i64) -> i64 {\n-    match div_rem_64(this, other) {\n-        (d, r) if (r > 0 && other < 0)\n-               || (r < 0 && other > 0) => d - 1,\n-        (d, _)                         => d,\n-    }\n-}\n-\n-#[inline]\n-fn mod_floor_64(this: i64, other: i64) -> i64 {\n-    match this % other {\n-        r if (r > 0 && other < 0)\n-          || (r < 0 && other > 0) => r + other,\n-        r                         => r,\n     }\n }\n \n-#[inline]\n-fn div_rem_64(this: i64, other: i64) -> (i64, i64) {\n-    (this / other, this % other)\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use super::{Duration, MIN, MAX};\n-    use {i32, i64};\n-    use option::Option::{Some, None};\n-    use string::ToString;\n+    use prelude::v1::*;\n+    use super::Duration;\n \n     #[test]\n-    fn test_duration() {\n-        assert!(Duration::seconds(1) != Duration::zero());\n-        assert_eq!(Duration::seconds(1) + Duration::seconds(2), Duration::seconds(3));\n-        assert_eq!(Duration::seconds(86399) + Duration::seconds(4),\n-                   Duration::days(1) + Duration::seconds(3));\n-        assert_eq!(Duration::days(10) - Duration::seconds(1000), Duration::seconds(863000));\n-        assert_eq!(Duration::days(10) - Duration::seconds(1000000), Duration::seconds(-136000));\n-        assert_eq!(Duration::days(2) + Duration::seconds(86399) +\n-                   Duration::nanoseconds(1234567890),\n-                   Duration::days(3) + Duration::nanoseconds(234567890));\n-        assert_eq!(-Duration::days(3), Duration::days(-3));\n-        assert_eq!(-(Duration::days(3) + Duration::seconds(70)),\n-                   Duration::days(-4) + Duration::seconds(86400-70));\n+    fn creation() {\n+        assert!(Duration::from_secs(1) != Duration::from_secs(0));\n+        assert_eq!(Duration::from_secs(1) + Duration::from_secs(2),\n+                   Duration::from_secs(3));\n+        assert_eq!(Duration::from_millis(10) + Duration::from_secs(4),\n+                   Duration::new(4, 10 * 1_000_000));\n+        assert_eq!(Duration::from_millis(4000), Duration::new(4, 0));\n     }\n \n     #[test]\n-    fn test_duration_num_days() {\n-        assert_eq!(Duration::zero().num_days(), 0);\n-        assert_eq!(Duration::days(1).num_days(), 1);\n-        assert_eq!(Duration::days(-1).num_days(), -1);\n-        assert_eq!(Duration::seconds(86399).num_days(), 0);\n-        assert_eq!(Duration::seconds(86401).num_days(), 1);\n-        assert_eq!(Duration::seconds(-86399).num_days(), 0);\n-        assert_eq!(Duration::seconds(-86401).num_days(), -1);\n-        assert_eq!(Duration::days(i32::MAX as i64).num_days(), i32::MAX as i64);\n-        assert_eq!(Duration::days(i32::MIN as i64).num_days(), i32::MIN as i64);\n+    fn secs() {\n+        assert_eq!(Duration::new(0, 0).secs(), 0);\n+        assert_eq!(Duration::from_secs(1).secs(), 1);\n+        assert_eq!(Duration::from_millis(999).secs(), 0);\n+        assert_eq!(Duration::from_millis(1001).secs(), 1);\n     }\n \n     #[test]\n-    fn test_duration_num_seconds() {\n-        assert_eq!(Duration::zero().num_seconds(), 0);\n-        assert_eq!(Duration::seconds(1).num_seconds(), 1);\n-        assert_eq!(Duration::seconds(-1).num_seconds(), -1);\n-        assert_eq!(Duration::milliseconds(999).num_seconds(), 0);\n-        assert_eq!(Duration::milliseconds(1001).num_seconds(), 1);\n-        assert_eq!(Duration::milliseconds(-999).num_seconds(), 0);\n-        assert_eq!(Duration::milliseconds(-1001).num_seconds(), -1);\n+    fn nanos() {\n+        assert_eq!(Duration::new(0, 0).extra_nanos(), 0);\n+        assert_eq!(Duration::new(0, 5).extra_nanos(), 5);\n+        assert_eq!(Duration::new(0, 1_000_000_001).extra_nanos(), 1);\n+        assert_eq!(Duration::from_secs(1).extra_nanos(), 0);\n+        assert_eq!(Duration::from_millis(999).extra_nanos(), 999 * 1_000_000);\n+        assert_eq!(Duration::from_millis(1001).extra_nanos(), 1 * 1_000_000);\n     }\n \n     #[test]\n-    fn test_duration_num_milliseconds() {\n-        assert_eq!(Duration::zero().num_milliseconds(), 0);\n-        assert_eq!(Duration::milliseconds(1).num_milliseconds(), 1);\n-        assert_eq!(Duration::milliseconds(-1).num_milliseconds(), -1);\n-        assert_eq!(Duration::microseconds(999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(1001).num_milliseconds(), 1);\n-        assert_eq!(Duration::microseconds(-999).num_milliseconds(), 0);\n-        assert_eq!(Duration::microseconds(-1001).num_milliseconds(), -1);\n-        assert_eq!(Duration::milliseconds(i64::MAX).num_milliseconds(), i64::MAX);\n-        assert_eq!(Duration::milliseconds(i64::MIN).num_milliseconds(), i64::MIN);\n-        assert_eq!(MAX.num_milliseconds(), i64::MAX);\n-        assert_eq!(MIN.num_milliseconds(), i64::MIN);\n+    fn add() {\n+        assert_eq!(Duration::new(0, 0) + Duration::new(0, 1),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(0, 500_000_000) + Duration::new(0, 500_000_001),\n+                   Duration::new(1, 1));\n     }\n \n     #[test]\n-    fn test_duration_num_microseconds() {\n-        assert_eq!(Duration::zero().num_microseconds(), Some(0));\n-        assert_eq!(Duration::microseconds(1).num_microseconds(), Some(1));\n-        assert_eq!(Duration::microseconds(-1).num_microseconds(), Some(-1));\n-        assert_eq!(Duration::nanoseconds(999).num_microseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(1001).num_microseconds(), Some(1));\n-        assert_eq!(Duration::nanoseconds(-999).num_microseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(-1001).num_microseconds(), Some(-1));\n-        assert_eq!(Duration::microseconds(i64::MAX).num_microseconds(), Some(i64::MAX));\n-        assert_eq!(Duration::microseconds(i64::MIN).num_microseconds(), Some(i64::MIN));\n-        assert_eq!(MAX.num_microseconds(), None);\n-        assert_eq!(MIN.num_microseconds(), None);\n-\n-        // overflow checks\n-        const MICROS_PER_DAY: i64 = 86400_000_000;\n-        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY).num_microseconds(),\n-                   Some(i64::MAX / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY).num_microseconds(),\n-                   Some(i64::MIN / MICROS_PER_DAY * MICROS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MAX / MICROS_PER_DAY + 1).num_microseconds(), None);\n-        assert_eq!(Duration::days(i64::MIN / MICROS_PER_DAY - 1).num_microseconds(), None);\n+    fn sub() {\n+        assert_eq!(Duration::new(0, 1) - Duration::new(0, 0),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(0, 500_000_001) - Duration::new(0, 500_000_000),\n+                   Duration::new(0, 1));\n+        assert_eq!(Duration::new(1, 0) - Duration::new(0, 1),\n+                   Duration::new(0, 999_999_999));\n     }\n \n-    #[test]\n-    fn test_duration_num_nanoseconds() {\n-        assert_eq!(Duration::zero().num_nanoseconds(), Some(0));\n-        assert_eq!(Duration::nanoseconds(1).num_nanoseconds(), Some(1));\n-        assert_eq!(Duration::nanoseconds(-1).num_nanoseconds(), Some(-1));\n-        assert_eq!(Duration::nanoseconds(i64::MAX).num_nanoseconds(), Some(i64::MAX));\n-        assert_eq!(Duration::nanoseconds(i64::MIN).num_nanoseconds(), Some(i64::MIN));\n-        assert_eq!(MAX.num_nanoseconds(), None);\n-        assert_eq!(MIN.num_nanoseconds(), None);\n-\n-        // overflow checks\n-        const NANOS_PER_DAY: i64 = 86400_000_000_000;\n-        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY).num_nanoseconds(),\n-                   Some(i64::MAX / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY).num_nanoseconds(),\n-                   Some(i64::MIN / NANOS_PER_DAY * NANOS_PER_DAY));\n-        assert_eq!(Duration::days(i64::MAX / NANOS_PER_DAY + 1).num_nanoseconds(), None);\n-        assert_eq!(Duration::days(i64::MIN / NANOS_PER_DAY - 1).num_nanoseconds(), None);\n+    #[test] #[should_panic]\n+    fn sub_bad1() {\n+        Duration::new(0, 0) - Duration::new(0, 1);\n     }\n \n-    #[test]\n-    fn test_duration_checked_ops() {\n-        assert_eq!(Duration::milliseconds(i64::MAX - 1).checked_add(&Duration::microseconds(999)),\n-                   Some(Duration::milliseconds(i64::MAX - 2) + Duration::microseconds(1999)));\n-        assert!(Duration::milliseconds(i64::MAX).checked_add(&Duration::microseconds(1000))\n-                                                .is_none());\n-\n-        assert_eq!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(0)),\n-                   Some(Duration::milliseconds(i64::MIN)));\n-        assert!(Duration::milliseconds(i64::MIN).checked_sub(&Duration::milliseconds(1))\n-                                                .is_none());\n+    #[test] #[should_panic]\n+    fn sub_bad2() {\n+        Duration::new(0, 0) - Duration::new(1, 0);\n     }\n \n     #[test]\n-    fn test_duration_mul() {\n-        assert_eq!(Duration::zero() * i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() * i32::MIN, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(1) * 0, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(1) * 1, Duration::nanoseconds(1));\n-        assert_eq!(Duration::nanoseconds(1) * 1_000_000_000, Duration::seconds(1));\n-        assert_eq!(Duration::nanoseconds(1) * -1_000_000_000, -Duration::seconds(1));\n-        assert_eq!(-Duration::nanoseconds(1) * 1_000_000_000, -Duration::seconds(1));\n-        assert_eq!(Duration::nanoseconds(30) * 333_333_333,\n-                   Duration::seconds(10) - Duration::nanoseconds(10));\n-        assert_eq!((Duration::nanoseconds(1) + Duration::seconds(1) + Duration::days(1)) * 3,\n-                   Duration::nanoseconds(3) + Duration::seconds(3) + Duration::days(3));\n-        assert_eq!(Duration::milliseconds(1500) * -2, Duration::seconds(-3));\n-        assert_eq!(Duration::milliseconds(-1500) * 2, Duration::seconds(-3));\n+    fn mul() {\n+        assert_eq!(Duration::new(0, 1) * 2, Duration::new(0, 2));\n+        assert_eq!(Duration::new(1, 1) * 3, Duration::new(3, 3));\n+        assert_eq!(Duration::new(0, 500_000_001) * 4, Duration::new(2, 4));\n+        assert_eq!(Duration::new(0, 500_000_001) * 4000,\n+                   Duration::new(2000, 4000));\n     }\n \n     #[test]\n-    fn test_duration_div() {\n-        assert_eq!(Duration::zero() / i32::MAX, Duration::zero());\n-        assert_eq!(Duration::zero() / i32::MIN, Duration::zero());\n-        assert_eq!(Duration::nanoseconds(123_456_789) / 1, Duration::nanoseconds(123_456_789));\n-        assert_eq!(Duration::nanoseconds(123_456_789) / -1, -Duration::nanoseconds(123_456_789));\n-        assert_eq!(-Duration::nanoseconds(123_456_789) / -1, Duration::nanoseconds(123_456_789));\n-        assert_eq!(-Duration::nanoseconds(123_456_789) / 1, -Duration::nanoseconds(123_456_789));\n-        assert_eq!(Duration::seconds(1) / 3, Duration::nanoseconds(333_333_333));\n-        assert_eq!(Duration::seconds(4) / 3, Duration::nanoseconds(1_333_333_333));\n-        assert_eq!(Duration::seconds(-1) / 2, Duration::milliseconds(-500));\n-        assert_eq!(Duration::seconds(1) / -2, Duration::milliseconds(-500));\n-        assert_eq!(Duration::seconds(-1) / -2, Duration::milliseconds(500));\n-        assert_eq!(Duration::seconds(-4) / 3, Duration::nanoseconds(-1_333_333_333));\n-        assert_eq!(Duration::seconds(-4) / -3, Duration::nanoseconds(1_333_333_333));\n+    fn div() {\n+        assert_eq!(Duration::new(0, 1) / 2, Duration::new(0, 0));\n+        assert_eq!(Duration::new(1, 1) / 3, Duration::new(0, 333_333_333));\n+        assert_eq!(Duration::new(99, 999_999_000) / 100,\n+                   Duration::new(0, 999_999_990));\n     }\n \n     #[test]\n-    fn test_duration_fmt() {\n-        assert_eq!(Duration::zero().to_string(), \"PT0S\");\n-        assert_eq!(Duration::days(42).to_string(), \"P42D\");\n-        assert_eq!(Duration::days(-42).to_string(), \"-P42D\");\n-        assert_eq!(Duration::seconds(42).to_string(), \"PT42S\");\n-        assert_eq!(Duration::milliseconds(42).to_string(), \"PT0.042S\");\n-        assert_eq!(Duration::microseconds(42).to_string(), \"PT0.000042S\");\n-        assert_eq!(Duration::nanoseconds(42).to_string(), \"PT0.000000042S\");\n-        assert_eq!((Duration::days(7) + Duration::milliseconds(6543)).to_string(),\n-                   \"P7DT6.543S\");\n-        assert_eq!(Duration::seconds(-86401).to_string(), \"-P1DT1S\");\n-        assert_eq!(Duration::nanoseconds(-1).to_string(), \"-PT0.000000001S\");\n-\n-        // the format specifier should have no effect on `Duration`\n-        assert_eq!(format!(\"{:30}\", Duration::days(1) + Duration::milliseconds(2345)),\n-                   \"P1DT2.345S\");\n+    fn display() {\n+        assert_eq!(Duration::new(0, 2).to_string(), \"2ns\");\n+        assert_eq!(Duration::new(0, 2_000_000).to_string(), \"2ms\");\n+        assert_eq!(Duration::new(2, 0).to_string(), \"2s\");\n+        assert_eq!(Duration::new(2, 2).to_string(), \"2.000000002s\");\n+        assert_eq!(Duration::new(2, 2_000_000).to_string(),\n+                   \"2.002s\");\n+        assert_eq!(Duration::new(0, 2_000_002).to_string(),\n+                   \"2000002ns\");\n+        assert_eq!(Duration::new(2, 2_000_002).to_string(),\n+                   \"2.002000002s\");\n     }\n }"}, {"sha": "d535b195519952d924a2b95b6c0bd631b5082e96", "filename": "src/libstd/time/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Ftime%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibstd%2Ftime%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftime%2Fmod.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,17 +10,8 @@\n \n //! Temporal quantification.\n \n-#![unstable(feature = \"std_misc\")]\n-\n-use sys::time::SteadyTime;\n+#![unstable(feature = \"time\")]\n \n pub use self::duration::Duration;\n \n-pub mod duration;\n-\n-/// Returns the current value of a high-resolution performance counter\n-/// in nanoseconds since an unspecified epoch.\n-// NB: this is intentionally not public, this is not ready to stabilize its api.\n-fn precise_time_ns() -> u64 {\n-    SteadyTime::now().ns()\n-}\n+mod duration;"}, {"sha": "c692babfacc4455d4badfaaa2a91f5d5f9f7c960", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -235,7 +235,9 @@ pub enum MacroFormat {\n     /// e.g. #[derive(...)] <item>\n     MacroAttribute,\n     /// e.g. `format!()`\n-    MacroBang\n+    MacroBang,\n+    /// Expansion performed by the compiler (libsyntax::expand).\n+    CompilerExpansion,\n }\n \n #[derive(Clone, Hash, Debug)]"}, {"sha": "0097bab2fea4d444593c38d366eafb8967cf7fbd", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -506,7 +506,7 @@ fn emit(dst: &mut EmitterWriter, cm: &codemap::CodeMap, rsp: RenderSpan,\n             match dst.registry.as_ref().and_then(|registry| registry.find_description(code)) {\n                 Some(_) => {\n                     try!(print_diagnostic(dst, &ss[..], Help,\n-                                          &format!(\"pass `--explain {}` to see a detailed \\\n+                                          &format!(\"run `rustc --explain {}` to see a detailed \\\n                                                    explanation\", code), None));\n                 }\n                 None => ()\n@@ -770,12 +770,15 @@ fn print_macro_backtrace(w: &mut EmitterWriter,\n                                                |span| cm.span_to_string(span));\n                 let (pre, post) = match ei.callee.format {\n                     codemap::MacroAttribute => (\"#[\", \"]\"),\n-                    codemap::MacroBang => (\"\", \"!\")\n+                    codemap::MacroBang => (\"\", \"!\"),\n+                    codemap::CompilerExpansion => (\"\", \"\"),\n                 };\n                 try!(print_diagnostic(w, &ss, Note,\n-                                      &format!(\"in expansion of {}{}{}\", pre,\n-                                              ei.callee.name,\n-                                              post), None));\n+                                      &format!(\"in expansion of {}{}{}\",\n+                                               pre,\n+                                               ei.callee.name,\n+                                               post),\n+                                      None));\n                 let ss = cm.span_to_string(ei.call_site);\n                 try!(print_diagnostic(w, &ss, Note, \"expansion site\", None));\n                 Ok(Some(ei.call_site))"}, {"sha": "fae0b56ce3d0b5d0b441c51b223348073bf589a7", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -19,7 +19,7 @@ use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, CompilerExpansion};\n use ext::base::*;\n use feature_gate::{self, Features};\n use fold;\n@@ -34,6 +34,18 @@ use visit::Visitor;\n use std_inject;\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n+    fn push_compiler_expansion(fld: &mut MacroExpander, span: Span, expansion_desc: &str) {\n+        fld.cx.bt_push(ExpnInfo {\n+            call_site: span,\n+            callee: NameAndSpan {\n+                name: expansion_desc.to_string(),\n+                format: CompilerExpansion,\n+                allow_internal_unstable: true,\n+                span: None,\n+            },\n+        });\n+    }\n+\n     e.and_then(|ast::Expr {id, node, span}| match node {\n         // expr_mac should really be expr_ext or something; it's the\n         // entry-point for all syntax extensions.\n@@ -77,6 +89,8 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     }\n             //   }\n \n+            push_compiler_expansion(fld, span, \"while let expansion\");\n+\n             // `<pat> => <body>`\n             let pat_arm = {\n                 let body_expr = fld.cx.expr_block(body);\n@@ -98,7 +112,9 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             // `[opt_ident]: loop { ... }`\n             let loop_block = fld.cx.block_expr(match_expr);\n             let (loop_block, opt_ident) = expand_loop_block(loop_block, opt_ident, fld);\n-            fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident))\n+            let result = fld.cx.expr(span, ast::ExprLoop(loop_block, opt_ident));\n+            fld.cx.bt_pop();\n+            result\n         }\n \n         // Desugar ExprIfLet\n@@ -112,6 +128,8 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     _ => [<elseopt> | ()]\n             //   }\n \n+            push_compiler_expansion(fld, span, \"if let expansion\");\n+\n             // `<pat> => <body>`\n             let pat_arm = {\n                 let body_expr = fld.cx.expr_block(body);\n@@ -173,13 +191,16 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                                                 ast::MatchSource::IfLetDesugar {\n                                                     contains_else_clause: contains_else_clause,\n                                                 }));\n-            fld.fold_expr(match_expr)\n+            let result = fld.fold_expr(match_expr);\n+            fld.cx.bt_pop();\n+            result\n         }\n \n         // Desugar support for ExprIfLet in the ExprIf else position\n         ast::ExprIf(cond, blk, elseopt) => {\n             let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n                 ast::ExprIfLet(..) => {\n+                    push_compiler_expansion(fld, span, \"if let expansion\");\n                     // wrap the if-let expr in a block\n                     let span = els.span;\n                     let blk = P(ast::Block {\n@@ -189,7 +210,9 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                         rules: ast::DefaultBlock,\n                         span: span\n                     });\n-                    fld.cx.expr_block(blk)\n+                    let result = fld.cx.expr_block(blk);\n+                    fld.cx.bt_pop();\n+                    result\n                 }\n                 _ => P(els)\n             }));\n@@ -221,6 +244,10 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     result\n             //   }\n \n+            push_compiler_expansion(fld, span, \"for loop expansion\");\n+\n+            let span = fld.new_span(span);\n+\n             // expand <head>\n             let head = fld.fold_expr(head);\n \n@@ -235,10 +262,11 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 rename_fld.fold_ident(ident)\n             };\n \n-            let pat_span = pat.span;\n-            // `:;std::option::Option::Some(<pat>) => <body>`\n+            let pat_span = fld.new_span(pat.span);\n+            // `::std::option::Option::Some(<pat>) => <body>`\n             let pat_arm = {\n                 let body_expr = fld.cx.expr_block(body);\n+                let pat = noop_fold_pat(pat, fld);\n                 let some_pat = fld.cx.pat_some(pat_span, pat);\n \n                 fld.cx.arm(pat_span, vec![some_pat], body_expr)\n@@ -304,20 +332,25 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n \n             // `{ let result = ...; result }`\n             let result_ident = token::gensym_ident(\"result\");\n-            fld.cx.expr_block(\n+            let result = fld.cx.expr_block(\n                 fld.cx.block_all(\n                     span,\n                     vec![fld.cx.stmt_let(span, false, result_ident, match_expr)],\n-                    Some(fld.cx.expr_ident(span, result_ident))))\n+                    Some(fld.cx.expr_ident(span, result_ident))));\n+            fld.cx.bt_pop();\n+            result\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n+            push_compiler_expansion(fld, span, \"closure expansion\");\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprClosure(capture_clause,\n                                             rewritten_fn_decl,\n                                             rewritten_block);\n-            P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)})\n+            let result = P(ast::Expr{id:id, node: new_node, span: fld.new_span(span)});\n+            fld.cx.bt_pop();\n+            result\n         }\n \n         _ => {"}, {"sha": "b16154861530dc70a61ddefb7beafc615b098bfc", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -43,6 +43,8 @@\n #![feature(std_misc)]\n #![feature(libc)]\n #![feature(set_stdio)]\n+#![feature(duration)]\n+#![feature(duration_span)]\n \n extern crate getopts;\n extern crate serialize;\n@@ -1069,7 +1071,7 @@ impl Bencher {\n     }\n \n     pub fn ns_elapsed(&mut self) -> u64 {\n-        self.dur.num_nanoseconds().unwrap() as u64\n+        self.dur.secs() * 1_000_000_000 + (self.dur.extra_nanos() as u64)\n     }\n \n     pub fn ns_per_iter(&mut self) -> u64 {\n@@ -1105,7 +1107,7 @@ impl Bencher {\n         // (i.e. larger error bars).\n         if n == 0 { n = 1; }\n \n-        let mut total_run = Duration::nanoseconds(0);\n+        let mut total_run = Duration::new(0, 0);\n         let samples : &mut [f64] = &mut [0.0_f64; 50];\n         loop {\n             let mut summ = None;\n@@ -1134,15 +1136,15 @@ impl Bencher {\n \n             // If we've run for 100ms and seem to have converged to a\n             // stable median.\n-            if loop_run.num_milliseconds() > 100 &&\n+            if loop_run > Duration::from_millis(100) &&\n                 summ.median_abs_dev_pct < 1.0 &&\n                 summ.median - summ5.median < summ5.median_abs_dev {\n                 return summ5;\n             }\n \n             total_run = total_run + loop_run;\n             // Longest we ever run for is 3s.\n-            if total_run.num_seconds() > 3 {\n+            if total_run > Duration::from_secs(3) {\n                 return summ5;\n             }\n \n@@ -1166,7 +1168,7 @@ pub mod bench {\n     pub fn benchmark<F>(f: F) -> BenchSamples where F: FnMut(&mut Bencher) {\n         let mut bs = Bencher {\n             iterations: 0,\n-            dur: Duration::nanoseconds(0),\n+            dur: Duration::new(0, 0),\n             bytes: 0\n         };\n \n@@ -1185,7 +1187,7 @@ pub mod bench {\n     pub fn run_once<F>(f: F) where F: FnOnce(&mut Bencher) {\n         let mut bs = Bencher {\n             iterations: 0,\n-            dur: Duration::nanoseconds(0),\n+            dur: Duration::new(0, 0),\n             bytes: 0\n         };\n         bs.bench_n(1, f);"}, {"sha": "47bdc9335c4019819de309ac70da326c1c528162", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -183,6 +183,12 @@ impl Subcommand for Build {\n             tgt = PathBuf::from(&env::args().nth(3).unwrap());\n         }\n \n+        // `_book` directory may already exist from previous runs. Check and\n+        // delete it if it exists.\n+        for entry in try!(fs::read_dir(&cwd)) {\n+            let path = try!(entry).path();\n+            if path == tgt { try!(fs::remove_dir_all(&tgt)) }\n+        }\n         try!(fs::create_dir(&tgt));\n \n         try!(File::create(&tgt.join(\"rust-book.css\")).and_then(|mut f| {"}, {"sha": "5eb48985bf90d82b4780fe924c6c2562f664edd1", "filename": "src/test/auxiliary/issue-9906.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fauxiliary%2Fissue-9906.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-9906.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// aux-build:issue-9906.rs\n-\n pub use other::FooBar;\n pub use other::foo;\n "}, {"sha": "7be5c3cf47c705cb94846045d82025704047ee96", "filename": "src/test/auxiliary/issue_16723_multiple_items_syntax_ext.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue_16723_multiple_items_syntax_ext.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,7 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-stage1\n // force-host\n \n #![feature(plugin_registrar, quote, rustc_private)]"}, {"sha": "af61b0aa0cdf41dc211788df85bbe12ca5a76344", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(std_misc, rand)]\n+#![feature(std_misc, rand, duration, duration_span)]\n \n use std::collections::{BTreeMap, HashMap, HashSet};\n use std::env;"}, {"sha": "eebf6feaffac33d0a4e120a26f48587a219d5e69", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,7 @@\n \n // ignore-pretty very bad with line comments\n \n-#![feature(unboxed_closures, rand, std_misc, collections)]\n+#![feature(unboxed_closures, rand, std_misc, collections, duration, duration_span)]\n \n extern crate collections;\n extern crate rand;\n@@ -167,13 +167,13 @@ fn write_results(label: &str, results: &Results) {\n \n fn empty_results() -> Results {\n     Results {\n-        sequential_ints: Duration::seconds(0),\n-        random_ints: Duration::seconds(0),\n-        delete_ints: Duration::seconds(0),\n+        sequential_ints: Duration::new(0, 0),\n+        random_ints: Duration::new(0, 0),\n+        delete_ints: Duration::new(0, 0),\n \n-        sequential_strings: Duration::seconds(0),\n-        random_strings: Duration::seconds(0),\n-        delete_strings: Duration::seconds(0),\n+        sequential_strings: Duration::new(0, 0),\n+        random_strings: Duration::new(0, 0),\n+        delete_strings: Duration::new(0, 0),\n     }\n }\n "}, {"sha": "6e85abb8e149fa64033690be0eb8b282594b9108", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmarks for various functions in std and extra\n \n-#![feature(rand, collections, std_misc)]\n+#![feature(rand, collections, std_misc, duration, duration_span)]\n \n use std::iter::repeat;\n use std::mem::swap;\n@@ -52,7 +52,7 @@ fn maybe_run_test<F>(argv: &[String], name: String, test: F) where F: FnOnce() {\n \n     let dur = Duration::span(test);\n \n-    println!(\"{}:\\t\\t{} ms\", name, dur.num_milliseconds());\n+    println!(\"{}:\\t\\t{}\", name, dur);\n }\n \n fn shift_push() {"}, {"sha": "2b7e204423e32226498cc5ad3329266257d31345", "filename": "src/test/bench/msgsend-pipes-shared.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes-shared.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -18,7 +18,7 @@\n // different scalability characteristics compared to the select\n // version.\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n@@ -88,9 +88,9 @@ fn run(args: &[String]) {\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n-    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n+    print!(\"Test took {}\\n\", dur);\n+    let thruput = ((size / workers * workers) as f64) / (dur.secs() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "5a541420d2abf528f19de88e1ed7ae1a73b125bc", "filename": "src/test/bench/msgsend-pipes.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-pipes.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -14,7 +14,7 @@\n //\n // I *think* it's the same, more or less.\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span)]\n \n use std::sync::mpsc::{channel, Sender, Receiver};\n use std::env;\n@@ -95,9 +95,9 @@ fn run(args: &[String]) {\n     });\n     let result = result.unwrap();\n     print!(\"Count is {}\\n\", result);\n-    print!(\"Test took {} ms\\n\", dur.num_milliseconds());\n-    let thruput = ((size / workers * workers) as f64) / (dur.num_milliseconds() as f64);\n-    print!(\"Throughput={} per sec\\n\", thruput / 1000.0);\n+    print!(\"Test took {}\\n\", dur);\n+    let thruput = ((size / workers * workers) as f64) / (dur.secs() as f64);\n+    print!(\"Throughput={} per sec\\n\", thruput);\n     assert_eq!(result, num_bytes * size);\n }\n "}, {"sha": "93e3394097bc57695a002cf2a9affb1256a2b344", "filename": "src/test/bench/msgsend-ring-mutex-arcs.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fmsgsend-ring-mutex-arcs.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -17,7 +17,7 @@\n \n // no-pretty-expanded FIXME #15189\n \n-#![feature(std_misc)]\n+#![feature(duration, duration_span, std_misc)]\n \n use std::env;\n use std::sync::{Arc, Future, Mutex, Condvar};\n@@ -107,9 +107,9 @@ fn main() {\n \n     // all done, report stats.\n     let num_msgs = num_tasks * msg_per_task;\n-    let rate = (num_msgs as f64) / (dur.num_milliseconds() as f64);\n+    let rate = (num_msgs as f64) / (dur.secs() as f64);\n \n-    println!(\"Sent {} messages in {} ms\", num_msgs, dur.num_milliseconds());\n-    println!(\"  {} messages / second\", rate / 1000.0);\n-    println!(\"  {} \u03bcs / message\", 1000000. / rate / 1000.0);\n+    println!(\"Sent {} messages in {}\", num_msgs, dur);\n+    println!(\"  {} messages / second\", rate);\n+    println!(\"  {} \u03bcs / message\", 1000000. / rate);\n }"}, {"sha": "2d5aae30ae8a95292b297338e9a3b2ebe9f8816e", "filename": "src/test/bench/shootout-pfib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fshootout-pfib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-pfib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -18,7 +18,7 @@\n \n */\n \n-#![feature(std_misc, rustc_private)]\n+#![feature(duration, duration_span, rustc_private)]\n \n extern crate getopts;\n "}, {"sha": "d7e556a124fe1ff635b6cfa9c110469adf7ed0cb", "filename": "src/test/bench/std-smallintmap.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Fstd-smallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fstd-smallintmap.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,7 @@\n \n // Microbenchmark for the smallintmap library\n \n-#![feature(collections, std_misc)]\n+#![feature(collections, duration, duration_span)]\n \n use std::collections::VecMap;\n use std::env;\n@@ -40,8 +40,8 @@ fn main() {\n     let max = args[1].parse::<usize>().unwrap();\n     let rep = args[2].parse::<usize>().unwrap();\n \n-    let mut checkf = Duration::seconds(0);\n-    let mut appendf = Duration::seconds(0);\n+    let mut checkf = Duration::new(0, 0);\n+    let mut appendf = Duration::new(0, 0);\n \n     for _ in 0..rep {\n         let mut map = VecMap::new();\n@@ -55,7 +55,7 @@ fn main() {\n     let maxf = max as f64;\n \n     println!(\"insert(): {} seconds\\n\", checkf);\n-    println!(\"        : {} op/ms\\n\", maxf / checkf.num_milliseconds() as f64);\n+    println!(\"        : {} op/s\\n\", maxf / checkf.secs() as f64);\n     println!(\"get()   : {} seconds\\n\", appendf);\n-    println!(\"        : {} op/ms\\n\", maxf / appendf.num_milliseconds() as f64);\n+    println!(\"        : {} op/s\\n\", maxf / appendf.secs() as f64);\n }"}, {"sha": "babae4d149f52d45e88c1c72cc71c48302f2f9c0", "filename": "src/test/bench/task-perf-alloc-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf-alloc-unwind.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(box_syntax, std_misc, collections)]\n+#![feature(box_syntax, duration, duration_span, collections)]\n \n use std::env;\n use std::thread;"}, {"sha": "b3dbcb743a135ecff2afdb56a3cc9b44d56e014f", "filename": "src/test/compile-fail-fulldeps/gated-macro-reexports.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-macro-reexports.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -11,7 +11,6 @@\n // Test that macro reexports item are gated by `macro_reexport` feature gate.\n \n // aux-build:macro_reexport_1.rs\n-// ignore-stage1\n \n #![crate_type = \"dylib\"]\n "}, {"sha": "4e80ca46c0a8470370ca0953879116597e68813d", "filename": "src/test/compile-fail-fulldeps/gated-plugin.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fgated-plugin.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_test.rs\n-// ignore-stage1\n \n #![plugin(macro_crate_test)]\n //~^ ERROR compiler plugins are experimental and possibly buggy"}, {"sha": "8ac03606720e4fbf8e6ec860aa40bfbb6a26767a", "filename": "src/test/compile-fail-fulldeps/macro-crate-doesnt-resolve.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-doesnt-resolve.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_test.rs\n-// ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_crate_test;"}, {"sha": "5b34d8e3adb0806eb534143631dac03f7754a451", "filename": "src/test/compile-fail-fulldeps/macro-crate-rlib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-rlib.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:rlib_crate_test.rs\n-// ignore-stage1\n // ignore-tidy-linelength\n // ignore-cross-compile gives a different error message\n "}, {"sha": "b0cd422053260e6c732add0c90ffcabaa30f64e7", "filename": "src/test/compile-fail-fulldeps/macro-crate-unexported-macro.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fmacro-crate-unexported-macro.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_test.rs\n-// ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_crate_test;"}, {"sha": "edbb77fe39063bb3e4defb5f08f9e0250b4d7faf", "filename": "src/test/compile-fail-fulldeps/plugin-as-extern-crate.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fplugin-as-extern-crate.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_test.rs\n-// ignore-stage1\n // ignore-cross-compile\n //\n // macro_crate_test will not compile on a cross-compiled target because"}, {"sha": "22292a6da9dfffe5d6221d313687975f5bcdd082", "filename": "src/test/compile-fail/associated-const-ambiguity-report.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-const-ambiguity-report.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(associated_consts)]\n+\n+trait Foo {\n+    const ID: i32;\n+}\n+\n+trait Bar {\n+    const ID: i32;\n+}\n+\n+impl Foo for i32 {\n+    const ID: i32 = 1;\n+}\n+\n+impl Bar for i32 {\n+    const ID: i32 = 3;\n+}\n+\n+const X: i32 = <i32>::ID; //~ ERROR E0034\n+\n+fn main() {\n+    assert_eq!(1, X);\n+}"}, {"sha": "f0f0bdfb38ee35edda402d516f065fe0d5fd2501", "filename": "src/test/compile-fail/auto-ref-slice-plus-ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fauto-ref-slice-plus-ref.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -15,11 +15,11 @@ fn main() {\n     // vectors to slices then automatically create a self reference.\n \n     let mut a = vec!(0);\n-    a.test_mut(); //~ ERROR does not implement any method in scope named `test_mut`\n-    a.test(); //~ ERROR does not implement any method in scope named `test`\n+    a.test_mut(); //~ ERROR no method named `test_mut` found\n+    a.test(); //~ ERROR no method named `test` found\n \n-    ([1]).test(); //~ ERROR does not implement any method in scope named `test`\n-    (&[1]).test(); //~ ERROR does not implement any method in scope named `test`\n+    ([1]).test(); //~ ERROR no method named `test` found\n+    (&[1]).test(); //~ ERROR no method named `test` found\n }\n \n trait MyIter {"}, {"sha": "af83b0ecbf22c59ac88f4c0c4fec2178f6fc8446", "filename": "src/test/compile-fail/class-cast-to-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclass-cast-to-trait.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -60,5 +60,5 @@ fn cat(in_x : usize, in_y : isize, in_name: String) -> cat {\n \n fn main() {\n   let nyan: Box<noisy> = box cat(0, 2, \"nyan\".to_string()) as Box<noisy>;\n-  nyan.eat(); //~ ERROR does not implement any method in scope named `eat`\n+  nyan.eat(); //~ ERROR no method named `eat` found\n }"}, {"sha": "087b8c14e35750af413ccdc1b38050114252d279", "filename": "src/test/compile-fail/coherence_inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -38,7 +38,7 @@ mod NoImport {\n     use Lib::TheStruct;\n \n     fn call_the_fn(s: &TheStruct) {\n-        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+        s.the_fn(); //~ ERROR no method named `the_fn` found\n     }\n }\n "}, {"sha": "442c4c89de4e1ad99ba01d8d4fb4ae1bc30eb413", "filename": "src/test/compile-fail/coherence_inherent_cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -30,7 +30,7 @@ mod NoImport {\n     use coherence_inherent_cc_lib::TheStruct;\n \n     fn call_the_fn(s: &TheStruct) {\n-        s.the_fn(); //~ ERROR does not implement any method in scope named `the_fn`\n+        s.the_fn(); //~ ERROR no method named `the_fn` found\n     }\n }\n "}, {"sha": "70633c92e6433ce9b525fbdf9c6227f7ea72f7cd", "filename": "src/test/compile-fail/copy-a-resource.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcopy-a-resource.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -26,6 +26,6 @@ fn foo(i:isize) -> foo {\n fn main() {\n     let x = foo(10);\n     let _y = x.clone();\n-    //~^ ERROR does not implement any method in scope\n+    //~^ ERROR no method named `clone` found\n     println!(\"{:?}\", x);\n }"}, {"sha": "d8cf23d1ff0bbbf00b9f1751f19a7c4dab5f9d20", "filename": "src/test/compile-fail/empty-macro-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fempty-macro-use.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use()]\n extern crate two_macros;"}, {"sha": "6b1dbf9d2d0ba23158b66e3ba7c7770f895fffd3", "filename": "src/test/compile-fail/for-expn-2.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-expn-2.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we get an expansion stack for `for` loops.\n+\n+// error-pattern:in expansion of for loop expansion\n+\n+fn main() {\n+    for t in &foo {\n+    }\n+}"}, {"sha": "43776d75a47f4aba186fe1364ae62de428146465", "filename": "src/test/compile-fail/for-expn.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffor-expn.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that an error on a sub-expresson in a for loop has the correct span.\n+\n+fn main() {\n+    // Odd formatting to make sure we get the right span.\n+    for t in &\n+      foo //~ ERROR unresolved name `foo`\n+    {\n+    }\n+}"}, {"sha": "ed91e935407b966a7200e92e8f773fbc47072d9e", "filename": "src/test/compile-fail/issue-10465.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-10465.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -24,7 +24,7 @@ pub mod b {\n         use b::B;\n \n         fn foo(b: &B) {\n-            b.foo(); //~ ERROR: does not implement any method in scope named\n+            b.foo(); //~ ERROR: no method named `foo` found\n         }\n     }\n "}, {"sha": "f5d158d64e19fa0a776a78d61568b76431290587", "filename": "src/test/compile-fail/issue-13853.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13853.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -31,7 +31,7 @@ impl Node for Stuff {\n }\n \n fn iterate<N: Node, G: Graph<N>>(graph: &G) {\n-    for node in graph.iter() { //~ ERROR does not implement any method in scope named\n+    for node in graph.iter() { //~ ERROR no method named `iter` found\n         node.zomg();  //~ error: the type of this value must be known in this context\n     }\n }"}, {"sha": "003c6644f7f0229061662a995ecc8ab5eff03ba1", "filename": "src/test/compile-fail/issue-14084.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14084.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -12,5 +12,5 @@\n \n fn main() {\n     box ( () ) 0;\n-    //~^ ERROR: only the managed heap and exchange heap are currently supported\n+    //~^ ERROR: only the exchange heap is currently supported\n }"}, {"sha": "43e9ca5fa6e7aa5b2bca45ff533377fb2134fee3", "filename": "src/test/compile-fail/issue-18343.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18343.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -14,6 +14,6 @@ struct Obj<F> where F: FnMut() -> u32 {\n \n fn main() {\n     let o = Obj { closure: || 42 };\n-    o.closure(); //~ ERROR does not implement any method in scope named `closure`\n+    o.closure(); //~ ERROR no method named `closure` found\n     //~^ NOTE use `(s.closure)(...)` if you meant to call the function stored in the `closure` field\n }"}, {"sha": "e4d132c86415ac013a8a4947ab75a4b708dcf997", "filename": "src/test/compile-fail/issue-1871.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-1871.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -14,7 +14,7 @@ fn main() {\n   let f = 42;\n \n   let _g = if f < 5 {\n-      f.honk() //~ ERROR does not implement any method in scope named `honk`\n+      f.honk() //~ ERROR no method named `honk` found\n   }\n   else {\n       ()"}, {"sha": "58a95e9da2bf36f534a7789a939fbb43938560db", "filename": "src/test/compile-fail/issue-19521.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19521.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -11,5 +11,5 @@\n #![feature(unboxed_closures)]\n \n fn main() {\n-    \"\".homura()(); //~ ERROR does not implement any method\n+    \"\".homura()(); //~ ERROR no method named `homura` found\n }"}, {"sha": "88ae0f835d0d724b69676800bd8199ca607618de", "filename": "src/test/compile-fail/issue-19692.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-19692.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -11,7 +11,7 @@\n struct Homura;\n \n fn akemi(homura: Homura) {\n-    let Some(ref madoka) = Some(homura.kaname()); //~ ERROR does not implement any method\n+    let Some(ref madoka) = Some(homura.kaname()); //~ ERROR no method named `kaname` found\n     madoka.clone(); //~ ERROR the type of this value must be known in this context\n }\n "}, {"sha": "bb170ef7d003662d004fc358fb86d9ea0ed9778a", "filename": "src/test/compile-fail/issue-2149.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2149.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -22,5 +22,5 @@ impl<A> vec_monad<A> for Vec<A> {\n }\n fn main() {\n     [\"hi\"].bind(|x| [x] );\n-    //~^ ERROR type `[&str; 1]` does not implement any method in scope named `bind`\n+    //~^ ERROR no method named `bind` found for type `[&str; 1]` in the current scope\n }"}, {"sha": "8677934fd646cb66269215b86c69d3c6a0ebc5ab", "filename": "src/test/compile-fail/issue-22645.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22645.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Add;\n+\n+trait Scalar {}\n+impl Scalar for f64 {}\n+\n+struct Bob;\n+\n+impl<RHS: Scalar> Add <RHS> for Bob {\n+  type Output = Bob;\n+  fn add(self, rhs : RHS) -> Bob {}\n+}\n+\n+fn main() {\n+  let b = Bob + 3.5;\n+  b + 3 //~ ERROR: is not implemented\n+  //~^ ERROR: is not implemented\n+  //~^^ ERROR: is not implemented\n+  //~^^^ ERROR: mismatched types\n+}"}, {"sha": "0fbc634826bc5b2931beef5389b333c8beb429bd", "filename": "src/test/compile-fail/issue-24352.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24352.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    1.0f64 - 1.0;\n+    1.0f64 - 1 //~ ERROR: is not implemented\n+    //~^ ERROR: is not implemented\n+}"}, {"sha": "631bcb7bd9eb9202f73f8f18595c314fd7421a1b", "filename": "src/test/compile-fail/issue-2823.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2823.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -20,5 +20,5 @@ impl Drop for C {\n \n fn main() {\n     let c = C{ x: 2};\n-    let _d = c.clone(); //~ ERROR does not implement any method in scope\n+    let _d = c.clone(); //~ ERROR no method named `clone` found\n }"}, {"sha": "29c1c584eed247aab1fea4511e1aec47d10a9039", "filename": "src/test/compile-fail/issue-3563.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3563.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -11,7 +11,7 @@\n trait A {\n     fn a(&self) {\n         || self.b()\n-        //~^ ERROR type `&Self` does not implement any method in scope named `b`\n+        //~^ ERROR no method named `b` found for type `&Self` in the current scope\n         //~| ERROR mismatched types\n         //~| expected `()`\n         //~| found closure"}, {"sha": "325f05841f4084468377cac538d51d4e6192b15e", "filename": "src/test/compile-fail/issue-3702-2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3702-2.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -23,7 +23,7 @@ trait Add {\n impl Add for isize {\n     fn to_int(&self) -> isize { *self }\n     fn add_dynamic(&self, other: &Add) -> isize {\n-        self.to_int() + other.to_int() //~ ERROR multiple applicable methods in scope\n+        self.to_int() + other.to_int() //~ ERROR multiple applicable items in scope\n     }\n }\n "}, {"sha": "ad56b125b087fdeba3d1acce166f4ab776fed67e", "filename": "src/test/compile-fail/issue-3707.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3707.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -17,7 +17,7 @@ impl Obj {\n         return 1+1 == 2\n     }\n     pub fn chirp(&self) {\n-        self.boom(); //~ ERROR `&Obj` does not implement any method in scope named `boom`\n+        self.boom(); //~ ERROR no method named `boom` found for type `&Obj` in the current scope\n     }\n }\n "}, {"sha": "da32408e199249a400013283b282e565a81e563f", "filename": "src/test/compile-fail/issue-5153.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-5153.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: type `&Foo` does not implement any method in scope named `foo`\n-\n trait Foo {\n     fn foo(self: Box<Self>);\n }\n@@ -20,4 +18,5 @@ impl Foo for isize {\n \n fn main() {\n     (&5 as &Foo).foo();\n+    //~^ ERROR: no method named `foo` found for type `&Foo` in the current scope\n }"}, {"sha": "6c7196527efdbd73db01cf703c57bc6d9a41282d", "filename": "src/test/compile-fail/issue-7575.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7575.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -71,15 +71,15 @@ impl ManyImplTrait for Myisize {}\n \n fn no_param_bound(u: usize, m: Myisize) -> usize {\n     u.f8(42) + u.f9(342) + m.fff(42)\n-            //~^ ERROR type `usize` does not implement any method in scope named `f9`\n+            //~^ ERROR no method named `f9` found for type `usize` in the current scope\n             //~^^ NOTE found defined static methods, maybe a `self` is missing?\n-            //~^^^ ERROR type `Myisize` does not implement any method in scope named `fff`\n+            //~^^^ ERROR no method named `fff` found for type `Myisize` in the current scope\n             //~^^^^ NOTE found defined static methods, maybe a `self` is missing?\n }\n \n fn param_bound<T: ManyImplTrait>(t: T) -> bool {\n     t.is_str()\n-    //~^ ERROR type `T` does not implement any method in scope named `is_str`\n+    //~^ ERROR no method named `is_str` found for type `T` in the current scope\n     //~^^ NOTE found defined static methods, maybe a `self` is missing?\n }\n "}, {"sha": "003329a2d7de22375e6de76df345ac4b697b0e9f", "filename": "src/test/compile-fail/issue-7950.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7950.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -13,5 +13,5 @@\n struct Foo;\n \n fn main() {\n-    Foo::bar(); //~ ERROR type `Foo` does not implement any method in scope named `bar`\n+    Foo::bar(); //~ ERROR no associated item named `bar` found for type `Foo` in the current scope\n }"}, {"sha": "34aa1c75872f36142734dc503cbcb17fb6070844", "filename": "src/test/compile-fail/macro-backtrace-invalid-internals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-backtrace-invalid-internals.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -12,7 +12,7 @@\n \n macro_rules! fake_method_stmt { //~ NOTE in expansion of\n      () => {\n-          1.fake() //~ ERROR does not implement any method\n+          1.fake() //~ ERROR no method named `fake` found\n      }\n }\n \n@@ -30,7 +30,7 @@ macro_rules! fake_anon_field_stmt { //~ NOTE in expansion of\n \n macro_rules! fake_method_expr { //~ NOTE in expansion of\n      () => {\n-          1.fake() //~ ERROR does not implement any method\n+          1.fake() //~ ERROR no method named `fake` found\n      }\n }\n "}, {"sha": "76211b88bd7c325f967688ad3704f90b8cc139b0", "filename": "src/test/compile-fail/macro-crate-nonterminal-non-root.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-crate-nonterminal-non-root.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_nonterminal.rs\n-// ignore-stage1\n \n mod foo {\n     #[macro_use]"}, {"sha": "cd6640f8b6dda2ad6f700816cbfb6fda352c6405", "filename": "src/test/compile-fail/macro-no-implicit-reexport.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-no-implicit-reexport.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:macro_reexport_1.rs\n // aux-build:macro_non_reexport_2.rs\n-// ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_non_reexport_2;"}, {"sha": "ca334d9fd2d78d331b3a1fef8b8a72c17b6f2fc0", "filename": "src/test/compile-fail/macro-reexport-not-locally-visible.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-not-locally-visible.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_reexport_1.rs\n-// ignore-stage1\n \n #![feature(macro_reexport)]\n "}, {"sha": "8fa6b32905cebb46aa7ec8e978eabb1f773d8e68", "filename": "src/test/compile-fail/macro-reexport-undef.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-reexport-undef.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_two)]\n #[macro_reexport(no_way)] //~ ERROR reexported macro not found"}, {"sha": "dd725aae95e899cf11a7f8e46fcf6d66f597c46c", "filename": "src/test/compile-fail/macro-use-undef.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-undef.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_two, no_way)] //~ ERROR imported macro not found\n extern crate two_macros;"}, {"sha": "4dc65434dc7e15d66d66855b7a19f89d60cdade2", "filename": "src/test/compile-fail/macro-use-wrong-name.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-use-wrong-name.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_one)]\n extern crate two_macros;"}, {"sha": "3434cf96fce9463c15822e240ff5fd61a73d1a88", "filename": "src/test/compile-fail/method-call-err-msg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-call-err-msg.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -25,6 +25,6 @@ fn main() {\n \n     let y = Foo;\n     y.zero()\n-     .take()    //~ ERROR type `Foo` does not implement any method in scope named `take`\n+     .take()    //~ ERROR no method named `take` found for type `Foo` in the current scope\n      .one(0);\n }"}, {"sha": "e6f3c8ab3170e6176a247d195f96892feff2e4a2", "filename": "src/test/compile-fail/method-suggestion-no-duplication.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmethod-suggestion-no-duplication.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -16,7 +16,7 @@ fn foo<F>(f: F) where F: FnMut(Foo) {}\n \n fn main() {\n     foo(|s| s.is_empty());\n-    //~^ ERROR does not implement any method\n+    //~^ ERROR no method named `is_empty` found\n     //~^^ HELP #1: `core::slice::SliceExt`\n     //~^^^ HELP #2: `core::str::StrExt`\n }"}, {"sha": "bbce9c21287575dc5291433bfc33ec24432a8fa5", "filename": "src/test/compile-fail/missing-macro-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmissing-macro-use.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n extern crate two_macros;\n "}, {"sha": "08c848a09ab09c14e800c77c5000f334e79911a9", "filename": "src/test/compile-fail/no-method-suggested-traits.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-method-suggested-traits.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -33,45 +33,45 @@ fn main() {\n \n     1u32.method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n-    //~^^ ERROR does not implement\n+    //~^^ ERROR no method named\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&1u32)).method();\n     //~^ HELP following traits are implemented but not in scope, perhaps add a `use` for one of them\n-    //~^^ ERROR does not implement\n+    //~^^ ERROR no method named\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     'a'.method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&'a')).method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `foo::Bar`\n \n     1i32.method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&1i32)).method();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n     //~^^ HELP the following trait is implemented but not in scope, perhaps add a `use` for it:\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     Foo.method();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following traits define a method `method`, perhaps you need to implement one of them\n+    //~^ ERROR no method named\n+    //~^^ HELP following traits define an item `method`, perhaps you need to implement one of them\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n     //~^^^^^^ HELP `no_method_suggested_traits::bar::PubPriv`\n     //~^^^^^^^ HELP `no_method_suggested_traits::qux::PrivPub`\n     //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n     std::rc::Rc::new(&mut Box::new(&Foo)).method();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following traits define a method `method`, perhaps you need to implement one of them\n+    //~^ ERROR no method named\n+    //~^^ HELP following traits define an item `method`, perhaps you need to implement one of them\n     //~^^^ HELP `foo::Bar`\n     //~^^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     //~^^^^^ HELP `no_method_suggested_traits::reexport::Reexported`\n@@ -80,55 +80,55 @@ fn main() {\n     //~^^^^^^^^ HELP `no_method_suggested_traits::quz::PrivPriv`\n \n     1u64.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP the following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&1u64)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP the following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP the following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n \n     no_method_suggested_traits::Foo.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     no_method_suggested_traits::Bar::X.method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method2();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method2`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method2`, perhaps you need to implement it\n     //~^^^ HELP `foo::Bar`\n \n     Foo.method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&Foo)).method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     Bar::X.method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n     std::rc::Rc::new(&mut Box::new(&Bar::X)).method3();\n-    //~^ ERROR does not implement\n-    //~^^ HELP following trait defines a method `method3`, perhaps you need to implement it\n+    //~^ ERROR no method named\n+    //~^^ HELP following trait defines an item `method3`, perhaps you need to implement it\n     //~^^^ HELP `no_method_suggested_traits::foo::PubPub`\n \n     // should have no help:\n-    1_usize.method3(); //~ ERROR does not implement\n-    std::rc::Rc::new(&mut Box::new(&1_usize)).method3(); //~ ERROR does not implement\n-    no_method_suggested_traits::Foo.method3();  //~ ERROR does not implement\n+    1_usize.method3(); //~ ERROR no method named\n+    std::rc::Rc::new(&mut Box::new(&1_usize)).method3(); //~ ERROR no method named\n+    no_method_suggested_traits::Foo.method3();  //~ ERROR no method named\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Foo)).method3();\n-    //~^ ERROR does not implement\n-    no_method_suggested_traits::Bar::X.method3();  //~ ERROR does not implement\n+    //~^ ERROR no method named\n+    no_method_suggested_traits::Bar::X.method3();  //~ ERROR no method named\n     std::rc::Rc::new(&mut Box::new(&no_method_suggested_traits::Bar::X)).method3();\n-    //~^ ERROR does not implement\n+    //~^ ERROR no method named\n }"}, {"sha": "fd245f38a0c92240d5bc1d98308fd5f7091e5e04", "filename": "src/test/compile-fail/non-copyable-void.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnon-copyable-void.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -15,6 +15,6 @@ fn main() {\n     let y : *const libc::c_void = x as *const libc::c_void;\n     unsafe {\n         let _z = (*y).clone();\n-        //~^ ERROR does not implement any method in scope\n+        //~^ ERROR no method named `clone` found\n     }\n }"}, {"sha": "f5712b0c957ba40363b0a36902a50de54900f989", "filename": "src/test/compile-fail/noncopyable-class.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnoncopyable-class.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -41,6 +41,6 @@ fn foo(i:isize) -> foo {\n \n fn main() {\n     let x = foo(10);\n-    let _y = x.clone(); //~ ERROR does not implement any method in scope\n+    let _y = x.clone(); //~ ERROR no method named `clone` found\n     println!(\"{:?}\", x);\n }"}, {"sha": "98c14cee942ed5fbf610eb9864f272f790c0028f", "filename": "src/test/compile-fail/object-pointer-types.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fobject-pointer-types.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -19,19 +19,19 @@ trait Foo {\n fn borrowed_receiver(x: &Foo) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n-    x.owned(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR no method named `owned` found\n }\n \n fn borrowed_mut_receiver(x: &mut Foo) {\n     x.borrowed();\n     x.borrowed_mut();\n-    x.owned(); //~ ERROR does not implement any method\n+    x.owned(); //~ ERROR no method named `owned` found\n }\n \n fn owned_receiver(x: Box<Foo>) {\n     x.borrowed();\n     x.borrowed_mut(); // See [1]\n-    x.managed();  //~ ERROR does not implement any method\n+    x.managed();  //~ ERROR no method named `managed` found\n     x.owned();\n }\n "}, {"sha": "6be98fbd82773ffad6e708af3bddb0559de87276", "filename": "src/test/compile-fail/ret-non-nil.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fret-non-nil.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern: `return;` in function returning non-nil\n+// error-pattern: `return;` in a function whose return type is not `()`\n \n fn f() { return; }\n "}, {"sha": "e682d3c81e793c39bd74acf9b64acd800bf937cf", "filename": "src/test/compile-fail/trait-impl-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-impl-1.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -22,5 +22,5 @@ impl T for i32 {}\n \n fn main() {\n     let x = &42i32;\n-    x.foo(); //~ERROR: type `&i32` does not implement any method in scope named `foo`\n+    x.foo(); //~ERROR: no method named `foo` found for type `&i32` in the current scope\n }"}, {"sha": "1c133fbfcdbbf896d902ba7c3408c0a85036b9a1", "filename": "src/test/compile-fail/unboxed-closures-static-call-wrong-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-static-call-wrong-trait.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -14,5 +14,5 @@ fn to_fn_mut<A,F:FnMut<A>>(f: F) -> F { f }\n \n fn main() {\n     let mut_ = to_fn_mut(|x| x);\n-    mut_.call((0, )); //~ ERROR does not implement any method in scope named `call`\n+    mut_.call((0, )); //~ ERROR no method named `call` found\n }"}, {"sha": "c44718c4fc9c231aa052d792ba204fcd5897a026", "filename": "src/test/compile-fail/unique-object-noncopyable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-object-noncopyable.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -31,5 +31,5 @@ impl Foo for Bar {\n fn main() {\n     let x = box Bar { x: 10 };\n     let y: Box<Foo> = x as Box<Foo>;\n-    let _z = y.clone(); //~ ERROR does not implement any method in scope\n+    let _z = y.clone(); //~ ERROR no method named `clone` found\n }"}, {"sha": "d971940db38f5af20cced487fa34dec81d825cf8", "filename": "src/test/compile-fail/unique-pinned-nocopy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funique-pinned-nocopy.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -20,6 +20,6 @@ impl Drop for r {\n fn main() {\n     // FIXME (#22405): Replace `Box::new` with `box` here when/if possible.\n     let i = Box::new(r { b: true });\n-    let _j = i.clone(); //~ ERROR not implement\n+    let _j = i.clone(); //~ ERROR no method named `clone` found\n     println!(\"{:?}\", i);\n }"}, {"sha": "88be7fe1212d1c4becaf5790207e92ed7df3600c", "filename": "src/test/run-pass-fulldeps/issue-13560.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-13560.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -11,7 +11,6 @@\n // aux-build:issue-13560-1.rs\n // aux-build:issue-13560-2.rs\n // aux-build:issue-13560-3.rs\n-// ignore-stage1\n // ignore-musl\n \n // Regression test for issue #13560, the test itself is all in the dependent"}, {"sha": "62e90d7a6e22b0f105b51812c5a42e59aad350b4", "filename": "src/test/run-pass/associated-const-match-patterns.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-const-match-patterns.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -41,6 +41,10 @@ fn main() {\n         _ => false,\n     });\n     // Trait impl\n+    assert!(match Bar::Var1 {\n+        Foo::THEBAR => true,\n+        _ => false,\n+    });\n     assert!(match Bar::Var1 {\n         <Foo>::THEBAR => true,\n         _ => false,"}, {"sha": "83ce0db365f8bb8afb5d212ae5c032b732954099", "filename": "src/test/run-pass/core-run-destroy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcore-run-destroy.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -16,7 +16,7 @@\n // instead of in std.\n \n #![reexport_test_harness_main = \"test_main\"]\n-#![feature(libc, std_misc)]\n+#![feature(libc, std_misc, duration)]\n \n extern crate libc;\n "}, {"sha": "1b857d94c72e42dd03b3b25467786e0c4f76583c", "filename": "src/test/run-pass/issue-23825.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fissue-23825.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fissue-23825.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23825.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+trait Stringify {\n+    fn to_string(&self) -> String;\n+}\n+\n+impl Stringify for u32 {\n+    fn to_string(&self) -> String { format!(\"u32: {}\", *self) }\n+}\n+\n+impl Stringify for f32 {\n+    fn to_string(&self) -> String { format!(\"f32: {}\", *self) }\n+}\n+\n+fn print<T: Stringify>(x: T) -> String {\n+    x.to_string()\n+}\n+\n+fn main() {\n+    assert_eq!(&print(5), \"u32: 5\");\n+    assert_eq!(&print(5.0), \"f32: 5\");\n+}"}, {"sha": "93f5899e3ac90108c03c3a211f503aefcc1a6270", "filename": "src/test/run-pass/macro-crate-nonterminal-renamed.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal-renamed.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_nonterminal.rs\n-// ignore-stage1\n \n #[macro_use]\n extern crate macro_crate_nonterminal as new_name;"}, {"sha": "28f9393ab7a10ea0be19dae70d96db5dac022285", "filename": "src/test/run-pass/macro-crate-nonterminal.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-crate-nonterminal.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:macro_crate_nonterminal.rs\n-// ignore-stage1\n \n #[macro_use]\n extern crate macro_crate_nonterminal;"}, {"sha": "e39f81e49d7c4bc6c17f79dbc85f2e9c4ebe8340", "filename": "src/test/run-pass/macro-export-inner-module.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-export-inner-module.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n //aux-build:macro_export_inner_module.rs\n-//ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_export_inner_module;"}, {"sha": "de7df1ec02125bc07988b98ca36c6b410cc5f64b", "filename": "src/test/run-pass/macro-reexport-no-intermediate-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-reexport-no-intermediate-use.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:macro_reexport_1.rs\n // aux-build:macro_reexport_2_no_use.rs\n-// ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_reexport_2_no_use;"}, {"sha": "b8926eca9e996fc20489bb996fb2c1e001eb2069", "filename": "src/test/run-pass/macro-reexport.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-reexport.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,6 @@\n \n // aux-build:macro_reexport_1.rs\n // aux-build:macro_reexport_2.rs\n-// ignore-stage1\n \n #[macro_use] #[no_link]\n extern crate macro_reexport_2;"}, {"sha": "60e1d6287f181a6198b866c0b02551a0a5796552", "filename": "src/test/run-pass/macro-use-all-and-none.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-all-and-none.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use]\n #[macro_use()]"}, {"sha": "ca9c0e23e7c33b01b65a12bce14a4fdc1d3852fd", "filename": "src/test/run-pass/macro-use-all.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-all.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use]\n extern crate two_macros;"}, {"sha": "7e0a374ef1521da0592d135b2a4241a19d5a35be", "filename": "src/test/run-pass/macro-use-both.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-both.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_one, macro_two)]\n extern crate two_macros;"}, {"sha": "6a30b3e55ba9a37a58f382030c79d6f7276cb5fe", "filename": "src/test/run-pass/macro-use-one.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-use-one.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_two)]\n extern crate two_macros;"}, {"sha": "36314c5e14ac2d082a60094c5f04dfceb83bd4fb", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -10,7 +10,7 @@\n \n // pretty-expanded FIXME #23616\n \n-#![feature(std_misc, alloc)]\n+#![feature(std_misc, alloc, static_condvar)]\n \n use std::sync;\n "}, {"sha": "5df9d0222b4bb22ca10e9e3f1cbcd343c5ce1b7c", "filename": "src/test/run-pass/two-macro-use.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Ftwo-macro-use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/507f8b8d942f17452c16876a02bef9e1bc15d028/src%2Ftest%2Frun-pass%2Ftwo-macro-use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftwo-macro-use.rs?ref=507f8b8d942f17452c16876a02bef9e1bc15d028", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n // aux-build:two_macros.rs\n-// ignore-stage1\n \n #[macro_use(macro_one)]\n #[macro_use(macro_two)]"}]}