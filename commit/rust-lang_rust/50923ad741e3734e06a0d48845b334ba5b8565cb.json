{"sha": "50923ad741e3734e06a0d48845b334ba5b8565cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwOTIzYWQ3NDFlMzczNGUwNmEwZDQ4ODQ1YjMzNGJhNWI4NTY1Y2I=", "commit": {"author": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-21T14:28:29Z"}, "committer": {"name": "mahdi-frms", "email": "mahdif1380@outlook.com", "date": "2021-08-21T14:43:14Z"}, "message": "func gen: seperate generation form position(3)", "tree": {"sha": "ebeb76983e0782794812b8f374a5665e7d5078eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebeb76983e0782794812b8f374a5665e7d5078eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50923ad741e3734e06a0d48845b334ba5b8565cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50923ad741e3734e06a0d48845b334ba5b8565cb", "html_url": "https://github.com/rust-lang/rust/commit/50923ad741e3734e06a0d48845b334ba5b8565cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50923ad741e3734e06a0d48845b334ba5b8565cb/comments", "author": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mahdifrmz", "id": 62165556, "node_id": "MDQ6VXNlcjYyMTY1NTU2", "avatar_url": "https://avatars.githubusercontent.com/u/62165556?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mahdifrmz", "html_url": "https://github.com/mahdifrmz", "followers_url": "https://api.github.com/users/mahdifrmz/followers", "following_url": "https://api.github.com/users/mahdifrmz/following{/other_user}", "gists_url": "https://api.github.com/users/mahdifrmz/gists{/gist_id}", "starred_url": "https://api.github.com/users/mahdifrmz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mahdifrmz/subscriptions", "organizations_url": "https://api.github.com/users/mahdifrmz/orgs", "repos_url": "https://api.github.com/users/mahdifrmz/repos", "events_url": "https://api.github.com/users/mahdifrmz/events{/privacy}", "received_events_url": "https://api.github.com/users/mahdifrmz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ac9400100d276dd169e56ce6df1ebbd8a75f961", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ac9400100d276dd169e56ce6df1ebbd8a75f961", "html_url": "https://github.com/rust-lang/rust/commit/1ac9400100d276dd169e56ce6df1ebbd8a75f961"}], "stats": {"total": 173, "additions": 85, "deletions": 88}, "files": [{"sha": "384d0c0ba9ebf32bb77b1742b54f4557d2d80a7c", "filename": "crates/ide_assists/src/handlers/generate_function.rs", "status": "modified", "additions": 85, "deletions": 88, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/50923ad741e3734e06a0d48845b334ba5b8565cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50923ad741e3734e06a0d48845b334ba5b8565cb/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=50923ad741e3734e06a0d48845b334ba5b8565cb", "patch": "@@ -6,7 +6,7 @@ use syntax::{\n     ast::{\n         self,\n         edit::{AstNodeEdit, IndentLevel},\n-        make, ArgListOwner, AstNode, ModuleItemOwner,\n+        make, ArgListOwner, AstNode, CallExpr, ModuleItemOwner,\n     },\n     SyntaxKind, SyntaxNode, TextRange, TextSize,\n };\n@@ -85,10 +85,10 @@ fn gen_fn(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         None => None,\n     };\n \n-    let (function_builder, inserting_offset, file) =\n-        FunctionBuilder::from_call(ctx, &call, &path, target_module)?;\n+    let (target, file, insert_offset) = get_fn_target(ctx, &target_module, call.clone())?;\n+    let function_builder = FunctionBuilder::from_call(ctx, &call, &path, target_module, target)?;\n     let target = call.syntax().text_range();\n-    add_func_to_accumulator(acc, ctx, target, function_builder, inserting_offset, file, None)\n+    add_func_to_accumulator(acc, ctx, target, function_builder, insert_offset, file, None)\n }\n \n fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n@@ -109,24 +109,26 @@ fn gen_method(acc: &mut Assists, ctx: &AssistContext) -> Option<()> {\n         ctx.sema.find_node_at_offset_with_macros(file.syntax(), range.range.start())?;\n     let impl_ = find_struct_impl(ctx, &adt_source, fn_name.text().as_str())?;\n \n-    let (function_builder, inserting_offset, file) = FunctionBuilder::from_method_call(\n+    let (target, insert_offset) = get_method_target(ctx, &target_module, &impl_)?;\n+    let function_builder =\n+        FunctionBuilder::from_method_call(ctx, &call, &fn_name, target_module, target)?;\n+    let text_range = call.syntax().text_range();\n+    let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n+    add_func_to_accumulator(\n+        acc,\n         ctx,\n-        &call,\n-        &fn_name,\n-        &impl_,\n+        text_range,\n+        function_builder,\n+        insert_offset,\n         range.file_id,\n-        target_module,\n-        current_module,\n-    )?;\n-    let target = call.syntax().text_range();\n-    let adt_name = if impl_.is_none() { Some(adt.name(ctx.sema.db)) } else { None };\n-    add_func_to_accumulator(acc, ctx, target, function_builder, inserting_offset, file, adt_name)\n+        adt_name,\n+    )\n }\n \n fn add_func_to_accumulator(\n     acc: &mut Assists,\n     ctx: &AssistContext,\n-    target: TextRange,\n+    text_range: TextRange,\n     function_builder: FunctionBuilder,\n     insert_offset: TextSize,\n     file: FileId,\n@@ -135,7 +137,7 @@ fn add_func_to_accumulator(\n     acc.add(\n         AssistId(\"generate_function\", AssistKind::Generate),\n         format!(\"Generate `{}` method\", function_builder.fn_name),\n-        target,\n+        text_range,\n         |builder| {\n             let function_template = function_builder.render();\n             let mut func = function_template.to_string(ctx.config.snippet_cap);\n@@ -194,7 +196,6 @@ struct FunctionBuilder {\n     params: ast::ParamList,\n     ret_type: Option<ast::RetType>,\n     should_focus_return_type: bool,\n-    file: FileId,\n     needs_pub: bool,\n     is_async: bool,\n }\n@@ -207,17 +208,8 @@ impl FunctionBuilder {\n         call: &ast::CallExpr,\n         path: &ast::Path,\n         target_module: Option<hir::Module>,\n-    ) -> Option<(Self, TextSize, FileId)> {\n-        let mut file = ctx.frange.file_id;\n-        let target = match &target_module {\n-            Some(target_module) => {\n-                let module_source = target_module.definition_source(ctx.db());\n-                let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n-                file = in_file;\n-                target\n-            }\n-            None => next_space_for_fn_after_call_site(FuncExpr::Func(call.clone()))?,\n-        };\n+        target: GeneratedFunctionTarget,\n+    ) -> Option<Self> {\n         let needs_pub = target_module.is_some();\n         let target_module = target_module.or_else(|| current_module(target.syntax(), ctx))?;\n         let fn_name = fn_name(path)?;\n@@ -229,51 +221,27 @@ impl FunctionBuilder {\n         let (ret_type, should_focus_return_type) =\n             make_return_type(ctx, &ast::Expr::CallExpr(call.clone()), target_module);\n \n-        let insert_offset = match &target {\n-            GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n-            GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                it.text_range().start() + TextSize::of('{')\n-            }\n-        };\n-\n-        Some((\n-            Self {\n-                target,\n-                fn_name,\n-                type_params,\n-                params,\n-                ret_type,\n-                should_focus_return_type,\n-                file,\n-                needs_pub,\n-                is_async,\n-            },\n-            insert_offset,\n-            file,\n-        ))\n+        Some(Self {\n+            target,\n+            fn_name,\n+            type_params,\n+            params,\n+            ret_type,\n+            should_focus_return_type,\n+            needs_pub,\n+            is_async,\n+        })\n     }\n \n     fn from_method_call(\n         ctx: &AssistContext,\n         call: &ast::MethodCallExpr,\n         name: &ast::NameRef,\n-        impl_: &Option<ast::Impl>,\n-        file: FileId,\n         target_module: Module,\n-        current_module: Module,\n-    ) -> Option<(Self, TextSize, FileId)> {\n-        let target = match impl_ {\n-            Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n-            None => {\n-                next_space_for_fn_in_module(\n-                    ctx.sema.db,\n-                    &target_module.definition_source(ctx.sema.db),\n-                )?\n-                .1\n-            }\n-        };\n-        let needs_pub = !module_is_descendant(&current_module, &target_module, ctx);\n-\n+        target: GeneratedFunctionTarget,\n+    ) -> Option<Self> {\n+        let needs_pub =\n+            !module_is_descendant(&current_module(call.syntax(), ctx)?, &target_module, ctx);\n         let fn_name = make::name(&name.text());\n         let (type_params, params) = fn_args(ctx, target_module, FuncExpr::Method(call.clone()))?;\n \n@@ -283,28 +251,16 @@ impl FunctionBuilder {\n         let (ret_type, should_focus_return_type) =\n             make_return_type(ctx, &ast::Expr::MethodCallExpr(call.clone()), target_module);\n \n-        let insert_offset = match &target {\n-            GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n-            GeneratedFunctionTarget::InEmptyItemList(it) => {\n-                it.text_range().start() + TextSize::of('{')\n-            }\n-        };\n-\n-        Some((\n-            Self {\n-                target,\n-                fn_name,\n-                type_params,\n-                params,\n-                ret_type,\n-                should_focus_return_type,\n-                file,\n-                needs_pub,\n-                is_async,\n-            },\n-            insert_offset,\n-            file,\n-        ))\n+        Some(Self {\n+            target,\n+            fn_name,\n+            type_params,\n+            params,\n+            ret_type,\n+            should_focus_return_type,\n+            needs_pub,\n+            is_async,\n+        })\n     }\n \n     fn render(self) -> FunctionTemplate {\n@@ -382,6 +338,47 @@ fn make_return_type(\n     (ret_type, should_focus_return_type)\n }\n \n+fn get_fn_target(\n+    ctx: &AssistContext,\n+    target_module: &Option<Module>,\n+    call: CallExpr,\n+) -> Option<(GeneratedFunctionTarget, FileId, TextSize)> {\n+    let mut file = ctx.frange.file_id;\n+    let target = match target_module {\n+        Some(target_module) => {\n+            let module_source = target_module.definition_source(ctx.db());\n+            let (in_file, target) = next_space_for_fn_in_module(ctx.sema.db, &module_source)?;\n+            file = in_file;\n+            target\n+        }\n+        None => next_space_for_fn_after_call_site(FuncExpr::Func(call.clone()))?,\n+    };\n+    Some((target.clone(), file, get_insert_offset(&target)))\n+}\n+\n+fn get_method_target(\n+    ctx: &AssistContext,\n+    target_module: &Module,\n+    impl_: &Option<ast::Impl>,\n+) -> Option<(GeneratedFunctionTarget, TextSize)> {\n+    let target = match impl_ {\n+        Some(impl_) => next_space_for_fn_in_impl(&impl_)?,\n+        None => {\n+            next_space_for_fn_in_module(ctx.sema.db, &target_module.definition_source(ctx.sema.db))?\n+                .1\n+        }\n+    };\n+    Some((target.clone(), get_insert_offset(&target)))\n+}\n+\n+fn get_insert_offset(target: &GeneratedFunctionTarget) -> TextSize {\n+    match &target {\n+        GeneratedFunctionTarget::BehindItem(it) => it.text_range().end(),\n+        GeneratedFunctionTarget::InEmptyItemList(it) => it.text_range().start() + TextSize::of('{'),\n+    }\n+}\n+\n+#[derive(Clone)]\n enum GeneratedFunctionTarget {\n     BehindItem(SyntaxNode),\n     InEmptyItemList(SyntaxNode),"}]}