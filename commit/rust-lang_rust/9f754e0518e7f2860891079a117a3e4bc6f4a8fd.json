{"sha": "9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNzU0ZTA1MThlN2YyODYwODkxMDc5YTExN2EzZTRiYzZmNGE4ZmQ=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-04T08:42:28Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-04T08:42:28Z"}, "message": "Merge #5219\n\n5219: Cleanup dot completiont tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "6c0d0cbde03a3f593256d76e7ab3784349868a3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c0d0cbde03a3f593256d76e7ab3784349868a3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfAED0CRBK7hj4Ov3rIwAAdHIIAFUV9gP3MAIErDFdBX1WQbDL\noqoJGJd0mvvYeoyIZ785ytYG63oRekV1Ly4PSQ8kR+iFHCZGdCzxThdb3V0YoWvr\ngMMYKjf+TT8alOYKhte52uNV75rpURTaWtbMzi3n4w3nn/WcgpMvoFFcYc3DpwZl\nKcYf+1bO/GlZ0N804Qfa5ZkQlu7zMocIyImpoWLNwZjkhnEbq36T/lrj8wL19WLF\nIceU+MBlJo0BdnZI5MQdGYp1v9bGOIR+v2Zli0AmpDmKbTat+hHXATZwTzCZRA9n\nP/rb71oZPTNqDIEFT2wVTh5ZAI9Ksyi5gyZjU+cWv3MMHkEo+cbUjqnTVW1/7EQ=\n=qpHR\n-----END PGP SIGNATURE-----\n", "payload": "tree 6c0d0cbde03a3f593256d76e7ab3784349868a3b\nparent 212fa29a69af5f0f0de30a1d450bb4cd978a0c3e\nparent f2f6a46aa4751393ae18e8b21aa631c9919c5f43\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1593852148 +0000\ncommitter GitHub <noreply@github.com> 1593852148 +0000\n\nMerge #5219\n\n5219: Cleanup dot completiont tests r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "html_url": "https://github.com/rust-lang/rust/commit/9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e", "html_url": "https://github.com/rust-lang/rust/commit/212fa29a69af5f0f0de30a1d450bb4cd978a0c3e"}, {"sha": "f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2f6a46aa4751393ae18e8b21aa631c9919c5f43", "html_url": "https://github.com/rust-lang/rust/commit/f2f6a46aa4751393ae18e8b21aa631c9919c5f43"}], "stats": {"total": 1996, "additions": 695, "deletions": 1301}, "files": [{"sha": "667a8b94993d263527ab4bba1ea269ef1936ef3e", "filename": "crates/ra_ide/src/completion/complete_dot.rs", "status": "modified", "additions": 266, "deletions": 722, "changes": 988, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -1,17 +1,12 @@\n-//! FIXME: write short doc here\n+//! Completes references after dot (fields and method calls).\n \n use hir::{HasVisibility, Type};\n-\n-use crate::{\n-    completion::{\n-        completion_context::CompletionContext,\n-        completion_item::{CompletionKind, Completions},\n-    },\n-    CompletionItem,\n-};\n use rustc_hash::FxHashSet;\n+use test_utils::mark;\n \n-/// Complete dot accesses, i.e. fields or methods (and .await syntax).\n+use crate::completion::{completion_context::CompletionContext, completion_item::Completions};\n+\n+/// Complete dot accesses, i.e. fields or methods.\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     let dot_receiver = match &ctx.dot_receiver {\n         Some(expr) => expr,\n@@ -23,18 +18,12 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n         _ => return,\n     };\n \n-    if !ctx.is_call {\n+    if ctx.is_call {\n+        mark::hit!(test_no_struct_field_completion_for_method_call);\n+    } else {\n         complete_fields(acc, ctx, &receiver_ty);\n     }\n     complete_methods(acc, ctx, &receiver_ty);\n-\n-    // Suggest .await syntax for types that implement Future trait\n-    if receiver_ty.impls_future(ctx.db) {\n-        CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n-            .detail(\"expr.await\")\n-            .insert_text(\"await\")\n-            .add_to(acc);\n-    }\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n@@ -72,801 +61,356 @@ fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &T\n \n #[cfg(test)]\n mod tests {\n-    use crate::completion::{test_utils::do_completion, CompletionItem, CompletionKind};\n-    use insta::assert_debug_snapshot;\n+    use expect::{expect, Expect};\n+    use test_utils::mark;\n+\n+    use crate::completion::{test_utils::completion_list, CompletionKind};\n \n-    fn do_ref_completion(code: &str) -> Vec<CompletionItem> {\n-        do_completion(code, CompletionKind::Reference)\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = completion_list(ra_fixture, CompletionKind::Reference);\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn test_struct_field_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                a.<|>\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 45..45,\n-                delete: 45..45,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+    fn test_struct_field_and_method_completion() {\n+        check(\n+            r#\"\n+struct S { foo: u32 }\n+impl S {\n+    fn bar(&self) {}\n+}\n+fn foo(s: S) { s.<|> }\n+\"#,\n+            expect![[r#\"\n+                me bar() fn bar(&self)\n+                fd foo u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_struct_field_completion_self() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {\n-                /// This is the_field\n-                the_field: (u32,)\n-            }\n-            impl A {\n-                fn foo(self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"foo()$0\",\n-                kind: Method,\n-                lookup: \"foo\",\n-                detail: \"fn foo(self)\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 102..102,\n-                delete: 102..102,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"(u32,)\",\n-                documentation: Documentation(\n-                    \"This is the_field\",\n-                ),\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+struct S { the_field: (u32,) }\n+impl S {\n+    fn foo(self) { self.<|> }\n+}\n+\"#,\n+            expect![[r#\"\n+                me foo() fn foo(self)\n+                fd the_field (u32,)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_struct_field_completion_autoderef() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: (u32, i32) }\n-            impl A {\n-                fn foo(&self) {\n-                    self.<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"foo()\",\n-                source_range: 77..77,\n-                delete: 77..77,\n-                insert: \"foo()$0\",\n-                kind: Method,\n-                lookup: \"foo\",\n-                detail: \"fn foo(&self)\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 77..77,\n-                delete: 77..77,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"(u32, i32)\",\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+struct A { the_field: (u32, i32) }\n+impl A {\n+    fn foo(&self) { self.<|> }\n+}\n+\"#,\n+            expect![[r#\"\n+                me foo() fn foo(&self)\n+                fd the_field (u32, i32)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_no_struct_field_completion_for_method_call() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            fn foo(a: A) {\n-               a.<|>()\n-            }\n-            \",\n-        ),\n-        @\"[]\"\n+        mark::check!(test_no_struct_field_completion_for_method_call);\n+        check(\n+            r#\"\n+struct A { the_field: u32 }\n+fn foo(a: A) { a.<|>() }\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n-    fn test_struct_field_visibility_private() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            mod inner {\n-                struct A {\n-                    private_field: u32,\n-                    pub pub_field: u32,\n-                    pub(crate) crate_field: u32,\n-                    pub(super) super_field: u32,\n-                }\n-            }\n-            fn foo(a: inner::A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"crate_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"crate_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"pub_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"pub_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"super_field\",\n-                source_range: 192..192,\n-                delete: 192..192,\n-                insert: \"super_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n-        );\n+    fn test_visibility_filtering() {\n+        check(\n+            r#\"\n+mod inner {\n+    pub struct A {\n+        private_field: u32,\n+        pub pub_field: u32,\n+        pub(crate) crate_field: u32,\n+        pub(super) super_field: u32,\n     }\n-\n-    #[test]\n-    fn test_union_field_completion() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            union Un {\n-                field: u8,\n-                other: u16,\n-            }\n-\n-            fn foo(u: Un) {\n-                u.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"field\",\n-                source_range: 67..67,\n-                delete: 67..67,\n-                insert: \"field\",\n-                kind: Field,\n-                detail: \"u8\",\n-            },\n-            CompletionItem {\n-                label: \"other\",\n-                source_range: 67..67,\n-                delete: 67..67,\n-                insert: \"other\",\n-                kind: Field,\n-                detail: \"u16\",\n-            },\n-        ]\n-        \"###\n+}\n+fn foo(a: inner::A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                fd crate_field u32\n+                fd pub_field u32\n+                fd super_field u32\n+            \"#]],\n         );\n-    }\n \n-    #[test]\n-    fn test_method_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {}\n-            impl A {\n-                fn the_method(&self) {}\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 71..71,\n-                delete: 71..71,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct A {}\n+mod m {\n+    impl super::A {\n+        fn private_method(&self) {}\n+        pub(super) fn the_method(&self) {}\n+    }\n+}\n+fn foo(a: A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() pub(super) fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_only_fitting_impls() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A<T> {}\n-            impl A<u32> {\n-                fn the_method(&self) {}\n-            }\n-            impl A<i32> {\n-                fn the_other_method(&self) {}\n-            }\n-            fn foo(a: A<u32>) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 134..134,\n-                delete: 134..134,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_union_field_completion() {\n+        check(\n+            r#\"\n+union U { field: u8, other: u16 }\n+fn foo(u: U) { u.<|> }\n+\"#,\n+            expect![[r#\"\n+                fd field u8\n+                fd other u16\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_private() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            mod m {\n-                impl super::A {\n-                    fn private_method(&self) {}\n-                    pub(super) fn the_method(&self) {}\n-                }\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 147..147,\n-                delete: 147..147,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"pub(super) fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n+    fn test_method_completion_only_fitting_impls() {\n+        check(\n+            r#\"\n+struct A<T> {}\n+impl A<u32> {\n+    fn the_method(&self) {}\n+}\n+impl A<i32> {\n+    fn the_other_method(&self) {}\n+}\n+fn foo(a: A<u32>) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_trait_method_completion() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            trait Trait { fn the_method(&self); }\n-            impl Trait for A {}\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 90..90,\n-                delete: 90..90,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+struct A {}\n+trait Trait { fn the_method(&self); }\n+impl Trait for A {}\n+fn foo(a: A) { a.<|> }\n+\"#,\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_trait_method_completion_deduplicated() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            trait Trait { fn the_method(&self); }\n-            impl<T> Trait for T {}\n-            fn foo(a: &A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 94..94,\n-                delete: 94..94,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r\"\n+struct A {}\n+trait Trait { fn the_method(&self); }\n+impl<T> Trait for T {}\n+fn foo(a: &A) { a.<|> }\n+\",\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn completes_trait_method_from_other_module() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct A {}\n-            mod m {\n-                pub trait Trait { fn the_method(&self); }\n-            }\n-            use m::Trait;\n-            impl Trait for A {}\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 122..122,\n-                delete: 122..122,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn test_no_non_self_method() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n+        check(\n             r\"\n-            struct A {}\n-            impl A {\n-                fn the_method() {}\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @\"[]\"\n+struct A {}\n+mod m {\n+    pub trait Trait { fn the_method(&self); }\n+}\n+use m::Trait;\n+impl Trait for A {}\n+fn foo(a: A) { a.<|> }\n+\",\n+            expect![[r#\"\n+                me the_method() fn the_method(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_attr_filtering() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A {}\n-            impl A {\n-                #[inline]\n-                fn the_method(&self) {\n-                    let x = 1;\n-                    let y = 2;\n-                }\n-            }\n-            fn foo(a: A) {\n-               a.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 128..128,\n-                delete: 128..128,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_no_non_self_method() {\n+        check(\n+            r#\"\n+struct A {}\n+impl A {\n+    fn the_method() {}\n+}\n+fn foo(a: A) {\n+   a.<|>\n+}\n+\"#,\n+            expect![[\"\"]],\n         );\n     }\n \n     #[test]\n     fn test_tuple_field_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            fn foo() {\n-               let b = (0, 3.14);\n-               b.<|>\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"0\",\n-                source_range: 38..38,\n-                delete: 38..38,\n-                insert: \"0\",\n-                kind: Field,\n-                detail: \"i32\",\n-            },\n-            CompletionItem {\n-                label: \"1\",\n-                source_range: 38..38,\n-                delete: 38..38,\n-                insert: \"1\",\n-                kind: Field,\n-                detail: \"f64\",\n-            },\n-        ]\n-        \"###\n-        );\n+        check(\n+            r#\"\n+fn foo() {\n+   let b = (0, 3.14);\n+   b.<|>\n+}\n+\"#,\n+            expect![[r#\"\n+                fd 0 i32\n+                fd 1 f64\n+            \"#]],\n+        )\n     }\n \n     #[test]\n     fn test_tuple_field_inference() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            pub struct S;\n-            impl S {\n-                pub fn blah(&self) {}\n-            }\n+        check(\n+            r#\"\n+pub struct S;\n+impl S { pub fn blah(&self) {} }\n \n-            struct T(S);\n+struct T(S);\n \n-            impl T {\n-                fn foo(&self) {\n-                    // FIXME: This doesn't work without the trailing `a` as `0.` is a float\n-                    self.0.a<|>\n-                }\n-            }\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"blah()\",\n-                source_range: 190..191,\n-                delete: 190..191,\n-                insert: \"blah()$0\",\n-                kind: Method,\n-                lookup: \"blah\",\n-                detail: \"pub fn blah(&self)\",\n-            },\n-        ]\n-        \"###\n-        );\n+impl T {\n+    fn foo(&self) {\n+        // FIXME: This doesn't work without the trailing `a` as `0.` is a float\n+        self.0.a<|>\n     }\n-\n-    #[test]\n-    fn test_completion_works_in_consts() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-            r\"\n-            struct A { the_field: u32 }\n-            const X: u32 = {\n-                A { the_field: 92 }.<|>\n-            };\n-            \",\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 69..69,\n-                delete: 69..69,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+}\n+\"#,\n+            expect![[r#\"\n+                me blah() pub fn blah(&self)\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_completion_await_impls_future() {\n-        assert_debug_snapshot!(\n-        do_completion(\n-            r###\"\n-            //- /main.rs\n-            use std::future::*;\n-            struct A {}\n-            impl Future for A {}\n-            fn foo(a: A) {\n-                a.<|>\n-            }\n-\n-            //- /std/lib.rs\n-            pub mod future {\n-                #[lang = \"future_trait\"]\n-                pub trait Future {}\n-            }\n-            \"###, CompletionKind::Keyword),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"await\",\n-                source_range: 74..74,\n-                delete: 74..74,\n-                insert: \"await\",\n-                detail: \"expr.await\",\n-            },\n-        ]\n-        \"###\n-        )\n-    }\n-\n-    #[test]\n-    fn test_super_super_completion() {\n-        assert_debug_snapshot!(\n-        do_ref_completion(\n-                r\"\n-                mod a {\n-                    const A: usize = 0;\n-\n-                    mod b {\n-                        const B: usize = 0;\n-\n-                        mod c {\n-                            use super::super::<|>\n-                        }\n-                    }\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"A\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"A\",\n-                kind: Const,\n-            },\n-            CompletionItem {\n-                label: \"b\",\n-                source_range: 120..120,\n-                delete: 120..120,\n-                insert: \"b\",\n-                kind: Module,\n-            },\n-        ]\n-        \"###\n+    fn test_completion_works_in_consts() {\n+        check(\n+            r#\"\n+struct A { the_field: u32 }\n+const X: u32 = {\n+    A { the_field: 92 }.<|>\n+};\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_1() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.x<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..92,\n-                delete: 91..92,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n-        );\n-    }\n-\n-    #[test]\n-    fn works_in_simple_macro_recursive() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.x<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..92,\n-                delete: 91..92,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(a.x<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_2() {\n         // this doesn't work yet because the macro doesn't expand without the token -- maybe it can be fixed with better recovery\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(a.<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 91..91,\n-                delete: 91..91,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(a.<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn works_in_simple_macro_recursive_1() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! m { ($e:expr) => { $e } }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    m!(m!(m!(a.x<|>)))\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 97..98,\n-                delete: 97..98,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! m { ($e:expr) => { $e } }\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    m!(m!(m!(a.x<|>)))\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn macro_expansion_resilient() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-                macro_rules! dbg {\n-                    () => {};\n-                    ($val:expr) => {\n-                        match $val { tmp => { tmp } }\n-                    };\n-                    // Trailing comma with single argument is ignored\n-                    ($val:expr,) => { $crate::dbg!($val) };\n-                    ($($val:expr),+ $(,)?) => {\n-                        ($($crate::dbg!($val)),+,)\n-                    };\n-                }\n-                struct A { the_field: u32 }\n-                fn foo(a: A) {\n-                    dbg!(a.<|>)\n-                }\n-                \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 327..327,\n-                delete: 327..327,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+macro_rules! dbg {\n+    () => {};\n+    ($val:expr) => {\n+        match $val { tmp => { tmp } }\n+    };\n+    // Trailing comma with single argument is ignored\n+    ($val:expr,) => { $crate::dbg!($val) };\n+    ($($val:expr),+ $(,)?) => {\n+        ($($crate::dbg!($val)),+,)\n+    };\n+}\n+struct A { the_field: u32 }\n+fn foo(a: A) {\n+    dbg!(a.<|>)\n+}\n+\"#,\n+            expect![[r#\"\n+                fd the_field u32\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_method_completion_3547() {\n-        assert_debug_snapshot!(\n-            do_ref_completion(\n-                r\"\n-            struct HashSet<T> {}\n-            impl<T> HashSet<T> {\n-                pub fn the_method(&self) {}\n-            }\n-            fn foo() {\n-                let s: HashSet<_>;\n-                s.<|>\n-            }\n-            \",\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_method()\",\n-                source_range: 116..116,\n-                delete: 116..116,\n-                insert: \"the_method()$0\",\n-                kind: Method,\n-                lookup: \"the_method\",\n-                detail: \"pub fn the_method(&self)\",\n-            },\n-        ]\n-        \"###\n+    fn test_method_completion_issue_3547() {\n+        check(\n+            r#\"\n+struct HashSet<T> {}\n+impl<T> HashSet<T> {\n+    pub fn the_method(&self) {}\n+}\n+fn foo() {\n+    let s: HashSet<_>;\n+    s.<|>\n+}\n+\"#,\n+            expect![[r#\"\n+                me the_method() pub fn the_method(&self)\n+            \"#]],\n         );\n     }\n }"}, {"sha": "340d57a49c605f2b0769749d989bcfb310af06c2", "filename": "crates/ra_ide/src/completion/complete_keyword.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_keyword.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -35,6 +35,19 @@ pub(super) fn complete_use_tree_keyword(acc: &mut Completions, ctx: &CompletionC\n         }\n         _ => {}\n     }\n+\n+    // Suggest .await syntax for types that implement Future trait\n+    if let Some(receiver) = &ctx.dot_receiver {\n+        if let Some(ty) = ctx.sema.type_of_expr(receiver) {\n+            if ty.impls_future(ctx.db) {\n+                CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n+                    .kind(CompletionItemKind::Keyword)\n+                    .detail(\"expr.await\")\n+                    .insert_text(\"await\")\n+                    .add_to(acc);\n+            }\n+        };\n+    }\n }\n \n pub(super) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -490,4 +503,26 @@ Some multi-line comment<|>\n             expect![[\"\"]],\n         );\n     }\n+\n+    #[test]\n+    fn test_completion_await_impls_future() {\n+        check(\n+            r#\"\n+//- /main.rs\n+use std::future::*;\n+struct A {}\n+impl Future for A {}\n+fn foo(a: A) { a.<|> }\n+\n+//- /std/lib.rs\n+pub mod future {\n+    #[lang = \"future_trait\"]\n+    pub trait Future {}\n+}\n+\"#,\n+            expect![[r#\"\n+                kw await expr.await\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "a16866cd2d4223dfbd1aee054bb3cd3a697c44dd", "filename": "crates/ra_ide/src/completion/complete_qualified_path.rs", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_qualified_path.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -1205,6 +1205,45 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_super_super_completion() {\n+        assert_debug_snapshot!(\n+            do_reference_completion(\n+                r\"\n+                mod a {\n+                    const A: usize = 0;\n+\n+                    mod b {\n+                        const B: usize = 0;\n+\n+                        mod c {\n+                            use super::super::<|>\n+                        }\n+                    }\n+                }\n+                \",\n+        ),\n+            @r###\"\n+        [\n+            CompletionItem {\n+                label: \"A\",\n+                source_range: 120..120,\n+                delete: 120..120,\n+                insert: \"A\",\n+                kind: Const,\n+            },\n+            CompletionItem {\n+                label: \"b\",\n+                source_range: 120..120,\n+                delete: 120..120,\n+                insert: \"b\",\n+                kind: Module,\n+            },\n+        ]\n+        \"###\n+        );\n+    }\n+\n     #[test]\n     fn completes_reexported_items_under_correct_name() {\n         assert_debug_snapshot!("}, {"sha": "477d6f6f6429516afab081a77182734555c61bd3", "filename": "crates/ra_ide/src/completion/completion_item.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcompletion_item.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -95,7 +95,7 @@ impl fmt::Debug for CompletionItem {\n     }\n }\n \n-#[derive(Debug, Clone, Copy)]\n+#[derive(Debug, Clone, Copy, Ord, PartialOrd, Eq, PartialEq)]\n pub enum CompletionScore {\n     /// If only type match\n     TypeMatch,"}, {"sha": "dc391c46bc1d24c27030100a8da3c70f87eebeb6", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 342, "deletions": 569, "changes": 911, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -1,4 +1,5 @@\n //! This modules takes care of rendering various definitions as completion items.\n+//! It also handles scoring (sorting) completions.\n \n use hir::{Docs, HasAttrs, HasSource, HirDisplay, ModPath, ScopeDef, StructKind, Type};\n use ra_syntax::ast::NameOwner;\n@@ -330,14 +331,14 @@ pub(crate) fn compute_score(\n     // FIXME: this should not fall back to string equality.\n     let ty = &ty.display(ctx.db).to_string();\n     let (active_name, active_type) = if let Some(record_field) = &ctx.record_field_syntax {\n-        mark::hit!(test_struct_field_completion_in_record_lit);\n+        mark::hit!(record_field_type_match);\n         let (struct_field, _local) = ctx.sema.resolve_record_field(record_field)?;\n         (\n             struct_field.name(ctx.db).to_string(),\n             struct_field.signature_ty(ctx.db).display(ctx.db).to_string(),\n         )\n     } else if let Some(active_parameter) = &ctx.active_parameter {\n-        mark::hit!(test_struct_field_completion_in_func_call);\n+        mark::hit!(active_param_type_match);\n         (active_parameter.name.clone(), active_parameter.ty.clone())\n     } else {\n         return None;\n@@ -461,174 +462,254 @@ fn guess_macro_braces(macro_name: &str, docs: &str) -> (&'static str, &'static s\n \n #[cfg(test)]\n mod tests {\n-    use insta::assert_debug_snapshot;\n+    use std::cmp::Reverse;\n+\n+    use expect::{expect, Expect};\n     use test_utils::mark;\n \n-    use crate::completion::{\n-        test_utils::{check_edit, check_edit_with_config, do_completion},\n-        CompletionConfig, CompletionItem, CompletionKind,\n+    use crate::{\n+        completion::{\n+            test_utils::{\n+                check_edit, check_edit_with_config, do_completion, get_all_completion_items,\n+            },\n+            CompletionConfig, CompletionKind,\n+        },\n+        CompletionScore,\n     };\n \n-    fn do_reference_completion(ra_fixture: &str) -> Vec<CompletionItem> {\n-        do_completion(ra_fixture, CompletionKind::Reference)\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        let actual = do_completion(ra_fixture, CompletionKind::Reference);\n+        expect.assert_debug_eq(&actual);\n+    }\n+\n+    fn check_scores(ra_fixture: &str, expect: Expect) {\n+        fn display_score(score: Option<CompletionScore>) -> &'static str {\n+            match score {\n+                Some(CompletionScore::TypeMatch) => \"[type]\",\n+                Some(CompletionScore::TypeAndNameMatch) => \"[type+name]\",\n+                None => \"[]\".into(),\n+            }\n+        }\n+\n+        let mut completions = get_all_completion_items(ra_fixture, &CompletionConfig::default());\n+        completions.sort_by_key(|it| (Reverse(it.score()), it.label().to_string()));\n+        let actual = completions\n+            .into_iter()\n+            .filter(|it| it.completion_kind == CompletionKind::Reference)\n+            .map(|it| {\n+                let tag = it.kind().unwrap().tag();\n+                let score = display_score(it.score());\n+                format!(\"{} {} {}\\n\", tag, it.label(), score)\n+            })\n+            .collect::<String>();\n+        expect.assert_eq(&actual);\n     }\n \n     #[test]\n-    fn enum_detail_includes_names_for_record() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n+    fn enum_detail_includes_record_fields() {\n+        check(\n             r#\"\n-                enum Foo {\n-                    Foo {x: i32, y: i32}\n-                }\n+enum Foo { Foo { x: i32, y: i32 } }\n \n-                fn main() { Foo::Fo<|> }\n-                \"#,\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Foo\",\n-                source_range: 56..58,\n-                delete: 56..58,\n-                insert: \"Foo\",\n-                kind: EnumVariant,\n-                detail: \"{ x: i32, y: i32 }\",\n-            },\n-        ]\n-        \"###\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 54..56,\n+                        delete: 54..56,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"{ x: i32, y: i32 }\",\n+                    },\n+                ]\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn enum_detail_doesnt_include_names_for_tuple() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n+    fn enum_detail_doesnt_include_tuple_fields() {\n+        check(\n             r#\"\n-                enum Foo {\n-                    Foo (i32, i32)\n-                }\n+enum Foo { Foo (i32, i32) }\n \n-                fn main() { Foo::Fo<|> }\n-                \"#,\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Foo(\u2026)\",\n-                source_range: 50..52,\n-                delete: 50..52,\n-                insert: \"Foo($0)\",\n-                kind: EnumVariant,\n-                lookup: \"Foo\",\n-                detail: \"(i32, i32)\",\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo(\u2026)\",\n+                        source_range: 46..48,\n+                        delete: 46..48,\n+                        insert: \"Foo($0)\",\n+                        kind: EnumVariant,\n+                        lookup: \"Foo\",\n+                        detail: \"(i32, i32)\",\n+                        trigger_call_info: true,\n+                    },\n+                ]\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn enum_detail_just_parentheses_for_unit() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n+        check(\n             r#\"\n-                enum Foo {\n-                    Foo\n-                }\n+enum Foo { Foo }\n \n-                fn main() { Foo::Fo<|> }\n-                \"#,\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Foo\",\n-                source_range: 39..41,\n-                delete: 39..41,\n-                insert: \"Foo\",\n-                kind: EnumVariant,\n-                detail: \"()\",\n-            },\n-        ]\n-        \"###\n+fn main() { Foo::Fo<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"Foo\",\n+                        source_range: 35..37,\n+                        delete: 35..37,\n+                        insert: \"Foo\",\n+                        kind: EnumVariant,\n+                        detail: \"()\",\n+                    },\n+                ]\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn sets_deprecated_flag_in_completion_items() {\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r#\"\n-                #[deprecated]\n-                fn something_deprecated() {}\n-\n-                #[deprecated(since = \"1.0.0\")]\n-                fn something_else_deprecated() {}\n-\n-                fn main() { som<|> }\n-                \"#,\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"main()\",\n-                source_range: 122..125,\n-                delete: 122..125,\n-                insert: \"main()$0\",\n-                kind: Function,\n-                lookup: \"main\",\n-                detail: \"fn main()\",\n-            },\n-            CompletionItem {\n-                label: \"something_deprecated()\",\n-                source_range: 122..125,\n-                delete: 122..125,\n-                insert: \"something_deprecated()$0\",\n-                kind: Function,\n-                lookup: \"something_deprecated\",\n-                detail: \"fn something_deprecated()\",\n-                deprecated: true,\n-            },\n-            CompletionItem {\n-                label: \"something_else_deprecated()\",\n-                source_range: 122..125,\n-                delete: 122..125,\n-                insert: \"something_else_deprecated()$0\",\n-                kind: Function,\n-                lookup: \"something_else_deprecated\",\n-                detail: \"fn something_else_deprecated()\",\n-                deprecated: true,\n-            },\n-        ]\n-        \"###\n+        check(\n+            r#\"\n+#[deprecated]\n+fn something_deprecated() {}\n+#[deprecated(since = \"1.0.0\")]\n+fn something_else_deprecated() {}\n+\n+fn main() { som<|> }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"main()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"main()$0\",\n+                        kind: Function,\n+                        lookup: \"main\",\n+                        detail: \"fn main()\",\n+                    },\n+                    CompletionItem {\n+                        label: \"something_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_deprecated\",\n+                        detail: \"fn something_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                    CompletionItem {\n+                        label: \"something_else_deprecated()\",\n+                        source_range: 121..124,\n+                        delete: 121..124,\n+                        insert: \"something_else_deprecated()$0\",\n+                        kind: Function,\n+                        lookup: \"something_else_deprecated\",\n+                        detail: \"fn something_else_deprecated()\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n+        );\n+\n+        check(\n+            r#\"\n+struct A { #[deprecated] the_field: u32 }\n+fn foo() { A { the<|> } }\n+\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_field\",\n+                        source_range: 57..60,\n+                        delete: 57..60,\n+                        insert: \"the_field\",\n+                        kind: Field,\n+                        detail: \"u32\",\n+                        deprecated: true,\n+                    },\n+                ]\n+            \"#]],\n         );\n+    }\n \n-        assert_debug_snapshot!(do_reference_completion(\n+    #[test]\n+    fn renders_docs() {\n+        check(\n             r#\"\n-struct A {\n-    #[deprecated]\n-    the_field: u32,\n+struct S {\n+    /// Field docs\n+    foo:\n }\n-fn foo() {\n-   A { the<|> }\n+impl S {\n+    /// Method docs\n+    fn bar(self) { self.<|> }\n+}\"#,\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"bar()\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"bar()$0\",\n+                        kind: Method,\n+                        lookup: \"bar\",\n+                        detail: \"fn bar(self)\",\n+                        documentation: Documentation(\n+                            \"Method docs\",\n+                        ),\n+                    },\n+                    CompletionItem {\n+                        label: \"foo\",\n+                        source_range: 94..94,\n+                        delete: 94..94,\n+                        insert: \"foo\",\n+                        kind: Field,\n+                        detail: \"{unknown}\",\n+                        documentation: Documentation(\n+                            \"Field docs\",\n+                        ),\n+                    },\n+                ]\n+            \"#]],\n+        )\n+    }\n+\n+    #[test]\n+    fn dont_render_attrs() {\n+        check(\n+            r#\"\n+struct S;\n+impl S {\n+    #[inline]\n+    fn the_method(&self) { }\n }\n+fn foo(s: S) { s.<|> }\n \"#,\n-        ),\n-        @r###\"\n-        [\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 69..72,\n-                delete: 69..72,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                deprecated: true,\n-            },\n-        ]\n-        \"###);\n+            expect![[r#\"\n+                [\n+                    CompletionItem {\n+                        label: \"the_method()\",\n+                        source_range: 81..81,\n+                        delete: 81..81,\n+                        insert: \"the_method()$0\",\n+                        kind: Method,\n+                        lookup: \"the_method\",\n+                        detail: \"fn the_method(&self)\",\n+                    },\n+                ]\n+            \"#]],\n+        )\n     }\n \n     #[test]\n@@ -844,466 +925,158 @@ fn f(foo: &Foo) { foo.foo(); }\n     #[test]\n     fn inserts_angle_brackets_for_generics() {\n         mark::check!(inserts_angle_brackets_for_generics);\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                struct Vec<T> {}\n-                fn foo(xs: Ve<|>)\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Vec<\u2026>\",\n-                source_range: 28..30,\n-                delete: 28..30,\n-                insert: \"Vec<$0>\",\n-                kind: Struct,\n-                lookup: \"Vec\",\n-            },\n-            CompletionItem {\n-                label: \"foo(\u2026)\",\n-                source_range: 28..30,\n-                delete: 28..30,\n-                insert: \"foo(${1:xs})$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo(xs: Ve)\",\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<$0>)\n+\"#,\n         );\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                type Vec<T> = (T,);\n-                fn foo(xs: Ve<|>)\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Vec<\u2026>\",\n-                source_range: 31..33,\n-                delete: 31..33,\n-                insert: \"Vec<$0>\",\n-                kind: TypeAlias,\n-                lookup: \"Vec\",\n-            },\n-            CompletionItem {\n-                label: \"foo(\u2026)\",\n-                source_range: 31..33,\n-                delete: 31..33,\n-                insert: \"foo(${1:xs})$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo(xs: Ve)\",\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+type Vec<T> = (T,);\n+fn foo(xs: Vec<$0>)\n+\"#,\n         );\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                struct Vec<T = i128> {}\n-                fn foo(xs: Ve<|>)\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Vec\",\n-                source_range: 35..37,\n-                delete: 35..37,\n-                insert: \"Vec\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"foo(\u2026)\",\n-                source_range: 35..37,\n-                delete: 35..37,\n-                insert: \"foo(${1:xs})$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo(xs: Ve)\",\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Ve<|>)\n+\"#,\n+            r#\"\n+struct Vec<T = i128> {}\n+fn foo(xs: Vec)\n+\"#,\n         );\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                struct Vec<T> {}\n-                fn foo(xs: Ve<|><i128>)\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"Vec\",\n-                source_range: 28..30,\n-                delete: 28..30,\n-                insert: \"Vec\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"foo(\u2026)\",\n-                source_range: 28..30,\n-                delete: 28..30,\n-                insert: \"foo(${1:xs})$0\",\n-                kind: Function,\n-                lookup: \"foo\",\n-                detail: \"fn foo(xs: Ve<i128>)\",\n-                trigger_call_info: true,\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"Vec\",\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Ve<|><i128>)\n+\"#,\n+            r#\"\n+struct Vec<T> {}\n+fn foo(xs: Vec<i128>)\n+\"#,\n         );\n     }\n \n     #[test]\n     fn dont_insert_macro_call_parens_unncessary() {\n         mark::check!(dont_insert_macro_call_parens_unncessary);\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                //- /main.rs\n-                use foo::<|>;\n-\n-                //- /foo/lib.rs\n-                #[macro_export]\n-                macro_rules frobnicate {\n-                    () => ()\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"frobnicate!\",\n-                source_range: 9..9,\n-                delete: 9..9,\n-                insert: \"frobnicate\",\n-                kind: Macro,\n-                detail: \"#[macro_export]\\nmacro_rules! frobnicate\",\n-            },\n-        ]\n-        \"###\n-        );\n-\n-        assert_debug_snapshot!(\n-            do_reference_completion(\n-                r\"\n-                //- /main.rs\n-                macro_rules frobnicate {\n-                    () => ()\n-                }\n-                fn main() {\n-                    frob<|>!();\n-                }\n-                \"\n-            ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"frobnicate!\",\n-                source_range: 56..60,\n-                delete: 56..60,\n-                insert: \"frobnicate\",\n-                kind: Macro,\n-                detail: \"macro_rules! frobnicate\",\n-            },\n-            CompletionItem {\n-                label: \"main()\",\n-                source_range: 56..60,\n-                delete: 56..60,\n-                insert: \"main()$0\",\n-                kind: Function,\n-                lookup: \"main\",\n-                detail: \"fn main()\",\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+//- /main.rs\n+use foo::<|>;\n+//- /foo/lib.rs\n+#[macro_export]\n+macro_rules frobnicate { () => () }\n+\"#,\n+            r#\"\n+use foo::frobnicate;\n+\"#,\n         );\n-    }\n \n-    #[test]\n-    fn test_struct_field_completion_in_func_call() {\n-        mark::check!(test_struct_field_completion_in_func_call);\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                struct A { another_field: i64, the_field: u32, my_string: String }\n-                fn test(my_param: u32) -> u32 { my_param }\n-                fn foo(a: A) {\n-                    test(a.<|>)\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: 136..136,\n-                delete: 136..136,\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"my_string\",\n-                source_range: 136..136,\n-                delete: 136..136,\n-                insert: \"my_string\",\n-                kind: Field,\n-                detail: \"{unknown}\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 136..136,\n-                delete: 136..136,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-        ]\n-        \"###\n+        check_edit(\n+            \"frobnicate!\",\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frob<|>!(); }\n+\"#,\n+            r#\"\n+macro_rules frobnicate { () => () }\n+fn main() { frobnicate!(); }\n+\"#,\n         );\n     }\n \n     #[test]\n-    fn test_struct_field_completion_in_func_call_with_type_and_name() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                fn test(the_field: u32) -> u32 { the_field }\n-                fn foo(a: A) {\n-                    test(a.<|>)\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: 143..143,\n-                delete: 143..143,\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: 143..143,\n-                delete: 143..143,\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 143..143,\n-                delete: 143..143,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n+    fn active_param_score() {\n+        mark::check!(active_param_type_match);\n+        check_scores(\n+            r#\"\n+struct S { foo: i64, bar: u32, baz: u32 }\n+fn test(bar: u32) { }\n+fn foo(s: S) { test(s.<|>) }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n         );\n     }\n \n     #[test]\n-    fn test_struct_field_completion_in_record_lit() {\n-        mark::check!(test_struct_field_completion_in_record_lit);\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn foo(a: A) {\n-                    let b = B {\n-                        the_field: a.<|>\n-                    };\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: 189..189,\n-                delete: 189..189,\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: 189..189,\n-                delete: 189..189,\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 189..189,\n-                delete: 189..189,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n-        );\n+    fn record_field_scores() {\n+        mark::check!(record_field_type_match);\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn foo(a: A) { B { bar: a.<|> }; }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n+        )\n     }\n \n     #[test]\n-    fn test_struct_field_completion_in_record_lit_and_fn_call() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn test(the_field: i64) -> i64 { the_field }\n-                fn foo(a: A) {\n-                    let b = B {\n-                        the_field: test(a.<|>)\n-                    };\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: 239..239,\n-                delete: 239..239,\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: 239..239,\n-                delete: 239..239,\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 239..239,\n-                delete: 239..239,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-            },\n-        ]\n-        \"###\n+    fn record_field_and_call_scores() {\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { B { bar: f(a.<|>) }; }\n+\"#,\n+            expect![[r#\"\n+                fd foo [type+name]\n+                fd bar []\n+                fd baz []\n+            \"#]],\n         );\n-    }\n-\n-    #[test]\n-    fn test_struct_field_completion_in_fn_call_and_record_lit() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                struct A { another_field: i64, another_good_type: u32, the_field: u32 }\n-                struct B { my_string: String, my_vec: Vec<u32>, the_field: u32 }\n-                fn test(the_field: i64) -> i64 { the_field }\n-                fn foo(a: A) {\n-                    test(B {\n-                        the_field: a.<|>\n-                    });\n-                }\n-                \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"another_field\",\n-                source_range: 231..231,\n-                delete: 231..231,\n-                insert: \"another_field\",\n-                kind: Field,\n-                detail: \"i64\",\n-            },\n-            CompletionItem {\n-                label: \"another_good_type\",\n-                source_range: 231..231,\n-                delete: 231..231,\n-                insert: \"another_good_type\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeMatch,\n-            },\n-            CompletionItem {\n-                label: \"the_field\",\n-                source_range: 231..231,\n-                delete: 231..231,\n-                insert: \"the_field\",\n-                kind: Field,\n-                detail: \"u32\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n+        check_scores(\n+            r#\"\n+struct A { foo: i64, bar: u32, baz: u32 }\n+struct B { x: (), y: f32, bar: u32 }\n+fn f(foo: i64) {  }\n+fn foo(a: A) { f(B { bar: a.<|> }); }\n+\"#,\n+            expect![[r#\"\n+                fd bar [type+name]\n+                fd baz [type]\n+                fd foo []\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn prioritize_exact_ref_match() {\n-        assert_debug_snapshot!(\n-        do_reference_completion(\n-                r\"\n-                    struct WorldSnapshot { _f: () };\n-                    fn go(world: &WorldSnapshot) {\n-                        go(w<|>)\n-                    }\n-                    \",\n-        ),\n-            @r###\"\n-        [\n-            CompletionItem {\n-                label: \"WorldSnapshot\",\n-                source_range: 71..72,\n-                delete: 71..72,\n-                insert: \"WorldSnapshot\",\n-                kind: Struct,\n-            },\n-            CompletionItem {\n-                label: \"go(\u2026)\",\n-                source_range: 71..72,\n-                delete: 71..72,\n-                insert: \"go(${1:world})$0\",\n-                kind: Function,\n-                lookup: \"go\",\n-                detail: \"fn go(world: &WorldSnapshot)\",\n-                trigger_call_info: true,\n-            },\n-            CompletionItem {\n-                label: \"world\",\n-                source_range: 71..72,\n-                delete: 71..72,\n-                insert: \"world\",\n-                kind: Binding,\n-                detail: \"&WorldSnapshot\",\n-                score: TypeAndNameMatch,\n-            },\n-        ]\n-        \"###\n+        check_scores(\n+            r#\"\n+struct WorldSnapshot { _f: () };\n+fn go(world: &WorldSnapshot) { go(w<|>) }\n+\"#,\n+            expect![[r#\"\n+                bn world [type+name]\n+                st WorldSnapshot []\n+                fn go(\u2026) []\n+            \"#]],\n         );\n     }\n }"}, {"sha": "cbae1da859a41c14818b448c1ff972be9200958b", "filename": "crates/ra_ide/src/completion/test_utils.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f754e0518e7f2860891079a117a3e4bc6f4a8fd/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Ftest_utils.rs?ref=9f754e0518e7f2860891079a117a3e4bc6f4a8fd", "patch": "@@ -13,15 +13,15 @@ use crate::{\n };\n \n pub(crate) fn do_completion(code: &str, kind: CompletionKind) -> Vec<CompletionItem> {\n-    do_completion_with_options(code, kind, &CompletionConfig::default())\n+    do_completion_with_config(code, kind, &CompletionConfig::default())\n }\n \n-pub(crate) fn do_completion_with_options(\n+pub(crate) fn do_completion_with_config(\n     code: &str,\n     kind: CompletionKind,\n-    options: &CompletionConfig,\n+    config: &CompletionConfig,\n ) -> Vec<CompletionItem> {\n-    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, options)\n+    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, config)\n         .into_iter()\n         .filter(|c| c.completion_kind == kind)\n         .collect();\n@@ -30,15 +30,15 @@ pub(crate) fn do_completion_with_options(\n }\n \n pub(crate) fn completion_list(code: &str, kind: CompletionKind) -> String {\n-    completion_list_with_options(code, kind, &CompletionConfig::default())\n+    completion_list_with_config(code, kind, &CompletionConfig::default())\n }\n \n-pub(crate) fn completion_list_with_options(\n+pub(crate) fn completion_list_with_config(\n     code: &str,\n     kind: CompletionKind,\n-    options: &CompletionConfig,\n+    config: &CompletionConfig,\n ) -> String {\n-    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, options)\n+    let mut kind_completions: Vec<CompletionItem> = get_all_completion_items(code, config)\n         .into_iter()\n         .filter(|c| c.completion_kind == kind)\n         .collect();\n@@ -92,7 +92,10 @@ pub(crate) fn check_pattern_is_applicable(code: &str, check: fn(SyntaxElement) -\n         .unwrap();\n }\n \n-fn get_all_completion_items(code: &str, options: &CompletionConfig) -> Vec<CompletionItem> {\n+pub(crate) fn get_all_completion_items(\n+    code: &str,\n+    options: &CompletionConfig,\n+) -> Vec<CompletionItem> {\n     let (analysis, position) = analysis_and_position(code);\n     analysis.completions(options, position).unwrap().unwrap().into()\n }"}]}