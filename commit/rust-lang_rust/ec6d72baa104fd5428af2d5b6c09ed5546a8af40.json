{"sha": "ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "node_id": "C_kwDOAAsO6NoAKGVjNmQ3MmJhYTEwNGZkNTQyOGFmMmQ1YjZjMDllZDU1NDZhOGFmNDA", "commit": {"author": {"name": "Emilio Cobos \u00c1lvarez", "email": "emilio@crisal.io", "date": "2022-10-21T20:04:43Z"}, "committer": {"name": "Emilio Cobos \u00c1lvarez", "email": "emilio@crisal.io", "date": "2022-10-22T13:21:31Z"}, "message": "scip: Rewrite tests to be closer to what we actually do.\n\nIt's also less code.", "tree": {"sha": "1b9b74bb5676b55294a999069c5511dd0f308e10", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b9b74bb5676b55294a999069c5511dd0f308e10"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE53alAzPAxlP8it4A4RUtCZTkv4oFAmNT7lsACgkQ4RUtCZTk\nv4pAeg//XFVAJzShE4qpVxARjpC8yoTgk7MxmGQtVQbVXMN8BX3xc+0vXh4dPpB7\nnNnip71L0BuEgOLa/fQAXEww8aVqsmbDXa8QjdS2uE8aLiILvSzVn7DCw2vi3bW2\n3jMJK9n0dB5HYvDCyEGempNI+cykZKp5TmQSVT/CX6jEl92z82IFkd//tx12c7Q+\nn0hfs8PDkEDcG5Y1fj5cUoNynYQOdof/uSlxCDeYivwyjECvGxxTcDzN/nbmHHjt\nQIRU9VsDDIGigsYSgpEqILk6EpZ3/OBGXwx8q8iSf2u04wbUDnYRIc4IUUznSWR0\nModmNc68Y5Dq9rzAUakktuaComs+5bB2zDuksV+Xg2sX8qJmhiFA9XlmIYwq94aq\nGjc58jyth8jYdZhyJdzpsC6qPkLe6o83bwoUyV+a5ZMOUTZQDbIJYWnhU4Fqnbjp\nFaicFFKOqgD3ITZyQaUKE2j18qBHWSpkgZVLJbmq5Un+f3Qo6P0+Suqo2/cxWVcw\n4yTXiphLNOfbzee5xErnnTHD284nOprX/9/EqbRtFssiaDcW0Z2NiibFTvtinM+K\ntFJ7jlHWXiHBr+zU5ddwg41xgeoGiV9MrLoee7c1jqJKv0LmAtyxF2efG3znC4fx\n5E4gaH6SPYEpNViPhEKuG1WvxcHggQegTqaBRq6sHBkXPs7w25E=\n=C5+F\n-----END PGP SIGNATURE-----", "payload": "tree 1b9b74bb5676b55294a999069c5511dd0f308e10\nparent 7ee72256eba49faa53b6885460b5769279893885\nauthor Emilio Cobos \u00c1lvarez <emilio@crisal.io> 1666382683 +0200\ncommitter Emilio Cobos \u00c1lvarez <emilio@crisal.io> 1666444891 +0200\n\nscip: Rewrite tests to be closer to what we actually do.\n\nIt's also less code.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "html_url": "https://github.com/rust-lang/rust/commit/ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ec6d72baa104fd5428af2d5b6c09ed5546a8af40/comments", "author": {"login": "emilio", "id": 1323194, "node_id": "MDQ6VXNlcjEzMjMxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1323194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emilio", "html_url": "https://github.com/emilio", "followers_url": "https://api.github.com/users/emilio/followers", "following_url": "https://api.github.com/users/emilio/following{/other_user}", "gists_url": "https://api.github.com/users/emilio/gists{/gist_id}", "starred_url": "https://api.github.com/users/emilio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emilio/subscriptions", "organizations_url": "https://api.github.com/users/emilio/orgs", "repos_url": "https://api.github.com/users/emilio/repos", "events_url": "https://api.github.com/users/emilio/events{/privacy}", "received_events_url": "https://api.github.com/users/emilio/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emilio", "id": 1323194, "node_id": "MDQ6VXNlcjEzMjMxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1323194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emilio", "html_url": "https://github.com/emilio", "followers_url": "https://api.github.com/users/emilio/followers", "following_url": "https://api.github.com/users/emilio/following{/other_user}", "gists_url": "https://api.github.com/users/emilio/gists{/gist_id}", "starred_url": "https://api.github.com/users/emilio/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emilio/subscriptions", "organizations_url": "https://api.github.com/users/emilio/orgs", "repos_url": "https://api.github.com/users/emilio/repos", "events_url": "https://api.github.com/users/emilio/events{/privacy}", "received_events_url": "https://api.github.com/users/emilio/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ee72256eba49faa53b6885460b5769279893885", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ee72256eba49faa53b6885460b5769279893885", "html_url": "https://github.com/rust-lang/rust/commit/7ee72256eba49faa53b6885460b5769279893885"}], "stats": {"total": 85, "additions": 30, "deletions": 55}, "files": [{"sha": "8b77ccde0ee4aaf94a4a9cfb0da3830fd44e951e", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 30, "deletions": 55, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/ec6d72baa104fd5428af2d5b6c09ed5546a8af40/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ec6d72baa104fd5428af2d5b6c09ed5546a8af40/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=ec6d72baa104fd5428af2d5b6c09ed5546a8af40", "patch": "@@ -8,8 +8,8 @@ use std::{\n use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n use hir::Name;\n use ide::{\n-    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n-    TokenId,\n+    LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n+    TokenStaticData,\n };\n use ide_db::LineIndexDatabase;\n use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n@@ -109,10 +109,7 @@ impl flags::Scip {\n                 occurrence.symbol = tokens_to_symbol\n                     .entry(id)\n                     .or_insert_with(|| {\n-                        let symbol = match &token.moniker {\n-                            Some(moniker) => moniker_to_symbol(&moniker),\n-                            None => new_local_symbol(),\n-                        };\n+                        let symbol = token_to_symbol(&token).unwrap_or_else(&mut new_local_symbol);\n                         scip::symbol::format_symbol(symbol)\n                     })\n                     .clone();\n@@ -201,9 +198,11 @@ fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_ty\n ///\n /// Only returns a Symbol when it's a non-local symbol.\n ///     So if the visibility isn't outside of a document, then it will return None\n-fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n     use scip_types::descriptor::Suffix::*;\n \n+    let moniker = token.moniker.as_ref()?;\n+\n     let package_name = moniker.package_information.name.clone();\n     let version = moniker.package_information.version.clone();\n     let descriptors = moniker\n@@ -227,7 +226,7 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         })\n         .collect();\n \n-    scip_types::Symbol {\n+    Some(scip_types::Symbol {\n         scheme: \"rust-analyzer\".into(),\n         package: Some(scip_types::Package {\n             manager: \"cargo\".to_string(),\n@@ -238,19 +237,15 @@ fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n         .into(),\n         descriptors,\n         ..Default::default()\n-    }\n+    })\n }\n \n #[cfg(test)]\n mod test {\n     use super::*;\n-    use hir::Semantics;\n-    use ide::{AnalysisHost, FilePosition};\n-    use ide_db::defs::IdentClass;\n-    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use ide::{AnalysisHost, FilePosition, StaticIndex, TextSize};\n+    use ide_db::base_db::fixture::ChangeFixture;\n     use scip::symbol::format_symbol;\n-    use syntax::SyntaxKind::*;\n-    use syntax::{AstNode, T};\n \n     fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n         let mut host = AnalysisHost::default();\n@@ -267,53 +262,33 @@ mod test {\n     fn check_symbol(ra_fixture: &str, expected: &str) {\n         let (host, position) = position(ra_fixture);\n \n+        let analysis = host.analysis();\n+        let si = StaticIndex::compute(&analysis);\n+\n         let FilePosition { file_id, offset } = position;\n \n-        let db = host.raw_database();\n-        let sema = &Semantics::new(db);\n-        let file = sema.parse(file_id).syntax().clone();\n-        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n-            IDENT\n-            | INT_NUMBER\n-            | LIFETIME_IDENT\n-            | T![self]\n-            | T![super]\n-            | T![crate]\n-            | T![Self]\n-            | COMMENT => 2,\n-            kind if kind.is_trivia() => 0,\n-            _ => 1,\n-        })\n-        .expect(\"OK OK\");\n-\n-        let navs = sema\n-            .descend_into_macros(original_token.clone())\n-            .into_iter()\n-            .filter_map(|token| {\n-                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n-                    it.into_iter().flat_map(|def| {\n-                        let module = def.module(db).unwrap();\n-                        let current_crate = module.krate();\n-\n-                        match MonikerResult::from_def(sema.db, def, current_crate) {\n-                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n-                            None => None,\n-                        }\n-                    })\n-                })\n-            })\n-            .flatten()\n-            .collect::<Vec<_>>();\n+        let mut found_symbol = None;\n+        for file in &si.files {\n+            if file.file_id != file_id {\n+                continue;\n+            }\n+            for &(range, id) in &file.tokens {\n+                if range.contains(offset - TextSize::from(1)) {\n+                    let token = si.tokens.get(id).unwrap();\n+                    found_symbol = token_to_symbol(token);\n+                    break;\n+                }\n+            }\n+        }\n \n         if expected == \"\" {\n-            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            assert!(found_symbol.is_none(), \"must have no symbols {:?}\", found_symbol);\n             return;\n         }\n \n-        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n-\n-        let res = navs.get(0).unwrap();\n-        let formatted = format_symbol(res.clone());\n+        assert!(found_symbol.is_some(), \"must have one symbol {:?}\", found_symbol);\n+        let res = found_symbol.unwrap();\n+        let formatted = format_symbol(res);\n         assert_eq!(formatted, expected);\n     }\n "}]}