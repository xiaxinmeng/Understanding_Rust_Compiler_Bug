{"sha": "264064df36e055c19af2c82145bbbe616b32fb02", "node_id": "C_kwDOAAsO6NoAKDI2NDA2NGRmMzZlMDU1YzE5YWYyYzgyMTQ1YmJiZTYxNmIzMmZiMDI", "commit": {"author": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-01-04T14:44:00Z"}, "committer": {"name": "Guillaume Gomez", "email": "guillaume.gomez@huawei.com", "date": "2022-04-18T18:59:08Z"}, "message": "* Greatly improve the rustdoc search parser source code\n* Move all functions outside parseQuery", "tree": {"sha": "ae9031f6c90138a37624c8ccbd75be38a97a6795", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae9031f6c90138a37624c8ccbd75be38a97a6795"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/264064df36e055c19af2c82145bbbe616b32fb02", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/264064df36e055c19af2c82145bbbe616b32fb02", "html_url": "https://github.com/rust-lang/rust/commit/264064df36e055c19af2c82145bbbe616b32fb02", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/264064df36e055c19af2c82145bbbe616b32fb02/comments", "author": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "committer": {"login": "GuillaumeGomez", "id": 3050060, "node_id": "MDQ6VXNlcjMwNTAwNjA=", "avatar_url": "https://avatars.githubusercontent.com/u/3050060?v=4", "gravatar_id": "", "url": "https://api.github.com/users/GuillaumeGomez", "html_url": "https://github.com/GuillaumeGomez", "followers_url": "https://api.github.com/users/GuillaumeGomez/followers", "following_url": "https://api.github.com/users/GuillaumeGomez/following{/other_user}", "gists_url": "https://api.github.com/users/GuillaumeGomez/gists{/gist_id}", "starred_url": "https://api.github.com/users/GuillaumeGomez/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/GuillaumeGomez/subscriptions", "organizations_url": "https://api.github.com/users/GuillaumeGomez/orgs", "repos_url": "https://api.github.com/users/GuillaumeGomez/repos", "events_url": "https://api.github.com/users/GuillaumeGomez/events{/privacy}", "received_events_url": "https://api.github.com/users/GuillaumeGomez/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99c5394ecc92190db16fc8dce1260658cbeedeb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/99c5394ecc92190db16fc8dce1260658cbeedeb1", "html_url": "https://github.com/rust-lang/rust/commit/99c5394ecc92190db16fc8dce1260658cbeedeb1"}], "stats": {"total": 1073, "additions": 563, "deletions": 510}, "files": [{"sha": "1fdd3068a033b5e4eaf3e271a5e0f54a60bb3ffe", "filename": "src/librustdoc/html/static/js/externs.js", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fexterns.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -8,7 +8,6 @@ function initSearch(searchIndex){}\n \n /**\n  * @typedef {{\n- *     isExact: boolean,\n  *     name: string,\n  *     fullPath: Array<string>,\n  *     pathWithoutLast: Array<string>,\n@@ -18,20 +17,25 @@ function initSearch(searchIndex){}\n  */\n var QueryElement;\n \n+/**\n+ * @typedef {{\n+ *      pos: number,\n+ *      totalElems: number,\n+ *      typeFilter: (null|string),\n+ *      userQuery: string,\n+ * }}\n+ */\n+var ParserState;\n+\n /**\n  * @typedef {{\n  *     original: string,\n  *     userQuery: string,\n- *     length: number,\n- *     pos: number,\n  *     typeFilter: number,\n  *     elems: Array<QueryElement>,\n- *     elemName: (string|null),\n  *     args: Array<QueryElement>,\n  *     returned: Array<QueryElement>,\n  *     foundElems: number,\n- *     id: string,\n- *     nameSplit: (string|null),\n  * }}\n  */\n var ParsedQuery;\n@@ -50,3 +54,31 @@ var ParsedQuery;\n  * }}\n  */\n var Row;\n+\n+/**\n+ * @typedef {{\n+ *    in_args: Array<Object>,\n+ *    returned: Array<Object>,\n+ *    others: Array<Object>,\n+ *    query: ParsedQuery,\n+ * }}\n+ */\n+var ResultsTable;\n+\n+/**\n+ * @typedef {{\n+ * crate: \"std\"\n+ *     desc: string,\n+ *     displayPath: string,\n+ *     fullPath: string,\n+ *     href: string,\n+ *     id: number,\n+ *     lev: number,\n+ *     name: string,\n+ *     normalizedName: string,\n+ *     parent: (Object|undefined),\n+ *     path: string,\n+ *     ty: number,\n+ * }}\n+ */\n+var Results;"}, {"sha": "7f21fa8bea6cee695779fd1e5dffeac8e1c7bf6e", "filename": "src/librustdoc/html/static/js/search.js", "status": "modified", "additions": 459, "deletions": 392, "changes": 851, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fjs%2Fsearch.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -124,6 +124,302 @@ window.initSearch = function(rawSearchIndex) {\n         searchState.input.value = params.search || \"\";\n     }\n \n+    function isWhitespace(c) {\n+        return \" \\t\\n\\r\".indexOf(c) !== -1;\n+    }\n+\n+    function isSpecialStartCharacter(c) {\n+        return \"(<\\\"\".indexOf(c) !== -1;\n+    }\n+\n+    function isStopCharacter(c) {\n+        return isWhitespace(c) || \"),>-=\".indexOf(c) !== -1;\n+    }\n+\n+    function removeEmptyStringsFromArray(arr) {\n+        for (var i = 0, len = arr.length; i < len; ++i) {\n+            if (arr[i] === \"\") {\n+                arr.splice(i, 1);\n+                i -= 1;\n+            }\n+        }\n+    }\n+\n+    function itemTypeFromName(typename) {\n+        for (var i = 0, len = itemTypes.length; i < len; ++i) {\n+            if (itemTypes[i] === typename) {\n+                return i;\n+            }\n+        }\n+        return NO_TYPE_FILTER;\n+    }\n+\n+    /**\n+     * If we encounter a `\"`, then we try to extract the string from it until we find another `\"`.\n+     *\n+     * This function will throw an error in the following cases:\n+     * * There is already another string element.\n+     * * We are parsing a generic argument.\n+     * * There is more than one element.\n+     * * There is no closing `\"`.\n+     *\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {boolean} isInGenerics\n+     */\n+    function getStringElem(query, parserState, isInGenerics) {\n+        if (isInGenerics) {\n+            throw new Error(\"`\\\"` cannot be used in generics\");\n+        } else if (query.literalSearch) {\n+            throw new Error(\"Cannot have more than one literal search element\");\n+        } else if (parserState.totalElems !== 0) {\n+            throw new Error(\"Cannot use literal search when there is more than one element\");\n+        }\n+        parserState.pos += 1;\n+        while (parserState.pos < parserState.length &&\n+            parserState.userQuery[parserState.pos] !== \"\\\"\")\n+        {\n+            parserState.pos += 1;\n+        }\n+        if (parserState.pos >= parserState.length) {\n+            throw new Error(\"Unclosed `\\\"`\");\n+        }\n+        // To skip the quote at the end.\n+        parserState.pos += 1;\n+        query.literalSearch = true;\n+    }\n+\n+    /**\n+     * Increase the parser position as long as the character is a whitespace. This check is\n+     * performed with the `isWhitespace` function.\n+     *\n+     * @param {ParserState} parserState\n+     */\n+    function skipWhitespaces(parserState) {\n+        while (parserState.pos < parserState.length) {\n+            var c = parserState.userQuery[parserState.pos];\n+            if (!isWhitespace(c)) {\n+                break;\n+            }\n+            parserState.pos += 1;\n+        }\n+    }\n+\n+    /**\n+     * Returns `true` if the current parser position is starting with \"::\".\n+     *\n+     * @param {ParserState} parserState\n+     * @return {boolean}\n+     */\n+    function isPathStart(parserState) {\n+        return parserState.userQuery.slice(parserState.pos, parserState.pos + 2) == '::';\n+    }\n+\n+    /**\n+     * Returns `true` if the current parser position is starting with \"->\".\n+     *\n+     * @param {ParserState} parserState\n+     * @return {boolean}\n+     */\n+    function isReturnArrow(parserState) {\n+        return parserState.userQuery.slice(parserState.pos, parserState.pos + 2) == '->';\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {Array<QueryElement>} elems    - This is where the new {QueryElement} will be added.\n+     * @param {string} name                  - Name of the query element.\n+     * @param {Array<QueryElement>} generics - List of generics of this query element.\n+     */\n+    function createQueryElement(query, parserState, elems, name, generics) {\n+        removeEmptyStringsFromArray(generics);\n+        if (name === '*' || (name.length === 0 && generics.length === 0)) {\n+            return;\n+        }\n+        if (query.literalSearch && parserState.totalElems > 0) {\n+            throw new Error(\"You cannot have more than one element if you use quotes\");\n+        }\n+        var pathSegments = name.split(\"::\");\n+        removeEmptyStringsFromArray(pathSegments);\n+        // In case we only have something like `<p>`, there is no name but it remains valid.\n+        if (pathSegments.length === 0) {\n+            pathSegments = [\"\"];\n+        }\n+        elems.push({\n+            name: name,\n+            fullPath: pathSegments,\n+            pathWithoutLast: pathSegments.slice(0, pathSegments.length - 1),\n+            pathLast: pathSegments[pathSegments.length - 1],\n+            generics: generics,\n+        });\n+        parserState.totalElems += 1;\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {Array<QueryElement>} elems - This is where the new {QueryElement} will be added.\n+     * @param {boolean} isInGenerics\n+     */\n+    function getNextElem(query, parserState, elems, isInGenerics) {\n+        var generics = [];\n+\n+        var start = parserState.pos;\n+        var end = start;\n+        // We handle the strings on their own mostly to make code easier to follow.\n+        if (parserState.userQuery[parserState.pos] === \"\\\"\") {\n+            start += 1;\n+            getStringElem(query, parserState, isInGenerics);\n+            end = parserState.pos - 1;\n+            skipWhitespaces(parserState);\n+        } else {\n+            while (parserState.pos < parserState.length) {\n+                var c = parserState.userQuery[parserState.pos];\n+                if (isStopCharacter(c) || isSpecialStartCharacter(c)) {\n+                    break;\n+                }\n+                // If we allow paths (\"str::string\" for example).\n+                else if (c === \":\") {\n+                    if (!isPathStart(parserState)) {\n+                        break;\n+                    }\n+                    // Skip current \":\".\n+                    parserState.pos += 1;\n+                }\n+                parserState.pos += 1;\n+                end = parserState.pos;\n+                skipWhitespaces(parserState);\n+            }\n+        }\n+        if (parserState.pos < parserState.length &&\n+            parserState.userQuery[parserState.pos] === \"<\")\n+        {\n+            parserState.pos += 1;\n+            getItemsBefore(query, parserState, generics, \">\");\n+        }\n+        if (start >= end && generics.length === 0) {\n+            return;\n+        }\n+        createQueryElement(\n+            query,\n+            parserState,\n+            elems,\n+            parserState.userQuery.slice(start, end),\n+            generics);\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     * @param {Array<QueryElement>} elems - This is where the new {QueryElement} will be added.\n+     * @param {string} limit              - This function will stop when it'll encounter this\n+     *                                      character.\n+     */\n+    function getItemsBefore(query, parserState, elems, limit) {\n+        while (parserState.pos < parserState.length) {\n+            var c = parserState.userQuery[parserState.pos];\n+            if (c === limit) {\n+                break;\n+            } else if (c === '(' || c === \":\") {\n+                // Something weird is going on in here. Ignoring it!\n+                parserState.pos += 1;\n+                continue;\n+            }\n+            var posBefore = parserState.pos;\n+            getNextElem(query, parserState, elems, limit === \">\");\n+            if (posBefore === parserState.pos) {\n+                parserState.pos += 1;\n+            }\n+        }\n+        // We skip the \"limit\".\n+        parserState.pos += 1;\n+    }\n+\n+    /**\n+     * @param {ParsedQuery} query\n+     * @param {ParserState} parserState\n+     */\n+    function parseInput(query, parserState) {\n+        var c, before;\n+\n+        while (parserState.pos < parserState.length) {\n+            c = parserState.userQuery[parserState.pos];\n+            if (isStopCharacter(c)) {\n+                if (c === \",\" || c === \" \") {\n+                    parserState.pos += 1;\n+                    continue;\n+                } else if (c === \"-\" && isReturnArrow(parserState)) {\n+                    break;\n+                }\n+            } else if (c == \"(\") {\n+                break;\n+            } else if (c === \":\" &&\n+                parserState.typeFilter === null &&\n+                !isPathStart(parserState) &&\n+                query.elems.length === 1)\n+            {\n+                if (query.literalSearch) {\n+                    throw new Error(\"You cannot use quotes on type filter\");\n+                }\n+                // The type filter doesn't count as an element since it's a modifier.\n+                parserState.typeFilter = query.elems.pop().name;\n+                parserState.pos += 1;\n+                parserState.totalElems = 0;\n+                query.literalSearch = false;\n+                continue;\n+            }\n+            before = query.elems.length;\n+            getNextElem(query, parserState, query.elems, false);\n+            if (query.elems.length === before) {\n+                // Nothing was added, let's check it's not because of a solo \":\"!\n+                if (parserState.pos >= parserState.length ||\n+                    parserState.userQuery[parserState.pos] !== \":\")\n+                {\n+                    break;\n+                }\n+                parserState.pos += 1;\n+            }\n+        }\n+        while (parserState.pos < parserState.length) {\n+            c = parserState.userQuery[parserState.pos];\n+            if (query.args.length === 0 && c === \"(\") {\n+                parserState.pos += 1;\n+                // Check for function/method arguments.\n+                getItemsBefore(query, parserState, query.args, \")\");\n+            } else if (isReturnArrow(parserState)) {\n+                parserState.pos += 2;\n+                // Get returned elements.\n+                getItemsBefore(query, parserState, query.returned, \"\");\n+                // Nothing can come afterward!\n+                break;\n+            } else {\n+                parserState.pos += 1;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Takes the user search input and returns an empty `ParsedQuery`.\n+     *\n+     * @param {string} userQuery\n+     * @return {ParsedQuery}\n+     */\n+    function newParsedQuery(userQuery) {\n+        return {\n+            original: userQuery,\n+            userQuery: userQuery.toLowerCase(),\n+            typeFilter: NO_TYPE_FILTER,\n+            elems: [],\n+            args: [],\n+            returned: [],\n+            // Total number of \"top\" elements (does not include generics).\n+            foundElems: 0,\n+            literalSearch: false,\n+            error: null,\n+        };\n+    }\n+\n     /**\n      * Build an URL with search parameters.\n      *\n@@ -158,7 +454,7 @@ window.initSearch = function(rawSearchIndex) {\n     }\n \n     /**\n-     * Executes the query and builds an index of results\n+     * Parses the query.\n      *\n      * The supported syntax by this parser is as follow:\n      *\n@@ -222,307 +518,72 @@ window.initSearch = function(rawSearchIndex) {\n      * @return {ParsedQuery}    - The parsed query\n      */\n     function parseQuery(userQuery) {\n-        function isWhitespace(c) {\n-            return \" \\t\\n\\r\".indexOf(c) !== -1;\n-        }\n-        function isSpecialStartCharacter(c) {\n-            return \"(<\\\"\".indexOf(c) !== -1;\n-        }\n-        function isStopCharacter(c) {\n-            return isWhitespace(c) || \"),>-=\".indexOf(c) !== -1;\n-        }\n-        function getStringElem(query, isInGenerics) {\n-            if (isInGenerics) {\n-                throw new Error(\"`\\\"` cannot be used in generics\");\n-            } else if (query.literalSearch) {\n-                throw new Error(\"Cannot have more than one literal search element\");\n-            } else if (query.totalElems !== 0) {\n-                throw new Error(\"Cannot use literal search when there is more than one element\");\n-            }\n-            query.pos += 1;\n-            while (query.pos < query.length && query.userQuery[query.pos] !== \"\\\"\") {\n-                if (query.userQuery[query.pos] === \"\\\\\") {\n-                    // We ignore the next coming character.\n-                    query.pos += 1;\n-                }\n-                query.pos += 1;\n-            }\n-            if (query.pos >= query.length) {\n-                throw new Error(\"Unclosed `\\\"`\");\n-            }\n-            // To skip the quote at the end.\n-            query.pos += 1;\n-            query.literalSearch = true;\n-        }\n-        function skipWhitespaces(query) {\n-            while (query.pos < query.length) {\n-                var c = query.userQuery[query.pos];\n-                if (!isWhitespace(c)) {\n-                    break;\n-                }\n-                query.pos += 1;\n-            }\n-        }\n-        function skipStopCharacters(query) {\n-            while (query.pos < query.length) {\n-                var c = query.userQuery[query.pos];\n-                if (!isStopCharacter(c)) {\n-                    break;\n-                }\n-                query.pos += 1;\n-            }\n-        }\n-        function isPathStart(query) {\n-            var pos = query.pos;\n-            return pos + 1 < query.length && query.userQuery[pos] === ':' &&\n-                query.userQuery[pos + 1] === ':';\n-        }\n-        function isReturnArrow(query) {\n-            var pos = query.pos;\n-            return pos + 1 < query.length && query.userQuery[pos] === '-' &&\n-                query.userQuery[pos + 1] === '>';\n-        }\n-        function removeEmptyStringsFromArray(x) {\n-            for (var i = 0, len = x.length; i < len; ++i) {\n-                if (x[i] === \"\") {\n-                    x.splice(i, 1);\n-                    i -= 1;\n-                }\n-            }\n-        }\n-        function createQueryElement(query, elems, name, generics) {\n-            removeEmptyStringsFromArray(generics);\n-            if (name === '*' || (name.length === 0 && generics.length === 0)) {\n-                return;\n-            }\n-            if (query.literalSearch && query.totalElems > 0) {\n-                throw new Error(\"You cannot have more than one element if you use quotes\");\n-            }\n-            var paths = name.split(\"::\");\n-            removeEmptyStringsFromArray(paths);\n-            // In case we only have something like `<p>`, there is no name but it remains valid.\n-            if (paths.length === 0) {\n-                paths = [\"\"];\n-            }\n-            elems.push({\n-                name: name,\n-                fullPath: paths,\n-                pathWithoutLast: paths.slice(0, paths.length - 1),\n-                pathLast: paths[paths.length - 1],\n-                generics: generics,\n-            });\n-            query.totalElems += 1;\n-        }\n-        function getNextElem(query, elems, isInGenerics) {\n-            var generics = [];\n-\n-            skipStopCharacters(query);\n-            var start = query.pos;\n-            var end = start;\n-            // We handle the strings on their own mostly to make code easier to follow.\n-            if (query.userQuery[query.pos] === \"\\\"\") {\n-                start += 1;\n-                getStringElem(query, isInGenerics);\n-                end = query.pos - 1;\n-                skipWhitespaces(query);\n-            } else {\n-                while (query.pos < query.length) {\n-                    var c = query.userQuery[query.pos];\n-                    if (isStopCharacter(c) || isSpecialStartCharacter(c)) {\n-                        break;\n-                    }\n-                    // If we allow paths (\"str::string\" for example).\n-                    else if (c === \":\") {\n-                        if (!isPathStart(query)) {\n-                            break;\n-                        }\n-                        // Skip current \":\".\n-                        query.pos += 1;\n-                    }\n-                    query.pos += 1;\n-                    end = query.pos;\n-                    skipWhitespaces(query);\n-                }\n-            }\n-            if (query.pos < query.length && query.userQuery[query.pos] === \"<\") {\n-                getItemsBefore(query, generics, \">\");\n-            }\n-            if (start >= end && generics.length === 0) {\n-                return;\n-            }\n-            createQueryElement(query, elems, query.userQuery.slice(start, end), generics);\n-        }\n-        function getItemsBefore(query, elems, limit) {\n-            while (query.pos < query.length) {\n-                var c = query.userQuery[query.pos];\n-                if (c === limit) {\n-                    break;\n-                } else if (isSpecialStartCharacter(c) || c === \":\") {\n-                    // Something weird is going on in here. Ignoring it!\n-                    query.pos += 1;\n-                }\n-                getNextElem(query, elems, limit === \">\");\n-            }\n-            // We skip the \"limit\".\n-            query.pos += 1;\n-        }\n-        function parseInput(query) {\n-            var c, before;\n-\n-            while (query.pos < query.length) {\n-                c = query.userQuery[query.pos];\n-                if (isStopCharacter(c)) {\n-                    if (c === \",\") {\n-                        query.pos += 1;\n-                        continue;\n-                    } else if (c === \"-\" && isReturnArrow(query)) {\n-                        break;\n-                    }\n-                } else if (c == \"(\") {\n-                    break;\n-                } else if (c === \":\" && query.typeFilter === null && !isPathStart(query) &&\n-                           query.elems.length === 1)\n-                {\n-                    if (query.literalSearch) {\n-                        throw new Error(\"You cannot use quotes on type filter\");\n-                    }\n-                    // The type filter doesn't count as an element since it's a modifier.\n-                    query.typeFilter = query.elems.pop().name;\n-                    query.pos += 1;\n-                    query.totalElems = 0;\n-                    query.literalSearch = false;\n-                    continue;\n-                }\n-                before = query.elems.length;\n-                getNextElem(query, query.elems, false);\n-                if (query.elems.length === before) {\n-                    // Nothing was added, let's check it's not because of a solo \":\"!\n-                    if (query.pos >= query.length || query.userQuery[query.pos] !== \":\") {\n-                        break;\n-                    }\n-                    query.pos += 1;\n-                }\n-            }\n-            while (query.pos < query.length) {\n-                c = query.userQuery[query.pos];\n-                if (query.args.length === 0 && c === \"(\") {\n-                    if (query.elemName === null && query.elems.length === 1) {\n-                        query.elemName = query.elems.pop();\n-                    }\n-                    // Check for function/method arguments.\n-                    getItemsBefore(query, query.args, \")\");\n-                } else if (isReturnArrow(query)) {\n-                    // Get returned elements.\n-                    getItemsBefore(query, query.returned, \"\");\n-                    // Nothing can come afterward!\n-                    break;\n-                } else {\n-                    query.pos += 1;\n-                }\n-            }\n-        }\n-        function itemTypeFromName(typename) {\n-            for (var i = 0, len = itemTypes.length; i < len; ++i) {\n-                if (itemTypes[i] === typename) {\n-                    return i;\n-                }\n-            }\n-            return NO_TYPE_FILTER;\n-        }\n-\n         userQuery = userQuery.trim();\n-        var query = {\n-            original: userQuery,\n-            userQuery: userQuery.toLowerCase(),\n+        var parserState = {\n             length: userQuery.length,\n             pos: 0,\n-            typeFilter: null,\n-            elems: [],\n-            elemName: null,\n-            args: [],\n-            returned: [],\n             // Total number of elements (includes generics).\n             totalElems: 0,\n-            // Total number of \"top\" elements (does not include generics).\n-            foundElems: 0,\n-            // This field is used to check if it's needed to re-run a search or not.\n-            id: \"\",\n-            // This field is used in `sortResults`.\n-            nameSplit: null,\n-            literalSearch: false,\n-            error: null,\n+            typeFilter: null,\n+            userQuery: userQuery.toLowerCase(),\n         };\n-        query.id = userQuery;\n+        var query = newParsedQuery(userQuery);\n+\n         try {\n-            parseInput(query);\n+            parseInput(query, parserState);\n         } catch (err) {\n+            query = newParsedQuery(userQuery);\n             query.error = err.message;\n-            query.elems = [];\n-            query.returned = [];\n-            query.args = [];\n             return query;\n         }\n-        query.foundElems = query.elems.length + query.args.length + query.returned.length;\n+\n         if (!query.literalSearch) {\n             // If there is more than one element in the query, we switch to literalSearch in any\n             // case.\n-            query.literalSearch = query.totalElems > 1;\n-        }\n-        if (query.elemName !== null) {\n-            query.foundElems += 1;\n+            query.literalSearch = parserState.totalElems > 1;\n         }\n-        if (query.foundElems === 0 && userQuery.length !== 0) {\n+        query.foundElems = query.elems.length + query.args.length + query.returned.length;\n+        if (query.foundElems === 0 && parserState.length !== 0) {\n             // In this case, we'll simply keep whatever was entered by the user...\n-            createQueryElement(query, query.elems, userQuery, []);\n+            createQueryElement(query, parserState, query.elems, userQuery, []);\n             query.foundElems += 1;\n         }\n-        if (query.typeFilter !== null) {\n-            query.typeFilter = query.typeFilter.replace(/^const$/, \"constant\");\n-            query.typeFilter = itemTypeFromName(query.typeFilter);\n-        } else {\n-            query.typeFilter = NO_TYPE_FILTER;\n-        }\n-        // In case we only have one argument, we move it back to `elems` to keep things simple.\n-        if (query.foundElems === 1 && query.elemName !== null) {\n-            query.elems.push(query.elemName);\n-            query.elemName = null;\n-        }\n-        if (query.elemName !== null || query.elems.length === 1) {\n-            userQuery = query.elemName || query.elems[0];\n-            query.nameSplit = typeof userQuery.path === \"undefined\" ? null : userQuery.path;\n+        if (parserState.typeFilter !== null) {\n+            var typeFilter = parserState.typeFilter.replace(/^const$/, \"constant\");\n+            query.typeFilter = itemTypeFromName(typeFilter);\n         }\n         return query;\n     }\n \n     /**\n      * Creates the query results.\n      *\n-     * @param {Array<Object>} results_in_args\n-     * @param {Array<Object>} results_returned\n-     * @param {Array<Object>} results_in_args\n-     * @param {ParsedQuery} queryInfo\n-     * @return {Object}                        - A search index of results\n+     * @param {Array<Result>} results_in_args\n+     * @param {Array<Result>} results_returned\n+     * @param {Array<Result>} results_in_args\n+     * @param {ParsedQuery} parsedQuery\n+     * @return {ResultsTable}\n      */\n-    function createQueryResults(results_in_args, results_returned, results_others, queryInfo) {\n+    function createQueryResults(results_in_args, results_returned, results_others, parsedQuery) {\n         return {\n             \"in_args\": results_in_args,\n             \"returned\": results_returned,\n             \"others\": results_others,\n-            \"query\": queryInfo,\n+            \"query\": parsedQuery,\n         };\n     }\n \n     /**\n-     * Executes the query and builds an index of results\n+     * Executes the parsed query and builds a {ResultsTable}.\n      *\n-     * @param  {ParsedQuery} query   - The user query\n-     * @param  {Object} searchWords  - The list of search words to query against\n-     * @param  {Object} filterCrates - Crate to search in if defined\n-     * @return {Object}              - A search index of results\n+     * @param  {ParsedQuery} parsedQuery - The parsed user query\n+     * @param  {Object} searchWords      - The list of search words to query against\n+     * @param  {Object} [filterCrates]   - Crate to search in if defined\n+     * @return {ResultsTable}\n      */\n-    function execQuery(queryInfo, searchWords, filterCrates) {\n-        if (queryInfo.error !== null) {\n-            createQueryResults([], [], [], queryInfo);\n+    function execQuery(parsedQuery, searchWords, filterCrates) {\n+        if (parsedQuery.error !== null) {\n+            createQueryResults([], [], [], parsedQuery);\n         }\n         var results_others = {}, results_in_args = {}, results_returned = {};\n \n@@ -558,8 +619,12 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function sortResults(results, isType) {\n-            var nameSplit = queryInfo.nameSplit;\n-            var query = queryInfo.userQuery;\n+            var nameSplit = null;\n+            if (parsedQuery.elems.length === 1) {\n+                var hasPath = typeof parsedQuery.elems[0].path === \"undefined\";\n+                nameSplit = hasPath ? null : parsedQuery.elems[0].path;\n+            }\n+            var query = parsedQuery.userQuery;\n             var ar = [];\n             for (var entry in results) {\n                 if (hasOwnPropertyRustdoc(results, entry)) {\n@@ -661,35 +726,35 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         /**\n-         * This function checks if the object (`obj`) generics match the given type (`val`)\n-         * generics. If there are no generics on `obj`, `defaultLev` is returned.\n+         * This function checks if the object (`row`) generics match the given type (`elem`)\n+         * generics. If there are no generics on `row`, `defaultLev` is returned.\n          *\n-         * @param {Row} obj            - The object to check.\n-         * @param {QueryElement} val   - The element from the parsed query.\n+         * @param {Row} row            - The object to check.\n+         * @param {QueryElement} elem  - The element from the parsed query.\n          * @param {integer} defaultLev - This is the value to return in case there are no generics.\n          *\n          * @return {integer}           - Returns the best match (if any) or `MAX_LEV_DISTANCE + 1`.\n          */\n-        function checkGenerics(obj, val, defaultLev) {\n-            if (obj.length <= GENERICS_DATA || obj[GENERICS_DATA].length === 0) {\n-                return val.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n+        function checkGenerics(row, elem, defaultLev) {\n+            if (row.length <= GENERICS_DATA || row[GENERICS_DATA].length === 0) {\n+                return elem.generics.length === 0 ? defaultLev : MAX_LEV_DISTANCE + 1;\n             }\n             // The names match, but we need to be sure that all generics kinda\n             // match as well.\n             var elem_name;\n-            if (val.generics.length > 0 && obj[GENERICS_DATA].length >= val.generics.length) {\n+            if (elem.generics.length > 0 && row[GENERICS_DATA].length >= elem.generics.length) {\n                 var elems = {};\n-                for (var x = 0, length = obj[GENERICS_DATA].length; x < length; ++x) {\n-                    elem_name = obj[GENERICS_DATA][x][NAME];\n+                for (var x = 0, length = row[GENERICS_DATA].length; x < length; ++x) {\n+                    elem_name = row[GENERICS_DATA][x][NAME];\n                     if (!elems[elem_name]) {\n                         elems[elem_name] = 0;\n                     }\n                     elems[elem_name] += 1;\n                 }\n                 // We need to find the type that matches the most to remove it in order\n                 // to move forward.\n-                for (x = 0, length = val.generics.length; x < length; ++x) {\n-                    var generic = val.generics[x];\n+                for (x = 0, length = elem.generics.length; x < length; ++x) {\n+                    var generic = elem.generics[x];\n                     var match = null;\n                     if (elems[generic.name]) {\n                         match = generic.name;\n@@ -718,71 +783,71 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         /**\n-          * This function checks if the object (`obj`) matches the given type (`val`) and its\n+          * This function checks if the object (`row`) matches the given type (`elem`) and its\n           * generics (if any).\n           *\n-          * @param {Row} obj\n-          * @param {QueryElement} val    - The element from the parsed query.\n+          * @param {Row} row\n+          * @param {QueryElement} elem    - The element from the parsed query.\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match.\n           */\n-        function checkIfInGenerics(obj, val) {\n+        function checkIfInGenerics(row, elem) {\n             var lev = MAX_LEV_DISTANCE + 1;\n-            for (var x = 0, length = obj[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n+            for (var x = 0, length = row[GENERICS_DATA].length; x < length && lev !== 0; ++x) {\n                 lev = Math.min(\n-                    checkType(obj[GENERICS_DATA][x], val, true),\n+                    checkType(row[GENERICS_DATA][x], elem, true),\n                     lev\n                 );\n             }\n             return lev;\n         }\n \n         /**\n-          * This function checks if the object (`obj`) matches the given type (`val`) and its\n+          * This function checks if the object (`row`) matches the given type (`elem`) and its\n           * generics (if any).\n           *\n-          * @param {Row} obj\n-          * @param {QueryElement} val      - The element from the parsed query.\n+          * @param {Row} row\n+          * @param {QueryElement} elem      - The element from the parsed query.\n           * @param {boolean} literalSearch\n           *\n           * @return {integer} - Returns a Levenshtein distance to the best match. If there is\n           *                     no match, returns `MAX_LEV_DISTANCE + 1`.\n           */\n-        function checkType(obj, val, literalSearch) {\n-            if (val.name.length === 0 || obj[NAME].length === 0) {\n+        function checkType(row, elem, literalSearch) {\n+            if (elem.name.length === 0 || row[NAME].length === 0) {\n                 // This is a pure \"generic\" search, no need to run other checks.\n-                if (obj.length > GENERICS_DATA) {\n-                    return checkIfInGenerics(obj, val);\n+                if (row.length > GENERICS_DATA) {\n+                    return checkIfInGenerics(row, elem);\n                 }\n                 return MAX_LEV_DISTANCE + 1;\n             }\n \n-            var lev = levenshtein(obj[NAME], val.name);\n+            var lev = levenshtein(row[NAME], elem.name);\n             if (literalSearch) {\n                 if (lev !== 0) {\n                     // The name didn't match, let's try to check if the generics do.\n-                    if (val.generics.length === 0) {\n-                        var checkGeneric = (obj.length > GENERICS_DATA &&\n-                            obj[GENERICS_DATA].length > 0);\n-                        if (checkGeneric && obj[GENERICS_DATA].findIndex(function(elem) {\n-                            return elem[NAME] === val.name;\n+                    if (elem.generics.length === 0) {\n+                        var checkGeneric = (row.length > GENERICS_DATA &&\n+                            row[GENERICS_DATA].length > 0);\n+                        if (checkGeneric && row[GENERICS_DATA].findIndex(function(tmp_elem) {\n+                            return tmp_elem[NAME] === elem.name;\n                         }) !== -1) {\n                             return 0;\n                         }\n                     }\n                     return MAX_LEV_DISTANCE + 1;\n-                } else if (val.generics.length > 0) {\n-                    return checkGenerics(obj, val, MAX_LEV_DISTANCE + 1);\n+                } else if (elem.generics.length > 0) {\n+                    return checkGenerics(row, elem, MAX_LEV_DISTANCE + 1);\n                 }\n                 return 0;\n-            } else if (obj.length > GENERICS_DATA) {\n-                if (val.generics.length === 0) {\n+            } else if (row.length > GENERICS_DATA) {\n+                if (elem.generics.length === 0) {\n                     if (lev === 0) {\n                         return 0;\n                     }\n                     // The name didn't match so we now check if the type we're looking for is inside\n                     // the generics!\n-                    lev = checkIfInGenerics(obj, val);\n+                    lev = checkIfInGenerics(row, elem);\n                     // Now whatever happens, the returned distance is \"less good\" so we should mark\n                     // it as such, and so we add 0.5 to the distance to make it \"less good\".\n                     return lev + 0.5;\n@@ -791,18 +856,18 @@ window.initSearch = function(rawSearchIndex) {\n                     //\n                     // Maybe it's present in a sub generic? For example \"f<A<B<C>>>()\", if we're\n                     // looking for \"B<C>\", we'll need to go down.\n-                    return checkIfInGenerics(obj, val);\n+                    return checkIfInGenerics(row, elem);\n                 } else {\n                     // At this point, the name kinda match and we have generics to check, so\n                     // let's go!\n-                    var tmp_lev = checkGenerics(obj, val, lev);\n+                    var tmp_lev = checkGenerics(row, elem, lev);\n                     if (tmp_lev > MAX_LEV_DISTANCE) {\n                         return MAX_LEV_DISTANCE + 1;\n                     }\n                     // We compute the median value of both checks and return it.\n                     return (tmp_lev + lev) / 2;\n                 }\n-            } else if (val.generics.length > 0) {\n+            } else if (elem.generics.length > 0) {\n                 // In this case, we were expecting generics but there isn't so we simply reject this\n                 // one.\n                 return MAX_LEV_DISTANCE + 1;\n@@ -813,64 +878,62 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         /**\n-         * This function checks if the object (`obj`) has an argument with the given type (`val`).\n+         * This function checks if the object (`row`) has an argument with the given type (`elem`).\n          *\n-         * @param {Row} obj\n-         * @param {QueryElement} val    - The element from the parsed query.\n+         * @param {Row} row\n+         * @param {QueryElement} elem    - The element from the parsed query.\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n-        function findArg(obj, val, typeFilter) {\n+        function findArg(row, elem, typeFilter) {\n             var lev = MAX_LEV_DISTANCE + 1;\n-            var tmp;\n \n-            if (obj && obj.type && obj.type[INPUTS_DATA] && obj.type[INPUTS_DATA].length > 0) {\n-                var length = obj.type[INPUTS_DATA].length;\n+            if (row && row.type && row.type[INPUTS_DATA] && row.type[INPUTS_DATA].length > 0) {\n+                var length = row.type[INPUTS_DATA].length;\n                 for (var i = 0; i < length; i++) {\n-                    tmp = obj.type[INPUTS_DATA][i];\n+                    var tmp = row.type[INPUTS_DATA][i];\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, val, queryInfo.literalSearch));\n+                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return queryInfo.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n         /**\n-         * @param {Row} obj\n-         * @param {QueryElement} val   - The element from the parsed query.\n+         * @param {Row} row\n+         * @param {QueryElement} elem   - The element from the parsed query.\n          * @param {integer} typeFilter\n          *\n          * @return {integer} - Returns a Levenshtein distance to the best match. If there is no\n          *                      match, returns `MAX_LEV_DISTANCE + 1`.\n          */\n-        function checkReturned(obj, val, typeFilter) {\n+        function checkReturned(row, elem, typeFilter) {\n             var lev = MAX_LEV_DISTANCE + 1;\n-            var tmp;\n \n-            if (obj && obj.type && obj.type.length > OUTPUT_DATA) {\n-                var ret = obj.type[OUTPUT_DATA];\n+            if (row && row.type && row.type.length > OUTPUT_DATA) {\n+                var ret = row.type[OUTPUT_DATA];\n                 if (typeof ret[0] === \"string\") {\n                     ret = [ret];\n                 }\n                 for (var x = 0, len = ret.length; x < len; ++x) {\n-                    tmp = ret[x];\n+                    var tmp = ret[x];\n                     if (!typePassesFilter(typeFilter, tmp[1])) {\n                         continue;\n                     }\n-                    lev = Math.min(lev, checkType(tmp, val, queryInfo.literalSearch));\n+                    lev = Math.min(lev, checkType(tmp, elem, parsedQuery.literalSearch));\n                     if (lev === 0) {\n                         return 0;\n                     }\n                 }\n             }\n-            return queryInfo.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n+            return parsedQuery.literalSearch ? MAX_LEV_DISTANCE + 1 : lev;\n         }\n \n         function checkPath(contains, lastElem, ty) {\n@@ -945,23 +1008,24 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         function handleAliases(ret, query, filterCrates) {\n+            var lowerQuery = query.toLowerCase();\n             // We separate aliases and crate aliases because we want to have current crate\n             // aliases to be before the others in the displayed results.\n             var aliases = [];\n             var crateAliases = [];\n             if (filterCrates !== null) {\n-                if (ALIASES[filterCrates] && ALIASES[filterCrates][query]) {\n-                    var query_aliases = ALIASES[filterCrates][query];\n+                if (ALIASES[filterCrates] && ALIASES[filterCrates][lowerQuery]) {\n+                    var query_aliases = ALIASES[filterCrates][lowerQuery];\n                     var len = query_aliases.length;\n                     for (var i = 0; i < len; ++i) {\n                         aliases.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n                     }\n                 }\n             } else {\n                 Object.keys(ALIASES).forEach(function(crate) {\n-                    if (ALIASES[crate][query]) {\n+                    if (ALIASES[crate][lowerQuery]) {\n                         var pushTo = crate === window.currentCrate ? crateAliases : aliases;\n-                        var query_aliases = ALIASES[crate][query];\n+                        var query_aliases = ALIASES[crate][lowerQuery];\n                         var len = query_aliases.length;\n                         for (var i = 0; i < len; ++i) {\n                             pushTo.push(createAliasFromItem(searchIndex[query_aliases[i]]));\n@@ -998,37 +1062,37 @@ window.initSearch = function(rawSearchIndex) {\n         }\n \n         /**\n-         * This function adds the given result into the provided `res` map if it matches the\n+         * This function adds the given result into the provided `results` map if it matches the\n          * following condition:\n          *\n-         * * If it is a \"literal search\" (`queryInfo.literalSearch`), then `lev` must be 0.\n+         * * If it is a \"literal search\" (`parsedQuery.literalSearch`), then `lev` must be 0.\n          * * If it is not a \"literal search\", `lev` must be <= `MAX_LEV_DISTANCE`.\n          *\n-         * The `res` map contains information which will be used to sort the search results:\n+         * The `results` map contains information which will be used to sort the search results:\n          *\n-         * * `fullId` is a `string`` used as the key of the object we use for the `res` map.\n+         * * `fullId` is a `string`` used as the key of the object we use for the `results` map.\n          * * `id` is the index in both `searchWords` and `searchIndex` arrays for this element.\n          * * `index` is an `integer`` used to sort by the position of the word in the item's name.\n          * * `lev` is the main metric used to sort the search results.\n          *\n-         * @param {Object} res\n+         * @param {Object} results\n          * @param {string} fullId\n          * @param {integer} id\n          * @param {integer} index\n          * @param {integer} lev\n          */\n-        function addIntoResults(res, fullId, id, index, lev) {\n-            if (lev === 0 || (!queryInfo.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n-                if (res[fullId] !== undefined) {\n-                    var result = res[fullId];\n+        function addIntoResults(results, fullId, id, index, lev) {\n+            if (lev === 0 || (!parsedQuery.literalSearch && lev <= MAX_LEV_DISTANCE)) {\n+                if (results[fullId] !== undefined) {\n+                    var result = results[fullId];\n                     if (result.dontValidate || result.lev <= lev) {\n                         return;\n                     }\n                 }\n-                res[fullId] = {\n+                results[fullId] = {\n                     id: id,\n                     index: index,\n-                    dontValidate: queryInfo.literalSearch,\n+                    dontValidate: parsedQuery.literalSearch,\n                     lev: lev,\n                 };\n             }\n@@ -1037,29 +1101,29 @@ window.initSearch = function(rawSearchIndex) {\n         /**\n          * This function is called in case the query is only one element (with or without generics).\n          *\n-         * @param {Row} ty\n+         * @param {Row} row\n          * @param {integer} pos           - Position in the `searchIndex`.\n          * @param {QueryElement} elem     - The element from the parsed query.\n          */\n-        function handleSingleArg(ty, pos, elem) {\n-            if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n+        function handleSingleArg(row, pos, elem) {\n+            if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n             var lev, lev_add = 0, index = -1;\n-            var fullId = ty.id;\n+            var fullId = row.id;\n \n-            var in_args = findArg(ty, elem, queryInfo.typeFilter);\n-            var returned = checkReturned(ty, elem, queryInfo.typeFilter);\n+            var in_args = findArg(row, elem, parsedQuery.typeFilter);\n+            var returned = checkReturned(row, elem, parsedQuery.typeFilter);\n \n             addIntoResults(results_in_args, fullId, pos, index, in_args);\n             addIntoResults(results_returned, fullId, pos, index, returned);\n \n-            if (!typePassesFilter(queryInfo.typeFilter, ty.ty)) {\n+            if (!typePassesFilter(parsedQuery.typeFilter, row.ty)) {\n                 return;\n             }\n             var searchWord = searchWords[pos];\n \n-            if (queryInfo.literalSearch) {\n+            if (parsedQuery.literalSearch) {\n                 if (searchWord === elem.name) {\n                     addIntoResults(results_others, fullId, pos, -1, 0);\n                 }\n@@ -1068,33 +1132,33 @@ window.initSearch = function(rawSearchIndex) {\n \n             // No need to check anything else if it's a \"pure\" generics search.\n             if (elem.name.length === 0) {\n-                if (ty.type !== null) {\n-                    lev = checkGenerics(ty.type, elem, MAX_LEV_DISTANCE + 1);\n+                if (row.type !== null) {\n+                    lev = checkGenerics(row.type, elem, MAX_LEV_DISTANCE + 1);\n                     addIntoResults(results_others, fullId, pos, index, lev);\n                 }\n                 return;\n             }\n \n             if (elem.fullPath.length > 1) {\n-                lev = checkPath(elem.pathWithoutLast, elem.pathLast, ty);\n-                if (lev > MAX_LEV_DISTANCE || (queryInfo.literalSearch && lev !== 0)) {\n+                lev = checkPath(elem.pathWithoutLast, elem.pathLast, row);\n+                if (lev > MAX_LEV_DISTANCE || (parsedQuery.literalSearch && lev !== 0)) {\n                     return;\n                 } else if (lev > 0) {\n                     lev_add = lev / 10;\n                 }\n             }\n \n             if (searchWord.indexOf(elem.pathLast) > -1 ||\n-                ty.normalizedName.indexOf(elem.pathLast) > -1)\n+                row.normalizedName.indexOf(elem.pathLast) > -1)\n             {\n                 // filter type: ... queries\n                 if (!results_others[fullId] !== undefined) {\n-                    index = ty.normalizedName.indexOf(elem.pathLast);\n+                    index = row.normalizedName.indexOf(elem.pathLast);\n                 }\n             }\n             lev = levenshtein(searchWord, elem.pathLast);\n             lev += lev_add;\n-            if (lev > 0 && elem.pathLast.length > 3 && searchWord.indexOf(elem.pathLast) > -1)\n+            if (lev > 0 && elem.pathLast.length > 2 && searchWord.indexOf(elem.pathLast) > -1)\n             {\n                 if (elem.pathLast.length < 6) {\n                     lev = 1;\n@@ -1116,27 +1180,25 @@ window.initSearch = function(rawSearchIndex) {\n         /**\n          * This function is called in case the query has more than one element.\n          *\n-         * @param {Object} ty\n-         * @param {integer} pos     - Position in the `searchIndex`.\n-         * @param {Object} elem     - The element from the parsed query.\n+         * @param {Row} row\n+         * @param {integer} pos      - Position in the `searchIndex`.\n+         * @param {Object} results\n          */\n-        function handleArgs(ty, pos, results) {\n-            if (!ty || (filterCrates !== null && ty.crate !== filterCrates)) {\n+        function handleArgs(row, pos, results) {\n+            if (!row || (filterCrates !== null && row.crate !== filterCrates)) {\n                 return;\n             }\n \n             var totalLev = 0;\n             var nbLev = 0;\n             var lev;\n-            var i, len;\n-            var el;\n \n             // If the result is too \"bad\", we return false and it ends this search.\n-            function checkArgs(args, callback) {\n-                for (i = 0, len = args.length; i < len; ++i) {\n-                    el = args[i];\n+            function checkArgs(elems, callback) {\n+                for (var i = 0, len = elems.length; i < len; ++i) {\n+                    var elem = elems[i];\n                     // There is more than one parameter to the query so all checks should be \"exact\"\n-                    lev = callback(ty, el, NO_TYPE_FILTER);\n+                    lev = callback(row, elem, NO_TYPE_FILTER);\n                     if (lev <= 1) {\n                         nbLev += 1;\n                         totalLev += lev;\n@@ -1146,57 +1208,57 @@ window.initSearch = function(rawSearchIndex) {\n                 }\n                 return true;\n             }\n-            if (!checkArgs(queryInfo.elems, findArg)) {\n+            if (!checkArgs(parsedQuery.elems, findArg)) {\n                 return;\n             }\n-            if (!checkArgs(queryInfo.args, findArg)) {\n+            if (!checkArgs(parsedQuery.args, findArg)) {\n                 return;\n             }\n-            if (!checkArgs(queryInfo.returned, checkReturned)) {\n+            if (!checkArgs(parsedQuery.returned, checkReturned)) {\n                 return;\n             }\n \n             if (nbLev === 0) {\n                 return;\n             }\n             lev = Math.round(totalLev / nbLev);\n-            addIntoResults(results, ty.id, pos, 0, lev);\n+            addIntoResults(results, row.id, pos, 0, lev);\n         }\n \n         function innerRunQuery() {\n-            var elem, i, nSearchWords, in_args, in_returned, ty;\n+            var elem, i, nSearchWords, in_args, in_returned, row;\n \n-            if (queryInfo.foundElems === 1) {\n-                if (queryInfo.elems.length === 1) {\n-                    elem = queryInfo.elems[0];\n+            if (parsedQuery.foundElems === 1) {\n+                if (parsedQuery.elems.length === 1) {\n+                    elem = parsedQuery.elems[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n                         // It means we want to check for this element everywhere (in names, args and\n                         // returned).\n                         handleSingleArg(searchIndex[i], i, elem);\n                     }\n-                } else if (queryInfo.args.length === 1) {\n+                } else if (parsedQuery.args.length === 1) {\n                     // We received one argument to check, so looking into args.\n-                    elem = queryInfo.args[0];\n+                    elem = parsedQuery.args[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                        ty = searchIndex[i];\n-                        in_args = findArg(ty, elem, queryInfo.typeFilter);\n-                        addIntoResults(results_in_args, ty.id, i, -1, in_args);\n+                        row = searchIndex[i];\n+                        in_args = findArg(row, elem, parsedQuery.typeFilter);\n+                        addIntoResults(results_in_args, row.id, i, -1, in_args);\n                     }\n-                } else if (queryInfo.returned.length === 1) {\n+                } else if (parsedQuery.returned.length === 1) {\n                     // We received one returned argument to check, so looking into returned values.\n-                    elem = queryInfo.returned[0];\n+                    elem = parsedQuery.returned[0];\n                     for (i = 0, nSearchWords = searchWords.length; i < nSearchWords; ++i) {\n-                        ty = searchIndex[i];\n-                        in_returned = checkReturned(ty, elem, queryInfo.typeFilter);\n-                        addIntoResults(results_returned, ty.id, i, -1, in_returned);\n+                        row = searchIndex[i];\n+                        in_returned = checkReturned(row, elem, parsedQuery.typeFilter);\n+                        addIntoResults(results_returned, row.id, i, -1, in_returned);\n                     }\n                 }\n-            } else if (queryInfo.foundElems > 0) {\n+            } else if (parsedQuery.foundElems > 0) {\n                 var container = results_others;\n                 // In the special case where only a \"returned\" information is available, we want to\n                 // put the information into the \"results_returned\" dict.\n-                if (queryInfo.returned.length !== 0 && queryInfo.elemName === null &&\n-                        queryInfo.args.length === 0 && queryInfo.elems.length === 0)\n+                if (parsedQuery.returned.length !== 0 && parsedQuery.args.length === 0 &&\n+                    parsedQuery.elems.length === 0)\n                 {\n                     container = results_returned;\n                 }\n@@ -1211,8 +1273,8 @@ window.initSearch = function(rawSearchIndex) {\n             sortResults(results_in_args, true),\n             sortResults(results_returned, true),\n             sortResults(results_others, false),\n-            queryInfo);\n-        handleAliases(ret, queryInfo.original.replace(/\"/g, \"\").toLowerCase(), filterCrates);\n+            parsedQuery);\n+        handleAliases(ret, parsedQuery.original.replace(/\"/g, \"\"), filterCrates);\n         return ret;\n     }\n \n@@ -1434,6 +1496,11 @@ window.initSearch = function(rawSearchIndex) {\n         return \"<button>\" + text + \" <div class=\\\"count\\\">(\" + nbElems + \")</div></button>\";\n     }\n \n+    /**\n+     * @param {ResultsTable} results\n+     * @param {boolean} go_to_first\n+     * @param {string} filterCrates\n+     */\n     function showResults(results, go_to_first, filterCrates) {\n         var search = searchState.outputElement();\n         if (go_to_first || (results.others.length === 1\n@@ -1455,7 +1522,7 @@ window.initSearch = function(rawSearchIndex) {\n             results.query = parseQuery(searchState.input.value);\n         }\n \n-        currentResults = results.query.id;\n+        currentResults = results.query.userQuery;\n \n         var ret_others = addTab(results.others, results.query, true);\n         var ret_in_args = addTab(results.in_args, results.query, false);\n@@ -1535,7 +1602,7 @@ window.initSearch = function(rawSearchIndex) {\n             e.preventDefault();\n         }\n \n-        if (!forced && query.id === currentResults) {\n+        if (!forced && query.userQuery === currentResults) {\n             if (query.userQuery.length > 0) {\n                 putBackSearch();\n             }"}, {"sha": "901634fe0e635a381124505e25d849499b70b398", "filename": "src/test/rustdoc-gui/search-result-color.goml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-gui%2Fsearch-result-color.goml?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -1,5 +1,5 @@\n // The goal of this test is to ensure the color of the text is the one expected.\n-goto: file://|DOC_PATH|/test_docs/index.html?search=cook\n+goto: file://|DOC_PATH|/test_docs/index.html?search=coo\n \n // This is needed so that the text color is computed.\n show-text: true"}, {"sha": "887ac38f4175deb5e5be1d3283bcda78ad9abef2", "filename": "src/test/rustdoc-js-std/parser-errors.js", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-errors.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,66 +3,51 @@ const QUERY = ['<\"P\">', '\"P\" \"P\"', 'P \"P\"', '\"p\" p', '\"const\": p'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 0,\n-        id: \"<\\\"P\\\">\",\n-        nameSplit: null,\n         original: \"<\\\"P\\\">\",\n         returned: [],\n-        typeFilter: null,\n+        typeFilter: -1,\n         userQuery: \"<\\\"p\\\">\",\n         error: \"`\\\"` cannot be used in generics\",\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 0,\n-        id: \"\\\"P\\\" \\\"P\\\"\",\n-        nameSplit: null,\n         original: \"\\\"P\\\" \\\"P\\\"\",\n         returned: [],\n-        typeFilter: null,\n+        typeFilter: -1,\n         userQuery: \"\\\"p\\\" \\\"p\\\"\",\n         error: \"Cannot have more than one literal search element\",\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 0,\n-        id: \"P \\\"P\\\"\",\n-        nameSplit: null,\n         original: \"P \\\"P\\\"\",\n         returned: [],\n-        typeFilter: null,\n+        typeFilter: -1,\n         userQuery: \"p \\\"p\\\"\",\n         error: \"Cannot use literal search when there is more than one element\",\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 0,\n-        id: \"\\\"p\\\" p\",\n-        nameSplit: null,\n         original: \"\\\"p\\\" p\",\n         returned: [],\n-        typeFilter: null,\n+        typeFilter: -1,\n         userQuery: \"\\\"p\\\" p\",\n         error: \"You cannot have more than one element if you use quotes\",\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 0,\n-        id: \"\\\"const\\\": p\",\n-        nameSplit: null,\n         original: \"\\\"const\\\": p\",\n         returned: [],\n-        typeFilter: null,\n+        typeFilter: -1,\n         userQuery: \"\\\"const\\\": p\",\n         error: \"You cannot use quotes on type filter\",\n     },"}, {"sha": "49fa66b5bb3ca2f03076f533f60ca4a725e2dcf5", "filename": "src/test/rustdoc-js-std/parser-filter.js", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-filter.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,7 +3,6 @@ const QUERY = ['fn:foo', 'enum : foo', 'macro<f>:foo'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"foo\",\n             fullPath: [\"foo\"],\n@@ -12,8 +11,6 @@ const PARSED = [\n             generics: [],\n         }],\n         foundElems: 1,\n-        id: \"fn:foo\",\n-        nameSplit: null,\n         original: \"fn:foo\",\n         returned: [],\n         typeFilter: 5,\n@@ -22,7 +19,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"foo\",\n             fullPath: [\"foo\"],\n@@ -31,8 +27,6 @@ const PARSED = [\n             generics: [],\n         }],\n         foundElems: 1,\n-        id: \"enum : foo\",\n-        nameSplit: null,\n         original: \"enum : foo\",\n         returned: [],\n         typeFilter: 4,\n@@ -41,7 +35,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"foo\",\n             fullPath: [\"foo\"],\n@@ -50,8 +43,6 @@ const PARSED = [\n             generics: [],\n         }],\n         foundElems: 1,\n-        id: \"macro<f>:foo\",\n-        nameSplit: null,\n         original: \"macro<f>:foo\",\n         returned: [],\n         typeFilter: 14,"}, {"sha": "34d33ed4d67a85604da31f272eada22d2529f3dd", "filename": "src/test/rustdoc-js-std/parser-generics.js", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-generics.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -1,9 +1,8 @@\n-const QUERY = ['<P>', 'A<B<C<D>, E>'];\n+const QUERY = ['<P>', 'A<B<C<D>, E>', 'p<> u8'];\n \n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"\",\n             fullPath: [\"\"],\n@@ -20,8 +19,6 @@ const PARSED = [\n             ],\n         }],\n         foundElems: 1,\n-        id: \"<P>\",\n-        nameSplit: null,\n         original: \"<P>\",\n         returned: [],\n         typeFilter: -1,\n@@ -30,7 +27,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"a\",\n             fullPath: [\"a\"],\n@@ -70,12 +66,35 @@ const PARSED = [\n             ],\n         }],\n         foundElems: 1,\n-        id: 'A<B<C<D>, E>',\n-        nameSplit: null,\n         original: 'A<B<C<D>, E>',\n         returned: [],\n         typeFilter: -1,\n         userQuery: 'a<b<c<d>, e>',\n         error: null,\n-    }\n+    },\n+    {\n+        args: [],\n+        elems: [\n+            {\n+                name: \"p\",\n+                fullPath: [\"p\"],\n+                pathWithoutLast: [],\n+                pathLast: \"p\",\n+                generics: [],\n+            },\n+            {\n+                name: \"u8\",\n+                fullPath: [\"u8\"],\n+                pathWithoutLast: [],\n+                pathLast: \"u8\",\n+                generics: [],\n+            },\n+        ],\n+        foundElems: 2,\n+        original: \"p<> u8\",\n+        returned: [],\n+        typeFilter: -1,\n+        userQuery: \"p<> u8\",\n+        error: null,\n+    },\n ];"}, {"sha": "e74e423ceed8220b427cd5628b59ec7e822b232a", "filename": "src/test/rustdoc-js-std/parser-in_args.js", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-in_args.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-in_args.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-in_args.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -9,11 +9,8 @@ const PARSED = [\n             pathLast: \"whatever\",\n             generics: [],\n         }],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"(whatever)\",\n-        nameSplit: null,\n         original: \"(whatever)\",\n         returned: [],\n         typeFilter: -1,\n@@ -36,11 +33,8 @@ const PARSED = [\n                 },\n             ],\n         }],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"(<P>)\",\n-        nameSplit: null,\n         original: \"(<P>)\",\n         returned: [],\n         typeFilter: -1,"}, {"sha": "5e7be3c73b0fae12f9adaf773b65061932c6fe10", "filename": "src/test/rustdoc-js-std/parser-invalid.js", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-invalid.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-invalid.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-invalid.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -6,11 +6,8 @@ const QUERY = ['-> <P> (p2)', '(p -> p2', 'a b', 'a,b(c)'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 2,\n-        id: \"-> <P> (p2)\",\n-        nameSplit: null,\n         original: \"-> <P> (p2)\",\n         returned: [\n             {\n@@ -57,11 +54,8 @@ const PARSED = [\n                 generics: [],\n             },\n         ],\n-        elemName: null,\n         elems: [],\n         foundElems: 2,\n-        id: \"(p -> p2\",\n-        nameSplit: null,\n         original: \"(p -> p2\",\n         returned: [],\n         typeFilter: -1,\n@@ -70,7 +64,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [\n             {\n                 name: \"a b\",\n@@ -81,8 +74,6 @@ const PARSED = [\n             },\n         ],\n         foundElems: 1,\n-        id: \"a b\",\n-        nameSplit: null,\n         original: \"a b\",\n         returned: [],\n         typeFilter: -1,\n@@ -99,7 +90,6 @@ const PARSED = [\n                 generics: [],\n             },\n         ],\n-        elemName: null,\n         elems: [\n             {\n                 name: \"a\",\n@@ -117,8 +107,6 @@ const PARSED = [\n             },\n         ],\n         foundElems: 3,\n-        id: \"a,b(c)\",\n-        nameSplit: null,\n         original: \"a,b(c)\",\n         returned: [],\n         typeFilter: -1,"}, {"sha": "f8c7367292226cc6777613b9a19418f5f4a07692", "filename": "src/test/rustdoc-js-std/parser-literal.js", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-literal.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,7 +3,6 @@ const QUERY = ['R<P>'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"r\",\n             fullPath: [\"r\"],\n@@ -20,8 +19,6 @@ const PARSED = [\n             ],\n         }],\n         foundElems: 1,\n-        id: \"R<P>\",\n-        nameSplit: null,\n         original: \"R<P>\",\n         returned: [],\n         typeFilter: -1,"}, {"sha": "1bd3bb61dc9669bc58afa6f2048f0b4f2095d68e", "filename": "src/test/rustdoc-js-std/parser-paths.js", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-paths.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,7 +3,6 @@ const QUERY = ['A::B', '::A::B', 'A::B::,C',  'A::B::<f>,C'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"a::b\",\n             fullPath: [\"a\", \"b\"],\n@@ -12,8 +11,6 @@ const PARSED = [\n             generics: [],\n         }],\n         foundElems: 1,\n-        id: \"A::B\",\n-        nameSplit: null,\n         original: \"A::B\",\n         returned: [],\n         typeFilter: -1,\n@@ -22,7 +19,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [{\n             name: \"::a::b\",\n             fullPath: [\"a\", \"b\"],\n@@ -31,8 +27,6 @@ const PARSED = [\n             generics: [],\n         }],\n         foundElems: 1,\n-        id: '::A::B',\n-        nameSplit: null,\n         original: '::A::B',\n         returned: [],\n         typeFilter: -1,\n@@ -41,7 +35,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [\n             {\n                 name: \"a::b::\",\n@@ -59,8 +52,6 @@ const PARSED = [\n             },\n         ],\n         foundElems: 2,\n-        id: 'A::B::,C',\n-        nameSplit: null,\n         original: 'A::B::,C',\n         returned: [],\n         typeFilter: -1,\n@@ -69,7 +60,6 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [\n             {\n                 name: \"a::b::\",\n@@ -95,8 +85,6 @@ const PARSED = [\n             },\n         ],\n         foundElems: 2,\n-        id: 'A::B::<f>,C',\n-        nameSplit: null,\n         original: 'A::B::<f>,C',\n         returned: [],\n         typeFilter: -1,"}, {"sha": "07af92491726f30699256dc61fc3c3eff3864d75", "filename": "src/test/rustdoc-js-std/parser-quote.js", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-quote.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,11 +3,8 @@ const QUERY = ['-> \"p\"', '(\"p\")'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"-> \\\"p\\\"\",\n-        nameSplit: null,\n         original: \"-> \\\"p\\\"\",\n         returned: [{\n             name: \"p\",\n@@ -28,11 +25,8 @@ const PARSED = [\n             pathLast: \"p\",\n             generics: [],\n         }],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"(\\\"p\\\")\",\n-        nameSplit: null,\n         original: \"(\\\"p\\\")\",\n         returned: [],\n         typeFilter: -1,"}, {"sha": "face0a7461df5f5a9dae29f66a00a22ad3bfc443", "filename": "src/test/rustdoc-js-std/parser-returned.js", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fparser-returned.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -3,11 +3,8 @@ const QUERY = ['-> <P>', '-> P'];\n const PARSED = [\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"-> <P>\",\n-        nameSplit: null,\n         original: \"-> <P>\",\n         returned: [{\n             name: \"\",\n@@ -30,11 +27,8 @@ const PARSED = [\n     },\n     {\n         args: [],\n-        elemName: null,\n         elems: [],\n         foundElems: 1,\n-        id: \"-> P\",\n-        nameSplit: null,\n         original: \"-> P\",\n         returned: [{\n             name: \"p\","}, {"sha": "cd0e8e7b4a9eb41524adbb55fc8d9c931a8d20d4", "filename": "src/test/rustdoc-js-std/vec-new.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js-std%2Fvec-new.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -4,6 +4,6 @@ const EXPECTED = {\n     'others': [\n         { 'path': 'std::vec::Vec', 'name': 'new' },\n         { 'path': 'std::vec::Vec', 'name': 'ne' },\n-        { 'path': 'std::rc::Rc', 'name': 'ne' },\n+        { 'path': 'alloc::vec::Vec', 'name': 'ne' },\n     ],\n };"}, {"sha": "c9fc0c4311f19adfe5e2d256f516729b4ae4a2f5", "filename": "src/test/rustdoc-js/doc-alias-whitespace.js", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias-whitespace.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -10,7 +10,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias_whitespace',\n                 'name': 'Struct',\n-                'alias': 'demon lord',\n+                'alias': 'Demon Lord',\n                 'href': '../doc_alias_whitespace/struct.Struct.html',\n                 'is_alias': true\n             },"}, {"sha": "7bb0cbe388fee1c8d7626b2d4aa74edd9ac80d10", "filename": "src/test/rustdoc-js/doc-alias.js", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-js%2Fdoc-alias.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -32,7 +32,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Struct',\n-                'alias': 'structitem',\n+                'alias': 'StructItem',\n                 'href': '../doc_alias/struct.Struct.html',\n                 'is_alias': true\n             },\n@@ -44,7 +44,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Struct',\n                 'name': 'field',\n-                'alias': 'structfielditem',\n+                'alias': 'StructFieldItem',\n                 'href': '../doc_alias/struct.Struct.html#structfield.field',\n                 'is_alias': true\n             },\n@@ -56,7 +56,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Struct',\n                 'name': 'method',\n-                'alias': 'structmethoditem',\n+                'alias': 'StructMethodItem',\n                 'href': '../doc_alias/struct.Struct.html#method.method',\n                 'is_alias': true\n             },\n@@ -72,7 +72,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Struct',\n                 'name': 'ImplConstItem',\n-                'alias': 'structimplconstitem',\n+                'alias': 'StructImplConstItem',\n                 'href': '../doc_alias/struct.Struct.html#associatedconstant.ImplConstItem',\n                 'is_alias': true\n             },\n@@ -84,7 +84,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Struct',\n                 'name': 'function',\n-                'alias': 'impltraitfunction',\n+                'alias': 'ImplTraitFunction',\n                 'href': '../doc_alias/struct.Struct.html#method.function',\n                 'is_alias': true\n             },\n@@ -96,7 +96,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Enum',\n-                'alias': 'enumitem',\n+                'alias': 'EnumItem',\n                 'href': '../doc_alias/enum.Enum.html',\n                 'is_alias': true\n             },\n@@ -108,7 +108,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Enum',\n                 'name': 'Variant',\n-                'alias': 'variantitem',\n+                'alias': 'VariantItem',\n                 'href': '../doc_alias/enum.Enum.html#variant.Variant',\n                 'is_alias': true\n             },\n@@ -120,7 +120,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Enum',\n                 'name': 'method',\n-                'alias': 'enummethoditem',\n+                'alias': 'EnumMethodItem',\n                 'href': '../doc_alias/enum.Enum.html#method.method',\n                 'is_alias': true\n             },\n@@ -132,7 +132,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Typedef',\n-                'alias': 'typedefitem',\n+                'alias': 'TypedefItem',\n                 'href': '../doc_alias/type.Typedef.html',\n                 'is_alias': true\n             },\n@@ -144,7 +144,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Trait',\n-                'alias': 'traititem',\n+                'alias': 'TraitItem',\n                 'href': '../doc_alias/trait.Trait.html',\n                 'is_alias': true\n             },\n@@ -156,7 +156,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Trait',\n                 'name': 'Target',\n-                'alias': 'traittypeitem',\n+                'alias': 'TraitTypeItem',\n                 'href': '../doc_alias/trait.Trait.html#associatedtype.Target',\n                 'is_alias': true\n             },\n@@ -168,7 +168,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Trait',\n                 'name': 'AssociatedConst',\n-                'alias': 'associatedconstitem',\n+                'alias': 'AssociatedConstItem',\n                 'href': '../doc_alias/trait.Trait.html#associatedconstant.AssociatedConst',\n                 'is_alias': true\n             },\n@@ -180,7 +180,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Trait',\n                 'name': 'function',\n-                'alias': 'traitfunctionitem',\n+                'alias': 'TraitFunctionItem',\n                 'href': '../doc_alias/trait.Trait.html#tymethod.function',\n                 'is_alias': true\n             },\n@@ -192,7 +192,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'function',\n-                'alias': 'functionitem',\n+                'alias': 'FunctionItem',\n                 'href': '../doc_alias/fn.function.html',\n                 'is_alias': true\n             },\n@@ -204,7 +204,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Module',\n-                'alias': 'moduleitem',\n+                'alias': 'ModuleItem',\n                 'href': '../doc_alias/Module/index.html',\n                 'is_alias': true\n             },\n@@ -216,7 +216,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Const',\n-                'alias': 'constitem',\n+                'alias': 'ConstItem',\n                 'href': '../doc_alias/constant.Const.html',\n                 'is_alias': true\n             },\n@@ -232,7 +232,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Static',\n-                'alias': 'staticitem',\n+                'alias': 'StaticItem',\n                 'href': '../doc_alias/static.Static.html',\n                 'is_alias': true\n             },\n@@ -244,7 +244,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Union',\n-                'alias': 'unionitem',\n+                'alias': 'UnionItem',\n                 'href': '../doc_alias/union.Union.html',\n                 'is_alias': true\n             },\n@@ -262,7 +262,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Union',\n                 'name': 'union_item',\n-                'alias': 'unionfielditem',\n+                'alias': 'UnionFieldItem',\n                 'href': '../doc_alias/union.Union.html#structfield.union_item',\n                 'is_alias': true\n             },\n@@ -274,7 +274,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias::Union',\n                 'name': 'method',\n-                'alias': 'unionmethoditem',\n+                'alias': 'UnionMethodItem',\n                 'href': '../doc_alias/union.Union.html#method.method',\n                 'is_alias': true\n             },\n@@ -286,7 +286,7 @@ const EXPECTED = [\n             {\n                 'path': 'doc_alias',\n                 'name': 'Macro',\n-                'alias': 'macroitem',\n+                'alias': 'MacroItem',\n                 'href': '../doc_alias/macro.Macro.html',\n                 'is_alias': true\n             },"}, {"sha": "4ef08f53dabc5d2826143a6c92a86a1cfe9b870f", "filename": "src/tools/rustdoc-js/tester.js", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftools%2Frustdoc-js%2Ftester.js", "raw_url": "https://github.com/rust-lang/rust/raw/264064df36e055c19af2c82145bbbe616b32fb02/src%2Ftools%2Frustdoc-js%2Ftester.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Frustdoc-js%2Ftester.js?ref=264064df36e055c19af2c82145bbbe616b32fb02", "patch": "@@ -270,7 +270,12 @@ function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     // execQuery last parameter is built in buildIndex.\n     // buildIndex requires the hashmap from search-index.\n     var functionsToLoad = [\"buildHrefAndPath\", \"pathSplitter\", \"levenshtein\", \"validateResult\",\n-                           \"buildIndex\", \"execQuery\", \"parseQuery\", \"createQueryResults\"];\n+                           \"buildIndex\", \"execQuery\", \"parseQuery\", \"createQueryResults\",\n+                           \"isWhitespace\", \"isSpecialStartCharacter\", \"isStopCharacter\",\n+                           \"removeEmptyStringsFromArray\", \"parseInput\", \"getItemsBefore\",\n+                           \"getNextElem\", \"createQueryElement\", \"isReturnArrow\", \"isPathStart\",\n+                           \"skipWhitespaces\", \"getStringElem\", \"itemTypeFromName\",\n+                           \"newParsedQuery\"];\n \n     const functions = [\"hasOwnPropertyRustdoc\", \"onEach\"];\n     ALIASES = {};\n@@ -286,13 +291,12 @@ function loadSearchJsAndIndex(searchJs, searchIndex, storageJs, crate) {\n     return [loaded, index];\n }\n \n-function checkFieldNeededFields(fullPath, expected, error_text, queryName, position) {\n+// This function checks if `expected` has all the required fields needed for the checks.\n+function checkNeededFields(fullPath, expected, error_text, queryName, position) {\n     let fieldsToCheck;\n     if (fullPath.length === 0) {\n         fieldsToCheck = [\n             \"foundElems\",\n-            \"id\",\n-            \"nameSplit\",\n             \"original\",\n             \"returned\",\n             \"typeFilter\",\n@@ -328,7 +332,7 @@ function checkFieldNeededFields(fullPath, expected, error_text, queryName, posit\n function valueCheck(fullPath, expected, result, error_text, queryName) {\n     if (Array.isArray(expected)) {\n         for (var i = 0; i < expected.length; ++i) {\n-            checkFieldNeededFields(fullPath, expected[i], error_text, queryName, i);\n+            checkNeededFields(fullPath, expected[i], error_text, queryName, i);\n             if (i >= result.length) {\n                 error_text.push(`${queryName}==> EXPECTED has extra value in array from field ` +\n                     `\\`${fullPath}\\` (position ${i}): \\`${JSON.stringify(expected[i])}\\``);\n@@ -367,7 +371,7 @@ function valueCheck(fullPath, expected, result, error_text, queryName) {\n \n function runParser(query, expected, loaded, loadedFile, queryName) {\n     var error_text = [];\n-    checkFieldNeededFields(\"\", expected, error_text, queryName, null);\n+    checkNeededFields(\"\", expected, error_text, queryName, null);\n     if (error_text.length === 0) {\n         valueCheck('', expected, loaded.parseQuery(query), error_text, queryName);\n     }"}]}