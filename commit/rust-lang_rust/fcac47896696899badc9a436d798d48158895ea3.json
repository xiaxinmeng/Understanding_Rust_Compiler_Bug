{"sha": "fcac47896696899badc9a436d798d48158895ea3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjYWM0Nzg5NjY5Njg5OWJhZGM5YTQzNmQ3OThkNDgxNTg4OTVlYTM=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-06-17T21:40:57Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-17T21:40:57Z"}, "message": "Rollup merge of #85925 - clarfonthey:lerp, r=m-ou-se\n\nLinear interpolation\n\n#71016 is a previous attempt at implementation that was closed by the author. I decided to reuse the feature request issue (#71015) as a tracking issue. A member of the rust-lang org will have to edit the original post to be formatted correctly as I am not the issue's original author.\n\nThe common name `lerp` is used because it is the term used by most code in a wide variety of contexts; it also happens to be the recently chosen name of the function that was added to C++20.\n\nTo ensure symmetry as a method, this breaks the usual ordering of the method from `lerp(a, b, t)` to `t.lerp(a, b)`. This makes the most sense to me personally, and there will definitely be discussion before stabilisation anyway.\n\nImplementing lerp \"correctly\" is very dififcult even though it's a very common building-block used in all sorts of applications. A good prior reading is [this proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html#linear-interpolation) for the C++20 lerp which talks about the various guarantees, which I've simplified down to:\n\n1. Exactness: `(0.0).lerp(start, end) == start` and `(1.0).lerp(start, end) == end`\n2. Consistency: `anything.lerp(x, x) == x`\n3. Monotonicity: once you go up don't go down\n\nFun story: the version provided in that proposal, from what I understand, isn't actually monotonic.\n\nI messed around with a *lot* of different lerp implementations because I kind of got a bit obsessed and I ultimately landed on one that uses the fused `mul_add` instruction. Floating-point lerp lore is hard to come by, so, just trust me when I say that this ticks all the boxes. I'm only 90% certain that it's monotonic, but I'm sure that people who care deeply about this will be there to discuss before stabilisation.\n\nThe main reason for using `mul_add` is that, in general, it ticks more boxes with fewer branches to be \"correct.\" Although it will be slower on architectures without the fused `mul_add`, that's becoming more and more rare and I have a feeling that most people who will find themselves needing `lerp` will also have an efficient `mul_add` instruction available.", "tree": {"sha": "08302428c205c02b60d6b0d142a2127737f4480e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08302428c205c02b60d6b0d142a2127737f4480e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fcac47896696899badc9a436d798d48158895ea3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgy8FqCRBK7hj4Ov3rIwAArYQIAEqg4XQuP1dRE48bWAj10V7C\ngVG+a0C2zJkBn5co9IeeOSv46a5eiSttTABFO0w9ChWWBw0rU3AauefdbIiuvEnL\nFUdq78bxrd0OgbAhiWP9l6bKY5e9m897OGSsVrEQcGjZKO3GJfspnmKEwAQYTRTq\nnqfEPq9tQY7ZqbiXbrnzi0mV92HR9rG8dqmNiAguubkI9OM1Ol1Lvf6uNpejzUcO\nb9pXFEFHXyTYP4ymJP1gJGl9aMwt35sG0cF1TG18YRJ5LVZkv7hPE3q0snLg4MVy\nbORxzx60e37wNjPY7TN7c6+uHPbtvDezzaugqbbTl9tPi10jDn6y3rW9ACbzlJA=\n=7Blf\n-----END PGP SIGNATURE-----\n", "payload": "tree 08302428c205c02b60d6b0d142a2127737f4480e\nparent e062e5d34ee80e0d5da403e8c5609f29e6a7dbcb\nparent 525d76026fe855f6a9de4604d9fee50d974994a3\nauthor Mara Bos <m-ou.se@m-ou.se> 1623966057 +0200\ncommitter GitHub <noreply@github.com> 1623966057 +0200\n\nRollup merge of #85925 - clarfonthey:lerp, r=m-ou-se\n\nLinear interpolation\n\n#71016 is a previous attempt at implementation that was closed by the author. I decided to reuse the feature request issue (#71015) as a tracking issue. A member of the rust-lang org will have to edit the original post to be formatted correctly as I am not the issue's original author.\n\nThe common name `lerp` is used because it is the term used by most code in a wide variety of contexts; it also happens to be the recently chosen name of the function that was added to C++20.\n\nTo ensure symmetry as a method, this breaks the usual ordering of the method from `lerp(a, b, t)` to `t.lerp(a, b)`. This makes the most sense to me personally, and there will definitely be discussion before stabilisation anyway.\n\nImplementing lerp \"correctly\" is very dififcult even though it's a very common building-block used in all sorts of applications. A good prior reading is [this proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0811r2.html#linear-interpolation) for the C++20 lerp which talks about the various guarantees, which I've simplified down to:\n\n1. Exactness: `(0.0).lerp(start, end) == start` and `(1.0).lerp(start, end) == end`\n2. Consistency: `anything.lerp(x, x) == x`\n3. Monotonicity: once you go up don't go down\n\nFun story: the version provided in that proposal, from what I understand, isn't actually monotonic.\n\nI messed around with a *lot* of different lerp implementations because I kind of got a bit obsessed and I ultimately landed on one that uses the fused `mul_add` instruction. Floating-point lerp lore is hard to come by, so, just trust me when I say that this ticks all the boxes. I'm only 90% certain that it's monotonic, but I'm sure that people who care deeply about this will be there to discuss before stabilisation.\n\nThe main reason for using `mul_add` is that, in general, it ticks more boxes with fewer branches to be \"correct.\" Although it will be slower on architectures without the fused `mul_add`, that's becoming more and more rare and I have a feeling that most people who will find themselves needing `lerp` will also have an efficient `mul_add` instruction available.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fcac47896696899badc9a436d798d48158895ea3", "html_url": "https://github.com/rust-lang/rust/commit/fcac47896696899badc9a436d798d48158895ea3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fcac47896696899badc9a436d798d48158895ea3/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e062e5d34ee80e0d5da403e8c5609f29e6a7dbcb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e062e5d34ee80e0d5da403e8c5609f29e6a7dbcb", "html_url": "https://github.com/rust-lang/rust/commit/e062e5d34ee80e0d5da403e8c5609f29e6a7dbcb"}, {"sha": "525d76026fe855f6a9de4604d9fee50d974994a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/525d76026fe855f6a9de4604d9fee50d974994a3", "html_url": "https://github.com/rust-lang/rust/commit/525d76026fe855f6a9de4604d9fee50d974994a3"}], "stats": {"total": 191, "additions": 191, "deletions": 0}, "files": [{"sha": "21bd79611a5e519d6dc6ad6ee206d36c96502b64", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=fcac47896696899badc9a436d798d48158895ea3", "patch": "@@ -876,4 +876,40 @@ impl f32 {\n     pub fn atanh(self) -> f32 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n+\n+    /// Linear interpolation between `start` and `end`.\n+    ///\n+    /// This enables linear interpolation between `start` and `end`, where start is represented by\n+    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n+    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n+    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n+    ///\n+    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n+    /// range from `start` to `end`. This also is useful for transition functions which might\n+    /// move slightly past the end or start for a desired effect. Mathematically, the values\n+    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n+    /// guarantees that are useful specifically to linear interpolation.\n+    ///\n+    /// These guarantees are:\n+    ///\n+    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n+    ///   value at 1.0 is always `end`. (exactness)\n+    /// * If `start` and `end` are [finite], the values will always move in the direction from\n+    ///   `start` to `end` (monotonicity)\n+    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n+    ///   `start == end`. (consistency)\n+    ///\n+    /// [finite]: #method.is_finite\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n+    pub fn lerp(self, start: f32, end: f32) -> f32 {\n+        // consistent\n+        if start == end {\n+            start\n+\n+        // exact/monotonic\n+        } else {\n+            self.mul_add(end, (-self).mul_add(start, start))\n+        }\n+    }\n }"}, {"sha": "fe66a73afd63ab7ef6d55f5dfe708640e22cde46", "filename": "library/std/src/f32/tests.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32%2Ftests.rs?ref=fcac47896696899badc9a436d798d48158895ea3", "patch": "@@ -757,3 +757,66 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f32::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n+\n+#[test]\n+fn test_lerp_exact() {\n+    // simple values\n+    assert_eq!(f32::lerp(0.0, 2.0, 4.0), 2.0);\n+    assert_eq!(f32::lerp(1.0, 2.0, 4.0), 4.0);\n+\n+    // boundary values\n+    assert_eq!(f32::lerp(0.0, f32::MIN, f32::MAX), f32::MIN);\n+    assert_eq!(f32::lerp(1.0, f32::MIN, f32::MAX), f32::MAX);\n+}\n+\n+#[test]\n+fn test_lerp_consistent() {\n+    assert_eq!(f32::lerp(f32::MAX, f32::MIN, f32::MIN), f32::MIN);\n+    assert_eq!(f32::lerp(f32::MIN, f32::MAX, f32::MAX), f32::MAX);\n+\n+    // as long as t is finite, a/b can be infinite\n+    assert_eq!(f32::lerp(f32::MAX, f32::NEG_INFINITY, f32::NEG_INFINITY), f32::NEG_INFINITY);\n+    assert_eq!(f32::lerp(f32::MIN, f32::INFINITY, f32::INFINITY), f32::INFINITY);\n+}\n+\n+#[test]\n+fn test_lerp_nan_infinite() {\n+    // non-finite t is not NaN if a/b different\n+    assert!(!f32::lerp(f32::INFINITY, f32::MIN, f32::MAX).is_nan());\n+    assert!(!f32::lerp(f32::NEG_INFINITY, f32::MIN, f32::MAX).is_nan());\n+}\n+\n+#[test]\n+fn test_lerp_values() {\n+    // just a few basic values\n+    assert_eq!(f32::lerp(0.25, 1.0, 2.0), 1.25);\n+    assert_eq!(f32::lerp(0.50, 1.0, 2.0), 1.50);\n+    assert_eq!(f32::lerp(0.75, 1.0, 2.0), 1.75);\n+}\n+\n+#[test]\n+fn test_lerp_monotonic() {\n+    // near 0\n+    let below_zero = f32::lerp(-f32::EPSILON, f32::MIN, f32::MAX);\n+    let zero = f32::lerp(0.0, f32::MIN, f32::MAX);\n+    let above_zero = f32::lerp(f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_zero <= zero);\n+    assert!(zero <= above_zero);\n+    assert!(below_zero <= above_zero);\n+\n+    // near 0.5\n+    let below_half = f32::lerp(0.5 - f32::EPSILON, f32::MIN, f32::MAX);\n+    let half = f32::lerp(0.5, f32::MIN, f32::MAX);\n+    let above_half = f32::lerp(0.5 + f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_half <= half);\n+    assert!(half <= above_half);\n+    assert!(below_half <= above_half);\n+\n+    // near 1\n+    let below_one = f32::lerp(1.0 - f32::EPSILON, f32::MIN, f32::MAX);\n+    let one = f32::lerp(1.0, f32::MIN, f32::MAX);\n+    let above_one = f32::lerp(1.0 + f32::EPSILON, f32::MIN, f32::MAX);\n+    assert!(below_one <= one);\n+    assert!(one <= above_one);\n+    assert!(below_one <= above_one);\n+}"}, {"sha": "8c8cf73741b512aa4fa1f76833f7518ef94f4b8f", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=fcac47896696899badc9a436d798d48158895ea3", "patch": "@@ -879,6 +879,42 @@ impl f64 {\n         0.5 * ((2.0 * self) / (1.0 - self)).ln_1p()\n     }\n \n+    /// Linear interpolation between `start` and `end`.\n+    ///\n+    /// This enables linear interpolation between `start` and `end`, where start is represented by\n+    /// `self == 0.0` and `end` is represented by `self == 1.0`. This is the basis of all\n+    /// \"transition\", \"easing\", or \"step\" functions; if you change `self` from 0.0 to 1.0\n+    /// at a given rate, the result will change from `start` to `end` at a similar rate.\n+    ///\n+    /// Values below 0.0 or above 1.0 are allowed, allowing you to extrapolate values outside the\n+    /// range from `start` to `end`. This also is useful for transition functions which might\n+    /// move slightly past the end or start for a desired effect. Mathematically, the values\n+    /// returned are equivalent to `start + self * (end - start)`, although we make a few specific\n+    /// guarantees that are useful specifically to linear interpolation.\n+    ///\n+    /// These guarantees are:\n+    ///\n+    /// * If `start` and `end` are [finite], the value at 0.0 is always `start` and the\n+    ///   value at 1.0 is always `end`. (exactness)\n+    /// * If `start` and `end` are [finite], the values will always move in the direction from\n+    ///   `start` to `end` (monotonicity)\n+    /// * If `self` is [finite] and `start == end`, the value at any point will always be\n+    ///   `start == end`. (consistency)\n+    ///\n+    /// [finite]: #method.is_finite\n+    #[must_use = \"method returns a new number and does not mutate the original value\"]\n+    #[unstable(feature = \"float_interpolation\", issue = \"86269\")]\n+    pub fn lerp(self, start: f64, end: f64) -> f64 {\n+        // consistent\n+        if start == end {\n+            start\n+\n+        // exact/monotonic\n+        } else {\n+            self.mul_add(end, (-self).mul_add(start, start))\n+        }\n+    }\n+\n     // Solaris/Illumos requires a wrapper around log, log2, and log10 functions\n     // because of their non-standard behavior (e.g., log(-n) returns -Inf instead\n     // of expected NaN)."}, {"sha": "04cb0109261a48068d54261a7c3cb381ed458220", "filename": "library/std/src/f64/tests.rs", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64%2Ftests.rs?ref=fcac47896696899badc9a436d798d48158895ea3", "patch": "@@ -753,3 +753,58 @@ fn test_total_cmp() {\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&f64::INFINITY));\n     assert_eq!(Ordering::Less, (-s_nan()).total_cmp(&s_nan()));\n }\n+\n+#[test]\n+fn test_lerp_exact() {\n+    // simple values\n+    assert_eq!(f64::lerp(0.0, 2.0, 4.0), 2.0);\n+    assert_eq!(f64::lerp(1.0, 2.0, 4.0), 4.0);\n+\n+    // boundary values\n+    assert_eq!(f64::lerp(0.0, f64::MIN, f64::MAX), f64::MIN);\n+    assert_eq!(f64::lerp(1.0, f64::MIN, f64::MAX), f64::MAX);\n+}\n+\n+#[test]\n+fn test_lerp_consistent() {\n+    assert_eq!(f64::lerp(f64::MAX, f64::MIN, f64::MIN), f64::MIN);\n+    assert_eq!(f64::lerp(f64::MIN, f64::MAX, f64::MAX), f64::MAX);\n+\n+    // as long as t is finite, a/b can be infinite\n+    assert_eq!(f64::lerp(f64::MAX, f64::NEG_INFINITY, f64::NEG_INFINITY), f64::NEG_INFINITY);\n+    assert_eq!(f64::lerp(f64::MIN, f64::INFINITY, f64::INFINITY), f64::INFINITY);\n+}\n+\n+#[test]\n+fn test_lerp_nan_infinite() {\n+    // non-finite t is not NaN if a/b different\n+    assert!(!f64::lerp(f64::INFINITY, f64::MIN, f64::MAX).is_nan());\n+    assert!(!f64::lerp(f64::NEG_INFINITY, f64::MIN, f64::MAX).is_nan());\n+}\n+\n+#[test]\n+fn test_lerp_values() {\n+    // just a few basic values\n+    assert_eq!(f64::lerp(0.25, 1.0, 2.0), 1.25);\n+    assert_eq!(f64::lerp(0.50, 1.0, 2.0), 1.50);\n+    assert_eq!(f64::lerp(0.75, 1.0, 2.0), 1.75);\n+}\n+\n+#[test]\n+fn test_lerp_monotonic() {\n+    // near 0\n+    let below_zero = f64::lerp(-f64::EPSILON, f64::MIN, f64::MAX);\n+    let zero = f64::lerp(0.0, f64::MIN, f64::MAX);\n+    let above_zero = f64::lerp(f64::EPSILON, f64::MIN, f64::MAX);\n+    assert!(below_zero <= zero);\n+    assert!(zero <= above_zero);\n+    assert!(below_zero <= above_zero);\n+\n+    // near 1\n+    let below_one = f64::lerp(1.0 - f64::EPSILON, f64::MIN, f64::MAX);\n+    let one = f64::lerp(1.0, f64::MIN, f64::MAX);\n+    let above_one = f64::lerp(1.0 + f64::EPSILON, f64::MIN, f64::MAX);\n+    assert!(below_one <= one);\n+    assert!(one <= above_one);\n+    assert!(below_one <= above_one);\n+}"}, {"sha": "664cc748ca6db6f28fff2ee5beeec903880e1166", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fcac47896696899badc9a436d798d48158895ea3/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=fcac47896696899badc9a436d798d48158895ea3", "patch": "@@ -268,6 +268,7 @@\n #![feature(exhaustive_patterns)]\n #![feature(extend_one)]\n #![cfg_attr(bootstrap, feature(extended_key_value_attributes))]\n+#![feature(float_interpolation)]\n #![feature(fn_traits)]\n #![feature(format_args_nl)]\n #![feature(gen_future)]"}]}