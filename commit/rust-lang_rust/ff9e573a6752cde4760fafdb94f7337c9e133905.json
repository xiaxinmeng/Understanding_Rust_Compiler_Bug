{"sha": "ff9e573a6752cde4760fafdb94f7337c9e133905", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOWU1NzNhNjc1MmNkZTQ3NjBmYWZkYjk0ZjczMzdjOWUxMzM5MDU=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-23T03:57:55Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-10-28T01:25:19Z"}, "message": "Remove MD4.", "tree": {"sha": "fabb306942ad55a76526b1ed0060b499c7b6d834", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fabb306942ad55a76526b1ed0060b499c7b6d834"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff9e573a6752cde4760fafdb94f7337c9e133905", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff9e573a6752cde4760fafdb94f7337c9e133905", "html_url": "https://github.com/rust-lang/rust/commit/ff9e573a6752cde4760fafdb94f7337c9e133905", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff9e573a6752cde4760fafdb94f7337c9e133905/comments", "author": null, "committer": null, "parents": [{"sha": "ca132006a0875bb373c780f32f6aea4fd94ffbf0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca132006a0875bb373c780f32f6aea4fd94ffbf0", "html_url": "https://github.com/rust-lang/rust/commit/ca132006a0875bb373c780f32f6aea4fd94ffbf0"}], "stats": {"total": 151, "additions": 0, "deletions": 151}, "files": [{"sha": "90434cf0d4912ad0569ecb6d10c890d89d6801eb", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff9e573a6752cde4760fafdb94f7337c9e133905/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=ff9e573a6752cde4760fafdb94f7337c9e133905", "patch": "@@ -74,7 +74,6 @@ pub mod url;\n pub mod ebml;\n pub mod getopts;\n pub mod json;\n-pub mod md4;\n pub mod tempfile;\n pub mod glob;\n pub mod term;"}, {"sha": "96238986bf1c8ef81c376d3455999c33cfefc9fd", "filename": "src/libextra/md4.rs", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibextra%2Fmd4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca132006a0875bb373c780f32f6aea4fd94ffbf0/src%2Flibextra%2Fmd4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fmd4.rs?ref=ca132006a0875bb373c780f32f6aea4fd94ffbf0", "patch": "@@ -1,150 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[allow(missing_doc)];\n-\n-use std::vec;\n-\n-struct Quad {\n-    a: u32,\n-    b: u32,\n-    c: u32,\n-    d: u32\n-}\n-\n-/// Calculates the md4 hash of the given slice of bytes, returning the 128-bit\n-/// result as a quad of u32's\n-pub fn md4(msg: &[u8]) -> Quad {\n-    // subtle: if orig_len is merely uint, then the code below\n-    // which performs shifts by 32 bits or more has undefined\n-    // results.\n-    let orig_len: u64 = (msg.len() * 8u) as u64;\n-\n-    // pad message\n-    let mut msg = vec::append(msg.to_owned(), [0x80u8]);\n-    let mut bitlen = orig_len + 8u64;\n-    while (bitlen + 64u64) % 512u64 > 0u64 {\n-        msg.push(0u8);\n-        bitlen += 8u64;\n-    }\n-\n-    // append length\n-    let mut i = 0u64;\n-    while i < 8u64 {\n-        msg.push((orig_len >> (i * 8u64)) as u8);\n-        i += 1u64;\n-    }\n-\n-    let mut a = 0x67452301u32;\n-    let mut b = 0xefcdab89u32;\n-    let mut c = 0x98badcfeu32;\n-    let mut d = 0x10325476u32;\n-\n-    fn rot(r: int, x: u32) -> u32 {\n-        let r = r as u32;\n-        (x << r) | (x >> (32u32 - r))\n-    }\n-\n-    let mut i = 0u;\n-    let e = msg.len();\n-    let mut x = vec::from_elem(16u, 0u32);\n-    while i < e {\n-        let (aa, bb, cc, dd) = (a, b, c, d);\n-\n-        let mut j = 0u;\n-        let mut base = i;\n-        while j < 16u {\n-            x[j] = (msg[base] as u32) + (msg[base + 1u] as u32 << 8u32) +\n-                (msg[base + 2u] as u32 << 16u32) +\n-                (msg[base + 3u] as u32 << 24u32);\n-            j += 1u; base += 4u;\n-        }\n-\n-        let mut j = 0u;\n-        while j < 16u {\n-            a = rot(3, a + ((b & c) | (!b & d)) + x[j]);\n-            j += 1u;\n-            d = rot(7, d + ((a & b) | (!a & c)) + x[j]);\n-            j += 1u;\n-            c = rot(11, c + ((d & a) | (!d & b)) + x[j]);\n-            j += 1u;\n-            b = rot(19, b + ((c & d) | (!c & a)) + x[j]);\n-            j += 1u;\n-        }\n-\n-        let mut j = 0u;\n-        let q = 0x5a827999u32;\n-        while j < 4u {\n-            a = rot(3, a + ((b & c) | ((b & d) | (c & d))) + x[j] + q);\n-            d = rot(5, d + ((a & b) | ((a & c) | (b & c))) + x[j + 4u] + q);\n-            c = rot(9, c + ((d & a) | ((d & b) | (a & b))) + x[j + 8u] + q);\n-            b = rot(13, b + ((c & d) | ((c & a) | (d & a))) + x[j + 12u] + q);\n-            j += 1u;\n-        }\n-\n-        let mut j = 0u;\n-        let q = 0x6ed9eba1u32;\n-        while j < 8u {\n-            let jj = if j > 2u { j - 3u } else { j };\n-            a = rot(3, a + (b ^ c ^ d) + x[jj] + q);\n-            d = rot(9, d + (a ^ b ^ c) + x[jj + 8u] + q);\n-            c = rot(11, c + (d ^ a ^ b) + x[jj + 4u] + q);\n-            b = rot(15, b + (c ^ d ^ a) + x[jj + 12u] + q);\n-            j += 2u;\n-        }\n-\n-        a += aa; b += bb; c += cc; d += dd;\n-        i += 64u;\n-    }\n-    return Quad {a: a, b: b, c: c, d: d};\n-}\n-\n-/// Calculates the md4 hash of a slice of bytes, returning the hex-encoded\n-/// version of the hash\n-pub fn md4_str(msg: &[u8]) -> ~str {\n-    let Quad {a, b, c, d} = md4(msg);\n-    fn app(a: u32, b: u32, c: u32, d: u32, f: &fn(u32)) {\n-        f(a); f(b); f(c); f(d);\n-    }\n-    let mut result = ~\"\";\n-    do app(a, b, c, d) |u| {\n-        let mut i = 0u32;\n-        while i < 4u32 {\n-            let byte = (u >> (i * 8u32)) as u8;\n-            if byte <= 16u8 {\n-                result.push_char('0')\n-            }\n-            result.push_str((byte as uint).to_str_radix(16u));\n-            i += 1u32;\n-        }\n-    }\n-    result\n-}\n-\n-/// Calculates the md4 hash of a string, returning the hex-encoded version of\n-/// the hash\n-pub fn md4_text(msg: &str) -> ~str { md4_str(msg.as_bytes()) }\n-\n-#[test]\n-fn test_md4() {\n-    assert_eq!(md4_text(\"\"), ~\"31d6cfe0d16ae931b73c59d7e0c089c0\");\n-    assert_eq!(md4_text(\"a\"), ~\"bde52cb31de33e46245e05fbdbd6fb24\");\n-    assert_eq!(md4_text(\"abc\"), ~\"a448017aaf21d8525fc10ae87aa6729d\");\n-    assert!(md4_text(\"message digest\") ==\n-        ~\"d9130a8164549fe818874806e1c7014b\");\n-    assert!(md4_text(\"abcdefghijklmnopqrstuvwxyz\") ==\n-        ~\"d79e1c308aa5bbcdeea8ed63df412da9\");\n-    assert!(md4_text(\n-        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\\\n-        0123456789\") == ~\"043f8582f241db351ce627e153e7f0e4\");\n-    assert!(md4_text(\"1234567890123456789012345678901234567890123456789\\\n-                     0123456789012345678901234567890\") ==\n-        ~\"e33b4ddc9c38f2199c3e7b164fcc0536\");\n-}"}]}