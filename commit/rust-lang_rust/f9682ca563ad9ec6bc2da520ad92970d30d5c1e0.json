{"sha": "f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5NjgyY2E1NjNhZDllYzZiYzJkYTUyMGFkOTI5NzBkMzBkNWMxZTA=", "commit": {"author": {"name": "Oliver Schneider", "email": "oli-obk@users.noreply.github.com", "date": "2017-10-24T06:19:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-24T06:19:39Z"}, "message": "Merge pull request #2154 from durka/ifchain\n\nreplace if_let_chain with if_chain", "tree": {"sha": "f451dfbc24809772a350d53e77eaab1708ac346d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f451dfbc24809772a350d53e77eaab1708ac346d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "html_url": "https://github.com/rust-lang/rust/commit/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2771378620d6350e9a9ef62735690f854d780c31", "url": "https://api.github.com/repos/rust-lang/rust/commits/2771378620d6350e9a9ef62735690f854d780c31", "html_url": "https://github.com/rust-lang/rust/commit/2771378620d6350e9a9ef62735690f854d780c31"}, {"sha": "24a2c14733604132135b2ab598e7a1cf95d8b3ab", "url": "https://api.github.com/repos/rust-lang/rust/commits/24a2c14733604132135b2ab598e7a1cf95d8b3ab", "html_url": "https://github.com/rust-lang/rust/commit/24a2c14733604132135b2ab598e7a1cf95d8b3ab"}], "stats": {"total": 3812, "additions": 1929, "deletions": 1883}, "files": [{"sha": "2dcac941c09ffebeaf5ea6ee776e8c2c6689bced", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -28,6 +28,7 @@ toml = \"0.4\"\n unicode-normalization = \"0.1\"\n pulldown-cmark = \"0.0.15\"\n url = \"1.5.0\"\n+if_chain = \"0.1\"\n \n [features]\n debugging = []"}, {"sha": "ab9ba4a9327b0651f6767b9486e4b5d3377e4a2a", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -140,12 +140,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n                                         let parent_fn = cx.tcx.hir.get_parent(e.id);\n                                         let parent_impl = cx.tcx.hir.get_parent(parent_fn);\n                                         // the crate node is the only one that is not in the map\n-                                        if_let_chain!{[\n-                                            parent_impl != ast::CRATE_NODE_ID,\n-                                            let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl),\n-                                            let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node,\n-                                            trait_ref.path.def.def_id() == trait_id\n-                                        ], { return; }}\n+                                        if_chain! {\n+                                            if parent_impl != ast::CRATE_NODE_ID;\n+                                            if let hir::map::Node::NodeItem(item) = cx.tcx.hir.get(parent_impl);\n+                                            if let hir::Item_::ItemImpl(_, _, _, _, Some(ref trait_ref), _, _) = item.node;\n+                                            if trait_ref.path.def.def_id() == trait_id;\n+                                            then { return; }\n+                                        }\n                                         implements_trait($cx, $ty, trait_id, &[$rty])\n                                     },)*\n                                     _ => false,"}, {"sha": "8baff55191046ffb13ec9d11e70c7ed77f02f582", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -94,13 +94,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n                 return;\n             }\n             for item in items {\n-                if_let_chain! {[\n-                    let NestedMetaItemKind::MetaItem(ref mi) = item.node,\n-                    let MetaItemKind::NameValue(ref lit) = mi.node,\n-                    mi.name() == \"since\",\n-                ], {\n-                    check_semver(cx, item.span, lit);\n-                }}\n+                if_chain! {\n+                    if let NestedMetaItemKind::MetaItem(ref mi) = item.node;\n+                    if let MetaItemKind::NameValue(ref lit) = mi.node;\n+                    if mi.name() == \"since\";\n+                    then {\n+                        check_semver(cx, item.span, lit);\n+                    }\n+                }\n             }\n         }\n     }"}, {"sha": "f0ff27d4d63788428a2573982c84f76655eeb13c", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -119,27 +119,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n                 }\n             }\n         }\n-        if_let_chain!{[\n-            let Expr_::ExprBinary(ref op, ref left, ref right) = e.node,\n-            BinOp_::BiEq == op.node,\n-            let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node,\n-            BinOp_::BiBitAnd == op1.node,\n-            let Expr_::ExprLit(ref lit) = right1.node,\n-            let LitKind::Int(n, _) = lit.node,\n-            let Expr_::ExprLit(ref lit1) = right.node,\n-            let LitKind::Int(0, _) = lit1.node,\n-            n.leading_zeros() == n.count_zeros(),\n-            n > u128::from(self.verbose_bit_mask_threshold),\n-        ], {\n-            span_lint_and_then(cx,\n-                               VERBOSE_BIT_MASK,\n-                               e.span,\n-                               \"bit mask could be simplified with a call to `trailing_zeros`\",\n-                               |db| {\n-                let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n-                db.span_suggestion(e.span, \"try\", format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()));\n-            });\n-        }}\n+        if_chain! {\n+            if let Expr_::ExprBinary(ref op, ref left, ref right) = e.node;\n+            if BinOp_::BiEq == op.node;\n+            if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n+            if BinOp_::BiBitAnd == op1.node;\n+            if let Expr_::ExprLit(ref lit) = right1.node;\n+            if let LitKind::Int(n, _) = lit.node;\n+            if let Expr_::ExprLit(ref lit1) = right.node;\n+            if let LitKind::Int(0, _) = lit1.node;\n+            if n.leading_zeros() == n.count_zeros();\n+            if n > u128::from(self.verbose_bit_mask_threshold);\n+            then {\n+                span_lint_and_then(cx,\n+                                   VERBOSE_BIT_MASK,\n+                                   e.span,\n+                                   \"bit mask could be simplified with a call to `trailing_zeros`\",\n+                                   |db| {\n+                    let sugg = Sugg::hir(cx, left1, \"...\").maybe_par();\n+                    db.span_suggestion(e.span, \"try\", format!(\"{}.trailing_zeros() >= {}\", sugg, n.count_ones()));\n+                });\n+            }\n+        }\n     }\n }\n "}, {"sha": "e0ce4bbc93bfdca5ca37e69f6d2716e596ceeef0", "filename": "clippy_lints/src/bytecount.rs", "status": "modified", "additions": 50, "deletions": 48, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fbytecount.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fbytecount.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbytecount.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -37,56 +37,58 @@ impl LintPass for ByteCount {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ByteCount {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if_let_chain!([\n-            let ExprMethodCall(ref count, _, ref count_args) = expr.node,\n-            count.name == \"count\",\n-            count_args.len() == 1,\n-            let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node,\n-            filter.name == \"filter\",\n-            filter_args.len() == 2,\n-            let ExprClosure(_, _, body_id, _, _) = filter_args[1].node,\n-        ], {\n-            let body = cx.tcx.hir.body(body_id);\n-            if_let_chain!([\n-                body.arguments.len() == 1,\n-                let Some(argname) = get_pat_name(&body.arguments[0].pat),\n-                let ExprBinary(ref op, ref l, ref r) = body.value.node,\n-                op.node == BiEq,\n-                match_type(cx,\n-                           walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n-                           &paths::SLICE_ITER),\n-            ], {\n-                let needle = match get_path_name(l) {\n-                    Some(name) if check_arg(name, argname, r) => r,\n-                    _ => match get_path_name(r) {\n-                        Some(name) if check_arg(name, argname, l) => l,\n-                        _ => { return; }\n+        if_chain! {\n+            if let ExprMethodCall(ref count, _, ref count_args) = expr.node;\n+            if count.name == \"count\";\n+            if count_args.len() == 1;\n+            if let ExprMethodCall(ref filter, _, ref filter_args) = count_args[0].node;\n+            if filter.name == \"filter\";\n+            if filter_args.len() == 2;\n+            if let ExprClosure(_, _, body_id, _, _) = filter_args[1].node;\n+            then {\n+                let body = cx.tcx.hir.body(body_id);\n+                if_chain! {\n+                    if body.arguments.len() == 1;\n+                    if let Some(argname) = get_pat_name(&body.arguments[0].pat);\n+                    if let ExprBinary(ref op, ref l, ref r) = body.value.node;\n+                    if op.node == BiEq;\n+                    if match_type(cx,\n+                               walk_ptrs_ty(cx.tables.expr_ty(&filter_args[0])),\n+                               &paths::SLICE_ITER);\n+                    then {\n+                        let needle = match get_path_name(l) {\n+                            Some(name) if check_arg(name, argname, r) => r,\n+                            _ => match get_path_name(r) {\n+                                Some(name) if check_arg(name, argname, l) => l,\n+                                _ => { return; }\n+                            }\n+                        };\n+                        if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n+                            return;\n+                        }\n+                        let haystack = if let ExprMethodCall(ref path, _, ref args) =\n+                                filter_args[0].node {\n+                            let p = path.name;\n+                            if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n+                                &args[0]\n+                            } else {\n+                                &filter_args[0]\n+                            }\n+                        } else {\n+                            &filter_args[0]\n+                        };\n+                        span_lint_and_sugg(cx,\n+                                           NAIVE_BYTECOUNT,\n+                                           expr.span,\n+                                           \"You appear to be counting bytes the naive way\",\n+                                           \"Consider using the bytecount crate\",\n+                                           format!(\"bytecount::count({}, {})\",\n+                                                    snippet(cx, haystack.span, \"..\"),\n+                                                    snippet(cx, needle.span, \"..\")));\n                     }\n                 };\n-                if ty::TyUint(UintTy::U8) != walk_ptrs_ty(cx.tables.expr_ty(needle)).sty {\n-                    return;\n-                }\n-                let haystack = if let ExprMethodCall(ref path, _, ref args) =\n-                        filter_args[0].node {\n-                    let p = path.name;\n-                    if (p == \"iter\" || p == \"iter_mut\") && args.len() == 1 {\n-                        &args[0]\n-                    } else {\n-                        &filter_args[0]\n-                    }\n-                } else {\n-                    &filter_args[0]\n-                };\n-                span_lint_and_sugg(cx,\n-                                   NAIVE_BYTECOUNT,\n-                                   expr.span,\n-                                   \"You appear to be counting bytes the naive way\",\n-                                   \"Consider using the bytecount crate\",\n-                                   format!(\"bytecount::count({}, {})\",\n-                                            snippet(cx, haystack.span, \"..\"),\n-                                            snippet(cx, needle.span, \"..\")));\n-            });\n-        });\n+            }\n+        };\n     }\n }\n "}, {"sha": "3ac19980a6d3d20b7e40ea0f993d40220b374a9c", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 33, "deletions": 31, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -100,43 +100,45 @@ fn check_if(cx: &EarlyContext, expr: &ast::Expr) {\n }\n \n fn check_collapsible_maybe_if_let(cx: &EarlyContext, else_: &ast::Expr) {\n-    if_let_chain! {[\n-        let ast::ExprKind::Block(ref block) = else_.node,\n-        let Some(else_) = expr_block(block),\n-        !in_macro(else_.span),\n-    ], {\n-        match else_.node {\n-            ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n-                span_lint_and_sugg(cx,\n-                                   COLLAPSIBLE_IF,\n-                                   block.span,\n-                                   \"this `else { if .. }` block can be collapsed\",\n-                                   \"try\",\n-                                   snippet_block(cx, else_.span, \"..\").into_owned());\n+    if_chain! {\n+        if let ast::ExprKind::Block(ref block) = else_.node;\n+        if let Some(else_) = expr_block(block);\n+        if !in_macro(else_.span);\n+        then {\n+            match else_.node {\n+                ast::ExprKind::If(..) | ast::ExprKind::IfLet(..) => {\n+                    span_lint_and_sugg(cx,\n+                                       COLLAPSIBLE_IF,\n+                                       block.span,\n+                                       \"this `else { if .. }` block can be collapsed\",\n+                                       \"try\",\n+                                       snippet_block(cx, else_.span, \"..\").into_owned());\n+                }\n+                _ => (),\n             }\n-            _ => (),\n         }\n-    }}\n+    }\n }\n \n fn check_collapsible_no_if_let(cx: &EarlyContext, expr: &ast::Expr, check: &ast::Expr, then: &ast::Block) {\n-    if_let_chain! {[\n-        let Some(inner) = expr_block(then),\n-        let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node,\n-    ], {\n-        if expr.span.ctxt() != inner.span.ctxt() {\n-            return;\n+    if_chain! {\n+        if let Some(inner) = expr_block(then);\n+        if let ast::ExprKind::If(ref check_inner, ref content, None) = inner.node;\n+        then {\n+            if expr.span.ctxt() != inner.span.ctxt() {\n+                return;\n+            }\n+            span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this if statement can be collapsed\", |db| {\n+                let lhs = Sugg::ast(cx, check, \"..\");\n+                let rhs = Sugg::ast(cx, check_inner, \"..\");\n+                db.span_suggestion(expr.span,\n+                                   \"try\",\n+                                   format!(\"if {} {}\",\n+                                           lhs.and(rhs),\n+                                           snippet_block(cx, content.span, \"..\")));\n+            });\n         }\n-        span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this if statement can be collapsed\", |db| {\n-            let lhs = Sugg::ast(cx, check, \"..\");\n-            let rhs = Sugg::ast(cx, check_inner, \"..\");\n-            db.span_suggestion(expr.span,\n-                               \"try\",\n-                               format!(\"if {} {}\",\n-                                       lhs.and(rhs),\n-                                       snippet_block(cx, content.span, \"..\")));\n-        });\n-    }}\n+    }\n }\n \n /// If the block contains only one expression, return it."}, {"sha": "2c45aaf6ac935402639fcf929432ca77560dcb64", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 38, "deletions": 37, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -91,43 +91,44 @@ fn check_hash_peq<'a, 'tcx>(\n     ty: Ty<'tcx>,\n     hash_is_automatically_derived: bool,\n ) {\n-    if_let_chain! {[\n-        match_path(&trait_ref.path, &paths::HASH),\n-        let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait()\n-    ], {\n-        // Look for the PartialEq implementations for `ty`\n-        cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n-            let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n-\n-            if peq_is_automatically_derived == hash_is_automatically_derived {\n-                return;\n-            }\n-\n-            let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n-\n-            // Only care about `impl PartialEq<Foo> for Foo`\n-            // For `impl PartialEq<B> for A, input_types is [A, B]\n-            if trait_ref.substs.type_at(1) == ty {\n-                let mess = if peq_is_automatically_derived {\n-                    \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n-                } else {\n-                    \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n-                };\n-\n-                span_lint_and_then(\n-                    cx, DERIVE_HASH_XOR_EQ, span,\n-                    mess,\n-                    |db| {\n-                    if let Some(node_id) = cx.tcx.hir.as_local_node_id(impl_id) {\n-                        db.span_note(\n-                            cx.tcx.hir.span(node_id),\n-                            \"`PartialEq` implemented here\"\n-                        );\n-                    }\n-                });\n-            }\n-        });\n-    }}\n+    if_chain! {\n+        if match_path(&trait_ref.path, &paths::HASH);\n+        if let Some(peq_trait_def_id) = cx.tcx.lang_items().eq_trait();\n+        then {\n+            // Look for the PartialEq implementations for `ty`\n+            cx.tcx.for_each_relevant_impl(peq_trait_def_id, ty, |impl_id| {\n+                let peq_is_automatically_derived = is_automatically_derived(&cx.tcx.get_attrs(impl_id));\n+    \n+                if peq_is_automatically_derived == hash_is_automatically_derived {\n+                    return;\n+                }\n+    \n+                let trait_ref = cx.tcx.impl_trait_ref(impl_id).expect(\"must be a trait implementation\");\n+    \n+                // Only care about `impl PartialEq<Foo> for Foo`\n+                // For `impl PartialEq<B> for A, input_types is [A, B]\n+                if trait_ref.substs.type_at(1) == ty {\n+                    let mess = if peq_is_automatically_derived {\n+                        \"you are implementing `Hash` explicitly but have derived `PartialEq`\"\n+                    } else {\n+                        \"you are deriving `Hash` but have implemented `PartialEq` explicitly\"\n+                    };\n+    \n+                    span_lint_and_then(\n+                        cx, DERIVE_HASH_XOR_EQ, span,\n+                        mess,\n+                        |db| {\n+                        if let Some(node_id) = cx.tcx.hir.as_local_node_id(impl_id) {\n+                            db.span_note(\n+                                cx.tcx.hir.span(node_id),\n+                                \"`PartialEq` implemented here\"\n+                            );\n+                        }\n+                    });\n+                }\n+            });\n+        }\n+    }\n }\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint."}, {"sha": "1601c276e2b255dc65909c4a7f8e71098d6ea3aa", "filename": "clippy_lints/src/drop_forget_ref.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_forget_ref.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -115,50 +115,51 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain!{[\n-            let ExprCall(ref path, ref args) = expr.node,\n-            let ExprPath(ref qpath) = path.node,\n-            args.len() == 1,\n-            let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)),\n-        ], {\n-            let lint;\n-            let msg;\n-            let arg = &args[0];\n-            let arg_ty = cx.tables.expr_ty(arg);\n-\n-            if let ty::TyRef(..) = arg_ty.sty {\n-                if match_def_path(cx.tcx, def_id, &paths::DROP) {\n-                    lint = DROP_REF;\n-                    msg = DROP_REF_SUMMARY.to_string();\n-                } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n-                    lint = FORGET_REF;\n-                    msg = FORGET_REF_SUMMARY.to_string();\n-                } else {\n-                    return;\n-                }\n-                span_note_and_lint(cx,\n-                                   lint,\n-                                   expr.span,\n-                                   &msg,\n-                                   arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty));\n-            } else if is_copy(cx, arg_ty) {\n-                if match_def_path(cx.tcx, def_id, &paths::DROP) {\n-                    lint = DROP_COPY;\n-                    msg = DROP_COPY_SUMMARY.to_string();\n-                } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n-                    lint = FORGET_COPY;\n-                    msg = FORGET_COPY_SUMMARY.to_string();\n-                } else {\n-                    return;\n+        if_chain! {\n+            if let ExprCall(ref path, ref args) = expr.node;\n+            if let ExprPath(ref qpath) = path.node;\n+            if args.len() == 1;\n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            then {\n+                let lint;\n+                let msg;\n+                let arg = &args[0];\n+                let arg_ty = cx.tables.expr_ty(arg);\n+    \n+                if let ty::TyRef(..) = arg_ty.sty {\n+                    if match_def_path(cx.tcx, def_id, &paths::DROP) {\n+                        lint = DROP_REF;\n+                        msg = DROP_REF_SUMMARY.to_string();\n+                    } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                        lint = FORGET_REF;\n+                        msg = FORGET_REF_SUMMARY.to_string();\n+                    } else {\n+                        return;\n+                    }\n+                    span_note_and_lint(cx,\n+                                       lint,\n+                                       expr.span,\n+                                       &msg,\n+                                       arg.span,\n+                                       &format!(\"argument has type {}\", arg_ty));\n+                } else if is_copy(cx, arg_ty) {\n+                    if match_def_path(cx.tcx, def_id, &paths::DROP) {\n+                        lint = DROP_COPY;\n+                        msg = DROP_COPY_SUMMARY.to_string();\n+                    } else if match_def_path(cx.tcx, def_id, &paths::MEM_FORGET) {\n+                        lint = FORGET_COPY;\n+                        msg = FORGET_COPY_SUMMARY.to_string();\n+                    } else {\n+                        return;\n+                    }\n+                    span_note_and_lint(cx,\n+                                       lint,\n+                                       expr.span,\n+                                       &msg,\n+                                       arg.span,\n+                                       &format!(\"argument has type {}\", arg_ty));\n                 }\n-                span_note_and_lint(cx,\n-                                   lint,\n-                                   expr.span,\n-                                   &msg,\n-                                   arg.span,\n-                                   &format!(\"argument has type {}\", arg_ty));\n             }\n-        }}\n+        }\n     }\n }"}, {"sha": "6c7a5fec03c9aa8d032a0ac1f46ac8e727a0abb0", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 46, "deletions": 44, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -87,25 +87,26 @@ fn check_cond<'a, 'tcx, 'b>(\n     cx: &'a LateContext<'a, 'tcx>,\n     check: &'b Expr,\n ) -> Option<(&'static str, &'b Expr, &'b Expr)> {\n-    if_let_chain! {[\n-        let ExprMethodCall(ref path, _, ref params) = check.node,\n-        params.len() >= 2,\n-        path.name == \"contains_key\",\n-        let ExprAddrOf(_, ref key) = params[1].node\n-    ], {\n-        let map = &params[0];\n-        let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n-\n-        return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n-            Some((\"BTreeMap\", map, key))\n-        }\n-        else if match_type(cx, obj_ty, &paths::HASHMAP) {\n-            Some((\"HashMap\", map, key))\n+    if_chain! {\n+        if let ExprMethodCall(ref path, _, ref params) = check.node;\n+        if params.len() >= 2;\n+        if path.name == \"contains_key\";\n+        if let ExprAddrOf(_, ref key) = params[1].node;\n+        then {\n+            let map = &params[0];\n+            let obj_ty = walk_ptrs_ty(cx.tables.expr_ty(map));\n+    \n+            return if match_type(cx, obj_ty, &paths::BTREEMAP) {\n+                Some((\"BTreeMap\", map, key))\n+            }\n+            else if match_type(cx, obj_ty, &paths::HASHMAP) {\n+                Some((\"HashMap\", map, key))\n+            }\n+            else {\n+                None\n+            };\n         }\n-        else {\n-            None\n-        };\n-    }}\n+    }\n \n     None\n }\n@@ -121,32 +122,33 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n \n impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if_let_chain! {[\n-            let ExprMethodCall(ref path, _, ref params) = expr.node,\n-            params.len() == 3,\n-            path.name == \"insert\",\n-            get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]),\n-            SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n-        ], {\n-            span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n-                               &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |db| {\n-                if self.sole_expr {\n-                    let help = format!(\"{}.entry({}).or_insert({})\",\n-                                       snippet(self.cx, self.map.span, \"map\"),\n-                                       snippet(self.cx, params[1].span, \"..\"),\n-                                       snippet(self.cx, params[2].span, \"..\"));\n-\n-                    db.span_suggestion(self.span, \"consider using\", help);\n-                }\n-                else {\n-                    let help = format!(\"{}.entry({})\",\n-                                       snippet(self.cx, self.map.span, \"map\"),\n-                                       snippet(self.cx, params[1].span, \"..\"));\n-\n-                    db.span_suggestion(self.span, \"consider using\", help);\n-                }\n-            });\n-        }}\n+        if_chain! {\n+            if let ExprMethodCall(ref path, _, ref params) = expr.node;\n+            if params.len() == 3;\n+            if path.name == \"insert\";\n+            if get_item_name(self.cx, self.map) == get_item_name(self.cx, &params[0]);\n+            if SpanlessEq::new(self.cx).eq_expr(self.key, &params[1]);\n+            then {\n+                span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n+                                   &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |db| {\n+                    if self.sole_expr {\n+                        let help = format!(\"{}.entry({}).or_insert({})\",\n+                                           snippet(self.cx, self.map.span, \"map\"),\n+                                           snippet(self.cx, params[1].span, \"..\"),\n+                                           snippet(self.cx, params[2].span, \"..\"));\n+    \n+                        db.span_suggestion(self.span, \"consider using\", help);\n+                    }\n+                    else {\n+                        let help = format!(\"{}.entry({})\",\n+                                           snippet(self.cx, self.map.span, \"map\"),\n+                                           snippet(self.cx, params[1].span, \"..\"));\n+    \n+                        db.span_suggestion(self.span, \"consider using\", help);\n+                    }\n+                });\n+            }\n+        }\n \n         if !self.sole_expr {\n             walk_expr(self, expr);"}, {"sha": "847aec41500283afd2f8b7dfac9a5cf14f7e781d", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -298,23 +298,24 @@ impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n \n         match expr.node {\n             ExprPath(ref qpath) => {\n-                if_let_chain! {[\n-                    let QPath::Resolved(None, ref path) = *qpath,\n-                    path.segments.len() == 1,\n-                    let def::Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n-                    local_id == self.var,\n+                if_chain! {\n+                    if let QPath::Resolved(None, ref path) = *qpath;\n+                    if path.segments.len() == 1;\n+                    if let def::Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n+                    if local_id == self.var;\n                     // Check that this is a read, not a write.\n-                    !is_in_assignment_position(self.cx, expr),\n-                ], {\n-                    span_note_and_lint(\n-                        self.cx,\n-                        EVAL_ORDER_DEPENDENCE,\n-                        expr.span,\n-                        \"unsequenced read of a variable\",\n-                        self.write_expr.span,\n-                        \"whether read occurs before this write depends on evaluation order\"\n-                    );\n-                }}\n+                    if !is_in_assignment_position(self.cx, expr);\n+                    then {\n+                        span_note_and_lint(\n+                            self.cx,\n+                            EVAL_ORDER_DEPENDENCE,\n+                            expr.span,\n+                            \"unsequenced read of a variable\",\n+                            self.write_expr.span,\n+                            \"whether read occurs before this write depends on evaluation order\"\n+                        );\n+                    }\n+                }\n             }\n             // We're about to descend a closure. Since we don't know when (or\n             // if) the closure will be evaluated, any reads in it might not"}, {"sha": "7ea96cabfac8a2b636a2b535fc5f6f9aad0a56d6", "filename": "clippy_lints/src/explicit_write.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fexplicit_write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fexplicit_write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fexplicit_write.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -33,69 +33,70 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain! {[\n+        if_chain! {\n             // match call to unwrap\n-            let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node,\n-            unwrap_fun.name == \"unwrap\",\n+            if let ExprMethodCall(ref unwrap_fun, _, ref unwrap_args) = expr.node;\n+            if unwrap_fun.name == \"unwrap\";\n             // match call to write_fmt\n-            unwrap_args.len() > 0,\n-            let ExprMethodCall(ref write_fun, _, ref write_args) =\n-                unwrap_args[0].node,\n-            write_fun.name == \"write_fmt\",\n+            if unwrap_args.len() > 0;\n+            if let ExprMethodCall(ref write_fun, _, ref write_args) =\n+                unwrap_args[0].node;\n+            if write_fun.name == \"write_fmt\";\n             // match calls to std::io::stdout() / std::io::stderr ()\n-            write_args.len() > 0,\n-            let ExprCall(ref dest_fun, _) = write_args[0].node,\n-            let ExprPath(ref qpath) = dest_fun.node,\n-            let Some(dest_fun_id) =\n-                opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id)),\n-            let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {\n+            if write_args.len() > 0;\n+            if let ExprCall(ref dest_fun, _) = write_args[0].node;\n+            if let ExprPath(ref qpath) = dest_fun.node;\n+            if let Some(dest_fun_id) =\n+                opt_def_id(resolve_node(cx, qpath, dest_fun.hir_id));\n+            if let Some(dest_name) = if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stdout\"]) {\n                 Some(\"stdout\")\n             } else if match_def_path(cx.tcx, dest_fun_id, &[\"std\", \"io\", \"stdio\", \"stderr\"]) {\n                 Some(\"stderr\")\n             } else {\n                 None\n-            },\n-        ], {\n-            let write_span = unwrap_args[0].span;\n-            let calling_macro =\n-                // ordering is important here, since `writeln!` uses `write!` internally\n-                if is_expn_of(write_span, \"writeln\").is_some() {\n-                    Some(\"writeln\")\n-                } else if is_expn_of(write_span, \"write\").is_some() {\n-                    Some(\"write\")\n+            };\n+            then {\n+                let write_span = unwrap_args[0].span;\n+                let calling_macro =\n+                    // ordering is important here, since `writeln!` uses `write!` internally\n+                    if is_expn_of(write_span, \"writeln\").is_some() {\n+                        Some(\"writeln\")\n+                    } else if is_expn_of(write_span, \"write\").is_some() {\n+                        Some(\"write\")\n+                    } else {\n+                        None\n+                    };\n+                let prefix = if dest_name == \"stderr\" {\n+                    \"e\"\n                 } else {\n-                    None\n+                    \"\"\n                 };\n-            let prefix = if dest_name == \"stderr\" {\n-                \"e\"\n-            } else {\n-                \"\"\n-            };\n-            if let Some(macro_name) = calling_macro {\n-                span_lint(\n-                    cx,\n-                    EXPLICIT_WRITE,\n-                    expr.span,\n-                    &format!(\n-                        \"use of `{}!({}(), ...).unwrap()`. Consider using `{}{}!` instead\",\n-                        macro_name,\n-                        dest_name,\n-                        prefix,\n-                        macro_name.replace(\"write\", \"print\")\n-                    )\n-                );\n-            } else {\n-                span_lint(\n-                    cx,\n-                    EXPLICIT_WRITE,\n-                    expr.span,\n-                    &format!(\n-                        \"use of `{}().write_fmt(...).unwrap()`. Consider using `{}print!` instead\",\n-                        dest_name,\n-                        prefix,\n-                    )\n-                );\n+                if let Some(macro_name) = calling_macro {\n+                    span_lint(\n+                        cx,\n+                        EXPLICIT_WRITE,\n+                        expr.span,\n+                        &format!(\n+                            \"use of `{}!({}(), ...).unwrap()`. Consider using `{}{}!` instead\",\n+                            macro_name,\n+                            dest_name,\n+                            prefix,\n+                            macro_name.replace(\"write\", \"print\")\n+                        )\n+                    );\n+                } else {\n+                    span_lint(\n+                        cx,\n+                        EXPLICIT_WRITE,\n+                        expr.span,\n+                        &format!(\n+                            \"use of `{}().write_fmt(...).unwrap()`. Consider using `{}print!` instead\",\n+                            dest_name,\n+                            prefix,\n+                        )\n+                    );\n+                }\n             }\n-        }}\n+        }\n     }\n }"}, {"sha": "e6efd41e6fb9ec94823c9139418cd4f529ef5360", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -37,13 +37,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         // check for `impl From<???> for ..`\n         let impl_def_id = cx.tcx.hir.local_def_id(item.id);\n-        if_let_chain!{[\n-            let hir::ItemImpl(.., ref impl_items) = item.node,\n-            let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id),\n-            match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT),\n-        ], {\n-            lint_impl_body(cx, item.span, impl_items);\n-        }}\n+        if_chain! {\n+            if let hir::ItemImpl(.., ref impl_items) = item.node;\n+            if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n+            if match_def_path(cx.tcx, impl_trait_ref.def_id, &FROM_TRAIT);\n+            then {\n+                lint_impl_body(cx, item.span, impl_items);\n+            }\n+        }\n     }\n }\n \n@@ -60,14 +61,15 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     impl<'a, 'tcx: 'a> Visitor<'tcx> for FindPanicUnwrap<'a, 'tcx> {\n         fn visit_expr(&mut self, expr: &'tcx Expr) {\n             // check for `begin_panic`\n-            if_let_chain!{[\n-                let ExprCall(ref func_expr, _) = expr.node,\n-                let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node,\n-                match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC) ||\n-                    match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC_FMT),\n-            ], {\n-                self.result.push(expr.span);\n-            }}\n+            if_chain! {\n+                if let ExprCall(ref func_expr, _) = expr.node;\n+                if let ExprPath(QPath::Resolved(_, ref path)) = func_expr.node;\n+                if match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC) ||\n+                    match_def_path(self.tcx, path.def.def_id(), &BEGIN_PANIC_FMT);\n+                then {\n+                    self.result.push(expr.span);\n+                }\n+            }\n \n             // check for `unwrap`\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n@@ -89,36 +91,37 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n     }\n \n     for impl_item in impl_items {\n-        if_let_chain!{[\n-            impl_item.name == \"from\",\n-            let ImplItemKind::Method(_, body_id) =\n-                cx.tcx.hir.impl_item(impl_item.id).node,\n-        ], {\n-            // check the body for `begin_panic` or `unwrap`\n-            let body = cx.tcx.hir.body(body_id);\n-            let impl_item_def_id = cx.tcx.hir.local_def_id(impl_item.id.node_id);\n-            let mut fpu = FindPanicUnwrap {\n-                tcx: cx.tcx,\n-                tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n-                result: Vec::new(),\n-            };\n-            fpu.visit_expr(&body.value);\n-\n-            // if we've found one, lint\n-            if !fpu.result.is_empty() {\n-                span_lint_and_then(\n-                    cx,\n-                    FALLIBLE_IMPL_FROM,\n-                    impl_span,\n-                    \"consider implementing `TryFrom` instead\",\n-                    move |db| {\n-                        db.help(\n-                            \"`From` is intended for infallible conversions only. \\\n-                             Use `TryFrom` if there's a possibility for the conversion to fail.\");\n-                        db.span_note(fpu.result, \"potential failure(s)\");\n-                    });\n+        if_chain! {\n+            if impl_item.name == \"from\";\n+            if let ImplItemKind::Method(_, body_id) =\n+                cx.tcx.hir.impl_item(impl_item.id).node;\n+            then {\n+                // check the body for `begin_panic` or `unwrap`\n+                let body = cx.tcx.hir.body(body_id);\n+                let impl_item_def_id = cx.tcx.hir.local_def_id(impl_item.id.node_id);\n+                let mut fpu = FindPanicUnwrap {\n+                    tcx: cx.tcx,\n+                    tables: cx.tcx.typeck_tables_of(impl_item_def_id),\n+                    result: Vec::new(),\n+                };\n+                fpu.visit_expr(&body.value);\n+    \n+                // if we've found one, lint\n+                if !fpu.result.is_empty() {\n+                    span_lint_and_then(\n+                        cx,\n+                        FALLIBLE_IMPL_FROM,\n+                        impl_span,\n+                        \"consider implementing `TryFrom` instead\",\n+                        move |db| {\n+                            db.help(\n+                                \"`From` is intended for infallible conversions only. \\\n+                                 Use `TryFrom` if there's a possibility for the conversion to fail.\");\n+                            db.span_note(fpu.result, \"potential failure(s)\");\n+                        });\n+                }\n             }\n-        }}\n+        }\n     }\n }\n "}, {"sha": "8004dc1708355365410a6169fc9c63fd6d7a7cfd", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 41, "deletions": 38, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -42,19 +42,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             match expr.node {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n-                    if_let_chain!{[\n-                        let ExprPath(ref qpath) = fun.node,\n-                        args.len() == 2,\n-                        let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n-                        match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1),\n+                    if_chain! {\n+                        if let ExprPath(ref qpath) = fun.node;\n+                        if args.len() == 2;\n+                        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+                        if match_def_path(cx.tcx, fun_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n-                        check_static_str(&args[0]),\n+                        if check_static_str(&args[0]);\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n                         // and that the argument is a string\n-                        check_arg_is_display(cx, &args[1])\n-                    ], {\n-                        span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n-                    }}\n+                        if check_arg_is_display(cx, &args[1]);\n+                        then {\n+                            span_lint(cx, USELESS_FORMAT, span, \"useless use of `format!`\");\n+                        }\n+                    }\n                 },\n                 // `format!(\"foo\")` expansion contains `match () { () => [], }`\n                 ExprMatch(ref matchee, _, _) => if let ExprTup(ref tup) = matchee.node {\n@@ -70,15 +71,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n /// Checks if the expressions matches `&[\"\"]`\n fn check_static_str(expr: &Expr) -> bool {\n-    if_let_chain! {[\n-        let ExprAddrOf(_, ref expr) = expr.node, // &[\"\"]\n-        let ExprArray(ref exprs) = expr.node, // [\"\"]\n-        exprs.len() == 1,\n-        let ExprLit(ref lit) = exprs[0].node,\n-        let LitKind::Str(ref lit, _) = lit.node,\n-    ], {\n-        return lit.as_str().is_empty();\n-    }}\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\"]\n+        if let ExprArray(ref exprs) = expr.node; // [\"\"]\n+        if exprs.len() == 1;\n+        if let ExprLit(ref lit) = exprs[0].node;\n+        if let LitKind::Str(ref lit, _) = lit.node;\n+        then {\n+            return lit.as_str().is_empty();\n+        }\n+    }\n \n     false\n }\n@@ -91,25 +93,26 @@ fn check_static_str(expr: &Expr) -> bool {\n /// }\n /// ```\n fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n-    if_let_chain! {[\n-        let ExprAddrOf(_, ref expr) = expr.node,\n-        let ExprMatch(_, ref arms, _) = expr.node,\n-        arms.len() == 1,\n-        arms[0].pats.len() == 1,\n-        let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node,\n-        pat.len() == 1,\n-        let ExprArray(ref exprs) = arms[0].body.node,\n-        exprs.len() == 1,\n-        let ExprCall(_, ref args) = exprs[0].node,\n-        args.len() == 2,\n-        let ExprPath(ref qpath) = args[1].node,\n-        let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id)),\n-        match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD),\n-    ], {\n-        let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n-\n-        return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n-    }}\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node;\n+        if let ExprMatch(_, ref arms, _) = expr.node;\n+        if arms.len() == 1;\n+        if arms[0].pats.len() == 1;\n+        if let PatKind::Tuple(ref pat, None) = arms[0].pats[0].node;\n+        if pat.len() == 1;\n+        if let ExprArray(ref exprs) = arms[0].body.node;\n+        if exprs.len() == 1;\n+        if let ExprCall(_, ref args) = exprs[0].node;\n+        if args.len() == 2;\n+        if let ExprPath(ref qpath) = args[1].node;\n+        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, args[1].hir_id));\n+        if match_def_path(cx.tcx, fun_def_id, &paths::DISPLAY_FMT_METHOD);\n+        then {\n+            let ty = walk_ptrs_ty(cx.tables.pat_ty(&pat[0]));\n+    \n+            return ty.sty == ty::TyStr || match_type(cx, ty, &paths::STRING);\n+        }\n+    }\n \n     false\n }"}, {"sha": "649e1f7ac78b6987d6811f3bf23df58241f7e6de", "filename": "clippy_lints/src/invalid_ref.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Finvalid_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Finvalid_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Finvalid_ref.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -34,22 +34,23 @@ impl LintPass for InvalidRef {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidRef {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain!{[\n-            let ExprCall(ref path, ref args) = expr.node,\n-            let ExprPath(ref qpath) = path.node,\n-            args.len() == 0,\n-            let ty::TyRef(..) = cx.tables.expr_ty(expr).sty, \n-            let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id)),\n-        ], {\n-            let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) | match_def_path(cx.tcx, def_id, &paths::INIT) {\n-                ZERO_REF_SUMMARY\n-            } else if match_def_path(cx.tcx, def_id, &paths::MEM_UNINIT) | match_def_path(cx.tcx, def_id, &paths::UNINIT) {\n-                UNINIT_REF_SUMMARY\n-            } else {\n-                return;\n-            };\n-            span_help_and_lint(cx, INVALID_REF, expr.span, msg, HELP);\n-        }}        \n+        if_chain! {\n+            if let ExprCall(ref path, ref args) = expr.node;\n+            if let ExprPath(ref qpath) = path.node;\n+            if args.len() == 0;\n+            if let ty::TyRef(..) = cx.tables.expr_ty(expr).sty; \n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, path.hir_id));\n+            then {\n+                let msg = if match_def_path(cx.tcx, def_id, &paths::MEM_ZEROED) | match_def_path(cx.tcx, def_id, &paths::INIT) {\n+                    ZERO_REF_SUMMARY\n+                } else if match_def_path(cx.tcx, def_id, &paths::MEM_UNINIT) | match_def_path(cx.tcx, def_id, &paths::UNINIT) {\n+                    UNINIT_REF_SUMMARY\n+                } else {\n+                    return;\n+                };\n+                span_help_and_lint(cx, INVALID_REF, expr.span, msg, HELP);\n+            }\n+        }        \n         return;\n     }\n }"}, {"sha": "931b872e036acad226af9c51a2956053dcbad5ea", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 92, "deletions": 89, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -63,69 +63,70 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n     fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n-            if_let_chain! {[\n-                let Some(expr) = it.peek(),\n-                let hir::StmtDecl(ref decl, _) = stmt.node,\n-                let hir::DeclLocal(ref decl) = decl.node,\n-                let hir::PatKind::Binding(mode, canonical_id, ref name, None) = decl.pat.node,\n-                let hir::StmtExpr(ref if_, _) = expr.node,\n-                let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n-                !used_in_expr(cx, canonical_id, cond),\n-                let hir::ExprBlock(ref then) = then.node,\n-                let Some(value) = check_assign(cx, canonical_id, &*then),\n-                !used_in_expr(cx, canonical_id, value),\n-            ], {\n-                let span = stmt.span.to(if_.span);\n-\n-                let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n-                    if let hir::ExprBlock(ref else_) = else_.node {\n-                        if let Some(default) = check_assign(cx, canonical_id, else_) {\n-                            (else_.stmts.len() > 1, default)\n-                        } else if let Some(ref default) = decl.init {\n-                            (true, &**default)\n+            if_chain! {\n+                if let Some(expr) = it.peek();\n+                if let hir::StmtDecl(ref decl, _) = stmt.node;\n+                if let hir::DeclLocal(ref decl) = decl.node;\n+                if let hir::PatKind::Binding(mode, canonical_id, ref name, None) = decl.pat.node;\n+                if let hir::StmtExpr(ref if_, _) = expr.node;\n+                if let hir::ExprIf(ref cond, ref then, ref else_) = if_.node;\n+                if !used_in_expr(cx, canonical_id, cond);\n+                if let hir::ExprBlock(ref then) = then.node;\n+                if let Some(value) = check_assign(cx, canonical_id, &*then);\n+                if !used_in_expr(cx, canonical_id, value);\n+                then {\n+                    let span = stmt.span.to(if_.span);\n+    \n+                    let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n+                        if let hir::ExprBlock(ref else_) = else_.node {\n+                            if let Some(default) = check_assign(cx, canonical_id, else_) {\n+                                (else_.stmts.len() > 1, default)\n+                            } else if let Some(ref default) = decl.init {\n+                                (true, &**default)\n+                            } else {\n+                                continue;\n+                            }\n                         } else {\n                             continue;\n                         }\n+                    } else if let Some(ref default) = decl.init {\n+                        (false, &**default)\n                     } else {\n                         continue;\n-                    }\n-                } else if let Some(ref default) = decl.init {\n-                    (false, &**default)\n-                } else {\n-                    continue;\n-                };\n-\n-                let mutability = match mode {\n-                    BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n-                    _ => \"\",\n-                };\n-\n-                // FIXME: this should not suggest `mut` if we can detect that the variable is not\n-                // use mutably after the `if`\n-\n-                let sug = format!(\n-                    \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n-                    mut=mutability,\n-                    name=name.node,\n-                    cond=snippet(cx, cond.span, \"_\"),\n-                    then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },\n-                    else=if default_multi_stmts { \" ..;\" } else { \"\" },\n-                    value=snippet(cx, value.span, \"<value>\"),\n-                    default=snippet(cx, default.span, \"<default>\"),\n-                );\n-                span_lint_and_then(cx,\n-                                   USELESS_LET_IF_SEQ,\n-                                   span,\n-                                   \"`if _ { .. } else { .. }` is an expression\",\n-                                   |db| {\n-                                       db.span_suggestion(span,\n-                                                          \"it is more idiomatic to write\",\n-                                                          sug);\n-                                       if !mutability.is_empty() {\n-                                           db.note(\"you might not need `mut` at all\");\n-                                       }\n-                                   });\n-            }}\n+                    };\n+    \n+                    let mutability = match mode {\n+                        BindingAnnotation::RefMut | BindingAnnotation::Mutable => \"<mut> \",\n+                        _ => \"\",\n+                    };\n+    \n+                    // FIXME: this should not suggest `mut` if we can detect that the variable is not\n+                    // use mutably after the `if`\n+    \n+                    let sug = format!(\n+                        \"let {mut}{name} = if {cond} {{{then} {value} }} else {{{else} {default} }};\",\n+                        mut=mutability,\n+                        name=name.node,\n+                        cond=snippet(cx, cond.span, \"_\"),\n+                        then=if then.stmts.len() > 1 { \" ..;\" } else { \"\" },\n+                        else=if default_multi_stmts { \" ..;\" } else { \"\" },\n+                        value=snippet(cx, value.span, \"<value>\"),\n+                        default=snippet(cx, default.span, \"<default>\"),\n+                    );\n+                    span_lint_and_then(cx,\n+                                       USELESS_LET_IF_SEQ,\n+                                       span,\n+                                       \"`if _ { .. } else { .. }` is an expression\",\n+                                       |db| {\n+                                           db.span_suggestion(span,\n+                                                              \"it is more idiomatic to write\",\n+                                                              sug);\n+                                           if !mutability.is_empty() {\n+                                               db.note(\"you might not need `mut` at all\");\n+                                           }\n+                                       });\n+                }\n+            }\n         }\n     }\n }\n@@ -138,14 +139,15 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n-        if_let_chain! {[\n-            let hir::ExprPath(ref qpath) = expr.node,\n-            let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n-            self.id == local_id,\n-        ], {\n-            self.used = true;\n-            return;\n-        }}\n+        if_chain! {\n+            if let hir::ExprPath(ref qpath) = expr.node;\n+            if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n+            if self.id == local_id;\n+            then {\n+                self.used = true;\n+                return;\n+            }\n+        }\n         hir::intravisit::walk_expr(self, expr);\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> hir::intravisit::NestedVisitorMap<'this, 'tcx> {\n@@ -158,31 +160,32 @@ fn check_assign<'a, 'tcx>(\n     decl: ast::NodeId,\n     block: &'tcx hir::Block,\n ) -> Option<&'tcx hir::Expr> {\n-    if_let_chain! {[\n-        block.expr.is_none(),\n-        let Some(expr) = block.stmts.iter().last(),\n-        let hir::StmtSemi(ref expr, _) = expr.node,\n-        let hir::ExprAssign(ref var, ref value) = expr.node,\n-        let hir::ExprPath(ref qpath) = var.node,\n-        let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id),\n-        decl == local_id,\n-    ], {\n-        let mut v = UsedVisitor {\n-            cx: cx,\n-            id: decl,\n-            used: false,\n-        };\n-\n-        for s in block.stmts.iter().take(block.stmts.len()-1) {\n-            hir::intravisit::walk_stmt(&mut v, s);\n-\n-            if v.used {\n-                return None;\n+    if_chain! {\n+        if block.expr.is_none();\n+        if let Some(expr) = block.stmts.iter().last();\n+        if let hir::StmtSemi(ref expr, _) = expr.node;\n+        if let hir::ExprAssign(ref var, ref value) = expr.node;\n+        if let hir::ExprPath(ref qpath) = var.node;\n+        if let Def::Local(local_id) = cx.tables.qpath_def(qpath, var.hir_id);\n+        if decl == local_id;\n+        then {\n+            let mut v = UsedVisitor {\n+                cx: cx,\n+                id: decl,\n+                used: false,\n+            };\n+    \n+            for s in block.stmts.iter().take(block.stmts.len()-1) {\n+                hir::intravisit::walk_stmt(&mut v, s);\n+    \n+                if v.used {\n+                    return None;\n+                }\n             }\n+    \n+            return Some(value);\n         }\n-\n-        return Some(value);\n-    }}\n+    }\n \n     None\n }"}, {"sha": "1cd3479f11d7efafd8c1855f3e0dcb70643464db", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -11,6 +11,8 @@\n #![feature(inclusive_range_syntax, range_contains)]\n #![allow(unknown_lints, indexing_slicing, shadow_reuse, missing_docs_in_private_items)]\n \n+#![recursion_limit=\"256\"]\n+\n #[macro_use]\n extern crate rustc;\n extern crate rustc_typeck;\n@@ -54,6 +56,9 @@ extern crate itertools;\n extern crate pulldown_cmark;\n extern crate url;\n \n+#[macro_use]\n+extern crate if_chain;\n+\n macro_rules! declare_restriction_lint {\n     { pub $name:tt, $description:tt } => {\n         declare_lint! { pub $name, Allow, $description }"}, {"sha": "91e4c5674885e65914c2a05646ebdd5718b919a7", "filename": "clippy_lints/src/literal_digit_grouping.rs", "status": "modified", "additions": 52, "deletions": 50, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fliteral_digit_grouping.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -244,58 +244,60 @@ impl EarlyLintPass for LiteralDigitGrouping {\n impl LiteralDigitGrouping {\n     fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n         // Lint integral literals.\n-        if_let_chain! {[\n-            let LitKind::Int(..) = lit.node,\n-            let Some(src) = snippet_opt(cx, lit.span),\n-            let Some(firstch) = src.chars().next(),\n-            char::to_digit(firstch, 10).is_some()\n-        ], {\n-            let digit_info = DigitInfo::new(&src, false);\n-            let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n-                warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n-            });\n-        }}\n+        if_chain! {\n+            if let LitKind::Int(..) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(firstch) = src.chars().next();\n+            if char::to_digit(firstch, 10).is_some();\n+            then {\n+                let digit_info = DigitInfo::new(&src, false);\n+                let _ = Self::do_lint(digit_info.digits).map_err(|warning_type| {\n+                    warning_type.display(&digit_info.grouping_hint(), cx, &lit.span)\n+                });\n+            }\n+        }\n \n         // Lint floating-point literals.\n-        if_let_chain! {[\n-            let LitKind::Float(..) = lit.node,\n-            let Some(src) = snippet_opt(cx, lit.span),\n-            let Some(firstch) = src.chars().next(),\n-            char::to_digit(firstch, 10).is_some()\n-        ], {\n-            let digit_info = DigitInfo::new(&src, true);\n-            // Separate digits into integral and fractional parts.\n-            let parts: Vec<&str> = digit_info\n-                .digits\n-                .split_terminator('.')\n-                .collect();\n-\n-            // Lint integral and fractional parts separately, and then check consistency of digit\n-            // groups if both pass.\n-            let _ = Self::do_lint(parts[0])\n-                .map(|integral_group_size| {\n-                    if parts.len() > 1 {\n-                        // Lint the fractional part of literal just like integral part, but reversed.\n-                        let fractional_part = &parts[1].chars().rev().collect::<String>();\n-                        let _ = Self::do_lint(fractional_part)\n-                            .map(|fractional_group_size| {\n-                                let consistent = Self::parts_consistent(integral_group_size,\n-                                                                        fractional_group_size,\n-                                                                        parts[0].len(),\n-                                                                        parts[1].len());\n-                                if !consistent {\n-                                    WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(),\n-                                                                                   cx,\n-                                                                                   &lit.span);\n-                                }\n-                            })\n-                            .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n-                                                                         cx,\n-                                                                         &lit.span));\n-                    }\n-                })\n-                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n-        }}\n+        if_chain! {\n+            if let LitKind::Float(..) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(firstch) = src.chars().next();\n+            if char::to_digit(firstch, 10).is_some();\n+            then {\n+                let digit_info = DigitInfo::new(&src, true);\n+                // Separate digits into integral and fractional parts.\n+                let parts: Vec<&str> = digit_info\n+                    .digits\n+                    .split_terminator('.')\n+                    .collect();\n+    \n+                // Lint integral and fractional parts separately, and then check consistency of digit\n+                // groups if both pass.\n+                let _ = Self::do_lint(parts[0])\n+                    .map(|integral_group_size| {\n+                        if parts.len() > 1 {\n+                            // Lint the fractional part of literal just like integral part, but reversed.\n+                            let fractional_part = &parts[1].chars().rev().collect::<String>();\n+                            let _ = Self::do_lint(fractional_part)\n+                                .map(|fractional_group_size| {\n+                                    let consistent = Self::parts_consistent(integral_group_size,\n+                                                                            fractional_group_size,\n+                                                                            parts[0].len(),\n+                                                                            parts[1].len());\n+                                    if !consistent {\n+                                        WarningType::InconsistentDigitGrouping.display(&digit_info.grouping_hint(),\n+                                                                                       cx,\n+                                                                                       &lit.span);\n+                                    }\n+                                })\n+                                .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(),\n+                                                                             cx,\n+                                                                             &lit.span));\n+                        }\n+                    })\n+                    .map_err(|warning_type| warning_type.display(&digit_info.grouping_hint(), cx, &lit.span));\n+            }\n+        }\n     }\n \n     /// Given the sizes of the digit groups of both integral and fractional"}, {"sha": "0c3fd915399f112f00ed1ff102349fbf815c7f1f", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 120, "deletions": 111, "changes": 231, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -611,16 +611,17 @@ fn check_for_loop<'a, 'tcx>(\n }\n \n fn same_var<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &Expr, var: ast::NodeId) -> bool {\n-    if_let_chain! {[\n-        let ExprPath(ref qpath) = expr.node,\n-        let QPath::Resolved(None, ref path) = *qpath,\n-        path.segments.len() == 1,\n-        let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id),\n+    if_chain! {\n+        if let ExprPath(ref qpath) = expr.node;\n+        if let QPath::Resolved(None, ref path) = *qpath;\n+        if path.segments.len() == 1;\n+        if let Def::Local(local_id) = cx.tables.qpath_def(qpath, expr.hir_id);\n         // our variable!\n-        local_id == var\n-    ], {\n-        return true;\n-    }}\n+        if local_id == var;\n+        then {\n+            return true;\n+        }\n+    }\n \n     false\n }\n@@ -725,14 +726,15 @@ fn fetch_cloned_fixed_offset_var<'a, 'tcx>(\n     expr: &Expr,\n     var: ast::NodeId,\n ) -> Option<FixedOffsetVar> {\n-    if_let_chain! {[\n-        let ExprMethodCall(ref method, _, ref args) = expr.node,\n-        method.name == \"clone\",\n-        args.len() == 1,\n-        let Some(arg) = args.get(0),\n-    ], {\n-        return get_fixed_offset_var(cx, arg, var);\n-    }}\n+    if_chain! {\n+        if let ExprMethodCall(ref method, _, ref args) = expr.node;\n+        if method.name == \"clone\";\n+        if args.len() == 1;\n+        if let Some(arg) = args.get(0);\n+        then {\n+            return get_fixed_offset_var(cx, arg, var);\n+        }\n+    }\n \n     get_fixed_offset_var(cx, expr, var)\n }\n@@ -821,19 +823,20 @@ fn detect_manual_memcpy<'a, 'tcx>(\n             };\n \n             let print_limit = |end: &Option<&Expr>, offset: Offset, var_name: &str| if let Some(end) = *end {\n-                if_let_chain! {[\n-                    let ExprMethodCall(ref method, _, ref len_args) = end.node,\n-                    method.name == \"len\",\n-                    len_args.len() == 1,\n-                    let Some(arg) = len_args.get(0),\n-                    snippet(cx, arg.span, \"??\") == var_name,\n-                ], {\n-                    return if offset.negate {\n-                        format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n-                    } else {\n-                        \"\".to_owned()\n-                    };\n-                }}\n+                if_chain! {\n+                    if let ExprMethodCall(ref method, _, ref len_args) = end.node;\n+                    if method.name == \"len\";\n+                    if len_args.len() == 1;\n+                    if let Some(arg) = len_args.get(0);\n+                    if snippet(cx, arg.span, \"??\") == var_name;\n+                    then {\n+                        return if offset.negate {\n+                            format!(\"({} - {})\", snippet(cx, end.span, \"<src>.len()\"), offset.value)\n+                        } else {\n+                            \"\".to_owned()\n+                        };\n+                    }\n+                }\n \n                 let end_str = match limits {\n                     ast::RangeLimits::Closed => {\n@@ -1003,16 +1006,17 @@ fn check_for_loop_range<'a, 'tcx>(\n }\n \n fn is_len_call(expr: &Expr, var: &Name) -> bool {\n-    if_let_chain! {[\n-        let ExprMethodCall(ref method, _, ref len_args) = expr.node,\n-        len_args.len() == 1,\n-        method.name == \"len\",\n-        let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n-        path.segments.len() == 1,\n-        path.segments[0].name == *var\n-    ], {\n-        return true;\n-    }}\n+    if_chain! {\n+        if let ExprMethodCall(ref method, _, ref len_args) = expr.node;\n+        if len_args.len() == 1;\n+        if method.name == \"len\";\n+        if let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node;\n+        if path.segments.len() == 1;\n+        if path.segments[0].name == *var;\n+        then {\n+            return true;\n+        }\n+    }\n \n     false\n }\n@@ -1374,22 +1378,24 @@ fn mut_warn_with_span(cx: &LateContext, span: Option<Span>) {\n }\n \n fn check_for_mutability(cx: &LateContext, bound: &Expr) -> Option<NodeId> {\n-    if_let_chain! {[\n-        let ExprPath(ref qpath) = bound.node,\n-        let QPath::Resolved(None, _) = *qpath,\n-    ], {\n-        let def = cx.tables.qpath_def(qpath, bound.hir_id);\n-        if let Def::Local(node_id) = def {\n-            let node_str = cx.tcx.hir.get(node_id);\n-            if_let_chain! {[\n-                let map::Node::NodeBinding(pat) = node_str,\n-                let PatKind::Binding(bind_ann, _, _, _) = pat.node,\n-                let BindingAnnotation::Mutable = bind_ann,\n-            ], {\n-                return Some(node_id);\n-            }}\n+    if_chain! {\n+        if let ExprPath(ref qpath) = bound.node;\n+        if let QPath::Resolved(None, _) = *qpath;\n+        then {\n+            let def = cx.tables.qpath_def(qpath, bound.hir_id);\n+            if let Def::Local(node_id) = def {\n+                let node_str = cx.tcx.hir.get(node_id);\n+                if_chain! {\n+                    if let map::Node::NodeBinding(pat) = node_str;\n+                    if let PatKind::Binding(bind_ann, _, _, _) = pat.node;\n+                    if let BindingAnnotation::Mutable = bind_ann;\n+                    then {\n+                        return Some(node_id);\n+                    }\n+                }\n+            }\n         }\n-    }}\n+    }\n     None\n }\n \n@@ -1476,67 +1482,69 @@ struct VarVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n     fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        if_let_chain! {[\n+        if_chain! {\n             // an index op\n-            let ExprIndex(ref seqexpr, ref idx) = expr.node,\n+            if let ExprIndex(ref seqexpr, ref idx) = expr.node;\n             // the indexed container is referenced by a name\n-            let ExprPath(ref seqpath) = seqexpr.node,\n-            let QPath::Resolved(None, ref seqvar) = *seqpath,\n-            seqvar.segments.len() == 1,\n-        ], {\n-            let index_used_directly = same_var(self.cx, idx, self.var);\n-            let index_used = index_used_directly || {\n-                let mut used_visitor = LocalUsedVisitor {\n-                    cx: self.cx,\n-                    local: self.var,\n-                    used: false,\n+            if let ExprPath(ref seqpath) = seqexpr.node;\n+            if let QPath::Resolved(None, ref seqvar) = *seqpath;\n+            if seqvar.segments.len() == 1;\n+            then {\n+                let index_used_directly = same_var(self.cx, idx, self.var);\n+                let index_used = index_used_directly || {\n+                    let mut used_visitor = LocalUsedVisitor {\n+                        cx: self.cx,\n+                        local: self.var,\n+                        used: false,\n+                    };\n+                    walk_expr(&mut used_visitor, idx);\n+                    used_visitor.used\n                 };\n-                walk_expr(&mut used_visitor, idx);\n-                used_visitor.used\n-            };\n-\n-            if index_used {\n-                let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n-                match def {\n-                    Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n-\n-                        let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n-                        let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n-                        let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n-                        self.indexed.insert(seqvar.segments[0].name, Some(extent));\n-                        if index_used_directly {\n-                            self.indexed_directly.insert(seqvar.segments[0].name, Some(extent));\n+    \n+                if index_used {\n+                    let def = self.cx.tables.qpath_def(seqpath, seqexpr.hir_id);\n+                    match def {\n+                        Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n+                            let hir_id = self.cx.tcx.hir.node_to_hir_id(node_id);\n+    \n+                            let parent_id = self.cx.tcx.hir.get_parent(expr.id);\n+                            let parent_def_id = self.cx.tcx.hir.local_def_id(parent_id);\n+                            let extent = self.cx.tcx.region_scope_tree(parent_def_id).var_scope(hir_id.local_id);\n+                            self.indexed.insert(seqvar.segments[0].name, Some(extent));\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(seqvar.segments[0].name, Some(extent));\n+                            }\n+                            return;  // no need to walk further *on the variable*\n                         }\n-                        return;  // no need to walk further *on the variable*\n-                    }\n-                    Def::Static(..) | Def::Const(..) => {\n-                        self.indexed.insert(seqvar.segments[0].name, None);\n-                        if index_used_directly {\n-                            self.indexed_directly.insert(seqvar.segments[0].name, None);\n+                        Def::Static(..) | Def::Const(..) => {\n+                            self.indexed.insert(seqvar.segments[0].name, None);\n+                            if index_used_directly {\n+                                self.indexed_directly.insert(seqvar.segments[0].name, None);\n+                            }\n+                            return;  // no need to walk further *on the variable*\n                         }\n-                        return;  // no need to walk further *on the variable*\n+                        _ => (),\n                     }\n-                    _ => (),\n                 }\n             }\n-        }}\n+        }\n \n-        if_let_chain! {[\n+        if_chain! {\n             // directly using a variable\n-            let ExprPath(ref qpath) = expr.node,\n-            let QPath::Resolved(None, ref path) = *qpath,\n-            path.segments.len() == 1,\n-            let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id),\n-        ], {\n-            if local_id == self.var {\n-                // we are not indexing anything, record that\n-                self.nonindex = true;\n-            } else {\n-                // not the correct variable, but still a variable\n-                self.referenced.insert(path.segments[0].name);\n+            if let ExprPath(ref qpath) = expr.node;\n+            if let QPath::Resolved(None, ref path) = *qpath;\n+            if path.segments.len() == 1;\n+            if let Def::Local(local_id) = self.cx.tables.qpath_def(qpath, expr.hir_id);\n+            then {\n+                if local_id == self.var {\n+                    // we are not indexing anything, record that\n+                    self.nonindex = true;\n+                } else {\n+                    // not the correct variable, but still a variable\n+                    self.referenced.insert(path.segments[0].name);\n+                }\n             }\n-        }}\n+        }\n \n         walk_expr(self, expr);\n     }\n@@ -1845,12 +1853,13 @@ fn is_conditional(expr: &Expr) -> bool {\n }\n \n fn is_nested(cx: &LateContext, match_expr: &Expr, iter_expr: &Expr) -> bool {\n-    if_let_chain! {[\n-        let Some(loop_block) = get_enclosing_block(cx, match_expr.id),\n-        let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id)),\n-    ], {\n-        return is_loop_nested(cx, loop_expr, iter_expr)\n-    }}\n+    if_chain! {\n+        if let Some(loop_block) = get_enclosing_block(cx, match_expr.id);\n+        if let Some(map::Node::NodeExpr(loop_expr)) = cx.tcx.hir.find(cx.tcx.hir.get_parent_node(loop_block.id));\n+        then {\n+            return is_loop_nested(cx, loop_expr, iter_expr)\n+        }\n+    }\n     false\n }\n "}, {"sha": "e126d5c07d700ae6887ef457402165399affa301", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -35,43 +35,44 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n                         let body = cx.tcx.hir.body(closure_eid);\n                         let closure_expr = remove_blocks(&body.value);\n                         let ty = cx.tables.pat_ty(&body.arguments[0].pat);\n-                        if_let_chain! {[\n+                        if_chain! {\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n-                            let Some(first_arg) = iter_input_pats(decl, body).next(),\n-                            let Some(arg_ident) = get_arg_name(&first_arg.pat),\n+                            if let Some(first_arg) = iter_input_pats(decl, body).next();\n+                            if let Some(arg_ident) = get_arg_name(&first_arg.pat);\n                             // the method is being called on a known type (option or iterator)\n-                            let Some(type_name) = get_type_name(cx, expr, &args[0])\n-                        ], {\n-                            // look for derefs, for .map(|x| *x)\n-                            if only_derefs(cx, &*closure_expr, arg_ident) &&\n-                                // .cloned() only removes one level of indirection, don't lint on more\n-                                walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n-                            {\n-                                // the argument is not an &mut T\n-                                if let ty::TyRef(_, tam) = ty.sty {\n-                                    if tam.mutbl == MutImmutable {\n+                            if let Some(type_name) = get_type_name(cx, expr, &args[0]);\n+                            then {\n+                                // look for derefs, for .map(|x| *x)\n+                                if only_derefs(cx, &*closure_expr, arg_ident) &&\n+                                    // .cloned() only removes one level of indirection, don't lint on more\n+                                    walk_ptrs_ty_depth(cx.tables.pat_ty(&first_arg.pat)).1 == 1\n+                                {\n+                                    // the argument is not an &mut T\n+                                    if let ty::TyRef(_, tam) = ty.sty {\n+                                        if tam.mutbl == MutImmutable {\n+                                            span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n+                                                \"you seem to be using .map() to clone the contents of an {}, consider \\\n+                                                using `.cloned()`\", type_name),\n+                                                &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n+                                        }\n+                                    }\n+                                }\n+                                // explicit clone() calls ( .map(|x| x.clone()) )\n+                                else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n+                                    if clone_call.name == \"clone\" &&\n+                                        clone_args.len() == 1 &&\n+                                        match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n+                                        expr_eq_name(&clone_args[0], arg_ident)\n+                                    {\n                                         span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n                                             \"you seem to be using .map() to clone the contents of an {}, consider \\\n                                             using `.cloned()`\", type_name),\n                                             &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n                                     }\n                                 }\n                             }\n-                            // explicit clone() calls ( .map(|x| x.clone()) )\n-                            else if let ExprMethodCall(ref clone_call, _, ref clone_args) = closure_expr.node {\n-                                if clone_call.name == \"clone\" &&\n-                                    clone_args.len() == 1 &&\n-                                    match_trait_method(cx, closure_expr, &paths::CLONE_TRAIT) &&\n-                                    expr_eq_name(&clone_args[0], arg_ident)\n-                                {\n-                                    span_help_and_lint(cx, MAP_CLONE, expr.span, &format!(\n-                                        \"you seem to be using .map() to clone the contents of an {}, consider \\\n-                                        using `.cloned()`\", type_name),\n-                                        &format!(\"try\\n{}.cloned()\", snippet(cx, args[0].span, \"..\")));\n-                                }\n-                            }\n-                        }}\n+                        }\n                     },\n                     ExprPath(ref path) => if match_qpath(path, &paths::CLONE) {\n                         let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");"}, {"sha": "18ba34f862128dac17260b7fd81a71787b457cb2", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -343,21 +343,22 @@ fn check_wild_err_arm(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n         for arm in arms {\n             if let PatKind::TupleStruct(ref path, ref inner, _) = arm.pats[0].node {\n                 let path_str = print::to_string(print::NO_ANN, |s| s.print_qpath(path, false));\n-                if_let_chain! {[\n-                    path_str == \"Err\",\n-                    inner.iter().any(|pat| pat.node == PatKind::Wild),\n-                    let ExprBlock(ref block) = arm.body.node,\n-                    is_panic_block(block)\n-                ], {\n-                    // `Err(_)` arm with `panic!` found\n-                    span_note_and_lint(cx,\n-                                       MATCH_WILD_ERR_ARM,\n-                                       arm.pats[0].span,\n-                                       \"Err(_) will match all errors, maybe not a good idea\",\n-                                       arm.pats[0].span,\n-                                       \"to remove this warning, match each error seperately \\\n-                                        or use unreachable macro\");\n-                }}\n+                if_chain! {\n+                    if path_str == \"Err\";\n+                    if inner.iter().any(|pat| pat.node == PatKind::Wild);\n+                    if let ExprBlock(ref block) = arm.body.node;\n+                    if is_panic_block(block);\n+                    then {\n+                        // `Err(_)` arm with `panic!` found\n+                        span_note_and_lint(cx,\n+                                           MATCH_WILD_ERR_ARM,\n+                                           arm.pats[0].span,\n+                                           \"Err(_) will match all errors, maybe not a good idea\",\n+                                           arm.pats[0].span,\n+                                           \"to remove this warning, match each error seperately \\\n+                                            or use unreachable macro\");\n+                    }\n+                }\n             }\n         }\n     }\n@@ -428,24 +429,26 @@ fn all_ranges<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, arms: &'tcx [Arm], id: NodeI\n             } else {\n                 [].iter()\n             }.filter_map(|pat| {\n-                if_let_chain! {[\n-                    let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node,\n-                    let Ok(lhs) = constcx.eval(lhs),\n-                    let Ok(rhs) = constcx.eval(rhs)\n-                ], {\n-                    let rhs = match *range_end {\n-                        RangeEnd::Included => Bound::Included(rhs),\n-                        RangeEnd::Excluded => Bound::Excluded(rhs),\n-                    };\n-                    return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n-                }}\n-\n-                if_let_chain! {[\n-                    let PatKind::Lit(ref value) = pat.node,\n-                    let Ok(value) = constcx.eval(value)\n-                ], {\n-                    return Some(SpannedRange { span: pat.span, node: (value, Bound::Included(value)) });\n-                }}\n+                if_chain! {\n+                    if let PatKind::Range(ref lhs, ref rhs, ref range_end) = pat.node;\n+                    if let Ok(lhs) = constcx.eval(lhs);\n+                    if let Ok(rhs) = constcx.eval(rhs);\n+                    then {\n+                        let rhs = match *range_end {\n+                            RangeEnd::Included => Bound::Included(rhs),\n+                            RangeEnd::Excluded => Bound::Excluded(rhs),\n+                        };\n+                        return Some(SpannedRange { span: pat.span, node: (lhs, rhs) });\n+                    }\n+                }\n+\n+                if_chain! {\n+                    if let PatKind::Lit(ref value) = pat.node;\n+                    if let Ok(value) = constcx.eval(value);\n+                    then {\n+                        return Some(SpannedRange { span: pat.span, node: (value, Bound::Included(value)) });\n+                    }\n+                }\n \n                 None\n             })"}, {"sha": "8b4520a5e03973d3de5748a823c17ac5a1748e96", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 116, "deletions": 111, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -735,60 +735,62 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         let name = implitem.name;\n         let parent = cx.tcx.hir.get_parent(implitem.id);\n         let item = cx.tcx.hir.expect_item(parent);\n-        if_let_chain! {[\n-            let hir::ImplItemKind::Method(ref sig, id) = implitem.node,\n-            let Some(first_arg_ty) = sig.decl.inputs.get(0),\n-            let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next(),\n-            let hir::ItemImpl(_, _, _, _, None, ref self_ty, _) = item.node,\n-        ], {\n-            // check missing trait implementations\n-            for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n-                if name == method_name &&\n-                   sig.decl.inputs.len() == n_args &&\n-                   out_type.matches(&sig.decl.output) &&\n-                   self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n-                    span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n-                        \"defining a method called `{}` on this type; consider implementing \\\n-                         the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+        if_chain! {\n+            if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n+            if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n+            if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir.body(id)).next();\n+            if let hir::ItemImpl(_, _, _, _, None, ref self_ty, _) = item.node;\n+            then {\n+                // check missing trait implementations\n+                for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n+                    if name == method_name &&\n+                       sig.decl.inputs.len() == n_args &&\n+                       out_type.matches(&sig.decl.output) &&\n+                       self_kind.matches(first_arg_ty, first_arg, self_ty, false, &sig.generics) {\n+                        span_lint(cx, SHOULD_IMPLEMENT_TRAIT, implitem.span, &format!(\n+                            \"defining a method called `{}` on this type; consider implementing \\\n+                             the `{}` trait or choosing a less ambiguous name\", name, trait_name));\n+                    }\n                 }\n-            }\n-\n-            // check conventions w.r.t. conversion method names and predicates\n-            let def_id = cx.tcx.hir.local_def_id(item.id);\n-            let ty = cx.tcx.type_of(def_id);\n-            let is_copy = is_copy(cx, ty);\n-            for &(ref conv, self_kinds) in &CONVENTIONS {\n-                if_let_chain! {[\n-                    conv.check(&name.as_str()),\n-                    !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &sig.generics)),\n-                ], {\n-                    let lint = if item.vis == hir::Visibility::Public {\n-                        WRONG_PUB_SELF_CONVENTION\n-                    } else {\n-                        WRONG_SELF_CONVENTION\n-                    };\n+    \n+                // check conventions w.r.t. conversion method names and predicates\n+                let def_id = cx.tcx.hir.local_def_id(item.id);\n+                let ty = cx.tcx.type_of(def_id);\n+                let is_copy = is_copy(cx, ty);\n+                for &(ref conv, self_kinds) in &CONVENTIONS {\n+                    if_chain! {\n+                        if conv.check(&name.as_str());\n+                        if !self_kinds.iter().any(|k| k.matches(first_arg_ty, first_arg, self_ty, is_copy, &sig.generics));\n+                        then {\n+                            let lint = if item.vis == hir::Visibility::Public {\n+                                WRONG_PUB_SELF_CONVENTION\n+                            } else {\n+                                WRONG_SELF_CONVENTION\n+                            };\n+                            span_lint(cx,\n+                                      lint,\n+                                      first_arg.pat.span,\n+                                      &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n+                                                ambiguous name\",\n+                                               conv,\n+                                               &self_kinds.iter()\n+                                                          .map(|k| k.description())\n+                                                          .collect::<Vec<_>>()\n+                                                          .join(\" or \")));\n+                        }\n+                    }\n+                }\n+    \n+                let ret_ty = return_ty(cx, implitem.id);\n+                if name == \"new\" &&\n+                   !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n                     span_lint(cx,\n-                              lint,\n-                              first_arg.pat.span,\n-                              &format!(\"methods called `{}` usually take {}; consider choosing a less \\\n-                                        ambiguous name\",\n-                                       conv,\n-                                       &self_kinds.iter()\n-                                                  .map(|k| k.description())\n-                                                  .collect::<Vec<_>>()\n-                                                  .join(\" or \")));\n-                }}\n-            }\n-\n-            let ret_ty = return_ty(cx, implitem.id);\n-            if name == \"new\" &&\n-               !ret_ty.walk().any(|t| same_tys(cx, t, ty)) {\n-                span_lint(cx,\n-                          NEW_RET_NO_SELF,\n-                          implitem.span,\n-                          \"methods called `new` usually return `Self`\");\n+                              NEW_RET_NO_SELF,\n+                              implitem.span,\n+                              \"methods called `new` usually return `Self`\");\n+                }\n             }\n-        }}\n+        }\n     }\n }\n \n@@ -1014,20 +1016,21 @@ fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &[hir::Expr]) {\n }\n \n fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwrap: &hir::Expr) {\n-    if_let_chain!{[\n-        let hir::ExprCall(ref fun, ref args) = new.node,\n-        args.len() == 1,\n-        let hir::ExprPath(ref path) = fun.node,\n-        let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id),\n-        match_def_path(cx.tcx, did, &paths::CSTRING_NEW)\n-    ], {\n-        span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n-                           \"you are getting the inner pointer of a temporary `CString`\",\n-                           |db| {\n-                               db.note(\"that pointer will be invalid outside this expression\");\n-                               db.span_help(unwrap.span, \"assign the `CString` to a variable to extend its lifetime\");\n-                           });\n-    }}\n+    if_chain! {\n+        if let hir::ExprCall(ref fun, ref args) = new.node;\n+        if args.len() == 1;\n+        if let hir::ExprPath(ref path) = fun.node;\n+        if let Def::Method(did) = cx.tables.qpath_def(path, fun.hir_id);\n+        if match_def_path(cx.tcx, did, &paths::CSTRING_NEW);\n+        then {\n+            span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n+                               \"you are getting the inner pointer of a temporary `CString`\",\n+                               |db| {\n+                                   db.note(\"that pointer will be invalid outside this expression\");\n+                                   db.span_help(unwrap.span, \"assign the `CString` to a variable to extend its lifetime\");\n+                               });\n+        }\n+    }\n }\n \n fn lint_iter_cloned_collect(cx: &LateContext, expr: &hir::Expr, iter_args: &[hir::Expr]) {\n@@ -1427,33 +1430,34 @@ fn lint_binary_expr_with_method_call<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, i\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_NEXT_CMP` lints.\n fn lint_chars_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n-    if_let_chain! {[\n-        let Some(args) = method_chain_args(info.chain, chain_methods),\n-        let hir::ExprCall(ref fun, ref arg_char) = info.other.node,\n-        arg_char.len() == 1,\n-        let hir::ExprPath(ref qpath) = fun.node,\n-        let Some(segment) = single_segment_path(qpath),\n-        segment.name == \"Some\"\n-    ], {\n-        let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n-\n-        if self_ty.sty != ty::TyStr {\n-            return false;\n+    if_chain! {\n+        if let Some(args) = method_chain_args(info.chain, chain_methods);\n+        if let hir::ExprCall(ref fun, ref arg_char) = info.other.node;\n+        if arg_char.len() == 1;\n+        if let hir::ExprPath(ref qpath) = fun.node;\n+        if let Some(segment) = single_segment_path(qpath);\n+        if segment.name == \"Some\";\n+        then {\n+            let self_ty = walk_ptrs_ty(cx.tables.expr_ty_adjusted(&args[0][0]));\n+    \n+            if self_ty.sty != ty::TyStr {\n+                return false;\n+            }\n+    \n+            span_lint_and_sugg(cx,\n+                               lint,\n+                               info.expr.span,\n+                               &format!(\"you should use the `{}` method\", suggest),\n+                               \"like this\",\n+                               format!(\"{}{}.{}({})\",\n+                                       if info.eq { \"\" } else { \"!\" },\n+                                       snippet(cx, args[0][0].span, \"_\"),\n+                                       suggest,\n+                                       snippet(cx, arg_char[0].span, \"_\")));\n+    \n+            return true;\n         }\n-\n-        span_lint_and_sugg(cx,\n-                           lint,\n-                           info.expr.span,\n-                           &format!(\"you should use the `{}` method\", suggest),\n-                           \"like this\",\n-                           format!(\"{}{}.{}({})\",\n-                                   if info.eq { \"\" } else { \"!\" },\n-                                   snippet(cx, args[0][0].span, \"_\"),\n-                                   suggest,\n-                                   snippet(cx, arg_char[0].span, \"_\")));\n-\n-        return true;\n-    }}\n+    }\n \n     false\n }\n@@ -1474,26 +1478,27 @@ fn lint_chars_last_cmp<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprIn\n \n /// Wrapper fn for `CHARS_NEXT_CMP` and `CHARS_LAST_CMP` lints with `unwrap()`.\n fn lint_chars_cmp_with_unwrap<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, info: &BinaryExprInfo, chain_methods: &[&str], lint: &'static Lint, suggest: &str) -> bool {\n-    if_let_chain! {[\n-        let Some(args) = method_chain_args(info.chain, chain_methods),\n-        let hir::ExprLit(ref lit) = info.other.node,\n-        let ast::LitKind::Char(c) = lit.node,\n-    ], {\n-        span_lint_and_sugg(\n-            cx,\n-            lint,\n-            info.expr.span,\n-            &format!(\"you should use the `{}` method\", suggest),\n-            \"like this\",\n-            format!(\"{}{}.{}('{}')\",\n-                    if info.eq { \"\" } else { \"!\" },\n-                    snippet(cx, args[0][0].span, \"_\"),\n-                    suggest,\n-                    c)\n-        );\n-\n-        return true;\n-    }}\n+    if_chain! {\n+        if let Some(args) = method_chain_args(info.chain, chain_methods);\n+        if let hir::ExprLit(ref lit) = info.other.node;\n+        if let ast::LitKind::Char(c) = lit.node;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                lint,\n+                info.expr.span,\n+                &format!(\"you should use the `{}` method\", suggest),\n+                \"like this\",\n+                format!(\"{}{}.{}('{}')\",\n+                        if info.eq { \"\" } else { \"!\" },\n+                        snippet(cx, args[0][0].span, \"_\"),\n+                        suggest,\n+                        c)\n+            );\n+    \n+            return true;\n+        }\n+    }\n \n     false\n }"}, {"sha": "18d7f7230a821218287030440f5476d6d9b42d20", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -251,55 +251,57 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n-        if_let_chain! {[\n-            let StmtDecl(ref d, _) = s.node,\n-            let DeclLocal(ref l) = d.node,\n-            let PatKind::Binding(an, _, i, None) = l.pat.node,\n-            let Some(ref init) = l.init\n-        ], {\n-            if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n-                let init = Sugg::hir(cx, init, \"..\");\n-                let (mutopt,initref) = if an == BindingAnnotation::RefMut {\n-                    (\"mut \", init.mut_addr())\n-                } else {\n-                    (\"\", init.addr())\n-                };\n-                let tyopt = if let Some(ref ty) = l.ty {\n-                    format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"_\"))\n-                } else {\n-                    \"\".to_owned()\n-                };\n+        if_chain! {\n+            if let StmtDecl(ref d, _) = s.node;\n+            if let DeclLocal(ref l) = d.node;\n+            if let PatKind::Binding(an, _, i, None) = l.pat.node;\n+            if let Some(ref init) = l.init;\n+            then {\n+                if an == BindingAnnotation::Ref || an == BindingAnnotation::RefMut {\n+                    let init = Sugg::hir(cx, init, \"..\");\n+                    let (mutopt,initref) = if an == BindingAnnotation::RefMut {\n+                        (\"mut \", init.mut_addr())\n+                    } else {\n+                        (\"\", init.addr())\n+                    };\n+                    let tyopt = if let Some(ref ty) = l.ty {\n+                        format!(\": &{mutopt}{ty}\", mutopt=mutopt, ty=snippet(cx, ty.span, \"_\"))\n+                    } else {\n+                        \"\".to_owned()\n+                    };\n+                    span_lint_and_then(cx,\n+                        TOPLEVEL_REF_ARG,\n+                        l.pat.span,\n+                        \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n+                        |db| {\n+                            db.span_suggestion(s.span,\n+                                               \"try\",\n+                                               format!(\"let {name}{tyopt} = {initref};\",\n+                                                       name=snippet(cx, i.span, \"_\"),\n+                                                       tyopt=tyopt,\n+                                                       initref=initref));\n+                        }\n+                    );\n+                }\n+            }\n+        };\n+        if_chain! {\n+            if let StmtSemi(ref expr, _) = s.node;\n+            if let Expr_::ExprBinary(ref binop, ref a, ref b) = expr.node;\n+            if binop.node == BiAnd || binop.node == BiOr;\n+            if let Some(sugg) = Sugg::hir_opt(cx, a);\n+            then {\n                 span_lint_and_then(cx,\n-                    TOPLEVEL_REF_ARG,\n-                    l.pat.span,\n-                    \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n+                    SHORT_CIRCUIT_STATEMENT,\n+                    s.span,\n+                    \"boolean short circuit operator in statement may be clearer using an explicit test\",\n                     |db| {\n-                        db.span_suggestion(s.span,\n-                                           \"try\",\n-                                           format!(\"let {name}{tyopt} = {initref};\",\n-                                                   name=snippet(cx, i.span, \"_\"),\n-                                                   tyopt=tyopt,\n-                                                   initref=initref));\n-                    }\n-                );\n+                        let sugg = if binop.node == BiOr { !sugg } else { sugg };\n+                        db.span_suggestion(s.span, \"replace it with\",\n+                                           format!(\"if {} {{ {}; }}\", sugg, &snippet(cx, b.span, \"..\")));\n+                    });\n             }\n-        }};\n-        if_let_chain! {[\n-            let StmtSemi(ref expr, _) = s.node,\n-            let Expr_::ExprBinary(ref binop, ref a, ref b) = expr.node,\n-            binop.node == BiAnd || binop.node == BiOr,\n-            let Some(sugg) = Sugg::hir_opt(cx, a),\n-        ], {\n-            span_lint_and_then(cx,\n-                SHORT_CIRCUIT_STATEMENT,\n-                s.span,\n-                \"boolean short circuit operator in statement may be clearer using an explicit test\",\n-                |db| {\n-                    let sugg = if binop.node == BiOr { !sugg } else { sugg };\n-                    db.span_suggestion(s.span, \"replace it with\",\n-                                       format!(\"if {} {{ {}; }}\", sugg, &snippet(cx, b.span, \"..\")));\n-                });\n-        }};\n+        };\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n@@ -582,17 +584,18 @@ fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n }\n \n fn check_cast(cx: &LateContext, span: Span, e: &Expr, ty: &Ty) {\n-    if_let_chain! {[\n-        let TyPtr(MutTy { mutbl, .. }) = ty.node,\n-        let ExprLit(ref lit) = e.node,\n-        let LitKind::Int(value, ..) = lit.node,\n-        value == 0,\n-        !in_constant(cx, e.id)\n-    ], {\n-        let msg = match mutbl {\n-            Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n-            Mutability::MutImmutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n-        };\n-        span_lint(cx, ZERO_PTR, span, msg);\n-    }}\n+    if_chain! {\n+        if let TyPtr(MutTy { mutbl, .. }) = ty.node;\n+        if let ExprLit(ref lit) = e.node;\n+        if let LitKind::Int(value, ..) = lit.node;\n+        if value == 0;\n+        if !in_constant(cx, e.id);\n+        then {\n+            let msg = match mutbl {\n+                Mutability::MutMutable => \"`0 as *mut _` detected. Consider using `ptr::null_mut()`\",\n+                Mutability::MutImmutable => \"`0 as *const _` detected. Consider using `ptr::null()`\",\n+            };\n+            span_lint(cx, ZERO_PTR, span, msg);\n+        }\n+    }\n }"}, {"sha": "160ccd8e9b3a16cc1963176e4aab0120859cd679", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 83, "deletions": 80, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -322,100 +322,103 @@ impl EarlyLintPass for MiscEarly {\n \n     fn check_block(&mut self, cx: &EarlyContext, block: &Block) {\n         for w in block.stmts.windows(2) {\n-            if_let_chain! {[\n-                let StmtKind::Local(ref local) = w[0].node,\n-                let Option::Some(ref t) = local.init,\n-                let ExprKind::Closure(_, _, _, _) = t.node,\n-                let PatKind::Ident(_, sp_ident, _) = local.pat.node,\n-                let StmtKind::Semi(ref second) = w[1].node,\n-                let ExprKind::Assign(_, ref call) = second.node,\n-                let ExprKind::Call(ref closure, _) = call.node,\n-                let ExprKind::Path(_, ref path) = closure.node\n-            ], {\n-                if sp_ident.node == (&path.segments[0]).identifier {\n-                    span_lint(\n-                        cx,\n-                        REDUNDANT_CLOSURE_CALL,\n-                        second.span,\n-                        \"Closure called just once immediately after it was declared\",\n-                    );\n+            if_chain! {\n+                if let StmtKind::Local(ref local) = w[0].node;\n+                if let Option::Some(ref t) = local.init;\n+                if let ExprKind::Closure(_, _, _, _) = t.node;\n+                if let PatKind::Ident(_, sp_ident, _) = local.pat.node;\n+                if let StmtKind::Semi(ref second) = w[1].node;\n+                if let ExprKind::Assign(_, ref call) = second.node;\n+                if let ExprKind::Call(ref closure, _) = call.node;\n+                if let ExprKind::Path(_, ref path) = closure.node;\n+                then {\n+                    if sp_ident.node == (&path.segments[0]).identifier {\n+                        span_lint(\n+                            cx,\n+                            REDUNDANT_CLOSURE_CALL,\n+                            second.span,\n+                            \"Closure called just once immediately after it was declared\",\n+                        );\n+                    }\n                 }\n-            }}\n+            }\n         }\n     }\n }\n \n impl MiscEarly {\n     fn check_lit(&self, cx: &EarlyContext, lit: &Lit) {\n-        if_let_chain! {[\n-            let LitKind::Int(value, ..) = lit.node,\n-            let Some(src) = snippet_opt(cx, lit.span),\n-            let Some(firstch) = src.chars().next(),\n-            char::to_digit(firstch, 10).is_some()\n-        ], {\n-            let mut prev = '\\0';\n-            for ch in src.chars() {\n-                if ch == 'i' || ch == 'u' {\n-                    if prev != '_' {\n-                        span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n-                                    \"integer type suffix should be separated by an underscore\");\n-                    }\n-                    break;\n-                }\n-                prev = ch;\n-            }\n-            if src.starts_with(\"0x\") {\n-                let mut seen = (false, false);\n+        if_chain! {\n+            if let LitKind::Int(value, ..) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(firstch) = src.chars().next();\n+            if char::to_digit(firstch, 10).is_some();\n+            then {\n+                let mut prev = '\\0';\n                 for ch in src.chars() {\n-                    match ch {\n-                        'a' ... 'f' => seen.0 = true,\n-                        'A' ... 'F' => seen.1 = true,\n-                        'i' | 'u'   => break,   // start of suffix already\n-                        _ => ()\n+                    if ch == 'i' || ch == 'u' {\n+                        if prev != '_' {\n+                            span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n+                                        \"integer type suffix should be separated by an underscore\");\n+                        }\n+                        break;\n                     }\n+                    prev = ch;\n                 }\n-                if seen.0 && seen.1 {\n-                    span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n-                                \"inconsistent casing in hexadecimal literal\");\n+                if src.starts_with(\"0x\") {\n+                    let mut seen = (false, false);\n+                    for ch in src.chars() {\n+                        match ch {\n+                            'a' ... 'f' => seen.0 = true,\n+                            'A' ... 'F' => seen.1 = true,\n+                            'i' | 'u'   => break,   // start of suffix already\n+                            _ => ()\n+                        }\n+                    }\n+                    if seen.0 && seen.1 {\n+                        span_lint(cx, MIXED_CASE_HEX_LITERALS, lit.span,\n+                                    \"inconsistent casing in hexadecimal literal\");\n+                    }\n+                } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n+                    /* nothing to do */\n+                } else if value != 0 && src.starts_with('0') {\n+                    span_lint_and_then(cx,\n+                                        ZERO_PREFIXED_LITERAL,\n+                                        lit.span,\n+                                        \"this is a decimal constant\",\n+                                        |db| {\n+                        db.span_suggestion(\n+                            lit.span,\n+                            \"if you mean to use a decimal constant, remove the `0` to remove confusion\",\n+                            src.trim_left_matches(|c| c == '_' || c == '0').to_string(),\n+                        );\n+                        db.span_suggestion(\n+                            lit.span,\n+                            \"if you mean to use an octal constant, use `0o`\",\n+                            format!(\"0o{}\", src.trim_left_matches(|c| c == '_' || c == '0')),\n+                        );\n+                    });\n                 }\n-            } else if src.starts_with(\"0b\") || src.starts_with(\"0o\") {\n-                /* nothing to do */\n-            } else if value != 0 && src.starts_with('0') {\n-                span_lint_and_then(cx,\n-                                    ZERO_PREFIXED_LITERAL,\n-                                    lit.span,\n-                                    \"this is a decimal constant\",\n-                                    |db| {\n-                    db.span_suggestion(\n-                        lit.span,\n-                        \"if you mean to use a decimal constant, remove the `0` to remove confusion\",\n-                        src.trim_left_matches(|c| c == '_' || c == '0').to_string(),\n-                    );\n-                    db.span_suggestion(\n-                        lit.span,\n-                        \"if you mean to use an octal constant, use `0o`\",\n-                        format!(\"0o{}\", src.trim_left_matches(|c| c == '_' || c == '0')),\n-                    );\n-                });\n             }\n-        }}\n-        if_let_chain! {[\n-            let LitKind::Float(..) = lit.node,\n-            let Some(src) = snippet_opt(cx, lit.span),\n-            let Some(firstch) = src.chars().next(),\n-            char::to_digit(firstch, 10).is_some()\n-        ], {\n-            let mut prev = '\\0';\n-            for ch in src.chars() {\n-                if ch == 'f' {\n-                    if prev != '_' {\n-                        span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n-                                    \"float type suffix should be separated by an underscore\");\n+        }\n+        if_chain! {\n+            if let LitKind::Float(..) = lit.node;\n+            if let Some(src) = snippet_opt(cx, lit.span);\n+            if let Some(firstch) = src.chars().next();\n+            if char::to_digit(firstch, 10).is_some();\n+            then {\n+                let mut prev = '\\0';\n+                for ch in src.chars() {\n+                    if ch == 'f' {\n+                        if prev != '_' {\n+                            span_lint(cx, UNSEPARATED_LITERAL_SUFFIX, lit.span,\n+                                        \"float type suffix should be separated by an underscore\");\n+                        }\n+                        break;\n                     }\n-                    break;\n+                    prev = ch;\n                 }\n-                prev = ch;\n             }\n-        }}\n+        }\n     }\n }"}, {"sha": "be1fd1dc525695d05571ddc626a36b887dcc2506", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -75,25 +75,26 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n         if in_macro(pat.span) {\n             return;\n         }\n-        if_let_chain! {[\n-            let PatKind::Binding(BindingAnnotation::Ref, _, name, _) = pat.node,\n-            let ty::TyRef(_, ref tam) = cx.tables.pat_ty(pat).sty,\n-            tam.mutbl == MutImmutable,\n-            let ty::TyRef(_, ref tam) = tam.ty.sty,\n+        if_chain! {\n+            if let PatKind::Binding(BindingAnnotation::Ref, _, name, _) = pat.node;\n+            if let ty::TyRef(_, ref tam) = cx.tables.pat_ty(pat).sty;\n+            if tam.mutbl == MutImmutable;\n+            if let ty::TyRef(_, ref tam) = tam.ty.sty;\n             // only lint immutable refs, because borrowed `&mut T` cannot be moved out\n-            tam.mutbl == MutImmutable,\n-        ], {\n-            span_lint_and_then(\n-                cx,\n-                NEEDLESS_BORROW,\n-                pat.span,\n-                \"this pattern creates a reference to a reference\",\n-                |db| {\n-                    if let Some(snippet) = snippet_opt(cx, name.span) {\n-                        db.span_suggestion(pat.span, \"change this to\", snippet);\n+            if tam.mutbl == MutImmutable;\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    NEEDLESS_BORROW,\n+                    pat.span,\n+                    \"this pattern creates a reference to a reference\",\n+                    |db| {\n+                        if let Some(snippet) = snippet_opt(cx, name.span) {\n+                            db.span_suggestion(pat.span, \"change this to\", snippet);\n+                        }\n                     }\n-                }\n-            )\n-        }}\n+                )\n+            }\n+        }\n     }\n }"}, {"sha": "c9a2e6b0935eac17b9e18964f228a6d24e1a41b9", "filename": "clippy_lints/src/needless_borrowed_ref.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrowed_ref.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -64,19 +64,20 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrowedRef {\n             return;\n         }\n \n-        if_let_chain! {[\n+        if_chain! {\n             // Only lint immutable refs, because `&mut ref T` may be useful.\n-            let PatKind::Ref(ref sub_pat, MutImmutable) = pat.node,\n+            if let PatKind::Ref(ref sub_pat, MutImmutable) = pat.node;\n \n             // Check sub_pat got a `ref` keyword (excluding `ref mut`).\n-            let PatKind::Binding(BindingAnnotation::Ref, _, spanned_name, ..) = sub_pat.node,\n-        ], {\n-            span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, pat.span,\n-                               \"this pattern takes a reference on something that is being de-referenced\",\n-                               |db| {\n-                                   let hint = snippet(cx, spanned_name.span, \"..\").into_owned();\n-                                   db.span_suggestion(pat.span, \"try removing the `&ref` part and just keep\", hint);\n-                               });\n-        }}\n+            if let PatKind::Binding(BindingAnnotation::Ref, _, spanned_name, ..) = sub_pat.node;\n+            then {\n+                span_lint_and_then(cx, NEEDLESS_BORROWED_REFERENCE, pat.span,\n+                                   \"this pattern takes a reference on something that is being de-referenced\",\n+                                   |db| {\n+                                       let hint = snippet(cx, spanned_name.span, \"..\").into_owned();\n+                                       db.span_suggestion(pat.span, \"try removing the `&ref` part and just keep\", hint);\n+                                   });\n+            }\n+        }\n     }\n }"}, {"sha": "e00938fb3ef1c4cd4b6fc04762cfb4e3973860d9", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 115, "deletions": 111, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -64,13 +64,14 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n         match kind {\n             FnKind::ItemFn(.., attrs) => for a in attrs {\n-                if_let_chain!{[\n-                    a.meta_item_list().is_some(),\n-                    let Some(name) = a.name(),\n-                    name == \"proc_macro_derive\",\n-                ], {\n-                    return;\n-                }}\n+                if_chain! {\n+                    if a.meta_item_list().is_some();\n+                    if let Some(name) = a.name();\n+                    if name == \"proc_macro_derive\";\n+                    then {\n+                        return;\n+                    }\n+                }\n             },\n             _ => return,\n         }\n@@ -148,101 +149,103 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 )\n             };\n \n-            if_let_chain! {[\n-                !is_self(arg),\n-                !ty.is_mutable_pointer(),\n-                !is_copy(cx, ty),\n-                !fn_traits.iter().any(|&t| implements_trait(cx, ty, t, &[])),\n-                !implements_borrow_trait,\n-                !all_borrowable_trait,\n-\n-                let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node,\n-                !moved_vars.contains(&canonical_id),\n-            ], {\n-                if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n-                    continue;\n-                }\n-\n-                // Dereference suggestion\n-                let sugg = |db: &mut DiagnosticBuilder| {\n-                    let deref_span = spans_need_deref.get(&canonical_id);\n-                    if_let_chain! {[\n-                        match_type(cx, ty, &paths::VEC),\n-                        let Some(clone_spans) =\n-                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]),\n-                        let TyPath(QPath::Resolved(_, ref path)) = input.node,\n-                        let Some(elem_ty) = path.segments.iter()\n-                            .find(|seg| seg.name == \"Vec\")\n-                            .and_then(|ps| ps.parameters.as_ref())\n-                            .map(|params| &params.types[0]),\n-                    ], {\n-                        let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));\n-                        db.span_suggestion(input.span,\n-                                        \"consider changing the type to\",\n-                                        slice_ty);\n-\n-                        for (span, suggestion) in clone_spans {\n-                            db.span_suggestion(\n-                                span,\n-                                &snippet_opt(cx, span)\n-                                    .map_or(\n-                                        \"change the call to\".into(),\n-                                        |x| Cow::from(format!(\"change `{}` to\", x)),\n-                                    ),\n-                                suggestion.into()\n-                            );\n+            if_chain! {\n+                if !is_self(arg);\n+                if !ty.is_mutable_pointer();\n+                if !is_copy(cx, ty);\n+                if !fn_traits.iter().any(|&t| implements_trait(cx, ty, t, &[]));\n+                if !implements_borrow_trait;\n+                if !all_borrowable_trait;\n+\n+                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node;\n+                if !moved_vars.contains(&canonical_id);\n+                then {\n+                    if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n+                        continue;\n+                    }\n+    \n+                    // Dereference suggestion\n+                    let sugg = |db: &mut DiagnosticBuilder| {\n+                        let deref_span = spans_need_deref.get(&canonical_id);\n+                        if_chain! {\n+                            if match_type(cx, ty, &paths::VEC);\n+                            if let Some(clone_spans) =\n+                                get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_owned()\")]);\n+                            if let TyPath(QPath::Resolved(_, ref path)) = input.node;\n+                            if let Some(elem_ty) = path.segments.iter()\n+                                .find(|seg| seg.name == \"Vec\")\n+                                .and_then(|ps| ps.parameters.as_ref())\n+                                .map(|params| &params.types[0]);\n+                            then {\n+                                let slice_ty = format!(\"&[{}]\", snippet(cx, elem_ty.span, \"_\"));\n+                                db.span_suggestion(input.span,\n+                                                \"consider changing the type to\",\n+                                                slice_ty);\n+        \n+                                for (span, suggestion) in clone_spans {\n+                                    db.span_suggestion(\n+                                        span,\n+                                        &snippet_opt(cx, span)\n+                                            .map_or(\n+                                                \"change the call to\".into(),\n+                                                |x| Cow::from(format!(\"change `{}` to\", x)),\n+                                            ),\n+                                        suggestion.into()\n+                                    );\n+                                }\n+        \n+                                // cannot be destructured, no need for `*` suggestion\n+                                assert!(deref_span.is_none());\n+                                return;\n+                            }\n                         }\n-\n-                        // cannot be destructured, no need for `*` suggestion\n-                        assert!(deref_span.is_none());\n-                        return;\n-                    }}\n-\n-                    if match_type(cx, ty, &paths::STRING) {\n-                        if let Some(clone_spans) =\n-                            get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n-                            db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n-\n-                            for (span, suggestion) in clone_spans {\n-                                db.span_suggestion(\n-                                    span,\n-                                    &snippet_opt(cx, span)\n-                                        .map_or(\n-                                            \"change the call to\".into(),\n-                                            |x| Cow::from(format!(\"change `{}` to\", x))\n-                                        ),\n-                                    suggestion.into(),\n-                                );\n+    \n+                        if match_type(cx, ty, &paths::STRING) {\n+                            if let Some(clone_spans) =\n+                                get_spans(cx, Some(body.id()), idx, &[(\"clone\", \".to_string()\"), (\"as_str\", \"\")]) {\n+                                db.span_suggestion(input.span, \"consider changing the type to\", \"&str\".to_string());\n+    \n+                                for (span, suggestion) in clone_spans {\n+                                    db.span_suggestion(\n+                                        span,\n+                                        &snippet_opt(cx, span)\n+                                            .map_or(\n+                                                \"change the call to\".into(),\n+                                                |x| Cow::from(format!(\"change `{}` to\", x))\n+                                            ),\n+                                        suggestion.into(),\n+                                    );\n+                                }\n+    \n+                                assert!(deref_span.is_none());\n+                                return;\n                             }\n-\n-                            assert!(deref_span.is_none());\n-                            return;\n                         }\n-                    }\n-\n-                    let mut spans = vec![(input.span, format!(\"&{}\", snippet(cx, input.span, \"_\")))];\n-\n-                    // Suggests adding `*` to dereference the added reference.\n-                    if let Some(deref_span) = deref_span {\n-                        spans.extend(\n-                            deref_span\n-                                .iter()\n-                                .cloned()\n-                                .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))),\n-                        );\n-                        spans.sort_by_key(|&(span, _)| span);\n-                    }\n-                    multispan_sugg(db, \"consider taking a reference instead\".to_string(), spans);\n-                };\n-\n-                span_lint_and_then(\n-                    cx,\n-                    NEEDLESS_PASS_BY_VALUE,\n-                    input.span,\n-                    \"this argument is passed by value, but not consumed in the function body\",\n-                    sugg,\n-                );\n-            }}\n+    \n+                        let mut spans = vec![(input.span, format!(\"&{}\", snippet(cx, input.span, \"_\")))];\n+    \n+                        // Suggests adding `*` to dereference the added reference.\n+                        if let Some(deref_span) = deref_span {\n+                            spans.extend(\n+                                deref_span\n+                                    .iter()\n+                                    .cloned()\n+                                    .map(|span| (span, format!(\"*{}\", snippet(cx, span, \"<expr>\")))),\n+                            );\n+                            spans.sort_by_key(|&(span, _)| span);\n+                        }\n+                        multispan_sugg(db, \"consider taking a reference instead\".to_string(), spans);\n+                    };\n+    \n+                    span_lint_and_then(\n+                        cx,\n+                        NEEDLESS_PASS_BY_VALUE,\n+                        input.span,\n+                        \"this argument is passed by value, but not consumed in the function body\",\n+                        sugg,\n+                    );\n+                }\n+            }\n         }\n     }\n }\n@@ -299,18 +302,19 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n \n                         map::Node::NodeStmt(s) => {\n                             // `let <pat> = x;`\n-                            if_let_chain! {[\n-                                let StmtDecl(ref decl, _) = s.node,\n-                                let DeclLocal(ref local) = decl.node,\n-                            ], {\n-                                self.spans_need_deref\n-                                    .entry(vid)\n-                                    .or_insert_with(HashSet::new)\n-                                    .insert(local.init\n-                                        .as_ref()\n-                                        .map(|e| e.span)\n-                                        .expect(\"`let` stmt without init aren't caught by match_pat\"));\n-                            }}\n+                            if_chain! {\n+                                if let StmtDecl(ref decl, _) = s.node;\n+                                if let DeclLocal(ref local) = decl.node;\n+                                then {\n+                                    self.spans_need_deref\n+                                        .entry(vid)\n+                                        .or_insert_with(HashSet::new)\n+                                        .insert(local.init\n+                                            .as_ref()\n+                                            .map(|e| e.span)\n+                                            .expect(\"`let` stmt without init aren't caught by match_pat\"));\n+                                }\n+                            }\n                         },\n \n                         _ => {},"}, {"sha": "e34136face9b41302a72556e1dab1c1864adf2c5", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -45,16 +45,17 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n }\n \n fn check_mul(cx: &LateContext, span: Span, lit: &Expr, exp: &Expr) {\n-    if_let_chain!([\n-        let ExprLit(ref l) = lit.node,\n-        let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit)),\n-        let Some(val) = ci.to_u64(),\n-        val == 1,\n-        cx.tables.expr_ty(exp).is_integral()\n-    ], {\n-        span_lint(cx,\n-                  NEG_MULTIPLY,\n-                  span,\n-                  \"Negation by multiplying with -1\");\n-    })\n+    if_chain! {\n+        if let ExprLit(ref l) = lit.node;\n+        if let Constant::Int(ref ci) = consts::lit_to_constant(&l.node, cx.tcx, cx.tables.expr_ty(lit));\n+        if let Some(val) = ci.to_u64();\n+        if val == 1;\n+        if cx.tables.expr_ty(exp).is_integral();\n+        then {\n+            span_lint(cx,\n+                      NEG_MULTIPLY,\n+                      span,\n+                      \"Negation by multiplying with -1\");\n+        }\n+    }\n }"}, {"sha": "31a9de871b466fbcf20d33f263cf1ced29974a19", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -117,40 +117,41 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n             if decl.inputs.is_empty() && name == \"new\" && cx.access_levels.is_reachable(id) {\n                 let self_ty = cx.tcx\n                     .type_of(cx.tcx.hir.local_def_id(cx.tcx.hir.get_parent(id)));\n-                if_let_chain!{[\n-                                    same_tys(cx, self_ty, return_ty(cx, id)),\n-                                    let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT),\n-                                    !implements_trait(cx, self_ty, default_trait_id, &[])\n-                                ], {\n-                                    if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n-                                        span_lint_and_then(cx,\n-                                                           NEW_WITHOUT_DEFAULT_DERIVE, span,\n-                                                           &format!(\"you should consider deriving a \\\n-                                                                     `Default` implementation for `{}`\",\n-                                                                    self_ty),\n-                                                           |db| {\n-                                            db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n-                                        });\n-                                    } else {\n-                                        span_lint_and_then(cx,\n-                                                           NEW_WITHOUT_DEFAULT, span,\n-                                                           &format!(\"you should consider adding a \\\n-                                                                    `Default` implementation for `{}`\",\n-                                                                    self_ty),\n-                                                           |db| {\n-                                        db.suggest_prepend_item(cx,\n-                                                                  span,\n-                                                                  \"try this\",\n-                                                                  &format!(\n+                if_chain! {\n+                                    if same_tys(cx, self_ty, return_ty(cx, id));\n+                                    if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n+                                    if !implements_trait(cx, self_ty, default_trait_id, &[]);\n+                                    then {\n+                                        if let Some(sp) = can_derive_default(self_ty, cx, default_trait_id) {\n+                                            span_lint_and_then(cx,\n+                                                               NEW_WITHOUT_DEFAULT_DERIVE, span,\n+                                                               &format!(\"you should consider deriving a \\\n+                                                                         `Default` implementation for `{}`\",\n+                                                                        self_ty),\n+                                                               |db| {\n+                                                db.suggest_item_with_attr(cx, sp, \"try this\", \"#[derive(Default)]\");\n+                                            });\n+                                        } else {\n+                                            span_lint_and_then(cx,\n+                                                               NEW_WITHOUT_DEFAULT, span,\n+                                                               &format!(\"you should consider adding a \\\n+                                                                        `Default` implementation for `{}`\",\n+                                                                        self_ty),\n+                                                               |db| {\n+                                            db.suggest_prepend_item(cx,\n+                                                                      span,\n+                                                                      \"try this\",\n+                                                                      &format!(\n \"impl Default for {} {{\n     fn default() -> Self {{\n         Self::new()\n     }}\n }}\",\n-                                                                           self_ty));\n-                                        });\n+                                                                               self_ty));\n+                                            });\n+                                        }\n                                     }\n-                                }}\n+                }\n             }\n         }\n     }"}, {"sha": "e6fe0631a63b95692d1a3146af514d43f1c7ced9", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -43,21 +43,22 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain! {[ //begin checking variables\n-            let ExprMatch(ref op, ref body, ref source) = expr.node, //test if expr is a match\n-            let MatchSource::IfLetDesugar { .. } = *source, //test if it is an If Let\n-            let ExprMethodCall(_, _, ref result_types) = op.node, //check is expr.ok() has type Result<T,E>.ok()\n-            let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node, //get operation\n-            method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n-\n-        ], {\n-            let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n-            let some_expr_string = snippet(cx, y[0].span, \"\");\n-            if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n-                span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,\n-                \"Matching on `Some` with `ok()` is redundant\",\n-                &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string));\n+        if_chain! { //begin checking variables\n+            if let ExprMatch(ref op, ref body, ref source) = expr.node; //test if expr is a match\n+            if let MatchSource::IfLetDesugar { .. } = *source; //test if it is an If Let\n+            if let ExprMethodCall(_, _, ref result_types) = op.node; //check is expr.ok() has type Result<T,E>.ok()\n+            if let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node; //get operation\n+            if method_chain_args(op, &[\"ok\"]).is_some(); //test to see if using ok() methoduse std::marker::Sized;\n+    \n+            then {\n+                let is_result_type = match_type(cx, cx.tables.expr_ty(&result_types[0]), &paths::RESULT);\n+                let some_expr_string = snippet(cx, y[0].span, \"\");\n+                if print::to_string(print::NO_ANN, |s| s.print_path(x, false)) == \"Some\" && is_result_type {\n+                    span_help_and_lint(cx, IF_LET_SOME_RESULT, expr.span,\n+                    \"Matching on `Some` with `ok()` is redundant\",\n+                    &format!(\"Consider matching on `Ok({})` and removing the call to `ok` instead\", some_expr_string));\n+                }\n             }\n-        }}\n+        }\n     }\n }"}, {"sha": "4177f4a3e73c01ce0aeed5ea30d499327f1e75a8", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 42, "deletions": 40, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -31,52 +31,54 @@ impl LintPass for OverflowCheckConditional {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain! {[\n-            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n-            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n-            cx.tables.expr_ty(ident1).is_integral(),\n-            cx.tables.expr_ty(ident2).is_integral()\n-        ], {\n-            if let BinOp_::BiLt = op.node {\n-                if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+        if_chain! {\n+            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n+            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node;\n+            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if cx.tables.expr_ty(ident1).is_integral();\n+            if cx.tables.expr_ty(ident2).is_integral();\n+            then {\n+                if let BinOp_::BiLt = op.node {\n+                    if let BinOp_::BiAdd = op2.node {\n+                        span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                            \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    }\n                 }\n-            }\n-            if let BinOp_::BiGt = op.node {\n-                if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                if let BinOp_::BiGt = op.node {\n+                    if let BinOp_::BiSub = op2.node {\n+                        span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                            \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    }\n                 }\n             }\n-        }}\n+        }\n \n-        if_let_chain! {[\n-            let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n-            let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n-            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n-            path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0],\n-            cx.tables.expr_ty(ident1).is_integral(),\n-            cx.tables.expr_ty(ident2).is_integral()\n-        ], {\n-            if let BinOp_::BiGt = op.node {\n-                if let BinOp_::BiAdd = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                        \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+        if_chain! {\n+            if let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node;\n+            if let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node;\n+            if let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node;\n+            if path1.segments[0] == path3.segments[0] || path2.segments[0] == path3.segments[0];\n+            if cx.tables.expr_ty(ident1).is_integral();\n+            if cx.tables.expr_ty(ident2).is_integral();\n+            then {\n+                if let BinOp_::BiGt = op.node {\n+                    if let BinOp_::BiAdd = op2.node {\n+                        span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                            \"You are trying to use classic C overflow conditions that will fail in Rust.\");\n+                    }\n                 }\n-            }\n-            if let BinOp_::BiLt = op.node {\n-                if let BinOp_::BiSub = op2.node {\n-                    span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n-                        \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                if let BinOp_::BiLt = op.node {\n+                    if let BinOp_::BiSub = op2.node {\n+                        span_lint(cx, OVERFLOW_CHECK_CONDITIONAL, expr.span,\n+                            \"You are trying to use classic C underflow conditions that will fail in Rust.\");\n+                    }\n                 }\n             }\n-        }}\n+        }\n     }\n }"}, {"sha": "1a14a0bc45da7546b5097a4eb3e76e7529d23f0f", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -34,23 +34,24 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain! {[\n-            let ExprBlock(ref block) = expr.node,\n-            let Some(ref ex) = block.expr,\n-            let ExprCall(ref fun, ref params) = ex.node,\n-            params.len() == 2,\n-            let ExprPath(ref qpath) = fun.node,\n-            let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n-            match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC),\n-            let ExprLit(ref lit) = params[0].node,\n-            is_direct_expn_of(expr.span, \"panic\").is_some(),\n-            let LitKind::Str(ref string, _) = lit.node,\n-            let Some(par) = string.as_str().find('{'),\n-            string.as_str()[par..].contains('}'),\n-            params[0].span.source_callee().is_none()\n-        ], {\n-            span_lint(cx, PANIC_PARAMS, params[0].span,\n-                      \"you probably are missing some parameter in your format string\");\n-        }}\n+        if_chain! {\n+            if let ExprBlock(ref block) = expr.node;\n+            if let Some(ref ex) = block.expr;\n+            if let ExprCall(ref fun, ref params) = ex.node;\n+            if params.len() == 2;\n+            if let ExprPath(ref qpath) = fun.node;\n+            if let Some(fun_def_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+            if match_def_path(cx.tcx, fun_def_id, &paths::BEGIN_PANIC);\n+            if let ExprLit(ref lit) = params[0].node;\n+            if is_direct_expn_of(expr.span, \"panic\").is_some();\n+            if let LitKind::Str(ref string, _) = lit.node;\n+            if let Some(par) = string.as_str().find('{');\n+            if string.as_str()[par..].contains('}');\n+            if params[0].span.source_callee().is_none();\n+            then {\n+                span_lint(cx, PANIC_PARAMS, params[0].span,\n+                          \"you probably are missing some parameter in your format string\");\n+            }\n+        }\n     }\n }"}, {"sha": "22dc43eb6c583b611e635ddbb5dc44e8c39c4e05", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -37,20 +37,21 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n-        if_let_chain! {[\n-            let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n-            !is_automatically_derived(&*item.attrs),\n-            let Some(eq_trait) = cx.tcx.lang_items().eq_trait(),\n-            trait_ref.path.def.def_id() == eq_trait\n-        ], {\n-            for impl_item in impl_items {\n-                if impl_item.name == \"ne\" {\n-                    span_lint(cx,\n-                              PARTIALEQ_NE_IMPL,\n-                              impl_item.span,\n-                              \"re-implementing `PartialEq::ne` is unnecessary\")\n+        if_chain! {\n+            if let ItemImpl(_, _, _, _, Some(ref trait_ref), _, ref impl_items) = item.node;\n+            if !is_automatically_derived(&*item.attrs);\n+            if let Some(eq_trait) = cx.tcx.lang_items().eq_trait();\n+            if trait_ref.path.def.def_id() == eq_trait;\n+            then {\n+                for impl_item in impl_items {\n+                    if impl_item.name == \"ne\" {\n+                        span_lint(cx,\n+                                  PARTIALEQ_NE_IMPL,\n+                                  impl_item.span,\n+                                  \"re-implementing `PartialEq::ne` is unnecessary\")\n+                    }\n                 }\n             }\n-        }};\n+        };\n     }\n }"}, {"sha": "ce6b96108a40b291aaaf98e6e5d910801c2c25ca", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 77, "deletions": 72, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -89,58 +89,60 @@ impl LintPass for Pass {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain! {[\n-            let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(ref qpath) = fun.node,\n-            let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id)),\n-        ], {\n-\n-            // Search for `std::io::_print(..)` which is unique in a\n-            // `print!` expansion.\n-            if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n-                if let Some(span) = is_expn_of(expr.span, \"print\") {\n-                    // `println!` uses `print!`.\n-                    let (span, name) = match is_expn_of(span, \"println\") {\n-                        Some(span) => (span, \"println\"),\n-                        None => (span, \"print\"),\n-                    };\n-\n-                    span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n-\n-                    if_let_chain!{[\n-                        // ensure we're calling Arguments::new_v1\n-                        args.len() == 1,\n-                        let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                        let ExprPath(ref qpath) = args_fun.node,\n-                        let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id)),\n-                        match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1),\n-                        args_args.len() == 2,\n-                        let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n-                        let ExprMatch(ref args, _, _) = match_expr.node,\n-                        let ExprTup(ref args) = args.node,\n-                        let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]),\n-                    ], {\n-                        match name {\n-                            \"print\" => check_print(cx, span, args, fmtstr, fmtlen),\n-                            \"println\" => check_println(cx, span, fmtstr, fmtlen),\n-                            _ => (),\n+        if_chain! {\n+            if let ExprCall(ref fun, ref args) = expr.node;\n+            if let ExprPath(ref qpath) = fun.node;\n+            if let Some(fun_id) = opt_def_id(resolve_node(cx, qpath, fun.hir_id));\n+            then {\n+    \n+                // Search for `std::io::_print(..)` which is unique in a\n+                // `print!` expansion.\n+                if match_def_path(cx.tcx, fun_id, &paths::IO_PRINT) {\n+                    if let Some(span) = is_expn_of(expr.span, \"print\") {\n+                        // `println!` uses `print!`.\n+                        let (span, name) = match is_expn_of(span, \"println\") {\n+                            Some(span) => (span, \"println\"),\n+                            None => (span, \"print\"),\n+                        };\n+    \n+                        span_lint(cx, PRINT_STDOUT, span, &format!(\"use of `{}!`\", name));\n+    \n+                        if_chain! {\n+                            // ensure we're calling Arguments::new_v1\n+                            if args.len() == 1;\n+                            if let ExprCall(ref args_fun, ref args_args) = args[0].node;\n+                            if let ExprPath(ref qpath) = args_fun.node;\n+                            if let Some(const_def_id) = opt_def_id(resolve_node(cx, qpath, args_fun.hir_id));\n+                            if match_def_path(cx.tcx, const_def_id, &paths::FMT_ARGUMENTS_NEWV1);\n+                            if args_args.len() == 2;\n+                            if let ExprAddrOf(_, ref match_expr) = args_args[1].node;\n+                            if let ExprMatch(ref args, _, _) = match_expr.node;\n+                            if let ExprTup(ref args) = args.node;\n+                            if let Some((fmtstr, fmtlen)) = get_argument_fmtstr_parts(&args_args[0]);\n+                            then {\n+                                match name {\n+                                    \"print\" => check_print(cx, span, args, fmtstr, fmtlen),\n+                                    \"println\" => check_println(cx, span, fmtstr, fmtlen),\n+                                    _ => (),\n+                                }\n+                            }\n                         }\n-                    }}\n+                    }\n                 }\n-            }\n-            // Search for something like\n-            // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n-            else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-                if let ExprPath(ref qpath) = args[1].node {\n-                    if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n-                        if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD)\n-                                && !is_in_debug_impl(cx, expr) && is_expn_of(expr.span, \"panic\").is_none() {\n-                            span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                // Search for something like\n+                // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n+                else if args.len() == 2 && match_def_path(cx.tcx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n+                    if let ExprPath(ref qpath) = args[1].node {\n+                        if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, args[1].hir_id)) {\n+                            if match_def_path(cx.tcx, def_id, &paths::DEBUG_FMT_METHOD)\n+                                    && !is_in_debug_impl(cx, expr) && is_expn_of(expr.span, \"panic\").is_none() {\n+                                span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n+                            }\n                         }\n                     }\n                 }\n             }\n-        }}\n+        }\n     }\n }\n \n@@ -152,36 +154,38 @@ fn check_print<'a, 'tcx>(\n     fmtstr: InternedString,\n     fmtlen: usize,\n ) {\n-    if_let_chain!{[\n+    if_chain! {\n         // check the final format string part\n-        let Some('\\n') = fmtstr.chars().last(),\n+        if let Some('\\n') = fmtstr.chars().last();\n \n         // \"foo{}bar\" is made into two strings + one argument,\n         // if the format string starts with `{}` (eg. \"{}foo\"),\n         // the string array is prepended an empty string \"\".\n         // We only want to check the last string after any `{}`:\n-        args.len() < fmtlen,\n-    ], {\n-        span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                  \"using `print!()` with a format string that ends in a \\\n-                   newline, consider using `println!()` instead\");\n-    }}\n+        if args.len() < fmtlen;\n+        then {\n+            span_lint(cx, PRINT_WITH_NEWLINE, span,\n+                      \"using `print!()` with a format string that ends in a \\\n+                       newline, consider using `println!()` instead\");\n+        }\n+    }\n }\n \n /// Check for println!(\"\")\n fn check_println<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, fmtstr: InternedString, fmtlen: usize) {\n-    if_let_chain!{[\n+    if_chain! {\n         // check that the string is empty\n-        fmtlen == 1,\n-        fmtstr.deref() == \"\\n\",\n+        if fmtlen == 1;\n+        if fmtstr.deref() == \"\\n\";\n \n         // check the presence of that string\n-        let Ok(snippet) = cx.sess().codemap().span_to_snippet(span),\n-        snippet.contains(\"\\\"\\\"\"),\n-    ], {\n-        span_lint(cx, PRINT_WITH_NEWLINE, span,\n-                  \"using `println!(\\\"\\\")`, consider using `println!()` instead\");\n-     }}\n+        if let Ok(snippet) = cx.sess().codemap().span_to_snippet(span);\n+        if snippet.contains(\"\\\"\\\"\");\n+        then {\n+            span_lint(cx, PRINT_WITH_NEWLINE, span,\n+                      \"using `println!(\\\"\\\")`, consider using `println!()` instead\");\n+         }\n+    }\n }\n \n fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n@@ -202,14 +206,15 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n \n /// Returns the slice of format string parts in an `Arguments::new_v1` call.\n fn get_argument_fmtstr_parts(expr: &Expr) -> Option<(InternedString, usize)> {\n-    if_let_chain! {[\n-        let ExprAddrOf(_, ref expr) = expr.node, // &[\"\u2026\", \"\u2026\", \u2026]\n-        let ExprArray(ref exprs) = expr.node,\n-        let Some(expr) = exprs.last(),\n-        let ExprLit(ref lit) = expr.node,\n-        let LitKind::Str(ref lit, _) = lit.node,\n-    ], {\n-        return Some((lit.as_str(), exprs.len()));\n-    }}\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node; // &[\"\u2026\", \"\u2026\", \u2026]\n+        if let ExprArray(ref exprs) = expr.node;\n+        if let Some(expr) = exprs.last();\n+        if let ExprLit(ref lit) = expr.node;\n+        if let LitKind::Str(ref lit, _) = lit.node;\n+        then {\n+            return Some((lit.as_str(), exprs.len()));\n+        }\n+    }\n     None\n }"}, {"sha": "916132daeff2ecab3374f57b6f27c32d5831e375", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -156,13 +156,14 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<\n         {\n             if match_type(cx, ty, &paths::VEC) {\n                 let mut ty_snippet = None;\n-                if_let_chain!([\n-                    let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node,\n-                    let Some(&PathSegment{parameters: Some(ref parameters), ..}) = path.segments.last(),\n-                    parameters.types.len() == 1,\n-                ], {\n-                    ty_snippet = snippet_opt(cx, parameters.types[0].span);\n-                });\n+                if_chain! {\n+                    if let TyPath(QPath::Resolved(_, ref path)) = walk_ptrs_hir_ty(arg).node;\n+                    if let Some(&PathSegment{parameters: Some(ref parameters), ..}) = path.segments.last();\n+                    if parameters.types.len() == 1;\n+                    then {\n+                        ty_snippet = snippet_opt(cx, parameters.types[0].span);\n+                    }\n+                };\n                 if let Some(spans) = get_spans(cx, opt_body_id, idx, &[(\"clone\", \".to_owned()\")]) {\n                     span_lint_and_then(\n                         cx,"}, {"sha": "6e9bebca7570459ee0a66cc9b674dd71e5850b29", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -113,69 +113,72 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             } else if name == \"zip\" && args.len() == 2 {\n                 let iter = &args[0].node;\n                 let zip_arg = &args[1];\n-                if_let_chain! {[\n+                if_chain! {\n                     // .iter() call\n-                    let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter,\n-                    iter_path.name == \"iter\",\n+                    if let ExprMethodCall(ref iter_path, _, ref iter_args ) = *iter;\n+                    if iter_path.name == \"iter\";\n                     // range expression in .zip() call: 0..x.len()\n-                    let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg),\n-                    is_integer_literal(start, 0),\n+                    if let Some(higher::Range { start: Some(start), end: Some(end), .. }) = higher::range(zip_arg);\n+                    if is_integer_literal(start, 0);\n                     // .len() call\n-                    let ExprMethodCall(ref len_path, _, ref len_args) = end.node,\n-                    len_path.name == \"len\" && len_args.len() == 1,\n+                    if let ExprMethodCall(ref len_path, _, ref len_args) = end.node;\n+                    if len_path.name == \"len\" && len_args.len() == 1;\n                     // .iter() and .len() called on same Path\n-                    let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n-                    let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,\n-                    iter_path.segments == len_path.segments\n-                 ], {\n-                     span_lint(cx,\n-                               RANGE_ZIP_WITH_LEN,\n-                               expr.span,\n-                               &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                        snippet(cx, iter_args[0].span, \"_\")));\n-                }}\n+                    if let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node;\n+                    if let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node;\n+                    if iter_path.segments == len_path.segments;\n+                     then {\n+                         span_lint(cx,\n+                                   RANGE_ZIP_WITH_LEN,\n+                                   expr.span,\n+                                   &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                            snippet(cx, iter_args[0].span, \"_\")));\n+                    }\n+                }\n             }\n         }\n \n         // exclusive range plus one: x..(y+1)\n-        if_let_chain! {[\n-            let Some(higher::Range { start, end: Some(end), limits: RangeLimits::HalfOpen }) = higher::range(expr),\n-            let Some(y) = y_plus_one(end),\n-        ], {\n-            span_lint_and_then(\n-                cx,\n-                RANGE_PLUS_ONE,\n-                expr.span,\n-                \"an inclusive range would be more readable\",\n-                |db| {\n-                    let start = start.map_or(\"\".to_owned(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                    let end = Sugg::hir(cx, y, \"y\");\n-                    db.span_suggestion(expr.span,\n-                                       \"use\",\n-                                       format!(\"{}..={}\", start, end));\n-                },\n-            );\n-        }}\n+        if_chain! {\n+            if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::HalfOpen }) = higher::range(expr);\n+            if let Some(y) = y_plus_one(end);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    RANGE_PLUS_ONE,\n+                    expr.span,\n+                    \"an inclusive range would be more readable\",\n+                    |db| {\n+                        let start = start.map_or(\"\".to_owned(), |x| Sugg::hir(cx, x, \"x\").to_string());\n+                        let end = Sugg::hir(cx, y, \"y\");\n+                        db.span_suggestion(expr.span,\n+                                           \"use\",\n+                                           format!(\"{}..={}\", start, end));\n+                    },\n+                );\n+            }\n+        }\n \n         // inclusive range minus one: x..=(y-1)\n-        if_let_chain! {[\n-            let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr),\n-            let Some(y) = y_minus_one(end),\n-        ], {\n-            span_lint_and_then(\n-                cx,\n-                RANGE_MINUS_ONE,\n-                expr.span,\n-                \"an exclusive range would be more readable\",\n-                |db| {\n-                    let start = start.map_or(\"\".to_owned(), |x| Sugg::hir(cx, x, \"x\").to_string());\n-                    let end = Sugg::hir(cx, y, \"y\");\n-                    db.span_suggestion(expr.span,\n-                                       \"use\",\n-                                       format!(\"{}..{}\", start, end));\n-                },\n-            );\n-        }}\n+        if_chain! {\n+            if let Some(higher::Range { start, end: Some(end), limits: RangeLimits::Closed }) = higher::range(expr);\n+            if let Some(y) = y_minus_one(end);\n+            then {\n+                span_lint_and_then(\n+                    cx,\n+                    RANGE_MINUS_ONE,\n+                    expr.span,\n+                    \"an exclusive range would be more readable\",\n+                    |db| {\n+                        let start = start.map_or(\"\".to_owned(), |x| Sugg::hir(cx, x, \"x\").to_string());\n+                        let end = Sugg::hir(cx, y, \"y\");\n+                        db.span_suggestion(expr.span,\n+                                           \"use\",\n+                                           format!(\"{}..{}\", start, end));\n+                    },\n+                );\n+            }\n+        }\n     }\n }\n "}, {"sha": "0c125825d8a6164b6d84147d0153fdad4b6ee00e", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 42, "deletions": 39, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -86,22 +86,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n-        if_let_chain!{[\n-            self.last.is_none(),\n-            let Some(ref expr) = block.expr,\n-            match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX),\n-            let Some(span) = is_expn_of(expr.span, \"regex\"),\n-        ], {\n-            if !self.spans.contains(&span) {\n-                span_lint(cx,\n-                          REGEX_MACRO,\n-                          span,\n-                          \"`regex!(_)` found. \\\n-                          Please use `Regex::new(_)`, which is faster for now.\");\n-                self.spans.insert(span);\n+        if_chain! {\n+            if self.last.is_none();\n+            if let Some(ref expr) = block.expr;\n+            if match_type(cx, cx.tables.expr_ty(expr), &paths::REGEX);\n+            if let Some(span) = is_expn_of(expr.span, \"regex\");\n+            then {\n+                if !self.spans.contains(&span) {\n+                    span_lint(cx,\n+                              REGEX_MACRO,\n+                              span,\n+                              \"`regex!(_)` found. \\\n+                              Please use `Regex::new(_)`, which is faster for now.\");\n+                    self.spans.insert(span);\n+                }\n+                self.last = Some(block.id);\n             }\n-            self.last = Some(block.id);\n-        }}\n+        }\n     }\n \n     fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n@@ -111,24 +112,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     }\n \n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n-        if_let_chain!{[\n-            let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(ref qpath) = fun.node,\n-            args.len() == 1,\n-            let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id)),\n-        ], {\n-            if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n-               match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {\n-                check_regex(cx, &args[0], true);\n-            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_NEW) ||\n-               match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n-                check_regex(cx, &args[0], false);\n-            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_SET_NEW) {\n-                check_set(cx, &args[0], true);\n-            } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n-                check_set(cx, &args[0], false);\n+        if_chain! {\n+            if let ExprCall(ref fun, ref args) = expr.node;\n+            if let ExprPath(ref qpath) = fun.node;\n+            if args.len() == 1;\n+            if let Some(def_id) = opt_def_id(cx.tables.qpath_def(qpath, fun.hir_id));\n+            then {\n+                if match_def_path(cx.tcx, def_id, &paths::REGEX_NEW) ||\n+                   match_def_path(cx.tcx, def_id, &paths::REGEX_BUILDER_NEW) {\n+                    check_regex(cx, &args[0], true);\n+                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_NEW) ||\n+                   match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_BUILDER_NEW) {\n+                    check_regex(cx, &args[0], false);\n+                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_SET_NEW) {\n+                    check_set(cx, &args[0], true);\n+                } else if match_def_path(cx.tcx, def_id, &paths::REGEX_BYTES_SET_NEW) {\n+                    check_set(cx, &args[0], false);\n+                }\n             }\n-        }}\n+        }\n     }\n }\n \n@@ -179,14 +181,15 @@ fn is_trivial_regex(s: &regex_syntax::Expr) -> Option<&'static str> {\n }\n \n fn check_set<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {\n-    if_let_chain! {[\n-        let ExprAddrOf(_, ref expr) = expr.node,\n-        let ExprArray(ref exprs) = expr.node,\n-    ], {\n-        for expr in exprs {\n-            check_regex(cx, expr, utf8);\n+    if_chain! {\n+        if let ExprAddrOf(_, ref expr) = expr.node;\n+        if let ExprArray(ref exprs) = expr.node;\n+        then {\n+            for expr in exprs {\n+                check_regex(cx, expr, utf8);\n+            }\n         }\n-    }}\n+    }\n }\n \n fn check_regex<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, utf8: bool) {"}, {"sha": "98027885ccf1e162d99002ccb303339db91f0f4c", "filename": "clippy_lints/src/returns.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Freturns.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -103,28 +103,29 @@ impl ReturnPass {\n         let mut it = block.stmts.iter();\n \n         // we need both a let-binding stmt and an expr\n-        if_let_chain! {[\n-            let Some(retexpr) = it.next_back(),\n-            let ast::StmtKind::Expr(ref retexpr) = retexpr.node,\n-            let Some(stmt) = it.next_back(),\n-            let ast::StmtKind::Local(ref local) = stmt.node,\n+        if_chain! {\n+            if let Some(retexpr) = it.next_back();\n+            if let ast::StmtKind::Expr(ref retexpr) = retexpr.node;\n+            if let Some(stmt) = it.next_back();\n+            if let ast::StmtKind::Local(ref local) = stmt.node;\n             // don't lint in the presence of type inference\n-            local.ty.is_none(),\n-            !local.attrs.iter().any(attr_is_cfg),\n-            let Some(ref initexpr) = local.init,\n-            let ast::PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node,\n-            let ast::ExprKind::Path(_, ref path) = retexpr.node,\n-            match_path_ast(path, &[&id.name.as_str()]),\n-            !in_external_macro(cx, initexpr.span),\n-        ], {\n-                span_note_and_lint(cx,\n-                                   LET_AND_RETURN,\n-                                   retexpr.span,\n-                                   \"returning the result of a let binding from a block. \\\n-                                   Consider returning the expression directly.\",\n-                                   initexpr.span,\n-                                   \"this expression can be directly returned\");\n-        }}\n+            if local.ty.is_none();\n+            if !local.attrs.iter().any(attr_is_cfg);\n+            if let Some(ref initexpr) = local.init;\n+            if let ast::PatKind::Ident(_, Spanned { node: id, .. }, _) = local.pat.node;\n+            if let ast::ExprKind::Path(_, ref path) = retexpr.node;\n+            if match_path_ast(path, &[&id.name.as_str()]);\n+            if !in_external_macro(cx, initexpr.span);\n+            then {\n+                    span_note_and_lint(cx,\n+                                       LET_AND_RETURN,\n+                                       retexpr.span,\n+                                       \"returning the result of a let binding from a block. \\\n+                                       Consider returning the expression directly.\",\n+                                       initexpr.span,\n+                                       \"this expression can be directly returned\");\n+            }\n+        }\n     }\n }\n "}, {"sha": "6497bb9b443a78028b75ee824c693b9c39cd09e4", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 100, "deletions": 98, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -59,120 +59,122 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n /// Implementation of the `MANUAL_SWAP` lint.\n fn check_manual_swap(cx: &LateContext, block: &Block) {\n     for w in block.stmts.windows(3) {\n-        if_let_chain!{[\n+        if_chain! {\n             // let t = foo();\n-            let StmtDecl(ref tmp, _) = w[0].node,\n-            let DeclLocal(ref tmp) = tmp.node,\n-            let Some(ref tmp_init) = tmp.init,\n-            let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node,\n+            if let StmtDecl(ref tmp, _) = w[0].node;\n+            if let DeclLocal(ref tmp) = tmp.node;\n+            if let Some(ref tmp_init) = tmp.init;\n+            if let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node;\n \n             // foo() = bar();\n-            let StmtSemi(ref first, _) = w[1].node,\n-            let ExprAssign(ref lhs1, ref rhs1) = first.node,\n+            if let StmtSemi(ref first, _) = w[1].node;\n+            if let ExprAssign(ref lhs1, ref rhs1) = first.node;\n \n             // bar() = t;\n-            let StmtSemi(ref second, _) = w[2].node,\n-            let ExprAssign(ref lhs2, ref rhs2) = second.node,\n-            let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node,\n-            rhs2.segments.len() == 1,\n-\n-            tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),\n-            SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1),\n-            SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2)\n-        ], {\n-            fn check_for_slice<'a>(\n-                cx: &LateContext,\n-                lhs1: &'a Expr,\n-                lhs2: &'a Expr,\n-            ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n-                if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n-                    if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n-                        if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n-                            let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n-\n-                            if matches!(ty.sty, ty::TySlice(_)) ||\n-                                matches!(ty.sty, ty::TyArray(_, _)) ||\n-                                match_type(cx, ty, &paths::VEC) ||\n-                                match_type(cx, ty, &paths::VEC_DEQUE) {\n-                                    return Some((lhs1, idx1, idx2));\n+            if let StmtSemi(ref second, _) = w[2].node;\n+            if let ExprAssign(ref lhs2, ref rhs2) = second.node;\n+            if let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node;\n+            if rhs2.segments.len() == 1;\n+\n+            if tmp_name.node.as_str() == rhs2.segments[0].name.as_str();\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(tmp_init, lhs1);\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(rhs1, lhs2);\n+            then {\n+                fn check_for_slice<'a>(\n+                    cx: &LateContext,\n+                    lhs1: &'a Expr,\n+                    lhs2: &'a Expr,\n+                ) -> Option<(&'a Expr, &'a Expr, &'a Expr)> {\n+                    if let ExprIndex(ref lhs1, ref idx1) = lhs1.node {\n+                        if let ExprIndex(ref lhs2, ref idx2) = lhs2.node {\n+                            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, lhs2) {\n+                                let ty = walk_ptrs_ty(cx.tables.expr_ty(lhs1));\n+    \n+                                if matches!(ty.sty, ty::TySlice(_)) ||\n+                                    matches!(ty.sty, ty::TyArray(_, _)) ||\n+                                    match_type(cx, ty, &paths::VEC) ||\n+                                    match_type(cx, ty, &paths::VEC_DEQUE) {\n+                                        return Some((lhs1, idx1, idx2));\n+                                }\n                             }\n                         }\n                     }\n+    \n+                    None\n                 }\n-\n-                None\n-            }\n-\n-            let (replace, what, sugg) = if let Some((slice, idx1, idx2)) = check_for_slice(cx, lhs1, lhs2) {\n-                if let Some(slice) = Sugg::hir_opt(cx, slice) {\n-                    (false,\n-                     format!(\" elements of `{}`\", slice),\n-                     format!(\"{}.swap({}, {})\",\n-                             slice.maybe_par(),\n-                             snippet(cx, idx1.span, \"..\"),\n-                             snippet(cx, idx2.span, \"..\")))\n+    \n+                let (replace, what, sugg) = if let Some((slice, idx1, idx2)) = check_for_slice(cx, lhs1, lhs2) {\n+                    if let Some(slice) = Sugg::hir_opt(cx, slice) {\n+                        (false,\n+                         format!(\" elements of `{}`\", slice),\n+                         format!(\"{}.swap({}, {})\",\n+                                 slice.maybe_par(),\n+                                 snippet(cx, idx1.span, \"..\"),\n+                                 snippet(cx, idx2.span, \"..\")))\n+                    } else {\n+                        (false, \"\".to_owned(), \"\".to_owned())\n+                    }\n+                } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n+                    (true, format!(\" `{}` and `{}`\", first, second),\n+                        format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n                 } else {\n-                    (false, \"\".to_owned(), \"\".to_owned())\n-                }\n-            } else if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n-                (true, format!(\" `{}` and `{}`\", first, second),\n-                    format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n-            } else {\n-                (true, \"\".to_owned(), \"\".to_owned())\n-            };\n-\n-            let span = w[0].span.to(second.span);\n-\n-            span_lint_and_then(cx,\n-                               MANUAL_SWAP,\n-                               span,\n-                               &format!(\"this looks like you are swapping{} manually\", what),\n-                               |db| {\n-                                   if !sugg.is_empty() {\n-                                       db.span_suggestion(span, \"try\", sugg);\n-\n-                                       if replace {\n-                                           db.note(\"or maybe you should use `std::mem::replace`?\");\n+                    (true, \"\".to_owned(), \"\".to_owned())\n+                };\n+    \n+                let span = w[0].span.to(second.span);\n+    \n+                span_lint_and_then(cx,\n+                                   MANUAL_SWAP,\n+                                   span,\n+                                   &format!(\"this looks like you are swapping{} manually\", what),\n+                                   |db| {\n+                                       if !sugg.is_empty() {\n+                                           db.span_suggestion(span, \"try\", sugg);\n+    \n+                                           if replace {\n+                                               db.note(\"or maybe you should use `std::mem::replace`?\");\n+                                           }\n                                        }\n-                                   }\n-                               });\n-        }}\n+                                   });\n+            }\n+        }\n     }\n }\n \n /// Implementation of the `ALMOST_SWAPPED` lint.\n fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n     for w in block.stmts.windows(2) {\n-        if_let_chain!{[\n-            let StmtSemi(ref first, _) = w[0].node,\n-            let StmtSemi(ref second, _) = w[1].node,\n-            !differing_macro_contexts(first.span, second.span),\n-            let ExprAssign(ref lhs0, ref rhs0) = first.node,\n-            let ExprAssign(ref lhs1, ref rhs1) = second.node,\n-            SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n-            SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n-        ], {\n-            let lhs0 = Sugg::hir_opt(cx, lhs0);\n-            let rhs0 = Sugg::hir_opt(cx, rhs0);\n-            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n-                (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n-            } else {\n-                (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n-            };\n-\n-            let span = first.span.to(second.span);\n-\n-            span_lint_and_then(cx,\n-                               ALMOST_SWAPPED,\n-                               span,\n-                               &format!(\"this looks like you are trying to swap{}\", what),\n-                               |db| {\n-                                   if !what.is_empty() {\n-                                       db.span_suggestion(span, \"try\",\n-                                                          format!(\"std::mem::swap({}, {})\", lhs, rhs));\n-                                       db.note(\"or maybe you should use `std::mem::replace`?\");\n-                                   }\n-                               });\n-        }}\n+        if_chain! {\n+            if let StmtSemi(ref first, _) = w[0].node;\n+            if let StmtSemi(ref second, _) = w[1].node;\n+            if !differing_macro_contexts(first.span, second.span);\n+            if let ExprAssign(ref lhs0, ref rhs0) = first.node;\n+            if let ExprAssign(ref lhs1, ref rhs1) = second.node;\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1);\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0);\n+            then {\n+                let lhs0 = Sugg::hir_opt(cx, lhs0);\n+                let rhs0 = Sugg::hir_opt(cx, rhs0);\n+                let (what, lhs, rhs) = if let (Some(first), Some(second)) = (lhs0, rhs0) {\n+                    (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n+                } else {\n+                    (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n+                };\n+    \n+                let span = first.span.to(second.span);\n+    \n+                span_lint_and_then(cx,\n+                                   ALMOST_SWAPPED,\n+                                   span,\n+                                   &format!(\"this looks like you are trying to swap{}\", what),\n+                                   |db| {\n+                                       if !what.is_empty() {\n+                                           db.span_suggestion(span, \"try\",\n+                                                              format!(\"std::mem::swap({}, {})\", lhs, rhs));\n+                                           db.note(\"or maybe you should use `std::mem::replace`?\");\n+                                       }\n+                                   });\n+            }\n+        }\n     }\n }"}, {"sha": "f816ddc464f5c1fa48fc1f2ef312b509943836f6", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -301,14 +301,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n /// lifetime, but it should be rare.\n fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: Ty) -> String {\n     let seg = last_path_segment(path);\n-    if_let_chain!{[\n-        let Some(ref params) = seg.parameters,\n-        !params.parenthesized,\n-        let Some(to_ty) = params.types.get(1),\n-        let TyRptr(_, ref to_ty) = to_ty.node,\n-    ], {\n-        return snippet(cx, to_ty.ty.span, &to_rty.to_string()).to_string();\n-    }}\n+    if_chain! {\n+        if let Some(ref params) = seg.parameters;\n+        if !params.parenthesized;\n+        if let Some(to_ty) = params.types.get(1);\n+        if let TyRptr(_, ref to_ty) = to_ty.node;\n+        then {\n+            return snippet(cx, to_ty.ty.span, &to_rty.to_string()).to_string();\n+        }\n+    }\n \n     to_rty.to_string()\n }"}, {"sha": "96caea5c17dd08da1d8daf5123661d7f671ba227", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 92, "deletions": 88, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -158,21 +158,22 @@ fn check_ty(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool) {\n             if let Some(def_id) = opt_def_id(def) {\n                 if Some(def_id) == cx.tcx.lang_items().owned_box() {\n                     let last = last_path_segment(qpath);\n-                    if_let_chain! {[\n-                        let Some(ref params) = last.parameters,\n-                        !params.parenthesized,\n-                        let Some(vec) = params.types.get(0),\n-                        let TyPath(ref qpath) = vec.node,\n-                        let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(vec.id))),\n-                        match_def_path(cx.tcx, did, &paths::VEC),\n-                    ], {\n-                        span_help_and_lint(cx,\n-                                           BOX_VEC,\n-                                           ast_ty.span,\n-                                           \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n-                                           \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n-                        return; // don't recurse into the type\n-                    }}\n+                    if_chain! {\n+                        if let Some(ref params) = last.parameters;\n+                        if !params.parenthesized;\n+                        if let Some(vec) = params.types.get(0);\n+                        if let TyPath(ref qpath) = vec.node;\n+                        if let Some(did) = opt_def_id(cx.tables.qpath_def(qpath, cx.tcx.hir.node_to_hir_id(vec.id)));\n+                        if match_def_path(cx.tcx, did, &paths::VEC);\n+                        then {\n+                            span_help_and_lint(cx,\n+                                               BOX_VEC,\n+                                               ast_ty.span,\n+                                               \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n+                                               \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n+                            return; // don't recurse into the type\n+                        }\n+                    }\n                 } else if match_def_path(cx.tcx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(\n                         cx,\n@@ -227,39 +228,40 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n         TyPath(ref qpath) => {\n             let hir_id = cx.tcx.hir.node_to_hir_id(mut_ty.ty.id);\n             let def = cx.tables.qpath_def(qpath, hir_id);\n-            if_let_chain! {[\n-                let Some(def_id) = opt_def_id(def),\n-                Some(def_id) == cx.tcx.lang_items().owned_box(),\n-                let QPath::Resolved(None, ref path) = *qpath,\n-                let [ref bx] = *path.segments,\n-                let Some(ref params) = bx.parameters,\n-                !params.parenthesized,\n-                let [ref inner] = *params.types\n-            ], {\n-                if is_any_trait(inner) {\n-                    // Ignore `Box<Any>` types, see #1884 for details.\n-                    return;\n+            if_chain! {\n+                if let Some(def_id) = opt_def_id(def);\n+                if Some(def_id) == cx.tcx.lang_items().owned_box();\n+                if let QPath::Resolved(None, ref path) = *qpath;\n+                if let [ref bx] = *path.segments;\n+                if let Some(ref params) = bx.parameters;\n+                if !params.parenthesized;\n+                if let [ref inner] = *params.types;\n+                then {\n+                    if is_any_trait(inner) {\n+                        // Ignore `Box<Any>` types, see #1884 for details.\n+                        return;\n+                    }\n+    \n+                    let ltopt = if lt.is_elided() {\n+                        \"\".to_owned()\n+                    } else {\n+                        format!(\"{} \", lt.name.name().as_str())\n+                    };\n+                    let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n+                        \"mut \"\n+                    } else {\n+                        \"\"\n+                    };\n+                    span_lint_and_sugg(cx,\n+                        BORROWED_BOX,\n+                        ast_ty.span,\n+                        \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n+                        \"try\",\n+                        format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n+                    );\n+                    return; // don't recurse into the type\n                 }\n-\n-                let ltopt = if lt.is_elided() {\n-                    \"\".to_owned()\n-                } else {\n-                    format!(\"{} \", lt.name.name().as_str())\n-                };\n-                let mutopt = if mut_ty.mutbl == Mutability::MutMutable {\n-                    \"mut \"\n-                } else {\n-                    \"\"\n-                };\n-                span_lint_and_sugg(cx,\n-                    BORROWED_BOX,\n-                    ast_ty.span,\n-                    \"you seem to be trying to use `&Box<T>`. Consider using just `&T`\",\n-                    \"try\",\n-                    format!(\"&{}{}{}\", ltopt, mutopt, &snippet(cx, inner.span, \"..\"))\n-                );\n-                return; // don't recurse into the type\n-            }};\n+            };\n             check_ty(cx, &mut_ty.ty, is_local);\n         },\n         _ => check_ty(cx, &mut_ty.ty, is_local),\n@@ -268,15 +270,16 @@ fn check_ty_rptr(cx: &LateContext, ast_ty: &hir::Ty, is_local: bool, lt: &Lifeti\n \n // Returns true if given type is `Any` trait.\n fn is_any_trait(t: &hir::Ty) -> bool {\n-    if_let_chain! {[\n-        let TyTraitObject(ref traits, _) = t.node,\n-        traits.len() >= 1,\n+    if_chain! {\n+        if let TyTraitObject(ref traits, _) = t.node;\n+        if traits.len() >= 1;\n         // Only Send/Sync can be used as additional traits, so it is enough to\n         // check only the first trait.\n-        match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT)\n-    ], {\n-        return true;\n-    }}\n+        if match_path(&traits[0].trait_ref.path, &paths::ANY_TRAIT);\n+        then {\n+            return true;\n+        }\n+    }\n \n     false\n }\n@@ -1719,43 +1722,44 @@ impl<'a, 'b, 'tcx: 'a + 'b> Visitor<'tcx> for ImplicitHasherConstructorVisitor<'\n     }\n \n     fn visit_expr(&mut self, e: &'tcx Expr) {\n-        if_let_chain!{[\n-            let ExprCall(ref fun, ref args) = e.node,\n-            let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node,\n-            let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node,\n-        ], {\n-            if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n-                return;\n-            }\n-\n-            if match_path(ty_path, &paths::HASHMAP) {\n-                if method.name == \"new\" {\n-                    self.suggestions\n-                        .insert(e.span, \"HashMap::default()\".to_string());\n-                } else if method.name == \"with_capacity\" {\n-                    self.suggestions.insert(\n-                        e.span,\n-                        format!(\n-                            \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n-                            snippet(self.cx, args[0].span, \"capacity\"),\n-                        ),\n-                    );\n+        if_chain! {\n+            if let ExprCall(ref fun, ref args) = e.node;\n+            if let ExprPath(QPath::TypeRelative(ref ty, ref method)) = fun.node;\n+            if let TyPath(QPath::Resolved(None, ref ty_path)) = ty.node;\n+            then {\n+                if !same_tys(self.cx, self.target.ty(), self.body.expr_ty(e)) {\n+                    return;\n                 }\n-            } else if match_path(ty_path, &paths::HASHSET) {\n-                if method.name == \"new\" {\n-                    self.suggestions\n-                        .insert(e.span, \"HashSet::default()\".to_string());\n-                } else if method.name == \"with_capacity\" {\n-                    self.suggestions.insert(\n-                        e.span,\n-                        format!(\n-                            \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n-                            snippet(self.cx, args[0].span, \"capacity\"),\n-                        ),\n-                    );\n+    \n+                if match_path(ty_path, &paths::HASHMAP) {\n+                    if method.name == \"new\" {\n+                        self.suggestions\n+                            .insert(e.span, \"HashMap::default()\".to_string());\n+                    } else if method.name == \"with_capacity\" {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashMap::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n+                } else if match_path(ty_path, &paths::HASHSET) {\n+                    if method.name == \"new\" {\n+                        self.suggestions\n+                            .insert(e.span, \"HashSet::default()\".to_string());\n+                    } else if method.name == \"with_capacity\" {\n+                        self.suggestions.insert(\n+                            e.span,\n+                            format!(\n+                                \"HashSet::with_capacity_and_hasher({}, Default::default())\",\n+                                snippet(self.cx, args[0].span, \"capacity\"),\n+                            ),\n+                        );\n+                    }\n                 }\n             }\n-        }}\n+        }\n \n         walk_expr(self, e);\n     }"}, {"sha": "985b52b4f5359b5f484d9f61451efde63725ebce", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -54,26 +54,27 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n         if in_macro(item.span) {\n             return;\n         }\n-        if_let_chain!([\n-            let ItemImpl(.., ref item_type, ref refs) = item.node,\n-            let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node,\n-        ], {\n-            let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n-            let should_check = if let Some(ref params) = *parameters {\n-                !params.parenthesized && params.lifetimes.len() == 0 \n-            } else {\n-                true\n-            };\n-            if should_check {\n-                let visitor = &mut UseSelfVisitor {\n-                    item_path: item_path,\n-                    cx: cx,\n+        if_chain! {\n+            if let ItemImpl(.., ref item_type, ref refs) = item.node;\n+            if let Ty_::TyPath(QPath::Resolved(_, ref item_path)) = item_type.node;\n+            then {\n+                let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).parameters;\n+                let should_check = if let Some(ref params) = *parameters {\n+                    !params.parenthesized && params.lifetimes.len() == 0 \n+                } else {\n+                    true\n                 };\n-                for impl_item_ref in refs {\n-                    visitor.visit_impl_item(cx.tcx.hir.impl_item(impl_item_ref.id));\n+                if should_check {\n+                    let visitor = &mut UseSelfVisitor {\n+                        item_path: item_path,\n+                        cx: cx,\n+                    };\n+                    for impl_item_ref in refs {\n+                        visitor.visit_impl_item(cx.tcx.hir.impl_item(impl_item_ref.id));\n+                    }\n                 }\n             }\n-        })\n+        }\n     }\n }\n "}, {"sha": "a4bdcd152904eda1c942a446ac11fdbe77c9ab16", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 69, "deletions": 67, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -28,15 +28,16 @@ use std::collections::HashMap;\n /// prints\n ///\n /// ```\n-/// if_let_chain!{[\n-///     let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n-///     let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n-///     let Expr_::ExprPath(ref path) = left.node,\n-///     let Expr_::ExprLit(ref lit) = right.node,\n-///     let LitKind::Int(42, _) = lit.node,\n-/// ], {\n-///     // report your lint here\n-/// }}\n+/// if_chain!{\n+///     if let Expr_::ExprIf(ref cond, ref then, None) = item.node,\n+///     if let Expr_::ExprBinary(BinOp::Eq, ref left, ref right) = cond.node,\n+///     if let Expr_::ExprPath(ref path) = left.node,\n+///     if let Expr_::ExprLit(ref lit) = right.node,\n+///     if let LitKind::Int(42, _) = lit.node,\n+///     then {\n+///         // report your lint here\n+///     }\n+/// }\n /// ```\n declare_lint! {\n     pub LINT_AUTHOR,\n@@ -53,13 +54,14 @@ impl LintPass for Pass {\n }\n \n fn prelude() {\n-    println!(\"if_let_chain!{{[\");\n+    println!(\"if_chain! {{\");\n }\n \n fn done() {\n-    println!(\"], {{\");\n-    println!(\"    // report your lint here\");\n-    println!(\"}}}}\");\n+    println!(\"    then {{\");\n+    println!(\"        // report your lint here\");\n+    println!(\"    }}\");\n+    println!(\"}}\");\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n@@ -181,36 +183,36 @@ struct PrintVisitor {\n \n impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     fn visit_expr(&mut self, expr: &Expr) {\n-        print!(\"    let Expr_::Expr\");\n+        print!(\"    if let Expr_::Expr\");\n         let current = format!(\"{}.node\", self.current);\n         match expr.node {\n             Expr_::ExprBox(ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"Box(ref {}) = {},\", inner_pat, current);\n+                println!(\"Box(ref {}) = {};\", inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprArray(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n-                println!(\"Array(ref {}) = {},\", elements_pat, current);\n-                println!(\"    {}.len() == {},\", elements_pat, elements.len());\n+                println!(\"Array(ref {}) = {};\", elements_pat, current);\n+                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n                 }\n             },\n             Expr_::ExprCall(ref _func, ref _args) => {\n-                println!(\"Call(ref func, ref args) = {},\", current);\n+                println!(\"Call(ref func, ref args) = {};\", current);\n                 println!(\"    // unimplemented: `ExprCall` is not further destructured at the moment\");\n             },\n             Expr_::ExprMethodCall(ref _method_name, ref _generics, ref _args) => {\n-                println!(\"MethodCall(ref method_name, ref generics, ref args) = {},\", current);\n+                println!(\"MethodCall(ref method_name, ref generics, ref args) = {};\", current);\n                 println!(\"    // unimplemented: `ExprMethodCall` is not further destructured at the moment\");\n             },\n             Expr_::ExprTup(ref elements) => {\n                 let elements_pat = self.next(\"elements\");\n-                println!(\"Tup(ref {}) = {},\", elements_pat, current);\n-                println!(\"    {}.len() == {},\", elements_pat, elements.len());\n+                println!(\"Tup(ref {}) = {};\", elements_pat, current);\n+                println!(\"    if {}.len() == {};\", elements_pat, elements.len());\n                 for (i, element) in elements.iter().enumerate() {\n                     self.current = format!(\"{}[{}]\", elements_pat, i);\n                     self.visit_expr(element);\n@@ -220,51 +222,51 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let left_pat = self.next(\"left\");\n                 let right_pat = self.next(\"right\");\n-                println!(\"Binary(ref {}, ref {}, ref {}) = {},\", op_pat, left_pat, right_pat, current);\n-                println!(\"    BinOp_::{:?} == {}.node,\", op.node, op_pat);\n+                println!(\"Binary(ref {}, ref {}, ref {}) = {};\", op_pat, left_pat, right_pat, current);\n+                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = left_pat;\n                 self.visit_expr(left);\n                 self.current = right_pat;\n                 self.visit_expr(right);\n             },\n             Expr_::ExprUnary(ref op, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"Unary(UnOp::{:?}, ref {}) = {},\", op, inner_pat, current);\n+                println!(\"Unary(UnOp::{:?}, ref {}) = {};\", op, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprLit(ref lit) => {\n                 let lit_pat = self.next(\"lit\");\n-                println!(\"Lit(ref {}) = {},\", lit_pat, current);\n+                println!(\"Lit(ref {}) = {};\", lit_pat, current);\n                 match lit.node {\n-                    LitKind::Bool(val) => println!(\"    let LitKind::Bool({:?}) = {}.node,\", val, lit_pat),\n-                    LitKind::Char(c) => println!(\"    let LitKind::Char({:?}) = {}.node,\", c, lit_pat),\n-                    LitKind::Byte(b) => println!(\"    let LitKind::Byte({}) = {}.node,\", b, lit_pat),\n+                    LitKind::Bool(val) => println!(\"    if let LitKind::Bool({:?}) = {}.node;\", val, lit_pat),\n+                    LitKind::Char(c) => println!(\"    if let LitKind::Char({:?}) = {}.node;\", c, lit_pat),\n+                    LitKind::Byte(b) => println!(\"    if let LitKind::Byte({}) = {}.node;\", b, lit_pat),\n                     // FIXME: also check int type\n-                    LitKind::Int(i, _) => println!(\"    let LitKind::Int({}, _) = {}.node,\", i, lit_pat),\n-                    LitKind::Float(..) => println!(\"    let LitKind::Float(..) = {}.node,\", lit_pat),\n-                    LitKind::FloatUnsuffixed(_) => println!(\"    let LitKind::FloatUnsuffixed(_) = {}.node,\", lit_pat),\n+                    LitKind::Int(i, _) => println!(\"    if let LitKind::Int({}, _) = {}.node;\", i, lit_pat),\n+                    LitKind::Float(..) => println!(\"    if let LitKind::Float(..) = {}.node;\", lit_pat),\n+                    LitKind::FloatUnsuffixed(_) => println!(\"    if let LitKind::FloatUnsuffixed(_) = {}.node;\", lit_pat),\n                     LitKind::ByteStr(ref vec) => {\n                         let vec_pat = self.next(\"vec\");\n-                        println!(\"    let LitKind::ByteStr(ref {}) = {}.node,\", vec_pat, lit_pat);\n-                        println!(\"    let [{:?}] = **{},\", vec, vec_pat);\n+                        println!(\"    if let LitKind::ByteStr(ref {}) = {}.node;\", vec_pat, lit_pat);\n+                        println!(\"    if let [{:?}] = **{};\", vec, vec_pat);\n                     },\n                     LitKind::Str(ref text, _) => {\n                         let str_pat = self.next(\"s\");\n-                        println!(\"    let LitKind::Str(ref {}) = {}.node,\", str_pat, lit_pat);\n-                        println!(\"    {}.as_str() == {:?}\", str_pat, &*text.as_str())\n+                        println!(\"    if let LitKind::Str(ref {}) = {}.node;\", str_pat, lit_pat);\n+                        println!(\"    if {}.as_str() == {:?}\", str_pat, &*text.as_str())\n                     },\n                 }\n             },\n             Expr_::ExprCast(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n-                println!(\"Cast(ref {}, _) = {},\", cast_pat, current);\n+                println!(\"Cast(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n             Expr_::ExprType(ref expr, ref _ty) => {\n                 let cast_pat = self.next(\"expr\");\n-                println!(\"Type(ref {}, _) = {},\", cast_pat, current);\n+                println!(\"Type(ref {}, _) = {};\", cast_pat, current);\n                 self.current = cast_pat;\n                 self.visit_expr(expr);\n             },\n@@ -273,49 +275,49 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let then_pat = self.next(\"then\");\n                 if let Some(ref else_) = *opt_else {\n                     let else_pat = self.next(\"else_\");\n-                    println!(\"If(ref {}, ref {}, Some(ref {})) = {},\", cond_pat, then_pat, else_pat, current);\n+                    println!(\"If(ref {}, ref {}, Some(ref {})) = {};\", cond_pat, then_pat, else_pat, current);\n                     self.current = else_pat;\n                     self.visit_expr(else_);\n                 } else {\n-                    println!(\"If(ref {}, ref {}, None) = {},\", cond_pat, then_pat, current);\n+                    println!(\"If(ref {}, ref {}, None) = {};\", cond_pat, then_pat, current);\n                 }\n                 self.current = cond_pat;\n                 self.visit_expr(cond);\n                 self.current = then_pat;\n                 self.visit_expr(then);\n             },\n             Expr_::ExprWhile(ref _cond, ref _body, ref _opt_label) => {\n-                println!(\"While(ref cond, ref body, ref opt_label) = {},\", current);\n+                println!(\"While(ref cond, ref body, ref opt_label) = {};\", current);\n                 println!(\"    // unimplemented: `ExprWhile` is not further destructured at the moment\");\n             },\n             Expr_::ExprLoop(ref _body, ref _opt_label, ref _desuraging) => {\n-                println!(\"Loop(ref body, ref opt_label, ref desugaring) = {},\", current);\n+                println!(\"Loop(ref body, ref opt_label, ref desugaring) = {};\", current);\n                 println!(\"    // unimplemented: `ExprLoop` is not further destructured at the moment\");\n             },\n             Expr_::ExprMatch(ref _expr, ref _arms, ref _desugaring) => {\n-                println!(\"Match(ref expr, ref arms, ref desugaring) = {},\", current);\n+                println!(\"Match(ref expr, ref arms, ref desugaring) = {};\", current);\n                 println!(\"    // unimplemented: `ExprMatch` is not further destructured at the moment\");\n             },\n             Expr_::ExprClosure(ref _capture_clause, ref _func, _, _, _) => {\n-                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {},\", current);\n+                println!(\"Closure(ref capture_clause, ref func, _, _, _) = {};\", current);\n                 println!(\"    // unimplemented: `ExprClosure` is not further destructured at the moment\");\n             },\n             Expr_::ExprYield(ref sub) => {\n                 let sub_pat = self.next(\"sub\");\n-                println!(\"Yield(ref sub) = {},\", current);\n+                println!(\"Yield(ref sub) = {};\", current);\n                 self.current = sub_pat;\n                 self.visit_expr(sub);\n             },\n             Expr_::ExprBlock(ref block) => {\n                 let block_pat = self.next(\"block\");\n-                println!(\"Block(ref {}) = {},\", block_pat, current);\n+                println!(\"Block(ref {}) = {};\", block_pat, current);\n                 self.current = block_pat;\n                 self.visit_block(block);\n             },\n             Expr_::ExprAssign(ref target, ref value) => {\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n-                println!(\"Assign(ref {}, ref {}) = {},\", target_pat, value_pat, current);\n+                println!(\"Assign(ref {}, ref {}) = {};\", target_pat, value_pat, current);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n@@ -325,8 +327,8 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 let op_pat = self.next(\"op\");\n                 let target_pat = self.next(\"target\");\n                 let value_pat = self.next(\"value\");\n-                println!(\"AssignOp(ref {}, ref {}, ref {}) = {},\", op_pat, target_pat, value_pat, current);\n-                println!(\"    BinOp_::{:?} == {}.node,\", op.node, op_pat);\n+                println!(\"AssignOp(ref {}, ref {}, ref {}) = {};\", op_pat, target_pat, value_pat, current);\n+                println!(\"    if BinOp_::{:?} == {}.node;\", op.node, op_pat);\n                 self.current = target_pat;\n                 self.visit_expr(target);\n                 self.current = value_pat;\n@@ -335,67 +337,67 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n             Expr_::ExprField(ref object, ref field_name) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_name_pat = self.next(\"field_name\");\n-                println!(\"Field(ref {}, ref {}) = {},\", obj_pat, field_name_pat, current);\n-                println!(\"    {}.node.as_str() == {:?}\", field_name_pat, field_name.node.as_str());\n+                println!(\"Field(ref {}, ref {}) = {};\", obj_pat, field_name_pat, current);\n+                println!(\"    if {}.node.as_str() == {:?}\", field_name_pat, field_name.node.as_str());\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n             Expr_::ExprTupField(ref object, ref field_id) => {\n                 let obj_pat = self.next(\"object\");\n                 let field_id_pat = self.next(\"field_id\");\n-                println!(\"TupField(ref {}, ref {}) = {},\", obj_pat, field_id_pat, current);\n-                println!(\"    {}.node == {}\", field_id_pat, field_id.node);\n+                println!(\"TupField(ref {}, ref {}) = {};\", obj_pat, field_id_pat, current);\n+                println!(\"    if {}.node == {}\", field_id_pat, field_id.node);\n                 self.current = obj_pat;\n                 self.visit_expr(object);\n             },\n             Expr_::ExprIndex(ref object, ref index) => {\n                 let object_pat = self.next(\"object\");\n                 let index_pat = self.next(\"index\");\n-                println!(\"Index(ref {}, ref {}) = {},\", object_pat, index_pat, current);\n+                println!(\"Index(ref {}, ref {}) = {};\", object_pat, index_pat, current);\n                 self.current = object_pat;\n                 self.visit_expr(object);\n                 self.current = index_pat;\n                 self.visit_expr(index);\n             },\n             Expr_::ExprPath(ref path) => {\n                 let path_pat = self.next(\"path\");\n-                println!(\"Path(ref {}) = {},\", path_pat, current);\n+                println!(\"Path(ref {}) = {};\", path_pat, current);\n                 self.current = path_pat;\n                 self.visit_qpath(path, expr.id, expr.span);\n             },\n             Expr_::ExprAddrOf(mutability, ref inner) => {\n                 let inner_pat = self.next(\"inner\");\n-                println!(\"AddrOf({:?}, ref {}) = {},\", mutability, inner_pat, current);\n+                println!(\"AddrOf({:?}, ref {}) = {};\", mutability, inner_pat, current);\n                 self.current = inner_pat;\n                 self.visit_expr(inner);\n             },\n             Expr_::ExprBreak(ref _destination, ref opt_value) => {\n                 let destination_pat = self.next(\"destination\");\n                 if let Some(ref value) = *opt_value {\n                     let value_pat = self.next(\"value\");\n-                    println!(\"Break(ref {}, Some(ref {})) = {},\", destination_pat, value_pat, current);\n+                    println!(\"Break(ref {}, Some(ref {})) = {};\", destination_pat, value_pat, current);\n                     self.current = value_pat;\n                     self.visit_expr(value);\n                 } else {\n-                    println!(\"Break(ref {}, None) = {},\", destination_pat, current);\n+                    println!(\"Break(ref {}, None) = {};\", destination_pat, current);\n                 }\n                 // FIXME: implement label printing\n             },\n             Expr_::ExprAgain(ref _destination) => {\n                 let destination_pat = self.next(\"destination\");\n-                println!(\"Again(ref {}) = {},\", destination_pat, current);\n+                println!(\"Again(ref {}) = {};\", destination_pat, current);\n                 // FIXME: implement label printing\n             },\n             Expr_::ExprRet(ref opt_value) => if let Some(ref value) = *opt_value {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Ret(Some(ref {})) = {},\", value_pat, current);\n+                println!(\"Ret(Some(ref {})) = {};\", value_pat, current);\n                 self.current = value_pat;\n                 self.visit_expr(value);\n             } else {\n-                println!(\"Ret(None) = {},\", current);\n+                println!(\"Ret(None) = {};\", current);\n             },\n             Expr_::ExprInlineAsm(_, ref _input, ref _output) => {\n-                println!(\"InlineAsm(_, ref input, ref output) = {},\", current);\n+                println!(\"InlineAsm(_, ref input, ref output) = {};\", current);\n                 println!(\"    // unimplemented: `ExprInlineAsm` is not further destructured at the moment\");\n             },\n             Expr_::ExprStruct(ref path, ref fields, ref opt_base) => {\n@@ -404,7 +406,7 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                 if let Some(ref base) = *opt_base {\n                     let base_pat = self.next(\"base\");\n                     println!(\n-                        \"Struct(ref {}, ref {}, Some(ref {})) = {},\",\n+                        \"Struct(ref {}, ref {}, Some(ref {})) = {};\",\n                         path_pat,\n                         fields_pat,\n                         base_pat,\n@@ -413,17 +415,17 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n                     self.current = base_pat;\n                     self.visit_expr(base);\n                 } else {\n-                    println!(\"Struct(ref {}, ref {}, None) = {},\", path_pat, fields_pat, current);\n+                    println!(\"Struct(ref {}, ref {}, None) = {};\", path_pat, fields_pat, current);\n                 }\n                 self.current = path_pat;\n                 self.visit_qpath(path, expr.id, expr.span);\n-                println!(\"    {}.len() == {},\", fields_pat, fields.len());\n+                println!(\"    if {}.len() == {};\", fields_pat, fields.len());\n                 println!(\"    // unimplemented: field checks\");\n             },\n             // FIXME: compute length (needs type info)\n             Expr_::ExprRepeat(ref value, _) => {\n                 let value_pat = self.next(\"value\");\n-                println!(\"Repeat(ref {}, _) = {},\", value_pat, current);\n+                println!(\"Repeat(ref {}, _) = {};\", value_pat, current);\n                 println!(\"// unimplemented: repeat count check\");\n                 self.current = value_pat;\n                 self.visit_expr(value);\n@@ -432,9 +434,9 @@ impl<'tcx> Visitor<'tcx> for PrintVisitor {\n     }\n \n     fn visit_qpath(&mut self, path: &QPath, _: NodeId, _: Span) {\n-        print!(\"    match_qpath({}, &[\", self.current);\n+        print!(\"    if match_qpath({}, &[\", self.current);\n         print_path(path, &mut true);\n-        println!(\"]),\");\n+        println!(\"]);\");\n     }\n     fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n         NestedVisitorMap::None"}, {"sha": "93afb449cf64a59631d14ae573db5c730abf2aaf", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 55, "deletions": 50, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -120,13 +120,14 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     //   // do stuff\n     // }\n     // ```\n-    if_let_chain! {[\n-        let hir::DeclLocal(ref loc) = decl.node,\n-        let Some(ref expr) = loc.init,\n-        let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node,\n-    ], {\n-        return true;\n-    }}\n+    if_chain! {\n+        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let Some(ref expr) = loc.init;\n+        if let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        then {\n+            return true;\n+        }\n+    }\n \n     // This detects a variable binding in for loop to avoid `let_unit_value`\n     // lint (see issue #1964).\n@@ -136,32 +137,34 @@ pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n     //   // anything\n     // }\n     // ```\n-    if_let_chain! {[\n-        let hir::DeclLocal(ref loc) = decl.node,\n-        let hir::LocalSource::ForLoopDesugar = loc.source,\n-    ], {\n-        return true;\n-    }}\n+    if_chain! {\n+        if let hir::DeclLocal(ref loc) = decl.node;\n+        if let hir::LocalSource::ForLoopDesugar = loc.source;\n+        then {\n+            return true;\n+        }\n+    }\n \n     false\n }\n \n /// Recover the essential nodes of a desugared for loop:\n /// `for pat in arg { body }` becomes `(pat, arg, body)`.\n pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n-    if_let_chain! {[\n-        let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node,\n-        let hir::ExprCall(_, ref iterargs) = iterexpr.node,\n-        iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n-        let hir::ExprLoop(ref block, _, _) = arms[0].body.node,\n-        block.expr.is_none(),\n-        let [ _, _, ref let_stmt, ref body ] = *block.stmts,\n-        let hir::StmtDecl(ref decl, _) = let_stmt.node,\n-        let hir::DeclLocal(ref decl) = decl.node,\n-        let hir::StmtExpr(ref expr, _) = body.node,\n-    ], {\n-        return Some((&*decl.pat, &iterargs[0], expr));\n-    }}\n+    if_chain! {\n+        if let hir::ExprMatch(ref iterexpr, ref arms, hir::MatchSource::ForLoopDesugar) = expr.node;\n+        if let hir::ExprCall(_, ref iterargs) = iterexpr.node;\n+        if iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none();\n+        if let hir::ExprLoop(ref block, _, _) = arms[0].body.node;\n+        if block.expr.is_none();\n+        if let [ _, _, ref let_stmt, ref body ] = *block.stmts;\n+        if let hir::StmtDecl(ref decl, _) = let_stmt.node;\n+        if let hir::DeclLocal(ref decl) = decl.node;\n+        if let hir::StmtExpr(ref expr, _) = body.node;\n+        then {\n+            return Some((&*decl.pat, &iterargs[0], expr));\n+        }\n+    }\n     None\n }\n \n@@ -176,31 +179,33 @@ pub enum VecArgs<'a> {\n /// Returns the arguments of the `vec!` macro if this expression was expanded\n /// from `vec!`.\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n-    if_let_chain!{[\n-        let hir::ExprCall(ref fun, ref args) = expr.node,\n-        let hir::ExprPath(ref path) = fun.node,\n-        is_expn_of(fun.span, \"vec\").is_some(),\n-        let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id)),\n-    ], {\n-        return if match_def_path(cx.tcx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n-            // `vec![elem; size]` case\n-            Some(VecArgs::Repeat(&args[0], &args[1]))\n-        }\n-        else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n-            // `vec![a, b, c]` case\n-            if_let_chain!{[\n-                let hir::ExprBox(ref boxed) = args[0].node,\n-                let hir::ExprArray(ref args) = boxed.node\n-            ], {\n-                return Some(VecArgs::Vec(&*args));\n-            }}\n-\n-            None\n+    if_chain! {\n+        if let hir::ExprCall(ref fun, ref args) = expr.node;\n+        if let hir::ExprPath(ref path) = fun.node;\n+        if is_expn_of(fun.span, \"vec\").is_some();\n+        if let Some(fun_def_id) = opt_def_id(resolve_node(cx, path, fun.hir_id));\n+        then {\n+            return if match_def_path(cx.tcx, fun_def_id, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+                // `vec![elem; size]` case\n+                Some(VecArgs::Repeat(&args[0], &args[1]))\n+            }\n+            else if match_def_path(cx.tcx, fun_def_id, &paths::SLICE_INTO_VEC) && args.len() == 1 {\n+                // `vec![a, b, c]` case\n+                if_chain! {\n+                    if let hir::ExprBox(ref boxed) = args[0].node;\n+                    if let hir::ExprArray(ref args) = boxed.node;\n+                    then {\n+                        return Some(VecArgs::Vec(&*args));\n+                    }\n+                }\n+    \n+                None\n+            }\n+            else {\n+                None\n+            };\n         }\n-        else {\n-            None\n-        };\n-    }}\n+    }\n \n     None\n }"}, {"sha": "e0ed668945805fc8ab132327353c5415bcacb5c0", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 29, "deletions": 83, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -37,63 +37,6 @@ pub use self::hir_utils::{SpanlessEq, SpanlessHash};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n-/// Produce a nested chain of if-lets and ifs from the patterns:\n-///\n-/// ```rust,ignore\n-/// if_let_chain! {[\n-///     let Some(y) = x,\n-///     y.len() == 2,\n-///     let Some(z) = y,\n-/// ], {\n-///     block\n-/// }}\n-/// ```\n-///\n-/// becomes\n-///\n-/// ```rust,ignore\n-/// if let Some(y) = x {\n-///     if y.len() == 2 {\n-///         if let Some(z) = y {\n-///             block\n-///         }\n-///     }\n-/// }\n-/// ```\n-#[macro_export]\n-macro_rules! if_let_chain {\n-    ([let $pat:pat = $expr:expr, $($tt:tt)+], $block:block) => {\n-        if let $pat = $expr {\n-           if_let_chain!{ [$($tt)+], $block }\n-        }\n-    };\n-    ([let $pat:pat = $expr:expr], $block:block) => {\n-        if let $pat = $expr {\n-           $block\n-        }\n-    };\n-    ([let $pat:pat = $expr:expr,], $block:block) => {\n-        if let $pat = $expr {\n-           $block\n-        }\n-    };\n-    ([$expr:expr, $($tt:tt)+], $block:block) => {\n-        if $expr {\n-           if_let_chain!{ [$($tt)+], $block }\n-        }\n-    };\n-    ([$expr:expr], $block:block) => {\n-        if $expr {\n-           $block\n-        }\n-    };\n-    ([$expr:expr,], $block:block) => {\n-        if $expr {\n-           $block\n-        }\n-    };\n-}\n-\n pub mod higher;\n \n /// Returns true if the two spans come from differing expansions (i.e. one is\n@@ -1004,13 +947,14 @@ pub fn is_self(slf: &Arg) -> bool {\n }\n \n pub fn is_self_ty(slf: &hir::Ty) -> bool {\n-    if_let_chain! {[\n-        let TyPath(ref qp) = slf.node,\n-        let QPath::Resolved(None, ref path) = *qp,\n-        let Def::SelfTy(..) = path.def,\n-    ], {\n-        return true\n-    }}\n+    if_chain! {\n+        if let TyPath(ref qp) = slf.node;\n+        if let QPath::Resolved(None, ref path) = *qp;\n+        if let Def::SelfTy(..) = path.def;\n+        then {\n+            return true\n+        }\n+    }\n     false\n }\n \n@@ -1022,16 +966,17 @@ pub fn iter_input_pats<'tcx>(decl: &FnDecl, body: &'tcx Body) -> impl Iterator<I\n /// expanded from `?` operator or `try` macro.\n pub fn is_try(expr: &Expr) -> Option<&Expr> {\n     fn is_ok(arm: &Arm) -> bool {\n-        if_let_chain! {[\n-            let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node,\n-            match_qpath(path, &paths::RESULT_OK[1..]),\n-            let PatKind::Binding(_, defid, _, None) = pat[0].node,\n-            let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node,\n-            let Def::Local(lid) = path.def,\n-            lid == defid,\n-        ], {\n-            return true;\n-        }}\n+        if_chain! {\n+            if let PatKind::TupleStruct(ref path, ref pat, None) = arm.pats[0].node;\n+            if match_qpath(path, &paths::RESULT_OK[1..]);\n+            if let PatKind::Binding(_, defid, _, None) = pat[0].node;\n+            if let ExprPath(QPath::Resolved(None, ref path)) = arm.body.node;\n+            if let Def::Local(lid) = path.def;\n+            if lid == defid;\n+            then {\n+                return true;\n+            }\n+        }\n         false\n     }\n \n@@ -1049,15 +994,16 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n             return Some(expr);\n         }\n \n-        if_let_chain! {[\n-            arms.len() == 2,\n-            arms[0].pats.len() == 1 && arms[0].guard.is_none(),\n-            arms[1].pats.len() == 1 && arms[1].guard.is_none(),\n-            (is_ok(&arms[0]) && is_err(&arms[1])) ||\n-                (is_ok(&arms[1]) && is_err(&arms[0])),\n-        ], {\n-            return Some(expr);\n-        }}\n+        if_chain! {\n+            if arms.len() == 2;\n+            if arms[0].pats.len() == 1 && arms[0].guard.is_none();\n+            if arms[1].pats.len() == 1 && arms[1].guard.is_none();\n+            if (is_ok(&arms[0]) && is_err(&arms[1])) ||\n+                (is_ok(&arms[1]) && is_err(&arms[0]));\n+            then {\n+                return Some(expr);\n+            }\n+        }\n     }\n \n     None"}, {"sha": "90a6896b348f09286c0d2e00863887e70726d340", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -35,25 +35,27 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n-        if_let_chain!{[\n-            let ty::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty,\n-            let ty::TySlice(..) = ty.ty.sty,\n-            let ExprAddrOf(_, ref addressee) = expr.node,\n-            let Some(vec_args) = higher::vec_macro(cx, addressee),\n-        ], {\n-            check_vec_macro(cx, &vec_args, expr.span);\n-        }}\n+        if_chain! {\n+            if let ty::TyRef(_, ref ty) = cx.tables.expr_ty_adjusted(expr).sty;\n+            if let ty::TySlice(..) = ty.ty.sty;\n+            if let ExprAddrOf(_, ref addressee) = expr.node;\n+            if let Some(vec_args) = higher::vec_macro(cx, addressee);\n+            then {\n+                check_vec_macro(cx, &vec_args, expr.span);\n+            }\n+        }\n \n         // search for `for _ in vec![\u2026]`\n-        if_let_chain!{[\n-            let Some((_, arg, _)) = higher::for_loop(expr),\n-            let Some(vec_args) = higher::vec_macro(cx, arg),\n-            is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg))),\n-        ], {\n-            // report the error around the `vec!` not inside `<std macros>:`\n-            let span = arg.span.ctxt().outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n-            check_vec_macro(cx, &vec_args, span);\n-        }}\n+        if_chain! {\n+            if let Some((_, arg, _)) = higher::for_loop(expr);\n+            if let Some(vec_args) = higher::vec_macro(cx, arg);\n+            if is_copy(cx, vec_type(cx.tables.expr_ty_adjusted(arg)));\n+            then {\n+                // report the error around the `vec!` not inside `<std macros>:`\n+                let span = arg.span.ctxt().outer().expn_info().map(|info| info.call_site).expect(\"unable to get call_site\");\n+                check_vec_macro(cx, &vec_args, span);\n+            }\n+        }\n     }\n }\n "}, {"sha": "313af61bf15b5fc7a2140228124a51be5f7dc5ed", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -31,27 +31,28 @@ impl LintPass for Pass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n-        if_let_chain! {[\n-            let ExprBinary(ref op, ref left, ref right) = expr.node,\n-            let BinOp_::BiDiv = op.node,\n+        if_chain! {\n+            if let ExprBinary(ref op, ref left, ref right) = expr.node;\n+            if let BinOp_::BiDiv = op.node;\n             // TODO - constant_simple does not fold many operations involving floats.\n             // That's probably fine for this lint - it's pretty unlikely that someone would\n             // do something like 0.0/(2.0 - 2.0), but it would be nice to warn on that case too.\n-            let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left),\n-            let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right),\n-            Ok(0.0) == lhs_value.parse(),\n-            Ok(0.0) == rhs_value.parse()\n-        ], {\n-            // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n-            // match the precision of the literals that are given.\n-            let float_type = match (lhs_width, rhs_width) {\n-                (FloatWidth::F64, _)\n-                | (_, FloatWidth::F64) => \"f64\",\n-                _ => \"f32\"\n-            };\n-            span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n-                \"constant division of 0.0 with 0.0 will always result in NaN\",\n-                &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n-        }}\n+            if let Some(Constant::Float(ref lhs_value, lhs_width)) = constant_simple(cx, left);\n+            if let Some(Constant::Float(ref rhs_value, rhs_width)) = constant_simple(cx, right);\n+            if Ok(0.0) == lhs_value.parse();\n+            if Ok(0.0) == rhs_value.parse();\n+            then {\n+                // since we're about to suggest a use of std::f32::NaN or std::f64::NaN,\n+                // match the precision of the literals that are given.\n+                let float_type = match (lhs_width, rhs_width) {\n+                    (FloatWidth::F64, _)\n+                    | (_, FloatWidth::F64) => \"f64\",\n+                    _ => \"f32\"\n+                };\n+                span_help_and_lint(cx, ZERO_DIVIDED_BY_ZERO, expr.span,\n+                    \"constant division of 0.0 with 0.0 will always result in NaN\",\n+                    &format!(\"Consider using `std::{}::NAN` if you would like a constant representing NaN\", float_type));\n+            }\n+        }\n     }\n }"}, {"sha": "145c102ed95b1631fd2146cc595e29d2a59d9930", "filename": "tests/ui/trailing_zeros.stdout", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/tests%2Fui%2Ftrailing_zeros.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/f9682ca563ad9ec6bc2da520ad92970d30d5c1e0/tests%2Fui%2Ftrailing_zeros.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftrailing_zeros.stdout?ref=f9682ca563ad9ec6bc2da520ad92970d30d5c1e0", "patch": "@@ -1,14 +1,15 @@\n-if_let_chain!{[\n-    let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node,\n-    BinOp_::BiEq == op.node,\n-    let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node,\n-    BinOp_::BiBitAnd == op1.node,\n-    let Expr_::ExprPath(ref path) = left1.node,\n-    match_qpath(path, &[\"x\"]),\n-    let Expr_::ExprLit(ref lit) = right1.node,\n-    let LitKind::Int(15, _) = lit.node,\n-    let Expr_::ExprLit(ref lit1) = right.node,\n-    let LitKind::Int(0, _) = lit1.node,\n-], {\n-    // report your lint here\n-}}\n+if_chain! {\n+    if let Expr_::ExprBinary(ref op, ref left, ref right) = expr.node;\n+    if BinOp_::BiEq == op.node;\n+    if let Expr_::ExprBinary(ref op1, ref left1, ref right1) = left.node;\n+    if BinOp_::BiBitAnd == op1.node;\n+    if let Expr_::ExprPath(ref path) = left1.node;\n+    if match_qpath(path, &[\"x\"]);\n+    if let Expr_::ExprLit(ref lit) = right1.node;\n+    if let LitKind::Int(15, _) = lit.node;\n+    if let Expr_::ExprLit(ref lit1) = right.node;\n+    if let LitKind::Int(0, _) = lit1.node;\n+    then {\n+        // report your lint here\n+    }\n+}"}]}