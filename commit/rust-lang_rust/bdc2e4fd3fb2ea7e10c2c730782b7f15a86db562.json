{"sha": "bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYzJlNGZkM2ZiMmVhN2UxMGMyYzczMDc4MmI3ZjE1YTg2ZGI1NjI=", "commit": {"author": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-11-20T20:58:39Z"}, "committer": {"name": "Marcus Klaas de Vries", "email": "mail@marcusklaas.nl", "date": "2015-11-20T20:58:39Z"}, "message": "Merge pull request #603 from marcusklaas/multiline-math-armz\n\nWrap/unwrap match arms", "tree": {"sha": "1f6b770a035cb9218c14fd80d4fe40c38ab51254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f6b770a035cb9218c14fd80d4fe40c38ab51254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "html_url": "https://github.com/rust-lang/rust/commit/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc76558910b0eb8917e7e20a79a0080aa75a1b73", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc76558910b0eb8917e7e20a79a0080aa75a1b73", "html_url": "https://github.com/rust-lang/rust/commit/bc76558910b0eb8917e7e20a79a0080aa75a1b73"}, {"sha": "9fe3c08abcd4c1817525ef9fc49d0d9b0a052908", "url": "https://api.github.com/repos/rust-lang/rust/commits/9fe3c08abcd4c1817525ef9fc49d0d9b0a052908", "html_url": "https://github.com/rust-lang/rust/commit/9fe3c08abcd4c1817525ef9fc49d0d9b0a052908"}], "stats": {"total": 483, "additions": 258, "deletions": 225}, "files": [{"sha": "04251d09c747b68f1bf1fd0d9f0d047297ce032f", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -118,9 +118,7 @@ fn execute() -> i32 {\n         Operation::Stdin(input, write_mode) => {\n             // try to read config from local directory\n             let config = match lookup_and_read_project_file(&Path::new(\".\")) {\n-                Ok((_, toml)) => {\n-                    Config::from_toml(&toml)\n-                }\n+                Ok((_, toml)) => Config::from_toml(&toml),\n                 Err(_) => Default::default(),\n             };\n "}, {"sha": "665fb5ac0739e36f3db8747218ded4aae099edec", "filename": "src/chains.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -21,7 +21,7 @@\n \n use Indent;\n use rewrite::{Rewrite, RewriteContext};\n-use utils::first_line_width;\n+use utils::{wrap_str, first_line_width};\n use expr::rewrite_call;\n use config::BlockIndentStyle;\n \n@@ -58,12 +58,8 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n     } else {\n         match context.config.chain_indent {\n             BlockIndentStyle::Inherit => (context.block_indent, false),\n-            BlockIndentStyle::Tabbed => {\n-                (context.block_indent.block_indent(context.config), false)\n-            }\n-            BlockIndentStyle::Visual => {\n-                (offset + Indent::new(context.config.tab_spaces, 0), false)\n-            }\n+            BlockIndentStyle::Tabbed => (context.block_indent.block_indent(context.config), false),\n+            BlockIndentStyle::Visual => (offset + Indent::new(context.config.tab_spaces, 0), false),\n         }\n     };\n \n@@ -142,10 +138,13 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n         &connector[..]\n     };\n \n-    Some(format!(\"{}{}{}\",\n-                 parent_rewrite,\n-                 first_connector,\n-                 rewrites.join(&connector)))\n+    wrap_str(format!(\"{}{}{}\",\n+                     parent_rewrite,\n+                     first_connector,\n+                     rewrites.join(&connector)),\n+             context.config.max_width,\n+             width,\n+             offset)\n }\n \n // States whether an expression's last line exclusively consists of closing\n@@ -171,13 +170,9 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n \n fn pop_expr_chain<'a>(expr: &'a ast::Expr) -> Option<&'a ast::Expr> {\n     match expr.node {\n-        ast::Expr_::ExprMethodCall(_, _, ref expressions) => {\n-            Some(&expressions[0])\n-        }\n+        ast::Expr_::ExprMethodCall(_, _, ref expressions) => Some(&expressions[0]),\n         ast::Expr_::ExprTupField(ref subexpr, _) |\n-        ast::Expr_::ExprField(ref subexpr, _) => {\n-            Some(subexpr)\n-        }\n+        ast::Expr_::ExprField(ref subexpr, _) => Some(subexpr),\n         _ => None,\n     }\n }\n@@ -199,12 +194,8 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                                 width,\n                                 offset)\n         }\n-        ast::Expr_::ExprField(_, ref field) => {\n-            Some(format!(\".{}\", field.node))\n-        }\n-        ast::Expr_::ExprTupField(_, ref field) => {\n-            Some(format!(\".{}\", field.node))\n-        }\n+        ast::Expr_::ExprField(_, ref field) => Some(format!(\".{}\", field.node)),\n+        ast::Expr_::ExprTupField(_, ref field) => Some(format!(\".{}\", field.node)),\n         _ => unreachable!(),\n     }\n }"}, {"sha": "0f118ca5d294a72cc64201d7d9a3d49836538eaa", "filename": "src/comment.rs", "status": "modified", "additions": 39, "deletions": 29, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -127,12 +127,14 @@ impl FindUncommented for str {\n                 None => {\n                     return Some(i - pat.len());\n                 }\n-                Some(c) => match kind {\n-                    CodeCharKind::Normal if b == c => {}\n-                    _ => {\n-                        needle_iter = pat.chars();\n+                Some(c) => {\n+                    match kind {\n+                        CodeCharKind::Normal if b == c => {}\n+                        _ => {\n+                            needle_iter = pat.chars();\n+                        }\n                     }\n-                },\n+                }\n             }\n         }\n \n@@ -233,33 +235,39 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n         let item = try_opt!(self.base.next());\n         let chr = item.get_char();\n         self.status = match self.status {\n-            CharClassesStatus::LitString => match chr {\n-                '\"' => CharClassesStatus::Normal,\n-                '\\\\' => CharClassesStatus::LitStringEscape,\n-                _ => CharClassesStatus::LitString,\n-            },\n+            CharClassesStatus::LitString => {\n+                match chr {\n+                    '\"' => CharClassesStatus::Normal,\n+                    '\\\\' => CharClassesStatus::LitStringEscape,\n+                    _ => CharClassesStatus::LitString,\n+                }\n+            }\n             CharClassesStatus::LitStringEscape => CharClassesStatus::LitString,\n-            CharClassesStatus::LitChar => match chr {\n-                '\\\\' => CharClassesStatus::LitCharEscape,\n-                '\\'' => CharClassesStatus::Normal,\n-                _ => CharClassesStatus::LitChar,\n-            },\n+            CharClassesStatus::LitChar => {\n+                match chr {\n+                    '\\\\' => CharClassesStatus::LitCharEscape,\n+                    '\\'' => CharClassesStatus::Normal,\n+                    _ => CharClassesStatus::LitChar,\n+                }\n+            }\n             CharClassesStatus::LitCharEscape => CharClassesStatus::LitChar,\n             CharClassesStatus::Normal => {\n                 match chr {\n                     '\"' => CharClassesStatus::LitString,\n                     '\\'' => CharClassesStatus::LitChar,\n-                    '/' => match self.base.peek() {\n-                        Some(next) if next.get_char() == '*' => {\n-                            self.status = CharClassesStatus::BlockCommentOpening(1);\n-                            return Some((CodeCharKind::Comment, item));\n-                        }\n-                        Some(next) if next.get_char() == '/' => {\n-                            self.status = CharClassesStatus::LineComment;\n-                            return Some((CodeCharKind::Comment, item));\n+                    '/' => {\n+                        match self.base.peek() {\n+                            Some(next) if next.get_char() == '*' => {\n+                                self.status = CharClassesStatus::BlockCommentOpening(1);\n+                                return Some((CodeCharKind::Comment, item));\n+                            }\n+                            Some(next) if next.get_char() == '/' => {\n+                                self.status = CharClassesStatus::LineComment;\n+                                return Some((CodeCharKind::Comment, item));\n+                            }\n+                            _ => CharClassesStatus::Normal,\n                         }\n-                        _ => CharClassesStatus::Normal,\n-                    },\n+                    }\n                     _ => CharClassesStatus::Normal,\n                 }\n             }\n@@ -271,10 +279,12 @@ impl<T> Iterator for CharClasses<T> where T: Iterator, T::Item: RichChar {\n                     return Some((CodeCharKind::Comment, item));\n                 }\n                 self.status = match self.base.peek() {\n-                    Some(next) if next.get_char() == '/' && chr == '*' =>\n-                        CharClassesStatus::BlockCommentClosing(deepness - 1),\n-                    Some(next) if next.get_char() == '*' && chr == '/' =>\n-                        CharClassesStatus::BlockCommentOpening(deepness + 1),\n+                    Some(next) if next.get_char() == '/' && chr == '*' => {\n+                        CharClassesStatus::BlockCommentClosing(deepness - 1)\n+                    }\n+                    Some(next) if next.get_char() == '*' && chr == '/' => {\n+                        CharClassesStatus::BlockCommentOpening(deepness + 1)\n+                    }\n                     _ => CharClassesStatus::BlockComment(deepness),\n                 };\n                 return Some((CodeCharKind::Comment, item));"}, {"sha": "c02d618437fa3620648a893630191b0babf2ccfe", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -307,4 +307,5 @@ create_config! {\n     take_source_hints: bool, true, \"Retain some formatting characteristics from the source code\";\n     hard_tabs: bool, false, \"Use tab characters for indentation, spaces for alignment\";\n     wrap_comments: bool, false, \"Break comments to fit on the line\";\n+    wrap_match_arms: bool, true, \"Wrap multiline match arms in blocks\";\n }"}, {"sha": "29d6d32c0dd47af356b37729bda312504daea07d", "filename": "src/expr.rs", "status": "modified", "additions": 60, "deletions": 58, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -58,9 +58,7 @@ impl Rewrite for ast::Expr {\n                 let inner_span = mk_sp(callee.span.hi, self.span.hi);\n                 rewrite_call(context, &**callee, args, inner_span, width, offset)\n             }\n-            ast::Expr_::ExprParen(ref subexpr) => {\n-                rewrite_paren(context, subexpr, width, offset)\n-            }\n+            ast::Expr_::ExprParen(ref subexpr) => rewrite_paren(context, subexpr, width, offset),\n             ast::Expr_::ExprBinary(ref op, ref lhs, ref rhs) => {\n                 rewrite_binary_op(context, op, lhs, rhs, width, offset)\n             }\n@@ -91,9 +89,7 @@ impl Rewrite for ast::Expr {\n             ast::Expr_::ExprLoop(ref block, label) => {\n                 Loop::new_loop(block, label).rewrite(context, width, offset)\n             }\n-            ast::Expr_::ExprBlock(ref block) => {\n-                block.rewrite(context, width, offset)\n-            }\n+            ast::Expr_::ExprBlock(ref block) => block.rewrite(context, width, offset),\n             ast::Expr_::ExprIf(ref cond, ref if_block, ref else_block) => {\n                 rewrite_if_else(context,\n                                 cond,\n@@ -145,9 +141,7 @@ impl Rewrite for ast::Expr {\n             }\n             ast::Expr_::ExprField(..) |\n             ast::Expr_::ExprTupField(..) |\n-            ast::Expr_::ExprMethodCall(..) => {\n-                rewrite_chain(self, context, width, offset)\n-            }\n+            ast::Expr_::ExprMethodCall(..) => rewrite_chain(self, context, width, offset),\n             ast::Expr_::ExprMac(ref mac) => {\n                 // Failure to rewrite a marco should not imply failure to\n                 // rewrite the expression.\n@@ -571,13 +565,15 @@ impl<'a> Rewrite for Loop<'a> {\n         let inner_offset = offset + self.keyword.len() + label_string.len();\n \n         let pat_expr_string = match self.cond {\n-            Some(cond) => try_opt!(rewrite_pat_expr(context,\n-                                                    self.pat,\n-                                                    cond,\n-                                                    self.matcher,\n-                                                    self.connector,\n-                                                    inner_width,\n-                                                    inner_offset)),\n+            Some(cond) => {\n+                try_opt!(rewrite_pat_expr(context,\n+                                          self.pat,\n+                                          cond,\n+                                          self.matcher,\n+                                          self.connector,\n+                                          inner_width,\n+                                          inner_offset))\n+            }\n             None => String::new(),\n         };\n \n@@ -711,6 +707,8 @@ fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n }\n \n // Checks that a block contains no statements, an expression and no comments.\n+// FIXME: incorrectly returns false when comment is contained completely within\n+// the expression.\n pub fn is_simple_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n     block.stmts.is_empty() && block.expr.is_some() && !block_contains_comment(block, codemap)\n }\n@@ -726,6 +724,14 @@ pub fn is_empty_block(block: &ast::Block, codemap: &CodeMap) -> bool {\n     block.stmts.is_empty() && block.expr.is_none() && !block_contains_comment(block, codemap)\n }\n \n+fn is_unsafe_block(block: &ast::Block) -> bool {\n+    if let ast::BlockCheckMode::UnsafeBlock(..) = block.rules {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n // inter-match-arm-comment-rules:\n //  - all comments following a match arm before the start of the next arm\n //    are about the second arm\n@@ -907,7 +913,7 @@ impl Rewrite for ast::Arm {\n         }\n \n         let pats_width = if vertical {\n-            pat_strs[pat_strs.len() - 1].len()\n+            pat_strs.last().unwrap().len()\n         } else {\n             total_width\n         };\n@@ -934,65 +940,62 @@ impl Rewrite for ast::Arm {\n             line_start += offset.width();\n         }\n \n+        let body = match **body {\n+            ast::Expr { node: ast::ExprBlock(ref block), .. } if !is_unsafe_block(block) &&\n+                                                                 is_simple_block(block,\n+                                                                                 context.codemap) &&\n+                                                                 context.config.wrap_match_arms => {\n+                block.expr.as_ref().map(|e| &**e).unwrap()\n+            }\n+            ref x => x,\n+        };\n+\n         let comma = arm_comma(body);\n \n         // Let's try and get the arm body on the same line as the condition.\n         // 4 = ` => `.len()\n-        let same_line_body = if context.config.max_width > line_start + comma.len() + 4 {\n+        if context.config.max_width > line_start + comma.len() + 4 {\n             let budget = context.config.max_width - line_start - comma.len() - 4;\n             let offset = Indent::new(offset.block_indent, line_start + 4 - offset.block_indent);\n             let rewrite = nop_block_collapse(body.rewrite(context, budget, offset), budget);\n \n             match rewrite {\n-                Some(ref body_str) if body_str.len() <= budget || comma.is_empty() =>\n+                Some(ref body_str) if !body_str.contains('\\n') || !context.config.wrap_match_arms ||\n+                                      comma.is_empty() => {\n                     return Some(format!(\"{}{} => {}{}\",\n                                         attr_str.trim_left(),\n                                         pats_str,\n                                         body_str,\n-                                        comma)),\n-                _ => rewrite,\n+                                        comma));\n+                }\n+                _ => {}\n             }\n-        } else {\n-            None\n-        };\n-\n-        if let ast::ExprBlock(_) = body.node {\n-            // We're trying to fit a block in, but it still failed, give up.\n-            return None;\n         }\n \n+        // FIXME: we're doing a second rewrite of the expr; This may not be\n+        // necessary.\n         let body_budget = try_opt!(width.checked_sub(context.config.tab_spaces));\n         let indent = context.block_indent.block_indent(context.config);\n         let inner_context = &RewriteContext { block_indent: indent, ..*context };\n-        let next_line_body = nop_block_collapse(body.rewrite(inner_context, body_budget, indent),\n-                                                body_budget);\n-\n-        let body_str = try_opt!(match_arm_heuristic(same_line_body.as_ref().map(|x| &x[..]),\n-                                                    next_line_body.as_ref().map(|x| &x[..])));\n-\n-        let spacer = match same_line_body {\n-            Some(ref body) if body == body_str => \" \".to_owned(),\n-            _ => format!(\"\\n{}\",\n-                         offset.block_indent(context.config).to_string(context.config)),\n+        let next_line_body = try_opt!(nop_block_collapse(body.rewrite(inner_context,\n+                                                                      body_budget,\n+                                                                      indent),\n+                                                         body_budget));\n+        let indent_str = offset.block_indent(context.config).to_string(context.config);\n+        let (body_prefix, body_suffix) = if context.config.wrap_match_arms {\n+            (\" {\", \"}\")\n+        } else {\n+            (\"\", \"\")\n         };\n \n-        Some(format!(\"{}{} =>{}{},\",\n+        Some(format!(\"{}{} =>{}\\n{}{}\\n{}{}\",\n                      attr_str.trim_left(),\n                      pats_str,\n-                     spacer,\n-                     body_str))\n-    }\n-}\n-\n-// Takes two possible rewrites for the match arm body and chooses the \"nicest\".\n-fn match_arm_heuristic<'a>(former: Option<&'a str>, latter: Option<&'a str>) -> Option<&'a str> {\n-    match (former, latter) {\n-        (f @ Some(..), None) => f,\n-        (Some(f), Some(l)) if f.chars().filter(|&c| c == '\\n').count() <=\n-                              l.chars().filter(|&c| c == '\\n').count() => {\n-            Some(f)\n-        }\n-        (_, l) => l,\n+                     body_prefix,\n+                     indent_str,\n+                     next_line_body,\n+                     offset.to_string(context.config),\n+                     body_suffix))\n     }\n }\n \n@@ -1285,9 +1288,7 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n     // Foo { a: Foo } - indent is +3, width is -5.\n     let h_budget = width.checked_sub(path_str.len() + 5).unwrap_or(0);\n     let (indent, v_budget) = match context.config.struct_lit_style {\n-        StructLitStyle::Visual => {\n-            (offset + path_str.len() + 3, h_budget)\n-        }\n+        StructLitStyle::Visual => (offset + path_str.len() + 3, h_budget),\n         StructLitStyle::Block => {\n             // If we are all on one line, then we'll ignore the indent, and we\n             // have a smaller budget.\n@@ -1396,8 +1397,9 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n \n     match (context.config.struct_lit_style,\n            context.config.struct_lit_multiline_style) {\n-        (StructLitStyle::Block, _) if fields_str.contains('\\n') || fields_str.len() > h_budget =>\n-            format_on_newline(),\n+        (StructLitStyle::Block, _) if fields_str.contains('\\n') || fields_str.len() > h_budget => {\n+            format_on_newline()\n+        }\n         (StructLitStyle::Block, MultilineStyle::ForceMulti) => format_on_newline(),\n         _ => Some(format!(\"{} {{ {} }}\", path_str, fields_str)),\n     }"}, {"sha": "42d152fc6ac0b41e8b22aed1cfcb0e9e5a902a18", "filename": "src/imports.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -74,12 +74,8 @@ fn rewrite_single_use_list(path_str: String, vpi: &ast::PathListItem) -> String\n \n fn rewrite_path_item(vpi: &&ast::PathListItem) -> Option<String> {\n     let path_item_str = match vpi.node {\n-        ast::PathListItem_::PathListIdent{ name, .. } => {\n-            name.to_string()\n-        }\n-        ast::PathListItem_::PathListMod{ .. } => {\n-            \"self\".to_owned()\n-        }\n+        ast::PathListItem_::PathListIdent{ name, .. } => name.to_string(),\n+        ast::PathListItem_::PathListMod{ .. } => \"self\".to_owned(),\n     };\n \n     Some(append_alias(path_item_str, vpi))"}, {"sha": "19aec73f1165942fbdd4cc8509e24739c6f897a8", "filename": "src/items.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -564,23 +564,26 @@ impl<'a> FmtVisitor<'a> {\n                                           \")\",\n                                           |arg| {\n                                               match *arg {\n-                                                  ArgumentKind::Regular(arg) =>\n-                                                      span_lo_for_arg(arg),\n+                                                  ArgumentKind::Regular(arg) => {\n+                                                      span_lo_for_arg(arg)\n+                                                  }\n                                                   ArgumentKind::Variadic(start) => start,\n                                               }\n                                           },\n                                           |arg| {\n                                               match *arg {\n                                                   ArgumentKind::Regular(arg) => arg.ty.span.hi,\n-                                                  ArgumentKind::Variadic(start) =>\n-                                                      start + BytePos(3),\n+                                                  ArgumentKind::Variadic(start) => {\n+                                                      start + BytePos(3)\n+                                                  }\n                                               }\n                                           },\n                                           |arg| {\n                                               match *arg {\n                                                   ArgumentKind::Regular(..) => None,\n-                                                  ArgumentKind::Variadic(..) =>\n-                                                      Some(\"...\".to_owned()),\n+                                                  ArgumentKind::Variadic(..) => {\n+                                                      Some(\"...\".to_owned())\n+                                                  }\n                                               }\n                                           },\n                                           comment_span_start,\n@@ -821,9 +824,7 @@ impl<'a> FmtVisitor<'a> {\n                          offset: Indent)\n                          -> Option<String> {\n         match *struct_def {\n-            ast::VariantData::Unit(..) => {\n-                self.format_unit_struct(item_name, ident, vis)\n-            }\n+            ast::VariantData::Unit(..) => self.format_unit_struct(item_name, ident, vis),\n             ast::VariantData::Tuple(ref fields, _) => {\n                 self.format_tuple_struct(item_name, ident, vis, fields, generics, span, offset)\n             }\n@@ -874,12 +875,14 @@ impl<'a> FmtVisitor<'a> {\n                                               offset + header_str.len(),\n                                               mk_sp(span.lo, body_lo)))\n             }\n-            None => if self.config.item_brace_style == BraceStyle::AlwaysNextLine &&\n-                       !fields.is_empty() {\n-                format!(\"\\n{}{{\", self.block_indent.to_string(self.config))\n-            } else {\n-                \" {\".to_owned()\n-            },\n+            None => {\n+                if self.config.item_brace_style == BraceStyle::AlwaysNextLine &&\n+                   !fields.is_empty() {\n+                    format!(\"\\n{}{{\", self.block_indent.to_string(self.config))\n+                } else {\n+                    \" {\".to_owned()\n+                }\n+            }\n         };\n         result.push_str(&generics_str);\n \n@@ -1118,8 +1121,9 @@ impl<'a> FmtVisitor<'a> {\n \n         let extra_indent = match self.config.where_indent {\n             BlockIndentStyle::Inherit => Indent::empty(),\n-            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual =>\n-                Indent::new(config.tab_spaces, 0),\n+            BlockIndentStyle::Tabbed | BlockIndentStyle::Visual => {\n+                Indent::new(config.tab_spaces, 0)\n+            }\n         };\n \n         let context = self.get_context();"}, {"sha": "3923f6b742db3e5bfa98946d76f8b3bdca1c294f", "filename": "src/lib.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -225,15 +225,9 @@ pub enum ErrorKind {\n impl fmt::Display for ErrorKind {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n         match *self {\n-            ErrorKind::LineOverflow => {\n-                write!(fmt, \"line exceeded maximum length\")\n-            }\n-            ErrorKind::TrailingWhitespace => {\n-                write!(fmt, \"left behind trailing whitespace\")\n-            }\n-            ErrorKind::BadIssue(issue) => {\n-                write!(fmt, \"found {}\", issue)\n-            }\n+            ErrorKind::LineOverflow => write!(fmt, \"line exceeded maximum length\"),\n+            ErrorKind::TrailingWhitespace => write!(fmt, \"left behind trailing whitespace\"),\n+            ErrorKind::BadIssue(issue) => write!(fmt, \"found {}\", issue),\n         }\n     }\n }"}, {"sha": "ecde4f19fe44bb3218cda74b0ac98add9cd5a0a8", "filename": "src/lists.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -392,9 +392,7 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n                     match (block_open_index, newline_index) {\n                         // Separator before comment, with the next item on same line.\n                         // Comment belongs to next item.\n-                        (Some(i), None) if i > separator_index => {\n-                            separator_index + 1\n-                        }\n+                        (Some(i), None) if i > separator_index => separator_index + 1,\n                         // Block-style post-comment before the separator.\n                         (Some(i), None) => {\n                             cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,"}, {"sha": "727bc49a7422c2afc39721be04e87f7421eacf70", "filename": "src/missed_spans.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -103,10 +103,12 @@ impl<'a> FmtVisitor<'a> {\n         }\n \n         let replaced = match self.write_mode {\n-            Some(mode) => match mode {\n-                WriteMode::Coverage => replace_chars(old_snippet),\n-                _ => old_snippet.to_owned(),\n-            },\n+            Some(mode) => {\n+                match mode {\n+                    WriteMode::Coverage => replace_chars(old_snippet),\n+                    _ => old_snippet.to_owned(),\n+                }\n+            }\n             None => old_snippet.to_owned(),\n         };\n         let snippet = &*replaced;"}, {"sha": "af0bd8277518d51899ac9c2db19d9f9b4f9d4fe1", "filename": "src/patterns.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -21,9 +21,7 @@ use syntax::ast::{BindingMode, Pat, Pat_};\n impl Rewrite for Pat {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n         match self.node {\n-            Pat_::PatBox(ref pat) => {\n-                rewrite_unary_prefix(context, \"box \", &**pat, width, offset)\n-            }\n+            Pat_::PatBox(ref pat) => rewrite_unary_prefix(context, \"box \", &**pat, width, offset),\n             Pat_::PatIdent(binding_mode, ident, None) => {\n                 let (prefix, mutability) = match binding_mode {\n                     BindingMode::BindByRef(mutability) => (\"ref \", mutability),\n@@ -50,9 +48,7 @@ impl Rewrite for Pat {\n                 let prefix = format!(\"&{}\", format_mutability(mutability));\n                 rewrite_unary_prefix(context, &prefix, &**pat, width, offset)\n             }\n-            Pat_::PatTup(ref items) => {\n-                rewrite_tuple(context, items, self.span, width, offset)\n-            }\n+            Pat_::PatTup(ref items) => rewrite_tuple(context, items, self.span, width, offset),\n             Pat_::PatEnum(ref path, Some(ref pat_vec)) => {\n                 let path_str = try_opt!(::types::rewrite_path(context,\n                                                               true,"}, {"sha": "9e693e9cff6a481ef6392c007505fdb9759f81a3", "filename": "src/types.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -137,9 +137,7 @@ impl<'a> Rewrite for SegmentParam<'a> {\n                          width,\n                          offset)\n             }\n-            SegmentParam::Type(ref ty) => {\n-                ty.rewrite(context, width, offset)\n-            }\n+            SegmentParam::Type(ref ty) => ty.rewrite(context, width, offset),\n             SegmentParam::Binding(ref binding) => {\n                 let mut result = format!(\"{} = \", binding.ident);\n                 let budget = try_opt!(width.checked_sub(result.len()));\n@@ -479,9 +477,7 @@ impl Rewrite for ast::Ty {\n                 let budget = try_opt!(width.checked_sub(2));\n                 ty.rewrite(context, budget, offset + 1).map(|ty_str| format!(\"[{}]\", ty_str))\n             }\n-            ast::TyTup(ref items) => {\n-                rewrite_tuple(context, items, self.span, width, offset)\n-            }\n+            ast::TyTup(ref items) => rewrite_tuple(context, items, self.span, width, offset),\n             ast::TyPolyTraitRef(ref trait_ref) => trait_ref.rewrite(context, width, offset),\n             ast::TyPath(ref q_self, ref path) => {\n                 rewrite_path(context, false, q_self.as_ref(), path, width, offset)"}, {"sha": "37dfb756972548c54e596f648697e03ebbbfa5e6", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -75,9 +75,7 @@ pub fn last_line_width(s: &str) -> usize {\n fn is_skip(meta_item: &MetaItem) -> bool {\n     match meta_item.node {\n         MetaItem_::MetaWord(ref s) => *s == SKIP_ANNOTATION,\n-        MetaItem_::MetaList(ref s, ref l) => {\n-            *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1])\n-        }\n+        MetaItem_::MetaList(ref s, ref l) => *s == \"cfg_attr\" && l.len() == 2 && is_skip(&l[1]),\n         _ => false,\n     }\n }"}, {"sha": "83e0fbbd4509b9b8442bed66e901faa0f6218b6c", "filename": "tests/source/match-nowrap.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsource%2Fmatch-nowrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsource%2Fmatch-nowrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch-nowrap.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -0,0 +1,12 @@\n+// rustfmt-wrap_match_arms: false\n+// Match expressions, no unwrapping of block arms or wrapping of multiline\n+// expressions.\n+\n+fn foo() {\n+    match x {\n+        a => { foo() }\n+        b =>\n+            (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+            bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb),\n+    }\n+}"}, {"sha": "b4d35cb3815438863089a7b7f8b7ec88241f8f86", "filename": "tests/source/match.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsource%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsource%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fmatch.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -11,7 +11,6 @@ fn foo() {\n             an_expression;\n             foo()\n         }\n-        // Perhaps this should introduce braces?\n         Foo(ref bar) =>\n             aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n         Pattern1 | Pattern2 | Pattern3 => false,\n@@ -83,7 +82,11 @@ fn main() {\n                                                 \"scopeid\"),\n                                            true,\n                                            true),\n-    }\n+    };\n+\n+    match  x{\n+    y=>{/*Block with comment. Preserve me.*/  }\n+    z=>{stmt();} }\n }\n \n fn matches() {"}, {"sha": "6d3c817256cae7443c0260d4c1ffa212ff0165eb", "filename": "tests/system.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -249,8 +249,10 @@ fn handle_result(result: HashMap<String, String>,\n fn get_target(file_name: &str, target: Option<&str>, write_mode: WriteMode) -> String {\n     let file_path = Path::new(file_name);\n     let (source_path_prefix, target_path_prefix) = match write_mode {\n-        WriteMode::Coverage => (Path::new(\"tests/coverage-source/\"),\n-                                \"tests/coverage-target/\"),\n+        WriteMode::Coverage => {\n+            (Path::new(\"tests/coverage-source/\"),\n+             \"tests/coverage-target/\")\n+        }\n         _ => (Path::new(\"tests/source/\"), \"tests/target/\"),\n     };\n "}, {"sha": "db2a874c838bcb6c75ba00c9f0f30f703f40ccd0", "filename": "tests/target/match-nowrap.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Ftarget%2Fmatch-nowrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Ftarget%2Fmatch-nowrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch-nowrap.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -0,0 +1,13 @@\n+// rustfmt-wrap_match_arms: false\n+// Match expressions, no unwrapping of block arms or wrapping of multiline\n+// expressions.\n+\n+fn foo() {\n+    match x {\n+        a => {\n+            foo()\n+        }\n+        b => (aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+              bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb),\n+    }\n+}"}, {"sha": "2c238ea8a685ff4214732d0471698017cf7662c5", "filename": "tests/target/match.rs", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Ftarget%2Fmatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562/tests%2Ftarget%2Fmatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fmatch.rs?ref=bdc2e4fd3fb2ea7e10c2c730782b7f15a86db562", "patch": "@@ -12,14 +12,12 @@ fn foo() {\n             an_expression;\n             foo()\n         }\n-        // Perhaps this should introduce braces?\n-        Foo(ref bar) =>\n-            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa,\n+        Foo(ref bar) => {\n+            aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+        }\n         Pattern1 | Pattern2 | Pattern3 => false,\n         Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn |\n-        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n-            blah\n-        }\n+        Paternnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => blah,\n         Patternnnnnnnnnnnnnnnnnnn |\n         Patternnnnnnnnnnnnnnnnnnn |\n         Patternnnnnnnnnnnnnnnnnnn |\n@@ -29,8 +27,9 @@ fn foo() {\n         Patternnnnnnnnnnnnnnnnnnn if looooooooooooooooooong_guard => meh,\n \n         Patternnnnnnnnnnnnnnnnnnnnnnnnn |\n-        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard =>\n-            meh,\n+        Patternnnnnnnnnnnnnnnnnnnnnnnnn if looooooooooooooooooooooooooooooooooooooooong_guard => {\n+            meh\n+        }\n \n         // Test that earlier patterns can take the guard space\n         (aaaa,\n@@ -75,19 +74,33 @@ fn main() {\n // Test that one-line bodies align.\n fn main() {\n     match r {\n-        Variableeeeeeeeeeeeeeeeee => (\"variable\",\n-                                      vec![\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"],\n-                                      true,\n-                                      true),\n-        Enummmmmmmmmmmmmmmmmmmmm => (\"enum\",\n-                                     vec![\"id\", \"qualname\", \"scopeid\", \"value\"],\n-                                     true,\n-                                     true),\n-        Variantttttttttttttttttttttttt =>\n+        Variableeeeeeeeeeeeeeeeee => {\n+            (\"variable\",\n+             vec![\"id\", \"name\", \"qualname\", \"value\", \"type\", \"scopeid\"],\n+             true,\n+             true)\n+        }\n+        Enummmmmmmmmmmmmmmmmmmmm => {\n+            (\"enum\",\n+             vec![\"id\", \"qualname\", \"scopeid\", \"value\"],\n+             true,\n+             true)\n+        }\n+        Variantttttttttttttttttttttttt => {\n             (\"variant\",\n              vec![\"id\", \"name\", \"qualname\", \"type\", \"value\", \"scopeid\"],\n              true,\n-             true),\n+             true)\n+        }\n+    };\n+\n+    match x {\n+        y => {\n+            // Block with comment. Preserve me.\n+        }\n+        z => {\n+            stmt();\n+        }\n     }\n }\n \n@@ -157,15 +170,9 @@ fn issue355() {\n         a => println!(\"a\", b),\n         b => vec![1, 2],\n         c => vec!(3; 4),\n-        d => {\n-            println!(\"a\", b)\n-        }\n-        e => {\n-            vec![1, 2]\n-        }\n-        f => {\n-            vec!(3; 4)\n-        }\n+        d => println!(\"a\", b),\n+        e => vec![1, 2],\n+        f => vec!(3; 4),\n         h => println!(\"a\", b), // h comment\n         i => vec![1, 2], // i comment\n         j => vec!(3; 4), // j comment\n@@ -176,22 +183,28 @@ fn issue355() {\n         // m comment\n         m => vec!(3; 4),\n         // Rewrite splits macro\n-        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn =>\n-            println!(\"a\", b),\n+        nnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnn => {\n+            println!(\"a\", b)\n+        }\n         // Rewrite splits macro\n-        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo =>\n-            vec![1, 2],\n+        oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo => {\n+            vec![1, 2]\n+        }\n         // Macro support fails to recognise this macro as splitable\n         // We push the whole expr to a new line, TODO split this macro as well\n-        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp =>\n-            vec!(3; 4),\n+        pppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppp => {\n+            vec!(3; 4)\n+        }\n         // q, r and s: Rewrite splits match arm\n-        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq =>\n-            println!(\"a\", b),\n-        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr =>\n-            vec![1, 2],\n-        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss =>\n-            vec!(3; 4),\n+        qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqq => {\n+            println!(\"a\", b)\n+        }\n+        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr => {\n+            vec![1, 2]\n+        }\n+        ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssss => {\n+            vec!(3; 4)\n+        }\n         // Funky bracketing styles\n         t => println!{\"a\", b},\n         u => vec![1, 2],\n@@ -206,20 +219,24 @@ fn issue355() {\n         wc => println![\"a\", b], // comment\n         xc => vec![1, 2], // comment\n         yc => vec![3; 4], // comment\n-        yd => looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n-                                                                                bbbbbbbbbb,\n-                                                                                cccccccccc,\n-                                                                                dddddddddd),\n+        yd => {\n+            looooooooooooooooooooooooooooooooooooooooooooooooooooooooong_func(aaaaaaaaaa,\n+                                                                              bbbbbbbbbb,\n+                                                                              cccccccccc,\n+                                                                              dddddddddd)\n+        }\n     }\n }\n \n fn issue280() {\n     {\n         match x {\n-            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline =>\n-                ch == '\\n',\n-            ast::ItemConst(ref typ, ref expr) =>\n-                self.process_static_or_const_item(item, &typ, &expr),\n+            CompressionMode::DiscardNewline | CompressionMode::CompressWhitespaceNewline => {\n+                ch == '\\n'\n+            }\n+            ast::ItemConst(ref typ, ref expr) => {\n+                self.process_static_or_const_item(item, &typ, &expr)\n+            }\n         }\n     }\n }\n@@ -253,12 +270,11 @@ fn issue496() {\n         {\n             {\n                 match def {\n-                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) =>\n+                    def::DefConst(def_id) | def::DefAssociatedConst(def_id) => {\n                         match const_eval::lookup_const_by_id(cx.tcx, def_id, Some(self.pat.id)) {\n-                            Some(const_expr) => {\n-                                x\n-                            }\n-                        },\n+                            Some(const_expr) => x,\n+                        }\n+                    }\n                 }\n             }\n         }\n@@ -268,14 +284,15 @@ fn issue496() {\n fn issue494() {\n     {\n         match stmt.node {\n-            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) =>\n+            hir::StmtExpr(ref expr, id) | hir::StmtSemi(ref expr, id) => {\n                 result.push(StmtRef::Mirror(Box::new(Stmt {\n                     span: stmt.span,\n                     kind: StmtKind::Expr {\n                         scope: cx.tcx.region_maps.node_extent(id),\n                         expr: expr.to_ref(),\n                     },\n-                }))),\n+                })))\n+            }\n         }\n     }\n }"}]}