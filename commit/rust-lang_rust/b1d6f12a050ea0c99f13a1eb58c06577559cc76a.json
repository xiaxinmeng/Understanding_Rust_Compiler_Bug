{"sha": "b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxZDZmMTJhMDUwZWEwYzk5ZjEzYTFlYjU4YzA2NTc3NTU5Y2M3NmE=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-07T20:41:19Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-06-07T20:56:27Z"}, "message": "Don't put a copy of main (the C one) in each binary we produce. This is a step\nin getting a driver that works on all linux systems.\n\nSorry for the linker hacks, I will remove them after snapshotting a new compiler.", "tree": {"sha": "048932bebb544fe8be1f2dfd4a94502e606d54f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/048932bebb544fe8be1f2dfd4a94502e606d54f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "html_url": "https://github.com/rust-lang/rust/commit/b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/comments", "author": null, "committer": null, "parents": [{"sha": "df9cf0be9b898bc3432d444826ff05d6d0e22f97", "url": "https://api.github.com/repos/rust-lang/rust/commits/df9cf0be9b898bc3432d444826ff05d6d0e22f97", "html_url": "https://github.com/rust-lang/rust/commit/df9cf0be9b898bc3432d444826ff05d6d0e22f97"}], "stats": {"total": 143, "additions": 77, "deletions": 66}, "files": [{"sha": "362b97ea03656903c1b31d9d6b07fe6c89eb32a7", "filename": "Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -144,9 +144,9 @@ COMPILER_INPUTS := $(wildcard $(addprefix $(S)src/comp/, \\\n ######################################################################\n \n LREQ := rt/$(CFG_RUNTIME) rustllvm/$(CFG_RUSTLLVM)\n-SREQ0 := stage0/rustc$(X) $(LREQ) stage1/glue.o stage1/$(CFG_STDLIB)\n-SREQ1 := stage1/rustc$(X) $(LREQ) stage2/glue.o stage2/$(CFG_STDLIB)\n-SREQ2 := stage2/rustc$(X) $(LREQ) stage3/glue.o stage3/$(CFG_STDLIB)\n+SREQ0 := stage0/rustc$(X) $(LREQ) rt/main.a stage1/glue.o stage1/$(CFG_STDLIB)\n+SREQ1 := stage1/rustc$(X) $(LREQ) rt/main.a stage2/glue.o stage2/$(CFG_STDLIB)\n+SREQ2 := stage2/rustc$(X) $(LREQ) rt/main.a stage3/glue.o stage3/$(CFG_STDLIB)\n \n \n ######################################################################"}, {"sha": "305b06b5e0a380c8bce53e8d166d004e0a7e9375", "filename": "mk/clean.mk", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -28,6 +28,8 @@ clean:\n \t$(Q)rm -f stage3/rustc$(X) stage3/$(CFG_STDLIB) stage3/glue*\n \t$(Q)rm -f rustllvm/$(CFG_RUSTLLVM) rustllvm/rustllvmbits.a\n \t$(Q)rm -f rt/$(CFG_RUNTIME)\n+\t$(Q)rm -f rt/main.o\n+\t$(Q)rm -f rt/main.a\n \t$(Q)rm -Rf $(PKG_NAME)-*.tar.gz dist\n \t$(Q)rm -f $(foreach ext,o a d bc s exe,$(wildcard stage*/*.$(ext)))\n \t$(Q)rm -Rf $(foreach ext,out out.tmp                      \\"}, {"sha": "1cc6dfb57f45f52d8c813332c63af5e74aaa78a7", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -76,6 +76,18 @@ rt/%.o: rt/%.s $(MKFILES)\n \t@$(call E, compile: $@)\n \t$(Q)$(call CFG_COMPILE_C, $@, $(RUNTIME_INCS)) $<\n \n+ifdef CFG_WINDOWSY\n+rt/main.ll: rt/main.ll.in\n+\tsed 's/MAIN/WinMain@16/' < $^ > $@\n+else\n+rt/main.ll: rt/main.ll.in\n+\tsed 's/MAIN/main/' < $^ > $@\n+endif\n+\n+rt/main.a: rt/main.o\n+\trm -f $@\n+\tar crs $@ $^\n+\n rt/%.o: rt/%.ll $(MKFILES)\n \t@$(call E, llc: $@)\n \t$(Q)$(LLC) -filetype=obj -relocation-model=pic -march=x86 -o $@ $<"}, {"sha": "c98882e41a872649e53351d05e188cbac17ef751", "filename": "mk/stage1.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage1.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage1.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage1.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -44,7 +44,7 @@ stage1/%.o: stage1/%.s\n stage1/%$(X): stage1/%.o  $(SREQ0)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage1 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "0d87400c1e2983e83e101687d0ed051653b7814a", "filename": "mk/stage2.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage2.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage2.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage2.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -44,7 +44,7 @@ stage2/%.o: stage2/%.s\n stage2/%$(X): stage2/%.o  $(SREQ1)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage2 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "77d09440883e750c40c9a453d4f32cf1208d935c", "filename": "mk/stage3.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage3.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Fstage3.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fstage3.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -23,7 +23,7 @@ stage3/rustc.o: $(COMPILER_CRATE) $(COMPILER_INPUTS) $(SREQ2)\n \t$(STAGE2) -c -o $@ $<\n \n stage3/glue.o: stage2/rustc$(X) stage2/$(CFG_STDLIB) stage2/intrinsics.bc \\\n-                rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n+               rustllvm/$(CFG_RUSTLLVM) rt/$(CFG_RUNTIME)\n \t@$(call E, generate: $@)\n \t$(STAGE2) -c -o $@ --glue\n \n@@ -44,7 +44,7 @@ stage3/%.o: stage3/%.s\n stage3/%$(X): stage3/%.o  $(SREQ2)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage3/glue.o -o $@ $< \\\n-      -Lstage3 -Lrustllvm -Lrt -lrustrt -lrustllvm -lstd -lm\n+      -Lstage3 -Lrustllvm -Lrt rt/main.a -lrustrt -lrustllvm -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "db7a3dd4d33cf4c2140a2fe3111fbef46b3ddb5c", "filename": "mk/tests.mk", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -185,7 +185,7 @@ compile-check: tidy \\\n %.stage0$(X): %.stage0.o  $(SREQ0)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage1/glue.o -o $@ $< \\\n-      -Lstage1 -Lrt -lrustrt -lstd -lm\n+      -Lstage1 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -194,7 +194,7 @@ compile-check: tidy \\\n %.stage1$(X): %.stage1.o $(SREQ1)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage2/glue.o -o $@ $< \\\n-      -Lstage2 -Lrt -lrustrt -lstd -lm\n+      -Lstage2 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise.\n@@ -203,7 +203,7 @@ compile-check: tidy \\\n %.stage2$(X): %.stage2.o $(SREQ2)\n \t@$(call E, link [gcc]: $@)\n \t$(Q)gcc $(CFG_GCCISH_CFLAGS) stage3/glue.o -o $@ $< \\\n-      -Lstage3 -Lrt -lrustrt -lstd -lm\n+      -Lstage3 -Lrt rt/main.a -lrustrt -lstd -lm\n \t@# dsymutil sometimes fails or prints a warning, but the\n \t@# program still runs.  Since it simplifies debugging other\n \t@# programs, I\\'ll live with the noise."}, {"sha": "a65b1403b38a8f57e05033e7acea0c14f2c3c302", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 29, "deletions": 56, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -338,6 +338,9 @@ fn get_type_sha1(&@crate_ctxt ccx, &ty::t t) -> str {\n \n fn mangle(&vec[str] ss) -> str {\n \n+    if (vec::len(ss) > 0u && str::eq(vec::top(ss), \"main\")) {\n+        ret \"_rust_main\";\n+    }\n     // Follow C++ namespace-mangling style\n \n     auto n = \"_ZN\"; // Begin name-sequence.\n@@ -369,7 +372,7 @@ fn mangle_name_by_path_and_seq(&@crate_ctxt ccx, &vec[str] path,\n     ret mangle(path + [ccx.names.next(flav)]);\n }\n \n-fn mangle_name_by_path(&@crate_ctxt ccx, &vec[str] path) -> str {\n+fn mangle_name_by_path(&vec[str] path) -> str {\n     ret mangle(path);\n }\n \n@@ -7095,7 +7098,7 @@ fn create_vtbl(@local_ctxt cx,\n \n         let @local_ctxt mcx = @rec(path = cx.path + [\"method\",\n                                                      m.node.ident] with *cx);\n-        let str s = mangle_name_by_path(mcx.ccx, mcx.path);\n+        let str s = mangle_name_by_path(mcx.path);\n         let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s,\n                                                       llfnty);\n         cx.ccx.item_ids.insert(m.node.id, llfn);\n@@ -7107,7 +7110,7 @@ fn create_vtbl(@local_ctxt cx,\n         methods += [llfn];\n     }\n     auto vtbl = C_struct(methods);\n-    auto vtbl_name = mangle_name_by_path(cx.ccx, cx.path + [\"vtbl\"]);\n+    auto vtbl_name = mangle_name_by_path(cx.path + [\"vtbl\"]);\n     auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, val_ty(vtbl),\n                                    str::buf(vtbl_name));\n     llvm::LLVMSetInitializer(gvar, vtbl);\n@@ -7124,7 +7127,7 @@ fn trans_dtor(@local_ctxt cx,\n               &@ast::method dtor) -> ValueRef {\n \n     auto llfnty = T_dtor(cx.ccx, dtor.span, llself_ty);\n-    let str s = mangle_name_by_path(cx.ccx, cx.path + [\"drop\"]);\n+    let str s = mangle_name_by_path(cx.path + [\"drop\"]);\n     let ValueRef llfn = decl_internal_fastcall_fn(cx.ccx.llmod, s, llfnty);\n     cx.ccx.item_ids.insert(dtor.node.id, llfn);\n     cx.ccx.item_symbols.insert(dtor.node.id, s);\n@@ -7518,7 +7521,7 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n     }\n \n     // Declare the function itself.\n-    let str s = mangle_name_by_path(ccx, path);\n+    let str s = mangle_name_by_path(path);\n     let ValueRef llfn = decl_internal_fastcall_fn(ccx.llmod, s, llfty);\n \n     // Declare the global constant pair that points to it.\n@@ -7532,6 +7535,8 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n             ccx.sess.span_err(sp, \"multiple 'main' functions\");\n         }\n         log #fmt(\"registering %s as main function for crate\", ps);\n+        llvm::LLVMSetLinkage(llfn, lib::llvm::LLVMExternalLinkage\n+                             as llvm::Linkage);\n         ccx.main_fn = some(llfn);\n     }\n }\n@@ -7593,7 +7598,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n     // Declare the wrapper.\n     auto t = node_ann_type(ccx, ann);\n     auto wrapper_type = native_fn_wrapper_type(ccx, sp, num_ty_param, t);\n-    let str s = mangle_name_by_path(ccx, path);\n+    let str s = mangle_name_by_path(path);\n     let ValueRef wrapper_fn = decl_internal_fastcall_fn(ccx.llmod, s,\n                                                         wrapper_type);\n \n@@ -7996,51 +8001,6 @@ fn create_typedefs(&@crate_ctxt cx) {\n     llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn trans_main_fn(@local_ctxt cx, ValueRef crate_map) {\n-    auto T_main_args = [T_int(), T_int()];\n-    auto T_rust_start_args = [T_int(), T_int(), T_int(), T_int()];\n-\n-    auto main_name;\n-    if (str::eq(std::os::target_os(), \"win32\")) {\n-        main_name = \"WinMain@16\";\n-    } else {\n-        main_name = \"main\";\n-    }\n-\n-    auto llmain =\n-        decl_cdecl_fn(cx.ccx.llmod, main_name, T_fn(T_main_args, T_int()));\n-\n-    auto llrust_start = decl_cdecl_fn(cx.ccx.llmod, \"rust_start\",\n-                                      T_fn(T_rust_start_args, T_int()));\n-\n-    auto llargc = llvm::LLVMGetParam(llmain, 0u);\n-    auto llargv = llvm::LLVMGetParam(llmain, 1u);\n-    auto llrust_main = alt (cx.ccx.main_fn) {\n-        case (none) {\n-            cx.ccx.sess.err(\"missing 'main' function\");\n-            // FIXME: shouldn't sess.err's ! result unify with f?\n-            C_nil()\n-        }\n-        case (some(?f)) { f }\n-    };\n-\n-    //\n-    // Emit the moral equivalent of:\n-    //\n-    // main(int argc, char **argv) {\n-    //     rust_start(&_rust.main, argc, argv);\n-    // }\n-    //\n-\n-    let BasicBlockRef llbb =\n-        llvm::LLVMAppendBasicBlock(llmain, str::buf(\"\"));\n-    auto b = new_builder(llbb);\n-\n-    auto start_args = [p2i(llrust_main), llargc, llargv, p2i(crate_map)];\n-\n-    b.Ret(b.Call(llrust_start, start_args));\n-}\n-\n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str,ValueRef] {\n \n     let vec[TypeRef] T_memmove32_args = [T_ptr(T_i8()), T_ptr(T_i8()),\n@@ -8211,8 +8171,6 @@ fn create_module_map(&@crate_ctxt ccx) -> ValueRef {\n     auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n     auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype,\n                                   str::buf(\"_rust_mod_map\"));\n-    llvm::LLVMSetLinkage(map, lib::llvm::LLVMInternalLinkage\n-                         as llvm::Linkage);\n     let vec[ValueRef] elts = [];\n     for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n         auto elt = C_struct([p2i(C_cstr(ccx, item._0)), p2i(item._1)]);\n@@ -8245,7 +8203,14 @@ fn create_crate_map(&@crate_ctxt ccx) -> ValueRef {\n         i += 1;\n     }\n     vec::push[ValueRef](subcrates, C_int(0));\n-    auto sym_name = \"_rust_crate_map_\" + crate_name(ccx, \"__none__\");\n+    auto cname = crate_name(ccx, \"__none__\");\n+    auto mapname;\n+    if (ccx.sess.get_opts().shared) {\n+        mapname = cname;\n+    } else {\n+        mapname = \"toplevel\";\n+    }\n+    auto sym_name = \"_rust_crate_map_\" + mapname;\n     auto arrtype = T_array(T_int(), vec::len[ValueRef](subcrates));\n     auto maptype = T_struct([T_int(), arrtype]);\n     auto map = llvm::LLVMAddGlobal(ccx.llmod, maptype, str::buf(sym_name));\n@@ -8322,9 +8287,17 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n     auto crate_map = create_crate_map(ccx);\n+\n     if (!sess.get_opts().shared) {\n-        trans_main_fn(cx, crate_map);\n-    }\n+      auto gvar = llvm::LLVMAddGlobal(cx.ccx.llmod, T_ptr(T_int()),\n+                                    str::buf(\"_rust_fetch_this_object_hack\"));\n+\n+      auto gvar2 = llvm::LLVMAddGlobal(cx.ccx.llmod, T_ptr(T_ptr(T_int())),\n+                                   str::buf(\"_rust_fetch_this_object_hack2\"));\n+     llvm::LLVMSetInitializer(gvar2, gvar);\n+     llvm::LLVMSetGlobalConstant(gvar, True);\n+     llvm::LLVMSetGlobalConstant(gvar2, True);\n+   }\n \n     emit_tydescs(ccx);\n "}, {"sha": "d956fb8681724a450682a6ea86a8b36e865d47f7", "filename": "src/rt/main.ll.in", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/src%2Frt%2Fmain.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/b1d6f12a050ea0c99f13a1eb58c06577559cc76a/src%2Frt%2Fmain.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmain.ll.in?ref=b1d6f12a050ea0c99f13a1eb58c06577559cc76a", "patch": "@@ -0,0 +1,24 @@\n+%0 = type { i32, [1 x i32] }\n+%1 = type { i32, i32 }\n+%2 = type { i32, %3 }\n+%3 = type { %tydesc*, %4, i1, {} }\n+%4 = type { i1*, i1* }\n+%5 = type { i32, i32, i32, i32, [0 x %6*] }\n+%6 = type { i32, i32, i32, i32, [0 x i8] }\n+\n+\n+@_rust_crate_map_toplevel = external global %0\n+\n+declare fastcc void @_rust_main(i1* nocapture, %task*, %2* nocapture, %5*);\n+declare i32 @rust_start(i32, i32, i32, i32)\n+\n+%tydesc = type { %tydesc**, i32, i32, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*, i8*, i8)* }\n+\n+%task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n+\n+@_rust_fetch_this_object_hack = global i32 0\n+\n+define i32 @\"MAIN\"(i32, i32) {\n+  %3 = tail call i32 @rust_start(i32 ptrtoint (void (i1*, %task*, %2*, %5*)* @_rust_main to i32), i32 %0, i32 %1, i32 ptrtoint (%0* @_rust_crate_map_toplevel to i32))\n+  ret i32 %3\n+}"}]}