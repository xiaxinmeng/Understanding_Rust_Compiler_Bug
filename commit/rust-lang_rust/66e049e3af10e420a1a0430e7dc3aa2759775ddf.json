{"sha": "66e049e3af10e420a1a0430e7dc3aa2759775ddf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2ZTA0OWUzYWYxMGU0MjBhMWEwNDMwZTdkYzNhYTI3NTk3NzVkZGY=", "commit": {"author": {"name": "Jack Moffitt", "email": "jack@metajack.im", "date": "2013-12-15T02:58:07Z"}, "committer": {"name": "Jack Moffitt", "email": "jack@metajack.im", "date": "2013-12-17T14:41:39Z"}, "message": "Change pkgid parser to allow overriding the inferred crate name.\n\nPreviously the a pkgid of `foo/rust-bar#1.0` implied a crate name of\n`rust-bar` and didn't allow this to be overridden. Now you can override the\ninferred crate name with `foo/rust-bar#bar:1.0`.", "tree": {"sha": "54cc9ca3629181dd4de141380a57940313ac44de", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54cc9ca3629181dd4de141380a57940313ac44de"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/66e049e3af10e420a1a0430e7dc3aa2759775ddf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/66e049e3af10e420a1a0430e7dc3aa2759775ddf", "html_url": "https://github.com/rust-lang/rust/commit/66e049e3af10e420a1a0430e7dc3aa2759775ddf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/66e049e3af10e420a1a0430e7dc3aa2759775ddf/comments", "author": {"login": "metajack", "id": 28357, "node_id": "MDQ6VXNlcjI4MzU3", "avatar_url": "https://avatars.githubusercontent.com/u/28357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/metajack", "html_url": "https://github.com/metajack", "followers_url": "https://api.github.com/users/metajack/followers", "following_url": "https://api.github.com/users/metajack/following{/other_user}", "gists_url": "https://api.github.com/users/metajack/gists{/gist_id}", "starred_url": "https://api.github.com/users/metajack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/metajack/subscriptions", "organizations_url": "https://api.github.com/users/metajack/orgs", "repos_url": "https://api.github.com/users/metajack/repos", "events_url": "https://api.github.com/users/metajack/events{/privacy}", "received_events_url": "https://api.github.com/users/metajack/received_events", "type": "User", "site_admin": false}, "committer": {"login": "metajack", "id": 28357, "node_id": "MDQ6VXNlcjI4MzU3", "avatar_url": "https://avatars.githubusercontent.com/u/28357?v=4", "gravatar_id": "", "url": "https://api.github.com/users/metajack", "html_url": "https://github.com/metajack", "followers_url": "https://api.github.com/users/metajack/followers", "following_url": "https://api.github.com/users/metajack/following{/other_user}", "gists_url": "https://api.github.com/users/metajack/gists{/gist_id}", "starred_url": "https://api.github.com/users/metajack/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/metajack/subscriptions", "organizations_url": "https://api.github.com/users/metajack/orgs", "repos_url": "https://api.github.com/users/metajack/repos", "events_url": "https://api.github.com/users/metajack/events{/privacy}", "received_events_url": "https://api.github.com/users/metajack/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "000cda611f8224ac780fa37432f869f425cd2bb7", "url": "https://api.github.com/repos/rust-lang/rust/commits/000cda611f8224ac780fa37432f869f425cd2bb7", "html_url": "https://github.com/rust-lang/rust/commit/000cda611f8224ac780fa37432f869f425cd2bb7"}], "stats": {"total": 128, "additions": 77, "deletions": 51}, "files": [{"sha": "3c10e5199c926a6af837ae0afd48d11735a7ff7d", "filename": "src/libsyntax/pkgid.rs", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/66e049e3af10e420a1a0430e7dc3aa2759775ddf/src%2Flibsyntax%2Fpkgid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/66e049e3af10e420a1a0430e7dc3aa2759775ddf/src%2Flibsyntax%2Fpkgid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fpkgid.rs?ref=66e049e3af10e420a1a0430e7dc3aa2759775ddf", "patch": "@@ -8,10 +8,21 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+/// PkgIds identify crates and include the crate name and optionall a path and\n+/// version. In the full form, they look like relative URLs. Example:\n+/// `github.com/mozilla/rust#std:1.0` would be a package ID with a path of\n+/// `gitub.com/mozilla/rust` and a crate name of `std` with a version of\n+/// `1.0`. If no crate name is given after the hash, the name is inferred to\n+/// be the last component of the path. If no version is given, it is inferred\n+/// to be `0.0`.\n #[deriving(Clone, Eq)]\n pub struct PkgId {\n+    /// A path which represents the codes origin. By convention this is the\n+    /// URL, without `http://` or `https://` prefix, to the crate's repository\n     path: ~str,\n+    /// The name of the crate.\n     name: ~str,\n+    /// The version of the crate.\n     version: Option<~str>,\n }\n \n@@ -21,62 +32,55 @@ impl ToStr for PkgId {\n             None => \"0.0\",\n             Some(ref version) => version.as_slice(),\n         };\n-        if self.path.is_empty() {\n-            format!(\"{}\\\\#{}\", self.name, version)\n+        if self.path == self.name || self.path.ends_with(format!(\"/{}\", self.name)) {\n+            format!(\"{}\\\\#{}\", self.path, version)\n         } else {\n-            format!(\"{}/{}\\\\#{}\", self.path, self.name, version)\n+            format!(\"{}\\\\#{}:{}\", self.path, self.name, version)\n         }\n     }\n }\n \n impl FromStr for PkgId {\n     fn from_str(s: &str) -> Option<PkgId> {\n-        let hash_idx = match s.find('#') {\n-            None => s.len(),\n-            Some(idx) => idx,\n-        };\n-        let prefix = s.slice_to(hash_idx);\n-        let name_idx = match prefix.rfind('/') {\n-            None => 0,\n-            Some(idx) => idx + 1,\n-        };\n-        if name_idx >= prefix.len() {\n-            return None;\n-        }\n-        let name = prefix.slice_from(name_idx);\n-        if name.len() <= 0 {\n-            return None;\n-        }\n+        let pieces: ~[&str] = s.splitn('#', 1).collect();\n+        let path = pieces[0].to_owned();\n \n-        let path = if name_idx == 0 {\n-            \"\"\n-        } else {\n-            prefix.slice_to(name_idx - 1)\n-        };\n-        let check_path = Path::new(path);\n-        if !check_path.is_relative() {\n+        if path.starts_with(\"/\") || path.ends_with(\"/\") ||\n+            path.starts_with(\".\") || path.is_empty() {\n             return None;\n         }\n \n-        let version = match s.find('#') {\n-            None => None,\n-            Some(idx) => {\n-                if idx >= s.len() {\n-                    None\n-                } else {\n-                    let v = s.slice_from(idx + 1);\n-                    if v.is_empty() {\n-                        None\n-                    } else {\n-                        Some(v.to_owned())\n-                    }\n-                }\n-            }\n+        let path_pieces: ~[&str] = path.rsplitn('/', 1).collect();\n+        let inferred_name = path_pieces[0];\n+\n+        let (name, version) = if pieces.len() == 1 {\n+            (inferred_name.to_owned(), None)\n+        } else {\n+            let hash_pieces: ~[&str] = pieces[1].splitn(':', 1).collect();\n+            let (hash_name, hash_version) = if hash_pieces.len() == 1 {\n+                (\"\", hash_pieces[0])\n+            } else {\n+                (hash_pieces[0], hash_pieces[1])\n+            };\n+\n+            let name = if !hash_name.is_empty() {\n+                hash_name.to_owned()\n+            } else {\n+                inferred_name.to_owned()\n+            };\n+\n+            let version = if !hash_version.is_empty() {\n+                Some(hash_version.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            (name, version)\n         };\n \n-        Some(PkgId{\n-            path: path.to_owned(),\n-            name: name.to_owned(),\n+        Some(PkgId {\n+            path: path,\n+            name: name,\n             version: version,\n         })\n     }\n@@ -96,15 +100,15 @@ fn bare_name() {\n     let pkgid: PkgId = from_str(\"foo\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"foo\");\n }\n \n #[test]\n fn bare_name_single_char() {\n     let pkgid: PkgId = from_str(\"f\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"f\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"f\");\n }\n \n #[test]\n@@ -118,15 +122,15 @@ fn simple_path() {\n     let pkgid: PkgId = from_str(\"example.com/foo/bar\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"bar\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn simple_version() {\n     let pkgid: PkgId = from_str(\"foo#1.0\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"\");\n+    assert_eq!(pkgid.path, ~\"foo\");\n }\n \n #[test]\n@@ -135,26 +139,48 @@ fn absolute_path() {\n     assert!(pkgid.is_none());\n }\n \n+#[test]\n+fn path_ends_with_slash() {\n+    let pkgid: Option<PkgId> = from_str(\"foo/bar/\");\n+    assert!(pkgid.is_none());\n+}\n+\n #[test]\n fn path_and_version() {\n     let pkgid: PkgId = from_str(\"example.com/foo/bar#1.0\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"bar\");\n     assert_eq!(pkgid.version, Some(~\"1.0\"));\n-    assert_eq!(pkgid.path, ~\"example.com/foo\");\n+    assert_eq!(pkgid.path, ~\"example.com/foo/bar\");\n }\n \n #[test]\n fn single_chars() {\n     let pkgid: PkgId = from_str(\"a/b#1\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"b\");\n     assert_eq!(pkgid.version, Some(~\"1\"));\n-    assert_eq!(pkgid.path, ~\"a\");\n+    assert_eq!(pkgid.path, ~\"a/b\");\n }\n \n #[test]\n fn missing_version() {\n     let pkgid: PkgId = from_str(\"foo#\").expect(\"valid pkgid\");\n     assert_eq!(pkgid.name, ~\"foo\");\n     assert_eq!(pkgid.version, None);\n-    assert_eq!(pkgid.path, ~\"\");\n-}\n\\ No newline at end of file\n+    assert_eq!(pkgid.path, ~\"foo\");\n+}\n+\n+#[test]\n+fn path_and_name() {\n+    let pkgid: PkgId = from_str(\"foo/rust-bar#bar:1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"foo/rust-bar\");\n+}\n+\n+#[test]\n+fn empty_name() {\n+    let pkgid: PkgId = from_str(\"foo/bar#:1.0\").expect(\"valid pkgid\");\n+    assert_eq!(pkgid.name, ~\"bar\");\n+    assert_eq!(pkgid.version, Some(~\"1.0\"));\n+    assert_eq!(pkgid.path, ~\"foo/bar\");\n+}"}]}