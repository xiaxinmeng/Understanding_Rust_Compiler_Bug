{"sha": "d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YjdjOTZjM2ViMjliOTI0NGVjZTBjMDQ2ZDNmMzcyZmY0MzJkMDQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-24T04:03:09Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-06-24T04:03:09Z"}, "message": "Populate tree.", "tree": {"sha": "b425187e232966063ffc2f0d14c04a55d8f004ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b425187e232966063ffc2f0d14c04a55d8f004ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "html_url": "https://github.com/rust-lang/rust/commit/d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c01efc669f09508b55eced32d3c88702578a7c3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c01efc669f09508b55eced32d3c88702578a7c3e", "html_url": "https://github.com/rust-lang/rust/commit/c01efc669f09508b55eced32d3c88702578a7c3e"}], "stats": {"total": 52877, "additions": 52692, "deletions": 185}, "files": [{"sha": "c7d56e16dae51bc39f3976183a5499386cdaca27", "filename": ".gitignore", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -1,4 +1,6 @@\n *~\n+*.x86\n+*.llvm\n *.out\n *.exe\n *.orig"}, {"sha": "82e593cae42b92fd09ddbcfe34a525ec3ff943e3", "filename": "AUTHORS.txt", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/AUTHORS.txt", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/AUTHORS.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/AUTHORS.txt?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -1,7 +1,12 @@\n-Rust authors:\n+Initial author, project lead, target of blame:\n \n Graydon Hoare <graydon@mozilla.com>\n+\n+Other authors:\n+\n Andreas Gal <gal@mozilla.com>\n+Brendan Eich <brendan@mozilla.org>\n Dave Herman <dherman@mozilla.com>\n+Michael Bebenita <mbebenita@mozilla.com>\n Patrick Walton <pwalton@mozilla.com>\n-Brendan Eich <brendan@mozilla.com>\n+Roy Frostig <rfrostig@mozilla.com>"}, {"sha": "9cab1f89f2c5b5f3ea73fdba3fa86ec7c40bbbab", "filename": "LICENSE.txt", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/LICENSE.txt", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/LICENSE.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/LICENSE.txt?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -53,7 +53,8 @@ The following third party packages are included:\n     All rights reserved.\n \n     Redistribution and use in source and binary forms, with or without\n-    modification, are permitted provided that the following conditions are met:\n+    modification, are permitted provided that the following conditions are\n+    met:\n \n         * Redistributions of source code must retain the above copyright\n           notice, this list of conditions and the following disclaimer.\n@@ -71,9 +72,10 @@ The following third party packages are included:\n     SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n \n \n-* Two header files that are part of the Valgrind package. These files are found\n-  at src/rt/valgrind.h and src/rt/memcheck.h, within this distribution. These\n-  files are redistributed under the following terms, as noted in them:\n+* Two header files that are part of the Valgrind package. These files are\n+  found at src/rt/valgrind.h and src/rt/memcheck.h, within this\n+  distribution. These files are redistributed under the following terms, as\n+  noted in them:\n \n   for src/rt/valgrind.h:\n \n@@ -158,20 +160,20 @@ well as the collective work itslf, is distributed under the following terms:\n     Copyright (c) 2006-2010 Graydon Hoare\n     Copyright (c) 2009-2010 Mozilla Foundation\n \n-    Permission is hereby granted, free of charge, to any person obtaining a copy\n-    of this software and associated documentation files (the \"Software\"), to deal\n-    in the Software without restriction, including without limitation the rights\n-    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n-    copies of the Software, and to permit persons to whom the Software is\n-    furnished to do so, subject to the following conditions:\n+    Permission is hereby granted, free of charge, to any person obtaining a\n+    copy of this software and associated documentation files (the \"Software\"),\n+    to deal in the Software without restriction, including without limitation\n+    the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+    and/or sell copies of the Software, and to permit persons to whom the\n+    Software is furnished to do so, subject to the following conditions:\n \n     The above copyright notice and this permission notice shall be included in\n     all copies or substantial portions of the Software.\n \n     THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n-    THE SOFTWARE.\n+    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n+    THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+    DEALINGS IN THE SOFTWARE."}, {"sha": "081a723b9d604a0e745396a6f194bc1bb040e9d2", "filename": "doc/Makefile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/doc%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/doc%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FMakefile?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -5,7 +5,8 @@ all: rust.pdf rust.html\n \ttexi2pdf $<\n \n %.html: %.texi\n-\tmakeinfo --html --force --no-split --output=$@ $<\n+\tmakeinfo --html --ifhtml --force --no-split --output=$@ $<\n \n clean:\n-\trm -f rust.aux rust.cp rust.fn rust.ky rust.log rust.pdf rust.html rust.pg rust.toc rust.tp rust.vr\n\\ No newline at end of file\n+\trm -f rust.aux rust.cp rust.fn rust.ky rust.log rust.pdf \\\n+          rust.html rust.pg rust.toc rust.tp rust.vr\n\\ No newline at end of file"}, {"sha": "a53520611eb559fa26c8eec39a8524460b59c429", "filename": "doc/rust.texi", "status": "added", "additions": 3244, "deletions": 0, "changes": 3244, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "5d4e6aa0fd3f41f6990172ebf8ee42405d1915e5", "filename": "src/Makefile", "status": "modified", "additions": 225, "deletions": 166, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -19,27 +19,29 @@ endif\n \n CFG_INFO := $(info cfg: building on $(CFG_OSTYPE) $(CFG_CPUTYPE))\n \n-CFG_GCC_COMPILE_FLAGS :=\n+CFG_GCC_CFLAGS :=\n CFG_GCC_LINK_FLAGS :=\n CFG_VALGRIND :=\n \n CFG_LLVM_CONFIG := llvm-config\n-CFG_BOOT_FLAGS :=\n+CFG_BOOT_FLAGS := $(FLAGS)\n \n ifeq ($(CFG_OSTYPE), Linux)\n   CFG_RUNTIME := librustrt.so\n   CFG_STDLIB := libstd.so\n-  CFG_GCC_COMPILE_FLAGS += -fPIC\n+  CFG_GCC_CFLAGS += -fPIC\n   CFG_GCC_LINK_FLAGS += -shared -fPIC -ldl -lpthread\n   ifeq ($(CFG_CPUTYPE), x86_64)\n-    CFG_GCC_COMPILE_FLAGS += -m32\n+    CFG_GCC_CFLAGS += -m32\n     CFG_GCC_LINK_FLAGS += -m32\n   endif\n   CFG_NATIVE := 1\n   CFG_UNIXY := 1\n   CFG_VALGRIND := $(shell which valgrind)\n   ifdef CFG_VALGRIND\n-    CFG_VALGRIND += --run-libc-freeres=no --leak-check=full --quiet --vex-iropt-level=0\n+    CFG_VALGRIND += --leak-check=full \\\n+                    --quiet --vex-iropt-level=0 \\\n+                    --suppressions=etc/x86.supp\n   endif\n endif\n \n@@ -52,7 +54,7 @@ ifeq ($(CFG_OSTYPE), Darwin)\n   # \"on an i386\" when the whole userspace is 64-bit and the compiler\n   # emits 64-bit binaries by default. So we just force -m32 here. Smarter\n   # approaches welcome!\n-  CFG_GCC_COMPILE_FLAGS += -m32\n+  CFG_GCC_CFLAGS += -m32\n   CFG_GCC_LINK_FLAGS += -m32\n endif\n \n@@ -73,7 +75,7 @@ ifdef CFG_WINDOWSY\n   CFG_EXE_SUFFIX := .exe\n   CFG_BOOT := ./rustboot.exe\n   CFG_COMPILER := ./rustc.exe\n-  CFG_GCC_COMPILE_FLAGS += -march=i686\n+  CFG_GCC_CFLAGS += -march=i686\n   CFG_GCC_LINK_FLAGS += -shared -fPIC\n   CFG_RUN_TARG = $(1)\n   # FIXME: support msvc at some point\n@@ -99,22 +101,22 @@ ifdef CFG_UNIXY\n     endif\n     CFG_OBJ_SUFFIX := .o\n     CFG_EXE_SUFFIX := .exe\n-    CFG_GCC_COMPILE_FLAGS :=\n+    CFG_GCC_CFLAGS :=\n     CFG_GCC_LINK_FLAGS := -shared\n     ifeq ($(CFG_CPUTYPE), x86_64)\n-      CFG_GCC_COMPILE_FLAGS += -m32\n+      CFG_GCC_CFLAGS += -m32\n       CFG_GCC_LINK_FLAGS += -m32\n     endif\n   endif\n endif\n \n ifdef CFG_GCC\n   CFG_INFO := $(info cfg: using gcc)\n-  CFG_GCC_COMPILE_FLAGS += -Wall -Werror -fno-rtti -fno-exceptions -g\n+  CFG_GCC_CFLAGS += -Wall -Werror -fno-rtti -fno-exceptions -g\n   CFG_GCC_LINK_FLAGS += -g\n-  CFG_COMPILE_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_COMPILE_FLAGS) -c -o $(1) $(2)\n+  CFG_COMPILE_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -c -o $(1) $(2)\n   CFG_LINK_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_LINK_FLAGS) -o $(1)\n-  CFG_DEPEND_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_COMPILE_FLAGS) -MT \"$(1)\" -MM $(2)\n+  CFG_DEPEND_C = $(CFG_GCC_CROSS)g++ $(CFG_GCC_CFLAGS) -MT \"$(1)\" -MM $(2)\n else\n   CFG_ERR := $(error please try on a system with gcc)\n endif\n@@ -153,19 +155,21 @@ ifneq ($(CFG_LLVM_CONFIG),)\n     $(info cfg: using LLVM version 2.8svn)\n   else\n     CFG_LLVM_CONFIG :=\n-    $(info cfg: incompatible LLVM version $(CFG_LLVM_VERSION), expected 2.8svn)\n+    $(info cfg: incompatible LLVM version $(CFG_LLVM_VERSION), \\\n+      expected 2.8svn)\n   endif\n endif\n ifdef CFG_LLVM_CONFIG\n   VARIANT=llvm\n   WHERE := $(shell ocamlc -where)\n   LLVM_LIBS := llvm.cma llvm_bitwriter.cma\n   LLVM_NATIVE_LIBS := llvm.cmxa llvm_bitwiter.cmxa\n-  LLVM_CLIBS := $(shell for c in `$(CFG_LLVM_CONFIG) --ldflags --libs` -lllvm -lllvm_bitwriter; do echo -cclib && echo $$c; done | xargs echo)\n+  LLVM_CLIBS := $(shell for c in `$(CFG_LLVM_CONFIG) --ldflags --libs` \\\n+    -lllvm -lllvm_bitwriter; do echo -cclib && echo $$c; done | xargs echo)\n   LLVM_INCS := -I boot/llvm -I $(WHERE)\n-  LLVM_MLS := $(addprefix boot/llvm/, llabi.ml llasm.ml llfinal.ml lltrans.ml \\\n-    llemit.ml)\n-  CFG_LLC_COMPILE_FLAGS := -march=x86\n+  LLVM_MLS := $(addprefix boot/llvm/, llabi.ml llasm.ml llfinal.ml \\\n+    lltrans.ml llemit.ml)\n+  CFG_LLC_CFLAGS := -march=x86\n   $(info cfg: found llvm-config at $(CFG_LLVM_CONFIG))\n else\n   VARIANT=x86\n@@ -190,7 +194,8 @@ ML_INCS := -I boot/fe -I boot/me -I boot/be -I boot/driver/$(VARIANT) \\\n ML_LIBS := unix.cma nums.cma bigarray.cma\n ML_NATIVE_LIBS := unix.cmxa nums.cmxa bigarray.cmxa\n OCAMLC_FLAGS := -g $(ML_INCS) -w Ael -warn-error Ael\n-OCAMLOPT_FLAGS := $(ML_INCS) -w Ael -warn-error Ael $(CFG_OCAMLOPT_PROFILE_FLAGS)\n+OCAMLOPT_FLAGS := $(ML_INCS) -w Ael -warn-error Ael \\\n+                    $(CFG_OCAMLOPT_PROFILE_FLAGS)\n \n ifdef CFG_LLVM_CONFIG\n   ML_LIBS += $(LLVM_LIBS) -custom -cclib -lstdc++ $(LLVM_CLIBS)\n@@ -205,11 +210,12 @@ DRIVER_BOT_MLS := $(addprefix boot/driver/, session.ml)\n BE_MLS := $(addprefix boot/be/, x86.ml ra.ml pe.ml elf.ml \\\n           macho.ml)\n IL_MLS := $(addprefix boot/be/, asm.ml il.ml abi.ml)\n-ME_MLS := $(addprefix boot/me/, walk.ml semant.ml resolve.ml alias.ml type.ml dead.ml \\\n-          typestate.ml mode.ml mutable.ml gctype.ml loop.ml layout.ml transutil.ml \\\n-          trans.ml dwarf.ml)\n-FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml pexp.ml item.ml cexp.ml)\n-DRIVER_TOP_MLS := $(addprefix boot/driver/, $(VARIANT)/glue.ml lib.ml main.ml)\n+ME_MLS := $(addprefix boot/me/, walk.ml semant.ml resolve.ml alias.ml \\\n+            type.ml dead.ml effect.ml typestate.ml loop.ml layout.ml  \\\n+            transutil.ml trans.ml dwarf.ml)\n+FE_MLS := $(addprefix boot/fe/, ast.ml token.ml lexer.ml parser.ml pexp.ml \\\n+            item.ml cexp.ml)\n+DRIVER_TOP_MLS := $(addprefix boot/driver/, lib.ml $(VARIANT)/glue.ml main.ml)\n \n BOOT_MLS := $(UTIL_BOT_MLS) $(DRIVER_BOT_MLS) $(FE_MLS) $(IL_MLS) $(ME_MLS) \\\n   $(BE_MLS) $(LLVM_MLS) $(DRIVER_TOP_MLS)\n@@ -226,8 +232,12 @@ RUNTIME_CS := rt/rust.cpp \\\n               rt/rust_comm.cpp \\\n               rt/rust_dom.cpp \\\n               rt/rust_task.cpp \\\n+              rt/rust_chan.cpp \\\n               rt/rust_upcall.cpp \\\n+              rt/rust_log.cpp \\\n+              rt/rust_timer.cpp \\\n               rt/isaac/randport.cpp\n+\n RUNTIME_HDR := rt/rust.h \\\n                rt/rust_dwarf.h \\\n                rt/rust_internal.h \\\n@@ -253,7 +263,8 @@ $(CFG_RUNTIME): $(RUNTIME_OBJS) $(MKFILES) $(RUNTIME_HDR)\n \n $(CFG_STDLIB): $(STDLIB_CRATE) $(CFG_BOOT) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -shared -o $@ $(STDLIB_CRATE)\n+\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) \\\n+      -shared -o $@ $(STDLIB_CRATE)\n \n %$(CFG_OBJ_SUFFIX): %.cpp $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n@@ -262,7 +273,8 @@ $(CFG_STDLIB): $(STDLIB_CRATE) $(CFG_BOOT) $(MKFILES)\n ifdef CFG_NATIVE\n $(CFG_BOOT): $(BOOT_CMXS) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n-\t$(CFG_QUIET)ocamlopt$(OPT) -o $@ $(OCAMLOPT_FLAGS) $(ML_NATIVE_LIBS) $(BOOT_CMXS)\n+\t$(CFG_QUIET)ocamlopt$(OPT) -o $@ $(OCAMLOPT_FLAGS) $(ML_NATIVE_LIBS) \\\n+      $(BOOT_CMXS)\n else\n $(CFG_BOOT): $(BOOT_CMOS) $(MKFILES)\n \t@$(call CFG_ECHO, compile: $<)\n@@ -288,7 +300,7 @@ endif\n # Main compiler targets and rules\n ######################################################################\n \n-$(CFG_COMPILER): $(COMPILER_CRATE) $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+$(CFG_COMPILER): $(COMPILER_INPUTS) $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n \t@$(call CFG_ECHO, compile: $<)\n \t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ $<\n \t$(CFG_QUIET)chmod 0755 $@\n@@ -302,75 +314,92 @@ self: $(CFG_COMPILER)\n # Testing\n ######################################################################\n \n-TEST_XFAILS_X86 :=  test/run-pass/mlist_cycle.rs \\\n+TEST_XFAILS_X86 :=  test/run-pass/mlist-cycle.rs \\\n                     test/run-pass/clone-with-exterior.rs \\\n+                    test/run-pass/obj-as.rs \\\n                     test/run-pass/rec-auto.rs \\\n                     test/run-pass/vec-slice.rs \\\n                     test/run-pass/generic-fn-infer.rs \\\n+                    test/run-pass/generic-recursive-tag.rs \\\n                     test/run-pass/generic-tag.rs \\\n+                    test/run-pass/generic-tag-alt.rs \\\n                     test/run-pass/bind-obj-ctor.rs \\\n+                    test/run-pass/task-comm.rs \\\n                     test/compile-fail/rec-missing-fields.rs \\\n                     test/compile-fail/infinite-tag-type-recursion.rs \\\n                     test/compile-fail/infinite-vec-type-recursion.rs\n \n TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       acyclic-unwind.rs \\\n                       alt-tag.rs \\\n+                      argv.rs \\\n                       basic.rs \\\n                       bind-obj-ctor.rs \\\n                       bind-thunk.rs \\\n                       bind-trivial.rs \\\n+                      bitwise.rs \\\n+                      box-unbox.rs \\\n                       cast.rs \\\n                       char.rs \\\n                       clone-with-exterior.rs \\\n                       comm.rs \\\n+                      command-line-args.rs \\\n                       complex.rs \\\n                       dead-code-one-arm-if.rs \\\n                       deep.rs \\\n                       div-mod.rs \\\n                       drop-on-ret.rs \\\n+                      else-if.rs \\\n+                      export-non-interference.rs \\\n                       exterior.rs \\\n-                      foreach-simple.rs \\\n-                      foreach-simple-outer-slot.rs \\\n                       foreach-put-structured.rs \\\n-                      vec-slice.rs \\\n-                      simple-obj.rs \\\n-                      import.rs \\\n+                      foreach-simple-outer-slot.rs \\\n+                      foreach-simple.rs \\\n                       fun-call-variants.rs \\\n                       fun-indirect-call.rs \\\n                       generic-derived-type.rs \\\n                       generic-drop-glue.rs \\\n+                      generic-exterior-box.rs \\\n+                      generic-fn-infer.rs \\\n                       generic-fn.rs \\\n-                      generic-obj.rs \\\n                       generic-obj-with-derived-type.rs \\\n+                      generic-obj.rs \\\n+                      generic-recursive-tag.rs \\\n+                      generic-tag-alt.rs \\\n                       generic-tag.rs \\\n+                      generic-type-synonym.rs \\\n                       generic-type.rs \\\n-                      generic-fn-infer.rs \\\n-                      vec-append.rs \\\n-                      vec-concat.rs \\\n-                      vec-drop.rs \\\n-                      mutable-vec-drop.rs \\\n+                      i32-sub.rs \\\n+                      i8-incr.rs \\\n+                      import.rs \\\n                       inner-module.rs \\\n                       large-records.rs \\\n+                      lazy-and-or.rs \\\n                       lazychan.rs \\\n                       linear-for-loop.rs \\\n+                      list.rs \\\n                       many.rs \\\n+                      mlist-cycle.rs \\\n                       mlist.rs \\\n-                      mlist_cycle.rs \\\n+                      mutable-vec-drop.rs \\\n                       mutual-recursion-group.rs \\\n+                      native-mod.rc \\\n+                      native-opaque-type.rs \\\n                       native.rc \\\n-                      command-line-args.rs \\\n-                      native_mod.rc \\\n+                      obj-as.rs \\\n+                      obj-drop.rs \\\n+                      obj-dtor.rs \\\n+                      obj-with-vec.rs \\\n                       opeq.rs \\\n+                      preempt.rs \\\n                       pred.rs \\\n                       readalias.rs \\\n                       rec-auto.rs \\\n                       rec-extend.rs \\\n+                      rec-tup.rs \\\n                       rec.rs \\\n-                      rec_tup.rs \\\n                       return-nil.rs \\\n-                      i32-sub.rs \\\n-                      i8-incr.rs \\\n+                      simple-obj.rs \\\n                       spawn-fn.rs \\\n                       spawn.rs \\\n                       stateful-obj.rs \\\n@@ -383,31 +412,31 @@ TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       tail-direct.rs \\\n                       threads.rs \\\n                       tup.rs \\\n+                      type-sizes.rs \\\n                       u32-decr.rs \\\n                       u8-incr-decr.rs \\\n                       u8-incr.rs \\\n                       unit.rs \\\n                       user.rs \\\n+                      utf8.rs \\\n+                      vec-append.rs \\\n+                      vec-concat.rs \\\n+                      vec-drop.rs \\\n+                      vec-slice.rs \\\n                       vec.rs \\\n                       writealias.rs \\\n                       yield.rs \\\n                       yield2.rs \\\n-                      native-opaque-type.rs \\\n-                      type-sizes.rs \\\n-                      obj-drop.rs \\\n-                      obj-dtor.rs \\\n-                      obj-with-vec.rs \\\n-                      else-if.rs \\\n-                      lazy-and-or.rs \\\n+                      task-comm.rs \\\n                      ) \\\n                     $(addprefix test/run-fail/, \\\n                       explicit-fail.rs \\\n                       fail.rs \\\n                       linked-failure.rs \\\n                       pred.rs \\\n-                      vec_overrun.rs \\\n-                      str_overrun.rs \\\n-                      vec_underrun.rs \\\n+                      vec-overrun.rs \\\n+                      str-overrun.rs \\\n+                      vec-underrun.rs \\\n                      ) \\\n                     $(addprefix test/compile-fail/, \\\n                       rec-missing-fields.rs \\\n@@ -416,149 +445,167 @@ TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                      )\n \n ifdef CFG_WINDOWSY\n-TEST_XFAILS_X86 += test/run-pass/native_mod.rc\n-TEST_XFAILS_LLVM += test/run-pass/native_mod.rc\n+TEST_XFAILS_X86 += test/run-pass/native-mod.rc\n+TEST_XFAILS_LLVM += test/run-pass/native-mod.rc\n+else\n+TEST_XFAILS_X86 += test/run-pass/preempt.rs\n+TEST_XFAILS_LLVM += test/run-pass/preempt.rs\n endif\n \n-TEST_RUN_PASS_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/run-pass/*.rc))\n-TEST_RUN_PASS_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/run-pass/*.rc))\n-TEST_RUN_PASS_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/run-pass/*.rs))\n-TEST_RUN_PASS_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/run-pass/*.rs))\n-TEST_RUN_PASS_EXTRAS := $(wildcard test/run-pass/*/*.rs)\n-TEST_RUN_PASS_EXES_X86 := \\\n-                      $(TEST_RUN_PASS_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n-                      $(TEST_RUN_PASS_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n-TEST_RUN_PASS_EXES_LLVM := \\\n-                      $(TEST_RUN_PASS_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n-                      $(TEST_RUN_PASS_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n-TEST_RUN_PASS_OUTS_X86  := \\\n-                    $(TEST_RUN_PASS_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_RUN_PASS_OUTS_LLVM := \\\n-                    $(TEST_RUN_PASS_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n-\n-\n-TEST_RUN_FAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/run-fail/*.rc))\n-TEST_RUN_FAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/run-fail/*.rc))\n-TEST_RUN_FAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/run-fail/*.rs))\n-TEST_RUN_FAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/run-fail/*.rs))\n-TEST_RUN_FAIL_EXTRAS := $(wildcard test/run-fail/*/*.rs)\n-TEST_RUN_FAIL_EXES_X86 := \\\n-                      $(TEST_RUN_FAIL_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n-                      $(TEST_RUN_FAIL_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n-TEST_RUN_FAIL_EXES_LLVM := \\\n-                      $(TEST_RUN_FAIL_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n-                      $(TEST_RUN_FAIL_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n-TEST_RUN_FAIL_OUTS_X86  := \\\n-                    $(TEST_RUN_FAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_RUN_FAIL_OUTS_LLVM := \\\n-                    $(TEST_RUN_FAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n-\n-\n-TEST_COMPILE_FAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/compile-fail/*.rc))\n-TEST_COMPILE_FAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/compile-fail/*.rc))\n-TEST_COMPILE_FAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(wildcard test/compile-fail/*.rs))\n-TEST_COMPILE_FAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(wildcard test/compile-fail/*.rs))\n-TEST_COMPILE_FAIL_EXTRAS := $(wildcard test/compile-fail/*/*.rs)\n-TEST_COMPILE_FAIL_EXES_X86 := \\\n-                  $(TEST_COMPILE_FAIL_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n-                  $(TEST_COMPILE_FAIL_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n-TEST_COMPILE_FAIL_EXES_LLVM := \\\n-                  $(TEST_COMPILE_FAIL_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n-                  $(TEST_COMPILE_FAIL_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n-TEST_COMPILE_FAIL_OUTS_X86 := \\\n-                $(TEST_COMPILE_FAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n-TEST_COMPILE_FAIL_OUTS_LLVM := \\\n-                $(TEST_COMPILE_FAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n-\n-ALL_TEST_CRATES := $(TEST_COMPILE_FAIL_CRATES_X86) \\\n-                   $(TEST_RUN_FAIL_CRATES_X86) \\\n-                   $(TEST_RUN_PASS_CRATES_X86)\n-\n-ALL_TEST_SOURCES := $(TEST_COMPILE_FAIL_SOURCES_X86) \\\n-                    $(TEST_RUN_FAIL_SOURCES_X86) \\\n-                    $(TEST_RUN_PASS_SOURCES_X86)\n+RPASS_RC := $(wildcard test/run-pass/*.rc)\n+RPASS_RS := $(wildcard test/run-pass/*.rs)\n+RFAIL_RC := $(wildcard test/run-fail/*.rc)\n+RFAIL_RS := $(wildcard test/run-fail/*.rs)\n+CFAIL_RC := $(wildcard test/compile-fail/*.rc)\n+CFAIL_RS := $(wildcard test/compile-fail/*.rs)\n+\n+TEST_RPASS_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RC))\n+TEST_RPASS_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RC))\n+TEST_RPASS_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RPASS_RS))\n+TEST_RPASS_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RPASS_RS))\n+TEST_RPASS_EXTRAS := $(wildcard test/run-pass/*/*.rs)\n+TEST_RPASS_EXES_X86 := \\\n+                      $(TEST_RPASS_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n+                      $(TEST_RPASS_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n+TEST_RPASS_EXES_LLVM := \\\n+                      $(TEST_RPASS_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n+                      $(TEST_RPASS_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n+TEST_RPASS_OUTS_X86  := \\\n+                    $(TEST_RPASS_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n+TEST_RPASS_OUTS_LLVM := \\\n+                    $(TEST_RPASS_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n+\n+\n+TEST_RFAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RFAIL_RC))\n+TEST_RFAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RFAIL_RC))\n+TEST_RFAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(RFAIL_RS))\n+TEST_RFAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(RFAIL_RS))\n+TEST_RFAIL_EXTRAS := $(wildcard test/run-fail/*/*.rs)\n+TEST_RFAIL_EXES_X86 := \\\n+                      $(TEST_RFAIL_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n+                      $(TEST_RFAIL_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n+TEST_RFAIL_EXES_LLVM := \\\n+                      $(TEST_RFAIL_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n+                      $(TEST_RFAIL_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n+TEST_RFAIL_OUTS_X86  := \\\n+                    $(TEST_RFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n+TEST_RFAIL_OUTS_LLVM := \\\n+                    $(TEST_RFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n+\n+\n+TEST_CFAIL_CRATES_X86 := $(filter-out $(TEST_XFAILS_X86), $(CFAIL_RC))\n+TEST_CFAIL_CRATES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(CFAIL_RC))\n+TEST_CFAIL_SOURCES_X86 := $(filter-out $(TEST_XFAILS_X86), $(CFAIL_RS))\n+TEST_CFAIL_SOURCES_LLVM := $(filter-out $(TEST_XFAILS_LLVM), $(CFAIL_RS))\n+TEST_CFAIL_EXTRAS := $(wildcard test/compile-fail/*/*.rs)\n+TEST_CFAIL_EXES_X86 := \\\n+                  $(TEST_CFAIL_CRATES_X86:.rc=.x86$(CFG_EXE_SUFFIX)) \\\n+                  $(TEST_CFAIL_SOURCES_X86:.rs=.x86$(CFG_EXE_SUFFIX))\n+TEST_CFAIL_EXES_LLVM := \\\n+                  $(TEST_CFAIL_CRATES_LLVM:.rc=.llvm$(CFG_EXE_SUFFIX)) \\\n+                  $(TEST_CFAIL_SOURCES_LLVM:.rs=.llvm$(CFG_EXE_SUFFIX))\n+TEST_CFAIL_OUTS_X86 := \\\n+                $(TEST_CFAIL_EXES_X86:.x86$(CFG_EXE_SUFFIX)=.x86.out)\n+TEST_CFAIL_OUTS_LLVM := \\\n+                $(TEST_CFAIL_EXES_LLVM:.llvm$(CFG_EXE_SUFFIX)=.llvm.out)\n+\n+ALL_TEST_CRATES := $(TEST_CFAIL_CRATES_X86) \\\n+                   $(TEST_RFAIL_CRATES_X86) \\\n+                   $(TEST_RPASS_CRATES_X86)\n+\n+ALL_TEST_SOURCES := $(TEST_CFAIL_SOURCES_X86) \\\n+                    $(TEST_RFAIL_SOURCES_X86) \\\n+                    $(TEST_RPASS_SOURCES_X86)\n \n ALL_TEST_INPUTS := $(wildcard test/*/*.rs test/*/*/*.rs test/*/*.rc)\n \n \n-check_nocompile: $(TEST_COMPILE_FAIL_OUTS_X86)\n+check_nocompile: $(TEST_CFAIL_OUTS_X86)\n+\n+check: tidy \\\n+       $(TEST_RPASS_EXES_X86) $(TEST_RFAIL_EXES_X86) \\\n+       $(TEST_RPASS_OUTS_X86) $(TEST_RFAIL_OUTS_X86) \\\n+       $(TEST_CFAIL_OUTS_X86)\n \n-check: $(TEST_RUN_PASS_EXES_X86) $(TEST_RUN_FAIL_EXES_X86) \\\n-       $(TEST_RUN_PASS_OUTS_X86) $(TEST_RUN_FAIL_OUTS_X86) \\\n-       $(TEST_COMPILE_FAIL_OUTS_X86)\n \n ifeq ($(VARIANT),llvm)\n-ALL_TEST_CRATES += $(TEST_COMPILE_FAIL_CRATES_LLVM) \\\n-                   $(TEST_RUN_FAIL_CRATES_LLVM) \\\n-                   $(TEST_RUN_PASS_CRATES_LLVM)\n+ALL_TEST_CRATES += $(TEST_CFAIL_CRATES_LLVM) \\\n+                   $(TEST_RFAIL_CRATES_LLVM) \\\n+                   $(TEST_RPASS_CRATES_LLVM)\n \n-ALL_TEST_SOURCES += $(TEST_COMPILE_FAIL_SOURCES_LLVM) \\\n-                    $(TEST_RUN_FAIL_SOURCES_LLVM) \\\n-                    $(TEST_RUN_PASS_SOURCES_LLVM)\n+ALL_TEST_SOURCES += $(TEST_CFAIL_SOURCES_LLVM) \\\n+                    $(TEST_RFAIL_SOURCES_LLVM) \\\n+                    $(TEST_RPASS_SOURCES_LLVM)\n \n-check_nocompile: $(TEST_COMPILE_FAIL_OUTS_LLVM)\n+check_nocompile: $(TEST_CFAIL_OUTS_LLVM)\n \n-check:  $(TEST_RUN_PASS_EXES_LLVM) $(TEST_RUN_FAIL_EXES_LLVM) \\\n-        $(TEST_RUN_PASS_OUTS_LLVM) $(TEST_RUN_FAIL_OUTS_LLVM) \\\n-        $(TEST_COMPILE_FAIL_OUTS_LLVM)\n+check:  tidy \\\n+        $(TEST_RPASS_EXES_LLVM) $(TEST_RFAIL_EXES_LLVM) \\\n+        $(TEST_RPASS_OUTS_LLVM) $(TEST_RFAIL_OUTS_LLVM) \\\n+        $(TEST_CFAIL_OUTS_LLVM)\n endif\n \n+REQ := $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+BOOT := $(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS)\n+\n test/run-pass/%.out: test/run-pass/%$(CFG_EXE_SUFFIX) $(CFG_RUNTIME)\n \t@$(call CFG_ECHO, run: $<)\n \t$(CFG_QUIET)$(call CFG_RUN_TARG, $<) > $@\n \n test/run-fail/%.out: test/run-fail/%$(CFG_EXE_SUFFIX) $(CFG_RUNTIME)\n \t@$(call CFG_ECHO, run: $<)\n \t$(CFG_QUIET)rm -f $@\n-\t$(CFG_QUIET)$(call CFG_RUN_TARG, $<) >$@ 2>&1 ; X=$$? ; if [ $$X -eq 0 ] ; then exit 1 ; else exit 0 ; fi\n-\t$(CFG_QUIET)grep --text --quiet \"`awk -F: '/error-pattern/ { print $$2 }' $(basename $(basename $@)).rs | tr -d '\\n\\r'`\" $@\n+\t$(CFG_QUIET)$(call CFG_RUN_TARG, $<) >$@ 2>&1 ; X=$$? ; \\\n+      if [ $$X -eq 0 ] ; then exit 1 ; else exit 0 ; fi\n+\t$(CFG_QUIET)grep --text --quiet \\\n+      \"`awk -F: '/error-pattern/ { print $$2 }' \\\n+        $(basename $(basename $@)).rs | tr -d '\\n\\r'`\" $@\n \n-test/compile-fail/%.x86.out: test/compile-fail/%.rs $(CFG_BOOT) $(CFG_RUNTIME)\n+test/compile-fail/%.x86.out: test/compile-fail/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [x86]: $<)\n \t$(CFG_QUIET)rm -f $@\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) -o $(@:.out=$(CFG_EXE_SUFFIX)) $< >$@ 2>&1 || true\n-\t$(CFG_QUIET)grep --text --quiet \"`awk -F: '/error-pattern/ { print $$2 }' $< | tr -d '\\n\\r'`\" $@\n+\t$(BOOT) -o $(@:.out=$(CFG_EXE_SUFFIX)) $< >$@ 2>&1 || true\n+\t$(CFG_QUIET)grep --text --quiet \\\n+      \"`awk -F: '/error-pattern/ { print $$2 }' $< | tr -d '\\n\\r'`\" $@\n \n-test/compile-fail/%.llvm.out: test/compile-fail/%.rs $(CFG_BOOT) $(CFG_RUNTIME)\n+test/compile-fail/%.llvm.out: test/compile-fail/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n \t$(CFG_QUIET)rm -f $@\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $(@:.out=$(CFG_EXE_SUFFIX)) $< >$@ 2>&1 || true\n-\t$(CFG_QUIET)grep --text --quiet \"`awk -F: '/error-pattern/ { print $$2 }' $< | tr -d '\\n\\r'`\" $@\n+\t$(BOOT) -o $(@:.out=$(CFG_EXE_SUFFIX)) $< >$@ 2>&1 || true\n+\t$(CFG_QUIET)grep --text --quiet \\\n+      \"`awk -F: '/error-pattern/ { print $$2 }' $< | tr -d '\\n\\r'`\" $@\n \n-test/run-pass/%.x86$(CFG_EXE_SUFFIX): test/run-pass/%.rc $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+test/run-pass/%.x86$(CFG_EXE_SUFFIX): test/run-pass/%.rc $(REQ)\n \t@$(call CFG_ECHO, compile [x86]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ $<\n-\t$(CFG_QUIET)chmod 0755 $@\n+\t$(BOOT) -o $@ $<\n \n %.s: %.bc\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n-\t$(CFG_QUIET)llc $(CFG_LLC_COMPILE_FLAGS) -o $@ $<\n+\t$(CFG_QUIET)llc $(CFG_LLC_CFLAGS) -o $@ $<\n \n %.llvm$(CFG_EXE_SUFFIX): %.s $(CFG_RUNTIME)\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n-\t$(CFG_QUIET)gcc $(CFG_GCC_COMPILE_FLAGS) -o $@ $< -L. -lrustrt\n+\t$(CFG_QUIET)gcc $(CFG_GCC_CFLAGS) -o $@ $< -L. -lrustrt\n \n-test/run-pass/%.bc: test/run-pass/%.rc $(CFG_BOOT) $(CFG_STDLIB)\n+test/run-pass/%.bc: test/run-pass/%.rc $(REQ)\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ -llvm $<\n+\t$(BOOT) -o $@ -llvm $<\n \n-test/run-pass/%.x86$(CFG_EXE_SUFFIX): test/run-pass/%.rs $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+test/run-pass/%.x86$(CFG_EXE_SUFFIX): test/run-pass/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [x86]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ $<\n-\t$(CFG_QUIET)chmod 0755 $@\n+\t$(BOOT) -o $@ $<\n \n-test/run-pass/%.bc: test/run-pass/%.rs $(CFG_BOOT) $(CFG_STDLIB)\n+test/run-pass/%.bc: test/run-pass/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ -llvm $<\n+\t$(BOOT) -o $@ -llvm $<\n \n-test/run-fail/%.x86$(CFG_EXE_SUFFIX): test/run-fail/%.rs $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n+test/run-fail/%.x86$(CFG_EXE_SUFFIX): test/run-fail/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [x86]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ $<\n-\t$(CFG_QUIET)chmod 0755 $@\n+\t$(BOOT) -o $@ $<\n \n-test/run-fail/%.bc: test/run-fail/%.rs $(CFG_BOOT) $(CFG_STDLIB)\n+test/run-fail/%.bc: test/run-fail/%.rs $(REQ)\n \t@$(call CFG_ECHO, compile [llvm]: $<)\n-\t$(CFG_QUIET)OCAMLRUNPARAM=\"b1\" $(CFG_BOOT) $(CFG_BOOT_FLAGS) -o $@ -llvm $<\n+\t$(BOOT) -o $@ -llvm $<\n \n \n ######################################################################\n@@ -570,7 +617,9 @@ C_DEPFILES := $(RUNTIME_CS:%.cpp=%.d)\n \n %.d: %.cpp $(MKFILES)\n \t@$(call CFG_ECHO, dep: $<)\n-\t$(CFG_QUIET)$(call CFG_DEPEND_C, $@ $(patsubst %.cpp, %$(CFG_OBJ_SUFFIX), $<), $(RUNTIME_INCS)) $< $(CFG_PATH_MUNGE) >$@\n+\t$(CFG_QUIET)$(call CFG_DEPEND_C, $@ \\\n+      $(patsubst %.cpp, %$(CFG_OBJ_SUFFIX), $<), \\\n+      $(RUNTIME_INCS)) $< $(CFG_PATH_MUNGE) >$@\n \n %.d: %.ml $(MKFILES)\n \t@$(call CFG_ECHO, dep: $<)\n@@ -593,15 +642,15 @@ CRATE_DEPFILES := $(ALL_TEST_CRATES:%.rc=%.d) $(STDLIB_DEPFILE)\n \n $(STDLIB_DEPFILE): $(STDLIB_CRATE) $(MKFILES) $(CFG_BOOT)\n \t@$(call CFG_ECHO, dep: $<)\n-\t$(CFG_QUIET)$(CFG_BOOT) $(CFG_BOOT_FLAGS) -shared -rdeps $< $(CFG_PATH_MUNGE) >$@\n+\t$(BOOT) -shared -rdeps $< $(CFG_PATH_MUNGE) >$@\n \n %.d: %.rc $(MKFILES) $(CFG_BOOT)\n \t@$(call CFG_ECHO, dep: $<)\n-\t$(CFG_QUIET)$(CFG_BOOT) $(CFG_BOOT_FLAGS) -rdeps $< $(CFG_PATH_MUNGE) >$@\n+\t$(BOOT) -rdeps $< $(CFG_PATH_MUNGE) >$@\n \n %.d: %.rs $(MKFILES) $(CFG_BOOT)\n \t@$(call CFG_ECHO, dep: $<)\n-\t$(CFG_QUIET)$(CFG_BOOT) $(CFG_BOOT_FLAGS) -rdeps $< $(CFG_PATH_MUNGE) >$@\n+\t$(BOOT) -rdeps $< $(CFG_PATH_MUNGE) >$@\n \n ifneq ($(MAKECMDGOALS),clean)\n -include $(CRATE_DEPFILES)\n@@ -622,8 +671,9 @@ PKG_3RDPARTY := rt/valgrind.h rt/memcheck.h \\\n                 rt/bigint/bigint.h rt/bigint/bigint_int.cpp \\\n                 rt/bigint/bigint_ext.cpp rt/bigint/low_primes.h\n PKG_FILES := README \\\n+             $(wildcard etc/*.*) \\\n              $(MKFILES) $(BOOT_MLS) boot/fe/lexer.mll \\\n-             $(COMPILER_CRATE) $(COMPILER_INPUTS) \\\n+             $(COMPILER_INPUTS) \\\n              $(STDLIB_CRATE) $(STDLIB_INPUTS) \\\n              $(RUNTIME_CS) $(RUNTIME_HDR) $(PKG_3RDPARTY) \\\n              $(ALL_TEST_INPUTS)\n@@ -658,20 +708,29 @@ distcheck:\n # Cleanup\n ######################################################################\n \n-.PHONY: clean\n+.PHONY: clean tidy\n+\n+tidy:\n+\t@$(call CFG_ECHO, check: formatting)\n+\t$(CFG_QUIET) python etc/tidy.py \\\n+      $(wildcard ../*.txt) \\\n+      ../README \\\n+      $(filter-out boot/fe/lexer.ml $(PKG_3RDPARTY), $(PKG_FILES))\n \n clean:\n \t@$(call CFG_ECHO, cleaning)\n-\t$(CFG_QUIET)rm -f $(RUNTIME_OBJS) $(BOOT_CMOS) $(BOOT_CMIS) $(BOOT_CMXS) $(BOOT_OBJS)\n+\t$(CFG_QUIET)rm -f $(RUNTIME_OBJS)\n+\t$(CFG_QUIET)rm -f $(BOOT_CMOS) $(BOOT_CMIS) $(BOOT_CMXS) $(BOOT_OBJS)\n \t$(CFG_QUIET)rm -f $(CFG_COMPILER)\n \t$(CFG_QUIET)rm -f $(ML_DEPFILES) $(C_DEPFILES) $(CRATE_DEPFILES)\n \t$(CFG_QUIET)rm -f boot/fe/lexer.ml\n \t$(CFG_QUIET)rm -f $(CFG_BOOT) $(CFG_RUNTIME) $(CFG_STDLIB)\n-\t$(CFG_QUIET)rm -f $(TEST_RUN_PASS_EXES_X86) $(TEST_RUN_PASS_OUTS_X86)\n-\t$(CFG_QUIET)rm -f $(TEST_RUN_PASS_EXES_LLVM) $(TEST_RUN_PASS_OUTS_LLVM)\n-\t$(CFG_QUIET)rm -f $(TEST_RUN_FAIL_EXES_X86) $(TEST_RUN_FAIL_OUTS_X86)\n-\t$(CFG_QUIET)rm -f $(TEST_RUN_FAIL_EXES_LLVM) $(TEST_RUN_FAIL_OUTS_LLVM)\n-\t$(CFG_QUIET)rm -f $(TEST_COMPILE_FAIL_EXES_X86) $(TEST_COMPILE_FAIL_OUTS_X86)\n-\t$(CFG_QUIET)rm -f $(TEST_COMPILE_FAIL_EXES_LLVM) $(TEST_COMPILE_FAIL_OUTS_LLVM)\n+\t$(CFG_QUIET)rm -f $(TEST_RPASS_EXES_X86) $(TEST_RPASS_OUTS_X86)\n+\t$(CFG_QUIET)rm -f $(TEST_RPASS_EXES_LLVM) $(TEST_RPASS_OUTS_LLVM)\n+\t$(CFG_QUIET)rm -f $(TEST_RFAIL_EXES_X86) $(TEST_RFAIL_OUTS_X86)\n+\t$(CFG_QUIET)rm -f $(TEST_RFAIL_EXES_LLVM) $(TEST_RFAIL_OUTS_LLVM)\n+\t$(CFG_QUIET)rm -f $(TEST_CFAIL_EXES_X86) $(TEST_CFAIL_OUTS_X86)\n+\t$(CFG_QUIET)rm -f $(TEST_CFAIL_EXES_LLVM) $(TEST_CFAIL_OUTS_LLVM)\n \t$(CFG_QUIET)rm -Rf $(PKG_NAME)-*.tar.gz dist\n-\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma o a d exe,$(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))\n+\t$(CFG_QUIET)rm -f $(foreach ext,cmx cmi cmo cma o a d exe,\\\n+                        $(wildcard boot/*/*.$(ext) boot/*/*/*.$(ext)))"}, {"sha": "c51709d0556ef014152b6786db72a3d5e60f3bf2", "filename": "src/README", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2FREADME", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2FREADME", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,28 @@\n+This is preliminary version of the Rust compiler.\n+\n+Source layout:\n+\n+boot/              The bootstrap compiler\n+boot/fe            - Front end (lexer, parser, AST)\n+boot/me            - Middle end (resolve, check, layout, trans)\n+boot/be            - Back end (IL, RA, insns, asm, objfiles)\n+boot/util          - Ubiquitous helpers\n+boot/llvm          - LLVM-based alternative back end\n+boot/driver        - Compiler driver\n+\n+comp/              The self-hosted compiler (doesn't exist yet)\n+comp/*             - Same structure as in boot/\n+\n+rt/                The runtime system\n+rt/rust_*.cpp      - The majority of the runtime services\n+rt/isaac           - The PRNG used for pseudo-random choices in the runtime\n+rt/bigint          - The bigint library used for the 'big' type\n+rt/uthash          - Small hashtable-and-list library for C, used in runtime\n+rt/{sync,util}     - Small utility classes for the runtime.\n+\n+test/              Testsuite (for both bootstrap and self-hosted)\n+test/compile-fail  - Tests that should fail to compile\n+test/run-fail      - Tests that should compile, run and fail\n+test/run-pass      - Tests that should compile, run and succeed\n+\n+Please be gentle, it's a work in progress."}, {"sha": "fd9ca750e9151e87aa60780e995e9bc7c45af538", "filename": "src/boot/be/abi.ml", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fabi.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,207 @@\n+\n+(*\n+ * The 'abi' structure is pretty much just a grab-bag of machine\n+ * dependencies and structure-layout information. Part of the latter\n+ * is shared with trans and semant.\n+ *\n+ * Make some attempt to factor it as time goes by.\n+ *)\n+\n+(* Word offsets for structure fields in rust-internal.h, and elsewhere in\n+   compiler. *)\n+\n+let rc_base_field_refcnt = 0;;\n+\n+let task_field_refcnt = rc_base_field_refcnt;;\n+let task_field_stk = task_field_refcnt + 1;;\n+let task_field_runtime_sp = task_field_stk + 1;;\n+let task_field_rust_sp = task_field_runtime_sp + 1;;\n+let task_field_gc_alloc_chain = task_field_rust_sp + 1;;\n+let task_field_dom = task_field_gc_alloc_chain + 1;;\n+let n_visible_task_fields = task_field_dom + 1;;\n+\n+let dom_field_interrupt_flag = 0;;\n+\n+let frame_glue_fns_field_mark = 0;;\n+let frame_glue_fns_field_drop = 1;;\n+let frame_glue_fns_field_reloc = 2;;\n+\n+let exterior_rc_slot_field_refcnt = 0;;\n+let exterior_rc_slot_field_body = 1;;\n+\n+let exterior_gc_slot_field_next = (-2);;\n+let exterior_gc_slot_field_ctrl = (-1);;\n+let exterior_gc_slot_field_refcnt = 0;;\n+let exterior_gc_slot_field_body = 1;;\n+\n+let exterior_rc_header_size = 1;;\n+let exterior_gc_header_size = 3;;\n+\n+let exterior_gc_malloc_return_adjustment = 2;;\n+\n+let stk_field_valgrind_id = 0 + 1;;\n+let stk_field_limit = stk_field_valgrind_id + 1;;\n+let stk_field_data = stk_field_limit + 1;;\n+\n+let binding_size = 2;;\n+let binding_field_item = 0;;\n+let binding_field_binding = 1;;\n+\n+let general_code_alignment = 16;;\n+\n+let tydesc_field_first_param = 0;;\n+let tydesc_field_size = 1;;\n+let tydesc_field_align = 2;;\n+let tydesc_field_copy_glue = 3;;\n+let tydesc_field_drop_glue = 4;;\n+let tydesc_field_free_glue = 5;;\n+let tydesc_field_mark_glue = 6;;\n+let tydesc_field_obj_drop_glue = 7;;\n+\n+let vec_elt_rc = 0;;\n+let vec_elt_alloc = 1;;\n+let vec_elt_fill = 2;;\n+let vec_elt_data = 3;;\n+\n+let calltup_elt_out_ptr = 0;;\n+let calltup_elt_task_ptr = 1;;\n+let calltup_elt_ty_params = 2;;\n+let calltup_elt_args = 3;;\n+let calltup_elt_iterator_args = 4;;\n+let calltup_elt_indirect_args = 5;;\n+\n+let iterator_args_elt_block_fn = 0;;\n+let iterator_args_elt_outer_frame_ptr = 1;;\n+\n+let indirect_args_elt_closure = 0;;\n+\n+(* ty_params, src, dst, tydesc, taskptr. *)\n+let worst_case_glue_call_args = 5;;\n+\n+type abi =\n+  {\n+    abi_word_sz: int64;\n+    abi_word_bits: Il.bits;\n+    abi_word_ty: Common.ty_mach;\n+\n+    abi_is_2addr_machine: bool;\n+    abi_has_pcrel_data: bool;\n+    abi_has_pcrel_code: bool;\n+\n+    abi_n_hardregs: int;\n+    abi_str_of_hardreg: (int -> string);\n+\n+    abi_prealloc_quad: (Il.quad' -> Il.quad');\n+    abi_constrain_vregs: (Il.quad -> Bits.t array -> unit);\n+\n+    abi_emit_fn_prologue: (Il.emitter\n+                           -> Common.size        (* framesz *)\n+                             -> Common.size      (* callsz  *)\n+                               -> Common.nabi\n+                                 -> Common.fixup (* grow_task *)\n+                                   -> unit);\n+\n+    abi_emit_fn_epilogue: (Il.emitter -> unit);\n+\n+    abi_emit_fn_tail_call: (Il.emitter\n+                            -> int64            (* caller_callsz *)\n+                              -> int64          (* caller_argsz  *)\n+                                -> Il.code      (* callee_code   *)\n+                                  -> int64      (* callee_argsz  *)\n+                                    -> unit);\n+\n+    abi_clobbers: (Il.quad -> Il.hreg list);\n+\n+    abi_emit_native_call: (Il.emitter\n+                           -> Il.cell                 (* ret    *)\n+                             -> Common.nabi\n+                               -> Common.fixup        (* callee *)\n+                                 -> Il.operand array  (* args   *)\n+                                   -> unit);\n+\n+    abi_emit_native_void_call: (Il.emitter\n+                                -> Common.nabi\n+                                  -> Common.fixup             (* callee *)\n+                                    -> Il.operand array       (* args   *)\n+                                      -> unit);\n+\n+    abi_emit_native_call_in_thunk: (Il.emitter\n+                                    -> Il.cell                (* ret    *)\n+                                      -> Common.nabi\n+                                        -> Il.operand         (* callee *)\n+                                          -> Il.operand array (* args   *)\n+                                            -> unit);\n+    abi_emit_inline_memcpy: (Il.emitter\n+                             -> int64           (* n_bytes   *)\n+                               -> Il.reg        (* dst_ptr   *)\n+                                 -> Il.reg      (* src_ptr   *)\n+                                   -> Il.reg    (* tmp_reg   *)\n+                                     -> bool    (* ascending *)\n+                                       -> unit);\n+\n+    (* Global glue. *)\n+    abi_activate: (Il.emitter -> unit);\n+    abi_yield: (Il.emitter -> unit);\n+    abi_unwind: (Il.emitter -> Common.nabi -> Common.fixup -> unit);\n+    abi_get_next_pc_thunk:\n+      ((Il.reg                   (* output            *)\n+        * Common.fixup           (* thunk in objfile  *)\n+        * (Il.emitter -> unit))  (* fn to make thunk  *)\n+         option);\n+\n+    abi_sp_reg: Il.reg;\n+    abi_fp_reg: Il.reg;\n+    abi_dwarf_fp_reg: int;\n+    abi_tp_cell: Il.cell;\n+    abi_implicit_args_sz: int64;\n+    abi_frame_base_sz: int64;\n+    abi_frame_info_sz: int64;\n+    abi_spill_slot: (Il.spill -> Il.mem);\n+  }\n+;;\n+\n+let load_fixup_addr\n+    (e:Il.emitter)\n+    (out_reg:Il.reg)\n+    (fix:Common.fixup)\n+    (rty:Il.referent_ty)\n+    : unit =\n+\n+  let cell = Il.Reg (out_reg, Il.AddrTy rty) in\n+  let op = Il.ImmPtr (fix, rty) in\n+    Il.emit e (Il.lea cell op);\n+;;\n+\n+let load_fixup_codeptr\n+    (e:Il.emitter)\n+    (out_reg:Il.reg)\n+    (fixup:Common.fixup)\n+    (has_pcrel_code:bool)\n+    (indirect:bool)\n+    : Il.code =\n+  if indirect\n+  then\n+    begin\n+      load_fixup_addr e out_reg fixup (Il.ScalarTy (Il.AddrTy Il.CodeTy));\n+      Il.CodePtr (Il.Cell (Il.Mem (Il.RegIn (out_reg, None),\n+                                   Il.ScalarTy (Il.AddrTy Il.CodeTy))))\n+    end\n+  else\n+    if has_pcrel_code\n+    then (Il.CodePtr (Il.ImmPtr (fixup, Il.CodeTy)))\n+    else\n+      begin\n+        load_fixup_addr e out_reg fixup Il.CodeTy;\n+        Il.CodePtr (Il.Cell (Il.Reg (out_reg, Il.AddrTy Il.CodeTy)))\n+      end\n+;;\n+\n+\n+(* \n+ * Local Variables:\n+ * fill-column: 78; \n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\"; \n+ * End:\n+ *)"}, {"sha": "10b2142aad695a65fb5bb5b2551c253679e140f2", "filename": "src/boot/be/asm.ml", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fasm.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fasm.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fasm.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,755 @@\n+(*\n+\n+   Our assembler is an all-at-once, buffer-in-memory job, very simple\n+   minded. I have 1gb of memory on my laptop: I don't expect to ever\n+   emit a program that large with this code.\n+\n+   It is based on the 'frag' type, which has a variant for every major\n+   type of machine-blob we know how to write (bytes, zstrings, BSS\n+   blocks, words of various sorts).\n+\n+   A frag can contain symbolic references between the sub-parts of\n+   it. These are accomplished through ref cells we call fixups, and a\n+   2-pass (resolution and writing) process defined recursively over\n+   the frag structure.\n+\n+   Fixups are defined by wrapping a frag in a DEF pseudo-frag with\n+   a fixup attached. This will record information about the wrapped\n+   frag -- positions and sizes -- in the fixup during resolution.\n+\n+   We say \"positions\" and \"sizes\" there, in plural, because both a\n+   file number and a memory number is recorded for each concept.\n+\n+   File numbers refer to positions and sizes in the file we're\n+   generating, and are based on the native int type for the host\n+   platform -- usually 31 or 62 bits -- whereas the expressions that\n+   *use* position fixups tend to promote them up to 32 or 64 bits\n+   somehow. On a 32 bit platform, you can't generate output buffers\n+   with 64-bit positions (ocaml limitation!)\n+\n+   Memory numbers are 64 bit, always, and refer to sizes and positions\n+   of frags when they are loaded into memory in the target. When\n+   you're generating code for a 32-bit target, or using a memory\n+   number in a context that's less than 64 bits, the value is\n+   range-checked and truncated. But in all other respects, we imagine\n+   a 32-bit address space is just the prefix of the continuing 64-bit\n+   address space. If you need to pin an object at a particular place\n+   from the point 2^32-1, say, you will need to do arithmetic and use\n+   the MEMPOS pseudo-frag, that sets the current memory position as\n+   it's being processed.\n+\n+   Fixups can be *used* anywhere else in the frag tree, as many times\n+   as you like. If you try to write an unresolved fixup, the emitter\n+   faults. When you specify the use of a fixup, you need to specify\n+   whether you want to use its file size, file position, memory size,\n+   or memory position.\n+\n+   Positions, addresses, sizes and such, of course, are in bytes.\n+\n+   Expressions are evaluated to an int64 (signed), even if the\n+   expression is an int32 or less. Depending on how you use the result\n+   of the expression, a range check error may fire (for example, if\n+   the expression evaluates to -2^24 and you're emitting a word16).\n+\n+   Word endianness is per-file. At the moment this seems acceptable.\n+\n+   Because we want to be *very specific* about the time and place\n+   arithmetic promotions occur, we define two separate expression-tree\n+   types (with the same polymorphic constructors) and two separate\n+   evaluation functions, with an explicit operator for marking the\n+   promotion-points.\n+\n+*)\n+\n+open Common;;\n+\n+\n+let log (sess:Session.sess) =\n+  Session.log \"asm\"\n+    sess.Session.sess_log_asm\n+    sess.Session.sess_log_out\n+;;\n+\n+let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n+  if sess.Session.sess_log_asm\n+  then thunk ()\n+  else ()\n+;;\n+\n+exception Bad_fit of string;;\n+exception Undef_sym of string;;\n+\n+type ('a, 'b) expr =\n+    IMM of 'a\n+  | ADD of (('a, 'b) expr) * (('a, 'b) expr)\n+  | SUB of (('a, 'b) expr) * (('a, 'b) expr)\n+  | MUL of (('a, 'b) expr) * (('a, 'b) expr)\n+  | DIV of (('a, 'b) expr) * (('a, 'b) expr)\n+  | REM of (('a, 'b) expr) * (('a, 'b) expr)\n+  | MAX of (('a, 'b) expr) * (('a, 'b) expr)\n+  | ALIGN of (('a, 'b) expr) * (('a, 'b) expr)\n+  | SLL of (('a, 'b) expr) * int\n+  | SLR of (('a, 'b) expr) * int\n+  | SAR of (('a, 'b) expr) * int\n+  | AND of (('a, 'b) expr) * (('a, 'b) expr)\n+  | XOR of (('a, 'b) expr) * (('a, 'b) expr)\n+  | OR of (('a, 'b) expr) * (('a, 'b) expr)\n+  | NOT of (('a, 'b) expr)\n+  | NEG of (('a, 'b) expr)\n+  | F_POS of fixup\n+  | F_SZ of fixup\n+  | M_POS of fixup\n+  | M_SZ of fixup\n+  | EXT of 'b\n+\n+type expr32 = (int32, int) expr\n+;;\n+\n+type expr64 = (int64, expr32) expr\n+;;\n+\n+\n+let rec eval32 (e:expr32)\n+    : int32  =\n+  let chop64 kind name v =\n+    let x = Int64.to_int32 v in\n+      if (Int64.compare v (Int64.of_int32 x)) = 0 then\n+        x\n+      else raise (Bad_fit (kind\n+                           ^ \" fixup \"\n+                           ^ name\n+                           ^ \" overflowed 32 bits in eval32: \"\n+                           ^ Int64.to_string v))\n+  in\n+  let expandInt _ _ v = Int32.of_int v in\n+  let checkdef kind name v inj =\n+    match v with\n+        None ->\n+          raise (Undef_sym (kind ^ \" fixup \" ^ name\n+                            ^ \" undefined in eval32\"))\n+      | Some x -> inj kind name x\n+  in\n+  match e with\n+      IMM i -> i\n+    | ADD (a, b) -> Int32.add (eval32 a) (eval32 b)\n+    | SUB (a, b) -> Int32.sub (eval32 a) (eval32 b)\n+    | MUL (a, b) -> Int32.mul (eval32 a) (eval32 b)\n+    | DIV (a, b) -> Int32.div (eval32 a) (eval32 b)\n+    | REM (a, b) -> Int32.rem (eval32 a) (eval32 b)\n+    | MAX (a, b) -> i32_max (eval32 a) (eval32 b)\n+    | ALIGN (a, b) -> i32_align (eval32 a) (eval32 b)\n+    | SLL (a, b) -> Int32.shift_left (eval32 a) b\n+    | SLR (a, b) -> Int32.shift_right_logical (eval32 a) b\n+    | SAR (a, b) -> Int32.shift_right (eval32 a) b\n+    | AND (a, b) -> Int32.logand (eval32 a) (eval32 b)\n+    | XOR (a, b) -> Int32.logxor (eval32 a) (eval32 b)\n+    | OR (a, b) -> Int32.logor (eval32 a) (eval32 b)\n+    | NOT a -> Int32.lognot (eval32 a)\n+    | NEG a -> Int32.neg (eval32 a)\n+    | F_POS f ->\n+        checkdef \"file position\"\n+          f.fixup_name f.fixup_file_pos expandInt\n+    | F_SZ f ->\n+        checkdef \"file size\"\n+          f.fixup_name f.fixup_file_sz expandInt\n+    | M_POS f ->\n+        checkdef \"mem position\"\n+          f.fixup_name f.fixup_mem_pos chop64\n+    | M_SZ f ->\n+        checkdef \"mem size\" f.fixup_name f.fixup_mem_sz chop64\n+    | EXT i -> Int32.of_int i\n+;;\n+\n+let rec eval64 (e:expr64)\n+    : int64  =\n+  let checkdef kind name v inj =\n+    match v with\n+        None ->\n+          raise (Undef_sym (kind ^ \" fixup '\"\n+                            ^ name ^ \"' undefined in eval64\"))\n+      | Some x -> inj x\n+  in\n+  match e with\n+      IMM i -> i\n+    | ADD (a, b) -> Int64.add (eval64 a) (eval64 b)\n+    | SUB (a, b) -> Int64.sub (eval64 a) (eval64 b)\n+    | MUL (a, b) -> Int64.mul (eval64 a) (eval64 b)\n+    | DIV (a, b) -> Int64.div (eval64 a) (eval64 b)\n+    | REM (a, b) -> Int64.rem (eval64 a) (eval64 b)\n+    | MAX (a, b) -> i64_max (eval64 a) (eval64 b)\n+    | ALIGN (a, b) -> i64_align (eval64 a) (eval64 b)\n+    | SLL (a, b) -> Int64.shift_left (eval64 a) b\n+    | SLR (a, b) -> Int64.shift_right_logical (eval64 a) b\n+    | SAR (a, b) -> Int64.shift_right (eval64 a) b\n+    | AND (a, b) -> Int64.logand (eval64 a) (eval64 b)\n+    | XOR (a, b) -> Int64.logxor (eval64 a) (eval64 b)\n+    | OR (a, b) -> Int64.logor (eval64 a) (eval64 b)\n+    | NOT a -> Int64.lognot (eval64 a)\n+    | NEG a -> Int64.neg (eval64 a)\n+    | F_POS f ->\n+        checkdef \"file position\"\n+          f.fixup_name f.fixup_file_pos Int64.of_int\n+    | F_SZ f ->\n+        checkdef \"file size\"\n+          f.fixup_name f.fixup_file_sz Int64.of_int\n+    | M_POS f ->\n+        checkdef \"mem position\"\n+          f.fixup_name f.fixup_mem_pos (fun x -> x)\n+    | M_SZ f ->\n+        checkdef \"mem size\"\n+          f.fixup_name f.fixup_mem_sz (fun x -> x)\n+    | EXT e -> Int64.of_int32 (eval32 e)\n+;;\n+\n+\n+type frag =\n+    MARK  (* MARK == 'PAD (IMM 0L)' *)\n+  | SEQ of frag array\n+  | PAD of int\n+  | BSS of int64\n+  | MEMPOS of int64\n+  | BYTE of int\n+  | BYTES of int array\n+  | CHAR of char\n+  | STRING of string\n+  | ZSTRING of string\n+  | ULEB128 of expr64\n+  | SLEB128 of expr64\n+  | WORD of (ty_mach * expr64)\n+  | ALIGN_FILE of (int * frag)\n+  | ALIGN_MEM of (int * frag)\n+  | DEF of (fixup * frag)\n+  | RELAX of relaxation\n+\n+and relaxation =\n+    { relax_options: frag array;\n+      relax_choice: int ref; }\n+;;\n+\n+exception Relax_more of relaxation;;\n+\n+let new_relaxation (frags:frag array) =\n+  RELAX { relax_options = frags;\n+          relax_choice = ref ((Array.length frags) - 1); }\n+;;\n+\n+\n+let rec write_frag\n+    ~(sess:Session.sess)\n+    ~(lsb0:bool)\n+    ~(buf:Buffer.t)\n+    ~(frag:frag)\n+    : unit =\n+  let relax = Queue.create () in\n+  let bump_relax r =\n+    iflog sess (fun _ ->\n+                  log sess \"bumping relaxation to position %d\"\n+                    ((!(r.relax_choice)) - 1));\n+    r.relax_choice := (!(r.relax_choice)) - 1;\n+    if !(r.relax_choice) < 0\n+    then bug () \"relaxation ran out of options\"\n+  in\n+  let rec loop _ =\n+    Queue.clear relax;\n+    Buffer.clear buf;\n+    resolve_frag_full relax frag;\n+    lower_frag ~sess ~lsb0 ~buf ~relax ~frag;\n+    if Queue.is_empty relax\n+    then ()\n+    else\n+      begin\n+        iflog sess (fun _ -> log sess \"relaxing\");\n+        Queue.iter bump_relax relax;\n+        loop ()\n+      end\n+  in\n+    loop ()\n+\n+\n+and resolve_frag_full (relax:relaxation Queue.t) (frag:frag)\n+    : unit =\n+  let file_pos = ref 0 in\n+  let mem_pos = ref 0L in\n+  let bump i =\n+    mem_pos := Int64.add (!mem_pos) (Int64.of_int i);\n+    file_pos := (!file_pos) + i\n+  in\n+\n+  let uleb (e:expr64) : unit =\n+    let rec loop value =\n+      let value = Int64.shift_right_logical value 7 in\n+        if value = 0L\n+        then bump 1\n+        else\n+          begin\n+            bump 1;\n+            loop value\n+          end\n+    in\n+      loop (eval64 e)\n+  in\n+\n+  let sleb (e:expr64) : unit =\n+    let rec loop value =\n+      let byte = Int64.logand value 0xf7L in\n+      let value = Int64.shift_right value 7 in\n+      let signbit = Int64.logand byte 0x40L in\n+        if (((value = 0L) && (signbit = 0L)) ||\n+              ((value = -1L) && (signbit = 0x40L)))\n+        then bump 1\n+        else\n+          begin\n+            bump 1;\n+            loop value\n+          end\n+    in\n+      loop (eval64 e)\n+  in\n+  let rec resolve_frag it =\n+    match it with\n+      | MARK -> ()\n+      | SEQ frags -> Array.iter resolve_frag frags\n+      | PAD i -> bump i\n+      | BSS i -> mem_pos := Int64.add (!mem_pos) i\n+      | MEMPOS i -> mem_pos := i\n+      | BYTE _ -> bump 1\n+      | BYTES ia -> bump (Array.length ia)\n+      | CHAR _ -> bump 1\n+      | STRING s -> bump (String.length s)\n+      | ZSTRING s -> bump ((String.length s) + 1)\n+      | ULEB128 e -> uleb e\n+      | SLEB128 e -> sleb e\n+      | WORD (mach,_) -> bump (bytes_of_ty_mach mach)\n+      | ALIGN_FILE (n, frag) ->\n+          let spill = (!file_pos) mod n in\n+          let pad = (n - spill) mod n in\n+            file_pos := (!file_pos) + pad;\n+            (*\n+             * NB: aligning the file *causes* likewise alignment of\n+             * memory, since we implement \"file alignment\" by\n+             * padding!\n+             *)\n+            mem_pos := Int64.add (!mem_pos) (Int64.of_int pad);\n+            resolve_frag frag\n+\n+      | ALIGN_MEM (n, frag) ->\n+          let n64 = Int64.of_int n in\n+          let spill = Int64.rem (!mem_pos) n64 in\n+          let pad = Int64.rem (Int64.sub n64 spill) n64 in\n+            mem_pos := Int64.add (!mem_pos) pad;\n+            resolve_frag frag\n+\n+      | DEF (f, i) ->\n+          let fpos1 = !file_pos in\n+          let mpos1 = !mem_pos in\n+            resolve_frag i;\n+            f.fixup_file_pos <- Some fpos1;\n+            f.fixup_mem_pos <- Some mpos1;\n+            f.fixup_file_sz <- Some ((!file_pos) - fpos1);\n+            f.fixup_mem_sz <- Some (Int64.sub (!mem_pos) mpos1)\n+\n+      | RELAX rel ->\n+          begin\n+            try\n+              resolve_frag rel.relax_options.(!(rel.relax_choice))\n+            with\n+                Bad_fit _ -> Queue.add rel relax\n+          end\n+  in\n+    resolve_frag frag\n+\n+and lower_frag\n+    ~(sess:Session.sess)\n+    ~(lsb0:bool)\n+    ~(buf:Buffer.t)\n+    ~(relax:relaxation Queue.t)\n+    ~(frag:frag)\n+    : unit =\n+  let byte (i:int) =\n+    if i < 0\n+    then raise (Bad_fit \"byte underflow\")\n+    else\n+      if i > 255\n+      then raise (Bad_fit \"byte overflow\")\n+      else Buffer.add_char buf (Char.chr i)\n+  in\n+\n+  let uleb (e:expr64) : unit =\n+    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n+    let rec loop value =\n+      let byte = Int64.logand value 0x7fL in\n+      let value = Int64.shift_right_logical value 7 in\n+        if value = 0L\n+        then emit1 byte\n+        else\n+          begin\n+            emit1 (Int64.logor byte 0x80L);\n+            loop value\n+          end\n+    in\n+      loop (eval64 e)\n+  in\n+\n+  let sleb (e:expr64) : unit =\n+    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n+    let rec loop value =\n+      let byte = Int64.logand value 0x7fL in\n+      let value = Int64.shift_right value 7 in\n+      let signbit = Int64.logand byte 0x40L in\n+        if (((value = 0L) && (signbit = 0L)) ||\n+              ((value = -1L) && (signbit = 0x40L)))\n+        then emit1 byte\n+        else\n+          begin\n+            emit1 (Int64.logor byte 0x80L);\n+            loop value\n+          end\n+    in\n+      loop (eval64 e)\n+  in\n+\n+  let word (nbytes:int) (signed:bool) (e:expr64) =\n+    let i = eval64 e in\n+\n+    (*\n+       FIXME:\n+\n+       We should really base the entire assembler and memory-position\n+       system on Big_int.big_int, but in ocaml the big_int type lacks,\n+       oh, just about every useful function (no format string spec, no\n+       bitwise ops, blah blah) so it's useless; we're stuck on int64\n+       for bootstrapping.\n+\n+       For the time being we're just going to require you to represent\n+       those few unsigned 64 bit terms you have in mind via their\n+       signed bit pattern. Suboptimal but it's the best we can do.\n+    *)\n+\n+    let (top,bot) =\n+      if nbytes >= 8\n+      then\n+        if signed\n+        then (Int64.max_int,Int64.min_int)\n+        else (Int64.max_int,0L)\n+      else\n+        if signed\n+        then\n+          let bound = (Int64.shift_left 1L ((8 * nbytes) - 1)) in\n+            (Int64.sub bound 1L, Int64.neg bound)\n+        else\n+          let bound = (Int64.shift_left 1L (8 * nbytes)) in\n+            (Int64.sub bound 1L, 0L)\n+    in\n+\n+    let mask1 = Int64.logand 0xffL in\n+    let shift = Int64.shift_right_logical in\n+    let emit1 k = Buffer.add_char buf (Char.chr (Int64.to_int k)) in\n+      if Int64.compare i bot = (-1)\n+      then raise (Bad_fit (\"word underflow: \"\n+                           ^ (Int64.to_string i)\n+                           ^ \" into \"\n+                           ^ (string_of_int nbytes)\n+                           ^ (if signed then \" signed\" else \" unsigned\")\n+                           ^ \" bytes\"))\n+      else\n+        if Int64.compare i top = 1\n+        then raise (Bad_fit (\"word overflow: \"\n+                             ^ (Int64.to_string i)\n+                             ^ \" into \"\n+                             ^ (string_of_int nbytes)\n+                             ^ (if signed then \" signed\" else \" unsigned\")\n+                             ^ \" bytes\"))\n+        else\n+          if lsb0\n+          then\n+            for n = 0 to (nbytes - 1) do\n+              emit1 (mask1 (shift i (8*n)))\n+            done\n+          else\n+            for n = (nbytes - 1) downto 0 do\n+              emit1 (mask1 (shift i (8*n)))\n+            done\n+  in\n+    match frag with\n+        MARK -> ()\n+\n+      | SEQ frags ->\n+          Array.iter\n+            begin\n+              fun frag ->\n+                lower_frag ~sess ~lsb0 ~buf ~relax ~frag\n+            end frags\n+\n+      | PAD c ->\n+          for i = 1 to c do\n+            Buffer.add_char buf '\\x00'\n+          done\n+\n+      | BSS _ -> ()\n+\n+      | MEMPOS _ -> ()\n+\n+      | BYTE i -> byte i\n+\n+      | BYTES bs ->\n+          iflog sess (fun _ -> log sess \"lowering %d bytes\"\n+                        (Array.length bs));\n+          Array.iter byte bs\n+\n+      | CHAR c ->\n+          iflog sess (fun _ -> log sess \"lowering char: %c\" c);\n+          Buffer.add_char buf c\n+\n+      | STRING s ->\n+          iflog sess (fun _ -> log sess \"lowering string: %s\" s);\n+          Buffer.add_string buf s\n+\n+      | ZSTRING s ->\n+          iflog sess (fun _ -> log sess \"lowering zstring: %s\" s);\n+          Buffer.add_string buf s;\n+          byte 0\n+\n+      | ULEB128 e -> uleb e\n+      | SLEB128 e -> sleb e\n+\n+      | WORD (m,e) ->\n+          iflog sess\n+            (fun _ ->\n+               log sess \"lowering word %s\"\n+                 (string_of_ty_mach m));\n+          word (bytes_of_ty_mach m) (mach_is_signed m) e\n+\n+      | ALIGN_FILE (n, frag) ->\n+          let spill = (Buffer.length buf) mod n in\n+          let pad = (n - spill) mod n in\n+            for i = 1 to pad do\n+              Buffer.add_char buf '\\x00'\n+            done;\n+            lower_frag sess lsb0 buf relax frag\n+\n+      | ALIGN_MEM (_, i) -> lower_frag sess lsb0 buf relax i\n+      | DEF (f, i) ->\n+          iflog sess (fun _ -> log sess \"lowering fixup: %s\" f.fixup_name);\n+          lower_frag sess lsb0 buf relax i;\n+\n+      | RELAX rel ->\n+          begin\n+            try\n+              lower_frag sess lsb0 buf relax\n+                rel.relax_options.(!(rel.relax_choice))\n+            with\n+                Bad_fit _ -> Queue.add rel relax\n+          end\n+;;\n+\n+let fold_flags (f:'a -> int64) (flags:'a list) : int64 =\n+  List.fold_left (Int64.logor) 0x0L (List.map f flags)\n+;;\n+\n+let write_out_frag sess lsb0 frag =\n+  let buf = Buffer.create 0xffff in\n+  let file = Session.filename_of sess.Session.sess_out in\n+  let out = open_out_bin file in\n+    write_frag ~sess ~lsb0 ~buf ~frag;\n+    Buffer.output_buffer out buf;\n+    flush out;\n+    close_out out;\n+    Unix.chmod file 0o755\n+;;\n+\n+(* Asm-reader stuff for loading info back from mapped files. *)\n+(*\n+ * Unfortunately the ocaml Bigarray interface takes 'int' indices, so\n+ * f.e. can't do 64-bit offsets / files when running on a 32bit platform.\n+ * Despite the fact that we can possibly produce them. Sigh. Yet another\n+ * \"bootstrap compiler limitation\".\n+ *)\n+type asm_reader =\n+    {\n+      asm_seek: int -> unit;\n+      asm_get_u32: unit -> int;\n+      asm_get_u16: unit -> int;\n+      asm_get_u8: unit -> int;\n+      asm_get_uleb: unit -> int;\n+      asm_get_zstr: unit -> string;\n+      asm_get_zstr_padded: int -> string;\n+      asm_get_off: unit -> int;\n+      asm_adv: int -> unit;\n+      asm_adv_u32: unit -> unit;\n+      asm_adv_u16: unit -> unit;\n+      asm_adv_u8: unit -> unit;\n+      asm_adv_zstr: unit -> unit;\n+      asm_close: unit -> unit;\n+    }\n+;;\n+\n+type mmap_arr =\n+    (int, Bigarray.int8_unsigned_elt, Bigarray.c_layout)\n+      Bigarray.Array1.t\n+;;\n+\n+let new_asm_reader (sess:Session.sess) (s:filename) : asm_reader =\n+  iflog sess (fun _ -> log sess \"opening file %s\" s);\n+  let fd = Unix.openfile s [ Unix.O_RDONLY ] 0 in\n+  let arr = (Bigarray.Array1.map_file\n+               fd ~pos:0L\n+               Bigarray.int8_unsigned\n+               Bigarray.c_layout\n+               false (-1))\n+  in\n+  let tmp = ref Nativeint.zero in\n+  let buf = Buffer.create 16 in\n+  let off = ref 0 in\n+  let is_open = ref true in\n+  let get_word_as_int (nbytes:int) : int =\n+    assert (!is_open);\n+    let lsb0 = true in\n+      tmp := Nativeint.zero;\n+      if lsb0\n+      then\n+        for j = nbytes-1 downto 0 do\n+          tmp := Nativeint.shift_left (!tmp) 8;\n+          tmp := Nativeint.logor (!tmp) (Nativeint.of_int arr.{(!off) + j})\n+        done\n+      else\n+        for j = 0 to nbytes-1 do\n+          tmp := Nativeint.shift_left (!tmp) 8;\n+          tmp := Nativeint.logor (!tmp) (Nativeint.of_int arr.{(!off) + j})\n+        done;\n+      off := (!off) + nbytes;\n+      Nativeint.to_int (!tmp)\n+  in\n+  let get_zstr_padded pad_opt =\n+    assert (!is_open);\n+    let i = ref (!off) in\n+      Buffer.clear buf;\n+      let buflen_ok _ =\n+        match pad_opt with\n+            None -> true\n+          | Some pad -> (Buffer.length buf) < pad\n+      in\n+      while arr.{!i} != 0 && (buflen_ok()) do\n+        Buffer.add_char buf (Char.chr arr.{!i});\n+        incr i\n+      done;\n+      begin\n+        match pad_opt with\n+            None -> off := (!off) + (Buffer.length buf) + 1\n+          | Some pad ->\n+              begin\n+                assert ((Buffer.length buf) <= pad);\n+                off := (!off) + pad\n+              end\n+      end;\n+      Buffer.contents buf\n+  in\n+  let bump i =\n+    assert (!is_open);\n+    off := (!off) + i\n+  in\n+    {\n+      asm_seek = (fun i -> off := i);\n+      asm_get_u32 = (fun _ -> get_word_as_int 4);\n+      asm_get_u16 = (fun _ -> get_word_as_int 2);\n+      asm_get_u8 = (fun _ -> get_word_as_int 1);\n+      asm_get_uleb =\n+        begin\n+          fun _ ->\n+            let rec loop result shift =\n+              let byte = arr.{!off} in\n+                incr off;\n+                let result = result lor ((byte land 0x7f) lsl shift) in\n+                  if (byte land 0x80) = 0\n+                  then result\n+                  else loop result (shift+7)\n+            in\n+              loop 0 0\n+        end;\n+      asm_get_zstr = (fun _ -> get_zstr_padded None);\n+      asm_get_zstr_padded = (fun pad -> get_zstr_padded (Some pad));\n+      asm_get_off = (fun _ -> !off);\n+      asm_adv = bump;\n+      asm_adv_u32 = (fun _ -> bump 4);\n+      asm_adv_u16 = (fun _ -> bump 2);\n+      asm_adv_u8 = (fun _ -> bump 1);\n+      asm_adv_zstr = (fun _ -> while arr.{!off} != 0\n+                      do incr off done);\n+      asm_close = (fun _ ->\n+                     assert (!is_open);\n+                     Unix.close fd;\n+                     is_open := false)\n+    }\n+;;\n+\n+\n+(* \n+ * Metadata note-section encoding / decoding.\n+ * \n+ * Since the only object format that defines a \"note\" section at all is\n+ * ELF, we model the contents of the metadata section on ELF's\n+ * notes. But the same blob of data is stuck into PE and Mach-O files\n+ * too.\n+ * \n+ * The format is essentially just the ELF note format:\n+ * \n+ *    <un-padded-size-of-name:u32>\n+ *    <size-of-desc:u32>\n+ *    <type-code=0:u32>\n+ *    <name=\"rust\":zstr>\n+ *    <0-pad to 4-byte boundary>\n+ *    <n=meta-count:u32>\n+ *    <k1:zstr> <v1:zstr>\n+ *    ...\n+ *    <kn:zstr> <vn:zstr>\n+ *    <0-pad to 4-byte boundary>\n+ * \n+ *)\n+let note_rust_frags (meta:(Ast.ident * string) array) : frag =\n+  let desc_fixup = new_fixup \".rust.note metadata\" in\n+  let desc =\n+    DEF (desc_fixup,\n+         SEQ [|\n+           WORD (TY_u32, IMM (Int64.of_int (Array.length meta)));\n+           SEQ (Array.map\n+                  (fun (k,v) -> SEQ [| ZSTRING k; ZSTRING v; |])\n+                  meta);\n+           ALIGN_FILE (4, MARK) |])\n+  in\n+  let name = \"rust\" in\n+  let ty = 0L in\n+  let padded_name = SEQ [| ZSTRING name;\n+                           ALIGN_FILE (4, MARK) |]\n+  in\n+  let name_sz = IMM (Int64.of_int ((String.length name) + 1)) in\n+    SEQ [| WORD (TY_u32, name_sz);\n+           WORD (TY_u32, F_SZ desc_fixup);\n+           WORD (TY_u32, IMM ty);\n+           padded_name;\n+           desc;|]\n+;;\n+\n+let read_rust_note (ar:asm_reader) : (Ast.ident * string) array =\n+  ar.asm_adv_u32 ();\n+  ar.asm_adv_u32 ();\n+  assert ((ar.asm_get_u32 ()) = 0);\n+  let rust_name = ar.asm_get_zstr_padded 8 in\n+    assert (rust_name = \"rust\");\n+    let n = ar.asm_get_u32() in\n+    let meta = Queue.create () in\n+      for i = 1 to n\n+      do\n+        let k = ar.asm_get_zstr() in\n+        let v = ar.asm_get_zstr() in\n+          Queue.add (k,v) meta\n+      done;\n+      queue_to_arr meta\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "56905b2a4d41bab088d36ce993a477f051172dc8", "filename": "src/boot/be/elf.ml", "status": "added", "additions": 1760, "deletions": 0, "changes": 1760, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Felf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Felf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Felf.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1760 @@\n+(*\n+ * Module for writing System V ELF files.\n+ *\n+ * FIXME: Presently heavily infected with x86 and elf32 specificities,\n+ * though they are reasonably well marked. Needs to be refactored to\n+ * depend on abi fields if it's to be usable for other elf\n+ * configurations.\n+ *)\n+\n+open Asm;;\n+open Common;;\n+\n+let log (sess:Session.sess) =\n+  Session.log \"obj (elf)\"\n+    sess.Session.sess_log_obj\n+    sess.Session.sess_log_out\n+;;\n+\n+let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n+  if sess.Session.sess_log_obj\n+  then thunk ()\n+  else ()\n+;;\n+\n+\n+(* Fixed sizes of structs involved in elf32 spec. *)\n+let elf32_ehsize = 52L;;\n+let elf32_phentsize = 32L;;\n+let elf32_shentsize = 40L;;\n+let elf32_symsize = 16L;;\n+let elf32_rela_entsz = 0xcL;;\n+\n+type ei_class =\n+    ELFCLASSNONE\n+  | ELFCLASS32\n+  | ELFCLASS64\n+;;\n+\n+\n+type ei_data =\n+    ELFDATANONE\n+  | ELFDATA2LSB\n+  | ELFDATA2MSB\n+;;\n+\n+\n+let elf_identification ei_class ei_data =\n+  SEQ\n+    [|\n+      STRING \"\\x7fELF\";\n+      BYTES\n+        [|\n+          (match ei_class with  (* EI_CLASS *)\n+               ELFCLASSNONE -> 0\n+             | ELFCLASS32 -> 1\n+             | ELFCLASS64 -> 2);\n+          (match ei_data with   (* EI_DATA *)\n+               ELFDATANONE -> 0\n+             | ELFDATA2LSB -> 1\n+             | ELFDATA2MSB -> 2);\n+          1;                    (* EI_VERSION = EV_CURRENT *)\n+          0;                    (* EI_PAD #7 *)\n+          0;                    (* EI_PAD #8 *)\n+          0;                    (* EI_PAD #9 *)\n+          0;                    (* EI_PAD #A *)\n+          0;                    (* EI_PAD #B *)\n+          0;                    (* EI_PAD #C *)\n+          0;                    (* EI_PAD #D *)\n+          0;                    (* EI_PAD #E *)\n+          0;                    (* EI_PAD #F *)\n+        |]\n+    |]\n+;;\n+\n+\n+type e_type =\n+    ET_NONE\n+  | ET_REL\n+  | ET_EXEC\n+  | ET_DYN\n+  | ET_CORE\n+;;\n+\n+\n+type e_machine =\n+    (* Maybe support more later. *)\n+    EM_NONE\n+  | EM_386\n+  | EM_X86_64\n+;;\n+\n+\n+type e_version =\n+    EV_NONE\n+  | EV_CURRENT\n+;;\n+\n+\n+let elf32_header\n+    ~(sess:Session.sess)\n+    ~(ei_data:ei_data)\n+    ~(e_type:e_type)\n+    ~(e_machine:e_machine)\n+    ~(e_version:e_version)\n+    ~(e_entry_fixup:fixup)\n+    ~(e_phoff_fixup:fixup)\n+    ~(e_shoff_fixup:fixup)\n+    ~(e_phnum:int64)\n+    ~(e_shnum:int64)\n+    ~(e_shstrndx:int64)\n+    : frag =\n+  let elf_header_fixup = new_fixup \"elf header\" in\n+  let entry_pos =\n+    if sess.Session.sess_library_mode\n+    then (IMM 0L)\n+    else (M_POS e_entry_fixup)\n+  in\n+    DEF\n+      (elf_header_fixup,\n+       SEQ [| elf_identification ELFCLASS32 ei_data;\n+              WORD (TY_u16, (IMM (match e_type with\n+                                      ET_NONE -> 0L\n+                                    | ET_REL -> 1L\n+                                    | ET_EXEC -> 2L\n+                                    | ET_DYN -> 3L\n+                                    | ET_CORE -> 4L)));\n+              WORD (TY_u16, (IMM (match e_machine with\n+                                      EM_NONE -> 0L\n+                                    | EM_386 -> 3L\n+                                    | EM_X86_64 -> 62L)));\n+              WORD (TY_u32, (IMM (match e_version with\n+                                      EV_NONE -> 0L\n+                                    | EV_CURRENT -> 1L)));\n+              WORD (TY_u32, entry_pos);\n+              WORD (TY_u32, (F_POS e_phoff_fixup));\n+              WORD (TY_u32, (F_POS e_shoff_fixup));\n+              WORD (TY_u32, (IMM 0L)); (* e_flags *)\n+              WORD (TY_u16, (IMM elf32_ehsize));\n+              WORD (TY_u16, (IMM elf32_phentsize));\n+              WORD (TY_u16, (IMM e_phnum));\n+              WORD (TY_u16, (IMM elf32_shentsize));\n+              WORD (TY_u16, (IMM e_shnum));\n+              WORD (TY_u16, (IMM e_shstrndx));\n+           |])\n+;;\n+\n+\n+type sh_type =\n+    SHT_NULL\n+  | SHT_PROGBITS\n+  | SHT_SYMTAB\n+  | SHT_STRTAB\n+  | SHT_RELA\n+  | SHT_HASH\n+  | SHT_DYNAMIC\n+  | SHT_NOTE\n+  | SHT_NOBITS\n+  | SHT_REL\n+  | SHT_SHLIB\n+  | SHT_DYNSYM\n+;;\n+\n+\n+type sh_flags =\n+    SHF_WRITE\n+  | SHF_ALLOC\n+  | SHF_EXECINSTR\n+;;\n+\n+\n+let section_header\n+    ~(shstring_table_fixup:fixup)\n+    ~(shname_string_fixup:fixup)\n+    ~(sh_type:sh_type)\n+    ~(sh_flags:sh_flags list)\n+    ~(section_fixup:fixup option)\n+    ~(sh_addralign:int64)\n+    ~(sh_entsize:int64)\n+    ~(sh_link:int64 option)\n+    : frag =\n+  SEQ\n+    [|\n+      WORD (TY_i32, (SUB\n+                       ((F_POS shname_string_fixup),\n+                        (F_POS shstring_table_fixup))));\n+      WORD (TY_u32, (IMM (match sh_type with\n+                              SHT_NULL -> 0L\n+                            | SHT_PROGBITS -> 1L\n+                            | SHT_SYMTAB -> 2L\n+                            | SHT_STRTAB -> 3L\n+                            | SHT_RELA -> 4L\n+                            | SHT_HASH -> 5L\n+                            | SHT_DYNAMIC -> 6L\n+                            | SHT_NOTE -> 7L\n+                            | SHT_NOBITS -> 8L\n+                            | SHT_REL -> 9L\n+                            | SHT_SHLIB -> 10L\n+                            | SHT_DYNSYM -> 11L)));\n+      WORD (TY_u32, (IMM (fold_flags\n+                            (fun f -> match f with\n+                                 SHF_WRITE -> 0x1L\n+                               | SHF_ALLOC -> 0x2L\n+                               | SHF_EXECINSTR -> 0x4L) sh_flags)));\n+      WORD (TY_u32, (match section_fixup with\n+                         None -> (IMM 0L)\n+                       | Some s -> (M_POS s)));\n+      WORD (TY_u32, (match section_fixup with\n+                         None -> (IMM 0L)\n+                       | Some s -> (F_POS s)));\n+      WORD (TY_u32, (match section_fixup with\n+                         None -> (IMM 0L)\n+                       | Some s -> (F_SZ s)));\n+      WORD (TY_u32, (IMM (match sh_link with\n+                              None -> 0L\n+                            | Some i -> i)));\n+      WORD (TY_u32, (IMM 0L)); (* sh_info *)\n+      WORD (TY_u32, (IMM sh_addralign));\n+      WORD (TY_u32, (IMM sh_entsize));\n+    |]\n+;;\n+\n+\n+type p_type =\n+    PT_NULL\n+  | PT_LOAD\n+  | PT_DYNAMIC\n+  | PT_INTERP\n+  | PT_NOTE\n+  | PT_SHLIB\n+  | PT_PHDR\n+;;\n+\n+\n+type p_flag =\n+    PF_X\n+  | PF_W\n+  | PF_R\n+;;\n+\n+\n+let program_header\n+    ~(p_type:p_type)\n+    ~(segment_fixup:fixup)\n+    ~(p_flags:p_flag list)\n+    ~(p_align:int64)\n+    : frag =\n+  SEQ\n+    [|\n+      WORD (TY_u32, (IMM (match p_type with\n+                              PT_NULL -> 0L\n+                            | PT_LOAD -> 1L\n+                            | PT_DYNAMIC -> 2L\n+                            | PT_INTERP -> 3L\n+                            | PT_NOTE -> 4L\n+                            | PT_SHLIB -> 5L\n+                            | PT_PHDR -> 6L)));\n+      WORD (TY_u32, (F_POS segment_fixup));\n+      WORD (TY_u32, (M_POS segment_fixup));\n+      WORD (TY_u32, (M_POS segment_fixup));\n+      WORD (TY_u32, (F_SZ segment_fixup));\n+      WORD (TY_u32, (M_SZ segment_fixup));\n+      WORD (TY_u32, (IMM (fold_flags\n+                            (fun f ->\n+                               match f with\n+                                   PF_X -> 0x1L\n+                                 | PF_W -> 0x2L\n+                                 | PF_R -> 0x4L)\n+                            p_flags)));\n+      WORD (TY_u32, (IMM p_align));\n+    |]\n+;;\n+\n+\n+type st_bind =\n+    STB_LOCAL\n+  | STB_GLOBAL\n+  | STB_WEAK\n+;;\n+\n+\n+type st_type =\n+    STT_NOTYPE\n+  | STT_OBJECT\n+  | STT_FUNC\n+  | STT_SECTION\n+  | STT_FILE\n+;;\n+\n+\n+(* Special symbol-section indices *)\n+let shn_UNDEF   = 0L;;\n+let shn_ABS     = 0xfff1L;;\n+let shn_ABS     = 0xfff2L;;\n+\n+\n+let symbol\n+    ~(string_table_fixup:fixup)\n+    ~(name_string_fixup:fixup)\n+    ~(sym_target_fixup:fixup option)\n+    ~(st_bind:st_bind)\n+    ~(st_type:st_type)\n+    ~(st_shndx:int64)\n+    : frag =\n+  let st_bind_num =\n+    match st_bind with\n+        STB_LOCAL -> 0L\n+      | STB_GLOBAL -> 1L\n+      | STB_WEAK -> 2L\n+  in\n+  let st_type_num =\n+    match st_type with\n+        STT_NOTYPE -> 0L\n+      | STT_OBJECT -> 1L\n+      | STT_FUNC -> 2L\n+      | STT_SECTION -> 3L\n+      | STT_FILE -> 4L\n+  in\n+    SEQ\n+      [|\n+        WORD (TY_u32, (SUB\n+                         ((F_POS name_string_fixup),\n+                          (F_POS string_table_fixup))));\n+        WORD (TY_u32, (match sym_target_fixup with\n+                           None -> (IMM 0L)\n+                         | Some f -> (M_POS f)));\n+        WORD (TY_u32, (match sym_target_fixup with\n+                           None -> (IMM 0L)\n+                         | Some f -> (M_SZ f)));\n+        WORD (TY_u8,           (* st_info *)\n+              (OR\n+                 ((SLL ((IMM st_bind_num), 4)),\n+                  (AND ((IMM st_type_num), (IMM 0xfL))))));\n+        WORD (TY_u8, (IMM 0L)); (* st_other *)\n+        WORD (TY_u16, (IMM st_shndx));\n+      |]\n+;;\n+\n+type d_tag =\n+    DT_NULL\n+  | DT_NEEDED\n+  | DT_PLTRELSZ\n+  | DT_PLTGOT\n+  | DT_HASH\n+  | DT_STRTAB\n+  | DT_SYMTAB\n+  | DT_RELA\n+  | DT_RELASZ\n+  | DT_RELAENT\n+  | DT_STRSZ\n+  | DT_SYMENT\n+  | DT_INIT\n+  | DT_FINI\n+  | DT_SONAME\n+  | DT_RPATH\n+  | DT_SYMBOLIC\n+  | DT_REL\n+  | DT_RELSZ\n+  | DT_RELENT\n+  | DT_PLTREL\n+  | DT_DEBUG\n+  | DT_TEXTREL\n+  | DT_JMPREL\n+  | DT_BIND_NOW\n+  | DT_INIT_ARRAY\n+  | DT_FINI_ARRAY\n+  | DT_INIT_ARRAYSZ\n+  | DT_FINI_ARRAYSZ\n+  | DT_RUNPATH\n+  | DT_FLAGS\n+  | DT_ENCODING\n+  | DT_PREINIT_ARRAY\n+  | DT_PREINIT_ARRAYSZ\n+;;\n+\n+type elf32_dyn = (d_tag * expr64);;\n+\n+let elf32_num_of_dyn_tag tag =\n+  match tag with\n+      DT_NULL -> 0L\n+    | DT_NEEDED -> 1L\n+    | DT_PLTRELSZ -> 2L\n+    | DT_PLTGOT -> 3L\n+    | DT_HASH -> 4L\n+    | DT_STRTAB -> 5L\n+    | DT_SYMTAB -> 6L\n+    | DT_RELA -> 7L\n+    | DT_RELASZ -> 8L\n+    | DT_RELAENT -> 9L\n+    | DT_STRSZ -> 10L\n+    | DT_SYMENT -> 11L\n+    | DT_INIT -> 12L\n+    | DT_FINI -> 13L\n+    | DT_SONAME -> 14L\n+    | DT_RPATH -> 15L\n+    | DT_SYMBOLIC -> 16L\n+    | DT_REL -> 17L\n+    | DT_RELSZ -> 18L\n+    | DT_RELENT -> 19L\n+    | DT_PLTREL -> 20L\n+    | DT_DEBUG -> 21L\n+    | DT_TEXTREL -> 22L\n+    | DT_JMPREL -> 23L\n+    | DT_BIND_NOW -> 24L\n+    | DT_INIT_ARRAY -> 25L\n+    | DT_FINI_ARRAY -> 26L\n+    | DT_INIT_ARRAYSZ -> 27L\n+    | DT_FINI_ARRAYSZ -> 28L\n+    | DT_RUNPATH -> 29L\n+    | DT_FLAGS -> 30L\n+    | DT_ENCODING -> 31L\n+    | DT_PREINIT_ARRAY -> 32L\n+    | DT_PREINIT_ARRAYSZ -> 33L\n+;;\n+\n+let elf32_dyn_frag d =\n+  let (tag, expr) = d in\n+  let tagval = elf32_num_of_dyn_tag tag in\n+    SEQ [| WORD (TY_u32, (IMM tagval)); WORD (TY_u32, expr) |]\n+;;\n+\n+type elf32_386_reloc_type =\n+    R_386_NONE\n+  | R_386_32\n+  | R_386_PC32\n+  | R_386_GOT32\n+  | R_386_PLT32\n+  | R_386_COPY\n+  | R_386_GLOB_DAT\n+  | R_386_JMP_SLOT\n+  | R_386_RELATIVE\n+  | R_386_GOTOFF\n+  | R_386_GOTPC\n+;;\n+\n+\n+type elf32_386_rela =\n+    { elf32_386_rela_type: elf32_386_reloc_type;\n+      elf32_386_rela_offset: expr64;\n+      elf32_386_rela_sym: expr64;\n+      elf32_386_rela_addend: expr64 }\n+;;\n+\n+let elf32_386_rela_frag r =\n+  let type_val =\n+    match r.elf32_386_rela_type with\n+        R_386_NONE -> 0L\n+      | R_386_32 -> 1L\n+      | R_386_PC32 -> 2L\n+      | R_386_GOT32 -> 3L\n+      | R_386_PLT32 -> 4L\n+      | R_386_COPY -> 5L\n+      | R_386_GLOB_DAT -> 6L\n+      | R_386_JMP_SLOT -> 7L\n+      | R_386_RELATIVE -> 8L\n+      | R_386_GOTOFF -> 9L\n+      | R_386_GOTPC -> 10L\n+  in\n+  let info_expr =\n+    WORD (TY_u32,\n+          (OR\n+             (SLL ((r.elf32_386_rela_sym), 8),\n+              AND ((IMM 0xffL), (IMM type_val)))))\n+  in\n+    SEQ [| WORD (TY_u32, r.elf32_386_rela_offset);\n+           info_expr;\n+           WORD (TY_u32, r.elf32_386_rela_addend) |]\n+;;\n+\n+\n+let elf32_linux_x86_file\n+    ~(sess:Session.sess)\n+    ~(crate:Ast.crate)\n+    ~(entry_name:string)\n+    ~(text_frags:(string option, frag) Hashtbl.t)\n+    ~(data_frags:(string option, frag) Hashtbl.t)\n+    ~(rodata_frags:(string option, frag) Hashtbl.t)\n+    ~(required_fixups:(string, fixup) Hashtbl.t)\n+    ~(dwarf:Dwarf.debug_records)\n+    ~(sem:Semant.ctxt)\n+    ~(needed_libs:string array)\n+    : frag =\n+\n+  (* Procedure Linkage Tables (PLTs), Global Offset Tables\n+   * (GOTs), and the relocations that set them up:\n+   *\n+   * The PLT goes in a section called .plt and GOT in a section called\n+   * .got. The portion of the GOT that holds PLT jump slots goes in a\n+   * section called .got.plt. Dynamic relocations for these jump slots go in\n+   * section .rela.plt.\n+   *\n+   * The easiest way to understand the PLT/GOT system is to draw it:\n+   *\n+   *     PLT                          GOT\n+   *   +----------------------+     +----------------------+\n+   *  0| push &<GOT[1]>            0| <reserved>\n+   *   | jmp *GOT[2]               1| <libcookie>\n+   *   |                           2| & <ld.so:resolve-a-sym>\n+   *  1| jmp *GOT[3]               3| & <'push 0' in PLT[1]>\n+   *   | push 0                    4| & <'push 1' in PLT[2]>\n+   *   | jmp *PLT[0]               5| & <'push 2' in PLT[3]>\n+   *   |\n+   *  2| jmp *GOT[4]\n+   *   | push 1\n+   *   | jmp *PLT[0]\n+   *   |\n+   *  2| jmp *GOT[5]\n+   *   | push 2\n+   *   | jmp *PLT[0]\n+   *\n+   *\n+   * In normal user code, we call PLT entries with a call to a\n+   * PC-relative address, the PLT entry, which itself does an indirect\n+   * jump through a slot in the GOT that it also addresses\n+   * PC-relative. This makes the whole scheme PIC.\n+   *\n+   * The linker fills in the GOT on startup. For the first 3, it uses\n+   * its own thinking. For the remainder it needs to be instructed to\n+   * fill them in with \"jump slot relocs\", type R_386_JUMP_SLOT, each\n+   * of which says in effect which PLT entry it's to point back to and\n+   * which symbol it's to be resolved to later. These relocs go in the\n+   * section .rela.plt.\n+   *)\n+\n+    let plt0_fixup = new_fixup \"PLT[0]\" in\n+    let got_prefix = SEQ [| WORD (TY_u32, (IMM 0L));\n+                            WORD (TY_u32, (IMM 0L));\n+                            WORD (TY_u32, (IMM 0L)); |]\n+    in\n+\n+    let got_cell reg i =\n+      let got_entry_off = Int64.of_int (i*4) in\n+      let got_entry_mem = Il.RegIn (reg, (Some (Asm.IMM got_entry_off))) in\n+        Il.Mem (got_entry_mem, Il.ScalarTy (Il.AddrTy Il.CodeTy))\n+    in\n+\n+    let got_code_cell reg i =\n+      Il.CodePtr (Il.Cell (got_cell reg i))\n+    in\n+\n+    let plt0_frag =\n+      let reg = Il.Hreg X86.eax in\n+      let e = X86.new_emitter_without_vregs () in\n+        Il.emit e (Il.Push (Il.Cell (got_cell reg 1)));\n+        Il.emit e (Il.jmp Il.JMP (got_code_cell reg 2));\n+        Il.emit e Il.Nop;\n+        Il.emit e Il.Nop;\n+        Il.emit e Il.Nop;\n+        Il.emit e Il.Nop;\n+        DEF (plt0_fixup, (X86.frags_of_emitted_quads sess e))\n+    in\n+\n+  (*\n+   * The existence of the GOT/PLT mish-mash causes, therefore, the\n+   * following new sections:\n+   *\n+   *   .plt       - the PLT itself, in the r/x text segment\n+   *   .got.plt   - the PLT-used portion of the GOT, in the r/w segment\n+   *   .rela.plt  - the dynamic relocs for the GOT-PLT, in the r/x segment\n+   *\n+   * In addition, because we're starting up a dynamically linked executable,\n+   * we have to have several more sections!\n+   *\n+   *   .interp    - the read-only section that names ld.so\n+   *   .dynsym    - symbols named by the PLT/GOT entries, r/x segment\n+   *   .dynstr    - string-names used in those symbols, r/x segment\n+   *   .hash      - hashtable in which to look these up, r/x segment\n+   *   .dynamic   - the machine-readable description of the dynamic\n+   *                linkage requirements of this elf file, in the\n+   *                r/w _DYNAMIC segment\n+   *\n+   * The Dynamic section contains a sequence of 2-word records of type\n+   * d_tag.\n+   *\n+   *)\n+\n+    (* There are 17 official section headers in the file we're making:  *)\n+    (*                                                                  *)\n+    (* section 0: <null section>                                        *)\n+    (*                                                                  *)\n+    (* section 1:  .interp            (segment 1: R+X, INTERP)          *)\n+    (*                                                                  *)\n+    (* section 2:  .text              (segment 2: R+X, LOAD)            *)\n+    (* section 3:  .rodata                   ...                        *)\n+    (* section 4:  .dynsym                   ...                        *)\n+    (* section 5:  .dynstr                   ...                        *)\n+    (* section 6:  .hash                     ...                        *)\n+    (* section 7:  .plt                      ...                        *)\n+    (* section 8:  .got                      ...                        *)\n+    (* section 9:  .rela.plt                 ...                        *)\n+    (*                                                                  *)\n+    (* section 10: .data              (segment 3: R+W, LOAD)            *)\n+    (* section 11: .bss                      ...                        *)\n+    (*                                                                  *)\n+    (* section 12: .dynamic           (segment 4: R+W, DYNAMIC)         *)\n+    (*                                                                  *)\n+    (* section 13: .shstrtab          (not in a segment)                *)\n+    (* section 14: .debug_aranges     (segment 2: cont'd)               *)\n+    (* section 15: .debug_pubnames           ...                        *)\n+    (* section 14: .debug_info               ...                        *)\n+    (* section 15: .debug_abbrev             ...                        *)\n+    (* section 14: .debug_line               ...                        *)\n+    (* section 15: .debug_frame              ...                        *)\n+    (* section 16: .note..rust        (segment 5: NOTE)                 *)\n+\n+    let sname s =\n+      new_fixup (Printf.sprintf \"string name of '%s' section\" s)\n+    in\n+    let null_section_name_fixup = sname \"<null>\" in\n+    let interp_section_name_fixup = sname \".interp\"in\n+    let text_section_name_fixup = sname \".text\" in\n+    let rodata_section_name_fixup = sname \".rodata\" in\n+    let dynsym_section_name_fixup = sname \".dynsym\" in\n+    let dynstr_section_name_fixup = sname \".dynstr\" in\n+    let hash_section_name_fixup = sname \".hash\" in\n+    let plt_section_name_fixup = sname \".plt\" in\n+    let got_plt_section_name_fixup = sname \".got.plt\" in\n+    let rela_plt_section_name_fixup = sname \".rela.plt\" in\n+    let data_section_name_fixup = sname \".data\" in\n+    let bss_section_name_fixup = sname \".bss\" in\n+    let dynamic_section_name_fixup = sname \".dynamic\" in\n+    let shstrtab_section_name_fixup = sname \".shstrtab\" in\n+    let debug_aranges_section_name_fixup = sname \".debug_aranges\" in\n+    let debug_pubnames_section_name_fixup = sname \".debug_pubnames\" in\n+    let debug_info_section_name_fixup = sname \".debug_info\" in\n+    let debug_abbrev_section_name_fixup = sname \".debug_abbrev\" in\n+    let debug_line_section_name_fixup = sname \".debug_line\" in\n+    let debug_frame_section_name_fixup = sname \".debug_frame\" in\n+    let note_rust_section_name_fixup = sname \".note.rust\" in\n+\n+  (* let interpndx      = 1L in *)  (* Section index of .interp *)\n+  let textndx        = 2L in  (* Section index of .text *)\n+  let rodatandx      = 3L in  (* Section index of .rodata *)\n+  let dynsymndx      = 4L in  (* Section index of .dynsym *)\n+  let dynstrndx      = 5L in  (* Section index of .dynstr *)\n+  (* let hashndx        = 6L in *)  (* Section index of .hash *)\n+  (* let pltndx         = 7L in *)  (* Section index of .plt *)\n+  (* let gotpltndx      = 8L in *)  (* Section index of .got.plt *)\n+  (* let relapltndx     = 9L in *)  (* Section index of .rela.plt *)\n+  let datandx        = 10L in  (* Section index of .data *)\n+  (* let bssndx         = 11L in *) (* Section index of .bss *)\n+  (* let dynamicndx     = 12L in *) (* Section index of .dynamic *)\n+  let shstrtabndx    = 13L in (* Section index of .shstrtab *)\n+\n+  let section_header_table_fixup = new_fixup \".section header table\" in\n+  let interp_section_fixup = new_fixup \".interp section\" in\n+  let text_section_fixup = new_fixup \".text section\" in\n+  let rodata_section_fixup = new_fixup \".rodata section\" in\n+  let dynsym_section_fixup = new_fixup \".dynsym section\" in\n+  let dynstr_section_fixup = new_fixup \".dynstr section\" in\n+  let hash_section_fixup = new_fixup \".hash section\" in\n+  let plt_section_fixup = new_fixup \".plt section\" in\n+  let got_plt_section_fixup = new_fixup \".got.plt section\" in\n+  let rela_plt_section_fixup = new_fixup \".rela.plt section\" in\n+  let data_section_fixup = new_fixup \".data section\" in\n+  let bss_section_fixup = new_fixup \".bss section\" in\n+  let dynamic_section_fixup = new_fixup \".dynamic section\" in\n+  let shstrtab_section_fixup = new_fixup \".shstrtab section\" in\n+  let note_rust_section_fixup = new_fixup \".shstrtab section\" in\n+\n+  let shstrtab_section =\n+    SEQ\n+      [|\n+        DEF (null_section_name_fixup, ZSTRING \"\");\n+        DEF (interp_section_name_fixup, ZSTRING \".interp\");\n+        DEF (text_section_name_fixup, ZSTRING \".text\");\n+        DEF (rodata_section_name_fixup, ZSTRING \".rodata\");\n+        DEF (dynsym_section_name_fixup, ZSTRING \".dynsym\");\n+        DEF (dynstr_section_name_fixup, ZSTRING \".dynstr\");\n+        DEF (hash_section_name_fixup, ZSTRING \".hash\");\n+        DEF (plt_section_name_fixup, ZSTRING \".plt\");\n+        DEF (got_plt_section_name_fixup, ZSTRING \".got.plt\");\n+        DEF (rela_plt_section_name_fixup, ZSTRING \".rela.plt\");\n+        DEF (data_section_name_fixup, ZSTRING \".data\");\n+        DEF (bss_section_name_fixup, ZSTRING \".bss\");\n+        DEF (dynamic_section_name_fixup, ZSTRING \".dynamic\");\n+        DEF (shstrtab_section_name_fixup, ZSTRING \".shstrtab\");\n+        DEF (debug_aranges_section_name_fixup, ZSTRING \".debug_aranges\");\n+        DEF (debug_pubnames_section_name_fixup, ZSTRING \".debug_pubnames\");\n+        DEF (debug_info_section_name_fixup, ZSTRING \".debug_info\");\n+        DEF (debug_abbrev_section_name_fixup, ZSTRING \".debug_abbrev\");\n+        DEF (debug_line_section_name_fixup, ZSTRING \".debug_line\");\n+        DEF (debug_frame_section_name_fixup, ZSTRING \".debug_frame\");\n+        DEF (note_rust_section_name_fixup, ZSTRING \".note.rust\");\n+      |]\n+  in\n+\n+  let section_headers =\n+    [|\n+        (* <null> *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: null_section_name_fixup\n+           ~sh_type: SHT_NULL\n+           ~sh_flags: []\n+           ~section_fixup: None\n+           ~sh_addralign: 0L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .interp *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: interp_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some interp_section_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .text *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: text_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC; SHF_EXECINSTR ]\n+           ~section_fixup: (Some text_section_fixup)\n+           ~sh_addralign: 32L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .rodata *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: rodata_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some rodata_section_fixup)\n+           ~sh_addralign: 32L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .dynsym *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: dynsym_section_name_fixup\n+           ~sh_type: SHT_DYNSYM\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some dynsym_section_fixup)\n+           ~sh_addralign: 8L\n+           ~sh_entsize: elf32_symsize\n+           ~sh_link: (Some dynstrndx) );\n+\n+        (* .dynstr *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: dynstr_section_name_fixup\n+           ~sh_type: SHT_STRTAB\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some dynstr_section_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .hash *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: hash_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some hash_section_fixup)\n+           ~sh_addralign: 4L\n+           ~sh_entsize: 4L\n+           ~sh_link: (Some dynsymndx));\n+\n+        (* .plt *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: plt_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC; SHF_EXECINSTR ]\n+           ~section_fixup: (Some plt_section_fixup)\n+           ~sh_addralign: 4L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .got.plt *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: got_plt_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n+           ~section_fixup: (Some got_plt_section_fixup)\n+           ~sh_addralign: 4L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .rela.plt *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: rela_plt_section_name_fixup\n+           ~sh_type: SHT_RELA\n+           ~sh_flags: [ SHF_ALLOC ]\n+           ~section_fixup: (Some rela_plt_section_fixup)\n+           ~sh_addralign: 4L\n+           ~sh_entsize: elf32_rela_entsz\n+           ~sh_link: (Some dynsymndx));\n+\n+        (* .data *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: data_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n+           ~section_fixup: (Some data_section_fixup)\n+           ~sh_addralign: 32L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .bss *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: bss_section_name_fixup\n+           ~sh_type: SHT_NOBITS\n+           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n+           ~section_fixup: (Some bss_section_fixup)\n+           ~sh_addralign: 32L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .dynamic *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: dynamic_section_name_fixup\n+           ~sh_type: SHT_DYNAMIC\n+           ~sh_flags: [ SHF_ALLOC; SHF_WRITE ]\n+           ~section_fixup: (Some dynamic_section_fixup)\n+           ~sh_addralign: 8L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .shstrtab *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: shstrtab_section_name_fixup\n+           ~sh_type: SHT_STRTAB\n+           ~sh_flags: []\n+           ~section_fixup: (Some shstrtab_section_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+(* \n+   FIXME: uncomment the dwarf section headers as you make use of them;\n+   recent gdb versions have got fussier about parsing dwarf and don't\n+   like seeing junk there. \n+*)\n+\n+        (* .debug_aranges *)\n+(*\n+\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_aranges_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_aranges_fixup)\n+           ~sh_addralign: 8L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+*)\n+        (* .debug_pubnames *)\n+(*\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_pubnames_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_pubnames_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+*)\n+\n+        (* .debug_info *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_info_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_info_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+        (* .debug_abbrev *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_abbrev_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_abbrev_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+        (* .debug_line *)\n+(*\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_line_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_line_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+*)\n+\n+        (* .debug_frame *)\n+(*\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: debug_frame_section_name_fixup\n+           ~sh_type: SHT_PROGBITS\n+           ~sh_flags: []\n+           ~section_fixup: (Some sem.Semant.ctxt_debug_frame_fixup)\n+           ~sh_addralign: 4L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+*)\n+\n+        (* .note.rust *)\n+        (section_header\n+           ~shstring_table_fixup: shstrtab_section_fixup\n+           ~shname_string_fixup: note_rust_section_name_fixup\n+           ~sh_type: SHT_NOTE\n+           ~sh_flags: []\n+           ~section_fixup: (Some note_rust_section_fixup)\n+           ~sh_addralign: 1L\n+           ~sh_entsize: 0L\n+           ~sh_link: None);\n+\n+      |]\n+  in\n+  let section_header_table = SEQ section_headers in\n+\n+\n+  (* There are 6 official program headers in the file we're making:   *)\n+  (* segment 0: RX / PHDR                                             *)\n+  (* segment 1: R  / INTERP                                           *)\n+  (* segment 2: RX / LOAD                                             *)\n+  (* segment 3: RW / LOAD                                             *)\n+  (* segment 4: RW / DYNAMIC                                          *)\n+  (* segment 5: R                                                     *)\n+\n+  let program_header_table_fixup = new_fixup \"program header table\" in\n+  let segment_0_fixup = new_fixup \"segment 0\" in\n+  let segment_1_fixup = new_fixup \"segment 1\" in\n+  let segment_2_fixup = new_fixup \"segment 2\" in\n+  let segment_3_fixup = new_fixup \"segment 3\" in\n+  let segment_4_fixup = new_fixup \"segment 4\" in\n+  let segment_5_fixup = new_fixup \"segment 5\" in\n+\n+  let segment_0_align = 4 in\n+  let segment_1_align = 1 in\n+  let segment_2_align = 0x1000 in\n+  let segment_3_align = 0x1000 in\n+  let segment_4_align = 0x1000 in\n+  let segment_5_align = 1 in\n+\n+  let program_headers = [|\n+        (program_header\n+           ~p_type: PT_PHDR\n+           ~segment_fixup: segment_0_fixup\n+           ~p_flags: [ PF_R; PF_X ]\n+           ~p_align: (Int64.of_int segment_0_align));\n+        (program_header\n+           ~p_type: PT_INTERP\n+           ~segment_fixup: segment_1_fixup\n+           ~p_flags: [ PF_R ]\n+           ~p_align: (Int64.of_int segment_1_align));\n+        (program_header\n+           ~p_type: PT_LOAD\n+           ~segment_fixup: segment_2_fixup\n+           ~p_flags: [ PF_R; PF_X ]\n+           ~p_align: (Int64.of_int segment_2_align));\n+        (program_header\n+           ~p_type: PT_LOAD\n+           ~segment_fixup: segment_3_fixup\n+           ~p_flags: [ PF_R; PF_W ]\n+           ~p_align: (Int64.of_int segment_3_align));\n+        (program_header\n+           ~p_type: PT_DYNAMIC\n+           ~segment_fixup: segment_4_fixup\n+           ~p_flags: [ PF_R; PF_W ]\n+           ~p_align: (Int64.of_int segment_4_align));\n+        (program_header\n+           ~p_type: PT_NOTE\n+           ~segment_fixup: segment_5_fixup\n+           ~p_flags: [ PF_R;]\n+           ~p_align: (Int64.of_int segment_5_align));\n+      |]\n+  in\n+  let program_header_table = SEQ program_headers in\n+\n+  let e_entry_fixup = new_fixup \"entry symbol\" in\n+\n+  let elf_header =\n+    elf32_header\n+      ~sess\n+      ~ei_data: ELFDATA2LSB\n+      ~e_type: ET_DYN\n+      ~e_machine: EM_386\n+      ~e_version: EV_CURRENT\n+\n+      ~e_entry_fixup: e_entry_fixup\n+      ~e_phoff_fixup: program_header_table_fixup\n+      ~e_shoff_fixup: section_header_table_fixup\n+      ~e_phnum: (Int64.of_int (Array.length program_headers))\n+      ~e_shnum: (Int64.of_int (Array.length section_headers))\n+      ~e_shstrndx: shstrtabndx\n+  in\n+\n+  let n_syms = ref 1 in (* The empty symbol, implicit. *)\n+\n+  let data_sym name st_bind fixup =\n+    let name_fixup = new_fixup (\"data symbol name fixup: '\" ^ name ^ \"'\") in\n+    let strtab_entry = DEF (name_fixup, ZSTRING name) in\n+    let symtab_entry =\n+      symbol\n+        ~string_table_fixup: dynstr_section_fixup\n+        ~name_string_fixup: name_fixup\n+        ~sym_target_fixup: (Some fixup)\n+        ~st_bind\n+        ~st_type: STT_OBJECT\n+        ~st_shndx: datandx\n+    in\n+      incr n_syms;\n+      (strtab_entry, symtab_entry)\n+  in\n+\n+  let rodata_sym name st_bind fixup =\n+    let name_fixup = new_fixup (\"rodata symbol name fixup: '\" ^ name ^ \"'\") in\n+    let strtab_entry = DEF (name_fixup, ZSTRING name) in\n+    let symtab_entry =\n+      symbol\n+        ~string_table_fixup: dynstr_section_fixup\n+        ~name_string_fixup: name_fixup\n+        ~sym_target_fixup: (Some fixup)\n+        ~st_bind\n+        ~st_type: STT_OBJECT\n+        ~st_shndx: rodatandx\n+    in\n+      incr n_syms;\n+      (strtab_entry, symtab_entry)\n+  in\n+\n+  let text_sym name st_bind fixup =\n+    let name_fixup = new_fixup (\"text symbol name fixup: '\" ^ name ^ \"'\") in\n+    let strtab_frag = DEF (name_fixup, ZSTRING name) in\n+    let symtab_frag =\n+      symbol\n+        ~string_table_fixup: dynstr_section_fixup\n+        ~name_string_fixup: name_fixup\n+        ~sym_target_fixup: (Some fixup)\n+        ~st_bind: st_bind\n+        ~st_type: STT_FUNC\n+        ~st_shndx: textndx\n+    in\n+      incr n_syms;\n+      (strtab_frag, symtab_frag)\n+  in\n+\n+  let require_sym name st_bind _(*fixup*) =\n+    let name_fixup =\n+      new_fixup (\"require symbol name fixup: '\" ^ name ^ \"'\")\n+    in\n+    let strtab_frag = DEF (name_fixup, ZSTRING name) in\n+    let symtab_frag =\n+      symbol\n+        ~string_table_fixup: dynstr_section_fixup\n+        ~name_string_fixup: name_fixup\n+        ~sym_target_fixup: None\n+        ~st_bind\n+        ~st_type: STT_FUNC\n+        ~st_shndx: shn_UNDEF\n+    in\n+      incr n_syms;\n+      (strtab_frag, symtab_frag)\n+  in\n+\n+  let frags_of_symbol sym_emitter st_bind symname_opt symbody x =\n+    let (strtab_frags, symtab_frags, body_frags) = x in\n+    let (strtab_frag, symtab_frag, body_frag) =\n+      match symname_opt with\n+          None -> (MARK, MARK, symbody)\n+        | Some symname ->\n+            let body_fixup =\n+              new_fixup (\"symbol body fixup: '\" ^ symname ^ \"'\")\n+            in\n+            let body =\n+              if symname = entry_name\n+              then DEF (e_entry_fixup, DEF (body_fixup, symbody))\n+              else DEF (body_fixup, symbody)\n+            in\n+            let (str, sym) = sym_emitter symname st_bind body_fixup in\n+              (str, sym, body)\n+    in\n+      ((strtab_frag :: strtab_frags),\n+       (symtab_frag :: symtab_frags),\n+       (body_frag :: body_frags))\n+  in\n+\n+  let frags_of_require_symbol sym_emitter st_bind symname plt_entry_fixup x =\n+    let (i, strtab_frags, symtab_frags,\n+         plt_frags, got_plt_frags, rela_plt_frags) = x in\n+    let (strtab_frag, symtab_frag) = sym_emitter symname st_bind None in\n+    let e = X86.new_emitter_without_vregs () in\n+    let jump_slot_fixup = new_fixup (\"jump slot #\" ^ string_of_int i) in\n+    let jump_slot_initial_target_fixup =\n+      new_fixup (\"jump slot #\" ^ string_of_int i ^ \" initial target\") in\n+\n+    (* You may notice this PLT entry doesn't look like either of the\n+     * types of \"normal\" PLT entries outlined in the ELF manual. It is,\n+     * however, just what you get when you combine a PIC PLT entry with\n+     * inline calls to the horrible __i686.get_pc_thunk.ax kludge used\n+     * on x86 to support entering PIC PLTs. We're just doing it *in*\n+     * the PLT entries rather than infecting all the callers with the\n+     * obligation of having the GOT address in a register on\n+     * PLT-entry.\n+     *)\n+\n+    let plt_frag =\n+      let (reg, _, _) = X86.get_next_pc_thunk in\n+\n+        Il.emit_full e (Some plt_entry_fixup) [] Il.Dead;\n+\n+        Abi.load_fixup_addr e reg got_plt_section_fixup Il.CodeTy;\n+\n+        Il.emit e (Il.jmp Il.JMP (got_code_cell reg (2+i)));\n+\n+        Il.emit_full e (Some jump_slot_initial_target_fixup)\n+          [] (Il.Push (X86.immi (Int64.of_int i)));\n+\n+        Il.emit e (Il.jmp Il.JMP (Il.direct_code_ptr plt0_fixup));\n+        X86.frags_of_emitted_quads sess e\n+    in\n+    let got_plt_frag =\n+      DEF (jump_slot_fixup,\n+           WORD (TY_u32, (M_POS jump_slot_initial_target_fixup)))\n+    in\n+    let rela_plt =\n+      { elf32_386_rela_type = R_386_JMP_SLOT;\n+        elf32_386_rela_offset = (M_POS jump_slot_fixup);\n+        elf32_386_rela_sym = (IMM (Int64.of_int i));\n+        elf32_386_rela_addend = (IMM 0L) }\n+    in\n+    let rela_plt_frag = elf32_386_rela_frag rela_plt in\n+      (i+1,\n+       (strtab_frag :: strtab_frags),\n+       (symtab_frag :: symtab_frags),\n+       (plt_frag :: plt_frags),\n+       (got_plt_frag :: got_plt_frags),\n+       (rela_plt_frag :: rela_plt_frags))\n+  in\n+\n+  (* Emit text export symbols. *)\n+  let (global_text_strtab_frags, global_text_symtab_frags) =\n+    match htab_search sem.Semant.ctxt_native_provided SEG_text with\n+        None -> ([], [])\n+      | Some etab ->\n+          Hashtbl.fold\n+            begin\n+              fun name fix x ->\n+                let (strtab_frags, symtab_frags) = x in\n+                let (str, sym) = text_sym name STB_GLOBAL fix in\n+                  (str :: strtab_frags,\n+                   sym :: symtab_frags)\n+            end\n+            etab\n+            ([],[])\n+  in\n+\n+  (* Emit text fragments (possibly named). *)\n+  let (global_text_strtab_frags,\n+       global_text_symtab_frags,\n+       text_body_frags) =\n+    Hashtbl.fold\n+      (frags_of_symbol text_sym STB_GLOBAL)\n+      text_frags\n+      (global_text_strtab_frags, global_text_symtab_frags, [])\n+  in\n+\n+  let (local_text_strtab_frags,\n+       local_text_symtab_frags) =\n+\n+    let symbol_frags_of_code _ code accum =\n+      let (strtab_frags, symtab_frags) = accum in\n+      let fix = code.Semant.code_fixup in\n+      let (strtab_frag, symtab_frag) =\n+        text_sym fix.fixup_name STB_LOCAL fix\n+      in\n+      (strtab_frag :: strtab_frags,\n+       symtab_frag :: symtab_frags)\n+    in\n+\n+    let symbol_frags_of_glue_code g code accum =\n+      let (strtab_frags, symtab_frags) = accum in\n+      let fix = code.Semant.code_fixup in\n+      let (strtab_frag, symtab_frag) =\n+        text_sym (Semant.glue_str sem g) STB_LOCAL fix\n+      in\n+      (strtab_frag :: strtab_frags,\n+       symtab_frag :: symtab_frags)\n+    in\n+\n+    let item_str_frags, item_sym_frags =\n+      Hashtbl.fold symbol_frags_of_code\n+        sem.Semant.ctxt_all_item_code ([], [])\n+    in\n+    let glue_str_frags, glue_sym_frags =\n+      Hashtbl.fold symbol_frags_of_glue_code\n+        sem.Semant.ctxt_glue_code ([], [])\n+    in\n+      (item_str_frags @ glue_str_frags,\n+       item_sym_frags @ glue_sym_frags)\n+  in\n+\n+  (* Emit rodata export symbols. *)\n+  let (rodata_strtab_frags, rodata_symtab_frags) =\n+    match htab_search sem.Semant.ctxt_native_provided SEG_data with\n+        None -> ([], [])\n+      | Some etab ->\n+          Hashtbl.fold\n+            begin\n+              fun name fix x ->\n+                let (strtab_frags, symtab_frags) = x in\n+                let (str, sym) = rodata_sym name STB_GLOBAL fix in\n+                  (str :: strtab_frags,\n+                   sym :: symtab_frags)\n+            end\n+            etab\n+            ([],[])\n+  in\n+\n+  (* Emit rodata fragments (possibly named). *)\n+  let (rodata_strtab_frags,\n+       rodata_symtab_frags,\n+       rodata_body_frags) =\n+    Hashtbl.fold\n+      (frags_of_symbol rodata_sym STB_GLOBAL)\n+      rodata_frags\n+      (rodata_strtab_frags, rodata_symtab_frags, [])\n+  in\n+\n+\n+  let (data_strtab_frags,\n+       data_symtab_frags,\n+       data_body_frags) =\n+    Hashtbl.fold (frags_of_symbol data_sym STB_GLOBAL) data_frags ([],[],[])\n+  in\n+\n+  let (_,\n+       require_strtab_frags,\n+       require_symtab_frags,\n+       plt_frags,\n+       got_plt_frags,\n+       rela_plt_frags) =\n+    Hashtbl.fold (frags_of_require_symbol require_sym STB_GLOBAL)\n+      required_fixups\n+      (1,[],[],[plt0_frag],[got_prefix],[])\n+  in\n+  let require_symtab_frags = List.rev require_symtab_frags in\n+  let plt_frags = List.rev plt_frags in\n+  let got_plt_frags = List.rev got_plt_frags in\n+  let rela_plt_frags = List.rev rela_plt_frags in\n+\n+  let dynamic_needed_strtab_frags =\n+    Array.make (Array.length needed_libs) MARK\n+  in\n+\n+  let dynamic_frags =\n+    let dynamic_needed_frags = Array.make (Array.length needed_libs) MARK in\n+      for i = 0 to (Array.length needed_libs) - 1 do\n+        let fixup =\n+          new_fixup (\"needed library name fixup: \" ^ needed_libs.(i))\n+        in\n+          dynamic_needed_frags.(i) <-\n+            elf32_dyn_frag (DT_NEEDED, SUB (M_POS fixup,\n+                                            M_POS dynstr_section_fixup));\n+          dynamic_needed_strtab_frags.(i) <-\n+            DEF (fixup, ZSTRING needed_libs.(i))\n+      done;\n+      (SEQ [|\n+         SEQ dynamic_needed_frags;\n+         elf32_dyn_frag (DT_STRTAB, M_POS dynstr_section_fixup);\n+         elf32_dyn_frag (DT_STRSZ, M_SZ dynstr_section_fixup);\n+\n+         elf32_dyn_frag (DT_SYMTAB, M_POS dynsym_section_fixup);\n+         elf32_dyn_frag (DT_SYMENT, IMM elf32_symsize);\n+\n+         elf32_dyn_frag (DT_HASH, M_POS hash_section_fixup);\n+         elf32_dyn_frag (DT_PLTGOT, M_POS got_plt_section_fixup);\n+\n+         elf32_dyn_frag (DT_PLTREL, IMM (elf32_num_of_dyn_tag DT_RELA));\n+         elf32_dyn_frag (DT_PLTRELSZ, M_SZ rela_plt_section_fixup);\n+         elf32_dyn_frag (DT_JMPREL, M_POS rela_plt_section_fixup);\n+\n+         elf32_dyn_frag (DT_NULL, IMM 0L)\n+       |])\n+  in\n+\n+  let null_strtab_fixup = new_fixup \"null dynstrtab entry\" in\n+  let null_strtab_frag = DEF (null_strtab_fixup, ZSTRING \"\") in\n+  let null_symtab_frag = (symbol\n+                            ~string_table_fixup: dynstr_section_fixup\n+                            ~name_string_fixup: null_strtab_fixup\n+                            ~sym_target_fixup: None\n+                            ~st_bind: STB_LOCAL\n+                            ~st_type: STT_NOTYPE\n+                            ~st_shndx: 0L) in\n+\n+  let dynsym_frags = (null_symtab_frag ::\n+                        (require_symtab_frags @\n+                           global_text_symtab_frags @\n+                           local_text_symtab_frags @\n+                           rodata_symtab_frags @\n+                           data_symtab_frags))\n+  in\n+\n+  let dynstr_frags = (null_strtab_frag ::\n+                        (require_strtab_frags @\n+                           global_text_strtab_frags @\n+                           local_text_strtab_frags @\n+                           rodata_strtab_frags @\n+                           data_strtab_frags @\n+                           (Array.to_list dynamic_needed_strtab_frags)))\n+  in\n+\n+  let interp_section =\n+    DEF (interp_section_fixup, ZSTRING \"/lib/ld-linux.so.2\")\n+  in\n+\n+  let text_section =\n+    DEF (text_section_fixup,\n+         SEQ (Array.of_list text_body_frags))\n+  in\n+  let rodata_section =\n+    DEF (rodata_section_fixup,\n+         SEQ (Array.of_list rodata_body_frags))\n+  in\n+  let data_section =\n+    DEF (data_section_fixup,\n+         SEQ (Array.of_list data_body_frags))\n+  in\n+  let bss_section =\n+    DEF (bss_section_fixup,\n+         SEQ [| |])\n+  in\n+  let dynsym_section =\n+    DEF (dynsym_section_fixup,\n+         SEQ (Array.of_list dynsym_frags))\n+  in\n+  let dynstr_section =\n+    DEF (dynstr_section_fixup,\n+         SEQ (Array.of_list dynstr_frags))\n+  in\n+\n+  let hash_section =\n+    let n_syms = !n_syms in\n+\n+    DEF (hash_section_fixup,\n+         (* Worst hashtable ever: one chain. *)\n+         SEQ [|\n+           WORD (TY_u32, IMM 1L);          (* nbucket *)\n+           WORD (TY_u32,                   (* nchain *)\n+                 IMM (Int64.of_int n_syms));\n+           WORD (TY_u32, IMM 1L);          (* bucket 0 => symbol 1. *)\n+           SEQ\n+             begin\n+               Array.init\n+                 n_syms\n+                 (fun i ->\n+                    let next = (* chain[i] => if last then 0 else i+1 *)\n+                      if i > 0 && i < (n_syms-1)\n+                      then Int64.of_int (i+1)\n+                      else 0L\n+                    in\n+                      WORD (TY_u32, IMM next))\n+             end;\n+         |])\n+  in\n+\n+  let plt_section =\n+    DEF (plt_section_fixup,\n+         SEQ (Array.of_list plt_frags))\n+  in\n+\n+  let got_plt_section =\n+    DEF (got_plt_section_fixup,\n+         SEQ (Array.of_list got_plt_frags))\n+  in\n+\n+  let rela_plt_section =\n+    DEF (rela_plt_section_fixup,\n+         SEQ (Array.of_list rela_plt_frags))\n+  in\n+\n+  let dynamic_section =\n+    DEF (dynamic_section_fixup, dynamic_frags)\n+  in\n+\n+  let note_rust_section =\n+    DEF (note_rust_section_fixup,\n+         (Asm.note_rust_frags crate.node.Ast.crate_meta))\n+  in\n+\n+\n+  let page_alignment = 0x1000 in\n+\n+  let align_both i =\n+    ALIGN_FILE (page_alignment,\n+                (ALIGN_MEM (page_alignment, i)))\n+  in\n+\n+  let def_aligned f i =\n+    align_both\n+      (SEQ [| DEF(f,i);\n+              (align_both MARK)|])\n+  in\n+\n+  let debug_aranges_section =\n+    def_aligned\n+      sem.Semant.ctxt_debug_aranges_fixup\n+      dwarf.Dwarf.debug_aranges\n+  in\n+  let debug_pubnames_section =\n+    def_aligned\n+      sem.Semant.ctxt_debug_pubnames_fixup\n+      dwarf.Dwarf.debug_pubnames\n+  in\n+  let debug_info_section =\n+    def_aligned\n+      sem.Semant.ctxt_debug_info_fixup\n+      dwarf.Dwarf.debug_info\n+  in\n+  let debug_abbrev_section =\n+    def_aligned\n+      sem.Semant.ctxt_debug_abbrev_fixup\n+      dwarf.Dwarf.debug_abbrev\n+  in\n+  let debug_line_section =\n+    def_aligned\n+      sem.Semant.ctxt_debug_line_fixup\n+      dwarf.Dwarf.debug_line\n+  in\n+  let debug_frame_section =\n+    def_aligned sem.Semant.ctxt_debug_frame_fixup dwarf.Dwarf.debug_frame\n+  in\n+\n+  let load_address = 0x0804_8000L in\n+\n+    SEQ\n+      [|\n+        MEMPOS load_address;\n+        ALIGN_FILE\n+          (segment_2_align,\n+           DEF\n+             (segment_2_fixup,\n+              SEQ\n+                [|\n+                  DEF (sem.Semant.ctxt_image_base_fixup, MARK);\n+                  elf_header;\n+                  ALIGN_FILE\n+                    (segment_0_align,\n+                     DEF\n+                       (segment_0_fixup,\n+                        SEQ\n+                          [|\n+                            DEF (program_header_table_fixup,\n+                                 program_header_table);\n+                          |]));\n+                  ALIGN_FILE\n+                    (segment_1_align,\n+                     DEF (segment_1_fixup, interp_section));\n+                  text_section;\n+                  rodata_section;\n+                  dynsym_section;\n+                  dynstr_section;\n+                  hash_section;\n+                  plt_section;\n+                  rela_plt_section;\n+                  debug_aranges_section;\n+                  debug_pubnames_section;\n+                  debug_info_section;\n+                  debug_abbrev_section;\n+                  debug_line_section;\n+                  debug_frame_section;\n+                |]));\n+        ALIGN_FILE\n+          (segment_3_align,\n+           DEF\n+             (segment_3_fixup,\n+              SEQ\n+                [|\n+                  data_section;\n+                  got_plt_section;\n+                  bss_section;\n+                  ALIGN_FILE\n+                    (segment_4_align,\n+                     DEF (segment_4_fixup,\n+                          dynamic_section));\n+                  ALIGN_FILE\n+                    (segment_5_align,\n+                     DEF (segment_5_fixup,\n+                          note_rust_section));\n+                |]));\n+        DEF (shstrtab_section_fixup,\n+             shstrtab_section);\n+        DEF (section_header_table_fixup,\n+             section_header_table);\n+      |]\n+;;\n+\n+let emit_file\n+    (sess:Session.sess)\n+    (crate:Ast.crate)\n+    (code:Asm.frag)\n+    (data:Asm.frag)\n+    (sem:Semant.ctxt)\n+    (dwarf:Dwarf.debug_records)\n+    : unit =\n+\n+  let text_frags = Hashtbl.create 4 in\n+  let rodata_frags = Hashtbl.create 4 in\n+  let data_frags = Hashtbl.create 4 in\n+  let required_fixups = Hashtbl.create 4 in\n+\n+  (*\n+   * Startup on elf-linux is more complex than in win32. It's\n+   * thankfully documented in some detail around the net.\n+   *\n+   *   - The elf entry address is for _start.\n+   *\n+   *   - _start pushes:\n+   *\n+   *       eax   (should be zero)\n+   *       esp   (holding the kernel-provided stack end)\n+   *       edx   (address of _rtld_fini)\n+   *       address of _fini\n+   *       address of _init\n+   *       ecx   (argv)\n+   *       esi   (argc)\n+   *       address of main\n+   *\n+   *     and then calls __libc_start_main@plt.\n+   *\n+   *   - This means any sensible binary has a PLT. Fun. So\n+   *     We call into the PLT, which itself is just a bunch\n+   *     of indirect jumps through slots in the GOT, and wind\n+   *     up in __libc_start_main. Which calls _init, then\n+   *     essentially exit(main(argc,argv)).\n+   *)\n+\n+\n+  let init_fixup = new_fixup \"_init function entry\" in\n+  let fini_fixup = new_fixup \"_fini function entry\" in\n+  let (start_fixup, rust_start_fixup) =\n+    if sess.Session.sess_library_mode\n+    then (None, None)\n+    else (Some (new_fixup \"start function entry\"),\n+          Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n+  in\n+  let libc_start_main_fixup = new_fixup \"__libc_start_main@plt stub\" in\n+\n+  let start_fn _ =\n+    let start_fixup =\n+      match start_fixup with\n+          None -> bug () \"missing start fixup in non-library mode\"\n+        | Some s -> s\n+    in\n+    let e = X86.new_emitter_without_vregs () in\n+    let push_r32 r = Il.emit e\n+      (Il.Push (Il.Cell (Il.Reg (Il.Hreg r, Il.ValTy Il.Bits32))))\n+    in\n+    let push_pos32 = X86.push_pos32 e in\n+\n+      Il.emit e (Il.unary Il.UMOV (X86.rc X86.ebp) (X86.immi 0L));\n+      Il.emit e (Il.Pop (X86.rc X86.esi));\n+      Il.emit e (Il.unary Il.UMOV (X86.rc X86.ecx) (X86.ro X86.esp));\n+      Il.emit e (Il.binary Il.AND\n+                   (X86.rc X86.esp) (X86.ro X86.esp)\n+                   (X86.immi 0xfffffffffffffff0L));\n+\n+      push_r32 X86.eax;\n+      push_r32 X86.esp;\n+      push_r32 X86.edx;\n+      push_pos32 fini_fixup;\n+      push_pos32 init_fixup;\n+      push_r32 X86.ecx;\n+      push_r32 X86.esi;\n+      push_pos32 start_fixup;\n+      Il.emit e (Il.call\n+                   (Il.Reg (Il.Hreg X86.eax, Il.ValTy Il.Bits32))\n+                   (Il.direct_code_ptr libc_start_main_fixup));\n+      X86.frags_of_emitted_quads sess e\n+  in\n+\n+  let do_nothing_fn _ =\n+    let e = X86.new_emitter_without_vregs () in\n+      Il.emit e Il.Ret;\n+      X86.frags_of_emitted_quads sess e\n+  in\n+\n+  let main_fn _ =\n+    match (start_fixup, rust_start_fixup, sem.Semant.ctxt_main_fn_fixup) with\n+        (None, _, _)\n+      | (_, None, _)\n+      | (_, _, None) -> MARK\n+      | (Some start_fixup,\n+         Some rust_start_fixup,\n+         Some main_fn_fixup) ->\n+          let e = X86.new_emitter_without_vregs () in\n+            X86.objfile_start e\n+              ~start_fixup\n+              ~rust_start_fixup\n+              ~main_fn_fixup\n+              ~crate_fixup: sem.Semant.ctxt_crate_fixup\n+              ~indirect_start: false;\n+            X86.frags_of_emitted_quads sess e\n+  in\n+\n+  let needed_libs =\n+    [|\n+      \"libc.so.6\";\n+      \"librustrt.so\"\n+    |]\n+  in\n+\n+  let _ =\n+    if not sess.Session.sess_library_mode\n+    then\n+      begin\n+        htab_put text_frags (Some \"_start\") (start_fn());\n+        htab_put text_frags (Some \"_init\")\n+          (DEF (init_fixup, do_nothing_fn()));\n+        htab_put text_frags (Some \"_fini\")\n+          (DEF (fini_fixup, do_nothing_fn()));\n+        htab_put text_frags (Some \"main\") (main_fn ());\n+        htab_put required_fixups \"__libc_start_main\" libc_start_main_fixup;\n+      end;\n+    htab_put text_frags None code;\n+    htab_put rodata_frags None data;\n+\n+    Hashtbl.iter\n+      begin\n+        fun _ tab ->\n+          Hashtbl.iter\n+            begin\n+              fun name fixup ->\n+                htab_put required_fixups name fixup\n+            end\n+            tab\n+      end\n+      sem.Semant.ctxt_native_required\n+  in\n+  let all_frags =\n+    elf32_linux_x86_file\n+      ~sess\n+      ~crate\n+      ~entry_name: \"_start\"\n+      ~text_frags\n+      ~data_frags\n+      ~dwarf\n+      ~sem\n+      ~rodata_frags\n+      ~required_fixups\n+      ~needed_libs\n+  in\n+    write_out_frag sess true all_frags\n+;;\n+\n+let elf_magic = \"\\x7fELF\";;\n+\n+let sniff\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : asm_reader option =\n+  try\n+    let stat = Unix.stat filename in\n+    if (stat.Unix.st_kind = Unix.S_REG) &&\n+      (stat.Unix.st_size > 4)\n+    then\n+      let ar = new_asm_reader sess filename in\n+      let _ = log sess \"sniffing ELF file\" in\n+        if (ar.asm_get_zstr_padded 4) = elf_magic\n+        then (ar.asm_seek 0; Some ar)\n+        else None\n+    else\n+      None\n+  with\n+      _ -> None\n+;;\n+\n+let get_sections\n+    (sess:Session.sess)\n+    (ar:asm_reader)\n+    : (string,(int*int)) Hashtbl.t =\n+  let sects = Hashtbl.create 0 in\n+  let _ = log sess \"reading sections\" in\n+  let elf_id = ar.asm_get_zstr_padded 4 in\n+  let _ = assert (elf_id = elf_magic) in\n+\n+  let _ = ar.asm_seek 0x10 in\n+  let _ = ar.asm_adv_u16 () in (* e_type *)\n+  let _ = ar.asm_adv_u16 () in (* e_machine *)\n+  let _ = ar.asm_adv_u32 () in (* e_version *)\n+  let _ = ar.asm_adv_u32 () in (* e_entry *)\n+  let _ = ar.asm_adv_u32 () in (* e_phoff *)\n+  let e_shoff = ar.asm_get_u32 () in (* e_shoff *)\n+  let _ = ar.asm_adv_u32 () in (* e_flags *)\n+  let _ = ar.asm_adv_u16 () in (* e_ehsize *)\n+  let _ = ar.asm_adv_u16 () in (* e_phentsize *)\n+  let _ = ar.asm_adv_u16 () in (* e_phnum *)\n+  let e_shentsize = ar.asm_get_u16 () in\n+  let e_shnum = ar.asm_get_u16 () in\n+  let e_shstrndx = ar.asm_get_u16 () in\n+  let _ = log sess\n+    \"%d ELF section headers, %d bytes each, starting at 0x%x\"\n+    e_shnum e_shentsize e_shoff\n+  in\n+  let _ = log sess \"section %d is .shstrtab\" e_shstrndx in\n+\n+  let read_section_hdr n =\n+    let _ = ar.asm_seek (e_shoff + n * e_shentsize) in\n+    let str_off = ar.asm_get_u32() in\n+    let _ = ar.asm_adv_u32() in (* sh_type  *)\n+    let _ = ar.asm_adv_u32() in (* sh_flags *)\n+    let _ = ar.asm_adv_u32() in (* sh_addr *)\n+    let off = ar.asm_get_u32() in (* sh_off *)\n+    let size = ar.asm_get_u32() in (* sh_size *)\n+    let _ = ar.asm_adv_u32() in (* sh_link *)\n+    let _ = ar.asm_adv_u32() in (* sh_info *)\n+    let _ = ar.asm_adv_u32() in (* sh_addralign *)\n+    let _ = ar.asm_adv_u32() in (* sh_entsize *)\n+      (str_off, off, size)\n+  in\n+\n+  let (_, str_base, _) = read_section_hdr e_shstrndx in\n+\n+  let _ = ar.asm_seek e_shoff in\n+    for i = 0 to (e_shnum - 1) do\n+      let (str_off, off, size) = read_section_hdr i in\n+      let _ = ar.asm_seek (str_base + str_off) in\n+      let name = ar.asm_get_zstr() in\n+        log sess \"section %d: %s, size %d, offset 0x%x\" i name size off;\n+        Hashtbl.add sects name (off, size);\n+    done;\n+    sects\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "e095e627b715d8628ef8688e1129f0989b3b1c73", "filename": "src/boot/be/il.ml", "status": "added", "additions": 1135, "deletions": 0, "changes": 1135, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fil.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1135 @@\n+open Common;;\n+\n+(* FIXME (issue #1): thread a session object through this eventually. *)\n+let log_iltypes = ref false;;\n+\n+(* IL type system, very rudimentary. *)\n+\n+type bits =\n+    Bits8\n+  | Bits16\n+  | Bits32\n+  | Bits64\n+;;\n+\n+type scalar_ty =\n+    ValTy of bits\n+  | AddrTy of referent_ty\n+\n+and referent_ty =\n+    ScalarTy of scalar_ty\n+  | StructTy of referent_ty array\n+  | UnionTy of referent_ty array\n+  | ParamTy of ty_param_idx (* Thing of current-frame type-param #n *)\n+  | OpaqueTy                (* Unknown memory-resident thing. *)\n+  | CodeTy                  (* Executable machine code. *)\n+  | NilTy                   (* 0 bits of space. *)\n+;;\n+\n+let (voidptr_t:scalar_ty) = AddrTy OpaqueTy;;\n+let (codeptr_t:scalar_ty) = AddrTy CodeTy;;\n+\n+(* Operands. *)\n+\n+type vreg = int ;;\n+type hreg = int ;;\n+type label = int ;;\n+type spill = int ;;\n+\n+type reg =\n+    Vreg of vreg\n+  | Hreg of hreg\n+;;\n+\n+type mem =\n+    Abs of Asm.expr64\n+  | RegIn of (reg * (Asm.expr64 option))\n+  | Spill of spill\n+;;\n+\n+type typed_reg = (reg * scalar_ty);;\n+type typed_mem = (mem * referent_ty);;\n+type typed_imm = (Asm.expr64 * ty_mach);;\n+type typed_imm_ptr = (fixup * referent_ty);;\n+\n+type cell =\n+    Reg of typed_reg\n+  | Mem of typed_mem\n+;;\n+\n+(* \n+ * ImmPtr (a, rty) can be assigned to anything of scalar_ty \n+ * AddrTy rty; the difference is that ImmAddr carries its value\n+ * so can be used in cases where we want to have an immediate\n+ * address constant-propagated through the code to the backend.\n+ *)\n+type operand =\n+    Cell of cell\n+  | Imm of typed_imm\n+  | ImmPtr of typed_imm_ptr\n+;;\n+\n+\n+type code =\n+    CodeLabel of label (* Index into current quad block. *)\n+  | CodePtr of operand\n+  | CodeNone\n+;;\n+\n+(* NB: for the most part, we let the register allocator assign spills\n+ * from vregs, and we permanently allocate aliased slots to stack\n+ * locations by static aliasing information early, in layout.\n+ * \n+ * The one awkward case this doesn't handle is when someone tries to\n+ * pass a literal-atom to an alias-slot. This *requires* a memory slot\n+ * but we only realize it rather late, much later than we'd normally\n+ * have thougt to desugar the literal into a temporary.\n+ * \n+ * So in these cases, we let the trans module explicitly demand a\n+ * \"Spill n\" operand, which the register allocator mops up before it\n+ * gets started on the vregs.\n+ * \n+ * NOTE: if we were more clever we'd integrate vregs and spills like\n+ * this together along with the general notion of a temporary way back\n+ * at the desugaring stage, and use some kind of size-class\n+ * consolidation so that spills with non-overlapping lifetimes could\n+ * share memory. But we're not that clever yet.\n+ *)\n+\n+\n+(* Helpers. *)\n+\n+let direct_code_ptr fix =\n+  (CodePtr (ImmPtr (fix, CodeTy)))\n+;;\n+\n+let cell_referent_ty c =\n+  match c with\n+      Reg (_, st) -> ScalarTy st\n+    | Mem (_, rt) -> rt\n+;;\n+\n+let cell_is_nil c =\n+  match c with\n+      Mem (_, NilTy) -> true\n+    | Reg (_, AddrTy NilTy) -> true\n+    | _ -> false\n+;;\n+\n+let operand_is_nil o =\n+  match o with\n+      Cell c -> cell_is_nil c\n+    | _ -> false\n+;;\n+\n+let mem_off (mem:mem) (off:Asm.expr64) : mem =\n+  let addto e = Asm.ADD (off, e) in\n+    match mem with\n+        Abs e -> Abs (addto e)\n+      | RegIn (r, None) -> RegIn (r, Some off)\n+      | RegIn (r, Some e) -> RegIn (r, Some (addto e))\n+      | Spill _ -> bug () \"Adding offset to spill slot\"\n+;;\n+\n+let mem_off_imm (mem:mem) (imm:int64) : mem =\n+  mem_off mem (Asm.IMM imm)\n+;;\n+\n+\n+(* Quads. *)\n+\n+type binop =\n+    ADD | SUB\n+  | IMUL | UMUL\n+  | IDIV | UDIV\n+  | IMOD | UMOD\n+  | AND | OR | XOR\n+  | LSL | LSR | ASR\n+;;\n+\n+type unop =\n+    NEG | NOT\n+  | UMOV | IMOV\n+  | ZERO\n+;;\n+\n+type jmpop =\n+    JE | JNE\n+  | JZ | JNZ (* FIXME: Synonyms with JE/JNE in x86, others? *)\n+  | JL | JLE | JG | JGE (* Signed.   *)\n+  | JB | JBE | JA | JAE (* Unsigned. *)\n+  | JC | JNC | JO | JNO\n+  | JMP\n+;;\n+\n+type binary =\n+    {\n+      binary_op: binop;\n+      binary_dst: cell;\n+      binary_lhs: operand;\n+      binary_rhs: operand\n+    }\n+;;\n+\n+type unary =\n+    {\n+      unary_op: unop;\n+      unary_dst: cell;\n+      unary_src: operand\n+    }\n+;;\n+\n+type cmp =\n+    {\n+      cmp_lhs: operand;\n+      cmp_rhs: operand\n+    }\n+;;\n+\n+type lea =\n+    {\n+      lea_dst: cell;\n+      lea_src: operand\n+    }\n+;;\n+\n+type jmp =\n+    {\n+      jmp_op: jmpop;\n+      jmp_targ: code;\n+    }\n+;;\n+\n+type call =\n+    {\n+      call_dst: cell;\n+      call_targ: code\n+    }\n+\n+type quad' =\n+    Binary of binary\n+  | Unary of unary\n+  | Lea of lea\n+  | Cmp of cmp\n+  | Jmp of jmp\n+  | Push of operand\n+  | Pop of cell\n+  | Call of call\n+  | Debug          (* Debug-break pseudo-instruction. *)\n+  | Enter of fixup (* Enter-fixup-block pseudo-instruction. *)\n+  | Leave          (* Leave-fixup-block pseudo-instruction. *)\n+  | Ret            (* Return to caller. *)\n+  | Nop            (* Keep this quad here, emit CPU nop. *)\n+  | Dead           (* Keep this quad but emit nothing. *)\n+  | Regfence       (* Clobber all hregs. *)\n+  | End            (* Space past the end of quads to emit. *)\n+;;\n+\n+type quad =\n+    { quad_fixup: fixup option;\n+      quad_implicits: label list;\n+      quad_body: quad'; }\n+\n+type quads = quad array ;;\n+\n+(* Query functions. *)\n+\n+let cell_is_scalar (c:cell) : bool =\n+  match c with\n+      Reg (_, _) -> true\n+    | Mem (_, ScalarTy _) -> true\n+    | _ -> false\n+;;\n+\n+\n+let bits_of_ty_mach (tm:ty_mach) : bits =\n+  match tm with\n+    | TY_u8 -> Bits8\n+    | TY_i8 -> Bits8\n+    | TY_u16 -> Bits16\n+    | TY_i16 -> Bits16\n+    | TY_u32 -> Bits32\n+    | TY_i32 -> Bits32\n+    | TY_u64 -> Bits64\n+    | TY_i64 -> Bits64\n+    | TY_f32 -> Bits32\n+    | TY_f64 -> Bits64\n+;;\n+\n+let cell_scalar_ty (c:cell) : scalar_ty =\n+  match c with\n+      Reg (_, st) -> st\n+    | Mem (_, ScalarTy st) -> st\n+    | _ -> bug () \"mem of non-scalar in Il.cell_scalar_ty\"\n+;;\n+\n+let operand_scalar_ty (op:operand) : scalar_ty =\n+  match op with\n+      Cell c -> cell_scalar_ty c\n+    | Imm (_, t) -> ValTy (bits_of_ty_mach t)\n+    | ImmPtr (_, t) -> AddrTy t\n+;;\n+\n+\n+let scalar_ty_bits (word_bits:bits) (st:scalar_ty) : bits =\n+  match st with\n+      ValTy bits -> bits\n+    | AddrTy _ -> word_bits\n+;;\n+\n+let cell_bits (word_bits:bits) (c:cell) : bits =\n+  match c with\n+      Reg (_, st) -> scalar_ty_bits word_bits st\n+    | Mem (_, ScalarTy st) -> scalar_ty_bits word_bits st\n+    | Mem _ -> bug () \"mem of non-scalar in Il.cell_bits\"\n+;;\n+\n+let operand_bits (word_bits:bits) (op:operand) : bits =\n+  match op with\n+      Cell cell -> cell_bits word_bits cell\n+    | Imm (_, tm) -> bits_of_ty_mach tm\n+    | ImmPtr _ -> word_bits\n+;;\n+\n+let bits_size (bits:bits) : int64 =\n+  match bits with\n+      Bits8 -> 1L\n+    | Bits16 -> 2L\n+    | Bits32 -> 4L\n+    | Bits64 -> 8L\n+;;\n+\n+let bits_align (bits:bits) : int64 =\n+  match bits with\n+      Bits8 -> 1L\n+    | Bits16 -> 2L\n+    | Bits32 -> 4L\n+    | Bits64 -> 8L\n+;;\n+\n+let scalar_ty_size (word_bits:bits) (st:scalar_ty) : int64 =\n+  bits_size (scalar_ty_bits word_bits st)\n+;;\n+\n+let scalar_ty_align (word_bits:bits) (st:scalar_ty) : int64 =\n+  bits_align (scalar_ty_bits word_bits st)\n+;;\n+\n+let rec referent_ty_layout (word_bits:bits) (rt:referent_ty) : (size * size) =\n+  match rt with\n+      ScalarTy st -> (SIZE_fixed (scalar_ty_size word_bits st),\n+                      SIZE_fixed (scalar_ty_align word_bits st))\n+    | StructTy rts ->\n+        begin\n+          let accum (off,align) rt : (size * size) =\n+            let (elt_size, elt_align) = referent_ty_layout word_bits rt in\n+            let elt_off = align_sz elt_align off in\n+              (add_sz elt_off elt_size, max_sz elt_align align)\n+          in\n+            Array.fold_left accum (SIZE_fixed 0L, SIZE_fixed 1L) rts\n+        end\n+   | UnionTy rts ->\n+        begin\n+          let accum (sz,align) rt : (size * size) =\n+            let (elt_size, elt_align) = referent_ty_layout word_bits rt in\n+              (max_sz sz elt_size, max_sz elt_align align)\n+          in\n+            Array.fold_left accum (SIZE_fixed 0L, SIZE_fixed 1L) rts\n+        end\n+   | OpaqueTy -> bug () \"opaque ty in referent_ty_layout\"\n+   | CodeTy -> bug () \"code ty in referent_ty_layout\"\n+   | ParamTy i -> (SIZE_param_size i, SIZE_param_align i)\n+   | NilTy -> (SIZE_fixed 0L, SIZE_fixed 1L)\n+\n+and referent_ty_size (word_bits:bits) (rt:referent_ty) : size =\n+  (fst (referent_ty_layout word_bits rt))\n+\n+and referent_ty_align (word_bits:bits) (rt:referent_ty) : size =\n+  (snd (referent_ty_layout word_bits rt))\n+\n+;;\n+\n+let get_element_offset\n+    (word_bits:bits)\n+    (elts:referent_ty array)\n+    (i:int)\n+    : size =\n+  let elts_before = Array.sub elts 0 i in\n+  let elt_rty = elts.(i) in\n+  let elts_before_size = referent_ty_size word_bits (StructTy elts_before) in\n+  let elt_align = referent_ty_align word_bits elt_rty in\n+  let elt_off = align_sz elt_align elts_before_size in\n+    elt_off\n+;;\n+\n+(* Processor. *)\n+\n+type quad_processor =\n+    { qp_reg:  (quad_processor -> reg -> reg);\n+      qp_mem:  (quad_processor -> mem -> mem);\n+      qp_cell_read: (quad_processor -> cell -> cell);\n+      qp_cell_write: (quad_processor -> cell -> cell);\n+      qp_code: (quad_processor -> code -> code);\n+      qp_op: (quad_processor -> operand -> operand); }\n+;;\n+\n+let identity_processor =\n+  let qp_cell = (fun qp c -> match c with\n+                     Reg (r, b) -> Reg (qp.qp_reg qp r, b)\n+                   | Mem (a, b) -> Mem (qp.qp_mem qp a, b))\n+  in\n+    { qp_reg = (fun _ r -> r);\n+      qp_mem = (fun qp a -> match a with\n+                     RegIn (r, o) -> RegIn (qp.qp_reg qp r, o)\n+                   | Abs _\n+                   | Spill _ -> a);\n+      qp_cell_read = qp_cell;\n+      qp_cell_write = qp_cell;\n+      qp_code = (fun qp c -> match c with\n+                     CodePtr op -> CodePtr (qp.qp_op qp op)\n+                   | CodeLabel _\n+                   | CodeNone -> c);\n+      qp_op = (fun qp op -> match op with\n+                   Cell c -> Cell (qp.qp_cell_read qp c)\n+                 | ImmPtr _ -> op\n+                 | Imm _ -> op) }\n+;;\n+\n+let process_quad (qp:quad_processor) (q:quad) : quad =\n+  { q with\n+      quad_body = match q.quad_body with\n+          Binary b ->\n+            Binary { b with\n+                       binary_dst = qp.qp_cell_write qp b.binary_dst;\n+                       binary_lhs = qp.qp_op qp b.binary_lhs;\n+                       binary_rhs = qp.qp_op qp b.binary_rhs }\n+        | Unary u ->\n+            Unary { u with\n+                      unary_dst = qp.qp_cell_write qp u.unary_dst;\n+                      unary_src = qp.qp_op qp u.unary_src }\n+\n+        | Lea le ->\n+            Lea { lea_dst = qp.qp_cell_write qp le.lea_dst;\n+                  lea_src = qp.qp_op qp le.lea_src }\n+\n+        | Cmp c ->\n+            Cmp { cmp_lhs = qp.qp_op qp c.cmp_lhs;\n+                  cmp_rhs = qp.qp_op qp c.cmp_rhs }\n+\n+        | Jmp j ->\n+            Jmp { j with\n+                    jmp_targ = qp.qp_code qp j.jmp_targ }\n+\n+        | Push op ->\n+            Push (qp.qp_op qp op)\n+\n+        | Pop c ->\n+            Pop (qp.qp_cell_write qp c)\n+\n+        | Call c ->\n+            Call { call_dst = qp.qp_cell_write qp c.call_dst;\n+                   call_targ = qp.qp_code qp c.call_targ }\n+\n+        | Ret -> Ret\n+        | Nop -> Nop\n+        | Debug -> Debug\n+        | Regfence -> Regfence\n+        | Enter f -> Enter f\n+        | Leave -> Leave\n+        | Dead -> Dead\n+        | End -> End }\n+;;\n+\n+let visit_quads (qp:quad_processor) (qs:quads) : unit =\n+  Array.iter (fun x ->ignore ( process_quad qp x); ()) qs\n+;;\n+\n+let process_quads (qp:quad_processor) (qs:quads) : quads =\n+  Array.map (process_quad qp) qs\n+;;\n+\n+let rewrite_quads (qp:quad_processor) (qs:quads) : unit =\n+  for i = 0 to ((Array.length qs) - 1) do\n+    qs.(i) <- process_quad qp qs.(i)\n+  done\n+;;\n+\n+\n+(* A little partial-evaluator to help lowering sizes. *)\n+\n+let rec size_to_expr64 (a:size) : Asm.expr64 option =\n+  let binary a b f =\n+    match (size_to_expr64 a, size_to_expr64 b) with\n+        (Some a, Some b) -> Some (f a b)\n+      | _ -> None\n+  in\n+    match a with\n+        SIZE_fixed i -> Some (Asm.IMM i)\n+      | SIZE_fixup_mem_sz f -> Some (Asm.M_SZ f)\n+      | SIZE_fixup_mem_pos f -> Some (Asm.M_POS f)\n+      | SIZE_rt_neg s ->\n+          begin\n+            match (size_to_expr64 s) with\n+                None -> None\n+              | Some s -> Some (Asm.NEG s)\n+          end\n+      | SIZE_rt_add (a, b) -> binary a b (fun a b -> Asm.ADD (a,b))\n+      | SIZE_rt_mul (a, b) -> binary a b (fun a b -> Asm.MUL (a,b))\n+      | SIZE_rt_max (a, b) -> binary a b (fun a b -> Asm.MAX (a,b))\n+      | SIZE_rt_align (a, b) -> binary a b (fun a b -> Asm.ALIGN (a,b))\n+      | _ -> None\n+;;\n+\n+\n+(* Formatters. *)\n+\n+let string_of_bits (b:bits) : string =\n+  match b with\n+      Bits8 -> \"b8\"\n+    | Bits16 -> \"b16\"\n+    | Bits32 -> \"b32\"\n+    | Bits64 -> \"b64\"\n+;;\n+\n+let rec string_of_scalar_ty (s:scalar_ty) : string =\n+  match s with\n+      ValTy b -> (string_of_bits b)\n+    | AddrTy r -> (string_of_referent_ty r) ^ \"*\"\n+\n+and string_of_referent_ty (r:referent_ty) : string =\n+  match r with\n+      ScalarTy s ->  (string_of_scalar_ty s)\n+    | StructTy rs ->\n+        Printf.sprintf \"[%s]\"\n+          (String.concat \",\"\n+             (Array.to_list (Array.map string_of_referent_ty rs)))\n+    | UnionTy rs ->\n+        Printf.sprintf \"(%s)\"\n+          (String.concat \"|\"\n+             (Array.to_list (Array.map string_of_referent_ty rs)))\n+    | ParamTy i -> Printf.sprintf \"#%d\" i\n+    | OpaqueTy -> \"?\"\n+    | CodeTy -> \"!\"\n+    | NilTy -> \"()\"\n+;;\n+\n+\n+type hreg_formatter = hreg -> string;;\n+\n+let string_of_reg (f:hreg_formatter) (r:reg) : string =\n+  match r with\n+      Vreg i -> Printf.sprintf \"<v%d>\" i\n+    | Hreg i -> f i\n+;;\n+\n+let rec string_of_expr64 (e64:Asm.expr64) : string =\n+  let bin op a b =\n+    Printf.sprintf \"(%s %s %s)\" (string_of_expr64 a) op (string_of_expr64 b)\n+  in\n+  let bini op a b =\n+    Printf.sprintf \"(%s %s %d)\" (string_of_expr64 a) op b\n+  in\n+    match e64 with\n+        Asm.IMM i when (i64_lt i 0L) -> Printf.sprintf \"-0x%Lx\" (Int64.neg i)\n+      | Asm.IMM i -> Printf.sprintf \"0x%Lx\" i\n+      | Asm.ADD (a,b) -> bin \"+\" a b\n+      | Asm.SUB (a,b) -> bin \"-\" a b\n+      | Asm.MUL (a,b) -> bin \"*\" a b\n+      | Asm.DIV (a,b) -> bin \"/\" a b\n+      | Asm.REM (a,b) -> bin \"%\" a b\n+      | Asm.MAX (a,b) ->\n+          Printf.sprintf \"(max %s %s)\"\n+            (string_of_expr64 a) (string_of_expr64 b)\n+      | Asm.ALIGN (a,b) ->\n+          Printf.sprintf \"(align %s %s)\"\n+            (string_of_expr64 a) (string_of_expr64 b)\n+      | Asm.SLL (a,b) -> bini \"<<\" a b\n+      | Asm.SLR (a,b) -> bini \">>\" a b\n+      | Asm.SAR (a,b) -> bini \">>>\" a b\n+      | Asm.AND (a,b) -> bin \"&\" a b\n+      | Asm.XOR (a,b) -> bin \"xor\" a b\n+      | Asm.OR (a,b) -> bin \"|\" a b\n+      | Asm.NOT a -> Printf.sprintf \"(not %s)\" (string_of_expr64 a)\n+      | Asm.NEG a -> Printf.sprintf \"-%s\" (string_of_expr64 a)\n+      | Asm.F_POS f -> Printf.sprintf \"<%s>.fpos\" f.fixup_name\n+      | Asm.F_SZ f -> Printf.sprintf \"<%s>.fsz\" f.fixup_name\n+      | Asm.M_POS f -> Printf.sprintf \"<%s>.mpos\" f.fixup_name\n+      | Asm.M_SZ f -> Printf.sprintf \"<%s>.msz\" f.fixup_name\n+      | Asm.EXT _ -> \"??ext??\"\n+;;\n+\n+let string_of_off (e:Asm.expr64 option) : string =\n+  match e with\n+      None -> \"\"\n+    | Some (Asm.IMM i) when (i64_lt i 0L) ->\n+        Printf.sprintf \" - 0x%Lx\" (Int64.neg i)\n+    | Some e' -> \" + \" ^ (string_of_expr64 e')\n+;;\n+\n+let string_of_mem (f:hreg_formatter) (a:mem) : string =\n+  match a with\n+      Abs e ->\n+        Printf.sprintf \"[%s]\" (string_of_expr64 e)\n+    | RegIn (r, off) ->\n+        Printf.sprintf \"[%s%s]\" (string_of_reg f r) (string_of_off off)\n+    | Spill i ->\n+        Printf.sprintf \"[<spill %d>]\" i\n+;;\n+let string_of_cell (f:hreg_formatter) (c:cell) : string =\n+  match c with\n+      Reg (r,ty) ->\n+        if !log_iltypes\n+        then\n+          Printf.sprintf \"%s:%s\" (string_of_reg f r) (string_of_scalar_ty ty)\n+        else\n+          Printf.sprintf \"%s\" (string_of_reg f r)\n+    | Mem (a,ty) ->\n+        if !log_iltypes\n+        then\n+          Printf.sprintf \"%s:%s\"\n+            (string_of_mem f a) (string_of_referent_ty ty)\n+        else\n+          Printf.sprintf \"%s\" (string_of_mem f a)\n+;;\n+\n+let string_of_operand (f:hreg_formatter) (op:operand) : string =\n+  match op with\n+      Cell c -> string_of_cell f c\n+    | ImmPtr (f, ty) ->\n+        if !log_iltypes\n+        then\n+          Printf.sprintf \"$<%s>.mpos:%s*\"\n+            f.fixup_name (string_of_referent_ty ty)\n+        else\n+          Printf.sprintf \"$<%s>.mpos\" f.fixup_name\n+    | Imm (i, ty) ->\n+        if !log_iltypes\n+        then\n+          Printf.sprintf \"$%s:%s\" (string_of_expr64 i) (string_of_ty_mach ty)\n+        else\n+          Printf.sprintf \"$%s\" (string_of_expr64 i)\n+;;\n+\n+\n+let string_of_code (f:hreg_formatter) (c:code) : string =\n+  match c with\n+      CodeLabel lab -> Printf.sprintf \"<label %d>\" lab\n+    | CodePtr op -> string_of_operand f op\n+    | CodeNone -> \"<none>\"\n+;;\n+\n+\n+let string_of_binop (op:binop) : string =\n+  match op with\n+      ADD -> \"add\"\n+    | SUB -> \"sub\"\n+    | IMUL -> \"imul\"\n+    | UMUL -> \"umul\"\n+    | IDIV -> \"idiv\"\n+    | UDIV -> \"udiv\"\n+    | IMOD -> \"imod\"\n+    | UMOD -> \"umod\"\n+    | AND -> \"and\"\n+    | OR -> \"or\"\n+    | XOR -> \"xor\"\n+    | LSL -> \"lsl\"\n+    | LSR -> \"lsr\"\n+    | ASR -> \"asr\"\n+;;\n+\n+let string_of_unop (op:unop) : string =\n+  match op with\n+      NEG -> \"neg\"\n+    | NOT -> \"not\"\n+    | UMOV -> \"umov\"\n+    | IMOV -> \"imov\"\n+    | ZERO -> \"zero\"\n+;;\n+\n+let string_of_jmpop (op:jmpop) : string =\n+  match op with\n+      JE -> \"je\"\n+    | JNE -> \"jne\"\n+    | JL -> \"jl\"\n+    | JLE -> \"jle\"\n+    | JG -> \"jg\"\n+    | JGE -> \"jge\"\n+    | JB -> \"jb\"\n+    | JBE -> \"jbe\"\n+    | JA -> \"ja\"\n+    | JAE -> \"jae\"\n+    | JC -> \"jc\"\n+    | JNC ->\"jnc\"\n+    | JO -> \"jo\"\n+    | JNO -> \"jno\"\n+    | JZ -> \"jz\"\n+    | JNZ ->\"jnz\"\n+    | JMP -> \"jmp\"\n+;;\n+\n+let string_of_quad (f:hreg_formatter) (q:quad) : string =\n+  match q.quad_body with\n+      Binary b ->\n+        Printf.sprintf \"%s = %s %s %s\"\n+          (string_of_cell f b.binary_dst)\n+          (string_of_operand f b.binary_lhs)\n+          (string_of_binop b.binary_op)\n+          (string_of_operand f b.binary_rhs)\n+\n+    | Unary u ->\n+        Printf.sprintf \"%s = %s %s\"\n+          (string_of_cell f u.unary_dst)\n+          (string_of_unop u.unary_op)\n+          (string_of_operand f u.unary_src)\n+\n+    | Cmp c ->\n+        Printf.sprintf \"cmp %s %s\"\n+          (string_of_operand f c.cmp_lhs)\n+          (string_of_operand f c.cmp_rhs)\n+\n+    | Lea le ->\n+        Printf.sprintf \"lea %s %s\"\n+          (string_of_cell f le.lea_dst)\n+          (string_of_operand f le.lea_src)\n+\n+    | Jmp j ->\n+        Printf.sprintf \"%s %s\"\n+          (string_of_jmpop j.jmp_op)\n+          (string_of_code f j.jmp_targ)\n+\n+    | Push op ->\n+        Printf.sprintf \"push %s\"\n+          (string_of_operand f op)\n+\n+    | Pop c ->\n+        Printf.sprintf \"%s = pop\"\n+          (string_of_cell f c)\n+\n+    | Call c ->\n+        Printf.sprintf \"%s = call %s\"\n+          (string_of_cell f c.call_dst)\n+          (string_of_code f c.call_targ)\n+\n+    | Ret -> \"ret\"\n+    | Nop -> \"nop\"\n+    | Dead -> \"dead\"\n+    | Debug -> \"debug\"\n+    | Regfence -> \"regfence\"\n+    | Enter _ -> \"enter lexical block\"\n+    | Leave -> \"leave lexical block\"\n+    | End -> \"---\"\n+;;\n+\n+\n+\n+(* Emitters. *)\n+\n+\n+type emitter = { mutable emit_pc: int;\n+                 mutable emit_next_vreg: int option;\n+                 mutable emit_next_spill: int;\n+                 emit_preallocator: (quad' -> quad');\n+                 emit_is_2addr: bool;\n+                 mutable emit_quads: quads;\n+                 emit_annotations: (int,string) Hashtbl.t;\n+                 emit_size_cache: ((size,operand) Hashtbl.t) Stack.t;\n+                 emit_node: node_id option;\n+               }\n+\n+\n+let badq = { quad_fixup = None;\n+             quad_implicits = [];\n+             quad_body = End }\n+;;\n+\n+\n+let deadq = { quad_fixup = None;\n+              quad_implicits = [];\n+              quad_body = Dead }\n+;;\n+\n+\n+let new_emitter\n+    (preallocator:quad' -> quad')\n+    (is_2addr:bool)\n+    (vregs_ok:bool)\n+    (node:node_id option)\n+    : emitter =\n+  {\n+    emit_pc = 0;\n+    emit_next_vreg = (if vregs_ok then Some 0 else None);\n+    emit_next_spill = 0;\n+    emit_preallocator = preallocator;\n+    emit_is_2addr = is_2addr;\n+    emit_quads = Array.create 4 badq;\n+    emit_annotations = Hashtbl.create 0;\n+    emit_size_cache = Stack.create ();\n+    emit_node = node;\n+  }\n+;;\n+\n+\n+let num_vregs (e:emitter) : int =\n+  match e.emit_next_vreg with\n+      None -> 0\n+    | Some i -> i\n+;;\n+\n+let next_vreg_num (e:emitter) : vreg =\n+  match e.emit_next_vreg with\n+      None -> bug () \"Il.next_vreg_num on non-vreg emitter\"\n+    | Some i ->\n+        e.emit_next_vreg <- Some (i + 1);\n+        i\n+;;\n+\n+let next_vreg (e:emitter) : reg =\n+  Vreg (next_vreg_num e)\n+;;\n+\n+let next_vreg_cell (e:emitter) (s:scalar_ty) : cell =\n+  Reg ((next_vreg e), s)\n+;;\n+\n+let next_spill (e:emitter) : spill =\n+  let i = e.emit_next_spill in\n+    e.emit_next_spill <- i + 1;\n+    i\n+;;\n+\n+let next_spill_slot (e:emitter) (r:referent_ty) : typed_mem =\n+  (Spill (next_spill e), r);\n+;;\n+\n+\n+let grow_if_necessary e =\n+  let len = Array.length e.emit_quads in\n+    if e.emit_pc >= len - 1\n+    then\n+      let n = Array.create (2 * len) badq in\n+        Array.blit e.emit_quads 0 n 0 len;\n+        e.emit_quads <- n\n+;;\n+\n+\n+let binary (op:binop) (dst:cell) (lhs:operand) (rhs:operand) : quad' =\n+  Binary { binary_op = op;\n+           binary_dst = dst;\n+           binary_lhs = lhs;\n+           binary_rhs = rhs }\n+;;\n+\n+let unary (op:unop) (dst:cell) (src:operand) : quad' =\n+  Unary { unary_op = op;\n+          unary_dst = dst;\n+          unary_src = src }\n+\n+let jmp (op:jmpop) (targ:code) : quad' =\n+  Jmp { jmp_op = op;\n+        jmp_targ = targ; }\n+;;\n+\n+\n+let lea (dst:cell) (src:operand) : quad' =\n+  Lea { lea_dst = dst;\n+        lea_src = src; }\n+;;\n+\n+let cmp (lhs:operand) (rhs:operand) : quad' =\n+  Cmp { cmp_lhs = lhs;\n+        cmp_rhs = rhs; }\n+;;\n+\n+let call (dst:cell) (targ:code) : quad' =\n+  Call { call_dst = dst;\n+         call_targ = targ; }\n+;;\n+\n+let umov (dst:cell) (src:operand) : quad' =\n+    if (cell_is_nil dst || operand_is_nil src)\n+    then Dead\n+    else unary UMOV dst src\n+;;\n+\n+let zero (dst:cell) (count:operand) : quad' =\n+  unary ZERO dst count\n+;;\n+\n+let is_mov uop =\n+  match uop with\n+      UMOV | IMOV -> true\n+    | _ -> false\n+;;\n+\n+let mk_quad (q':quad') : quad =\n+  { quad_body = q';\n+    quad_implicits = [];\n+    quad_fixup = None }\n+;;\n+\n+let emit_full\n+    (e:emitter)\n+    (fix:fixup option)\n+    (implicits:label list)\n+    (q':quad')\n+    : unit =\n+  let fixup = ref fix in\n+  let emit_quad_bottom q' =\n+    grow_if_necessary e;\n+    e.emit_quads.(e.emit_pc) <- { quad_body = q';\n+                                  quad_implicits = implicits;\n+                                  quad_fixup = (!fixup) };\n+    fixup := None;\n+    e.emit_pc <- e.emit_pc + 1\n+  in\n+\n+  let emit_quad (q':quad') : unit =\n+    (* re-decay any freshly generated mem-mem movs. *)\n+    match q' with\n+        Unary { unary_dst = Mem (dst_mem, ScalarTy src_st);\n+                unary_src = Cell (Mem (src_mem, ScalarTy dst_st));\n+                unary_op = op }\n+          when is_mov op ->\n+            let v = next_vreg_cell e dst_st in\n+              emit_quad_bottom\n+                (unary op v (Cell (Mem (src_mem, ScalarTy src_st))));\n+              emit_quad_bottom\n+                (unary op (Mem (dst_mem, ScalarTy dst_st)) (Cell v))\n+      | _ -> emit_quad_bottom q'\n+  in\n+\n+  let default_mov =\n+    match q' with\n+        Binary b ->\n+          begin\n+            match b.binary_op with\n+                IDIV | IMUL | IMOD -> IMOV\n+              | _ -> UMOV\n+          end\n+      | Unary u ->\n+          begin\n+            match u.unary_op with\n+                IMOV -> IMOV\n+              | _ -> UMOV\n+          end\n+      | _ -> UMOV\n+  in\n+\n+  let emit_mov (dst:cell) (src:operand) : unit =\n+    emit_quad (unary default_mov dst src)\n+  in\n+\n+  let mov_if_operands_differ\n+      (old_op:operand) (new_op:operand)\n+      : unit =\n+    if (new_op <> old_op)\n+    then\n+      match new_op with\n+          (Cell new_cell) ->\n+            emit_mov new_cell old_op\n+        | _ -> ()\n+  in\n+\n+  let mov_if_two_operands_differ\n+      (old_lhs_op:operand) (new_lhs_op:operand)\n+      (old_rhs_op:operand) (new_rhs_op:operand)\n+      : unit =\n+    (*\n+     * This is sufficiently obscure that it deserves an explanation.\n+     * \n+     * The main idea here is to do two \"mov_if_operands_differ\" calls,\n+     * such as one might have when setting up a binary quad.\n+     * \n+     * The problem comes when you happen to hit a case like X86 div,\n+     * which preallocates *both* operands. Preallocating both means we\n+     * have to potentially issue two movs into the preallocated regs,\n+     * and the second of those movs might be a problem. Specifically:\n+     * the second mov-to-prealloc might make be moving from a\n+     * register-indirect mem cell based on a vreg, and that vreg may\n+     * wind up being assigned to an hreg that we just loaded with the\n+     * first mov. In other words, the second mov may retask the\n+     * preallocated hreg we set up in the first mov.\n+     * \n+     * You laugh, but of course this actually happens.\n+     * \n+     * So here we do a conservative thing and check to see if either\n+     * operand is memory-indirect at all. If either is, then for either\n+     * of the 'old' operands we're *about* to mov into a prealloc reg,\n+     * we first bounce them off a spill slot. Spill slots, thankfully,\n+     * we can always count on being able to address irrespective of the\n+     * opinions of the RA, as they are all just fp-relative.\n+     * \n+     * A slightly more aggressive version of this would only bounce\n+     * cases that are not fp-relative already, though doing so would\n+     * require threading the notion of what fp *is* through to\n+     * here. Possibly tighten this up in the future (or just\n+     * ... destroy this backend ASAP).\n+     * \n+     *)\n+    let has_reg_indirect op =\n+      match op with\n+          Cell (Mem _) -> true\n+        | _ -> false\n+    in\n+    let either_old_op_has_reg_indirect =\n+      (has_reg_indirect old_lhs_op) || (has_reg_indirect old_rhs_op)\n+    in\n+    let old_lhs_op =\n+      if either_old_op_has_reg_indirect && (new_lhs_op <> old_lhs_op)\n+      then\n+        let tmp =\n+          Mem (next_spill_slot e\n+                 (ScalarTy (operand_scalar_ty old_lhs_op)))\n+        in\n+          emit_mov tmp old_lhs_op;\n+          Cell tmp\n+      else\n+        old_lhs_op\n+    in\n+    let old_rhs_op =\n+      if either_old_op_has_reg_indirect && (new_rhs_op <> old_rhs_op)\n+      then\n+        let tmp =\n+          Mem (next_spill_slot e\n+                 (ScalarTy (operand_scalar_ty old_rhs_op)))\n+        in\n+          emit_mov tmp old_rhs_op;\n+          Cell tmp\n+      else\n+        old_rhs_op\n+    in\n+      mov_if_operands_differ old_lhs_op new_lhs_op;\n+      mov_if_operands_differ old_rhs_op new_rhs_op;\n+  in\n+\n+  let mov_if_cells_differ (old_cell:cell) (new_cell:cell) : unit =\n+    if not (new_cell = old_cell)\n+    then\n+      emit_mov old_cell (Cell new_cell)\n+  in\n+\n+  let emit_decayed_quad q' =\n+    match (q', e.emit_preallocator q') with\n+        (Binary b, Binary b') ->\n+          begin\n+            mov_if_two_operands_differ\n+              b.binary_lhs b'.binary_lhs\n+              b.binary_rhs b'.binary_rhs;\n+            if e.emit_is_2addr &&\n+              (not (b'.binary_lhs = (Cell b'.binary_dst)))\n+            then\n+              begin\n+                emit_mov b'.binary_dst b'.binary_lhs;\n+                emit_quad (Binary { b' with\n+                                      binary_lhs = (Cell b'.binary_dst) })\n+              end\n+            else\n+              emit_quad (Binary b');\n+            mov_if_cells_differ b.binary_dst b'.binary_dst\n+          end\n+\n+      | (Unary u, Unary u') ->\n+          mov_if_operands_differ u.unary_src u'.unary_src;\n+          (* Assume '2addr' means '1addr' for unary ops. *)\n+          if e.emit_is_2addr &&\n+            (u'.unary_op = NEG || u'.unary_op = NOT) &&\n+            (not (u'.unary_src = (Cell u'.unary_dst)))\n+            then\n+              begin\n+                emit_mov u'.unary_dst u'.unary_src;\n+                emit_quad (Unary { u' with unary_src = (Cell u'.unary_dst) })\n+              end\n+            else\n+              emit_quad (Unary u');\n+          mov_if_cells_differ u.unary_dst u'.unary_dst\n+\n+      | (Cmp c, Cmp c') ->\n+          mov_if_two_operands_differ\n+            c.cmp_lhs c'.cmp_lhs\n+            c.cmp_rhs c'.cmp_rhs;\n+          emit_quad (Cmp c');\n+\n+      | (Push op, Push op') ->\n+          mov_if_operands_differ op op';\n+          emit_quad (Push op');\n+\n+      | (Pop c, Pop c') ->\n+          emit_quad (Pop c');\n+          mov_if_cells_differ c c'\n+\n+      | (Call c, Call c') ->\n+          emit_quad (Call c');\n+          mov_if_cells_differ c.call_dst c'.call_dst\n+\n+      | (Lea lea, Lea lea') ->\n+          emit_quad (Lea lea');\n+          mov_if_cells_differ lea.lea_dst lea'.lea_dst\n+\n+      | (x, y) ->\n+          assert (x = y);\n+          emit_quad x\n+  in\n+\n+    (* pre-decay mem-mem movs. *)\n+    match q' with\n+        Unary { unary_dst = Mem (dst_mem, ScalarTy src_st);\n+                unary_src = Cell (Mem (src_mem, ScalarTy dst_st));\n+                unary_op = op }\n+          when is_mov op ->\n+            let v = next_vreg_cell e dst_st in\n+              emit_decayed_quad\n+                (unary op v (Cell (Mem (src_mem, ScalarTy src_st))));\n+              emit_decayed_quad\n+                (unary op (Mem (dst_mem, ScalarTy dst_st)) (Cell v))\n+      | _ -> emit_decayed_quad q'\n+;;\n+\n+let emit (e:emitter) (q':quad') : unit =\n+  emit_full e None [] q'\n+;;\n+\n+let patch_jump (e:emitter) (jmp:int) (targ:int) : unit =\n+  let q = e.emit_quads.(jmp) in\n+    match q.quad_body with\n+        Jmp j ->\n+          assert (j.jmp_targ = CodeNone);\n+          e.emit_quads.(jmp) <-\n+            { q with quad_body =\n+                Jmp { j with jmp_targ = CodeLabel targ } }\n+      | _ -> ()\n+;;\n+\n+(* More query functions. *)\n+\n+let get_element_ptr\n+    (word_bits:bits)\n+    (fmt:hreg_formatter)\n+    (mem_cell:cell)\n+    (i:int)\n+    : cell =\n+  match mem_cell with\n+      Mem (mem, StructTy elts) when i >= 0 && i < (Array.length elts) ->\n+        assert ((Array.length elts) != 0);\n+        begin\n+          let elt_rty = elts.(i) in\n+          let elt_off = get_element_offset word_bits elts i in\n+            match elt_off with\n+                SIZE_fixed fixed_off ->\n+                  Mem (mem_off_imm mem fixed_off, elt_rty)\n+              | _ -> bug ()\n+                  \"get_element_ptr %d on dynamic-size cell: offset %s\"\n+                    i (string_of_size elt_off)\n+        end\n+\n+    | _ -> bug () \"get_element_ptr %d on cell %s\" i\n+        (string_of_cell fmt mem_cell)\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "7fccdfd35486b911ba91284407da8fa61af96d80", "filename": "src/boot/be/macho.ml", "status": "added", "additions": 1184, "deletions": 0, "changes": 1184, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fmacho.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fmacho.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fmacho.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1184 @@\n+open Asm;;\n+open Common;;\n+\n+(* Mach-O writer. *)\n+\n+let log (sess:Session.sess) =\n+  Session.log \"obj (mach-o)\"\n+    sess.Session.sess_log_obj\n+    sess.Session.sess_log_out\n+;;\n+\n+let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n+  if sess.Session.sess_log_obj\n+  then thunk ()\n+  else ()\n+;;\n+\n+let (cpu_arch_abi64:int64) = 0x01000000L\n+;;\n+\n+let (mh_magic:int64) = 0xfeedfaceL\n+;;\n+\n+let cpu_subtype_intel (f:int64) (m:int64) : int64 =\n+  Int64.add f (Int64.shift_left m 4)\n+;;\n+\n+type cpu_type =\n+    (* Maybe support more later. *)\n+    CPU_TYPE_X86\n+  | CPU_TYPE_X86_64\n+  | CPU_TYPE_ARM\n+  | CPU_TYPE_POWERPC\n+;;\n+\n+type cpu_subtype =\n+    (* Maybe support more later. *)\n+    CPU_SUBTYPE_X86_ALL\n+  | CPU_SUBTYPE_X86_64_ALL\n+  | CPU_SUBTYPE_ARM_ALL\n+  | CPU_SUBTYPE_POWERPC_ALL\n+;;\n+\n+type file_type =\n+    MH_OBJECT\n+  | MH_EXECUTE\n+  | MH_FVMLIB\n+  | MH_CORE\n+  | MH_PRELOAD\n+  | MH_DYLIB\n+  | MH_DYLINKER\n+  | MH_BUNDLE\n+  | MH_DYLIB_STUB\n+  | MH_DSYM\n+;;\n+\n+let file_type_code (ft:file_type) : int64 =\n+  match ft with\n+      MH_OBJECT ->0x1L      (* object *)\n+    | MH_EXECUTE -> 0x2L    (* executable *)\n+    | MH_FVMLIB -> 0x3L     (* fixed-VM shared lib *)\n+    | MH_CORE -> 0x4L       (* core *)\n+    | MH_PRELOAD -> 0x5L    (* preloaded executable *)\n+    | MH_DYLIB -> 0x6L      (* dynamic lib *)\n+    | MH_DYLINKER -> 0x7L   (* dynamic linker *)\n+    | MH_BUNDLE -> 0x8L     (* bundle *)\n+    | MH_DYLIB_STUB -> 0x9L (* shared lib stub *)\n+    | MH_DSYM -> 0xaL       (* debuginfo only *)\n+;;\n+\n+type file_flag =\n+    MH_NOUNDEFS\n+  | MH_INCRLINK\n+  | MH_DYLDLINK\n+  | MH_BINDATLOAD\n+  | MH_PREBOUND\n+  | MH_SPLIT_SEGS\n+  | MH_LAZY_INIT\n+  | MH_TWOLEVEL\n+  | MH_FORCE_FLAT\n+  | MH_NOMULTIDEFS\n+  | MH_NOFIXPREBINDING\n+  | MH_PREBINDABLE\n+  | MH_ALLMODSBOUND\n+  | MH_SUBSECTIONS_VIA_SYMBOLS\n+  | MH_CANONICAL\n+  | MH_WEAK_DEFINES\n+  | MH_BINDS_TO_WEAK\n+  | MH_ALLOW_STACK_EXECUTION\n+  | MH_ROOT_SAFE\n+  | MH_SETUID_SAFE\n+  | MH_NO_REEXPORTED_DYLIBS\n+  | MH_PIE\n+;;\n+\n+let file_flag_code (ff:file_flag) : int64 =\n+  match ff with\n+      MH_NOUNDEFS -> 0x1L\n+    | MH_INCRLINK -> 0x2L\n+    | MH_DYLDLINK -> 0x4L\n+    | MH_BINDATLOAD -> 0x8L\n+    | MH_PREBOUND -> 0x10L\n+    | MH_SPLIT_SEGS -> 0x20L\n+    | MH_LAZY_INIT -> 0x40L\n+    | MH_TWOLEVEL -> 0x80L\n+    | MH_FORCE_FLAT -> 0x100L\n+    | MH_NOMULTIDEFS -> 0x200L\n+    | MH_NOFIXPREBINDING -> 0x400L\n+    | MH_PREBINDABLE -> 0x800L\n+    | MH_ALLMODSBOUND -> 0x1000L\n+    | MH_SUBSECTIONS_VIA_SYMBOLS -> 0x2000L\n+    | MH_CANONICAL -> 0x4000L\n+    | MH_WEAK_DEFINES -> 0x8000L\n+    | MH_BINDS_TO_WEAK -> 0x10000L\n+    | MH_ALLOW_STACK_EXECUTION -> 0x20000L\n+    | MH_ROOT_SAFE -> 0x40000L\n+    | MH_SETUID_SAFE -> 0x80000L\n+    | MH_NO_REEXPORTED_DYLIBS -> 0x100000L\n+    | MH_PIE -> 0x200000L\n+;;\n+\n+\n+type vm_prot =\n+    VM_PROT_NONE\n+  | VM_PROT_READ\n+  | VM_PROT_WRITE\n+  | VM_PROT_EXECUTE\n+;;\n+\n+\n+type load_command =\n+    LC_SEGMENT\n+  | LC_SYMTAB\n+  | LC_SYMSEG\n+  | LC_THREAD\n+  | LC_UNIXTHREAD\n+  | LC_LOADFVMLIB\n+  | LC_IDFVMLIB\n+  | LC_IDENT\n+  | LC_FVMFILE\n+  | LC_PREPAGE\n+  | LC_DYSYMTAB\n+  | LC_LOAD_DYLIB\n+  | LC_ID_DYLIB\n+  | LC_LOAD_DYLINKER\n+  | LC_ID_DYLINKER\n+  | LC_PREBOUND_DYLIB\n+  | LC_ROUTINES\n+  | LC_SUB_FRAMEWORK\n+  | LC_SUB_UMBRELLA\n+  | LC_SUB_CLIENT\n+  | LC_SUB_LIBRARY\n+  | LC_TWOLEVEL_HINTS\n+  | LC_PREBIND_CKSUM\n+  | LC_LOAD_WEAK_DYLIB\n+  | LC_SEGMENT_64\n+  | LC_ROUTINES_64\n+  | LC_UUID\n+  | LC_RPATH\n+  | LC_CODE_SIGNATURE\n+  | LC_SEGMENT_SPLIT_INFO\n+  | LC_REEXPORT_DYLIB\n+  | LC_LAZY_LOAD_DYLIB\n+  | LC_ENCRYPTION_INFO\n+;;\n+\n+\n+let cpu_type_code (cpu:cpu_type) : int64 =\n+  match cpu with\n+      CPU_TYPE_X86 -> 7L\n+    | CPU_TYPE_X86_64 -> Int64.logor 7L cpu_arch_abi64\n+    | CPU_TYPE_ARM -> 12L\n+    | CPU_TYPE_POWERPC -> 18L\n+;;\n+\n+let cpu_subtype_code (cpu:cpu_subtype) : int64 =\n+  match cpu with\n+      CPU_SUBTYPE_X86_ALL -> 3L\n+    | CPU_SUBTYPE_X86_64_ALL -> 3L\n+    | CPU_SUBTYPE_ARM_ALL -> 0L\n+    | CPU_SUBTYPE_POWERPC_ALL -> 0L\n+;;\n+\n+\n+let vm_prot_code (vmp:vm_prot) : int64 =\n+  match vmp with\n+    VM_PROT_NONE -> 0L\n+  | VM_PROT_READ -> 1L\n+  | VM_PROT_WRITE -> 2L\n+  | VM_PROT_EXECUTE -> 4L\n+;;\n+\n+\n+let lc_req_dyld = 0x80000000L;;\n+\n+let load_command_code (lc:load_command) =\n+  match lc with\n+    | LC_SEGMENT -> 0x1L\n+    | LC_SYMTAB -> 0x2L\n+    | LC_SYMSEG -> 0x3L\n+    | LC_THREAD -> 0x4L\n+    | LC_UNIXTHREAD -> 0x5L\n+    | LC_LOADFVMLIB -> 0x6L\n+    | LC_IDFVMLIB -> 0x7L\n+    | LC_IDENT -> 0x8L\n+    | LC_FVMFILE -> 0x9L\n+    | LC_PREPAGE -> 0xaL\n+    | LC_DYSYMTAB -> 0xbL\n+    | LC_LOAD_DYLIB -> 0xcL\n+    | LC_ID_DYLIB -> 0xdL\n+    | LC_LOAD_DYLINKER -> 0xeL\n+    | LC_ID_DYLINKER -> 0xfL\n+    | LC_PREBOUND_DYLIB -> 0x10L\n+    | LC_ROUTINES -> 0x11L\n+    | LC_SUB_FRAMEWORK -> 0x12L\n+    | LC_SUB_UMBRELLA -> 0x13L\n+    | LC_SUB_CLIENT -> 0x14L\n+    | LC_SUB_LIBRARY -> 0x15L\n+    | LC_TWOLEVEL_HINTS -> 0x16L\n+    | LC_PREBIND_CKSUM -> 0x17L\n+    | LC_LOAD_WEAK_DYLIB -> Int64.logor lc_req_dyld 0x18L\n+    | LC_SEGMENT_64 -> 0x19L\n+    | LC_ROUTINES_64 -> 0x1aL\n+    | LC_UUID -> 0x1bL\n+    | LC_RPATH -> Int64.logor lc_req_dyld 0x1cL\n+    | LC_CODE_SIGNATURE -> 0x1dL\n+    | LC_SEGMENT_SPLIT_INFO -> 0x1eL\n+    | LC_REEXPORT_DYLIB -> Int64.logor lc_req_dyld 0x1fL\n+    | LC_LAZY_LOAD_DYLIB -> 0x20L\n+    | LC_ENCRYPTION_INFO -> 0x21L\n+;;\n+\n+\n+let fixed_sz_string (sz:int) (str:string) : frag =\n+  if String.length str > sz\n+  then STRING (String.sub str 0 sz)\n+  else SEQ [| STRING str; PAD (sz - (String.length str)) |]\n+;;\n+\n+type sect_type =\n+    S_REGULAR\n+  | S_ZEROFILL\n+  | S_CSTRING_LITERALS\n+  | S_4BYTE_LITERALS\n+  | S_8BYTE_LITERALS\n+  | S_LITERAL_POINTERS\n+  | S_NON_LAZY_SYMBOL_POINTERS\n+  | S_LAZY_SYMBOL_POINTERS\n+  | S_SYMBOL_STUBS\n+  | S_MOD_INIT_FUNC_POINTERS\n+  | S_MOD_TERM_FUNC_POINTERS\n+  | S_COALESCED\n+  | S_GB_ZEROFILL\n+  | S_INTERPOSING\n+  | S_16BYTE_LITERALS\n+  | S_DTRACE_DOF\n+  | S_LAZY_DYLIB_SYMBOL_POINTERS\n+;;\n+\n+let sect_type_code (s:sect_type) : int64 =\n+  match s with\n+    S_REGULAR -> 0x0L\n+  | S_ZEROFILL -> 0x1L\n+  | S_CSTRING_LITERALS -> 0x2L\n+  | S_4BYTE_LITERALS -> 0x3L\n+  | S_8BYTE_LITERALS -> 0x4L\n+  | S_LITERAL_POINTERS -> 0x5L\n+  | S_NON_LAZY_SYMBOL_POINTERS -> 0x6L\n+  | S_LAZY_SYMBOL_POINTERS -> 0x7L\n+  | S_SYMBOL_STUBS -> 0x8L\n+  | S_MOD_INIT_FUNC_POINTERS -> 0x9L\n+  | S_MOD_TERM_FUNC_POINTERS -> 0xaL\n+  | S_COALESCED -> 0xbL\n+  | S_GB_ZEROFILL -> 0xcL\n+  | S_INTERPOSING -> 0xdL\n+  | S_16BYTE_LITERALS -> 0xeL\n+  | S_DTRACE_DOF -> 0xfL\n+  | S_LAZY_DYLIB_SYMBOL_POINTERS -> 0x10L\n+;;\n+\n+type sect_attr =\n+    S_ATTR_PURE_INSTRUCTIONS\n+  | S_ATTR_NO_TOC\n+  | S_ATTR_STRIP_STATIC_SYMS\n+  | S_ATTR_NO_DEAD_STRIP\n+  | S_ATTR_LIVE_SUPPORT\n+  | S_ATTR_SELF_MODIFYING_CODE\n+  | S_ATTR_DEBUG\n+  | S_ATTR_SOME_INSTRUCTIONS\n+  | S_ATTR_EXT_RELOC\n+  | S_ATTR_LOC_RELOC\n+;;\n+\n+let sect_attr_code (s:sect_attr) : int64 =\n+  match s with\n+    S_ATTR_PURE_INSTRUCTIONS -> 0x80000000L\n+  | S_ATTR_NO_TOC -> 0x40000000L\n+  | S_ATTR_STRIP_STATIC_SYMS -> 0x20000000L\n+  | S_ATTR_NO_DEAD_STRIP -> 0x10000000L\n+  | S_ATTR_LIVE_SUPPORT -> 0x08000000L\n+  | S_ATTR_SELF_MODIFYING_CODE -> 0x04000000L\n+  | S_ATTR_DEBUG -> 0x02000000L\n+  | S_ATTR_SOME_INSTRUCTIONS -> 0x00000400L\n+  | S_ATTR_EXT_RELOC -> 0x00000200L\n+  | S_ATTR_LOC_RELOC -> 0x00000100L\n+;;\n+\n+type n_type =\n+  | N_EXT\n+  | N_UNDF\n+  | N_ABS\n+  | N_SECT\n+  | N_PBUD\n+  | N_INDIR\n+;;\n+\n+let n_type_code (n:n_type) : int64 =\n+  match n with\n+      N_EXT -> 0x1L\n+    | N_UNDF -> 0x0L\n+    | N_ABS -> 0x2L\n+    | N_SECT -> 0xeL\n+    | N_PBUD -> 0xcL\n+    | N_INDIR -> 0xaL\n+;;\n+\n+\n+type n_desc_reference_type =\n+    REFERENCE_FLAG_UNDEFINED_NON_LAZY\n+  | REFERENCE_FLAG_UNDEFINED_LAZY\n+  | REFERENCE_FLAG_DEFINED\n+  | REFERENCE_FLAG_PRIVATE_DEFINED\n+  | REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY\n+  | REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY\n+;;\n+\n+let n_desc_reference_type_code (n:n_desc_reference_type) : int64 =\n+  match n with\n+      REFERENCE_FLAG_UNDEFINED_NON_LAZY -> 0x0L\n+    | REFERENCE_FLAG_UNDEFINED_LAZY -> 0x1L\n+    | REFERENCE_FLAG_DEFINED -> 0x2L\n+    | REFERENCE_FLAG_PRIVATE_DEFINED -> 0x3L\n+    | REFERENCE_FLAG_PRIVATE_UNDEFINED_NON_LAZY -> 0x4L\n+    | REFERENCE_FLAG_PRIVATE_UNDEFINED_LAZY -> 0x5L\n+;;\n+\n+type n_desc_flags =\n+    REFERENCED_DYNAMICALLY\n+  | N_DESC_DISCARDED\n+  | N_NO_DEAD_STRIP\n+  | N_WEAK_REF\n+  | N_WEAK_DEF\n+;;\n+\n+let n_desc_flags_code (n:n_desc_flags) : int64 =\n+  match n with\n+      REFERENCED_DYNAMICALLY -> 0x10L\n+    | N_DESC_DISCARDED -> 0x20L\n+    | N_NO_DEAD_STRIP -> 0x20L (* Yes, they reuse 0x20. *)\n+    | N_WEAK_REF -> 0x40L\n+    | N_WEAK_DEF -> 0x80L\n+;;\n+\n+type n_desc_dylib_ordinal = int;;\n+\n+type n_desc = (n_desc_dylib_ordinal *\n+                 (n_desc_flags list) *\n+                 n_desc_reference_type)\n+;;\n+\n+let n_desc_code (n:n_desc) : int64 =\n+  let (dylib_ordinal, flags, ty) = n in\n+    Int64.logor\n+      (Int64.of_int (dylib_ordinal lsl 8))\n+      (Int64.logor\n+         (fold_flags n_desc_flags_code flags)\n+         (n_desc_reference_type_code ty))\n+;;\n+\n+\n+let macho_section_command\n+    (seg_name:string)\n+    (sect:(string * int * (sect_attr list) * sect_type * fixup))\n+    : frag =\n+  let (sect_name, sect_align, sect_attrs, sect_type, sect_fixup) = sect in\n+    SEQ [|\n+      fixed_sz_string 16 sect_name;\n+      fixed_sz_string 16 seg_name;\n+      WORD (TY_u32, M_POS sect_fixup);\n+      WORD (TY_u32, M_SZ sect_fixup);\n+      WORD (TY_u32, F_POS sect_fixup);\n+      WORD (TY_u32, IMM (Int64.of_int sect_align));\n+      WORD (TY_u32, IMM 0L); (* reloff *)\n+      WORD (TY_u32, IMM 0L); (* nreloc *)\n+      WORD (TY_u32, (IMM (Int64.logor (* flags (and attrs) *)\n+                            (fold_flags sect_attr_code sect_attrs)\n+                            (sect_type_code sect_type))));\n+      WORD (TY_u32, IMM 0L); (* reserved1 *)\n+      WORD (TY_u32, IMM 0L); (* reserved2 *)\n+  |]\n+;;\n+\n+let macho_segment_command\n+    (seg_name:string)\n+    (seg_fixup:fixup)\n+    (maxprot:vm_prot list)\n+    (initprot:vm_prot list)\n+    (sects:(string * int * (sect_attr list) * sect_type * fixup) array)\n+    : frag =\n+\n+  let cmd_fixup = new_fixup \"segment command\" in\n+  let cmd =\n+    SEQ [|\n+      WORD (TY_u32, IMM (load_command_code LC_SEGMENT));\n+      WORD (TY_u32, F_SZ cmd_fixup);\n+      fixed_sz_string 16 seg_name;\n+      WORD (TY_u32, M_POS seg_fixup);\n+      WORD (TY_u32, M_SZ seg_fixup);\n+      WORD (TY_u32, F_POS seg_fixup);\n+      WORD (TY_u32, F_SZ seg_fixup);\n+      WORD (TY_u32, IMM (fold_flags vm_prot_code maxprot));\n+      WORD (TY_u32, IMM (fold_flags vm_prot_code initprot));\n+      WORD (TY_u32, IMM (Int64.of_int (Array.length sects)));\n+      WORD (TY_u32, IMM 0L); (* Flags? *)\n+    |]\n+  in\n+    DEF (cmd_fixup,\n+         SEQ [|\n+           cmd;\n+           SEQ (Array.map (macho_section_command seg_name) sects);\n+         |])\n+;;\n+\n+let macho_thread_command\n+    (entry:fixup)\n+    : frag =\n+  let cmd_fixup = new_fixup \"thread command\" in\n+  let x86_THREAD_STATE32 = 1L in\n+  let regs =\n+    [|\n+      WORD (TY_u32, IMM 0x0L); (* eax *)\n+      WORD (TY_u32, IMM 0x0L); (* ebx *)\n+      WORD (TY_u32, IMM 0x0L); (* ecx *)\n+      WORD (TY_u32, IMM 0x0L); (* edx *)\n+\n+      WORD (TY_u32, IMM 0x0L); (* edi *)\n+      WORD (TY_u32, IMM 0x0L); (* esi *)\n+      WORD (TY_u32, IMM 0x0L); (* ebp *)\n+      WORD (TY_u32, IMM 0x0L); (* esp *)\n+\n+      WORD (TY_u32, IMM 0x0L);    (* ss     *)\n+      WORD (TY_u32, IMM 0x0L);    (* eflags *)\n+      WORD (TY_u32, M_POS entry); (* eip    *)\n+      WORD (TY_u32, IMM 0x0L);    (* cs     *)\n+\n+      WORD (TY_u32, IMM 0x0L); (* ds *)\n+      WORD (TY_u32, IMM 0x0L); (* es *)\n+      WORD (TY_u32, IMM 0x0L); (* fs *)\n+      WORD (TY_u32, IMM 0x0L); (* gs *)\n+    |]\n+  in\n+  let cmd =\n+    SEQ [|\n+      WORD (TY_u32, IMM (load_command_code LC_UNIXTHREAD));\n+      WORD (TY_u32, F_SZ cmd_fixup);\n+      WORD (TY_u32, IMM x86_THREAD_STATE32); (* \"flavour\" *)\n+      WORD (TY_u32, IMM (Int64.of_int (Array.length regs)));\n+      SEQ regs\n+    |]\n+  in\n+    DEF (cmd_fixup, cmd)\n+;;\n+\n+let macho_dylinker_command : frag =\n+  let cmd_fixup = new_fixup \"dylinker command\" in\n+  let str_fixup = new_fixup \"dylinker lc_str fixup\" in\n+  let cmd =\n+    SEQ\n+      [|\n+        WORD (TY_u32, IMM (load_command_code LC_LOAD_DYLINKER));\n+        WORD (TY_u32, F_SZ cmd_fixup);\n+\n+        (* see definition of lc_str; these things are weird. *)\n+        WORD (TY_u32, SUB (F_POS (str_fixup), F_POS (cmd_fixup)));\n+        DEF (str_fixup, ZSTRING \"/usr/lib/dyld\");\n+        ALIGN_FILE (4, MARK);\n+      |]\n+  in\n+    DEF (cmd_fixup, cmd);\n+;;\n+\n+let macho_dylib_command (dylib:string) : frag =\n+\n+  let cmd_fixup = new_fixup \"dylib command\" in\n+  let str_fixup = new_fixup \"dylib lc_str fixup\" in\n+  let cmd =\n+    SEQ\n+      [|\n+        WORD (TY_u32, IMM (load_command_code LC_LOAD_DYLIB));\n+        WORD (TY_u32, F_SZ cmd_fixup);\n+\n+        (* see definition of lc_str; these things are weird. *)\n+        WORD (TY_u32, SUB (F_POS (str_fixup), F_POS (cmd_fixup)));\n+\n+        WORD (TY_u32, IMM 0L); (* timestamp *)\n+        WORD (TY_u32, IMM 0L); (* current_version *)\n+        WORD (TY_u32, IMM 0L); (* compatibility_version *)\n+\n+        (* Payload-and-alignment of an lc_str goes at end of command. *)\n+        DEF (str_fixup, ZSTRING dylib);\n+        ALIGN_FILE (4, MARK);\n+\n+      |]\n+  in\n+    DEF (cmd_fixup, cmd)\n+;;\n+\n+\n+let macho_symtab_command\n+    (symtab_fixup:fixup)\n+    (nsyms:int64)\n+    (strtab_fixup:fixup)\n+    : frag =\n+  let cmd_fixup = new_fixup \"symtab command\" in\n+  let cmd =\n+    SEQ\n+      [|\n+        WORD (TY_u32, IMM (load_command_code LC_SYMTAB));\n+        WORD (TY_u32, F_SZ cmd_fixup);\n+\n+        WORD (TY_u32, F_POS symtab_fixup); (* symoff *)\n+        WORD (TY_u32, IMM nsyms);          (* nsyms *)\n+\n+        WORD (TY_u32, F_POS strtab_fixup); (* stroff *)\n+        WORD (TY_u32, F_SZ strtab_fixup);  (* strsz *)\n+      |]\n+  in\n+    DEF (cmd_fixup, cmd)\n+;;\n+\n+let macho_dysymtab_command\n+    (local_defined_syms_index:int64)\n+    (local_defined_syms_count:int64)\n+    (external_defined_syms_index:int64)\n+    (external_defined_syms_count:int64)\n+    (undefined_syms_index:int64)\n+    (undefined_syms_count:int64)\n+    (indirect_symtab_fixup:fixup)  : frag =\n+  let cmd_fixup = new_fixup \"dysymtab command\" in\n+  let cmd =\n+    SEQ\n+      [|\n+        WORD (TY_u32, IMM (load_command_code LC_DYSYMTAB));\n+        WORD (TY_u32, F_SZ cmd_fixup);\n+\n+        WORD (TY_u32, IMM local_defined_syms_index); (* ilocalsym *)\n+        WORD (TY_u32, IMM local_defined_syms_count); (* nlocalsym *)\n+\n+        WORD (TY_u32, IMM external_defined_syms_index); (* iextdefsym *)\n+        WORD (TY_u32, IMM external_defined_syms_count); (* nextdefsym *)\n+\n+        WORD (TY_u32, IMM undefined_syms_index); (* iundefsym *)\n+        WORD (TY_u32, IMM undefined_syms_count); (* nundefsym *)\n+\n+        WORD (TY_u32, IMM 0L); (* tocoff *)\n+        WORD (TY_u32, IMM 0L); (* ntoc *)\n+\n+        WORD (TY_u32, IMM 0L); (* modtaboff *)\n+        WORD (TY_u32, IMM 0L); (* nmodtab *)\n+\n+        WORD (TY_u32, IMM 0L); (* extrefsymoff *)\n+        WORD (TY_u32, IMM 0L); (* nextrefsyms *)\n+\n+        WORD (TY_u32, F_POS indirect_symtab_fixup); (* indirectsymoff *)\n+        WORD (TY_u32, IMM undefined_syms_count);    (* nindirectsyms *)\n+\n+        WORD (TY_u32, IMM 0L); (* extreloff *)\n+        WORD (TY_u32, IMM 0L); (* nextrel *)\n+\n+        WORD (TY_u32, IMM 0L); (* locreloff *)\n+        WORD (TY_u32, IMM 0L); (* nlocrel *)\n+      |]\n+  in\n+    DEF (cmd_fixup, cmd)\n+;;\n+\n+let macho_header_32\n+    (cpu:cpu_type)\n+    (sub:cpu_subtype)\n+    (ftype:file_type)\n+    (flags:file_flag list)\n+    (loadcmds:frag array) : frag =\n+  let load_commands_fixup = new_fixup \"load commands\" in\n+  let cmds = DEF (load_commands_fixup, SEQ loadcmds) in\n+    SEQ\n+    [|\n+      WORD (TY_u32, IMM mh_magic);\n+      WORD (TY_u32, IMM (cpu_type_code cpu));\n+      WORD (TY_u32, IMM (cpu_subtype_code sub));\n+      WORD (TY_u32, IMM (file_type_code ftype));\n+      WORD (TY_u32, IMM (Int64.of_int (Array.length loadcmds)));\n+      WORD (TY_u32, F_SZ load_commands_fixup);\n+      WORD (TY_u32, IMM (fold_flags file_flag_code flags));\n+      cmds\n+    |]\n+;;\n+\n+let emit_file\n+    (sess:Session.sess)\n+    (crate:Ast.crate)\n+    (code:Asm.frag)\n+    (data:Asm.frag)\n+    (sem:Semant.ctxt)\n+    (dwarf:Dwarf.debug_records)\n+    : unit =\n+\n+  (* FIXME: alignment? *)\n+\n+  let mh_execute_header_fixup = new_fixup \"__mh_execute header\" in\n+\n+  let nxargc_fixup = (Semant.provide_native sem SEG_data \"NXArgc\") in\n+  let nxargv_fixup = (Semant.provide_native sem SEG_data \"NXArgv\") in\n+  let progname_fixup = (Semant.provide_native sem SEG_data \"__progname\") in\n+  let environ_fixup = (Semant.provide_native sem SEG_data \"environ\") in\n+  let exit_fixup = (Semant.require_native sem REQUIRED_LIB_crt \"exit\") in\n+  let (start_fixup, rust_start_fixup) =\n+    if sess.Session.sess_library_mode\n+    then (None, None)\n+    else (Some (new_fixup \"start function entry\"),\n+          Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n+  in\n+\n+  let text_sect_align_log2 = 2 in\n+  let data_sect_align_log2 = 2 in\n+\n+  let seg_align = 0x1000 in\n+  let text_sect_align = 2 lsl text_sect_align_log2 in\n+  let data_sect_align = 2 lsl data_sect_align_log2 in\n+\n+  let align_both align i =\n+    ALIGN_FILE (align,\n+                (ALIGN_MEM (align, i)))\n+  in\n+\n+  let def_aligned a f i =\n+    align_both a\n+      (SEQ [| DEF(f, i);\n+              (align_both a MARK)|])\n+  in\n+\n+  (* Segments. *)\n+  let zero_segment_fixup = new_fixup \"__PAGEZERO segment\" in\n+  let text_segment_fixup = new_fixup \"__TEXT segment\" in\n+  let data_segment_fixup = new_fixup \"__DATA segment\" in\n+  let dwarf_segment_fixup = new_fixup \"__DWARF segment\" in\n+  let linkedit_segment_fixup = new_fixup \"__LINKEDIT segment\" in\n+\n+  (* Sections in the text segment. *)\n+  let text_section_fixup = new_fixup \"__text section\" in\n+\n+  (* Sections in the data segment. *)\n+  let data_section_fixup = new_fixup \"__data section\" in\n+  let const_section_fixup = new_fixup \"__const section\" in\n+  let bss_section_fixup = new_fixup \"__bss section\" in\n+  let note_rust_section_fixup = new_fixup \"__note.rust section\" in\n+  let nl_symbol_ptr_section_fixup = new_fixup \"__nl_symbol_ptr section\" in\n+\n+  let data_section = def_aligned data_sect_align data_section_fixup data in\n+  let const_section =\n+    def_aligned data_sect_align const_section_fixup (SEQ [| |])\n+  in\n+  let bss_section =\n+    def_aligned data_sect_align bss_section_fixup (SEQ [| |])\n+  in\n+  let note_rust_section =\n+    def_aligned\n+      data_sect_align note_rust_section_fixup\n+      (Asm.note_rust_frags crate.node.Ast.crate_meta)\n+  in\n+\n+  (* Officially Apple doesn't claim to support DWARF sections like this, but\n+     they work. *)\n+  let debug_info_section =\n+    def_aligned data_sect_align\n+      sem.Semant.ctxt_debug_info_fixup\n+      dwarf.Dwarf.debug_info\n+  in\n+  let debug_abbrev_section =\n+    def_aligned data_sect_align\n+      sem.Semant.ctxt_debug_abbrev_fixup\n+      dwarf.Dwarf.debug_abbrev\n+  in\n+\n+\n+  (* String, symbol and parallel \"nonlazy-pointer\" tables. *)\n+  let symtab_fixup = new_fixup \"symtab\" in\n+  let strtab_fixup = new_fixup \"strtab\" in\n+\n+  let symbol_nlist_entry\n+      (sect_index:int)\n+      (nty:n_type list)\n+      (nd:n_desc)\n+      (nv:Asm.expr64)\n+      : (frag * fixup) =\n+    let strtab_entry_fixup = new_fixup \"strtab entry\" in\n+      (SEQ\n+         [|\n+           WORD (TY_u32, SUB ((F_POS strtab_entry_fixup),\n+                              (F_POS strtab_fixup)));\n+           BYTE (Int64.to_int (fold_flags n_type_code nty));\n+           BYTE sect_index;\n+           WORD (TY_u16, IMM (n_desc_code nd));\n+           WORD (TY_u32, nv);\n+         |], strtab_entry_fixup)\n+  in\n+\n+  let sect_symbol_nlist_entry\n+      (seg:segment)\n+      (fixup_to_use:fixup)\n+      : (frag * fixup) =\n+    let nty = [ N_SECT; N_EXT ] in\n+    let nd = (0, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n+    let (sect_index, _(*seg_fix*)) =\n+      match seg with\n+          SEG_text -> (1, text_segment_fixup)\n+        | SEG_data -> (2, data_segment_fixup)\n+    in\n+      symbol_nlist_entry sect_index nty nd (M_POS fixup_to_use)\n+  in\n+\n+  let sect_private_symbol_nlist_entry\n+      (seg:segment)\n+      (fixup_to_use:fixup)\n+      : (frag * fixup) =\n+    let nty = [ N_SECT; ] in\n+    let nd = (0, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n+    let (sect_index, _(*seg_fix*)) =\n+      match seg with\n+          SEG_text -> (1, text_segment_fixup)\n+        | SEG_data -> (2, data_segment_fixup)\n+    in\n+      symbol_nlist_entry sect_index nty nd (M_POS fixup_to_use)\n+  in\n+\n+  let indirect_symbol_nlist_entry (dylib_index:int) : (frag * fixup) =\n+    let nty = [ N_UNDF; N_EXT ] in\n+    let nd = (dylib_index, [], REFERENCE_FLAG_UNDEFINED_NON_LAZY) in\n+      symbol_nlist_entry 0 nty nd (IMM 0L)\n+  in\n+\n+  let indirect_symbols =\n+    Array.of_list\n+      (List.concat\n+         (List.map\n+            (fun (lib, tab) ->\n+               (List.map\n+                  (fun (name,fix) -> (lib,name,fix))\n+                  (htab_pairs tab)))\n+            (htab_pairs sem.Semant.ctxt_native_required)))\n+  in\n+\n+  let dylib_index (lib:required_lib) : int =\n+    match lib with\n+        REQUIRED_LIB_rustrt -> 1\n+      | REQUIRED_LIB_crt -> 2\n+      | _ -> bug () \"Macho.dylib_index on nonstandard required lib.\"\n+  in\n+\n+  (* Make undef symbols for native imports. *)\n+  let (undefined_symbols:(string * (frag * fixup)) array) =\n+    Array.map (fun (lib,name,_) ->\n+                 (\"_\" ^ name,\n+                  indirect_symbol_nlist_entry (dylib_index lib)))\n+      indirect_symbols\n+  in\n+\n+  (* Make symbols for exports. *)\n+  let (export_symbols:(string * (frag * fixup)) array) =\n+    let export_symbols_of_seg (seg, tab) =\n+      List.map\n+        begin\n+          fun (name, fix) ->\n+            let name = \"_\" ^ name in\n+            let sym = sect_symbol_nlist_entry seg fix in\n+              (name, sym)\n+        end\n+        (htab_pairs tab)\n+    in\n+      Array.of_list\n+        (List.concat\n+           (List.map export_symbols_of_seg\n+              (htab_pairs sem.Semant.ctxt_native_provided)))\n+  in\n+\n+  (* Make private symbols for items. *)\n+  let (local_item_symbols:(string * (frag * fixup)) array) =\n+    Array.map (fun code ->\n+                 let fix = code.Semant.code_fixup in\n+                   (\"_\" ^ fix.fixup_name,\n+                    sect_private_symbol_nlist_entry SEG_text fix))\n+      (Array.of_list (htab_vals sem.Semant.ctxt_all_item_code))\n+  in\n+\n+  (* Make private symbols for glue. *)\n+  let (local_glue_symbols:(string * (frag * fixup)) array) =\n+    Array.map (fun (g, code) ->\n+                 let fix = code.Semant.code_fixup in\n+                   (\"_\" ^ (Semant.glue_str sem g),\n+                    sect_private_symbol_nlist_entry SEG_text fix))\n+      (Array.of_list (htab_pairs sem.Semant.ctxt_glue_code))\n+  in\n+\n+  let (export_header_symbols:(string * (frag * fixup)) array) =\n+    let name =\n+      if sess.Session.sess_library_mode\n+      then \"__mh_dylib_header\"\n+      else \"__mh_execute_header\"\n+    in\n+      [|\n+        (name, sect_symbol_nlist_entry SEG_text mh_execute_header_fixup);\n+      |]\n+  in\n+\n+  let export_symbols = Array.concat [ export_symbols;\n+                                      export_header_symbols ]\n+  in\n+\n+  let local_symbols = Array.concat [ local_item_symbols;\n+                                     local_glue_symbols ]\n+  in\n+\n+  let symbols = Array.concat [ local_symbols;\n+                               export_symbols;\n+                               undefined_symbols ]\n+  in\n+  let n_local_syms = Array.length local_symbols in\n+  let n_export_syms = Array.length export_symbols in\n+  let n_undef_syms = Array.length undefined_symbols in\n+\n+  let indirect_symbols_off = n_local_syms + n_export_syms in\n+  let indirect_symtab_fixup = new_fixup \"indirect symbol table\" in\n+  let indirect_symtab =\n+    DEF (indirect_symtab_fixup,\n+         SEQ (Array.mapi\n+                (fun i _ -> WORD (TY_u32,\n+                                  IMM (Int64.of_int\n+                                         (i + indirect_symbols_off))))\n+                indirect_symbols))\n+  in\n+\n+  let nl_symbol_ptr_section =\n+    def_aligned data_sect_align nl_symbol_ptr_section_fixup\n+      (SEQ (Array.map\n+              (fun (_, _, fix) ->\n+                 DEF(fix, WORD(TY_u32, IMM 0L)))\n+              indirect_symbols))\n+  in\n+  let strtab = DEF (strtab_fixup,\n+                    SEQ (Array.map\n+                           (fun (name, (_, fix)) -> DEF(fix, ZSTRING name))\n+                           symbols))\n+  in\n+  let symtab = DEF (symtab_fixup,\n+                    SEQ (Array.map (fun (_, (frag, _)) -> frag) symbols))\n+  in\n+\n+\n+  let load_commands =\n+    [|\n+      macho_segment_command \"__PAGEZERO\" zero_segment_fixup\n+        [] [] [||];\n+\n+      macho_segment_command \"__TEXT\" text_segment_fixup\n+        [VM_PROT_READ; VM_PROT_EXECUTE]\n+        [VM_PROT_READ; VM_PROT_EXECUTE]\n+        [|\n+          (\"__text\", text_sect_align_log2, [], S_REGULAR, text_section_fixup)\n+        |];\n+\n+      macho_segment_command \"__DATA\" data_segment_fixup\n+        [VM_PROT_READ; VM_PROT_WRITE]\n+        [VM_PROT_READ; VM_PROT_WRITE]\n+        [|\n+          (\"__data\", data_sect_align_log2, [],\n+           S_REGULAR, data_section_fixup);\n+          (\"__const\", data_sect_align_log2, [],\n+           S_REGULAR, const_section_fixup);\n+          (\"__bss\", data_sect_align_log2, [],\n+           S_REGULAR, bss_section_fixup);\n+          (\"__note.rust\", data_sect_align_log2, [],\n+           S_REGULAR, note_rust_section_fixup);\n+          (\"__nl_symbol_ptr\", data_sect_align_log2, [],\n+           S_NON_LAZY_SYMBOL_POINTERS, nl_symbol_ptr_section_fixup)\n+        |];\n+\n+      macho_segment_command \"__DWARF\" dwarf_segment_fixup\n+        [VM_PROT_READ]\n+        [VM_PROT_READ]\n+        [|\n+          (\"__debug_info\", data_sect_align_log2, [],\n+           S_REGULAR, sem.Semant.ctxt_debug_info_fixup);\n+          (\"__debug_abbrev\", data_sect_align_log2, [],\n+           S_REGULAR, sem.Semant.ctxt_debug_abbrev_fixup);\n+        |];\n+\n+      macho_segment_command \"__LINKEDIT\" linkedit_segment_fixup\n+        [VM_PROT_READ]\n+        [VM_PROT_READ]\n+        [|\n+        |];\n+\n+      macho_symtab_command\n+        symtab_fixup (Int64.of_int (Array.length symbols)) strtab_fixup;\n+\n+\n+      macho_dysymtab_command\n+        0L\n+        (Int64.of_int n_local_syms)\n+        (Int64.of_int n_local_syms)\n+        (Int64.of_int n_export_syms)\n+        (Int64.of_int (n_local_syms + n_export_syms))\n+        (Int64.of_int n_undef_syms)\n+        indirect_symtab_fixup;\n+\n+      macho_dylinker_command;\n+\n+      macho_dylib_command \"librustrt.dylib\";\n+\n+      macho_dylib_command \"/usr/lib/libSystem.B.dylib\";\n+\n+      begin\n+        match start_fixup with\n+            None -> MARK\n+          | Some start_fixup ->\n+              macho_thread_command start_fixup\n+      end;\n+    |]\n+  in\n+\n+  let header_and_commands =\n+    macho_header_32\n+      CPU_TYPE_X86\n+      CPU_SUBTYPE_X86_ALL\n+      (if sess.Session.sess_library_mode then MH_DYLIB else MH_EXECUTE)\n+      [ MH_BINDATLOAD; MH_DYLDLINK; MH_TWOLEVEL ]\n+      load_commands\n+  in\n+\n+  let objfile_start e start_fixup rust_start_fixup main_fn_fixup =\n+    let edx = X86.h X86.edx in\n+    let edx_pointee =\n+      Il.Mem ((Il.RegIn (edx, None)), Il.ScalarTy (Il.AddrTy Il.OpaqueTy))\n+    in\n+      Il.emit_full e (Some start_fixup) [] Il.Dead;\n+\n+      (* zero marks the bottom of the frame chain. *)\n+      Il.emit e (Il.Push (X86.imm (Asm.IMM 0L)));\n+      Il.emit e (Il.umov (X86.rc X86.ebp) (X86.ro X86.esp));\n+\n+      (* 16-byte align stack for SSE. *)\n+      Il.emit e (Il.binary Il.AND (X86.rc X86.esp) (X86.ro X86.esp)\n+                   (X86.imm (Asm.IMM 0xfffffffffffffff0L)));\n+\n+      (* Store argv. *)\n+      Abi.load_fixup_addr e edx nxargv_fixup Il.OpaqueTy;\n+      Il.emit e (Il.lea (X86.rc X86.ecx)\n+                   (Il.Cell (Il.Mem ((Il.RegIn (Il.Hreg X86.ebp,\n+                                                Some (X86.word_off_n 2))),\n+                                     Il.OpaqueTy))));\n+      Il.emit e (Il.umov edx_pointee (X86.ro X86.ecx));\n+      Il.emit e (Il.Push (X86.ro X86.ecx));\n+\n+      (* Store argc. *)\n+      Abi.load_fixup_addr e edx nxargc_fixup Il.OpaqueTy;\n+      Il.emit e (Il.umov (X86.rc X86.eax)\n+                   (X86.c (X86.word_n (Il.Hreg X86.ebp) 1)));\n+      Il.emit e (Il.umov edx_pointee (X86.ro X86.eax));\n+      Il.emit e (Il.Push (X86.ro X86.eax));\n+\n+      (* Calculte and store envp. *)\n+      Il.emit e (Il.binary Il.ADD\n+                   (X86.rc X86.eax) (X86.ro X86.eax)\n+                   (X86.imm (Asm.IMM 1L)));\n+      Il.emit e (Il.binary Il.UMUL\n+                   (X86.rc X86.eax) (X86.ro X86.eax)\n+                   (X86.imm (Asm.IMM X86.word_sz)));\n+      Il.emit e (Il.binary Il.ADD (X86.rc X86.eax)\n+                   (X86.ro X86.eax) (X86.ro X86.ecx));\n+      Abi.load_fixup_addr e edx environ_fixup Il.OpaqueTy;\n+      Il.emit e (Il.umov edx_pointee (X86.ro X86.eax));\n+\n+      (* Push 16 bytes to preserve SSE alignment. *)\n+      Abi.load_fixup_addr e edx sem.Semant.ctxt_crate_fixup Il.OpaqueTy;\n+      Il.emit e (Il.Push (X86.ro X86.edx));\n+      Abi.load_fixup_addr e edx main_fn_fixup Il.OpaqueTy;\n+      Il.emit e (Il.Push (X86.ro X86.edx));\n+      let fptr = Abi.load_fixup_codeptr e edx rust_start_fixup true true in\n+        Il.emit e (Il.call (X86.rc X86.eax) fptr);\n+        Il.emit e (Il.Pop (X86.rc X86.ecx));\n+        Il.emit e (Il.Push (X86.ro X86.eax));\n+        let fptr = Abi.load_fixup_codeptr e edx exit_fixup true true in\n+          Il.emit e (Il.call (X86.rc X86.eax) fptr);\n+          Il.emit e (Il.Pop (X86.rc X86.ecx));\n+          Il.emit e (Il.Pop (X86.rc X86.ecx));\n+          Il.emit e (Il.Pop (X86.rc X86.ecx));\n+          Il.emit e (Il.Pop (X86.rc X86.ecx));\n+\n+          Il.emit e Il.Ret;\n+  in\n+\n+  let text_section =\n+    let start_code =\n+      match (start_fixup, rust_start_fixup,\n+             sem.Semant.ctxt_main_fn_fixup) with\n+          (None, _, _)\n+        | (_, None, _)\n+        | (_, _, None) -> MARK\n+        | (Some start_fixup,\n+           Some rust_start_fixup,\n+           Some main_fn_fixup) ->\n+            let e = X86.new_emitter_without_vregs () in\n+              objfile_start e start_fixup rust_start_fixup main_fn_fixup;\n+              X86.frags_of_emitted_quads sess e\n+    in\n+      def_aligned text_sect_align text_section_fixup\n+        (SEQ [|\n+           start_code;\n+           code\n+         |])\n+  in\n+\n+  let text_segment =\n+      def_aligned seg_align text_segment_fixup\n+        (SEQ [|\n+           DEF (mh_execute_header_fixup, header_and_commands);\n+           text_section;\n+           align_both seg_align MARK;\n+         |]);\n+  in\n+\n+  let zero_segment = align_both seg_align\n+    (SEQ [| MEMPOS 0L; DEF (zero_segment_fixup,\n+                            SEQ [| MEMPOS 0x1000L; MARK |] ) |])\n+  in\n+\n+  let data_segment = def_aligned seg_align data_segment_fixup\n+    (SEQ [|\n+       DEF(nxargc_fixup, WORD (TY_u32, IMM 0L));\n+       DEF(nxargv_fixup, WORD (TY_u32, IMM 0L));\n+       DEF(environ_fixup, WORD (TY_u32, IMM 0L));\n+       DEF(progname_fixup, WORD (TY_u32, IMM 0L));\n+       data_section;\n+       const_section;\n+       bss_section;\n+       note_rust_section;\n+       nl_symbol_ptr_section\n+     |])\n+  in\n+\n+  let dwarf_segment = def_aligned seg_align dwarf_segment_fixup\n+    (SEQ [|\n+       debug_info_section;\n+       debug_abbrev_section;\n+     |])\n+  in\n+\n+  let linkedit_segment = def_aligned seg_align linkedit_segment_fixup\n+    (SEQ [|\n+       symtab;\n+       strtab;\n+       indirect_symtab;\n+     |])\n+  in\n+\n+  let segments =\n+    SEQ [|\n+      DEF (sem.Semant.ctxt_image_base_fixup, MARK);\n+      zero_segment;\n+      text_segment;\n+      data_segment;\n+      dwarf_segment;\n+      linkedit_segment;\n+    |]\n+  in\n+    write_out_frag sess true segments\n+;;\n+\n+\n+let sniff\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : asm_reader option =\n+  try\n+    let stat = Unix.stat filename in\n+    if (stat.Unix.st_kind = Unix.S_REG) &&\n+      (stat.Unix.st_size > 4)\n+    then\n+      let ar = new_asm_reader sess filename in\n+      let _ = log sess \"sniffing Mach-O file\" in\n+        if (ar.asm_get_u32()) = (Int64.to_int mh_magic)\n+        then (ar.asm_seek 0; Some ar)\n+        else None\n+    else\n+      None\n+  with\n+      _ -> None\n+;;\n+\n+let get_sections\n+    (sess:Session.sess)\n+    (ar:asm_reader)\n+    : (string,(int*int)) Hashtbl.t =\n+  let sects = Hashtbl.create 0 in\n+  let _ = log sess \"reading sections\" in\n+  let magic = ar.asm_get_u32() in\n+  let _ = assert (magic = (Int64.to_int mh_magic)) in\n+  let _ = ar.asm_adv_u32() in (* cpu type *)\n+  let _ = ar.asm_adv_u32() in (* cpu subtype *)\n+  let _ = ar.asm_adv_u32() in (* file type *)\n+  let n_load_cmds = ar.asm_get_u32() in\n+  let _ = ar.asm_adv_u32() in\n+  let _ = log sess \"Mach-o file with %d load commands\" n_load_cmds in\n+  let _ = ar.asm_adv_u32() in (* flags *)\n+  let lc_seg = Int64.to_int (load_command_code LC_SEGMENT) in\n+    for i = 0 to n_load_cmds - 1 do\n+      let load_cmd_code = ar.asm_get_u32() in\n+      let load_cmd_size = ar.asm_get_u32() in\n+      let _ = log sess \"load command %d:\" i in\n+        if load_cmd_code != lc_seg\n+        then ar.asm_adv (load_cmd_size - 8)\n+        else\n+          begin\n+            let seg_name = ar.asm_get_zstr_padded 16 in\n+            let _ = log sess \"LC_SEGMENT %s\" seg_name in\n+            let _ = ar.asm_adv_u32() in (* seg mem pos *)\n+            let _ = ar.asm_adv_u32() in (* seg mem sz *)\n+            let _ = ar.asm_adv_u32() in (* seg file pos *)\n+            let _ = ar.asm_adv_u32() in (* seg file sz *)\n+            let _ = ar.asm_adv_u32() in (* maxprot *)\n+            let _ = ar.asm_adv_u32() in (* initprot *)\n+            let n_sects = ar.asm_get_u32() in\n+            let _ = ar.asm_get_u32() in (* flags *)\n+            let _ = log sess \"%d sections\" in\n+              for j = 0 to n_sects - 1 do\n+                let sect_name = ar.asm_get_zstr_padded 16 in\n+                let _ = ar.asm_adv 16 in (* seg name *)\n+                let _ = ar.asm_adv_u32() in (* sect mem pos *)\n+                let m_sz = ar.asm_get_u32() in\n+                let f_pos = ar.asm_get_u32() in\n+                let _ = ar.asm_adv_u32() in (* sect align *)\n+                let _ = ar.asm_adv_u32() in (* reloff *)\n+                let _ = ar.asm_adv_u32() in (* nreloc *)\n+                let _ = ar.asm_adv_u32() in (* flags *)\n+                let _ = ar.asm_adv_u32() in (* reserved1 *)\n+                let _ = ar.asm_adv_u32() in (* reserved2 *)\n+                let _ =\n+                  log sess\n+                    \"  section %d: 0x%x - 0x%x %s \"\n+                    j f_pos (f_pos + m_sz) sect_name\n+                in\n+                let len = String.length sect_name in\n+                let sect_name =\n+                  if (len > 2\n+                      && sect_name.[0] = '_'\n+                      && sect_name.[1] = '_')\n+                  then \".\" ^ (String.sub sect_name 2 (len-2))\n+                  else sect_name\n+                in\n+                  Hashtbl.add sects sect_name (f_pos, m_sz)\n+              done\n+          end\n+    done;\n+    sects\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "d360ddf5a386a32aa50c133422190e859f567fb8", "filename": "src/boot/be/pe.ml", "status": "added", "additions": 1149, "deletions": 0, "changes": 1149, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fpe.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fpe.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fpe.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1149 @@\n+(*\n+\n+   Module for writing Microsoft PE files\n+\n+   Every image has a base address it's to be loaded at.\n+\n+   \"file pointer\" = offset in file\n+\n+   \"VA\" = address at runtime\n+\n+   \"RVA\" = VA - base address\n+\n+   If you write a non-RVA absolute address at any point you must put it\n+   in a rebasing list so the loader can adjust it when/if it has to load\n+   you at a different address.\n+\n+   Almost all addresses in the file are RVAs. Worry about the VAs.\n+\n+*)\n+\n+open Asm;;\n+open Common;;\n+\n+let log (sess:Session.sess) =\n+  Session.log \"obj (pe)\"\n+    sess.Session.sess_log_obj\n+    sess.Session.sess_log_out\n+;;\n+\n+let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n+  if sess.Session.sess_log_obj\n+  then thunk ()\n+  else ()\n+;;\n+\n+(*\n+\n+   The default image base (VA) for an executable on Win32 is 0x400000.\n+\n+   We use this too. RVAs are relative to this. RVA 0 = VA 0x400000.\n+\n+   Alignments are also relatively standard and fixed for Win32/PE32:\n+   4k memory pages, 512 byte disk sectors.\n+\n+   Since this is a stupid emitter, and we're not generating an awful\n+   lot of sections, we are not going to differentiate between these\n+   two kinds of alignment: we just align our sections to memory pages\n+   and sometimes waste most of them. Shucks.\n+\n+*)\n+\n+let pe_image_base = 0x400000L;;\n+let pe_file_alignment = 0x200;;\n+let pe_mem_alignment = 0x1000;;\n+\n+let rva (f:fixup) = (SUB ((M_POS f), (IMM pe_image_base)));;\n+\n+let def_file_aligned f i =\n+  ALIGN_FILE\n+    (pe_file_alignment,\n+     SEQ [|\n+       DEF(f,\n+           SEQ [| i;\n+                  ALIGN_FILE\n+                    (pe_file_alignment, MARK) |]) |] )\n+;;\n+\n+let def_mem_aligned f i =\n+  ALIGN_MEM\n+    (pe_mem_alignment,\n+     SEQ [|\n+       DEF(f,\n+           SEQ [| i;\n+                  ALIGN_MEM\n+                    (pe_mem_alignment, MARK) |]) |] )\n+;;\n+\n+let align_both i =\n+  ALIGN_FILE (pe_file_alignment,\n+              (ALIGN_MEM (pe_mem_alignment, i)))\n+;;\n+\n+let def_aligned f i =\n+  align_both\n+    (SEQ [| DEF(f,i);\n+            (align_both MARK)|])\n+;;\n+\n+\n+(*\n+\n+  At the beginning of a PE file there is an MS-DOS stub, 0x00 - 0x7F,\n+  that we just insert literally. It prints \"This program must be run\n+  under Win32\" and exits. Woo!\n+\n+  Within it, at offset 0x3C, there is an encoded offset of the PE\n+  header we actually care about. So 0x3C - 0x3F are 0x00000100 (LE)\n+  which say \"the PE header is actually at 0x100\", a nice sensible spot\n+  for it. We pad the next 128 bytes out to 0x100 and start there for\n+  real.\n+\n+  From then on in it's a sensible object file. Here's the MS-DOS bit.\n+*)\n+\n+let pe_msdos_header_and_padding\n+    : frag =\n+  SEQ [|\n+    BYTES\n+      [|\n+        (* 00000000 *)\n+        0x4d; 0x5a; 0x50; 0x00; 0x02; 0x00; 0x00; 0x00;\n+        0x04; 0x00; 0x0f; 0x00; 0xff; 0xff; 0x00; 0x00;\n+\n+        (* 00000010 *)\n+        0xb8; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n+        0x40; 0x00; 0x1a; 0x00; 0x00; 0x00; 0x00; 0x00;\n+\n+        (* 00000020 *)\n+        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n+        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n+\n+        (* 00000030 *)\n+        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n+        0x00; 0x00; 0x00; 0x00; 0x00; 0x01; 0x00; 0x00;\n+        (*                      ^^^^PE HDR offset^^^^^ *)\n+\n+        (* 00000040 *)\n+        0xba; 0x10; 0x00; 0x0e; 0x1f; 0xb4; 0x09; 0xcd;\n+        0x21; 0xb8; 0x01; 0x4c; 0xcd; 0x21; 0x90; 0x90;\n+\n+        (* 00000050 *)\n+        0x54; 0x68; 0x69; 0x73; 0x20; 0x70; 0x72; 0x6f;  (* \"This pro\" *)\n+        0x67; 0x72; 0x61; 0x6d; 0x20; 0x6d; 0x75; 0x73;  (* \"gram mus\" *)\n+\n+        (* 00000060 *)\n+        0x74; 0x20; 0x62; 0x65; 0x20; 0x72; 0x75; 0x6e;  (* \"t be run\" *)\n+        0x20; 0x75; 0x6e; 0x64; 0x65; 0x72; 0x20; 0x57;  (* \" under W\" *)\n+\n+        (* 00000070 *)\n+        0x69; 0x6e; 0x33; 0x32; 0x0d; 0x0a; 0x24; 0x37;  (* \"in32\\r\\n\" *)\n+        0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00; 0x00;\n+      |];\n+    PAD 0x80\n+  |]\n+;;\n+\n+(*\n+  A work of art, is it not? Take a moment to appreciate the madness.\n+\n+  All done? Ok, now on to the PE header proper.\n+\n+  PE headers are just COFF headers with a little preamble.\n+*)\n+\n+type pe_machine =\n+    (* Maybe support more later. *)\n+    IMAGE_FILE_MACHINE_AMD64\n+  | IMAGE_FILE_MACHINE_I386\n+;;\n+\n+\n+let pe_timestamp _ =\n+  Int64.of_float (Unix.gettimeofday())\n+;;\n+\n+\n+type pe_characteristics =\n+    (* Maybe support more later. *)\n+    IMAGE_FILE_RELOCS_STRIPPED\n+  | IMAGE_FILE_EXECUTABLE_IMAGE\n+  | IMAGE_FILE_LINE_NUMS_STRIPPED\n+  | IMAGE_FILE_LOCAL_SYMS_STRIPPED\n+  | IMAGE_FILE_32BIT_MACHINE\n+  | IMAGE_FILE_DEBUG_STRIPPED\n+  | IMAGE_FILE_DLL\n+;;\n+\n+\n+let pe_header\n+    ~(machine:pe_machine)\n+    ~(symbol_table_fixup:fixup)\n+    ~(number_of_sections:int64)\n+    ~(number_of_symbols:int64)\n+    ~(loader_hdr_fixup:fixup)\n+    ~(characteristics:pe_characteristics list)\n+    : frag =\n+  ALIGN_FILE\n+    (8,\n+     SEQ [|\n+       STRING \"PE\\x00\\x00\";\n+       WORD (TY_u16, (IMM (match machine with\n+                               IMAGE_FILE_MACHINE_AMD64 -> 0x8664L\n+                             | IMAGE_FILE_MACHINE_I386 -> 0x014cL)));\n+       WORD (TY_u16, (IMM number_of_sections));\n+       WORD (TY_u32, (IMM (pe_timestamp())));\n+       WORD (TY_u32, (F_POS symbol_table_fixup));\n+       WORD (TY_u32, (IMM number_of_symbols));\n+       WORD (TY_u16, (F_SZ loader_hdr_fixup));\n+       WORD (TY_u16, (IMM (fold_flags\n+                      (fun c -> match c with\n+                           IMAGE_FILE_RELOCS_STRIPPED -> 0x1L\n+                         | IMAGE_FILE_EXECUTABLE_IMAGE -> 0x2L\n+                         | IMAGE_FILE_LINE_NUMS_STRIPPED -> 0x4L\n+                         | IMAGE_FILE_LOCAL_SYMS_STRIPPED -> 0x8L\n+                         | IMAGE_FILE_32BIT_MACHINE -> 0x100L\n+                         | IMAGE_FILE_DEBUG_STRIPPED -> 0x200L\n+                         | IMAGE_FILE_DLL -> 0x2000L)\n+                      characteristics)))\n+     |])\n+;;\n+\n+(*\n+\n+   After the PE header comes an \"optional\" header for the loader. In\n+   our case this is hardly optional since we are producing a file for\n+   the loader.\n+\n+*)\n+\n+type pe_subsystem =\n+    (* Maybe support more later. *)\n+    IMAGE_SUBSYSTEM_WINDOWS_GUI\n+  | IMAGE_SUBSYSTEM_WINDOWS_CUI\n+;;\n+\n+let zero32 = WORD (TY_u32, (IMM 0L))\n+;;\n+\n+let pe_loader_header\n+    ~(text_fixup:fixup)\n+    ~(init_data_fixup:fixup)\n+    ~(size_of_uninit_data:int64)\n+    ~(entry_point_fixup:fixup option)\n+    ~(image_fixup:fixup)\n+    ~(all_hdrs_fixup:fixup)\n+    ~(subsys:pe_subsystem)\n+    ~(loader_hdr_fixup:fixup)\n+    ~(import_dir_fixup:fixup)\n+    ~(export_dir_fixup:fixup)\n+    : frag =\n+  DEF\n+    (loader_hdr_fixup,\n+     SEQ [|\n+       WORD (TY_u16, (IMM 0x10bL));          (* COFF magic tag for PE32.  *)\n+       (* Snagged *)\n+       WORD (TY_u8, (IMM 0x2L));             (* Linker major version.     *)\n+       WORD (TY_u8, (IMM 0x38L));            (* Linker minor version.     *)\n+\n+       WORD (TY_u32, (F_SZ text_fixup));     (* \"size of code\"            *)\n+       WORD (TY_u32,                         (* \"size of all init data\"   *)\n+             (F_SZ init_data_fixup));\n+       WORD (TY_u32,\n+             (IMM size_of_uninit_data));\n+\n+       begin\n+         match entry_point_fixup with\n+             None -> zero32                  (* Library mode: DLLMain     *)\n+           | Some entry_point_fixup ->\n+               WORD (TY_u32,\n+                     (rva\n+                        entry_point_fixup))  (* \"address of entry point\"  *)\n+       end;\n+\n+       WORD (TY_u32, (rva text_fixup));      (* \"base of code\"            *)\n+       WORD (TY_u32, (rva init_data_fixup)); (* \"base of data\"            *)\n+       WORD (TY_u32, (IMM pe_image_base));\n+       WORD (TY_u32, (IMM (Int64.of_int\n+                      pe_mem_alignment)));\n+       WORD (TY_u32, (IMM (Int64.of_int\n+                      pe_file_alignment)));\n+\n+       WORD (TY_u16, (IMM 4L));             (* Major OS version: NT4.     *)\n+       WORD (TY_u16, (IMM 0L));             (* Minor OS version.          *)\n+       WORD (TY_u16, (IMM 1L));             (* Major image version.       *)\n+       WORD (TY_u16, (IMM 0L));             (* Minor image version.       *)\n+       WORD (TY_u16, (IMM 4L));             (* Major subsystem version.   *)\n+       WORD (TY_u16, (IMM 0L));             (* Minor subsystem version.   *)\n+\n+       zero32;                              (* Reserved.                  *)\n+\n+       WORD (TY_u32, (M_SZ image_fixup));\n+       WORD (TY_u32, (M_SZ all_hdrs_fixup));\n+\n+       zero32;                              (* Checksum, but OK if zero.  *)\n+       WORD (TY_u16, (IMM (match subsys with\n+                        IMAGE_SUBSYSTEM_WINDOWS_GUI -> 2L\n+                      | IMAGE_SUBSYSTEM_WINDOWS_CUI -> 3L)));\n+\n+       WORD (TY_u16, (IMM 0L));             (* DLL characteristics.       *)\n+\n+       WORD (TY_u32, (IMM 0x100000L));      (* Size of stack reserve.     *)\n+       WORD (TY_u32, (IMM 0x4000L));        (* Size of stack commit.      *)\n+\n+       WORD (TY_u32, (IMM 0x100000L));      (* Size of heap reserve.      *)\n+       WORD (TY_u32, (IMM 0x1000L));        (* Size of heap commit.       *)\n+\n+       zero32;                              (* Reserved.                  *)\n+       WORD (TY_u32, (IMM 16L));            (* Number of dir references.  *)\n+\n+       (* Begin directories, variable part of hdr.        *)\n+\n+       (*\n+\n+         Standard PE files have ~10 directories referenced from\n+         here. We only fill in two of them -- the export/import\n+         directories -- because we don't care about the others. We\n+         leave the rest as zero in case someone is looking for\n+         them. This may be superfluous or wrong.\n+\n+       *)\n+\n+\n+       WORD (TY_u32, (rva export_dir_fixup));\n+       WORD (TY_u32, (M_SZ export_dir_fixup));\n+\n+       WORD (TY_u32, (rva import_dir_fixup));\n+       WORD (TY_u32, (M_SZ import_dir_fixup));\n+\n+       zero32; zero32;    (* Resource dir.      *)\n+       zero32; zero32;    (* Exception dir.     *)\n+       zero32; zero32;    (* Security dir.      *)\n+       zero32; zero32;    (* Base reloc dir.    *)\n+       zero32; zero32;    (* Debug dir.         *)\n+       zero32; zero32;    (* Image desc dir.    *)\n+       zero32; zero32;    (* Mach spec dir.     *)\n+       zero32; zero32;    (* TLS dir.           *)\n+\n+       zero32; zero32;    (* Load config.       *)\n+       zero32; zero32;    (* Bound import.      *)\n+       zero32; zero32;    (* IAT                *)\n+       zero32; zero32;    (* Delay import.      *)\n+       zero32; zero32;    (* COM descriptor     *)\n+       zero32; zero32;    (* ????????           *)\n+     |])\n+\n+;;\n+\n+\n+type pe_section_id =\n+    (* Maybe support more later. *)\n+    SECTION_ID_TEXT\n+  | SECTION_ID_DATA\n+  | SECTION_ID_RDATA\n+  | SECTION_ID_BSS\n+  | SECTION_ID_IMPORTS\n+  | SECTION_ID_EXPORTS\n+  | SECTION_ID_DEBUG_ARANGES\n+  | SECTION_ID_DEBUG_PUBNAMES\n+  | SECTION_ID_DEBUG_INFO\n+  | SECTION_ID_DEBUG_ABBREV\n+  | SECTION_ID_DEBUG_LINE\n+  | SECTION_ID_DEBUG_FRAME\n+  | SECTION_ID_NOTE_RUST\n+;;\n+\n+type pe_section_characteristics =\n+    (* Maybe support more later. *)\n+    IMAGE_SCN_CNT_CODE\n+  | IMAGE_SCN_CNT_INITIALIZED_DATA\n+  | IMAGE_SCN_CNT_UNINITIALIZED_DATA\n+  | IMAGE_SCN_MEM_DISCARDABLE\n+  | IMAGE_SCN_MEM_SHARED\n+  | IMAGE_SCN_MEM_EXECUTE\n+  | IMAGE_SCN_MEM_READ\n+  | IMAGE_SCN_MEM_WRITE\n+\n+let pe_section_header\n+    ~(id:pe_section_id)\n+    ~(hdr_fixup:fixup)\n+    : frag =\n+  let\n+      characteristics =\n+    match id with\n+        SECTION_ID_TEXT -> [ IMAGE_SCN_CNT_CODE;\n+                             IMAGE_SCN_MEM_READ;\n+                             IMAGE_SCN_MEM_EXECUTE ]\n+      | SECTION_ID_DATA -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n+                             IMAGE_SCN_MEM_READ;\n+                             IMAGE_SCN_MEM_WRITE ]\n+      | SECTION_ID_BSS -> [ IMAGE_SCN_CNT_UNINITIALIZED_DATA;\n+                            IMAGE_SCN_MEM_READ;\n+                            IMAGE_SCN_MEM_WRITE ]\n+      | SECTION_ID_IMPORTS -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n+                                IMAGE_SCN_MEM_READ;\n+                                IMAGE_SCN_MEM_WRITE ]\n+      | SECTION_ID_EXPORTS -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n+                                IMAGE_SCN_MEM_READ ]\n+      | SECTION_ID_RDATA\n+      | SECTION_ID_DEBUG_ARANGES\n+      | SECTION_ID_DEBUG_PUBNAMES\n+      | SECTION_ID_DEBUG_INFO\n+      | SECTION_ID_DEBUG_ABBREV\n+      | SECTION_ID_DEBUG_LINE\n+      | SECTION_ID_DEBUG_FRAME\n+      | SECTION_ID_NOTE_RUST -> [ IMAGE_SCN_CNT_INITIALIZED_DATA;\n+                                  IMAGE_SCN_MEM_READ ]\n+  in\n+    SEQ [|\n+      STRING\n+        begin\n+          match id with\n+              SECTION_ID_TEXT -> \".text\\x00\\x00\\x00\"\n+            | SECTION_ID_DATA -> \".data\\x00\\x00\\x00\"\n+            | SECTION_ID_RDATA -> \".rdata\\x00\\x00\"\n+            | SECTION_ID_BSS -> \".bss\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_IMPORTS -> \".idata\\x00\\x00\"\n+            | SECTION_ID_EXPORTS -> \".edata\\x00\\x00\"\n+\n+            (* There is a bizarre Microsoft COFF extension to account\n+             * for longer-than-8-char section names: you emit a single\n+             * '/' character then the ASCII-numeric encoding of the\n+             * offset within the file's string table of the full name.\n+             * So we put all our extended section names at the\n+             * beginning of the string table in a very specific order\n+             * and hard-wire the offsets as \"names\" here. You could\n+             * theoretically extend this to a \"new kind\" of fixup\n+             * reference (ASCII_POS or such), if you feel this is\n+             * something you want to twiddle with.\n+             *)\n+\n+            | SECTION_ID_DEBUG_ARANGES  -> \"/4\\x00\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_DEBUG_PUBNAMES -> \"/19\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_DEBUG_INFO     -> \"/35\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_DEBUG_ABBREV   -> \"/47\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_DEBUG_LINE     -> \"/61\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_DEBUG_FRAME    -> \"/73\\x00\\x00\\x00\\x00\\x00\"\n+            | SECTION_ID_NOTE_RUST      -> \"/86\\x00\\x00\\x00\\x00\\x00\"\n+        end;\n+\n+      (* The next two pairs are only supposed to be different if the\n+         file and section alignments differ. This is a stupid emitter\n+         so they're not, no problem. *)\n+\n+      WORD (TY_u32, (M_SZ hdr_fixup));  (* \"Virtual size\"    *)\n+      WORD (TY_u32, (rva hdr_fixup));   (* \"Virtual address\" *)\n+\n+      WORD (TY_u32, (F_SZ hdr_fixup));  (* \"Size of raw data\"    *)\n+      WORD (TY_u32, (F_POS hdr_fixup)); (* \"Pointer to raw data\" *)\n+\n+      zero32;      (* Reserved. *)\n+      zero32;      (* Reserved. *)\n+      zero32;      (* Reserved. *)\n+\n+      WORD (TY_u32, (IMM (fold_flags\n+                     (fun c -> match c with\n+                          IMAGE_SCN_CNT_CODE -> 0x20L\n+                        | IMAGE_SCN_CNT_INITIALIZED_DATA -> 0x40L\n+                        | IMAGE_SCN_CNT_UNINITIALIZED_DATA -> 0x80L\n+                        | IMAGE_SCN_MEM_DISCARDABLE -> 0x2000000L\n+                        | IMAGE_SCN_MEM_SHARED -> 0x10000000L\n+                        | IMAGE_SCN_MEM_EXECUTE -> 0x20000000L\n+                        | IMAGE_SCN_MEM_READ -> 0x40000000L\n+                        | IMAGE_SCN_MEM_WRITE -> 0x80000000L)\n+                     characteristics)))\n+    |]\n+;;\n+\n+\n+(*\n+\n+   \"Thunk\" is a misnomer here; the thunk RVA is the address of a word\n+   that the loader will store an address into. The stored address is\n+   the address of the imported object.\n+\n+   So if the imported object is X, and the thunk slot is Y, the loader\n+   is doing \"Y = &X\" and returning &Y as the thunk RVA. To load datum X\n+   after the imports are resolved, given the thunk RVA R, you load\n+   **R.\n+\n+*)\n+\n+type pe_import =\n+    {\n+      pe_import_name_fixup: fixup;\n+      pe_import_name: string;\n+      pe_import_address_fixup: fixup;\n+    }\n+\n+type pe_import_dll_entry =\n+    {\n+      pe_import_dll_name_fixup: fixup;\n+      pe_import_dll_name: string;\n+      pe_import_dll_ILT_fixup: fixup;\n+      pe_import_dll_IAT_fixup: fixup;\n+      pe_import_dll_imports: pe_import array;\n+    }\n+\n+  (*\n+\n+     The import section .idata has a mostly self-contained table\n+     structure. You feed it a list of DLL entries, each of which names\n+     a DLL and lists symbols in the DLL to import.\n+\n+     For each named symbol, a 4-byte slot will be reserved in an\n+     \"import lookup table\" (ILT, also in this section). The slot is\n+     a pointer to a string in this section giving the name.\n+\n+     Immediately *after* the ILT, there is an \"import address table\" (IAT),\n+     which is initially identical to the ILT. The loader replaces the entries\n+     in the IAT slots with the imported pointers at runtime.\n+\n+     A central directory at the start of the section lists all the the import\n+     thunk tables. Each entry in the import directory is 20 bytes (5 words)\n+     but only the last 2 are used: the second last is a pointer to the string\n+     name of the DLL in question (string also in this section) and the last is\n+     a pointer to the import thunk table itself (also in this section).\n+\n+     Curiously, of the 5 documents I've consulted on the nature of the\n+     first 3 fields, I find a variety of interpretations.\n+\n+  *)\n+\n+let pe_import_section\n+    ~(import_dir_fixup:fixup)\n+    ~(dlls:pe_import_dll_entry array)\n+    : frag =\n+\n+  let form_dir_entry\n+      (entry:pe_import_dll_entry)\n+      : frag =\n+    SEQ [|\n+      (* Note: documented opinions vary greatly about whether the\n+         first, last, or both of the slots in one of these rows points\n+         to the RVA of the name/hint used to look the import up. This\n+         table format is a mess!  *)\n+      WORD (TY_u32,\n+            (rva\n+               entry.pe_import_dll_ILT_fixup)); (* Import lookup table. *)\n+      WORD (TY_u32, (IMM 0L));                  (* Timestamp, unused.   *)\n+      WORD (TY_u32, (IMM 0x0L));                (* Forwarder chain, unused. *)\n+      WORD (TY_u32, (rva entry.pe_import_dll_name_fixup));\n+      WORD (TY_u32,\n+            (rva\n+               entry.pe_import_dll_IAT_fixup)); (* Import address table.*)\n+    |]\n+  in\n+\n+  let form_ILT_slot\n+      (import:pe_import)\n+      : frag =\n+    (WORD (TY_u32, (rva import.pe_import_name_fixup)))\n+  in\n+\n+  let form_IAT_slot\n+      (import:pe_import)\n+      : frag =\n+    (DEF (import.pe_import_address_fixup,\n+          (WORD (TY_u32, (rva import.pe_import_name_fixup)))))\n+  in\n+\n+  let form_tables_for_dll\n+      (dll:pe_import_dll_entry)\n+      : frag =\n+    let terminator = WORD (TY_u32, (IMM 0L)) in\n+    let ilt =\n+      SEQ [|\n+        SEQ (Array.map form_ILT_slot dll.pe_import_dll_imports);\n+        terminator\n+      |]\n+    in\n+    let iat =\n+      SEQ [|\n+        SEQ (Array.map form_IAT_slot dll.pe_import_dll_imports);\n+        terminator\n+      |]\n+    in\n+      if Array.length dll.pe_import_dll_imports < 1\n+      then bug () \"Pe.form_tables_for_dll: empty imports\"\n+      else\n+        SEQ [|\n+          DEF (dll.pe_import_dll_ILT_fixup, ilt);\n+          DEF (dll.pe_import_dll_IAT_fixup, iat)\n+        |]\n+\n+  in\n+\n+  let form_import_string\n+      (import:pe_import)\n+      : frag =\n+    DEF\n+      (import.pe_import_name_fixup,\n+       SEQ [|\n+         (* import string entries begin with a 2-byte \"hint\", but we just\n+            set it to zero.  *)\n+         (WORD (TY_u16, (IMM 0L)));\n+         ZSTRING import.pe_import_name;\n+         (if String.length import.pe_import_name mod 2 == 0\n+          then PAD 1\n+          else PAD 0)\n+       |])\n+  in\n+\n+  let form_dir_entry_string\n+      (dll:pe_import_dll_entry)\n+      : frag =\n+    DEF\n+      (dll.pe_import_dll_name_fixup,\n+       SEQ [| ZSTRING dll.pe_import_dll_name;\n+              (if String.length dll.pe_import_dll_name mod 2 == 0\n+               then PAD 1\n+               else PAD 0);\n+              SEQ (Array.map form_import_string dll.pe_import_dll_imports) |])\n+  in\n+\n+  let dir = SEQ (Array.map form_dir_entry dlls) in\n+  let dir_terminator = PAD 20 in\n+  let tables = SEQ (Array.map form_tables_for_dll dlls) in\n+  let strings = SEQ (Array.map form_dir_entry_string dlls)\n+  in\n+    def_aligned\n+      import_dir_fixup\n+      (SEQ\n+         [|\n+           dir;\n+           dir_terminator;\n+           tables;\n+           strings\n+         |])\n+\n+;;\n+\n+type pe_export =\n+    {\n+      pe_export_name_fixup: fixup;\n+      pe_export_name: string;\n+      pe_export_address_fixup: fixup;\n+    }\n+;;\n+\n+let pe_export_section\n+    ~(sess:Session.sess)\n+    ~(export_dir_fixup:fixup)\n+    ~(exports:pe_export array)\n+    : frag =\n+  Array.sort (fun a b -> compare a.pe_export_name b.pe_export_name) exports;\n+  let export_addr_table_fixup = new_fixup \"export address table\" in\n+  let export_addr_table =\n+    DEF\n+      (export_addr_table_fixup,\n+       SEQ\n+         (Array.map\n+            (fun e -> (WORD (TY_u32, rva e.pe_export_address_fixup)))\n+            exports))\n+  in\n+  let export_name_pointer_table_fixup =\n+      new_fixup \"export name pointer table\"\n+  in\n+  let export_name_pointer_table =\n+    DEF\n+      (export_name_pointer_table_fixup,\n+       SEQ\n+         (Array.map\n+            (fun e -> (WORD (TY_u32, rva e.pe_export_name_fixup)))\n+            exports))\n+  in\n+  let export_name_table_fixup = new_fixup \"export name table\" in\n+  let export_name_table =\n+    DEF\n+      (export_name_table_fixup,\n+       SEQ\n+         (Array.map\n+            (fun e -> (DEF (e.pe_export_name_fixup,\n+                            (ZSTRING e.pe_export_name))))\n+            exports))\n+  in\n+  let export_ordinal_table_fixup = new_fixup \"export ordinal table\" in\n+  let export_ordinal_table =\n+    DEF\n+      (export_ordinal_table_fixup,\n+       SEQ\n+         (Array.mapi\n+            (fun i _ -> (WORD (TY_u16, IMM (Int64.of_int (i)))))\n+            exports))\n+  in\n+  let image_name_fixup = new_fixup \"image name fixup\" in\n+  let n_exports = IMM (Int64.of_int (Array.length exports)) in\n+  let export_dir_table =\n+    SEQ [|\n+      WORD (TY_u32, IMM 0L);               (* Flags, reserved.    *)\n+      WORD (TY_u32, IMM 0L);               (* Timestamp, unused.  *)\n+      WORD (TY_u16, IMM 0L);               (* Major vers., unused *)\n+      WORD (TY_u16, IMM 0L);               (* Minor vers., unused *)\n+      WORD (TY_u32, rva image_name_fixup); (* Name RVA.           *)\n+      WORD (TY_u32, IMM 1L);               (* Ordinal base = 1.   *)\n+      WORD (TY_u32, n_exports);          (* # entries in EAT.     *)\n+      WORD (TY_u32, n_exports);          (* # entries in ENPT/EOT.*)\n+      WORD (TY_u32, rva export_addr_table_fixup);         (* EAT  *)\n+      WORD (TY_u32, rva export_name_pointer_table_fixup); (* ENPT *)\n+      WORD (TY_u32, rva export_ordinal_table_fixup);      (* EOT  *)\n+    |]\n+  in\n+    def_aligned export_dir_fixup\n+      (SEQ [|\n+         export_dir_table;\n+         export_addr_table;\n+         export_name_pointer_table;\n+         export_ordinal_table;\n+         DEF (image_name_fixup,\n+              ZSTRING (Session.filename_of sess.Session.sess_out));\n+         export_name_table\n+       |])\n+;;\n+\n+let pe_text_section\n+    ~(sess:Session.sess)\n+    ~(sem:Semant.ctxt)\n+    ~(start_fixup:fixup option)\n+    ~(rust_start_fixup:fixup option)\n+    ~(main_fn_fixup:fixup option)\n+    ~(text_fixup:fixup)\n+    ~(crate_code:frag)\n+    : frag =\n+  let startup =\n+    match (start_fixup, rust_start_fixup, main_fn_fixup) with\n+        (None, _, _)\n+      | (_, None, _)\n+      | (_, _, None) -> MARK\n+      | (Some start_fixup,\n+         Some rust_start_fixup,\n+         Some main_fn_fixup) ->\n+          let e = X86.new_emitter_without_vregs () in\n+            (*\n+             * We are called from the Microsoft C library startup routine,\n+             * and assumed to be stdcall; so we have to clean up our own\n+             * stack before returning.\n+             *)\n+            X86.objfile_start e\n+              ~start_fixup\n+              ~rust_start_fixup\n+              ~main_fn_fixup\n+              ~crate_fixup: sem.Semant.ctxt_crate_fixup\n+              ~indirect_start: true;\n+            X86.frags_of_emitted_quads sess e;\n+  in\n+    def_aligned\n+      text_fixup\n+      (SEQ [|\n+         startup;\n+         crate_code\n+       |])\n+;;\n+\n+let rustrt_imports sem =\n+  let make_imports_for_lib (lib, tab) =\n+    {\n+      pe_import_dll_name_fixup = new_fixup \"dll name\";\n+      pe_import_dll_name = (match lib with\n+                                REQUIRED_LIB_rustrt -> \"rustrt.dll\"\n+                              | REQUIRED_LIB_crt -> \"msvcrt.dll\"\n+                              | REQUIRED_LIB_rust ls\n+                              | REQUIRED_LIB_c ls -> ls.required_libname);\n+      pe_import_dll_ILT_fixup = new_fixup \"dll ILT\";\n+      pe_import_dll_IAT_fixup = new_fixup \"dll IAT\";\n+      pe_import_dll_imports =\n+        Array.of_list\n+          (List.map\n+             begin\n+               fun (name, fixup) ->\n+                 {\n+                   pe_import_name_fixup = new_fixup \"import name\";\n+                   pe_import_name = name;\n+                   pe_import_address_fixup = fixup;\n+                 }\n+             end\n+             (htab_pairs tab))\n+    }\n+  in\n+    Array.of_list\n+      (List.map\n+         make_imports_for_lib\n+         (htab_pairs sem.Semant.ctxt_native_required))\n+;;\n+\n+\n+let crate_exports (sem:Semant.ctxt) : pe_export array =\n+  let export_sym (name, fixup) =\n+    {\n+      pe_export_name_fixup = new_fixup \"export name fixup\";\n+      pe_export_name = name;\n+      pe_export_address_fixup = fixup;\n+    }\n+  in\n+  let export_seg (_, tab) =\n+    Array.of_list (List.map export_sym (htab_pairs tab))\n+  in\n+    Array.concat\n+      (List.map export_seg\n+         (htab_pairs sem.Semant.ctxt_native_provided))\n+;;\n+\n+\n+let emit_file\n+    (sess:Session.sess)\n+    (crate:Ast.crate)\n+    (code:Asm.frag)\n+    (data:Asm.frag)\n+    (sem:Semant.ctxt)\n+    (dw:Dwarf.debug_records)\n+    : unit =\n+\n+  let all_hdrs_fixup = new_fixup \"all headers\" in\n+  let all_init_data_fixup = new_fixup \"all initialized data\" in\n+  let loader_hdr_fixup = new_fixup \"loader header\" in\n+  let import_dir_fixup = new_fixup \"import directory\" in\n+  let export_dir_fixup = new_fixup \"export directory\" in\n+  let text_fixup = new_fixup \"text section\" in\n+  let bss_fixup = new_fixup \"bss section\" in\n+  let data_fixup = new_fixup \"data section\" in\n+  let image_fixup = new_fixup \"image fixup\" in\n+  let symtab_fixup = new_fixup \"symbol table\" in\n+  let strtab_fixup = new_fixup \"string table\" in\n+  let note_rust_fixup = new_fixup \".note.rust section\" in\n+\n+  let (start_fixup, rust_start_fixup) =\n+    if sess.Session.sess_library_mode\n+    then (None, None)\n+    else\n+      (Some (new_fixup \"start\"),\n+       Some (Semant.require_native sem REQUIRED_LIB_rustrt \"rust_start\"))\n+  in\n+\n+  let header = (pe_header\n+                  ~machine: IMAGE_FILE_MACHINE_I386\n+                  ~symbol_table_fixup: symtab_fixup\n+                  ~number_of_sections: 8L\n+                  ~number_of_symbols: 0L\n+                  ~loader_hdr_fixup: loader_hdr_fixup\n+                  ~characteristics:([IMAGE_FILE_EXECUTABLE_IMAGE;\n+                                    IMAGE_FILE_LINE_NUMS_STRIPPED;\n+                                    IMAGE_FILE_32BIT_MACHINE;]\n+                                    @\n+                                    (if sess.Session.sess_library_mode\n+                                     then [ IMAGE_FILE_DLL ]\n+                                     else [ ])))\n+  in\n+  let symtab =\n+    (* \n+     * We're not actually presenting a \"symbol table\", but wish to\n+     * provide a \"string table\" which comes immediately *after* the\n+     * symbol table. It's a violation of the PE spec to put one of\n+     * these in an executable file (as opposed to just loadable) but\n+     * it's necessary to communicate the debug section names to GDB,\n+     * and nobody else complains.  \n+     *)\n+    (def_aligned\n+       symtab_fixup\n+       (def_aligned\n+          strtab_fixup\n+          (SEQ\n+             [|\n+               WORD (TY_u32, (F_SZ strtab_fixup));\n+               ZSTRING \".debug_aranges\";\n+               ZSTRING \".debug_pubnames\";\n+               ZSTRING \".debug_info\";\n+               ZSTRING \".debug_abbrev\";\n+               ZSTRING \".debug_line\";\n+               ZSTRING \".debug_frame\";\n+               ZSTRING \".note.rust\";\n+             |])))\n+  in\n+  let loader_header = (pe_loader_header\n+                         ~text_fixup\n+                         ~init_data_fixup: all_init_data_fixup\n+                         ~size_of_uninit_data: 0L\n+                         ~entry_point_fixup: start_fixup\n+                         ~image_fixup: image_fixup\n+                         ~subsys: IMAGE_SUBSYSTEM_WINDOWS_CUI\n+                         ~all_hdrs_fixup\n+                         ~loader_hdr_fixup\n+                         ~import_dir_fixup\n+                         ~export_dir_fixup)\n+  in\n+  let text_header = (pe_section_header\n+                       ~id: SECTION_ID_TEXT\n+                       ~hdr_fixup: text_fixup)\n+\n+  in\n+  let bss_header = (pe_section_header\n+                      ~id: SECTION_ID_BSS\n+                      ~hdr_fixup: bss_fixup)\n+  in\n+  let import_section = (pe_import_section\n+                          ~import_dir_fixup\n+                          ~dlls: (rustrt_imports sem))\n+  in\n+  let import_header = (pe_section_header\n+                         ~id: SECTION_ID_IMPORTS\n+                         ~hdr_fixup: import_dir_fixup)\n+  in\n+  let export_section = (pe_export_section\n+                          ~sess\n+                          ~export_dir_fixup\n+                          ~exports: (crate_exports sem))\n+  in\n+  let export_header = (pe_section_header\n+                         ~id: SECTION_ID_EXPORTS\n+                         ~hdr_fixup: export_dir_fixup)\n+  in\n+  let data_header = (pe_section_header\n+                       ~id: SECTION_ID_DATA\n+                       ~hdr_fixup: data_fixup)\n+  in\n+(*\n+  let debug_aranges_header =\n+    (pe_section_header\n+      ~id: SECTION_ID_DEBUG_ARANGES\n+      ~hdr_fixup: sem.Semant.ctxt_debug_aranges_fixup)\n+  in\n+  let debug_pubnames_header =\n+    (pe_section_header\n+      ~id: SECTION_ID_DEBUG_PUBNAMES\n+      ~hdr_fixup: sem.Semant.ctxt_debug_pubnames_fixup)\n+  in\n+*)\n+  let debug_info_header = (pe_section_header\n+                             ~id: SECTION_ID_DEBUG_INFO\n+                             ~hdr_fixup: sem.Semant.ctxt_debug_info_fixup)\n+  in\n+  let debug_abbrev_header = (pe_section_header\n+                               ~id: SECTION_ID_DEBUG_ABBREV\n+                               ~hdr_fixup: sem.Semant.ctxt_debug_abbrev_fixup)\n+  in\n+(*\n+  let debug_line_header =\n+    (pe_section_header\n+      ~id: SECTION_ID_DEBUG_LINE\n+      ~hdr_fixup: sem.Semant.ctxt_debug_line_fixup)\n+  in\n+  let debug_frame_header =\n+    (pe_section_header\n+      ~id: SECTION_ID_DEBUG_FRAME\n+      ~hdr_fixup: sem.Semant.ctxt_debug_frame_fixup)\n+  in\n+*)\n+  let note_rust_header = (pe_section_header\n+                            ~id: SECTION_ID_NOTE_RUST\n+                            ~hdr_fixup: note_rust_fixup)\n+  in\n+  let all_headers = (def_file_aligned\n+                       all_hdrs_fixup\n+                       (SEQ\n+                          [|\n+                            pe_msdos_header_and_padding;\n+                            header;\n+                            loader_header;\n+                            text_header;\n+                            bss_header;\n+                            import_header;\n+                            export_header;\n+                            data_header;\n+                            (*\n+                            debug_aranges_header;\n+                            debug_pubnames_header;\n+                            *)\n+                            debug_info_header;\n+                            debug_abbrev_header;\n+                            (*\n+                            debug_line_header;\n+                            debug_frame_header;\n+                            *)\n+                            note_rust_header;\n+                          |]))\n+  in\n+\n+  let text_section = (pe_text_section\n+                        ~sem\n+                        ~sess\n+                        ~start_fixup\n+                        ~rust_start_fixup\n+                        ~main_fn_fixup: sem.Semant.ctxt_main_fn_fixup\n+                        ~text_fixup\n+                        ~crate_code: code)\n+  in\n+  let bss_section = def_aligned bss_fixup (BSS 0x10L)\n+  in\n+  let data_section = (def_aligned data_fixup\n+                        (SEQ [| data; symtab; |]))\n+  in\n+  let all_init_data = (def_aligned\n+                         all_init_data_fixup\n+                         (SEQ [| import_section;\n+                                 export_section;\n+                                 data_section; |]))\n+  in\n+(*\n+  let debug_aranges_section =\n+    def_aligned sem.Semant.ctxt_debug_aranges_fixup dw.Dwarf.debug_aranges\n+  in\n+  let debug_pubnames_section =\n+    def_aligned sem.Semant.ctxt_debug_pubnames_fixup dw.Dwarf.debug_pubnames\n+  in\n+*)\n+  let debug_info_section =\n+    def_aligned sem.Semant.ctxt_debug_info_fixup dw.Dwarf.debug_info\n+  in\n+  let debug_abbrev_section =\n+    def_aligned sem.Semant.ctxt_debug_abbrev_fixup dw.Dwarf.debug_abbrev\n+  in\n+(*\n+  let debug_line_section =\n+    def_aligned sem.Semant.ctxt_debug_line_fixup dw.Dwarf.debug_line\n+  in\n+  let debug_frame_section =\n+    def_aligned sem.Semant.ctxt_debug_frame_fixup dw.Dwarf.debug_frame\n+  in\n+*)\n+  let note_rust_section =\n+    def_aligned note_rust_fixup\n+      (Asm.note_rust_frags crate.node.Ast.crate_meta)\n+  in\n+\n+  let all_frags = SEQ [| MEMPOS pe_image_base;\n+                         (def_file_aligned image_fixup\n+                            (SEQ [| DEF (sem.Semant.ctxt_image_base_fixup,\n+                                         MARK);\n+                                    all_headers;\n+                                    text_section;\n+                                    bss_section;\n+                                    all_init_data;\n+                                    (* debug_aranges_section; *)\n+                                    (* debug_pubnames_section; *)\n+                                    debug_info_section;\n+                                    debug_abbrev_section;\n+                                    (* debug_line_section; *)\n+                                    (* debug_frame_section; *)\n+                                    note_rust_section;\n+                                    ALIGN_MEM (pe_mem_alignment, MARK)\n+                                 |]\n+                            )\n+                         )\n+                      |]\n+  in\n+    write_out_frag sess true all_frags\n+;;\n+\n+let pe_magic = \"PE\";;\n+\n+let sniff\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : asm_reader option =\n+  try\n+    let stat = Unix.stat filename in\n+    if (stat.Unix.st_kind = Unix.S_REG) &&\n+      (stat.Unix.st_size >= pe_file_alignment)\n+    then\n+      let ar = new_asm_reader sess filename in\n+      let _ = log sess \"sniffing PE file\" in\n+        (* PE header offset is at 0x3c in the MS-DOS compatibility header. *)\n+      let _ = ar.asm_seek 0x3c in\n+      let pe_hdr_off = ar.asm_get_u32() in\n+      let _ = log sess \"PE header offset: 0x%x\" pe_hdr_off in\n+\n+      let _ = ar.asm_seek pe_hdr_off in\n+      let pe_signature = ar.asm_get_zstr_padded 4 in\n+      let _ = log sess \"    PE signature: '%s'\" pe_signature in\n+        if pe_signature = pe_magic\n+        then (ar.asm_seek 0; Some ar)\n+        else None\n+    else\n+      None\n+  with\n+      _ -> None\n+;;\n+\n+\n+let get_sections\n+    (sess:Session.sess)\n+    (ar:asm_reader)\n+    : (string,(int*int)) Hashtbl.t =\n+  let _ = log sess \"reading sections\" in\n+  (* PE header offset is at 0x3c in the MS-DOS compatibility header. *)\n+  let _ = ar.asm_seek 0x3c in\n+  let pe_hdr_off = ar.asm_get_u32() in\n+  let _ = log sess \"PE header offset: 0x%x\" pe_hdr_off in\n+\n+  let _ = ar.asm_seek pe_hdr_off in\n+  let pe_signature = ar.asm_get_zstr_padded 4 in\n+  let _ = log sess \"    PE signature: '%s'\" pe_signature in\n+  let _ = assert (pe_signature = pe_magic) in\n+  let _ = ar.asm_adv_u16() in (* machine type *)\n+\n+  let num_sections = ar.asm_get_u16() in\n+  let _ = log sess \"    num sections: %d\" num_sections in\n+\n+  let _ = ar.asm_adv_u32() in (* timestamp *)\n+\n+  let symtab_off = ar.asm_get_u32() in\n+  let _ = log sess \"   symtab offset: 0x%x\" symtab_off in\n+\n+  let num_symbols = ar.asm_get_u32() in\n+  let _ = log sess \"     num symbols: %d\" num_symbols in\n+\n+  let loader_hdr_size = ar.asm_get_u16() in\n+  let _ = log sess \"loader header sz: %d\" loader_hdr_size in\n+\n+  let _ = ar.asm_adv_u16() in (* flags *)\n+  let sections_off = (ar.asm_get_off()) + loader_hdr_size in\n+\n+  let sects = Hashtbl.create 0 in\n+\n+  let _ =\n+    ar.asm_seek sections_off;\n+    for i = 0 to (num_sections - 1) do\n+      (* \n+       * Section-name encoding is crazy. ASCII-encoding offsets of\n+       * long names. See pe_section_header for details.\n+       *)\n+      let sect_name =\n+        let sect_name = ar.asm_get_zstr_padded 8 in\n+          assert ((String.length sect_name) > 0);\n+          if sect_name.[0] = '/'\n+          then\n+            let off_str =\n+              String.sub sect_name 1 ((String.length sect_name) - 1)\n+            in\n+            let i = int_of_string off_str in\n+            let curr = ar.asm_get_off() in\n+              ar.asm_seek (symtab_off + i);\n+              let ext_name = ar.asm_get_zstr() in\n+                ar.asm_seek curr;\n+                ext_name\n+          else\n+            sect_name\n+      in\n+      let _ = ar.asm_adv_u32() in (* virtual size *)\n+      let _ = ar.asm_adv_u32() in (* virtual address *)\n+      let file_sz = ar.asm_get_u32() in\n+      let file_off = ar.asm_get_u32() in\n+      let _ = ar.asm_adv_u32() in (* reserved *)\n+      let _ = ar.asm_adv_u32() in (* reserved *)\n+      let _ = ar.asm_adv_u32() in (* reserved *)\n+      let _ = ar.asm_adv_u32() in (* flags *)\n+        Hashtbl.add sects sect_name (file_off, file_sz);\n+        log sess \"       section %d: %s, size %d, offset 0x%x\"\n+          i sect_name file_sz file_off;\n+    done\n+  in\n+    sects\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "db70b21d0c7cb718967978da2fb69155c70a2285", "filename": "src/boot/be/ra.ml", "status": "added", "additions": 664, "deletions": 0, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fra.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fra.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fra.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,664 @@\n+open Il;;\n+open Common;;\n+\n+type ctxt =\n+    {\n+      ctxt_sess: Session.sess;\n+      ctxt_n_vregs: int;\n+      ctxt_abi: Abi.abi;\n+      mutable ctxt_quads: Il.quads;\n+      mutable ctxt_next_spill: int;\n+      mutable ctxt_next_label: int;\n+      (* More state as necessary. *)\n+    }\n+;;\n+\n+let new_ctxt\n+    (sess:Session.sess)\n+    (quads:Il.quads)\n+    (vregs:int)\n+    (abi:Abi.abi)\n+    : ctxt =\n+  {\n+    ctxt_sess = sess;\n+    ctxt_quads = quads;\n+    ctxt_n_vregs = vregs;\n+    ctxt_abi = abi;\n+    ctxt_next_spill = 0;\n+    ctxt_next_label = 0;\n+  }\n+;;\n+\n+let log (cx:ctxt) =\n+  Session.log \"ra\"\n+    cx.ctxt_sess.Session.sess_log_ra\n+    cx.ctxt_sess.Session.sess_log_out\n+;;\n+\n+let iflog (cx:ctxt) (thunk:(unit -> unit)) : unit =\n+  if cx.ctxt_sess.Session.sess_log_ra\n+  then thunk ()\n+  else ()\n+;;\n+\n+let list_to_str list eltstr =\n+  (String.concat \",\" (List.map eltstr (List.sort compare list)))\n+;;\n+\n+let next_spill (cx:ctxt) : int =\n+  let i = cx.ctxt_next_spill in\n+    cx.ctxt_next_spill <- i + 1;\n+    i\n+;;\n+\n+let next_label (cx:ctxt) : string =\n+  let i = cx.ctxt_next_label in\n+    cx.ctxt_next_label <- i + 1;\n+    (\".L\" ^ (string_of_int i))\n+;;\n+\n+exception Ra_error of string ;;\n+\n+let convert_labels (cx:ctxt) : unit =\n+  let quad_fixups = Array.map (fun q -> q.quad_fixup) cx.ctxt_quads in\n+  let qp_code (_:Il.quad_processor) (c:Il.code) : Il.code =\n+    match c with\n+        Il.CodeLabel lab ->\n+          let fix =\n+            match quad_fixups.(lab) with\n+                None ->\n+                  let fix = new_fixup (next_label cx) in\n+                    begin\n+                      quad_fixups.(lab) <- Some fix;\n+                      fix\n+                    end\n+              | Some f -> f\n+          in\n+            Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy))\n+      | _ -> c\n+  in\n+  let qp = { Il.identity_processor\n+             with Il.qp_code = qp_code }\n+  in\n+    Il.rewrite_quads qp cx.ctxt_quads;\n+    Array.iteri (fun i fix ->\n+                   cx.ctxt_quads.(i) <- { cx.ctxt_quads.(i) with\n+                                            Il.quad_fixup = fix })\n+      quad_fixups;\n+;;\n+\n+let convert_pre_spills\n+    (cx:ctxt)\n+    (mkspill:(Il.spill -> Il.mem))\n+    : int =\n+  let n = ref 0 in\n+  let qp_mem (_:Il.quad_processor) (a:Il.mem) : Il.mem =\n+    match a with\n+        Il.Spill i ->\n+          begin\n+            if i+1 > (!n)\n+            then n := i+1;\n+            mkspill i\n+          end\n+      | _ -> a\n+  in\n+  let qp = Il.identity_processor in\n+  let qp = { qp with\n+               Il.qp_mem = qp_mem  }\n+  in\n+    begin\n+      Il.rewrite_quads qp cx.ctxt_quads;\n+      !n\n+    end\n+;;\n+\n+let kill_quad (i:int) (cx:ctxt) : unit =\n+  cx.ctxt_quads.(i) <-\n+    { Il.deadq with\n+        Il.quad_fixup = cx.ctxt_quads.(i).Il.quad_fixup }\n+;;\n+\n+let kill_redundant_moves (cx:ctxt) : unit =\n+  let process_quad i q =\n+    match q.Il.quad_body with\n+        Il.Unary u when\n+          ((Il.is_mov u.Il.unary_op) &&\n+             (Il.Cell u.Il.unary_dst) = u.Il.unary_src) ->\n+            kill_quad i cx\n+      | _ -> ()\n+  in\n+    Array.iteri process_quad cx.ctxt_quads\n+;;\n+\n+let quad_jump_target_labels (q:quad) : Il.label list =\n+  let explicits =\n+    match q.Il.quad_body with\n+        Il.Jmp { Il.jmp_targ = Il.CodeLabel lab } -> [ lab ]\n+      | _ -> []\n+  in\n+    explicits @ q.quad_implicits;\n+;;\n+\n+let quad_used_vregs (q:quad) : Il.vreg list =\n+  let vregs = ref [] in\n+  let qp_reg _ r =\n+    match r with\n+        Il.Vreg v -> (vregs := (v :: (!vregs)); r)\n+      | _ -> r\n+  in\n+  let qp_cell_write qp c =\n+    match c with\n+        Il.Reg _ -> c\n+      | Il.Mem (a, b) -> Il.Mem (qp.qp_mem qp a, b)\n+  in\n+  let qp = { Il.identity_processor with\n+               Il.qp_reg = qp_reg;\n+               Il.qp_cell_write = qp_cell_write }\n+  in\n+    ignore (Il.process_quad qp q);\n+    !vregs\n+;;\n+\n+let quad_defined_vregs (q:quad) : Il.vreg list =\n+  let vregs = ref [] in\n+  let qp_cell_write _ c =\n+    match c with\n+        Il.Reg (Il.Vreg v, _) -> (vregs := (v :: (!vregs)); c)\n+      | _ -> c\n+  in\n+  let qp = { Il.identity_processor with\n+               Il.qp_cell_write = qp_cell_write }\n+  in\n+    ignore (Il.process_quad qp q);\n+    !vregs\n+;;\n+\n+let quad_is_unconditional_jump (q:quad) : bool =\n+  match q.Il.quad_body with\n+      Il.Jmp { jmp_op = Il.JMP } -> true\n+    | Il.Ret -> true\n+    | _ -> false\n+;;\n+\n+let calculate_live_bitvectors\n+    (cx:ctxt)\n+    : ((Bits.t array) * (Bits.t array)) =\n+\n+  log cx \"calculating live bitvectors\";\n+\n+  let quads = cx.ctxt_quads in\n+  let n_quads = Array.length quads in\n+  let n_vregs = cx.ctxt_n_vregs in\n+  let new_bitv _ = Bits.create n_vregs false in\n+  let (live_in_vregs:Bits.t array) = Array.init n_quads new_bitv in\n+  let (live_out_vregs:Bits.t array) = Array.init n_quads new_bitv in\n+\n+  let (quad_used_vrs:Bits.t array) = Array.init n_quads new_bitv in\n+  let (quad_defined_vrs:Bits.t array) = Array.init n_quads new_bitv in\n+  let (quad_uncond_jmp:bool array) = Array.make n_quads false in\n+  let (quad_jmp_targs:(Il.label list) array) = Array.make n_quads [] in\n+\n+  let outer_changed = ref true in\n+\n+  (* Working bit-vector. *)\n+  let scratch = new_bitv() in\n+\n+  (* bit-vector helpers. *)\n+    (* Setup pass. *)\n+    for i = 0 to n_quads - 1 do\n+      let q = quads.(i) in\n+        quad_uncond_jmp.(i) <- quad_is_unconditional_jump q;\n+        quad_jmp_targs.(i) <- quad_jump_target_labels q;\n+        List.iter\n+          (fun v -> Bits.set quad_used_vrs.(i) v true)\n+          (quad_used_vregs q);\n+        List.iter\n+          (fun v -> Bits.set quad_defined_vrs.(i) v true)\n+          (quad_defined_vregs q)\n+    done;\n+\n+    while !outer_changed do\n+      iflog cx (fun _ -> log cx \"iterating outer bitvector calculation\");\n+      outer_changed := false;\n+      for i = 0 to n_quads - 1 do\n+        Bits.clear live_in_vregs.(i);\n+        Bits.clear live_out_vregs.(i)\n+      done;\n+      let inner_changed = ref true in\n+        while !inner_changed do\n+          inner_changed := false;\n+          iflog cx\n+            (fun _ ->\n+               log cx \"iterating inner bitvector calculation over %d quads\"\n+                 n_quads);\n+          for i = n_quads - 1 downto 0 do\n+\n+            let note_change b = if b then inner_changed := true in\n+            let live_in = live_in_vregs.(i) in\n+            let live_out = live_out_vregs.(i) in\n+            let used = quad_used_vrs.(i) in\n+            let defined = quad_defined_vrs.(i) in\n+\n+              (* Union in the vregs we use. *)\n+              note_change (Bits.union live_in used);\n+\n+              (* Union in all our jump targets. *)\n+              List.iter\n+                (fun i -> note_change (Bits.union live_out live_in_vregs.(i)))\n+                (quad_jmp_targs.(i));\n+\n+              (* Union in our block successor if we have one *)\n+              if i < (n_quads - 1) && (not (quad_uncond_jmp.(i)))\n+              then note_change (Bits.union live_out live_in_vregs.(i+1));\n+\n+              (* Propagate live-out to live-in on anything we don't define. *)\n+              ignore (Bits.copy scratch defined);\n+              Bits.invert scratch;\n+              ignore (Bits.intersect scratch live_out);\n+              note_change (Bits.union live_in scratch);\n+\n+          done\n+        done;\n+        let kill_mov_to_dead_target i q =\n+          match q.Il.quad_body with\n+              Il.Unary { Il.unary_op=uop;\n+                         Il.unary_dst=Il.Reg (Il.Vreg v, _) }\n+                when\n+                  ((Il.is_mov uop) &&\n+                     not (Bits.get live_out_vregs.(i) v)) ->\n+                  begin\n+                    kill_quad i cx;\n+                    outer_changed := true;\n+                  end\n+            | _ -> ()\n+        in\n+          Array.iteri kill_mov_to_dead_target quads\n+    done;\n+    iflog cx\n+      begin\n+        fun _ ->\n+          log cx \"finished calculating live bitvectors\";\n+          log cx \"=========================\";\n+          for q = 0 to n_quads - 1 do\n+            let buf = Buffer.create 128 in\n+              for v = 0 to (n_vregs - 1)\n+              do\n+                if ((Bits.get live_in_vregs.(q) v)\n+                    && (Bits.get live_out_vregs.(q) v))\n+                then Printf.bprintf buf \" %-2d\" v\n+                else Buffer.add_string buf \"   \"\n+              done;\n+              log cx \"[%6d] live vregs: %s\" q (Buffer.contents buf)\n+          done;\n+          log cx \"=========================\"\n+      end;\n+    (live_in_vregs, live_out_vregs)\n+;;\n+\n+\n+let is_end_of_basic_block (q:quad) : bool =\n+  match q.Il.quad_body with\n+      Il.Jmp _ -> true\n+    | Il.Ret -> true\n+    | _ -> false\n+;;\n+\n+let is_beginning_of_basic_block (q:quad) : bool =\n+  match q.Il.quad_fixup with\n+      None -> false\n+    | Some _ -> true\n+;;\n+\n+let dump_quads cx =\n+  let f = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n+  let len = (Array.length cx.ctxt_quads) - 1 in\n+  let ndigits_of n = (int_of_float (log10 (float_of_int n))) in\n+  let padded_num n maxnum =\n+    let ndigits = ndigits_of n in\n+    let maxdigits = ndigits_of maxnum in\n+    let pad = String.make (maxdigits - ndigits) ' ' in\n+      Printf.sprintf \"%s%d\" pad n\n+  in\n+  let padded_str str maxlen =\n+    let pad = String.make (maxlen - (String.length str)) ' ' in\n+      Printf.sprintf \"%s%s\" pad str\n+  in\n+  let maxlablen = ref 0 in\n+  for i = 0 to len\n+  do\n+    let q = cx.ctxt_quads.(i) in\n+    match q.quad_fixup with\n+        None -> ()\n+      | Some f ->\n+          maxlablen := max (!maxlablen) ((String.length f.fixup_name) + 1)\n+  done;\n+  for i = 0 to len\n+  do\n+    let q = cx.ctxt_quads.(i) in\n+    let qs = (string_of_quad f q) in\n+    let lab = match q.quad_fixup with\n+        None -> \"\"\n+      | Some f -> f.fixup_name ^ \":\"\n+    in\n+      log cx \"[%s] %s %s\" (padded_num i len) (padded_str lab (!maxlablen)) qs\n+  done\n+;;\n+\n+let calculate_vreg_constraints (cx:ctxt) : Bits.t array =\n+  let abi = cx.ctxt_abi in\n+  let n_vregs = cx.ctxt_n_vregs in\n+  let n_hregs = abi.Abi.abi_n_hardregs in\n+  let constraints = Array.init n_vregs (fun _ -> Bits.create n_hregs true) in\n+    Array.iteri\n+      begin\n+        fun i q ->\n+          abi.Abi.abi_constrain_vregs q constraints;\n+          iflog cx\n+            begin\n+              fun _ ->\n+                let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n+                  log cx \"constraints for quad %d = %s\"\n+                    i (string_of_quad hr_str q);\n+                  let qp_reg _ r =\n+                    begin\n+                      match r with\n+                          Il.Hreg _ -> ()\n+                        | Il.Vreg v ->\n+                            let hregs = Bits.to_list constraints.(v) in\n+                              log cx \"<v%d> constrained to hregs: [%s]\"\n+                                v (list_to_str hregs hr_str)\n+                    end;\n+                    r\n+                  in\n+                    ignore (Il.process_quad { Il.identity_processor with\n+                                                Il.qp_reg = qp_reg } q)\n+            end;\n+      end\n+      cx.ctxt_quads;\n+    constraints\n+;;\n+\n+(* Simple local register allocator. Nothing fancy. *)\n+let reg_alloc\n+    (sess:Session.sess)\n+    (quads:Il.quads)\n+    (vregs:int)\n+    (abi:Abi.abi) =\n+ try\n+    let cx = new_ctxt sess quads vregs abi in\n+    let _ =\n+      iflog cx\n+        begin\n+          fun _ ->\n+            log cx \"un-allocated quads:\";\n+            dump_quads cx\n+        end\n+    in\n+\n+    (* Work out pre-spilled slots and allocate 'em. *)\n+    let spill_slot (s:Il.spill) = abi.Abi.abi_spill_slot s in\n+    let n_pre_spills = convert_pre_spills cx spill_slot in\n+\n+    let (live_in_vregs, live_out_vregs) =\n+      Session.time_inner \"RA liveness\" sess\n+        (fun _ -> calculate_live_bitvectors cx)\n+    in\n+    let (vreg_constraints:Bits.t array) = (* vreg idx -> hreg bits.t *)\n+      calculate_vreg_constraints cx\n+    in\n+    let inactive_hregs = ref [] in (* [hreg] *)\n+    let active_hregs = ref [] in (* [hreg] *)\n+    let dirty_vregs = Hashtbl.create 0 in (* vreg -> () *)\n+    let hreg_to_vreg = Hashtbl.create 0 in  (* hreg -> vreg *)\n+    let vreg_to_hreg = Hashtbl.create 0 in (* vreg -> hreg *)\n+    let vreg_to_spill = Hashtbl.create 0 in (* vreg -> spill *)\n+    let (word_ty:Il.scalar_ty) = Il.ValTy abi.Abi.abi_word_bits in\n+    let vreg_spill_cell v =\n+      Il.Mem ((spill_slot (Hashtbl.find vreg_to_spill v)),\n+              Il.ScalarTy word_ty)\n+    in\n+    let newq = ref [] in\n+    let fixup = ref None in\n+    let prepend q =\n+      newq := {q with quad_fixup = !fixup} :: (!newq);\n+      fixup := None\n+    in\n+    let hr h = Il.Reg (Il.Hreg h, Il.voidptr_t) in\n+    let hr_str = cx.ctxt_abi.Abi.abi_str_of_hardreg in\n+    let clean_hreg i hreg =\n+      if (Hashtbl.mem hreg_to_vreg hreg) &&\n+        (hreg < cx.ctxt_abi.Abi.abi_n_hardregs)\n+      then\n+        let vreg = Hashtbl.find hreg_to_vreg hreg in\n+          if Hashtbl.mem dirty_vregs vreg\n+          then\n+            begin\n+              Hashtbl.remove dirty_vregs vreg;\n+              if (Bits.get (live_out_vregs.(i)) vreg)\n+              then\n+                let spill_idx =\n+                  if Hashtbl.mem vreg_to_spill vreg\n+                  then Hashtbl.find vreg_to_spill vreg\n+                  else\n+                    begin\n+                      let s = next_spill cx in\n+                        Hashtbl.replace vreg_to_spill vreg s;\n+                        s\n+                    end\n+                in\n+                let spill_mem = spill_slot spill_idx in\n+                let spill_cell = Il.Mem (spill_mem, Il.ScalarTy word_ty) in\n+                  log cx \"spilling <%d> from %s to %s\"\n+                    vreg (hr_str hreg) (string_of_mem hr_str spill_mem);\n+                  prepend (Il.mk_quad\n+                             (Il.umov spill_cell (Il.Cell (hr hreg))));\n+              else ()\n+            end\n+          else ()\n+      else ()\n+    in\n+\n+    let inactivate_hreg hreg =\n+      if (Hashtbl.mem hreg_to_vreg hreg) &&\n+        (hreg < cx.ctxt_abi.Abi.abi_n_hardregs)\n+      then\n+        let vreg = Hashtbl.find hreg_to_vreg hreg in\n+          Hashtbl.remove vreg_to_hreg vreg;\n+          Hashtbl.remove hreg_to_vreg hreg;\n+          active_hregs := List.filter (fun x -> x != hreg) (!active_hregs);\n+          inactive_hregs := hreg :: (!inactive_hregs);\n+      else ()\n+    in\n+\n+    let spill_specific_hreg i hreg =\n+      clean_hreg i hreg;\n+      inactivate_hreg hreg\n+    in\n+\n+    let rec select_constrained\n+        (constraints:Bits.t)\n+        (hregs:Il.hreg list)\n+        : Il.hreg option =\n+      match hregs with\n+          [] -> None\n+        | h::hs ->\n+            if Bits.get constraints h\n+            then Some h\n+            else select_constrained constraints hs\n+    in\n+\n+    let spill_constrained constrs i =\n+      match select_constrained constrs (!active_hregs) with\n+          None ->\n+            raise (Ra_error (\"unable to spill according to constraint\"));\n+        | Some h ->\n+            begin\n+              spill_specific_hreg i h;\n+              h\n+            end\n+    in\n+\n+    let all_hregs = Bits.create abi.Abi.abi_n_hardregs true in\n+\n+    let spill_all_regs i =\n+      while (!active_hregs) != []\n+      do\n+        let _ = spill_constrained all_hregs i in\n+          ()\n+      done\n+    in\n+\n+    let reload vreg hreg =\n+      if Hashtbl.mem vreg_to_spill vreg\n+      then\n+        prepend (Il.mk_quad\n+                   (Il.umov\n+                      (hr hreg)\n+                      (Il.Cell (vreg_spill_cell vreg))))\n+      else ()\n+    in\n+\n+    let use_vreg def i vreg =\n+      if Hashtbl.mem vreg_to_hreg vreg\n+      then\n+        begin\n+          let h = Hashtbl.find vreg_to_hreg vreg in\n+          iflog cx (fun _ -> log cx \"found cached assignment %s for <v%d>\"\n+                      (hr_str h) vreg);\n+            h\n+        end\n+      else\n+        let hreg =\n+          let constrs = vreg_constraints.(vreg) in\n+          match select_constrained constrs (!inactive_hregs) with\n+              None ->\n+                let h = spill_constrained constrs i in\n+                  iflog cx\n+                    (fun _ -> log cx \"selected %s to spill and use for <v%d>\"\n+                       (hr_str h) vreg);\n+                  h\n+            | Some h ->\n+                iflog cx (fun _ -> log cx \"selected inactive %s for <v%d>\"\n+                            (hr_str h) vreg);\n+                h\n+        in\n+          inactive_hregs :=\n+            List.filter (fun x -> x != hreg) (!inactive_hregs);\n+          active_hregs := (!active_hregs) @ [hreg];\n+          Hashtbl.replace hreg_to_vreg hreg vreg;\n+          Hashtbl.replace vreg_to_hreg vreg hreg;\n+          if def\n+          then ()\n+          else\n+            reload vreg hreg;\n+          hreg\n+    in\n+    let qp_reg def i _ r =\n+      match r with\n+          Il.Hreg h -> (spill_specific_hreg i h; r)\n+        | Il.Vreg v -> (Il.Hreg (use_vreg def i v))\n+    in\n+    let qp_cell def i qp c =\n+      match c with\n+          Il.Reg (r, b) -> Il.Reg (qp_reg def i qp r, b)\n+        | Il.Mem  (a, b) ->\n+            let qp = { qp with Il.qp_reg = qp_reg false i } in\n+              Il.Mem (qp.qp_mem qp a, b)\n+    in\n+    let qp i = { Il.identity_processor with\n+                   Il.qp_cell_read = qp_cell false i;\n+                   Il.qp_cell_write = qp_cell true i;\n+                   Il.qp_reg = qp_reg false i }\n+    in\n+      cx.ctxt_next_spill <- n_pre_spills;\n+      convert_labels cx;\n+      for i = 0 to cx.ctxt_abi.Abi.abi_n_hardregs - 1\n+      do\n+        inactive_hregs := i :: (!inactive_hregs)\n+      done;\n+      for i = 0 to (Array.length cx.ctxt_quads) - 1\n+      do\n+        let quad = cx.ctxt_quads.(i) in\n+        let clobbers = cx.ctxt_abi.Abi.abi_clobbers quad in\n+        let used = quad_used_vregs quad in\n+        let defined = quad_defined_vregs quad in\n+          begin\n+            if List.exists (fun def -> List.mem def clobbers) defined\n+            then raise (Ra_error (\"clobber and defined sets overlap\"));\n+            iflog cx\n+              begin\n+                fun _ ->\n+                  let hr (v:int) : string =\n+                    if Hashtbl.mem vreg_to_hreg v\n+                    then hr_str (Hashtbl.find vreg_to_hreg v)\n+                    else \"??\"\n+                  in\n+                  let vr_str (v:int) : string =\n+                    Printf.sprintf \"v%d=%s\" v (hr v)\n+                  in\n+                  let lstr lab ls fn =\n+                    if List.length ls = 0\n+                    then ()\n+                    else log cx \"\\t%s: [%s]\" lab (list_to_str ls fn)\n+                  in\n+                    log cx \"processing quad %d = %s\"\n+                      i (string_of_quad hr_str quad);\n+                    (lstr \"dirt\" (htab_keys dirty_vregs) vr_str);\n+                    (lstr \"clob\" clobbers hr_str);\n+                    (lstr \"in\" (Bits.to_list live_in_vregs.(i)) vr_str);\n+                    (lstr \"out\" (Bits.to_list live_out_vregs.(i)) vr_str);\n+                    (lstr \"use\" used vr_str);\n+                    (lstr \"def\" defined vr_str);\n+              end;\n+            List.iter (clean_hreg i) clobbers;\n+            if is_beginning_of_basic_block quad\n+            then\n+              begin\n+                spill_all_regs i;\n+                fixup := quad.quad_fixup;\n+                prepend (Il.process_quad (qp i) quad)\n+              end\n+            else\n+              begin\n+                fixup := quad.quad_fixup;\n+                let newq = (Il.process_quad (qp i) quad) in\n+                  begin\n+                    if is_end_of_basic_block quad\n+                    then spill_all_regs i\n+                    else ()\n+                  end;\n+                  prepend newq\n+              end\n+          end;\n+          List.iter inactivate_hreg clobbers;\n+          List.iter (fun i -> Hashtbl.replace dirty_vregs i ()) defined;\n+      done;\n+      cx.ctxt_quads <- Array.of_list (List.rev (!newq));\n+      kill_redundant_moves cx;\n+\n+      iflog cx\n+        begin\n+          fun _ ->\n+            log cx \"spills: %d pre-spilled, %d total\"\n+              n_pre_spills cx.ctxt_next_spill;\n+            log cx \"register-allocated quads:\";\n+            dump_quads cx;\n+        end;\n+      (cx.ctxt_quads, cx.ctxt_next_spill)\n+\n+  with\n+      Ra_error s ->\n+        Session.fail sess \"RA Error: %s\" s;\n+        (quads, 0)\n+\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "01b7e29970d53310596c3ce9a966cc27088c7b66", "filename": "src/boot/be/x86.ml", "status": "added", "additions": 2205, "deletions": 0, "changes": 2205, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fx86.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fbe%2Fx86.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fbe%2Fx86.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,2205 @@\n+(*\n+ * x86/ia32 instructions have 6 parts:\n+ *\n+ *    [pre][op][modrm][sib][disp][imm]\n+ *\n+ * [pre] = 0..4 bytes of prefix\n+ * [op] = 1..3 byte opcode\n+ * [modrm] = 0 or 1 byte: [mod:2][reg/op:3][r/m:3]\n+ * [sib] = 0 or 1 byte: [scale:2][index:3][base:3]\n+ * [disp] = 1, 2 or 4 byte displacement\n+ * [imm] = 1, 2 or 4 byte immediate\n+ *\n+ * So between 1 and 17 bytes total.\n+ *\n+ * We're not going to use sib, but modrm is worth discussing.\n+ *\n+ * The high two bits of modrm denote an addressing mode. The modes are:\n+ *\n+ *   00 - \"mostly\" *(reg)\n+ *   01 - \"mostly\" *(reg) + disp8\n+ *   10 - \"mostly\" *(reg) + disp32\n+ *   11 - reg\n+ *\n+ * The next-lowest 3 bits denote a specific register, or a subopcode if\n+ * there is a fixed register or only one operand. The instruction format\n+ * reference will say \"/<n>\" for some number n, if a fixed subopcode is used.\n+ * It'll say \"/r\" if the instruction uses this field to specify a register.\n+ *\n+ * The registers specified in this field are:\n+ *\n+ *   000 - EAX or XMM0\n+ *   001 - ECX or XMM1\n+ *   010 - EDX or XMM2\n+ *   011 - EBX or XMM3\n+ *   100 - ESP or XMM4\n+ *   101 - EBP or XMM5\n+ *   110 - ESI or XMM6\n+ *   111 - EDI or XMM7\n+ *\n+ * The final low 3 bits denote sub-modes of the primary mode selected\n+ * with the top 2 bits. In particular, they \"mostly\" select the reg that is\n+ * to be used for effective address calculation.\n+ *\n+ * For the most part, these follow the same numbering order: EAX, ECX, EDX,\n+ * EBX, ESP, EBP, ESI, EDI. There are two unusual deviations from the rule\n+ * though:\n+ *\n+ *  - In primary modes 00, 01 and 10, r/m=100 means \"use SIB byte\".  You can\n+ *    use (unscaled) ESP as the base register in these modes by appending the\n+ *    SIB byte 0x24. We do that in our rm_r operand-encoder function.\n+ *\n+ *  - In primary mode 00, r/m=101 means \"just disp32\", no register is\n+ *    involved.  There is no way to use EBP in primary mode 00. If you try, we\n+ *    just decay into a mode 01 with an appended 8-bit immediate displacement.\n+ *\n+ * Some opcodes are written 0xNN +rd. This means \"we decided to chew up a\n+ * whole pile of opcodes here, with each opcode including a hard-wired\n+ * reference to a register\". For example, POP is \"0x58 +rd\", which means that\n+ * the 1-byte insns 0x58..0x5f are chewed up for \"POP EAX\" ... \"POP EDI\"\n+ * (again, the canonical order of register numberings)\n+ *)\n+\n+(*\n+ * Notes on register availability of x86:\n+ *\n+ * There are 8 GPRs but we use 2 of them for specific purposes:\n+ *\n+ *   - ESP always points to the current stack frame.\n+ *   - EBP always points to the current frame base.\n+ *\n+ * We tell IL that we have 6 GPRs then, and permit most register-register ops\n+ * on any of these 6, mostly-unconstrained.\n+ *\n+ *)\n+\n+open Common;;\n+\n+exception Unrecognized\n+;;\n+\n+let modrm m rm reg_or_subopcode =\n+  if (((m land 0b11) != m) or\n+        ((rm land 0b111) != rm) or\n+        ((reg_or_subopcode land 0b111) != reg_or_subopcode))\n+  then raise (Invalid_argument \"X86.modrm_deref\")\n+  else\n+    ((((m land 0b11) lsl 6)\n+      lor\n+      (rm land 0b111))\n+     lor\n+      ((reg_or_subopcode land 0b111) lsl 3))\n+;;\n+\n+let modrm_deref_reg = modrm 0b00 ;;\n+let modrm_deref_disp32 = modrm 0b00 0b101 ;;\n+let modrm_deref_reg_plus_disp8 = modrm 0b01 ;;\n+let modrm_deref_reg_plus_disp32 = modrm 0b10 ;;\n+let modrm_reg = modrm 0b11 ;;\n+\n+let slash0 = 0;;\n+let slash1 = 1;;\n+let slash2 = 2;;\n+let slash3 = 3;;\n+let slash4 = 4;;\n+let slash5 = 5;;\n+let slash6 = 6;;\n+let slash7 = 7;;\n+\n+\n+(*\n+ * Translate an IL-level hwreg number from 0..nregs into the 3-bit code number\n+ * used through the mod r/m byte and /r sub-register specifiers of the x86\n+ * ISA.\n+ *\n+ * See \"Table 2-2: 32-Bit Addressing Forms with the ModR/M Byte\", in the IA32\n+ * Architecture Software Developer's Manual, volume 2a.\n+ *)\n+\n+let eax = 0\n+let ecx = 1\n+let ebx = 2\n+let esi = 3\n+let edi = 4\n+let edx = 5\n+let ebp = 6\n+let esp = 7\n+\n+let code_eax = 0b000;;\n+let code_ecx = 0b001;;\n+let code_edx = 0b010;;\n+let code_ebx = 0b011;;\n+let code_esp = 0b100;;\n+let code_ebp = 0b101;;\n+let code_esi = 0b110;;\n+let code_edi = 0b111;;\n+\n+let reg r =\n+  match r with\n+      0 -> code_eax\n+    | 1 -> code_ecx\n+    | 2 -> code_ebx\n+    | 3 -> code_esi\n+    | 4 -> code_edi\n+    | 5 -> code_edx\n+        (* Never assigned by the register allocator, but synthetic code uses\n+           them *)\n+    | 6 -> code_ebp\n+    | 7 -> code_esp\n+    | _ -> raise (Invalid_argument \"X86.reg\")\n+;;\n+\n+\n+let dwarf_eax = 0;;\n+let dwarf_ecx = 1;;\n+let dwarf_edx = 2;;\n+let dwarf_ebx = 3;;\n+let dwarf_esp = 4;;\n+let dwarf_ebp = 5;;\n+let dwarf_esi = 6;;\n+let dwarf_edi = 7;;\n+\n+let dwarf_reg r =\n+  match r with\n+      0 -> dwarf_eax\n+    | 1 -> dwarf_ecx\n+    | 2 -> dwarf_ebx\n+    | 3 -> dwarf_esi\n+    | 4 -> dwarf_edi\n+    | 5 -> dwarf_edx\n+    | 6 -> dwarf_ebp\n+    | 7 -> dwarf_esp\n+    | _ -> raise (Invalid_argument \"X86.dwarf_reg\")\n+\n+let reg_str r =\n+  match r with\n+      0 -> \"eax\"\n+    | 1 -> \"ecx\"\n+    | 2 -> \"ebx\"\n+    | 3 -> \"esi\"\n+    | 4 -> \"edi\"\n+    | 5 -> \"edx\"\n+    | 6 -> \"ebp\"\n+    | 7 -> \"esp\"\n+    | _ -> raise (Invalid_argument \"X86.reg_str\")\n+;;\n+\n+(* This is a basic ABI. You might need to customize it by platform. *)\n+let (n_hardregs:int) = 6;;\n+let (n_callee_saves:int) = 4;;\n+\n+\n+let is_ty32 (ty:Il.scalar_ty) : bool =\n+  match ty with\n+      Il.ValTy (Il.Bits32) -> true\n+    | Il.AddrTy _ -> true\n+    | _ -> false\n+;;\n+\n+let is_r32 (c:Il.cell) : bool =\n+  match c with\n+      Il.Reg (_, st) -> is_ty32 st\n+    | _ -> false\n+;;\n+\n+let is_rm32 (c:Il.cell) : bool =\n+  match c with\n+      Il.Mem (_, Il.ScalarTy st) -> is_ty32 st\n+    | Il.Reg (_, st) -> is_ty32 st\n+    | _ -> false\n+;;\n+\n+let is_ty8 (ty:Il.scalar_ty) : bool =\n+  match ty with\n+      Il.ValTy (Il.Bits8) -> true\n+    | _ -> false\n+;;\n+\n+let is_m32 (c:Il.cell) : bool =\n+  match c with\n+      Il.Mem (_, Il.ScalarTy st) -> is_ty32 st\n+    | _ -> false\n+;;\n+\n+let is_m8 (c:Il.cell) : bool =\n+  match c with\n+      Il.Mem (_, Il.ScalarTy st) -> is_ty8 st\n+    | _ -> false\n+;;\n+\n+let is_ok_r8 (r:Il.hreg) : bool =\n+  (r == eax || r == ebx || r == ecx || r == edx)\n+;;\n+\n+let is_r8 (c:Il.cell) : bool =\n+  match c with\n+      Il.Reg (Il.Hreg r, st) when is_ok_r8 r -> is_ty8 st\n+    | _ -> false\n+;;\n+\n+let is_rm8 (c:Il.cell) : bool =\n+  match c with\n+      Il.Mem (_, Il.ScalarTy st) -> is_ty8 st\n+    | _ -> is_r8 c\n+;;\n+\n+let prealloc_quad (quad':Il.quad') : Il.quad' =\n+  let target_cell reg c =\n+    Il.Reg (Il.Hreg reg, Il.cell_scalar_ty c)\n+  in\n+  let target_operand reg op =\n+    Il.Cell (Il.Reg (Il.Hreg reg, Il.operand_scalar_ty op))\n+  in\n+\n+  let target_bin_to_hreg bin dst src =\n+    { bin with\n+        Il.binary_rhs = target_operand src bin.Il.binary_rhs;\n+        Il.binary_lhs = target_operand dst bin.Il.binary_lhs;\n+        Il.binary_dst = target_cell dst bin.Il.binary_dst }\n+  in\n+\n+  let target_cmp cmp =\n+    match cmp.Il.cmp_lhs with\n+        (* Immediate LHS we force to eax. *)\n+        Il.Imm _ ->\n+          { cmp with\n+              Il.cmp_lhs = target_operand eax cmp.Il.cmp_lhs }\n+      | _ -> cmp\n+  in\n+\n+    match quad' with\n+        Il.Binary bin ->\n+          begin\n+            Il.Binary\n+              begin\n+                match bin.Il.binary_op with\n+                    Il.IMUL | Il.UMUL\n+                  | Il.IDIV | Il.UDIV -> target_bin_to_hreg bin eax ecx\n+                  | Il.IMOD | Il.UMOD -> target_bin_to_hreg bin eax ecx\n+                  | _ -> bin\n+              end\n+          end\n+\n+      | Il.Cmp cmp -> Il.Cmp (target_cmp cmp)\n+\n+      | Il.Call c ->\n+          let ty = Il.cell_scalar_ty c.Il.call_dst in\n+            Il.Call { c with\n+                        Il.call_dst = Il.Reg ((Il.Hreg eax), ty) }\n+\n+      | Il.Lea le ->\n+          begin\n+            match (le.Il.lea_dst, le.Il.lea_src) with\n+                (Il.Reg (_, dst_ty), Il.ImmPtr _)\n+                  when is_ty32 dst_ty ->\n+                    Il.Lea { le with\n+                               Il.lea_dst = Il.Reg (Il.Hreg eax, dst_ty) }\n+              | _ -> quad'\n+          end\n+\n+      | x -> x\n+;;\n+\n+let constrain_vregs (q:Il.quad) (hregs:Bits.t array) : unit =\n+\n+  let involves_8bit_cell =\n+    let b = ref false in\n+    let qp_cell _ c =\n+      match c with\n+          Il.Reg (_, Il.ValTy Il.Bits8)\n+        | Il.Mem (_, Il.ScalarTy (Il.ValTy Il.Bits8)) ->\n+            (b := true; c)\n+        | _ -> c\n+    in\n+      ignore (Il.process_quad { Il.identity_processor with\n+                                  Il.qp_cell_read = qp_cell;\n+                                  Il.qp_cell_write = qp_cell } q);\n+      !b\n+  in\n+\n+  let qp_mem _ m = m in\n+  let qp_cell _ c =\n+    begin\n+      match c with\n+          Il.Reg (Il.Vreg v, _) when involves_8bit_cell ->\n+            (* 8-bit register cells must only be al, cl, dl, bl.\n+             * Not esi/edi. *)\n+            let hv = hregs.(v) in\n+              List.iter (fun bad -> Bits.set hv bad false) [esi; edi]\n+        | _ -> ()\n+    end;\n+    c\n+  in\n+    begin\n+      match q.Il.quad_body with\n+          Il.Binary b ->\n+            begin\n+              match b.Il.binary_op with\n+                  (* Shifts *)\n+                | Il.LSL | Il.LSR | Il.ASR ->\n+                    begin\n+                      match b.Il.binary_rhs with\n+                          Il.Cell (Il.Reg (Il.Vreg v, _)) ->\n+                            let hv = hregs.(v) in\n+                              (* Shift src has to be ecx. *)\n+                              List.iter\n+                                (fun bad -> Bits.set hv bad false)\n+                                [eax; edx; ebx; esi; edi]\n+                        | _ -> ()\n+                    end\n+                | _ -> ()\n+            end\n+        | _ -> ()\n+    end;\n+    ignore\n+      (Il.process_quad { Il.identity_processor with\n+                           Il.qp_mem = qp_mem;\n+                           Il.qp_cell_read = qp_cell;\n+                           Il.qp_cell_write = qp_cell } q)\n+;;\n+\n+\n+let clobbers (quad:Il.quad) : Il.hreg list =\n+  match quad.Il.quad_body with\n+      Il.Binary bin ->\n+        begin\n+          match bin.Il.binary_op with\n+              Il.IMUL | Il.UMUL\n+            | Il.IDIV | Il.UDIV -> [ edx ]\n+            | Il.IMOD | Il.UMOD -> [ edx ]\n+            | _ -> []\n+        end\n+    | Il.Unary un ->\n+        begin\n+          match un.Il.unary_op with\n+              Il.ZERO -> [ eax; edi; ecx ]\n+            | _ -> [ ]\n+        end\n+    | Il.Call _ -> [ eax; ecx; edx; ]\n+    | Il.Regfence -> [ eax; ecx; ebx; edx; edi; esi; ]\n+    | _ -> []\n+;;\n+\n+\n+let word_sz = 4L\n+;;\n+\n+let word_bits = Il.Bits32\n+;;\n+\n+let word_ty = TY_u32\n+;;\n+\n+let annotate (e:Il.emitter) (str:string) =\n+  Hashtbl.add e.Il.emit_annotations e.Il.emit_pc str\n+;;\n+\n+let c (c:Il.cell) : Il.operand = Il.Cell c ;;\n+let r (r:Il.reg) : Il.cell = Il.Reg ( r, (Il.ValTy word_bits) ) ;;\n+let h (x:Il.hreg) : Il.reg = Il.Hreg x ;;\n+let rc (x:Il.hreg) : Il.cell = r (h x) ;;\n+let ro (x:Il.hreg) : Il.operand = c (rc x) ;;\n+let vreg (e:Il.emitter) : (Il.reg * Il.cell) =\n+  let vr = Il.next_vreg e in\n+    (vr, (Il.Reg (vr, (Il.ValTy word_bits))))\n+;;\n+let imm (x:Asm.expr64) : Il.operand =\n+  Il.Imm (x, word_ty)\n+;;\n+let immi (x:int64) : Il.operand =\n+  imm (Asm.IMM x)\n+;;\n+\n+let imm_byte (x:Asm.expr64) : Il.operand =\n+  Il.Imm (x, TY_u8)\n+;;\n+let immi_byte (x:int64) : Il.operand =\n+  imm_byte (Asm.IMM x)\n+;;\n+\n+\n+let byte_off_n (i:int) : Asm.expr64 =\n+  Asm.IMM (Int64.of_int i)\n+;;\n+\n+let byte_n (reg:Il.reg) (i:int) : Il.cell =\n+  let imm = byte_off_n i in\n+  let mem = Il.RegIn (reg, Some imm) in\n+    Il.Mem (mem, Il.ScalarTy (Il.ValTy Il.Bits8))\n+;;\n+\n+let word_off_n (i:int) : Asm.expr64 =\n+  Asm.IMM (Int64.mul (Int64.of_int i) word_sz)\n+;;\n+\n+let word_at (reg:Il.reg) : Il.cell =\n+  let mem = Il.RegIn (reg, None) in\n+    Il.Mem (mem, Il.ScalarTy (Il.ValTy word_bits))\n+;;\n+\n+let word_at_off (reg:Il.reg) (off:Asm.expr64) : Il.cell =\n+  let mem = Il.RegIn (reg, Some off) in\n+    Il.Mem (mem, Il.ScalarTy (Il.ValTy word_bits))\n+;;\n+\n+let word_n (reg:Il.reg) (i:int) : Il.cell =\n+  word_at_off reg (word_off_n i)\n+;;\n+\n+let reg_codeptr (reg:Il.reg) : Il.code =\n+  Il.CodePtr (Il.Cell (Il.Reg (reg, Il.AddrTy Il.CodeTy)))\n+;;\n+\n+let word_n_low_byte (reg:Il.reg) (i:int) : Il.cell =\n+  let imm = word_off_n i in\n+  let mem = Il.RegIn (reg, Some imm) in\n+    Il.Mem (mem, Il.ScalarTy (Il.ValTy Il.Bits8))\n+;;\n+\n+let wordptr_n (reg:Il.reg) (i:int) : Il.cell =\n+  let imm = word_off_n i in\n+  let mem = Il.RegIn (reg, Some imm) in\n+    Il.Mem (mem, Il.ScalarTy (Il.AddrTy (Il.ScalarTy (Il.ValTy word_bits))))\n+;;\n+\n+let get_element_ptr = Il.get_element_ptr word_bits reg_str ;;\n+\n+let save_callee_saves (e:Il.emitter) : unit =\n+    Il.emit e (Il.Push (ro ebp));\n+    Il.emit e (Il.Push (ro edi));\n+    Il.emit e (Il.Push (ro esi));\n+    Il.emit e (Il.Push (ro ebx));\n+;;\n+\n+\n+let restore_callee_saves (e:Il.emitter) : unit =\n+    Il.emit e (Il.Pop (rc ebx));\n+    Il.emit e (Il.Pop (rc esi));\n+    Il.emit e (Il.Pop (rc edi));\n+    Il.emit e (Il.Pop (rc ebp));\n+;;\n+\n+\n+(* restores registers from the frame base without updating esp:\n+ *   - sets ebp, edi, esi, ebx to stored values from frame base\n+ *   - sets `retpc' register to stored retpc from frame base\n+ *   - sets `base' register to current fp\n+ *)\n+let restore_frame_base (e:Il.emitter) (base:Il.reg) (retpc:Il.reg) : unit =\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+    mov (r base) (ro ebp);\n+    mov (rc ebx) (c (word_at base));\n+    mov (rc esi) (c (word_n base 1));\n+    mov (rc edi) (c (word_n base 2));\n+    mov (rc ebp) (c (word_n base 3));\n+    mov (r retpc) (c (word_n base 4));\n+;;\n+\n+\n+(*\n+ * Our arrangement on x86 is this:\n+ *\n+ *   *ebp+20+(4*N) = [argN   ]\n+ *   ...\n+ *   *ebp+24       = [arg1   ] = task ptr\n+ *   *ebp+20       = [arg0   ] = out ptr\n+ *   *ebp+16       = [retpc  ]\n+ *   *ebp+12       = [old_ebp]\n+ *   *ebp+8        = [old_edi]\n+ *   *ebp+4        = [old_esi]\n+ *   *ebp          = [old_ebx]\n+ *\n+ * For x86-cdecl:\n+ *\n+ *  %eax, %ecx, %edx are \"caller save\" registers\n+ *  %ebp, %ebx, %esi, %edi are \"callee save\" registers\n+ *\n+ *)\n+\n+let frame_base_words = 5 (* eip,ebp,edi,esi,ebx *) ;;\n+let frame_base_sz = Int64.mul (Int64.of_int frame_base_words) word_sz;;\n+\n+let frame_info_words = 2 (* crate ptr, crate-rel frame info disp *) ;;\n+let frame_info_sz = Int64.mul (Int64.of_int frame_info_words) word_sz;;\n+\n+let implicit_arg_words = 2 (* task ptr,out ptr *);;\n+let implicit_args_sz =  Int64.mul (Int64.of_int implicit_arg_words) word_sz;;\n+\n+let out_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words);;\n+let task_ptr = wordptr_n (Il.Hreg ebp) (frame_base_words+1);;\n+let ty_param_n i =\n+  wordptr_n (Il.Hreg ebp) (frame_base_words + implicit_arg_words + i);;\n+\n+let spill_slot (i:Il.spill) : Il.mem =\n+  let imm = (Asm.IMM\n+               (Int64.neg\n+                  (Int64.add frame_info_sz\n+                     (Int64.mul word_sz\n+                        (Int64.of_int (i+1))))))\n+  in\n+    Il.RegIn ((Il.Hreg ebp), Some imm)\n+;;\n+\n+\n+let get_next_pc_thunk_fixup = new_fixup \"glue$get_next_pc\"\n+;;\n+\n+let emit_get_next_pc_thunk (e:Il.emitter) : unit =\n+  let sty = Il.AddrTy Il.CodeTy in\n+  let rty = Il.ScalarTy sty in\n+  let deref_esp = Il.Mem (Il.RegIn (Il.Hreg esp, None), rty) in\n+  let eax = (Il.Reg (Il.Hreg eax, sty)) in\n+    Il.emit_full e (Some get_next_pc_thunk_fixup) []\n+      (Il.umov eax (Il.Cell deref_esp));\n+    Il.emit e Il.Ret;\n+;;\n+\n+let get_next_pc_thunk : (Il.reg * fixup * (Il.emitter -> unit)) =\n+    (Il.Hreg eax, get_next_pc_thunk_fixup, emit_get_next_pc_thunk)\n+;;\n+\n+let emit_c_call\n+    (e:Il.emitter)\n+    (ret:Il.cell)\n+    (tmp1:Il.reg)\n+    (tmp2:Il.reg)\n+    (nabi:nabi)\n+    (in_prologue:bool)\n+    (fptr:Il.code)\n+    (args:Il.operand array)\n+    : unit =\n+\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n+\n+  (* rust calls get task as arg0  *)\n+  let args =\n+    if nabi.nabi_convention = CONV_rust\n+    then Array.append [| c task_ptr |] args\n+    else args\n+  in\n+  let nargs = Array.length args in\n+  let arg_sz = Int64.mul (Int64.of_int nargs) word_sz\n+  in\n+\n+    mov (r tmp1) (c task_ptr);               (* tmp1 = task from argv[-1] *)\n+    mov (r tmp2) (ro esp);                   (* tmp2 = esp                *)\n+    mov                                      (* task->rust_sp = tmp2      *)\n+      (word_n tmp1 Abi.task_field_rust_sp)\n+      (c (r tmp2));\n+    mov                                      (* esp = task->runtime_sp    *)\n+      (rc esp)\n+      (c (word_n tmp1 Abi.task_field_runtime_sp));\n+\n+    binary Il.SUB (rc esp) arg_sz;           (* make room on the stack    *)\n+    binary Il.AND (rc esp)                   (* and 16-byte align sp      *)\n+      0xfffffffffffffff0L;\n+\n+    Array.iteri\n+      begin\n+        fun i (arg:Il.operand) ->   (* write args to C stack     *)\n+          match arg with\n+              Il.Cell (Il.Mem (a, ty)) ->\n+                begin\n+                  match a with\n+                      Il.RegIn (Il.Hreg base, off) when base == esp ->\n+                        mov (r tmp1) (c (Il.Mem (Il.RegIn (tmp2, off), ty)));\n+                        mov (word_n (h esp) i) (c (r tmp1));\n+                    | _ ->\n+                        mov (r tmp1) arg;\n+                        mov (word_n (h esp) i) (c (r tmp1));\n+                end\n+            | _ ->\n+                mov (word_n (h esp) i) arg\n+      end\n+      args;\n+\n+    match ret with\n+        Il.Mem (Il.RegIn (Il.Hreg base, _), _) when base == esp ->\n+          assert (not in_prologue);\n+\n+          (* If ret is esp-relative, use a temporary register until we\n+             switched stacks. *)\n+\n+          emit (Il.call (r tmp1) fptr);\n+          mov (r tmp2) (c task_ptr);\n+          mov (rc esp) (c (word_n tmp2 Abi.task_field_rust_sp));\n+          mov ret (c (r tmp1));\n+\n+      | _ when in_prologue ->\n+          (*\n+           * We have to do something a little surprising here:\n+           * we're doing a 'grow' call so ebp is going to point\n+           * into a dead stack frame on call-return. So we\n+           * temporarily store task-ptr into ebp and then reload\n+           * esp *and* ebp via ebp->rust_sp on the other side of\n+           * the call.\n+           *)\n+          mov (rc ebp) (c task_ptr);\n+          emit (Il.call ret fptr);\n+          mov (rc esp) (c (word_n (h ebp) Abi.task_field_rust_sp));\n+          mov (rc ebp) (ro esp);\n+\n+      | _ ->\n+          emit (Il.call ret fptr);\n+          mov (r tmp2) (c task_ptr);\n+          mov (rc esp) (c (word_n tmp2 Abi.task_field_rust_sp));\n+;;\n+\n+let emit_void_prologue_call\n+    (e:Il.emitter)\n+    (nabi:nabi)\n+    (fn:fixup)\n+    (args:Il.operand array)\n+    : unit =\n+  let callee = Abi.load_fixup_codeptr e (h eax) fn true nabi.nabi_indirect in\n+    emit_c_call e (rc eax) (h edx) (h ecx) nabi true callee args\n+;;\n+\n+let emit_native_call\n+    (e:Il.emitter)\n+    (ret:Il.cell)\n+    (nabi:nabi)\n+    (fn:fixup)\n+    (args:Il.operand array)\n+    : unit =\n+\n+  let (tmp1, _) = vreg e in\n+  let (tmp2, _) = vreg e in\n+  let (freg, _) = vreg e in\n+  let callee = Abi.load_fixup_codeptr e freg fn true nabi.nabi_indirect in\n+    emit_c_call e ret tmp1 tmp2 nabi false callee args\n+;;\n+\n+let emit_native_void_call\n+    (e:Il.emitter)\n+    (nabi:nabi)\n+    (fn:fixup)\n+    (args:Il.operand array)\n+    : unit =\n+\n+  let (ret, _) = vreg e in\n+    emit_native_call e (r ret) nabi fn args\n+;;\n+\n+let emit_native_call_in_thunk\n+    (e:Il.emitter)\n+    (ret:Il.cell)\n+    (nabi:nabi)\n+    (fn:Il.operand)\n+    (args:Il.operand array)\n+    : unit =\n+\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+\n+    begin\n+      match fn with\n+          (*\n+           * NB: old path, remove when/if you're sure you don't\n+           * want native-linker-symbol-driven requirements.\n+           *)\n+          Il.ImmPtr (fix, _) ->\n+            let code =\n+              Abi.load_fixup_codeptr e (h eax) fix true nabi.nabi_indirect\n+            in\n+              emit_c_call e (rc eax) (h edx) (h ecx) nabi false code args;\n+\n+        | _ ->\n+            (*\n+             * NB: new path, ignores nabi_indirect, assumes\n+             * indirect via pointer from upcall_require_c_sym\n+             * or crate cache.\n+             *)\n+            mov (rc eax) fn;\n+            let cell = Il.Reg (h eax, Il.AddrTy Il.CodeTy) in\n+            let fptr = Il.CodePtr (Il.Cell cell) in\n+              emit_c_call e (rc eax) (h edx) (h ecx) nabi false fptr args;\n+    end;\n+\n+    match ret with\n+        Il.Reg (r, _) -> mov (word_at r) (ro eax)\n+      | _ -> mov (rc edx) (c ret);\n+          mov (word_at (h edx)) (ro eax)\n+;;\n+\n+let unwind_glue\n+    (e:Il.emitter)\n+    (nabi:nabi)\n+    (exit_task_fixup:fixup)\n+    : unit =\n+\n+  let fp_n = word_n (Il.Hreg ebp) in\n+  let edx_n = word_n (Il.Hreg edx) in\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let push x = emit (Il.Push x) in\n+  let pop x = emit (Il.Pop x) in\n+  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n+  let codefix fix = Il.CodePtr (Il.ImmPtr (fix, Il.CodeTy)) in\n+  let mark fix = Il.emit_full e (Some fix) [] Il.Dead in\n+  let glue_field = Abi.frame_glue_fns_field_drop in\n+\n+  let repeat_jmp_fix = new_fixup \"repeat jump\" in\n+  let skip_jmp_fix = new_fixup \"skip jump\" in\n+  let exit_jmp_fix = new_fixup \"exit jump\" in\n+\n+    mov (rc edx) (c task_ptr);          (* switch back to rust stack    *)\n+    mov\n+      (rc esp)\n+      (c (edx_n Abi.task_field_rust_sp));\n+\n+    mark repeat_jmp_fix;\n+\n+    mov (rc esi) (c (fp_n (-1)));       (* esi <- crate ptr             *)\n+    mov (rc edx) (c (fp_n (-2)));       (* edx <- frame glue functions. *)\n+    emit (Il.cmp (ro edx) (immi 0L));\n+\n+    emit\n+      (Il.jmp Il.JE\n+         (codefix skip_jmp_fix));       (* if struct* is nonzero        *)\n+    add edx esi;                        (* add crate ptr to disp.       *)\n+    mov\n+      (rc ecx)\n+      (c (edx_n glue_field));           (* ecx <- drop glue             *)\n+    emit (Il.cmp (ro ecx) (immi 0L));\n+\n+    emit\n+      (Il.jmp Il.JE\n+         (codefix skip_jmp_fix));       (* if glue-fn is nonzero        *)\n+    add ecx esi;                        (* add crate ptr to disp.       *)\n+    push (ro ebp);                      (* frame-to-drop                *)\n+    push (c task_ptr);                  (* form usual call to glue      *)\n+    push (immi 0L);                     (* outptr                       *)\n+    emit (Il.call (rc eax)\n+            (reg_codeptr (h ecx)));     (* call glue_fn, trashing eax.  *)\n+    pop (rc eax);\n+    pop (rc eax);\n+    pop (rc eax);\n+\n+    mark skip_jmp_fix;\n+    mov (rc edx) (c (fp_n 3));          (* load next fp (callee-saves[3]) *)\n+    emit (Il.cmp (ro edx) (immi 0L));\n+    emit (Il.jmp Il.JE\n+            (codefix exit_jmp_fix));    (* if nonzero                     *)\n+    mov (rc ebp) (ro edx);              (* move to next frame             *)\n+    emit (Il.jmp Il.JMP\n+            (codefix repeat_jmp_fix));  (* loop                           *)\n+\n+    (* exit path. *)\n+    mark exit_jmp_fix;\n+\n+    let callee =\n+      Abi.load_fixup_codeptr\n+        e (h eax) exit_task_fixup false nabi.nabi_indirect\n+    in\n+      emit_c_call\n+        e (rc eax) (h edx) (h ecx) nabi false callee [| (c task_ptr) |];\n+;;\n+\n+(* Puts result in eax; clobbers ecx, edx in the process. *)\n+let rec calculate_sz (e:Il.emitter) (size:size) : unit =\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let push x = emit (Il.Push x) in\n+  let pop x = emit (Il.Pop x) in\n+  let neg x = emit (Il.unary Il.NEG (rc x) (ro x)) in\n+  let bnot x = emit (Il.unary Il.NOT (rc x) (ro x)) in\n+  let band x y = emit (Il.binary Il.AND (rc x) (ro x) (ro y)) in\n+  let add x y = emit (Il.binary Il.ADD (rc x) (ro x) (ro y)) in\n+  let mul x y = emit (Il.binary Il.UMUL (rc x) (ro x) (ro y)) in\n+  let subi x y = emit (Il.binary Il.SUB (rc x) (ro x) (immi y)) in\n+  let eax_gets_a_and_ecx_gets_b a b =\n+    calculate_sz e b;\n+    push (ro eax);\n+    calculate_sz e a;\n+    pop (rc ecx);\n+  in\n+    match size with\n+        SIZE_fixed i ->\n+          mov (rc eax) (immi i)\n+\n+      | SIZE_fixup_mem_sz f ->\n+          mov (rc eax) (imm (Asm.M_SZ f))\n+\n+      | SIZE_fixup_mem_pos f ->\n+          mov (rc eax) (imm (Asm.M_POS f))\n+\n+      | SIZE_param_size i ->\n+          mov (rc eax) (Il.Cell (ty_param_n i));\n+          mov (rc eax) (Il.Cell (word_n (h eax) Abi.tydesc_field_size))\n+\n+      | SIZE_param_align i ->\n+          mov (rc eax) (Il.Cell (ty_param_n i));\n+          mov (rc eax) (Il.Cell (word_n (h eax) Abi.tydesc_field_align))\n+\n+      | SIZE_rt_neg a ->\n+          calculate_sz e a;\n+          neg eax\n+\n+      | SIZE_rt_add (a, b) ->\n+          eax_gets_a_and_ecx_gets_b a b;\n+          add eax ecx\n+\n+      | SIZE_rt_mul (a, b) ->\n+          eax_gets_a_and_ecx_gets_b a b;\n+          mul eax ecx\n+\n+      | SIZE_rt_max (a, b) ->\n+          eax_gets_a_and_ecx_gets_b a b;\n+          emit (Il.cmp (ro eax) (ro ecx));\n+          let jmp_pc = e.Il.emit_pc in\n+            emit (Il.jmp Il.JAE Il.CodeNone);\n+            mov (rc eax) (ro ecx);\n+            Il.patch_jump e jmp_pc e.Il.emit_pc;\n+\n+      | SIZE_rt_align (align, off) ->\n+          (*\n+           * calculate off + pad where:\n+           *\n+           * pad = (align - (off mod align)) mod align\n+           *\n+           * In our case it's always a power of two, \n+           * so we can just do:\n+           * \n+           * mask = align-1\n+           * off += mask\n+           * off &= ~mask\n+           * \n+           *)\n+          eax_gets_a_and_ecx_gets_b off align;\n+          subi ecx 1L;\n+          add eax ecx;\n+          bnot ecx;\n+          band eax ecx;\n+;;\n+\n+let rec size_calculation_stack_highwater (size:size) : int =\n+  match size with\n+      SIZE_fixed _\n+    | SIZE_fixup_mem_sz _\n+    | SIZE_fixup_mem_pos _\n+    | SIZE_param_size _\n+    | SIZE_param_align _ -> 0\n+    | SIZE_rt_neg a  ->\n+        (size_calculation_stack_highwater a)\n+    | SIZE_rt_max (a, b) ->\n+        (size_calculation_stack_highwater a)\n+        + (size_calculation_stack_highwater b)\n+    | SIZE_rt_add (a, b)\n+    | SIZE_rt_mul (a, b)\n+    | SIZE_rt_align (a, b) ->\n+        (size_calculation_stack_highwater a)\n+        + (size_calculation_stack_highwater b)\n+        + 1\n+;;\n+\n+let boundary_sz =\n+  (Asm.IMM\n+     (Int64.add                   (* Extra non-frame room:           *)\n+        frame_base_sz             (* to safely enter the next frame, *)\n+        frame_base_sz))           (* and make a 'grow' upcall there. *)\n+;;\n+\n+let stack_growth_check\n+    (e:Il.emitter)\n+    (nabi:nabi)\n+    (grow_task_fixup:fixup)\n+    (growsz:Il.operand)\n+    (grow_jmp:Il.label option)\n+    (restart_pc:Il.label)\n+    (end_reg:Il.reg)              (* \n+                                   * stack limit on entry,\n+                                   * new stack pointer on exit \n+                                   *)\n+    (tmp_reg:Il.reg)              (* temporary (trashed) *)\n+    : unit =\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n+  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n+    mov (r tmp_reg) (ro esp);         (* tmp = esp                 *)\n+    sub (r tmp_reg) growsz;           (* tmp -= size-request       *)\n+    emit (Il.cmp (c (r end_reg)) (c (r tmp_reg)));\n+    (* \n+     * Jump *over* 'grow' upcall on non-underflow:\n+     * if end_reg <= tmp_reg\n+     *)\n+\n+    let bypass_grow_upcall_jmp_pc = e.Il.emit_pc in\n+      emit (Il.jmp Il.JBE Il.CodeNone);\n+\n+      begin\n+        match grow_jmp with\n+            None -> ()\n+          | Some j -> Il.patch_jump e j e.Il.emit_pc\n+      end;\n+      (* Extract growth-amount from tmp_reg. *)\n+      mov (r end_reg) (ro esp);\n+      sub (r end_reg) (c (r tmp_reg));\n+      add (r end_reg) (Il.Imm (boundary_sz, word_ty));\n+      (* Perform 'grow' upcall, then restart frame-entry. *)\n+      emit_void_prologue_call e nabi grow_task_fixup [| c (r end_reg) |];\n+      emit (Il.jmp Il.JMP (Il.CodeLabel restart_pc));\n+      Il.patch_jump e bypass_grow_upcall_jmp_pc e.Il.emit_pc\n+;;\n+\n+let fn_prologue\n+    (e:Il.emitter)\n+    (framesz:size)\n+    (callsz:size)\n+    (nabi:nabi)\n+    (grow_task_fixup:fixup)\n+    : unit =\n+\n+  let esi_n = word_n (h esi) in\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let add dst src = emit (Il.binary Il.ADD dst (Il.Cell dst) src) in\n+  let sub dst src = emit (Il.binary Il.SUB dst (Il.Cell dst) src) in\n+\n+  (* We may be in a dynamic-sized frame. This makes matters complex,\n+   * as we can't just perform a simple growth check in terms of a\n+   * static size. The check is against a dynamic size, and we need to\n+   * calculate that size.\n+   *\n+   * Unlike size-calculations in 'trans', we do not use vregs to\n+   * calculate the frame size; instead we use a PUSH/POP stack-machine\n+   * translation that doesn't disturb the registers we're\n+   * somewhat-carefully *using* during frame setup.\n+   *\n+   * This only pushes the problem back a little ways though: we still\n+   * need to be sure we have enough room to do the PUSH/POP\n+   * calculation.  We refer to this amount of space as the 'primordial'\n+   * frame size, which can *thankfully* be calculated exactly from the\n+   * arithmetic expression we're aiming to calculate. So we make room\n+   * for the primordial frame, run the calculation of the full dynamic\n+   * frame size, then make room *again* for this dynamic size.\n+   *\n+   * Our caller reserved enough room for us to push our own frame-base,\n+   * as well as the frame-base that it will cost to do an upcall.\n+   *)\n+\n+  (*\n+   *  After we save callee-saves, We have a stack like this:\n+   *\n+   *  | ...           |\n+   *  | caller frame  |\n+   *  | + spill       |\n+   *  | caller arg K  |\n+   *  | ...           |\n+   *  | caller arg 0  |\n+   *  | retpc         | <-- sp we received, top of callee frame\n+   *  | callee save 1 |\n+   *  | ...           |\n+   *  | callee save N | <-- ebp and esp after saving callee-saves\n+   *  | ...           |\n+   *  | callee frame  |\n+   *  | + spill       |\n+   *  | callee arg J  |\n+   *  | ...           |\n+   *  | callee arg 0  | <-- bottom of callee frame\n+   *  | next retpc    |\n+   *  | next save 1   |\n+   *  | ...           |\n+   *  | next save N   | <-- bottom of region we must reserve\n+   *  | ...           |\n+   *\n+   * A \"frame base\" is the retpc and set of callee-saves.\n+   *\n+   * We need to reserve room for our frame *and* the next frame-base, because\n+   * we're going to be blindly entering the next frame-base (pushing eip and\n+   * callee-saves) before we perform the next check.\n+   *)\n+\n+  (*\n+   * We double the reserved callsz because we need a 'temporary tail-call\n+   * region' above the actual call region, in case there's a drop call at the\n+   * end of assembling the tail-call args and before copying them to callee\n+   * position.\n+   *)\n+\n+  let callsz = add_sz callsz callsz in\n+  let n_glue_args = Int64.of_int Abi.worst_case_glue_call_args in\n+  let n_glue_words = Int64.mul word_sz n_glue_args in\n+\n+  (*\n+   * Add in *another* word to handle an extra-awkward spill of the\n+   * callee address that might occur during an indirect tail call.\n+   *)\n+  let callsz = add_sz (SIZE_fixed word_sz) callsz in\n+\n+  (*\n+   * Add in enough words for a glue-call (these occur underneath esp)\n+   *)\n+  let callsz = add_sz (SIZE_fixed n_glue_words) callsz in\n+\n+  (*\n+   * Cumulative dynamic-frame size.\n+   *)\n+  let call_and_frame_sz = add_sz callsz framesz in\n+\n+    (* Already have room to save regs on entry. *)\n+    save_callee_saves e;\n+\n+    let restart_pc = e.Il.emit_pc in\n+\n+      mov (rc ebp) (ro esp);             (* Establish frame base.     *)\n+      mov (rc esi) (c task_ptr);         (* esi = task                *)\n+      mov\n+        (rc esi)\n+        (c (esi_n Abi.task_field_stk));  (* esi = task->stk           *)\n+      add (rc esi) (imm\n+                      (Asm.ADD\n+                         ((word_off_n Abi.stk_field_data),\n+                          boundary_sz)));\n+\n+      let (dynamic_frame_sz, dynamic_grow_jmp) =\n+        match Il.size_to_expr64 call_and_frame_sz with\n+            None ->\n+              begin\n+                let primordial_frame_sz =\n+                  Asm.IMM\n+                    (Int64.mul word_sz\n+                       (Int64.of_int\n+                          (size_calculation_stack_highwater\n+                             call_and_frame_sz)))\n+                in\n+                  (* Primordial size-check. *)\n+                  mov (rc edi) (ro esp);  (* edi = esp            *)\n+                  sub                     (* edi -= size-request  *)\n+                    (rc edi)\n+                    (imm primordial_frame_sz);\n+                  emit (Il.cmp (ro esi) (ro edi));\n+\n+                  (* Jump to 'grow' upcall on underflow: if esi (bottom) is >\n+                     edi (proposed-esp) *)\n+\n+                  let primordial_underflow_jmp_pc = e.Il.emit_pc in\n+                    emit (Il.jmp Il.JA Il.CodeNone);\n+\n+                    (* Calculate dynamic frame size. *)\n+                    calculate_sz e call_and_frame_sz;\n+                    ((ro eax), Some primordial_underflow_jmp_pc)\n+              end\n+          | Some e -> ((imm e), None)\n+      in\n+\n+        (* \"Full\" frame size-check. *)\n+        stack_growth_check e nabi grow_task_fixup\n+          dynamic_frame_sz dynamic_grow_jmp restart_pc (h esi) (h edi);\n+\n+\n+        (* Establish a frame, wherever we landed. *)\n+        sub (rc esp) dynamic_frame_sz;\n+\n+        (* Zero the frame.\n+         *\n+         * FIXME: this is awful, will go away when we have proper CFI.\n+         *)\n+\n+        mov (rc edi) (ro esp);\n+        mov (rc ecx) dynamic_frame_sz;\n+        emit (Il.unary Il.ZERO (word_at (h edi)) (ro ecx));\n+\n+        (* Move esp back up over the glue region. *)\n+        add (rc esp) (immi n_glue_words);\n+;;\n+\n+\n+let fn_epilogue (e:Il.emitter) : unit =\n+\n+  (* Tear down existing frame. *)\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+    mov (rc esp) (ro ebp);\n+    restore_callee_saves e;\n+    emit Il.Ret;\n+;;\n+\n+let inline_memcpy\n+    (e:Il.emitter)\n+    (n_bytes:int64)\n+    (dst_ptr:Il.reg)\n+    (src_ptr:Il.reg)\n+    (tmp_reg:Il.reg)\n+    (ascending:bool)\n+    : unit =\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let bpw = Int64.to_int word_sz in\n+  let w = Int64.to_int (Int64.div n_bytes word_sz) in\n+  let b = Int64.to_int (Int64.rem n_bytes word_sz) in\n+    if ascending\n+    then\n+      begin\n+        for i = 0 to (w-1) do\n+          mov (r tmp_reg) (c (word_n src_ptr i));\n+          mov (word_n dst_ptr i) (c (r tmp_reg));\n+        done;\n+        for i = 0 to (b-1) do\n+          let off = (w*bpw) + i in\n+            mov (r tmp_reg) (c (byte_n src_ptr off));\n+            mov (byte_n dst_ptr off) (c (r tmp_reg));\n+        done;\n+      end\n+    else\n+      begin\n+        for i = (b-1) downto 0 do\n+          let off = (w*bpw) + i in\n+            mov (r tmp_reg) (c (byte_n src_ptr off));\n+            mov (byte_n dst_ptr off) (c (r tmp_reg));\n+        done;\n+        for i = (w-1) downto 0 do\n+          mov (r tmp_reg) (c (word_n src_ptr i));\n+          mov (word_n dst_ptr i) (c (r tmp_reg));\n+        done;\n+      end\n+;;\n+\n+\n+\n+let fn_tail_call\n+    (e:Il.emitter)\n+    (caller_callsz:int64)\n+    (caller_argsz:int64)\n+    (callee_code:Il.code)\n+    (callee_argsz:int64)\n+    : unit =\n+  let emit = Il.emit e in\n+  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let argsz_diff = Int64.sub caller_argsz callee_argsz in\n+  let callee_spill_cell = word_at_off (h esp) (Asm.IMM caller_callsz) in\n+\n+    (*\n+     * Our outgoing arguments were prepared in a region above the call region;\n+     * this is reserved for the purpose of making tail-calls *only*, so we do\n+     * not collide with glue calls we had to make while dropping the frame,\n+     * after assembling our arg region.\n+     *\n+     * Thus, esp points to the \"normal\" arg region, and we need to move it\n+     * to point to the tail-call arg region. To make matters simple, both\n+     * regions are the same size, one atop the other.\n+     *)\n+\n+    annotate e \"tail call: move esp to temporary tail call arg-prep area\";\n+    binary Il.ADD (rc esp) caller_callsz;\n+\n+    (*\n+     * If we're given a non-ImmPtr callee, we may need to move it to a known\n+     * cell to avoid clobbering its register while we do the argument shuffle\n+     * below.\n+     *\n+     * Sadly, we are too register-starved to just flush our callee to a reg;\n+     * so we carve out an extra word of the temporary call-region and use\n+     * it.\n+     *\n+     * This is ridiculous, but works.\n+     *)\n+    begin\n+      match callee_code with\n+          Il.CodePtr (Il.Cell c) ->\n+              annotate e \"tail call: spill callee-ptr to temporary memory\";\n+              mov callee_spill_cell (Il.Cell c);\n+\n+        | _ -> ()\n+    end;\n+\n+    (* edx <- ebp; restore ebp, edi, esi, ebx; ecx <- retpc *)\n+    annotate e \"tail call: restore callee-saves from frame base\";\n+    restore_frame_base e (h edx) (h ecx);\n+    (* move edx past frame base and adjust for difference in call sizes *)\n+    annotate e \"tail call: adjust temporary fp\";\n+    binary Il.ADD (rc edx) (Int64.add frame_base_sz argsz_diff);\n+\n+    (*\n+     * stack grows downwards; copy from high to low\n+     *\n+     *   bpw = word_sz\n+     *   w = floor(callee_argsz / word_sz)\n+     *   b = callee_argsz % word_sz\n+     *\n+     * byte copies:\n+     *   +------------------------+\n+     *   |                        |\n+     *   +------------------------+ <-- base + (w * word_sz) + (b - 1)\n+     *   .                        .\n+     *   +------------------------+\n+     *   |                        |\n+     *   +------------------------+ <-- base + (w * word_sz) + (b - b)\n+     * word copies:                     =\n+     *   +------------------------+ <-- base + ((w-0) * word_sz)\n+     *   | bytes                  |\n+     *   | (w-1)*bpw..w*bpw-1     |\n+     *   +------------------------+ <-- base + ((w-1) * word_sz)\n+     *   | bytes                  |\n+     *   | (w-2)*bpw..(w-1)*bpw-1 |\n+     *   +------------------------+ <-- base + ((w-2) * word_sz)\n+     *   .                        .\n+     *   .                        .\n+     *   .                        .\n+     *   +------------------------+\n+     *   | bytes                  |\n+     *   | 0..bpw - 1             |\n+     *   +------------------------+ <-- base + ((w-w) * word_sz)\n+     *)\n+\n+    annotate e \"tail call: move arg-tuple up to top of frame\";\n+    (* NOTE: must copy top-to-bottom in case the regions overlap *)\n+    inline_memcpy e callee_argsz (h edx) (h esp) (h eax) false;\n+\n+    (*\n+     * We're done with eax now; so in the case where we had to spill\n+     * our callee codeptr, we can reload it into eax here and rewrite\n+     * our callee into *eax.\n+     *)\n+    let callee_code =\n+      match callee_code with\n+          Il.CodePtr (Il.Cell _) ->\n+              annotate e \"tail call: reload callee-ptr from temporary memory\";\n+              mov (rc eax) (Il.Cell callee_spill_cell);\n+              reg_codeptr (h eax)\n+\n+        | _ -> callee_code\n+    in\n+\n+\n+    (* esp <- edx *)\n+    annotate e \"tail call: adjust stack pointer\";\n+    mov (rc esp) (ro edx);\n+    (* PUSH ecx (retpc) *)\n+    annotate e \"tail call: push retpc\";\n+    emit (Il.Push (ro ecx));\n+    (* JMP callee_code *)\n+    emit (Il.jmp Il.JMP callee_code);\n+;;\n+\n+\n+let loop_info_field_retpc = 0;;\n+let loop_info_field_sp = 1;;\n+let loop_info_field_fp = 2;;\n+\n+let self_args_cell (self_args_rty:Il.referent_ty) : Il.cell =\n+  Il.Mem (Il.RegIn (h ebp, Some (Asm.IMM frame_base_sz)), self_args_rty)\n+;;\n+\n+let activate_glue (e:Il.emitter) : unit =\n+  (*\n+   * This is a bit of glue-code. It should be emitted once per\n+   * compilation unit.\n+   *\n+   *   - save regs on C stack\n+   *   - align sp on a 16-byte boundary\n+   *   - save sp to task.runtime_sp (runtime_sp is thus always aligned)\n+   *   - load saved task sp (switch stack)\n+   *   - restore saved task regs\n+   *   - return to saved task pc\n+   *\n+   * Our incoming stack looks like this:\n+   *\n+   *   *esp+4        = [arg1   ] = task ptr\n+   *   *esp          = [retpc  ]\n+   *)\n+\n+  let sp_n = word_n (Il.Hreg esp) in\n+  let edx_n = word_n (Il.Hreg edx) in\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let binary op dst imm = emit (Il.binary op dst (c dst) (immi imm)) in\n+\n+    mov (rc edx) (c (sp_n 1));            (* edx <- task             *)\n+    save_callee_saves e;\n+    mov\n+      (edx_n Abi.task_field_runtime_sp)\n+      (ro esp);                           (* task->runtime_sp <- esp *)\n+    mov\n+      (rc esp)\n+      (c (edx_n Abi.task_field_rust_sp)); (* esp <- task->rust_sp    *)\n+\n+    (*\n+     * There are two paths we can arrive at this code from:\n+     *\n+     *\n+     *   1. We are activating a task for the first time. When we switch into\n+     *      the task stack and 'ret' to its first instruction, we'll start\n+     *      doing whatever the first instruction says. Probably saving\n+     *      registers and starting to establish a frame. Harmless stuff,\n+     *      doesn't look at task->rust_sp again except when it clobbers it\n+     *      during a later upcall.\n+     *\n+     *\n+     *   2. We are resuming a task that was descheduled by the yield glue\n+     *      below.  When we switch into the task stack and 'ret', we'll be\n+     *      ret'ing to a very particular instruction:\n+     *\n+     *              \"esp <- task->rust_sp\"\n+     *\n+     *      this is the first instruction we 'ret' to after this glue, because\n+     *      it is the first instruction following *any* upcall, and the task\n+     *      we are activating was descheduled mid-upcall.\n+     *\n+     *      Unfortunately for us, we have already restored esp from\n+     *      task->rust_sp and are about to eat the 5 words off the top of it.\n+     *\n+     *\n+     *      | ...    | <-- where esp will be once we restore + ret, below,\n+     *      | retpc  |     and where we'd *like* task->rust_sp to wind up.\n+     *      | ebp    |\n+     *      | edi    |\n+     *      | esi    |\n+     *      | ebx    | <-- current task->rust_sp == current esp\n+     *\n+     * \n+     *      This is a problem. If we return to \"esp <- task->rust_sp\" it will\n+     *      push esp back down by 5 words. This manifests as a rust stack that\n+     *      grows by 5 words on each yield/reactivate. Not good.\n+     * \n+     *      So what we do here is just adjust task->rust_sp up 5 words as\n+     *      well, to mirror the movement in esp we're about to perform. That\n+     *      way the \"esp <- task->rust_sp\" we 'ret' to below will be a\n+     *      no-op. Esp won't move, and the task's stack won't grow.\n+     *)\n+\n+    binary Il.ADD (edx_n Abi.task_field_rust_sp)\n+      (Int64.mul (Int64.of_int (n_callee_saves + 1)) word_sz);\n+\n+    (**** IN TASK STACK ****)\n+    restore_callee_saves e;\n+    emit Il.Ret;\n+    (***********************)\n+  ()\n+;;\n+\n+let yield_glue (e:Il.emitter) : unit =\n+\n+  (* More glue code, this time the 'bottom half' of yielding.\n+   *\n+   * We arrived here because an upcall decided to deschedule the\n+   * running task. So the upcall's return address got patched to the\n+   * first instruction of this glue code.\n+   *\n+   * When the upcall does 'ret' it will come here, and its esp will be\n+   * pointing to the last argument pushed on the C stack before making\n+   * the upcall: the 0th argument to the upcall, which is always the\n+   * task ptr performing the upcall. That's where we take over.\n+   *\n+   * Our goal is to complete the descheduling\n+   *\n+   *   - Switch over to the task stack temporarily.\n+   *\n+   *   - Save the task's callee-saves onto the task stack.\n+   *     (the task is now 'descheduled', safe to set aside)\n+   *\n+   *   - Switch *back* to the C stack.\n+   *\n+   *   - Restore the C-stack callee-saves.\n+   *\n+   *   - Return to the caller on the C stack that activated the task.\n+   *\n+   *)\n+  let esp_n = word_n (Il.Hreg esp) in\n+  let edx_n = word_n (Il.Hreg edx) in\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+\n+    mov\n+      (rc edx) (c (esp_n 0));                (* edx <- arg0 (task)      *)\n+    mov\n+      (rc esp)\n+      (c (edx_n Abi.task_field_rust_sp));    (* esp <- task->rust_sp    *)\n+    save_callee_saves e;\n+    mov                                      (* task->rust_sp <- esp    *)\n+      (edx_n Abi.task_field_rust_sp)\n+      (ro esp);\n+    mov\n+      (rc esp)\n+      (c (edx_n Abi.task_field_runtime_sp)); (* esp <- task->runtime_sp *)\n+\n+    (**** IN C STACK ****)\n+    restore_callee_saves e;\n+    emit Il.Ret;\n+    (***********************)\n+  ()\n+;;\n+\n+\n+let push_pos32 (e:Il.emitter) (fix:fixup) : unit =\n+  let (reg, _, _) = get_next_pc_thunk in\n+    Abi.load_fixup_addr e reg fix Il.OpaqueTy;\n+    Il.emit e (Il.Push (Il.Cell (Il.Reg (reg, Il.AddrTy Il.OpaqueTy))))\n+;;\n+\n+let objfile_start\n+    (e:Il.emitter)\n+    ~(start_fixup:fixup)\n+    ~(rust_start_fixup:fixup)\n+    ~(main_fn_fixup:fixup)\n+    ~(crate_fixup:fixup)\n+    ~(indirect_start:bool)\n+    : unit =\n+  let ebp_n = word_n (Il.Hreg ebp) in\n+  let emit = Il.emit e in\n+  let mov dst src = emit (Il.umov dst src) in\n+  let push_pos32 = push_pos32 e in\n+    Il.emit_full e (Some start_fixup) [] Il.Dead;\n+    save_callee_saves e;\n+    mov (rc ebp) (ro esp);\n+\n+    (* If we're very lucky, the platform will have left us with\n+     * something sensible in the startup stack like so:\n+     * \n+     *   *ebp+24       = [arg1   ] = argv\n+     *   *ebp+20       = [arg0   ] = argc\n+     *   *ebp+16       = [retpc  ]\n+     *   *ebp+12       = [old_ebp]\n+     *   *ebp+8        = [old_edi]\n+     *   *ebp+4        = [old_esi]\n+     *   *ebp          = [old_ebx]\n+     * \n+     * This is not the case everywhere, but we start with this\n+     * assumption and correct it in the runtime library.\n+     *)\n+\n+    (* Copy argv. *)\n+    mov (rc eax) (c (ebp_n (2 + n_callee_saves)));\n+    Il.emit e (Il.Push (ro eax));\n+\n+    (* Copy argc. *)\n+    mov (rc eax) (c (ebp_n (1 + n_callee_saves)));\n+    Il.emit e (Il.Push (ro eax));\n+\n+    push_pos32 crate_fixup;\n+    push_pos32 main_fn_fixup;\n+    let fptr =\n+      Abi.load_fixup_codeptr e (h eax) rust_start_fixup true indirect_start\n+    in\n+      Il.emit e (Il.call (rc eax) fptr);\n+      Il.emit e (Il.Pop (rc ecx));\n+      Il.emit e (Il.Pop (rc ecx));\n+      Il.emit e (Il.Pop (rc ecx));\n+      Il.emit e (Il.Pop (rc ecx));\n+      Il.emit e (Il.umov (rc esp) (ro ebp));\n+      restore_callee_saves e;\n+      Il.emit e Il.Ret;\n+;;\n+\n+let (abi:Abi.abi) =\n+  {\n+    Abi.abi_word_sz = word_sz;\n+    Abi.abi_word_bits = word_bits;\n+    Abi.abi_word_ty = word_ty;\n+\n+    Abi.abi_is_2addr_machine = true;\n+    Abi.abi_has_pcrel_data = false;\n+    Abi.abi_has_pcrel_code = true;\n+\n+    Abi.abi_n_hardregs = n_hardregs;\n+    Abi.abi_str_of_hardreg = reg_str;\n+    Abi.abi_prealloc_quad = prealloc_quad;\n+    Abi.abi_constrain_vregs = constrain_vregs;\n+\n+    Abi.abi_emit_fn_prologue = fn_prologue;\n+    Abi.abi_emit_fn_epilogue = fn_epilogue;\n+    Abi.abi_emit_fn_tail_call = fn_tail_call;\n+    Abi.abi_clobbers = clobbers;\n+\n+    Abi.abi_emit_native_call = emit_native_call;\n+    Abi.abi_emit_native_void_call = emit_native_void_call;\n+    Abi.abi_emit_native_call_in_thunk = emit_native_call_in_thunk;\n+    Abi.abi_emit_inline_memcpy = inline_memcpy;\n+\n+    Abi.abi_activate = activate_glue;\n+    Abi.abi_yield = yield_glue;\n+    Abi.abi_unwind = unwind_glue;\n+    Abi.abi_get_next_pc_thunk = Some get_next_pc_thunk;\n+\n+    Abi.abi_sp_reg = (Il.Hreg esp);\n+    Abi.abi_fp_reg = (Il.Hreg ebp);\n+    Abi.abi_dwarf_fp_reg = dwarf_ebp;\n+    Abi.abi_tp_cell = task_ptr;\n+    Abi.abi_frame_base_sz = frame_base_sz;\n+    Abi.abi_frame_info_sz = frame_info_sz;\n+    Abi.abi_implicit_args_sz = implicit_args_sz;\n+    Abi.abi_spill_slot = spill_slot;\n+  }\n+\n+\n+(*\n+ * NB: factor the instruction selector often. There's lots of\n+ * semi-redundancy in the ISA.\n+ *)\n+\n+\n+let imm_is_signed_byte (n:int64) : bool =\n+  (i64_le (-128L) n) && (i64_le n 127L)\n+;;\n+\n+let imm_is_unsigned_byte (n:int64) : bool =\n+  (i64_le (0L) n) && (i64_le n 255L)\n+;;\n+\n+\n+let rm_r (c:Il.cell) (r:int) : Asm.frag =\n+  let reg_ebp = 6 in\n+  let reg_esp = 7 in\n+\n+  (*\n+   * We do a little contortion here to accommodate the special case of\n+   * being asked to form esp-relative addresses; these require SIB\n+   * bytes on x86. Of course!\n+   *)\n+  let sib_esp_base = Asm.BYTE 0x24 in\n+  let seq1 rm modrm =\n+    if rm = reg_esp\n+    then Asm.SEQ [| modrm; sib_esp_base |]\n+    else modrm\n+  in\n+  let seq2 rm modrm disp =\n+    if rm = reg_esp\n+    then Asm.SEQ [| modrm; sib_esp_base; disp |]\n+    else Asm.SEQ [| modrm; disp |]\n+  in\n+\n+    match c with\n+        Il.Reg ((Il.Hreg rm), _) ->\n+          Asm.BYTE (modrm_reg (reg rm) r)\n+      | Il.Mem (a, _) ->\n+          begin\n+            match a with\n+                Il.Abs disp ->\n+                  Asm.SEQ [| Asm.BYTE (modrm_deref_disp32 r);\n+                             Asm.WORD (TY_i32, disp) |]\n+\n+              | Il.RegIn ((Il.Hreg rm), None) when rm != reg_ebp ->\n+                  seq1 rm (Asm.BYTE (modrm_deref_reg (reg rm) r))\n+\n+              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM 0L))\n+                  when rm != reg_ebp ->\n+                  seq1 rm (Asm.BYTE (modrm_deref_reg (reg rm) r))\n+\n+              (* The next two are just to save the relaxation system some\n+               * churn.\n+               *)\n+\n+              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM n))\n+                  when imm_is_signed_byte n ->\n+                  seq2 rm\n+                    (Asm.BYTE (modrm_deref_reg_plus_disp8 (reg rm) r))\n+                    (Asm.WORD (TY_i8, Asm.IMM n))\n+\n+              | Il.RegIn ((Il.Hreg rm), Some (Asm.IMM n)) ->\n+                  seq2 rm\n+                    (Asm.BYTE (modrm_deref_reg_plus_disp32 (reg rm) r))\n+                    (Asm.WORD (TY_i32, Asm.IMM n))\n+\n+              | Il.RegIn ((Il.Hreg rm), Some disp) ->\n+                  Asm.new_relaxation\n+                    [|\n+                      seq2 rm\n+                        (Asm.BYTE (modrm_deref_reg_plus_disp32 (reg rm) r))\n+                        (Asm.WORD (TY_i32, disp));\n+                      seq2 rm\n+                        (Asm.BYTE (modrm_deref_reg_plus_disp8 (reg rm) r))\n+                        (Asm.WORD (TY_i8, disp))\n+                    |]\n+              | _ -> raise Unrecognized\n+          end\n+      | _ -> raise Unrecognized\n+;;\n+\n+\n+let insn_rm_r (op:int) (c:Il.cell) (r:int) : Asm.frag =\n+  Asm.SEQ [| Asm.BYTE op; rm_r c r |]\n+;;\n+\n+\n+let insn_rm_r_imm\n+    (op:int)\n+    (c:Il.cell)\n+    (r:int)\n+    (ty:ty_mach)\n+    (i:Asm.expr64)\n+    : Asm.frag =\n+  Asm.SEQ [| Asm.BYTE op; rm_r c r; Asm.WORD (ty, i) |]\n+;;\n+\n+let insn_rm_r_imm_s8_s32\n+    (op8:int)\n+    (op32:int)\n+    (c:Il.cell)\n+    (r:int)\n+    (i:Asm.expr64)\n+    : Asm.frag =\n+  match i with\n+      Asm.IMM n when imm_is_signed_byte n ->\n+        insn_rm_r_imm op8 c r TY_i8 i\n+    | _ ->\n+        Asm.new_relaxation\n+          [|\n+            insn_rm_r_imm op32 c r TY_i32 i;\n+            insn_rm_r_imm op8 c r TY_i8 i\n+          |]\n+;;\n+\n+let insn_rm_r_imm_u8_u32\n+    (op8:int)\n+    (op32:int)\n+    (c:Il.cell)\n+    (r:int)\n+    (i:Asm.expr64)\n+    : Asm.frag =\n+  match i with\n+      Asm.IMM n when imm_is_unsigned_byte n ->\n+        insn_rm_r_imm op8 c r TY_u8 i\n+    | _ ->\n+        Asm.new_relaxation\n+          [|\n+            insn_rm_r_imm op32 c r TY_u32 i;\n+            insn_rm_r_imm op8 c r TY_u8 i\n+          |]\n+;;\n+\n+\n+let insn_pcrel_relax\n+    (op8_frag:Asm.frag)\n+    (op32_frag:Asm.frag)\n+    (fix:fixup)\n+    : Asm.frag =\n+  let pcrel_mark_fixup = new_fixup \"pcrel mark fixup\" in\n+  let def = Asm.DEF (pcrel_mark_fixup, Asm.MARK) in\n+  let pcrel_expr = (Asm.SUB (Asm.M_POS fix,\n+                             Asm.M_POS pcrel_mark_fixup))\n+  in\n+    Asm.new_relaxation\n+      [|\n+        Asm.SEQ [| op32_frag; Asm.WORD (TY_i32, pcrel_expr); def |];\n+        Asm.SEQ [| op8_frag; Asm.WORD (TY_i8, pcrel_expr); def |];\n+      |]\n+;;\n+\n+let insn_pcrel_simple (op32:int) (fix:fixup) : Asm.frag =\n+  let pcrel_mark_fixup = new_fixup \"pcrel mark fixup\" in\n+  let def = Asm.DEF (pcrel_mark_fixup, Asm.MARK) in\n+  let pcrel_expr = (Asm.SUB (Asm.M_POS fix,\n+                             Asm.M_POS pcrel_mark_fixup))\n+  in\n+    Asm.SEQ [| Asm.BYTE op32; Asm.WORD (TY_i32, pcrel_expr); def |]\n+;;\n+\n+let insn_pcrel (op8:int) (op32:int) (fix:fixup) : Asm.frag =\n+  insn_pcrel_relax (Asm.BYTE op8) (Asm.BYTE op32) fix\n+;;\n+\n+let insn_pcrel_prefix32\n+    (op8:int)\n+    (prefix32:int)\n+    (op32:int)\n+    (fix:fixup)\n+    : Asm.frag =\n+  insn_pcrel_relax (Asm.BYTE op8) (Asm.BYTES [| prefix32; op32 |]) fix\n+;;\n+\n+(* FIXME: tighten imm-based dispatch by imm type. *)\n+let cmp (a:Il.operand) (b:Il.operand) : Asm.frag =\n+  match (a,b) with\n+      (Il.Cell c, Il.Imm (i, TY_i8)) when is_rm8 c ->\n+        insn_rm_r_imm 0x80 c slash7 TY_i8 i\n+    | (Il.Cell c, Il.Imm (i, TY_u8)) when is_rm8 c ->\n+        insn_rm_r_imm 0x80 c slash7 TY_u8 i\n+    | (Il.Cell c, Il.Imm (i, _)) when is_rm32 c ->\n+        (*\n+         * NB: We can't switch on signed-ness here, as 'cmp' is\n+         * defined to sign-extend its operand; i.e. we have to treat\n+         * it as though you're emitting a signed byte (in the sense of\n+         * immediate-size selection) even if the incoming value is\n+         * unsigned.\n+         *)\n+        insn_rm_r_imm_s8_s32 0x83 0x81 c slash7 i\n+    | (Il.Cell c, Il.Cell (Il.Reg (Il.Hreg r, _))) ->\n+        insn_rm_r 0x39 c (reg r)\n+    | (Il.Cell (Il.Reg (Il.Hreg r, _)), Il.Cell c) ->\n+        insn_rm_r 0x3b c (reg r)\n+    | _ -> raise Unrecognized\n+;;\n+\n+let zero (dst:Il.cell) (count:Il.operand) : Asm.frag =\n+  match (dst, count) with\n+\n+      ((Il.Mem (Il.RegIn ((Il.Hreg dst_ptr), None), _)),\n+       Il.Cell (Il.Reg ((Il.Hreg count), _)))\n+        when dst_ptr = edi && count = ecx ->\n+          Asm.BYTES [|\n+            0xb0; 0x0;  (* mov %eax, 0 : move a zero into al. *)\n+            0xf3; 0xaa; (* rep stos m8 : fill ecx bytes at [edi] with al *)\n+          |]\n+\n+    | _ -> raise Unrecognized\n+;;\n+\n+let mov (signed:bool) (dst:Il.cell) (src:Il.operand) : Asm.frag =\n+  if is_ty8 (Il.cell_scalar_ty dst) || is_ty8 (Il.operand_scalar_ty src)\n+  then\n+    begin\n+      (match dst with\n+           Il.Reg (Il.Hreg r, _)\n+           -> assert (is_ok_r8 r) | _ -> ());\n+      (match src with\n+           Il.Cell (Il.Reg (Il.Hreg r, _))\n+           -> assert (is_ok_r8 r) | _ -> ());\n+    end;\n+\n+  match (signed, dst, src) with\n+\n+      (* m8 <- r??, r8 or truncate(r32). *)\n+      (_,  _, Il.Cell (Il.Reg ((Il.Hreg r), _)))\n+        when is_m8 dst ->\n+          insn_rm_r 0x88 dst (reg r)\n+\n+    (* r8 <- r8: treat as r32 <- r32. *)\n+    | (_,  Il.Reg ((Il.Hreg r), _), Il.Cell src_cell)\n+        when is_r8 dst && is_r8 src_cell ->\n+        insn_rm_r 0x8b src_cell (reg r)\n+\n+    (* rm32 <- r32 *)\n+    | (_,  _, Il.Cell (Il.Reg ((Il.Hreg r), src_ty)))\n+        when (is_r8 dst || is_rm32 dst) && is_ty32 src_ty ->\n+        insn_rm_r 0x89 dst (reg r)\n+\n+    (* r32 <- rm32 *)\n+    | (_,  (Il.Reg ((Il.Hreg r), dst_ty)), Il.Cell src_cell)\n+        when is_ty32 dst_ty && is_rm32 src_cell ->\n+          insn_rm_r 0x8b src_cell (reg r)\n+\n+    (* MOVZX: r8/r32 <- zx(rm8) *)\n+    | (false, Il.Reg ((Il.Hreg r, _)), Il.Cell src_cell)\n+        when (is_r8 dst || is_r32 dst) && is_rm8 src_cell ->\n+        Asm.SEQ [| Asm.BYTE 0x0f;\n+                   insn_rm_r 0xb6 src_cell (reg r) |]\n+\n+    (* MOVZX: m32 <- zx(r8) *)\n+    | (false, _, (Il.Cell (Il.Reg ((Il.Hreg r), _) as src_cell)))\n+        when (is_m32 dst) && is_r8 src_cell ->\n+        (* Fake with 2 insns:\n+         *\n+         * movzx r32 <- r8;   (in-place zero-extension)\n+         * mov m32 <- r32;    (NB: must happen in AL/CL/DL/BL)\n+         *)\n+        Asm.SEQ [| Asm.BYTE 0x0f;\n+                   insn_rm_r 0xb6 src_cell (reg r);\n+                   insn_rm_r 0x89 dst (reg r);\n+                |]\n+\n+    (* MOVSX: r8/r32 <- sx(rm8) *)\n+    | (true, Il.Reg ((Il.Hreg r), _), Il.Cell src_cell)\n+        when (is_r8 dst || is_r32 dst) && is_rm8 src_cell ->\n+        Asm.SEQ [| Asm.BYTE 0x0f;\n+                   insn_rm_r 0xbe src_cell (reg r) |]\n+\n+    (* MOVSX: m32 <- sx(r8) *)\n+    | (true, _, (Il.Cell (Il.Reg ((Il.Hreg r), _) as src_cell)))\n+        when (is_m32 dst) && is_r8 src_cell ->\n+        (* Fake with 2 insns:\n+         *\n+         * movsx r32 <- r8;   (in-place sign-extension)\n+         * mov m32 <- r32;    (NB: must happen in AL/CL/DL/BL)\n+         *)\n+        Asm.SEQ [| Asm.BYTE 0x0f;\n+                   insn_rm_r 0xbe src_cell (reg r);\n+                   insn_rm_r 0x89 dst (reg r);\n+                |]\n+\n+    (* m8 <- imm8 (signed) *)\n+    | (_, _, Il.Imm ((Asm.IMM n), _))\n+        when is_m8 dst && imm_is_signed_byte n && signed ->\n+          insn_rm_r_imm 0xc6 dst slash0 TY_i8 (Asm.IMM n)\n+\n+    (* m8 <- imm8 (unsigned) *)\n+    | (_, _, Il.Imm ((Asm.IMM n), _))\n+        when is_m8 dst && imm_is_unsigned_byte n && (not signed) ->\n+          insn_rm_r_imm 0xc6 dst slash0 TY_u8 (Asm.IMM n)\n+\n+    (* rm32 <- imm32 *)\n+    | (_, _, Il.Imm (i, _)) when is_rm32 dst || is_r8 dst ->\n+        let t = if signed then TY_u32 else TY_i32 in\n+          insn_rm_r_imm 0xc7 dst slash0 t i\n+\n+    | _ -> raise Unrecognized\n+;;\n+\n+\n+let lea (dst:Il.cell) (src:Il.operand) : Asm.frag =\n+  match (dst, src) with\n+      (Il.Reg ((Il.Hreg r), dst_ty),\n+       Il.Cell (Il.Mem (mem, _)))\n+        when is_ty32 dst_ty ->\n+          insn_rm_r 0x8d (Il.Mem (mem, Il.OpaqueTy)) (reg r)\n+\n+    | (Il.Reg ((Il.Hreg r), dst_ty),\n+       Il.ImmPtr (fix, _))\n+        when is_ty32 dst_ty && r = eax ->\n+        let anchor = new_fixup \"anchor\" in\n+        let fix_off = Asm.SUB ((Asm.M_POS fix),\n+                               (Asm.M_POS anchor))\n+        in\n+          (* NB: These instructions must come as a\n+           * cluster, w/o any separation.\n+           *)\n+          Asm.SEQ [|\n+            insn_pcrel_simple 0xe8 get_next_pc_thunk_fixup;\n+            Asm.DEF (anchor, insn_rm_r_imm 0x81 dst slash0 TY_i32 fix_off);\n+          |]\n+\n+    | _ -> raise Unrecognized\n+;;\n+\n+\n+let select_insn_misc (q:Il.quad') : Asm.frag =\n+\n+  match q with\n+      Il.Call c ->\n+        begin\n+          match c.Il.call_dst with\n+              Il.Reg ((Il.Hreg dst), _) when dst = eax ->\n+                begin\n+                  match c.Il.call_targ with\n+\n+                      Il.CodePtr (Il.Cell c)\n+                        when Il.cell_referent_ty c\n+                          = Il.ScalarTy (Il.AddrTy Il.CodeTy) ->\n+                        insn_rm_r 0xff c slash2\n+\n+                    | Il.CodePtr (Il.ImmPtr (f, Il.CodeTy)) ->\n+                        insn_pcrel_simple 0xe8 f\n+\n+                    | _ -> raise Unrecognized\n+                end\n+            | _ -> raise Unrecognized\n+        end\n+\n+    | Il.Push (Il.Cell (Il.Reg ((Il.Hreg r), t))) when is_ty32 t ->\n+        Asm.BYTE (0x50 + (reg r))\n+\n+    | Il.Push (Il.Cell c) when is_rm32 c ->\n+        insn_rm_r 0xff c slash6\n+\n+    | Il.Push (Il.Imm (Asm.IMM i, _)) when imm_is_unsigned_byte i ->\n+        Asm.SEQ [| Asm.BYTE 0x6a; Asm.WORD (TY_u8, (Asm.IMM i)) |]\n+\n+    | Il.Push (Il.Imm (i, _)) ->\n+        Asm.SEQ [| Asm.BYTE 0x68; Asm.WORD (TY_u32, i) |]\n+\n+    | Il.Pop (Il.Reg ((Il.Hreg r), t)) when is_ty32 t ->\n+        Asm.BYTE (0x58 + (reg r))\n+\n+    | Il.Pop c when is_rm32 c ->\n+        insn_rm_r 0x8f c slash0\n+\n+    | Il.Ret -> Asm.BYTE 0xc3\n+\n+    | Il.Jmp j ->\n+        begin\n+          match (j.Il.jmp_op, j.Il.jmp_targ) with\n+\n+              (Il.JMP, Il.CodePtr (Il.ImmPtr (f, Il.CodeTy))) ->\n+                insn_pcrel 0xeb 0xe9 f\n+\n+            | (Il.JMP, Il.CodePtr (Il.Cell c))\n+                when Il.cell_referent_ty c\n+                  = Il.ScalarTy (Il.AddrTy Il.CodeTy) ->\n+                insn_rm_r 0xff c slash4\n+\n+            (* FIXME: refactor this to handle cell-based jumps\n+             * if we ever need them. So far not. *)\n+            | (_, Il.CodePtr (Il.ImmPtr (f, Il.CodeTy))) ->\n+                let (op8, op32) =\n+                  match j.Il.jmp_op with\n+                    | Il.JC  -> (0x72, 0x82)\n+                    | Il.JNC -> (0x73, 0x83)\n+                    | Il.JZ  -> (0x74, 0x84)\n+                    | Il.JNZ -> (0x75, 0x85)\n+                    | Il.JO  -> (0x70, 0x80)\n+                    | Il.JNO -> (0x71, 0x81)\n+                    | Il.JE  -> (0x74, 0x84)\n+                    | Il.JNE -> (0x75, 0x85)\n+\n+                    | Il.JL  -> (0x7c, 0x8c)\n+                    | Il.JLE -> (0x7e, 0x8e)\n+                    | Il.JG  -> (0x7f, 0x8f)\n+                    | Il.JGE -> (0x7d, 0x8d)\n+\n+                    | Il.JB  -> (0x72, 0x82)\n+                    | Il.JBE -> (0x76, 0x86)\n+                    | Il.JA  -> (0x77, 0x87)\n+                    | Il.JAE -> (0x73, 0x83)\n+                    | _ -> raise Unrecognized\n+                in\n+                let prefix32 = 0x0f in\n+                  insn_pcrel_prefix32 op8 prefix32 op32 f\n+\n+            | _ -> raise Unrecognized\n+        end\n+\n+    | Il.Dead -> Asm.MARK\n+    | Il.Debug -> Asm.BYTES [| 0xcc |] (* int 3 *)\n+    | Il.Regfence -> Asm.MARK\n+    | Il.End -> Asm.BYTES [| 0x90 |]\n+    | Il.Nop -> Asm.BYTES [| 0x90 |]\n+    | _ -> raise Unrecognized\n+;;\n+\n+\n+type alu_binop_codes =\n+     {\n+       insn: string;\n+       immslash: int;    (* mod/rm \"slash\" code for imm-src variant *)\n+       rm_dst_op8: int;  (* opcode for 8-bit r/m dst variant *)\n+       rm_dst_op32: int; (* opcode for 32-bit r/m dst variant *)\n+       rm_src_op8: int;  (* opcode for 8-bit r/m src variant *)\n+       rm_src_op32: int; (* opcode for 32-bit r/m src variant *)\n+     }\n+;;\n+\n+let alu_binop\n+    (dst:Il.cell) (src:Il.operand) (codes:alu_binop_codes)\n+    : Asm.frag =\n+  match (dst, src) with\n+      (Il.Reg ((Il.Hreg r), dst_ty), Il.Cell c)\n+        when (is_ty32 dst_ty && is_rm32 c) || (is_ty8 dst_ty && is_rm8 c)\n+          -> insn_rm_r codes.rm_src_op32 c (reg r)\n+\n+    | (_, Il.Cell (Il.Reg ((Il.Hreg r), src_ty)))\n+        when (is_rm32 dst && is_ty32 src_ty) || (is_rm8 dst && is_ty8 src_ty)\n+          -> insn_rm_r codes.rm_dst_op32 dst (reg r)\n+\n+    | (_, Il.Imm (i, _)) when is_rm32 dst || is_rm8 dst\n+        -> insn_rm_r_imm_s8_s32 0x83 0x81 dst codes.immslash i\n+\n+    | _ -> raise Unrecognized\n+;;\n+\n+\n+let mul_like (src:Il.operand) (signed:bool) (slash:int)\n+    : Asm.frag =\n+  match src with\n+      Il.Cell src when is_rm32 src ->\n+        insn_rm_r 0xf7 src slash\n+\n+    | Il.Cell src when is_rm8 src ->\n+        insn_rm_r 0xf6 src slash\n+\n+    | Il.Imm (_, TY_u32)\n+    | Il.Imm (_, TY_i32) ->\n+        let tmp = Il.Reg ((Il.Hreg edx), Il.ValTy Il.Bits32) in\n+        Asm.SEQ [| mov signed tmp src;\n+                   insn_rm_r 0xf7 tmp slash |]\n+\n+    | Il.Imm (_, TY_u8)\n+    | Il.Imm (_, TY_i8) ->\n+        let tmp = Il.Reg ((Il.Hreg edx), Il.ValTy Il.Bits8) in\n+        Asm.SEQ [| mov signed tmp src;\n+                   insn_rm_r 0xf6 tmp slash |]\n+\n+    | _ -> raise Unrecognized\n+;;\n+\n+\n+let select_insn (q:Il.quad) : Asm.frag =\n+  match q.Il.quad_body with\n+      Il.Unary u ->\n+        let unop s =\n+          if u.Il.unary_src = Il.Cell u.Il.unary_dst\n+          then insn_rm_r 0xf7 u.Il.unary_dst s\n+          else raise Unrecognized\n+        in\n+          begin\n+            match u.Il.unary_op with\n+                Il.UMOV -> mov false u.Il.unary_dst u.Il.unary_src\n+              | Il.IMOV -> mov true u.Il.unary_dst u.Il.unary_src\n+              | Il.NEG -> unop slash3\n+              | Il.NOT -> unop slash2\n+              | Il.ZERO -> zero u.Il.unary_dst u.Il.unary_src\n+          end\n+\n+    | Il.Lea le -> lea le.Il.lea_dst le.Il.lea_src\n+\n+    | Il.Cmp c -> cmp c.Il.cmp_lhs c.Il.cmp_rhs\n+\n+    | Il.Binary b ->\n+        begin\n+          if Il.Cell b.Il.binary_dst = b.Il.binary_lhs\n+          then\n+            let binop = alu_binop b.Il.binary_dst b.Il.binary_rhs in\n+            let mulop = mul_like b.Il.binary_rhs in\n+\n+            let divop signed slash =\n+              Asm.SEQ [|\n+                (* xor edx edx, then mul_like. *)\n+                insn_rm_r 0x33 (rc edx) (reg edx);\n+                mul_like b.Il.binary_rhs signed slash\n+              |]\n+            in\n+\n+            let modop signed slash =\n+              Asm.SEQ [|\n+                (* divop, then mov remainder to eax instead. *)\n+                divop signed slash;\n+                mov false (rc eax) (ro edx)\n+              |]\n+            in\n+\n+            let shiftop slash =\n+              let src = b.Il.binary_rhs in\n+              let dst = b.Il.binary_dst in\n+              let mask i = Asm.AND (i, Asm.IMM 0xffL) in\n+              if is_rm8 dst\n+              then\n+                match src with\n+                    Il.Imm (i, _) ->\n+                      insn_rm_r_imm 0xC0 dst slash TY_u8 (mask i)\n+                  | Il.Cell (Il.Reg ((Il.Hreg r), _))\n+                      when r = ecx ->\n+                      Asm.SEQ [| Asm.BYTE 0xD2; rm_r dst slash |]\n+                  | _ -> raise Unrecognized\n+              else\n+                match src with\n+                    Il.Imm (i, _) ->\n+                        insn_rm_r_imm 0xC1 dst slash TY_u8 (mask i)\n+                  | Il.Cell (Il.Reg ((Il.Hreg r), _))\n+                      when r = ecx ->\n+                      Asm.SEQ [| Asm.BYTE 0xD3; rm_r dst slash |]\n+                  | _ -> raise Unrecognized\n+            in\n+\n+              match (b.Il.binary_dst, b.Il.binary_op) with\n+                  (_, Il.ADD) -> binop { insn=\"ADD\";\n+                                         immslash=slash0;\n+                                         rm_dst_op8=0x0;\n+                                         rm_dst_op32=0x1;\n+                                         rm_src_op8=0x2;\n+                                         rm_src_op32=0x3; }\n+                | (_, Il.SUB) -> binop { insn=\"SUB\";\n+                                         immslash=slash5;\n+                                         rm_dst_op8=0x28;\n+                                         rm_dst_op32=0x29;\n+                                         rm_src_op8=0x2a;\n+                                         rm_src_op32=0x2b; }\n+                | (_, Il.AND) -> binop { insn=\"AND\";\n+                                         immslash=slash4;\n+                                         rm_dst_op8=0x20;\n+                                         rm_dst_op32=0x21;\n+                                         rm_src_op8=0x22;\n+                                         rm_src_op32=0x23; }\n+                | (_, Il.OR) -> binop { insn=\"OR\";\n+                                        immslash=slash1;\n+                                        rm_dst_op8=0x08;\n+                                        rm_dst_op32=0x09;\n+                                        rm_src_op8=0x0a;\n+                                        rm_src_op32=0x0b; }\n+                | (_, Il.XOR) -> binop { insn=\"XOR\";\n+                                         immslash=slash6;\n+                                         rm_dst_op8=0x30;\n+                                         rm_dst_op32=0x31;\n+                                         rm_src_op8=0x32;\n+                                         rm_src_op32=0x33; }\n+\n+                | (_, Il.LSL) -> shiftop slash4\n+                | (_, Il.LSR) -> shiftop slash5\n+                | (_, Il.ASR) -> shiftop slash7\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.UMUL)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    mulop false slash4\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.IMUL)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    mulop true slash5\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.UDIV)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    divop false slash6\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.IDIV)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    divop true slash7\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.UMOD)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    modop false slash6\n+\n+                | (Il.Reg (Il.Hreg r, t), Il.IMOD)\n+                    when (is_ty32 t || is_ty8 t) && r = eax ->\n+                    modop true slash7\n+\n+                | _ -> raise Unrecognized\n+          else raise Unrecognized\n+        end\n+    | _ -> select_insn_misc q.Il.quad_body\n+;;\n+\n+\n+let new_emitter_without_vregs _ : Il.emitter =\n+  Il.new_emitter\n+    abi.Abi.abi_prealloc_quad\n+    abi.Abi.abi_is_2addr_machine\n+    false None\n+;;\n+\n+let select_insns (sess:Session.sess) (q:Il.quads) : Asm.frag =\n+  let scopes = Stack.create () in\n+  let fixups = Stack.create () in\n+  let pop_frags _ =\n+    Asm.SEQ (Array.of_list\n+               (List.rev\n+                  (!(Stack.pop scopes))))\n+  in\n+    ignore (Stack.push (ref []) scopes);\n+    for i = 0 to (Array.length q) - 1 do\n+      let append frag =\n+        let frags = Stack.top scopes in\n+          frags := frag :: (!frags)\n+      in\n+        begin\n+          match q.(i).Il.quad_fixup with\n+              None -> ()\n+            | Some f -> append (Asm.DEF (f, Asm.MARK))\n+        end;\n+        begin\n+          match q.(i).Il.quad_body with\n+              Il.Enter f ->\n+                Stack.push f fixups;\n+                Stack.push (ref []) scopes;\n+            | Il.Leave ->\n+                append (Asm.DEF (Stack.pop fixups, pop_frags ()))\n+            | _ ->\n+                try\n+                  append (select_insn q.(i))\n+                with\n+                    Unrecognized ->\n+                      Session.fail sess\n+                        \"E:Assembly error: unrecognized quad: %s\\n%!\"\n+                        (Il.string_of_quad reg_str q.(i));\n+                      ()\n+        end\n+    done;\n+    pop_frags()\n+;;\n+\n+let frags_of_emitted_quads (sess:Session.sess) (e:Il.emitter) : Asm.frag =\n+  let frag = select_insns sess e.Il.emit_quads in\n+    if sess.Session.sess_failed\n+    then raise Unrecognized\n+    else frag\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "e0391c65937e60ccd9c0af9d8d46976aed83e671", "filename": "src/boot/driver/lib.ml", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Flib.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Flib.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Flib.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,232 @@\n+open Common;;\n+\n+let log (sess:Session.sess) =\n+  Session.log \"lib\"\n+    sess.Session.sess_log_lib\n+    sess.Session.sess_log_out\n+;;\n+\n+let iflog (sess:Session.sess) (thunk:(unit -> unit)) : unit =\n+  if sess.Session.sess_log_lib\n+  then thunk ()\n+  else ()\n+;;\n+\n+(* FIXME: move these to sess. *)\n+let ar_cache = Hashtbl.create 0 ;;\n+let sects_cache = Hashtbl.create 0;;\n+let meta_cache = Hashtbl.create 0;;\n+let die_cache = Hashtbl.create 0;;\n+\n+let get_ar\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : Asm.asm_reader option =\n+  htab_search_or_add ar_cache filename\n+    begin\n+      fun _ ->\n+        let sniff =\n+          match sess.Session.sess_targ with\n+              Win32_x86_pe -> Pe.sniff\n+            | MacOS_x86_macho -> Macho.sniff\n+            | Linux_x86_elf -> Elf.sniff\n+        in\n+          sniff sess filename\n+    end\n+;;\n+\n+\n+let get_sects\n+    (sess:Session.sess)\n+    (filename:filename) :\n+    (Asm.asm_reader * ((string,(int*int)) Hashtbl.t)) option =\n+  htab_search_or_add sects_cache filename\n+    begin\n+      fun _ ->\n+        match get_ar sess filename with\n+            None -> None\n+          | Some ar ->\n+              let get_sections =\n+                match sess.Session.sess_targ with\n+                    Win32_x86_pe -> Pe.get_sections\n+                  | MacOS_x86_macho -> Macho.get_sections\n+                  | Linux_x86_elf -> Elf.get_sections\n+              in\n+                Some (ar, (get_sections sess ar))\n+    end\n+;;\n+\n+let get_meta\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : Ast.meta option =\n+  htab_search_or_add meta_cache filename\n+    begin\n+      fun _ ->\n+        match get_sects sess filename with\n+            None -> None\n+          | Some (ar, sects) ->\n+              match htab_search sects \".note.rust\" with\n+                  Some (off, _) ->\n+                    ar.Asm.asm_seek off;\n+                    Some (Asm.read_rust_note ar)\n+                | None -> None\n+    end\n+;;\n+\n+let get_dies_opt\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : (Dwarf.rooted_dies option) =\n+  htab_search_or_add die_cache filename\n+    begin\n+      fun _ ->\n+        match get_sects sess filename with\n+            None -> None\n+          | Some (ar, sects) ->\n+              let debug_abbrev = Hashtbl.find sects \".debug_abbrev\" in\n+              let debug_info = Hashtbl.find sects \".debug_info\" in\n+              let abbrevs = Dwarf.read_abbrevs sess ar debug_abbrev in\n+              let dies = Dwarf.read_dies sess ar debug_info abbrevs in\n+                ar.Asm.asm_close ();\n+                Hashtbl.remove ar_cache filename;\n+                Some dies\n+    end\n+;;\n+\n+let get_dies\n+    (sess:Session.sess)\n+    (filename:filename)\n+    : Dwarf.rooted_dies =\n+  match get_dies_opt sess filename with\n+      None ->\n+        Printf.fprintf stderr \"Error: bad crate file: %s\\n%!\" filename;\n+        exit 1\n+    | Some dies -> dies\n+;;\n+\n+let get_file_mod\n+    (sess:Session.sess)\n+    (abi:Abi.abi)\n+    (filename:filename)\n+    (nref:node_id ref)\n+    (oref:opaque_id ref)\n+    : Ast.mod_items =\n+  let dies = get_dies sess filename in\n+  let items = Hashtbl.create 0 in\n+    Dwarf.extract_mod_items nref oref abi items dies;\n+    items\n+;;\n+\n+let get_mod\n+    (sess:Session.sess)\n+    (abi:Abi.abi)\n+    (meta:Ast.meta_pat)\n+    (use_id:node_id)\n+    (nref:node_id ref)\n+    (oref:opaque_id ref)\n+    : (filename * Ast.mod_items) =\n+  let found = Queue.create () in\n+  let suffix =\n+    match sess.Session.sess_targ with\n+        Win32_x86_pe -> \".dll\"\n+      | MacOS_x86_macho -> \".dylib\"\n+      | Linux_x86_elf -> \".so\"\n+  in\n+  let rec meta_matches i f_meta =\n+    if i >= (Array.length meta)\n+    then true\n+    else\n+      match meta.(i) with\n+          (* FIXME: bind the wildcards. *)\n+          (_, None) -> meta_matches (i+1) f_meta\n+        | (k, Some v) ->\n+            match atab_search f_meta k with\n+                None -> false\n+              | Some v' ->\n+                  if v = v'\n+                  then meta_matches (i+1) f_meta\n+                  else false\n+  in\n+  let file_matches file =\n+    log sess \"searching for metadata in %s\" file;\n+    match get_meta sess file with\n+        None -> false\n+      | Some f_meta ->\n+          log sess \"matching metadata in %s\" file;\n+          meta_matches 0 f_meta\n+  in\n+    iflog sess\n+      begin\n+        fun _ ->\n+          log sess \"searching for library matching:\";\n+          Array.iter\n+            begin\n+              fun (k,vo) ->\n+                match vo with\n+                    None -> ()\n+                  | Some v ->\n+                      log sess \"%s = %S\" k v\n+            end\n+            meta;\n+      end;\n+    Queue.iter\n+      begin\n+        fun dir ->\n+          let dh = Unix.opendir dir in\n+          let rec scan _ =\n+            try\n+              let file = Unix.readdir dh in\n+                log sess \"considering file %s\" file;\n+                if (Filename.check_suffix file suffix) &&\n+                  (file_matches file)\n+                then\n+                  begin\n+                    iflog sess\n+                      begin\n+                        fun _ ->\n+                          log sess \"matched against library %s\" file;\n+                          match get_meta sess file with\n+                              None -> ()\n+                            | Some meta ->\n+                                Array.iter\n+                                  (fun (k,v) -> log sess \"%s = %S\" k v)\n+                                  meta;\n+                      end;\n+                    Queue.add file found;\n+                  end;\n+                scan()\n+            with\n+                End_of_file -> ()\n+          in\n+            scan ()\n+      end\n+      sess.Session.sess_lib_dirs;\n+    match Queue.length found with\n+        0 -> Common.err (Some use_id) \"unsatisfied 'use' clause\"\n+      | 1 ->\n+          let filename = Queue.pop found in\n+          let items = get_file_mod sess abi filename nref oref in\n+            (filename, items)\n+      | _ -> Common.err (Some use_id) \"multiple crates match 'use' clause\"\n+;;\n+\n+let infer_lib_name\n+    (sess:Session.sess)\n+    (ident:filename)\n+    : filename =\n+  match sess.Session.sess_targ with\n+      Win32_x86_pe -> ident ^ \".dll\"\n+    | MacOS_x86_macho -> \"lib\" ^ ident ^ \".dylib\"\n+    | Linux_x86_elf -> \"lib\" ^ ident ^ \".so\"\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "ef5c1c8653bc2d61c85025782810007d018e902b", "filename": "src/boot/driver/llvm/glue.ml", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fllvm%2Fglue.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,37 @@\n+(*\n+ * Glue for the LLVM backend.\n+ *)\n+\n+let alt_argspecs sess = [\n+  (\"-llvm\", Arg.Unit (fun _ -> sess.Session.sess_alt_backend <- true),\n+    \"emit LLVM bitcode\")\n+];;\n+\n+let alt_pipeline sess sem_cx crate =\n+  let process processor =\n+    processor sem_cx crate;\n+    if sess.Session.sess_failed then exit 1 else ()\n+  in\n+  Array.iter process\n+    [|\n+      Resolve.process_crate;\n+      Type.process_crate;\n+      Effect.process_crate;\n+      Typestate.process_crate;\n+      Loop.process_crate;\n+      Alias.process_crate;\n+      Dead.process_crate;\n+      Layout.process_crate\n+    |];\n+  Llemit.trans_and_process_crate sess sem_cx crate\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)\n+"}, {"sha": "c5199a82681b5a0368bcb91b2b69a56e115bf21d", "filename": "src/boot/driver/main.ml", "status": "added", "additions": 421, "deletions": 0, "changes": 421, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fmain.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fmain.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fmain.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,421 @@\n+\n+open Common;;\n+\n+let _ =\n+  Gc.set { (Gc.get()) with\n+             Gc.space_overhead = 400; }\n+;;\n+\n+let (targ:Common.target) =\n+  match Sys.os_type with\n+      \"Unix\" ->\n+        (* FIXME: this is an absurd heuristic. *)\n+        if Sys.file_exists \"/System/Library\"\n+        then MacOS_x86_macho\n+        else Linux_x86_elf\n+    | \"Win32\" -> Win32_x86_pe\n+    | \"Cygwin\" -> Win32_x86_pe\n+    | _ -> Linux_x86_elf\n+;;\n+\n+let (abi:Abi.abi) = X86.abi;;\n+\n+let (sess:Session.sess) =\n+  {\n+    Session.sess_in = None;\n+    Session.sess_out = None;\n+    Session.sess_library_mode = false;\n+    Session.sess_alt_backend = false;\n+    (* FIXME: need something fancier here for unix sub-flavours. *)\n+    Session.sess_targ = targ;\n+    Session.sess_log_lex = false;\n+    Session.sess_log_parse = false;\n+    Session.sess_log_ast = false;\n+    Session.sess_log_resolve = false;\n+    Session.sess_log_type = false;\n+    Session.sess_log_effect = false;\n+    Session.sess_log_typestate = false;\n+    Session.sess_log_loop = false;\n+    Session.sess_log_alias = false;\n+    Session.sess_log_dead = false;\n+    Session.sess_log_layout = false;\n+    Session.sess_log_itype = false;\n+    Session.sess_log_trans = false;\n+    Session.sess_log_dwarf = false;\n+    Session.sess_log_ra = false;\n+    Session.sess_log_insn = false;\n+    Session.sess_log_asm = false;\n+    Session.sess_log_obj = false;\n+    Session.sess_log_lib = false;\n+    Session.sess_log_out = stdout;\n+    Session.sess_trace_block = false;\n+    Session.sess_trace_drop = false;\n+    Session.sess_trace_tag = false;\n+    Session.sess_trace_gc = false;\n+    Session.sess_failed = false;\n+    Session.sess_spans = Hashtbl.create 0;\n+    Session.sess_report_timing = false;\n+    Session.sess_report_gc = false;\n+    Session.sess_report_deps = false;\n+    Session.sess_timings = Hashtbl.create 0;\n+    Session.sess_lib_dirs = Queue.create ();\n+  }\n+;;\n+\n+let default_output_filename (sess:Session.sess) : filename option =\n+  match sess.Session.sess_in with\n+      None -> None\n+    | Some fname ->\n+        let base = Filename.chop_extension (Filename.basename fname) in\n+        let out =\n+          if sess.Session.sess_library_mode\n+          then\n+            Lib.infer_lib_name sess base\n+          else\n+            base ^ (match sess.Session.sess_targ with\n+                        Linux_x86_elf -> \"\"\n+                      | MacOS_x86_macho -> \"\"\n+                      | Win32_x86_pe -> \".exe\")\n+        in\n+          Some out\n+;;\n+\n+let set_default_output_filename (sess:Session.sess) : unit =\n+  match sess.Session.sess_out with\n+      None -> (sess.Session.sess_out <- default_output_filename sess)\n+    | _ -> ()\n+;;\n+\n+\n+let dump_sig (filename:filename) : unit =\n+  let items =\n+    Lib.get_file_mod sess abi filename (ref (Node 0)) (ref (Opaque 0)) in\n+    Printf.fprintf stdout \"%s\\n\" (Ast.fmt_to_str Ast.fmt_mod_items items);\n+    exit 0\n+;;\n+\n+let dump_meta (filename:filename) : unit =\n+  begin\n+    match Lib.get_meta sess filename with\n+        None -> Printf.fprintf stderr \"Error: bad crate file: %s\\n\" filename\n+      | Some meta ->\n+          Array.iter\n+            begin\n+              fun (k,v) ->\n+                Printf.fprintf stdout \"%s = %S\\n\" k v;\n+            end\n+            meta\n+  end;\n+  exit 0\n+;;\n+\n+let flag f opt desc =\n+  (opt, Arg.Unit f, desc)\n+;;\n+\n+let argspecs =\n+  [\n+    (\"-t\", Arg.Symbol ([\"linux-x86-elf\"; \"win32-x86-pe\"; \"macos-x86-macho\"],\n+                       fun s -> (sess.Session.sess_targ <-\n+                                   (match s with\n+                                        \"win32-x86-pe\" -> Win32_x86_pe\n+                                      | \"macos-x86-macho\" -> MacOS_x86_macho\n+                                      | _ -> Linux_x86_elf))),\n+     (\" target (default: \" ^ (match sess.Session.sess_targ with\n+                                  Win32_x86_pe -> \"win32-x86-pe\"\n+                                | Linux_x86_elf -> \"linux-x86-elf\"\n+                                | MacOS_x86_macho -> \"macos-x86-macho\"\n+                             ) ^ \")\"));\n+    (\"-o\", Arg.String (fun s -> sess.Session.sess_out <- Some s),\n+     \"file to output (default: \"\n+     ^ (Session.filename_of sess.Session.sess_out) ^ \")\");\n+    (\"-shared\", Arg.Unit (fun _ -> sess.Session.sess_library_mode <- true),\n+     \"compile a shared-library crate\");\n+    (\"-L\", Arg.String (fun s -> Queue.add s sess.Session.sess_lib_dirs),\n+     \"dir to add to library path\");\n+    (\"-litype\", Arg.Unit (fun _ -> sess.Session.sess_log_itype <- true;\n+                            Il.log_iltypes := true), \"log IL types\");\n+    (flag (fun _ -> sess.Session.sess_log_lex <- true)\n+       \"-llex\"      \"log lexing\");\n+    (flag (fun _ -> sess.Session.sess_log_parse <- true)\n+       \"-lparse\"    \"log parsing\");\n+    (flag (fun _ -> sess.Session.sess_log_ast <- true)\n+       \"-last\"      \"log AST\");\n+    (flag (fun _ -> sess.Session.sess_log_resolve <- true)\n+       \"-lresolve\"  \"log resolution\");\n+    (flag (fun _ -> sess.Session.sess_log_type <- true)\n+       \"-ltype\"     \"log type checking\");\n+    (flag (fun _ -> sess.Session.sess_log_effect <- true)\n+       \"-leffect\"   \"log effect checking\");\n+    (flag (fun _ -> sess.Session.sess_log_typestate <- true)\n+       \"-ltypestate\" \"log typestate pass\");\n+    (flag (fun _ -> sess.Session.sess_log_loop <- true)\n+       \"-lloop\"      \"log loop analysis\");\n+    (flag (fun _ -> sess.Session.sess_log_alias <- true)\n+       \"-lalias\"      \"log alias analysis\");\n+    (flag (fun _ -> sess.Session.sess_log_dead <- true)\n+       \"-ldead\"       \"log dead analysis\");\n+    (flag (fun _ -> sess.Session.sess_log_layout <- true)\n+       \"-llayout\"     \"log frame layout\");\n+    (flag (fun _ -> sess.Session.sess_log_trans <- true)\n+       \"-ltrans\"      \"log IR translation\");\n+    (flag (fun _ -> sess.Session.sess_log_dwarf <- true)\n+       \"-ldwarf\"      \"log DWARF generation\");\n+    (flag (fun _ -> sess.Session.sess_log_ra <- true)\n+       \"-lra\"         \"log register allocation\");\n+    (flag (fun _ -> sess.Session.sess_log_insn <- true)\n+       \"-linsn\"       \"log instruction selection\");\n+    (flag (fun _ -> sess.Session.sess_log_asm <- true)\n+       \"-lasm\"        \"log assembly\");\n+    (flag (fun _ -> sess.Session.sess_log_obj <- true)\n+       \"-lobj\"        \"log object-file generation\");\n+    (flag (fun _ -> sess.Session.sess_log_lib <- true)\n+       \"-llib\"        \"log library search\");\n+\n+    (flag (fun _ -> sess.Session.sess_trace_block <- true)\n+       \"-tblock\"      \"emit block-boundary tracing code\");\n+    (flag (fun _ -> sess.Session.sess_trace_drop <- true)\n+       \"-tdrop\"       \"emit slot-drop tracing code\");\n+    (flag (fun _ -> sess.Session.sess_trace_tag <- true)\n+       \"-ttag\"        \"emit tag-construction tracing code\");\n+    (flag (fun _ -> sess.Session.sess_trace_gc <- true)\n+       \"-tgc\"         \"emit GC tracing code\");\n+\n+    (\"-tall\", Arg.Unit (fun _ ->\n+                          sess.Session.sess_trace_block <- true;\n+                          sess.Session.sess_trace_drop <- true;\n+                          sess.Session.sess_trace_tag <- true ),\n+     \"emit all tracing code\");\n+\n+    (flag (fun _ -> sess.Session.sess_report_timing <- true)\n+       \"-rtime\"        \"report timing of compiler phases\");\n+    (flag (fun _ -> sess.Session.sess_report_gc <- true)\n+       \"-rgc\"          \"report gc behavior of compiler\");\n+    (\"-rsig\", Arg.String dump_sig,\n+     \"report type-signature from DWARF info in compiled file, then exit\");\n+    (\"-rmeta\", Arg.String dump_meta,\n+     \"report metadata from DWARF info in compiled file, then exit\");\n+    (\"-rdeps\", Arg.Unit (fun _ -> sess.Session.sess_report_deps <- true),\n+     \"report dependencies of input, then exit\");\n+  ] @ (Glue.alt_argspecs sess)\n+;;\n+\n+let exit_if_failed _ =\n+  if sess.Session.sess_failed\n+  then exit 1\n+  else ()\n+;;\n+\n+Arg.parse\n+  argspecs\n+  (fun arg -> sess.Session.sess_in <- (Some arg))\n+  (\"usage: \" ^ Sys.argv.(0) ^ \" [options] (CRATE_FILE.rc|SOURCE_FILE.rs)\\n\")\n+;;\n+\n+let _ = set_default_output_filename  sess\n+;;\n+\n+let _ =\n+  if sess.Session.sess_out = None\n+  then (Printf.fprintf stderr \"Error: no output file specified\\n\"; exit 1)\n+  else ()\n+;;\n+\n+let _ =\n+  if sess.Session.sess_in = None\n+  then (Printf.fprintf stderr \"Error: empty input filename\\n\"; exit 1)\n+  else ()\n+;;\n+\n+\n+let (crate:Ast.crate) =\n+  Session.time_inner \"parse\" sess\n+    begin\n+      fun _ ->\n+        let infile = Session.filename_of sess.Session.sess_in in\n+        let crate =\n+          if Filename.check_suffix infile \".rc\"\n+          then\n+            Cexp.parse_crate_file sess\n+              (Lib.get_mod sess abi)\n+              (Lib.infer_lib_name sess)\n+          else\n+            if Filename.check_suffix infile \".rs\"\n+            then\n+              Cexp.parse_src_file sess\n+                (Lib.get_mod sess abi)\n+                (Lib.infer_lib_name sess)\n+            else\n+              begin\n+                Printf.fprintf stderr\n+                  \"Error: unrecognized input file type: %s\\n\"\n+                  infile;\n+                exit 1\n+              end\n+        in\n+          if sess.Session.sess_report_deps\n+          then\n+            let outfile = (Session.filename_of sess.Session.sess_out) in\n+            let depfile =\n+              match sess.Session.sess_targ with\n+                  Linux_x86_elf\n+                | MacOS_x86_macho -> outfile ^ \".d\"\n+                | Win32_x86_pe -> (Filename.chop_extension outfile) ^ \".d\"\n+            in\n+              begin\n+                Array.iter\n+                  begin\n+                    fun out ->\n+                      Printf.fprintf stdout \"%s: \\\\\\n\" out;\n+                      Hashtbl.iter\n+                        (fun _ file ->\n+                           Printf.fprintf stdout \"    %s \\\\\\n\" file)\n+                        crate.node.Ast.crate_files;\n+                      Printf.fprintf stdout \"\\n\"\n+                  end\n+                  [| outfile; depfile|];\n+                exit 0\n+              end\n+          else\n+            crate\n+    end\n+;;\n+\n+exit_if_failed ()\n+;;\n+\n+if sess.Session.sess_log_ast\n+then\n+  begin\n+    Printf.fprintf stdout \"Post-parse AST:\\n\";\n+    Format.set_margin 80;\n+    Printf.fprintf stdout \"%s\\n\" (Ast.fmt_to_str Ast.fmt_crate crate)\n+  end\n+\n+let list_to_seq ls = Asm.SEQ (Array.of_list ls);;\n+let select_insns (quads:Il.quads) : Asm.frag =\n+  Session.time_inner \"insn\" sess\n+    (fun _ -> X86.select_insns sess quads)\n+;;\n+\n+\n+(* Semantic passes. *)\n+let sem_cx = Semant.new_ctxt sess abi crate.node\n+;;\n+\n+\n+let main_pipeline _ =\n+  let _ =\n+    Array.iter\n+      (fun proc ->\n+         proc sem_cx crate;\n+         exit_if_failed ())\n+      [| Resolve.process_crate;\n+         Type.process_crate;\n+         Effect.process_crate;\n+         Typestate.process_crate;\n+         Loop.process_crate;\n+         Alias.process_crate;\n+         Dead.process_crate;\n+         Layout.process_crate;\n+         Trans.process_crate |]\n+  in\n+\n+  (* Tying up various knots, allocating registers and selecting\n+   * instructions.\n+   *)\n+  let process_code _ (code:Semant.code) : Asm.frag =\n+    let frag =\n+      match code.Semant.code_vregs_and_spill with\n+          None -> select_insns code.Semant.code_quads\n+        | Some (n_vregs, spill_fix) ->\n+            let (quads', n_spills) =\n+              (Session.time_inner \"RA\" sess\n+                 (fun _ ->\n+                    Ra.reg_alloc sess\n+                      code.Semant.code_quads\n+                      n_vregs abi))\n+            in\n+            let insns = select_insns quads' in\n+              begin\n+                spill_fix.fixup_mem_sz <-\n+                  Some (Int64.mul\n+                          (Int64.of_int n_spills)\n+                          abi.Abi.abi_word_sz);\n+                insns\n+              end\n+    in\n+      Asm.ALIGN_FILE (Abi.general_code_alignment,\n+                      Asm.DEF (code.Semant.code_fixup, frag))\n+  in\n+\n+  let (file_frags:Asm.frag) =\n+    let process_file file_id frag_code =\n+      let file_fix = Hashtbl.find sem_cx.Semant.ctxt_file_fixups file_id in\n+        Asm.DEF (file_fix,\n+                 list_to_seq (reduce_hash_to_list process_code frag_code))\n+    in\n+      list_to_seq (reduce_hash_to_list\n+                     process_file sem_cx.Semant.ctxt_file_code)\n+  in\n+\n+    exit_if_failed ();\n+    let (glue_frags:Asm.frag) =\n+      list_to_seq (reduce_hash_to_list\n+                     process_code sem_cx.Semant.ctxt_glue_code)\n+    in\n+\n+      exit_if_failed ();\n+      let code = Asm.SEQ [| file_frags; glue_frags |] in\n+      let data = list_to_seq (reduce_hash_to_list\n+                                (fun _ (_, i) -> i) sem_cx.Semant.ctxt_data)\n+      in\n+      (* Emitting Dwarf and PE/ELF/Macho. *)\n+      let (dwarf:Dwarf.debug_records) =\n+        Session.time_inner \"dwarf\" sess\n+          (fun _ -> Dwarf.process_crate sem_cx crate)\n+      in\n+\n+        exit_if_failed ();\n+        let emitter =\n+          match sess.Session.sess_targ with\n+              Win32_x86_pe -> Pe.emit_file\n+            | MacOS_x86_macho -> Macho.emit_file\n+            | Linux_x86_elf -> Elf.emit_file\n+        in\n+          Session.time_inner \"emit\" sess\n+            (fun _ -> emitter sess crate code data sem_cx dwarf);\n+          exit_if_failed ()\n+;;\n+\n+if sess.Session.sess_alt_backend\n+then Glue.alt_pipeline sess sem_cx crate\n+else main_pipeline ()\n+;;\n+\n+if sess.Session.sess_report_timing\n+then\n+  begin\n+    Printf.fprintf stdout \"timing:\\n\\n\";\n+    Array.iter\n+      begin\n+        fun name ->\n+          Printf.fprintf stdout \"%20s: %f\\n\" name\n+            (Hashtbl.find sess.Session.sess_timings name)\n+      end\n+      (sorted_htab_keys sess.Session.sess_timings)\n+  end;\n+;;\n+\n+if sess.Session.sess_report_gc\n+then Gc.print_stat stdout;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "80253f440508e70adcd74b9a112b18fc47b24e34", "filename": "src/boot/driver/session.ml", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fsession.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fsession.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fsession.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,111 @@\n+(*\n+ * This module goes near the bottom of the dependency DAG, and holds option,\n+ * and global-state machinery for a single run of the compiler.\n+ *)\n+\n+open Common;;\n+\n+type sess =\n+{\n+  mutable sess_in: filename option;\n+  mutable sess_out: filename option;\n+  mutable sess_library_mode: bool;\n+  mutable sess_alt_backend: bool;\n+  mutable sess_targ: target;\n+  mutable sess_log_lex: bool;\n+  mutable sess_log_parse: bool;\n+  mutable sess_log_ast: bool;\n+  mutable sess_log_resolve: bool;\n+  mutable sess_log_type: bool;\n+  mutable sess_log_effect: bool;\n+  mutable sess_log_typestate: bool;\n+  mutable sess_log_dead: bool;\n+  mutable sess_log_loop: bool;\n+  mutable sess_log_alias: bool;\n+  mutable sess_log_layout: bool;\n+  mutable sess_log_trans: bool;\n+  mutable sess_log_itype: bool;\n+  mutable sess_log_dwarf: bool;\n+  mutable sess_log_ra: bool;\n+  mutable sess_log_insn: bool;\n+  mutable sess_log_asm: bool;\n+  mutable sess_log_obj: bool;\n+  mutable sess_log_lib: bool;\n+  mutable sess_log_out: out_channel;\n+  mutable sess_trace_block: bool;\n+  mutable sess_trace_drop: bool;\n+  mutable sess_trace_tag: bool;\n+  mutable sess_trace_gc: bool;\n+  mutable sess_failed: bool;\n+  mutable sess_report_timing: bool;\n+  mutable sess_report_gc: bool;\n+  mutable sess_report_deps: bool;\n+  sess_timings: (string, float) Hashtbl.t;\n+  sess_spans: (node_id,span) Hashtbl.t;\n+  sess_lib_dirs: filename Queue.t;\n+}\n+;;\n+\n+let add_time sess name amt =\n+  let existing =\n+    if Hashtbl.mem sess.sess_timings name\n+    then Hashtbl.find sess.sess_timings name\n+    else 0.0\n+  in\n+    (Hashtbl.replace sess.sess_timings name (existing +. amt))\n+;;\n+\n+let time_inner name sess thunk =\n+  let t0 = Unix.gettimeofday() in\n+  let x = thunk() in\n+  let t1 = Unix.gettimeofday() in\n+    add_time sess name (t1 -. t0);\n+    x\n+;;\n+\n+let get_span sess id =\n+  if Hashtbl.mem sess.sess_spans id\n+  then (Some (Hashtbl.find sess.sess_spans id))\n+  else None\n+;;\n+\n+let log name flag chan =\n+  let k1 s =\n+    Printf.fprintf chan \"%s: %s\\n%!\" name s\n+  in\n+  let k2 _ = () in\n+    Printf.ksprintf (if flag then k1 else k2)\n+;;\n+\n+let fail sess =\n+  sess.sess_failed <- true;\n+  Printf.fprintf sess.sess_log_out\n+;;\n+\n+\n+let string_of_pos (p:pos) =\n+  let (filename, line, col) = p in\n+  Printf.sprintf \"%s:%d:%d\" filename line col\n+;;\n+\n+\n+let string_of_span (s:span) =\n+    let (filename, line0, col0) = s.lo in\n+    let (_, line1, col1) = s.hi in\n+    Printf.sprintf \"%s:%d:%d - %d:%d\" filename line0 col0 line1 col1\n+;;\n+\n+let filename_of (fo:filename option) : filename =\n+  match fo with\n+      None -> \"<none>\"\n+    | Some f -> f\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "4fc7448054dfb4c85bf747851391fe29475cb545", "filename": "src/boot/driver/x86/glue.ml", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fx86%2Fglue.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fdriver%2Fx86%2Fglue.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fdriver%2Fx86%2Fglue.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,16 @@\n+(*\n+ * Glue, or lack thereof, for the standard x86 backend.\n+ *)\n+\n+let alt_argspecs _ = [];;\n+let alt_pipeline _ _ _ = ();;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)\n+"}, {"sha": "bf7a11ff4e9c2c74c28bcbf00e601251883a9435", "filename": "src/boot/fe/ast.ml", "status": "added", "additions": 1360, "deletions": 0, "changes": 1360, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fast.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fast.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fast.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1360 @@\n+(*\n+ * There are two kinds of rust files:\n+ *\n+ * .rc files, containing crates.\n+ * .rs files, containing source.\n+ *\n+ *)\n+\n+open Common;;\n+\n+(*\n+ * Slot names are given by a dot-separated path within the current\n+ * module namespace.\n+ *)\n+\n+type ident = string\n+;;\n+\n+type slot_key =\n+    KEY_ident of ident\n+  | KEY_temp of temp_id\n+;;\n+\n+(* \"names\" are statically computable references to particular items;\n+   they never involve dynamic indexing (nor even static tuple-indexing;\n+   you could add it but there are few contexts that need names that would\n+   benefit from it).\n+\n+   Each component of a name may also be type-parametric; you must\n+   supply type parameters to reference through a type-parametric name\n+   component. So for example if foo is parametric in 2 types, you can\n+   write foo[int,int].bar but not foo.bar.\n+ *)\n+\n+type effect =\n+    PURE\n+  | IO\n+  | STATE\n+  | UNSAFE\n+;;\n+\n+type name_base =\n+    BASE_ident of ident\n+  | BASE_temp of temp_id\n+  | BASE_app of (ident * (ty array))\n+\n+and name_component =\n+    COMP_ident of ident\n+  | COMP_app of (ident * (ty array))\n+  | COMP_idx of int\n+\n+and name =\n+    NAME_base of name_base\n+  | NAME_ext of (name * name_component)\n+\n+(*\n+ * Type expressions are transparent to type names, their equality is\n+ * structural.  (after normalization)\n+ *)\n+and ty =\n+\n+    TY_any\n+  | TY_nil\n+  | TY_bool\n+  | TY_mach of ty_mach\n+  | TY_int\n+  | TY_uint\n+  | TY_char\n+  | TY_str\n+\n+  | TY_tup of ty_tup\n+  | TY_vec of slot\n+  | TY_rec of ty_rec\n+\n+  (*\n+   * Note that ty_idx is only valid inside a slot of a ty_iso group, not\n+   * in a general type term.\n+   *)\n+  | TY_tag of ty_tag\n+  | TY_iso of ty_iso\n+  | TY_idx of int\n+\n+  | TY_fn of ty_fn\n+  | TY_chan of ty\n+  | TY_port of ty\n+\n+  | TY_obj of ty_obj\n+  | TY_task\n+\n+  | TY_native of opaque_id\n+  | TY_param of (ty_param_idx * effect)\n+  | TY_named of name\n+  | TY_type\n+\n+  | TY_constrained of (ty * constrs)\n+\n+and mode =\n+    MODE_exterior\n+  | MODE_interior\n+  | MODE_alias\n+\n+and slot = { slot_mode: mode;\n+             slot_mutable: bool;\n+             slot_ty: ty option; }\n+\n+and ty_tup = slot array\n+\n+(* In closed type terms a constraint may refer to components of the term by\n+ * anchoring off the \"formal symbol\" '*', which represents \"the term this\n+ * constraint is attached to\".\n+ * \n+ * \n+ * For example, if I have a tuple type tup(int,int), I may wish to enforce the\n+ * lt predicate on it; I can write this as a constrained type term like:\n+ * \n+ * tup(int,int) : lt( *._0, *._1 )\n+ * \n+ * In fact all tuple types are converted to this form for purpose of\n+ * type-compatibility testing; the argument tuple in a function\n+ * \n+ * fn (int x, int y) : lt(x, y) -> int\n+ * \n+ * desugars to\n+ * \n+ * fn (tup(int, int) : lt( *._1, *._2 )) -> int\n+ * \n+ *)\n+\n+and carg_base =\n+    BASE_formal\n+  | BASE_named of name_base\n+\n+and carg_path =\n+    CARG_base of carg_base\n+  | CARG_ext of (carg_path * name_component)\n+\n+and carg =\n+    CARG_path of carg_path\n+  | CARG_lit of lit\n+\n+and constr =\n+    {\n+      constr_name: name;\n+      constr_args: carg array;\n+    }\n+\n+and constrs = constr array\n+\n+and ty_rec = (ident * slot) array\n+\n+(* ty_tag is a sum type.\n+ *\n+ * a tag type expression either normalizes to a TY_tag or a TY_iso,\n+ * which (like in ocaml) is an indexed projection from an iso-recursive\n+ * group of TY_tags.\n+ *)\n+\n+and ty_tag = (name, ty_tup) Hashtbl.t\n+\n+and ty_iso =\n+    {\n+      iso_index: int;\n+      iso_group: ty_tag array\n+    }\n+\n+and ty_sig =\n+    {\n+      sig_input_slots: slot array;\n+      sig_input_constrs: constrs;\n+      sig_output_slot: slot;\n+    }\n+\n+and ty_fn_aux =\n+    {\n+      fn_is_iter: bool;\n+      fn_effect: effect;\n+    }\n+\n+and ty_fn = (ty_sig * ty_fn_aux)\n+\n+and ty_obj_header = (slot array * constrs)\n+\n+and ty_obj = (effect * ((ident,ty_fn) Hashtbl.t))\n+\n+and check_calls = (lval * (atom array)) array\n+\n+and rec_input = (ident * mode * bool * atom)\n+\n+and tup_input = (mode * bool * atom)\n+\n+and stmt' =\n+\n+  (* lval-assigning stmts. *)\n+    STMT_spawn of (lval * domain * lval * (atom array))\n+  | STMT_init_rec of (lval * (rec_input array) * lval option)\n+  | STMT_init_tup of (lval * (tup_input array))\n+  | STMT_init_vec of (lval * slot * (atom array))\n+  | STMT_init_str of (lval * string)\n+  | STMT_init_port of lval\n+  | STMT_init_chan of (lval * (lval option))\n+  | STMT_copy of (lval * expr)\n+  | STMT_copy_binop of (lval * binop * atom)\n+  | STMT_call of (lval * lval * (atom array))\n+  | STMT_bind of (lval * lval * ((atom option) array))\n+  | STMT_recv of (lval * lval)\n+  | STMT_slice of (lval * lval * slice)\n+\n+  (* control-flow stmts. *)\n+  | STMT_while of stmt_while\n+  | STMT_do_while of stmt_while\n+  | STMT_for of stmt_for\n+  | STMT_for_each of stmt_for_each\n+  | STMT_if of stmt_if\n+  | STMT_put of (atom option)\n+  | STMT_put_each of (lval * (atom array))\n+  | STMT_ret of (atom option)\n+  | STMT_be of (lval * (atom array))\n+  | STMT_alt_tag of stmt_alt_tag\n+  | STMT_alt_type of stmt_alt_type\n+  | STMT_alt_port of stmt_alt_port\n+\n+  (* structural and misc stmts. *)\n+  | STMT_fail\n+  | STMT_yield\n+  | STMT_join of lval\n+  | STMT_send of (lval * lval)\n+  | STMT_log of atom\n+  | STMT_note of atom\n+  | STMT_prove of (constrs)\n+  | STMT_check of (constrs * check_calls)\n+  | STMT_check_expr of expr\n+  | STMT_check_if of (constrs * check_calls * block)\n+  | STMT_block of block\n+  | STMT_decl of stmt_decl\n+\n+and stmt = stmt' identified\n+\n+and stmt_alt_tag =\n+    {\n+      alt_tag_lval: lval;\n+      alt_tag_arms: arm array;\n+    }\n+\n+and stmt_alt_type =\n+    {\n+      alt_type_lval: lval;\n+      alt_type_arms: (ident * slot * stmt) array;\n+      alt_type_else: stmt option;\n+    }\n+\n+and block' = stmt array\n+and block = block' identified\n+\n+and stmt_decl =\n+    DECL_mod_item of (ident * mod_item)\n+  | DECL_slot of (slot_key * (slot identified))\n+\n+and stmt_alt_port =\n+    {\n+      (* else lval is a timeout value. *)\n+      alt_port_arms: (lval * lval) array;\n+      alt_port_else: (lval * stmt) option;\n+    }\n+\n+and stmt_while =\n+    {\n+      while_lval: ((stmt array) * expr);\n+      while_body: block;\n+    }\n+\n+and stmt_for_each =\n+    {\n+      for_each_slot: (slot identified * ident);\n+      for_each_call: (lval * atom array);\n+      for_each_head: block;\n+      for_each_body: block;\n+    }\n+\n+and stmt_for =\n+    {\n+      for_slot: (slot identified * ident);\n+      for_seq: ((stmt array) * lval);\n+      for_body: block;\n+    }\n+\n+and stmt_if =\n+    {\n+      if_test: expr;\n+      if_then: block;\n+      if_else: block option;\n+    }\n+\n+and slice =\n+    { slice_start: atom option;\n+      slice_len: atom option; }\n+\n+and domain =\n+    DOMAIN_local\n+  | DOMAIN_thread\n+\n+and pat =\n+    PAT_lit of lit\n+  | PAT_tag of ident * (pat array)\n+  | PAT_slot of ((slot identified) * ident)\n+  | PAT_wild\n+\n+and arm' = pat * block\n+and arm = arm' identified\n+\n+and atom =\n+    ATOM_literal of (lit identified)\n+  | ATOM_lval of lval\n+\n+and expr =\n+    EXPR_binary of (binop * atom * atom)\n+  | EXPR_unary of (unop * atom)\n+  | EXPR_atom of atom\n+\n+and lit =\n+  | LIT_nil\n+  | LIT_bool of bool\n+  | LIT_mach of (ty_mach * int64 * string)\n+  | LIT_int of (int64 * string)\n+  | LIT_uint of (int64 * string)\n+  | LIT_char of int\n+\n+\n+and lval_component =\n+    COMP_named of name_component\n+  | COMP_atom of atom\n+\n+\n+and lval =\n+    LVAL_base of name_base identified\n+  | LVAL_ext of (lval * lval_component)\n+\n+and binop =\n+    BINOP_or\n+  | BINOP_and\n+  | BINOP_xor\n+\n+  | BINOP_eq\n+  | BINOP_ne\n+\n+  | BINOP_lt\n+  | BINOP_le\n+  | BINOP_ge\n+  | BINOP_gt\n+\n+  | BINOP_lsl\n+  | BINOP_lsr\n+  | BINOP_asr\n+\n+  | BINOP_add\n+  | BINOP_sub\n+  | BINOP_mul\n+  | BINOP_div\n+  | BINOP_mod\n+  | BINOP_send\n+\n+and unop =\n+    UNOP_not\n+  | UNOP_bitnot\n+  | UNOP_neg\n+  | UNOP_cast of ty identified\n+\n+\n+and header_slots = ((slot identified) * ident) array\n+\n+and header_tup = (slot identified) array\n+\n+and fn =\n+    {\n+      fn_input_slots: header_slots;\n+      fn_input_constrs: constrs;\n+      fn_output_slot: slot identified;\n+      fn_aux: ty_fn_aux;\n+      fn_body: block;\n+    }\n+\n+and obj =\n+    {\n+      obj_state: header_slots;\n+      obj_effect: effect;\n+      obj_constrs: constrs;\n+      obj_fns: (ident,fn identified) Hashtbl.t;\n+      obj_drop: block option;\n+    }\n+\n+(*\n+ * An 'a decl is a sort-of-thing that represents a parametric (generative)\n+ * declaration. Every reference to one of these involves applying 0 or more\n+ * type arguments, as part of *name resolution*.\n+ *\n+ * Slots are *not* parametric declarations. A slot has a specific type\n+ * even if it's a type that's bound by a quantifier in its environment.\n+ *)\n+\n+and ty_param = ident * (ty_param_idx * effect)\n+\n+and mod_item' =\n+    MOD_ITEM_type of ty\n+  | MOD_ITEM_tag of (header_tup * ty_tag * node_id)\n+  | MOD_ITEM_mod of (mod_view * mod_items)\n+  | MOD_ITEM_fn of fn\n+  | MOD_ITEM_obj of obj\n+\n+and mod_item_decl =\n+    {\n+      decl_params: (ty_param identified) array;\n+      decl_item: mod_item';\n+    }\n+\n+and mod_item = mod_item_decl identified\n+and mod_items = (ident, mod_item) Hashtbl.t\n+\n+and export =\n+    EXPORT_all_decls\n+  | EXPORT_ident of ident\n+\n+and mod_view =\n+    {\n+      view_imports: (ident, name) Hashtbl.t;\n+      view_exports: (export, unit) Hashtbl.t;\n+    }\n+\n+and meta = (ident * string) array\n+\n+and meta_pat = (ident * string option) array\n+\n+and crate' =\n+    {\n+      crate_items: (mod_view * mod_items);\n+      crate_meta: meta;\n+      crate_auth: (name, effect) Hashtbl.t;\n+      crate_required: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n+      crate_required_syms: (node_id, string) Hashtbl.t;\n+      crate_files: (node_id,filename) Hashtbl.t;\n+      crate_main: name option;\n+    }\n+and crate = crate' identified\n+;;\n+\n+(*\n+ * NB: names can only be type-parametric in their *last* path-entry.\n+ * All path-entries before that must be ident or idx (non-parametric).\n+ *)\n+let sane_name (n:name) : bool =\n+  let rec sane_prefix (n:name) : bool =\n+      match n with\n+          NAME_base (BASE_ident _)\n+        | NAME_base (BASE_temp _) -> true\n+        | NAME_ext (prefix, COMP_ident _)\n+        | NAME_ext (prefix, COMP_idx _) -> sane_prefix prefix\n+        | _ -> false\n+  in\n+    match n with\n+        NAME_base _ -> true\n+      | NAME_ext (prefix, _) -> sane_prefix prefix\n+;;\n+\n+\n+(***********************************************************************)\n+\n+(* FIXME (issue #19): finish all parts with ?foo? as their output. *)\n+\n+let fmt = Format.fprintf;;\n+\n+let fmt_ident (ff:Format.formatter) (i:ident) : unit =\n+  fmt ff  \"%s\" i\n+\n+let fmt_temp (ff:Format.formatter) (t:temp_id) : unit =\n+  fmt ff  \".t%d\" (int_of_temp t)\n+\n+let fmt_slot_key ff (s:slot_key) : unit =\n+  match s with\n+      KEY_ident i -> fmt_ident ff i\n+    | KEY_temp t -> fmt_temp ff t\n+\n+let rec fmt_app (ff:Format.formatter) (i:ident) (tys:ty array) : unit =\n+  fmt ff \"%s\" i;\n+  fmt_app_args ff tys\n+\n+and fmt_app_args (ff:Format.formatter) (tys:ty array) : unit =\n+  fmt ff \"[@[\";\n+  for i = 0 to (Array.length tys) - 1;\n+  do\n+    if i != 0\n+    then fmt ff \",@ \";\n+    fmt_ty ff tys.(i);\n+  done;\n+  fmt ff \"@]]\"\n+\n+and fmt_name_base (ff:Format.formatter) (nb:name_base) : unit =\n+  match nb with\n+      BASE_ident i -> fmt_ident ff i\n+    | BASE_temp t -> fmt_temp ff t\n+    | BASE_app (id, tys) -> fmt_app ff id tys\n+\n+and fmt_name_component (ff:Format.formatter) (nc:name_component) : unit =\n+  match nc with\n+      COMP_ident i -> fmt_ident ff i\n+    | COMP_app (id, tys) -> fmt_app ff id tys\n+    | COMP_idx i -> fmt ff \"_%d\" i\n+\n+and fmt_name (ff:Format.formatter) (n:name) : unit =\n+  match n with\n+      NAME_base nb -> fmt_name_base ff nb\n+    | NAME_ext (n, nc) ->\n+        fmt_name ff n;\n+        fmt ff \".\";\n+        fmt_name_component ff nc\n+\n+and fmt_mutable (ff:Format.formatter) (m:bool) : unit =\n+  if m\n+  then fmt ff \"mutable \";\n+\n+and fmt_mode (ff:Format.formatter) (m:mode) : unit =\n+  match m with\n+      MODE_exterior -> fmt ff \"@@\"\n+    | MODE_alias -> fmt ff \"&\"\n+    | MODE_interior -> ()\n+\n+and fmt_slot (ff:Format.formatter) (s:slot) : unit =\n+  match s.slot_ty with\n+      None -> fmt ff \"auto\"\n+    | Some t ->\n+        fmt_mutable ff s.slot_mutable;\n+        fmt_mode ff s.slot_mode;\n+        fmt_ty ff t\n+\n+and fmt_slots\n+    (ff:Format.formatter)\n+    (slots:slot array)\n+    (idents:(ident array) option)\n+    : unit =\n+  fmt ff \"(@[\";\n+  for i = 0 to (Array.length slots) - 1\n+  do\n+    if i != 0\n+    then fmt ff \",@ \";\n+    fmt_slot ff slots.(i);\n+    begin\n+      match idents with\n+          None -> ()\n+        | Some ids -> (fmt ff \" \"; fmt_ident ff ids.(i))\n+    end;\n+  done;\n+  fmt ff \"@])\"\n+\n+and fmt_effect\n+    (ff:Format.formatter)\n+    (effect:effect)\n+    : unit =\n+  match effect with\n+      PURE -> ()\n+    | IO -> fmt ff \"io\"\n+    | STATE -> fmt ff \"state\"\n+    | UNSAFE -> fmt ff \"unsafe\"\n+\n+and fmt_ty_fn\n+    (ff:Format.formatter)\n+    (ident_and_params:(ident * ty_param array) option)\n+    (tf:ty_fn)\n+    : unit =\n+  let (tsig, ta) = tf in\n+    fmt_effect ff ta.fn_effect;\n+    if ta.fn_effect <> PURE then fmt ff \" \";\n+    fmt ff \"%s\" (if ta.fn_is_iter then \"iter\" else \"fn\");\n+    begin\n+      match ident_and_params with\n+          Some (id, params) ->\n+            fmt ff \" \";\n+            fmt_ident_and_params ff id params\n+        | None -> ()\n+    end;\n+    fmt_slots ff tsig.sig_input_slots None;\n+    fmt_decl_constrs ff tsig.sig_input_constrs;\n+    fmt ff \" -> \";\n+    fmt_slot ff tsig.sig_output_slot;\n+\n+and fmt_tag (ff:Format.formatter) (ttag:ty_tag) : unit =\n+  fmt ff \"@[tag(@[\";\n+  let first = ref true in\n+    Hashtbl.iter\n+      begin\n+        fun name ttup ->\n+          (if !first\n+           then first := false\n+           else fmt ff \",@ \");\n+          fmt_name ff name;\n+          fmt_slots ff ttup None\n+      end\n+      ttag;\n+    fmt ff \"@])@]\"\n+\n+and fmt_iso (ff:Format.formatter) (tiso:ty_iso) : unit =\n+  fmt ff \"@[iso [@[\";\n+  for i = 0 to (Array.length tiso.iso_group) - 1\n+  do\n+    if i != 0\n+    then fmt ff \",@ \";\n+    if i == tiso.iso_index\n+    then fmt ff \"<%d>: \" i\n+    else fmt ff \"%d: \" i;\n+    fmt_tag ff tiso.iso_group.(i);\n+  done;\n+  fmt ff \"@]]@]\"\n+\n+and fmt_ty (ff:Format.formatter) (t:ty) : unit =\n+  match t with\n+    TY_any -> fmt ff \"any\"\n+  | TY_nil -> fmt ff \"()\"\n+  | TY_bool -> fmt ff \"bool\"\n+  | TY_mach m -> fmt_mach ff m\n+  | TY_int -> fmt ff \"int\"\n+  | TY_uint -> fmt ff \"uint\"\n+  | TY_char -> fmt ff \"char\"\n+  | TY_str -> fmt ff \"str\"\n+\n+  | TY_tup slots -> (fmt ff \"tup\"; fmt_slots ff slots None)\n+  | TY_vec s -> (fmt ff \"vec[\"; fmt_slot ff s; fmt ff \"]\")\n+  | TY_chan t -> (fmt ff \"chan[\"; fmt_ty ff t; fmt ff \"]\")\n+  | TY_port t -> (fmt ff \"port[\"; fmt_ty ff t; fmt ff \"]\")\n+\n+  | TY_rec slots ->\n+      let (idents, slots) =\n+        let (idents, slots) = List.split (Array.to_list slots) in\n+          (Array.of_list idents, Array.of_list slots)\n+      in\n+        fmt ff \"@[rec\";\n+        fmt_slots ff slots (Some idents);\n+        fmt ff \"@]\"\n+\n+  | TY_param (i, e) -> (fmt_effect ff e;\n+                        if e <> PURE then fmt ff \" \";\n+                        fmt ff \"<p#%d>\" i)\n+  | TY_native oid -> fmt ff \"<native#%d>\" (int_of_opaque oid)\n+  | TY_named n -> fmt_name ff n\n+  | TY_type -> fmt ff \"type\"\n+\n+  | TY_fn tfn -> fmt_ty_fn ff None tfn\n+  | TY_task -> fmt ff \"task\"\n+  | TY_tag ttag -> fmt_tag ff ttag\n+  | TY_iso tiso -> fmt_iso ff tiso\n+  | TY_idx idx -> fmt ff \"<idx#%d>\" idx\n+  | TY_constrained _ -> fmt ff \"?constrained?\"\n+\n+  | TY_obj (effect, fns) ->\n+      fmt_obox ff;\n+      fmt_effect ff effect;\n+      if effect <> PURE then fmt ff \" \";\n+      fmt ff \"obj \";\n+      fmt_obr ff;\n+      Hashtbl.iter\n+        begin\n+          fun id fn ->\n+            fmt ff \"@\\n\";\n+            fmt_ty_fn ff (Some (id, [||])) fn;\n+            fmt ff \";\"\n+        end\n+        fns;\n+      fmt_cbb ff\n+\n+\n+and fmt_constrs (ff:Format.formatter) (cc:constr array) : unit =\n+  Array.iter (fmt_constr ff) cc\n+\n+and fmt_decl_constrs (ff:Format.formatter) (cc:constr array) : unit =\n+  if Array.length cc = 0\n+  then ()\n+  else\n+    begin\n+      fmt ff \" : \";\n+      fmt_constrs ff cc\n+    end\n+\n+and fmt_constr (ff:Format.formatter) (c:constr) : unit =\n+  fmt_name ff c.constr_name;\n+  fmt ff \"(@[\";\n+  for i = 0 to (Array.length c.constr_args) - 1\n+  do\n+    if i != 0\n+    then fmt ff \",@ \";\n+    fmt_carg ff c.constr_args.(i);\n+  done;\n+  fmt ff \"@])\"\n+\n+and fmt_carg_path (ff:Format.formatter) (cp:carg_path) : unit =\n+  match cp with\n+      CARG_base BASE_formal -> fmt ff \"*\"\n+    | CARG_base (BASE_named nb) -> fmt_name_base ff nb\n+    | CARG_ext (base, nc) ->\n+        fmt_carg_path ff base;\n+        fmt ff \".\";\n+        fmt_name_component ff nc\n+\n+and fmt_carg (ff:Format.formatter) (ca:carg) : unit =\n+  match ca with\n+      CARG_path cp -> fmt_carg_path ff cp\n+    | CARG_lit lit -> fmt_lit ff lit\n+\n+and fmt_obox ff = Format.pp_open_box ff 4\n+and fmt_obox_3 ff = Format.pp_open_box ff 3\n+and fmt_cbox ff = Format.pp_close_box ff ()\n+and fmt_obr ff = fmt ff \"{\"\n+and fmt_cbr ff = fmt ff \"@\\n}\"\n+and fmt_cbb ff = (fmt_cbox ff; fmt_cbr ff)\n+\n+and fmt_stmts (ff:Format.formatter) (ss:stmt array) : unit =\n+  Array.iter (fmt_stmt ff) ss;\n+\n+and fmt_block (ff:Format.formatter) (b:stmt array) : unit =\n+  fmt_obox ff;\n+  fmt_obr ff;\n+  fmt_stmts ff b;\n+  fmt_cbb ff;\n+\n+and fmt_binop (ff:Format.formatter) (b:binop) : unit =\n+  fmt ff \"%s\"\n+    begin\n+      match b with\n+          BINOP_or -> \"|\"\n+        | BINOP_and -> \"&\"\n+        | BINOP_xor -> \"^\"\n+\n+        | BINOP_eq -> \"==\"\n+        | BINOP_ne -> \"!=\"\n+\n+        | BINOP_lt -> \"<\"\n+        | BINOP_le -> \"<=\"\n+        | BINOP_ge -> \">=\"\n+        | BINOP_gt -> \">\"\n+\n+        | BINOP_lsl -> \"<<\"\n+        | BINOP_lsr -> \">>\"\n+        | BINOP_asr -> \">>>\"\n+\n+        | BINOP_add -> \"+\"\n+        | BINOP_sub -> \"-\"\n+        | BINOP_mul -> \"*\"\n+        | BINOP_div -> \"/\"\n+        | BINOP_mod -> \"%\"\n+        | BINOP_send -> \"<|\"\n+    end\n+\n+\n+and fmt_unop (ff:Format.formatter) (u:unop) (a:atom) : unit =\n+  begin\n+    match u with\n+        UNOP_not ->\n+          fmt ff \"!\";\n+          fmt_atom ff a\n+\n+      | UNOP_bitnot ->\n+          fmt ff \"~\";\n+          fmt_atom ff a\n+\n+      | UNOP_neg ->\n+          fmt ff \"-\";\n+          fmt_atom ff a\n+\n+      | UNOP_cast t ->\n+          fmt_atom ff a;\n+          fmt ff \" as \";\n+          fmt_ty ff t.node;\n+  end\n+\n+and fmt_expr (ff:Format.formatter) (e:expr) : unit =\n+  match e with\n+    EXPR_binary (b,a1,a2) ->\n+      begin\n+        fmt_atom ff a1;\n+        fmt ff \" \";\n+        fmt_binop ff b;\n+        fmt ff \" \";\n+        fmt_atom ff a2\n+      end\n+  | EXPR_unary (u,a) ->\n+      begin\n+        fmt_unop ff u a;\n+      end\n+  | EXPR_atom a -> fmt_atom ff a\n+\n+and fmt_mach (ff:Format.formatter) (m:ty_mach) : unit =\n+  match m with\n+    TY_u8 -> fmt ff \"u8\"\n+  | TY_u16 -> fmt ff \"u16\"\n+  | TY_u32 -> fmt ff \"u32\"\n+  | TY_u64 -> fmt ff \"u64\"\n+  | TY_i8 -> fmt ff \"i8\"\n+  | TY_i16 -> fmt ff \"i16\"\n+  | TY_i32 -> fmt ff \"i32\"\n+  | TY_i64 -> fmt ff \"i64\"\n+  | TY_f32 -> fmt ff \"f32\"\n+  | TY_f64 -> fmt ff \"f64\"\n+\n+and fmt_lit (ff:Format.formatter) (l:lit) : unit =\n+  match l with\n+  | LIT_nil -> fmt ff \"()\"\n+  | LIT_bool true -> fmt ff \"true\"\n+  | LIT_bool false -> fmt ff \"false\"\n+  | LIT_mach (m, _, s) ->\n+      begin\n+        fmt_mach ff m;\n+        fmt ff \"(%s)\" s\n+      end\n+  | LIT_int (_,s) -> fmt ff \"%s\" s\n+  | LIT_uint (_,s) -> fmt ff \"%s\" s\n+  | LIT_char c -> fmt ff \"'%s'\" (Common.escaped_char c)\n+\n+and fmt_domain (ff:Format.formatter) (d:domain) : unit =\n+  match d with\n+      DOMAIN_local -> ()\n+    | DOMAIN_thread -> fmt ff \"thread \"\n+\n+and fmt_atom (ff:Format.formatter) (a:atom) : unit =\n+  match a with\n+      ATOM_literal lit -> fmt_lit ff lit.node\n+    | ATOM_lval lval -> fmt_lval ff lval\n+\n+and fmt_atoms (ff:Format.formatter) (az:atom array) : unit =\n+  fmt ff \"(\";\n+  Array.iteri\n+    begin\n+      fun i a ->\n+        if i != 0\n+        then fmt ff \", \";\n+        fmt_atom ff a;\n+    end\n+    az;\n+  fmt ff \")\"\n+\n+and fmt_atom_opts (ff:Format.formatter) (az:(atom option) array) : unit =\n+  fmt ff \"(\";\n+  Array.iteri\n+    begin\n+      fun i a ->\n+        if i != 0\n+        then fmt ff \", \";\n+        match a with\n+            None -> fmt ff \"_\"\n+          | Some a -> fmt_atom ff a;\n+    end\n+    az;\n+  fmt ff \")\"\n+\n+and fmt_lval_component (ff:Format.formatter) (lvc:lval_component) : unit =\n+  match lvc with\n+      COMP_named nc -> fmt_name_component ff nc\n+    | COMP_atom a ->\n+        begin\n+          fmt ff \"(\";\n+          fmt_atom ff a;\n+          fmt ff \")\"\n+        end\n+\n+and fmt_lval (ff:Format.formatter) (l:lval) : unit =\n+  match l with\n+      LVAL_base nbi -> fmt_name_base ff nbi.node\n+    | LVAL_ext (lv, lvc) ->\n+        begin\n+          fmt_lval ff lv;\n+          fmt ff \".\";\n+          fmt_lval_component ff lvc\n+        end\n+\n+and fmt_stmt (ff:Format.formatter) (s:stmt) : unit =\n+  fmt ff \"@\\n\";\n+  fmt_stmt_body ff s\n+\n+and fmt_stmt_body (ff:Format.formatter) (s:stmt) : unit =\n+  begin\n+    match s.node with\n+        STMT_log at ->\n+          begin\n+            fmt ff \"log \";\n+            fmt_atom ff at;\n+            fmt ff \";\"\n+          end\n+\n+      | STMT_spawn (dst, domain, fn, args) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = spawn \";\n+          fmt_domain ff domain;\n+          fmt_lval ff fn;\n+          fmt_atoms ff args;\n+          fmt ff \";\";\n+\n+      | STMT_while sw ->\n+          let (stmts, e) = sw.while_lval in\n+            begin\n+              fmt_obox ff;\n+              fmt ff \"while (\";\n+              if Array.length stmts != 0\n+              then fmt_block ff stmts;\n+              fmt_expr ff e;\n+              fmt ff \") \";\n+              fmt_obr ff;\n+              fmt_stmts ff sw.while_body.node;\n+              fmt_cbb ff\n+            end\n+\n+      | STMT_do_while sw ->\n+          let (stmts, e) = sw.while_lval in\n+            begin\n+              fmt_obox ff;\n+              fmt ff \"do \";\n+              fmt_obr ff;\n+              fmt_stmts ff sw.while_body.node;\n+              fmt ff \"while (\";\n+              if Array.length stmts != 0\n+              then fmt_block ff stmts;\n+              fmt_expr ff e;\n+              fmt ff \");\";\n+              fmt_cbb ff\n+            end\n+\n+      | STMT_if sif ->\n+          fmt_obox ff;\n+          fmt ff \"if (\";\n+          fmt_expr ff sif.if_test;\n+          fmt ff \") \";\n+          fmt_obr ff;\n+          fmt_stmts ff sif.if_then.node;\n+          begin\n+            match sif.if_else with\n+                None -> ()\n+              | Some e ->\n+                  begin\n+                    fmt_cbb ff;\n+                    fmt_obox_3 ff;\n+                    fmt ff \" else \";\n+                    fmt_obr ff;\n+                    fmt_stmts ff e.node\n+                  end\n+          end;\n+          fmt_cbb ff\n+\n+      | STMT_ret (ao) ->\n+          fmt ff \"ret\";\n+          begin\n+            match ao with\n+                None -> ()\n+              | Some at ->\n+                  fmt ff \" \";\n+                  fmt_atom ff at\n+          end;\n+          fmt ff \";\"\n+\n+      | STMT_be (fn, az) ->\n+          fmt ff \"be \";\n+          fmt_lval ff fn;\n+          fmt_atoms ff az;\n+          fmt ff \";\";\n+\n+      | STMT_block b -> fmt_block ff b.node\n+\n+      | STMT_copy (lv, ex) ->\n+          fmt_lval ff lv;\n+          fmt ff \" = \";\n+          fmt_expr ff ex;\n+          fmt ff \";\"\n+\n+      | STMT_copy_binop (lv, binop, at) ->\n+          fmt_lval ff lv;\n+          fmt ff \" \";\n+          fmt_binop ff binop;\n+          fmt ff \"=\";\n+          fmt_atom ff at;\n+          fmt ff \";\"\n+\n+      | STMT_call (dst, fn, args) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = \";\n+          fmt_lval ff fn;\n+          fmt_atoms ff args;\n+          fmt ff \";\";\n+\n+      | STMT_bind (dst, fn, arg_opts) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = \";\n+          fmt_lval ff fn;\n+          fmt_atom_opts ff arg_opts;\n+          fmt ff \";\";\n+\n+      | STMT_decl (DECL_slot (skey, sloti)) ->\n+          if sloti.node.slot_ty != None then fmt ff \"let \";\n+          fmt_slot ff sloti.node;\n+          fmt ff \" \";\n+          fmt_slot_key ff skey;\n+          fmt ff \";\"\n+\n+      | STMT_decl (DECL_mod_item (ident, item)) ->\n+          fmt_mod_item ff ident item\n+\n+      | STMT_init_rec (dst, entries, base) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = rec(\";\n+          for i = 0 to (Array.length entries) - 1\n+          do\n+            if i != 0\n+            then fmt ff \", \";\n+            let (ident, mode, mut, atom) = entries.(i) in\n+              fmt_ident ff ident;\n+              fmt ff \" = \";\n+              fmt_mutable ff mut;\n+              fmt_mode ff mode;\n+              fmt_atom ff atom;\n+          done;\n+          begin\n+            match base with\n+                None -> ()\n+              | Some b ->\n+                  fmt ff \" with \";\n+                  fmt_lval ff b\n+          end;\n+          fmt ff \");\"\n+\n+      | STMT_init_vec (dst, _, atoms) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = vec(\";\n+          for i = 0 to (Array.length atoms) - 1\n+          do\n+            if i != 0\n+            then fmt ff \", \";\n+            fmt_atom ff atoms.(i);\n+          done;\n+          fmt ff \");\"\n+\n+      | STMT_init_tup (dst, entries) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = (\";\n+          for i = 0 to (Array.length entries) - 1\n+          do\n+            if i != 0\n+            then fmt ff \", \";\n+            let (mode, mut, atom) = entries.(i) in\n+              fmt_mutable ff mut;\n+              fmt_mode ff mode;\n+              fmt_atom ff atom;\n+          done;\n+          fmt ff \");\";\n+\n+      | STMT_init_str (dst, s) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = \\\"%s\\\"\" (String.escaped s)\n+\n+      | STMT_init_port dst ->\n+          fmt_lval ff dst;\n+          fmt ff \" = port();\"\n+\n+      | STMT_init_chan (dst, port_opt) ->\n+          fmt_lval ff dst;\n+          fmt ff \" = chan(\";\n+          begin\n+            match port_opt with\n+                None -> ()\n+              | Some lv -> fmt_lval ff lv\n+          end;\n+          fmt ff \");\"\n+\n+      | STMT_check_expr expr ->\n+          fmt ff \"check (\";\n+          fmt_expr ff expr;\n+          fmt ff \");\"\n+\n+      | STMT_check_if (constrs, _, block) ->\n+          fmt_obox ff;\n+          fmt ff \"check if (\";\n+          fmt_constrs ff constrs;\n+          fmt ff \")\";\n+          fmt_obr ff;\n+          fmt_stmts ff block.node;\n+          fmt_cbb ff\n+\n+      | STMT_check (constrs, _) ->\n+          fmt ff \"check \";\n+          fmt_constrs ff constrs;\n+          fmt ff \";\"\n+\n+      | STMT_prove constrs ->\n+          fmt ff \"prove \";\n+          fmt_constrs ff constrs;\n+          fmt ff \";\"\n+\n+      | STMT_for sfor ->\n+          let (slot, ident) = sfor.for_slot in\n+          let (stmts, lval) = sfor.for_seq in\n+            begin\n+              fmt_obox ff;\n+              fmt ff \"for (\";\n+              fmt_slot ff slot.node;\n+              fmt ff \" \";\n+              fmt_ident ff ident;\n+              fmt ff \" in \";\n+              fmt_stmts ff stmts;\n+              fmt_lval ff lval;\n+              fmt ff \") \";\n+              fmt_obr ff;\n+              fmt_stmts ff sfor.for_body.node;\n+              fmt_cbb ff\n+            end\n+\n+      | STMT_for_each sf ->\n+          let (slot, ident) = sf.for_each_slot in\n+          let (f, az) = sf.for_each_call in\n+            begin\n+              fmt_obox ff;\n+              fmt ff \"for each (\";\n+              fmt_slot ff slot.node;\n+              fmt ff \" \";\n+              fmt_ident ff ident;\n+              fmt ff \" = \";\n+              fmt_lval ff f;\n+              fmt_atoms ff az;\n+              fmt ff \" \";\n+              fmt_obr ff;\n+              fmt_stmts ff sf.for_each_body.node;\n+              fmt_cbb ff\n+            end\n+\n+      | STMT_put (atom) ->\n+          fmt ff \"put \";\n+          begin\n+            match atom with\n+                Some a -> (fmt ff \" \"; fmt_atom ff a)\n+              | None -> ()\n+          end;\n+          fmt ff \";\"\n+\n+      | STMT_put_each (f, az) ->\n+          fmt ff \"put each \";\n+          fmt_lval ff f;\n+          fmt_atoms ff az;\n+          fmt ff \";\"\n+\n+      | STMT_fail -> fmt ff \"fail;\"\n+      | STMT_yield -> fmt ff \"yield;\"\n+\n+      | STMT_send (chan, v) ->\n+          fmt_lval ff chan;\n+          fmt ff \" <| \";\n+          fmt_lval ff v;\n+          fmt ff \";\";\n+\n+      | STMT_recv (d, port) ->\n+          fmt_lval ff d;\n+          fmt ff \" <- \";\n+          fmt_lval ff port;\n+          fmt ff \";\";\n+\n+      | STMT_join t ->\n+          fmt ff \"join \";\n+          fmt_lval ff t;\n+          fmt ff \";\"\n+\n+      | STMT_alt_tag _ -> fmt ff \"?stmt_alt_tag?\"\n+      | STMT_alt_type _ -> fmt ff \"?stmt_alt_type?\"\n+      | STMT_alt_port _ -> fmt ff \"?stmt_alt_port?\"\n+      | STMT_note _ -> fmt ff \"?stmt_note?\"\n+      | STMT_slice _ -> fmt ff \"?stmt_slice?\"\n+  end\n+\n+and fmt_decl_params (ff:Format.formatter) (params:ty_param array) : unit =\n+  if Array.length params = 0\n+  then ()\n+  else\n+    begin\n+      fmt ff \"[\";\n+      for i = 0 to (Array.length params) - 1\n+      do\n+        if i <> 0\n+        then fmt ff \", \";\n+        let (ident, (i, e)) = params.(i) in\n+          fmt_effect ff e;\n+          if e <> PURE then fmt ff \" \";\n+          fmt_ident ff ident;\n+          fmt ff \"=<p#%d>\" i\n+      done;\n+      fmt ff \"]\"\n+    end;\n+\n+and fmt_header_slots (ff:Format.formatter) (hslots:header_slots) : unit =\n+  fmt_slots ff\n+    (Array.map (fun (s,_) -> s.node) hslots)\n+    (Some (Array.map (fun (_, i) -> i) hslots))\n+\n+and fmt_ident_and_params\n+    (ff:Format.formatter)\n+    (id:ident)\n+    (params:ty_param array)\n+    : unit =\n+  fmt_ident ff id;\n+  fmt_decl_params ff params\n+\n+and fmt_fn\n+    (ff:Format.formatter)\n+    (id:ident)\n+    (params:ty_param array)\n+    (f:fn)\n+    : unit =\n+  fmt_obox ff;\n+  fmt_effect ff f.fn_aux.fn_effect;\n+  if f.fn_aux.fn_effect <> PURE then fmt ff \" \";\n+  fmt ff \"%s \"(if f.fn_aux.fn_is_iter then \"iter\" else \"fn\");\n+  fmt_ident_and_params ff id params;\n+  fmt_header_slots ff f.fn_input_slots;\n+  fmt_decl_constrs ff f.fn_input_constrs;\n+  fmt ff \" -> \";\n+  fmt_slot ff f.fn_output_slot.node;\n+  fmt ff \" \";\n+  fmt_obr ff;\n+  fmt_stmts ff f.fn_body.node;\n+  fmt_cbb ff\n+\n+\n+and fmt_obj\n+    (ff:Format.formatter)\n+    (id:ident)\n+    (params:ty_param array)\n+    (obj:obj)\n+    : unit =\n+  fmt_obox ff;\n+  fmt_effect ff obj.obj_effect;\n+  if obj.obj_effect <> PURE then fmt ff \" \";\n+  fmt ff \"obj \";\n+  fmt_ident_and_params ff id params;\n+  fmt_header_slots ff obj.obj_state;\n+  fmt_decl_constrs ff obj.obj_constrs;\n+  fmt ff \" \";\n+  fmt_obr ff;\n+  Hashtbl.iter\n+    begin\n+      fun id fn ->\n+        fmt ff \"@\\n\";\n+        fmt_fn ff id [||] fn.node\n+    end\n+    obj.obj_fns;\n+  begin\n+    match obj.obj_drop with\n+        None -> ()\n+      | Some d ->\n+          begin\n+            fmt ff \"@\\n\";\n+            fmt_obox ff;\n+            fmt ff \"drop \";\n+            fmt_obr ff;\n+            fmt_stmts ff d.node;\n+            fmt_cbb ff;\n+          end\n+  end;\n+  fmt_cbb ff\n+\n+\n+and fmt_mod_item (ff:Format.formatter) (id:ident) (item:mod_item) : unit =\n+  fmt ff \"@\\n\";\n+  let params = item.node.decl_params in\n+  let params = Array.map (fun i -> i.node) params in\n+    begin\n+      match item.node.decl_item with\n+          MOD_ITEM_type ty ->\n+            fmt ff \"type \";\n+            fmt_ident_and_params ff id params;\n+            fmt ff \" = \";\n+            fmt_ty ff ty;\n+            fmt ff \";\";\n+\n+        | MOD_ITEM_tag (hdr, ttag, _) ->\n+            fmt ff \"fn \";\n+            fmt_ident_and_params ff id params;\n+            fmt_header_slots ff\n+              (Array.mapi (fun i s -> (s,(Printf.sprintf \"_%d\" i))) hdr);\n+            fmt ff \" -> \";\n+            fmt_ty ff (TY_tag ttag);\n+            fmt ff \";\";\n+\n+        | MOD_ITEM_mod (view,items) ->\n+            fmt_obox ff;\n+            fmt ff \"mod \";\n+            fmt_ident_and_params ff id params;\n+            fmt ff \" \";\n+            fmt_obr ff;\n+            fmt_mod_view ff view;\n+            fmt_mod_items ff items;\n+            fmt_cbb ff\n+\n+        | MOD_ITEM_fn f ->\n+            fmt_fn ff id params f\n+\n+        | MOD_ITEM_obj obj ->\n+            fmt_obj ff id params obj\n+    end\n+\n+and fmt_import (ff:Format.formatter) (ident:ident) (name:name) : unit =\n+  fmt ff \"@\\n\";\n+  fmt ff \"import \";\n+  fmt ff \"%s = \" ident;\n+  fmt_name ff name;\n+\n+and fmt_export (ff:Format.formatter) (export:export) _ : unit =\n+  fmt ff \"@\\n\";\n+  match export with\n+      EXPORT_all_decls -> fmt ff \"export *;\"\n+    | EXPORT_ident i -> fmt ff \"export %s;\" i\n+\n+and fmt_mod_view (ff:Format.formatter) (mv:mod_view) : unit =\n+  Hashtbl.iter (fmt_import ff) mv.view_imports;\n+  Hashtbl.iter (fmt_export ff) mv.view_exports\n+\n+and fmt_mod_items (ff:Format.formatter) (mi:mod_items) : unit =\n+  Hashtbl.iter (fmt_mod_item ff) mi\n+\n+and fmt_crate (ff:Format.formatter) (c:crate) : unit =\n+  let (view,items) = c.node.crate_items in\n+    fmt_mod_view ff view;\n+    fmt_mod_items ff items\n+\n+\n+let fmt_to_str (f:Format.formatter -> 'a -> unit) (v:'a) : string =\n+  let buf = Buffer.create 16 in\n+  let bf = Format.formatter_of_buffer buf in\n+    begin\n+      f bf v;\n+      Format.pp_print_flush bf ();\n+      Buffer.contents buf\n+    end\n+\n+let sprintf_fmt\n+    (f:Format.formatter -> 'a -> unit)\n+    : (unit -> 'a -> string) =\n+  (fun _ -> fmt_to_str f)\n+\n+\n+let sprintf_expr = sprintf_fmt fmt_expr;;\n+let sprintf_name = sprintf_fmt fmt_name;;\n+let sprintf_lval = sprintf_fmt fmt_lval;;\n+let sprintf_lval_component = sprintf_fmt fmt_lval_component;;\n+let sprintf_atom = sprintf_fmt fmt_atom;;\n+let sprintf_slot = sprintf_fmt fmt_slot;;\n+let sprintf_slot_key = sprintf_fmt fmt_slot_key;;\n+let sprintf_mutable = sprintf_fmt fmt_mutable;;\n+let sprintf_ty = sprintf_fmt fmt_ty;;\n+let sprintf_effect = sprintf_fmt fmt_effect;;\n+let sprintf_tag = sprintf_fmt fmt_tag;;\n+let sprintf_carg = sprintf_fmt fmt_carg;;\n+let sprintf_constr = sprintf_fmt fmt_constr;;\n+let sprintf_stmt = sprintf_fmt fmt_stmt;;\n+let sprintf_mod_items = sprintf_fmt fmt_mod_items;;\n+let sprintf_decl_params = sprintf_fmt fmt_decl_params;;\n+let sprintf_app_args = sprintf_fmt fmt_app_args;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "6dffdb96d0264d08036a6875e8956d747349ed61", "filename": "src/boot/fe/cexp.ml", "status": "added", "additions": 762, "deletions": 0, "changes": 762, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fcexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fcexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fcexp.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,762 @@\n+\n+open Common;;\n+open Token;;\n+open Parser;;\n+\n+(* NB: cexps (crate-expressions / constant-expressions) are only used\n+ * transiently during compilation: they are the outermost expression-language\n+ * describing crate configuration and constants. They are completely evaluated\n+ * at compile-time, in a little micro-interpreter defined here, with the\n+ * results of evaluation being the sequence of directives controlling the rest\n+ * of the compiler.\n+ * \n+ * Cexps, like pexps, do not escape the language front-end.\n+ * \n+ * You can think of the AST as a statement-language called \"item\" sandwiched\n+ * between two expression-languages, \"cexp\" on the outside and \"pexp\" on the\n+ * inside. The front-end evaluates cexp on the outside in order to get one big\n+ * directive-list, evaluating those parts of pexp that are directly used by\n+ * cexp in passing, and desugaring those remaining parts of pexp that are\n+ * embedded within the items of the directives.\n+ * \n+ * The rest of the compiler only deals with the directives, which are mostly\n+ * just a set of containers for items. Items are what most of AST describes\n+ * (\"most\" because the type-grammar spans both items and pexps).\n+ * \n+ *)\n+\n+type meta = (Ast.ident * Pexp.pexp) array;;\n+\n+type meta_pat = (Ast.ident * (Pexp.pexp option)) array;;\n+\n+type auth = (Ast.name * Ast.effect);;\n+\n+type cexp =\n+    CEXP_alt of cexp_alt identified\n+  | CEXP_let of cexp_let identified\n+  | CEXP_src_mod of cexp_src identified\n+  | CEXP_dir_mod of cexp_dir identified\n+  | CEXP_use_mod of cexp_use identified\n+  | CEXP_nat_mod of cexp_nat identified\n+  | CEXP_meta of meta identified\n+  | CEXP_auth of auth identified\n+\n+and cexp_alt =\n+    { alt_val: Pexp.pexp;\n+      alt_arms: (Pexp.pexp * cexp array) array;\n+      alt_else: cexp array }\n+\n+and cexp_let =\n+    { let_ident: Ast.ident;\n+      let_value: Pexp.pexp;\n+      let_body: cexp array; }\n+\n+and cexp_src =\n+    { src_ident: Ast.ident;\n+      src_path: Pexp.pexp option }\n+\n+and cexp_dir =\n+    { dir_ident: Ast.ident;\n+      dir_path: Pexp.pexp option;\n+      dir_body: cexp array }\n+\n+and cexp_use =\n+    { use_ident: Ast.ident;\n+      use_meta: meta_pat; }\n+\n+and cexp_nat =\n+    { nat_abi: string;\n+      nat_ident: Ast.ident;\n+      nat_path: Pexp.pexp option;\n+      (* \n+       * FIXME: possibly support embedding optional strings as\n+       * symbol-names, to handle mangling schemes that aren't\n+       * Token.IDENT values\n+       *)\n+      nat_items: Ast.mod_items;\n+    }\n+;;\n+\n+\n+(* Cexp grammar. *)\n+\n+let parse_meta_input (ps:pstate) : (Ast.ident * Pexp.pexp option) =\n+  let lab = (ctxt \"meta input: label\" Pexp.parse_ident ps) in\n+    match peek ps with\n+        EQ ->\n+          bump ps;\n+          let v =\n+            match peek ps with\n+                UNDERSCORE -> bump ps; None\n+              | _ -> Some (Pexp.parse_pexp ps)\n+          in\n+            (lab, v)\n+      | _ -> raise (unexpected ps)\n+;;\n+\n+let parse_meta_pat (ps:pstate) : meta_pat =\n+  bracketed_zero_or_more LPAREN RPAREN\n+    (Some COMMA) parse_meta_input ps\n+;;\n+\n+let parse_meta (ps:pstate) : meta =\n+  Array.map\n+    begin\n+      fun (id,v) ->\n+        match v with\n+            None ->\n+              raise (err (\"wildcard found in meta pattern \"\n+                          ^ \"where value expected\") ps)\n+          | Some v -> (id,v)\n+    end\n+    (parse_meta_pat ps)\n+;;\n+\n+let parse_optional_meta_pat\n+    (ps:pstate)\n+    (ident:Ast.ident)\n+    : meta_pat =\n+  match peek ps with\n+      LPAREN -> parse_meta_pat ps\n+    | _ ->\n+        let apos = lexpos ps in\n+          [| (\"name\", Some (span ps apos apos (Pexp.PEXP_str ident))) |]\n+;;\n+\n+let rec parse_cexps (ps:pstate) (term:Token.token) : cexp array =\n+  let cexps = Queue.create () in\n+    while ((peek ps) <> term)\n+    do\n+      Queue.push (parse_cexp ps) cexps\n+    done;\n+    expect ps term;\n+    queue_to_arr cexps\n+\n+and parse_cexp (ps:pstate) : cexp =\n+\n+  let apos = lexpos ps in\n+    match peek ps with\n+        MOD ->\n+          begin\n+            bump ps;\n+            let name = ctxt \"mod: name\" Pexp.parse_ident ps in\n+            let path = ctxt \"mod: path\" parse_eq_pexp_opt ps\n+            in\n+              match peek ps with\n+                  SEMI ->\n+                    bump ps;\n+                    let bpos = lexpos ps in\n+                      CEXP_src_mod\n+                        (span ps apos bpos { src_ident = name;\n+                                             src_path = path })\n+                | LBRACE ->\n+                    let body =\n+                      bracketed_zero_or_more LBRACE RBRACE\n+                        None parse_cexp ps\n+                    in\n+                    let bpos = lexpos ps in\n+                      CEXP_dir_mod\n+                        (span ps apos bpos { dir_ident = name;\n+                                             dir_path = path;\n+                                             dir_body = body })\n+                | _ -> raise (unexpected ps)\n+        end\n+\n+      | NATIVE ->\n+          begin\n+            bump ps;\n+            let abi =\n+                match peek ps with\n+                    MOD -> \"cdecl\"\n+                  | LIT_STR s -> bump ps; s\n+                  | _ -> raise (unexpected ps)\n+            in\n+            let _ = expect ps MOD in\n+            let name = ctxt \"native mod: name\" Pexp.parse_ident ps in\n+            let path = ctxt \"native mod: path\" parse_eq_pexp_opt ps in\n+            let items = Hashtbl.create 0 in\n+            let get_item ps =\n+              let (ident, item) = Item.parse_mod_item_from_signature ps in\n+                htab_put items ident item;\n+            in\n+              ignore (bracketed_zero_or_more\n+                        LBRACE RBRACE None get_item ps);\n+              let bpos = lexpos ps in\n+                CEXP_nat_mod\n+                  (span ps apos bpos { nat_abi = abi;\n+                                       nat_ident = name;\n+                                       nat_path = path;\n+                                       nat_items = items })\n+          end\n+\n+      | USE ->\n+          begin\n+            bump ps;\n+            let ident = ctxt \"use mod: name\" Pexp.parse_ident ps in\n+            let meta =\n+              ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n+            in\n+            let bpos = lexpos ps in\n+              expect ps SEMI;\n+              CEXP_use_mod\n+                (span ps apos bpos { use_ident = ident;\n+                                     use_meta = meta })\n+          end\n+\n+      | LET ->\n+          begin\n+            bump ps;\n+            expect ps LPAREN;\n+            let id = Pexp.parse_ident ps in\n+              expect ps EQ;\n+              let v = Pexp.parse_pexp ps in\n+                expect ps RPAREN;\n+                expect ps LBRACE;\n+                let body = parse_cexps ps RBRACE in\n+                let bpos = lexpos ps in\n+                  CEXP_let\n+                    (span ps apos bpos\n+                       { let_ident = id;\n+                         let_value = v;\n+                         let_body = body })\n+          end\n+\n+      | ALT ->\n+          begin\n+            bump ps;\n+            expect ps LPAREN;\n+            let v = Pexp.parse_pexp ps in\n+              expect ps RPAREN;\n+              expect ps LBRACE;\n+              let rec consume_arms arms =\n+                match peek ps with\n+                    CASE ->\n+                      begin\n+                        bump ps;\n+                        expect ps LPAREN;\n+                        let cond = Pexp.parse_pexp ps in\n+                          expect ps RPAREN;\n+                          expect ps LBRACE;\n+                          let consequent = parse_cexps ps RBRACE in\n+                            let arm = (cond, consequent) in\n+                            consume_arms (arm::arms)\n+                      end\n+                  | ELSE ->\n+                      begin\n+                        bump ps;\n+                        expect ps LBRACE;\n+                        let consequent = parse_cexps ps RBRACE in\n+                          expect ps RBRACE;\n+                          let bpos = lexpos ps in\n+                            span ps apos bpos\n+                              { alt_val = v;\n+                                alt_arms = Array.of_list (List.rev arms);\n+                                alt_else = consequent }\n+                      end\n+\n+                  | _ -> raise (unexpected ps)\n+              in\n+                CEXP_alt (consume_arms [])\n+          end\n+\n+      | META ->\n+          bump ps;\n+          let meta = parse_meta ps in\n+            expect ps SEMI;\n+            let bpos = lexpos ps in\n+              CEXP_meta (span ps apos bpos meta)\n+\n+      | AUTH ->\n+          bump ps;\n+          let name = Pexp.parse_name ps in\n+            expect ps EQ;\n+            let effect = Pexp.parse_effect ps in\n+              expect ps SEMI;\n+              let bpos = lexpos ps in\n+                CEXP_auth (span ps apos bpos (name, effect))\n+\n+      | _ -> raise (unexpected ps)\n+\n+\n+and  parse_eq_pexp_opt (ps:pstate) : Pexp.pexp option =\n+  match peek ps with\n+      EQ ->\n+        begin\n+          bump ps;\n+          Some (Pexp.parse_pexp ps)\n+        end\n+    | _ -> None\n+;;\n+\n+\n+(*\n+ * Dynamic-typed micro-interpreter for the cexp language.\n+ * \n+ * The product of evaluating a pexp is a pval.\n+ * \n+ * The product of evlauating a cexp is a cdir array.\n+ *)\n+\n+type pval =\n+    PVAL_str of string\n+  | PVAL_num of int64\n+  | PVAL_bool of bool\n+;;\n+\n+type cdir =\n+    CDIR_meta of ((Ast.ident * string) array)\n+  | CDIR_syntax of Ast.name\n+  | CDIR_check of (Ast.name * pval array)\n+  | CDIR_mod of (Ast.ident * Ast.mod_item)\n+  | CDIR_auth of auth\n+\n+type env = { env_bindings: (Ast.ident * pval) list;\n+             env_prefix: filename list;\n+             env_items: (filename, Ast.mod_items) Hashtbl.t;\n+             env_files: (node_id,filename) Hashtbl.t;\n+             env_required: (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n+             env_required_syms: (node_id, string) Hashtbl.t;\n+             env_ps: pstate; }\n+\n+let unexpected_val (expected:string) (v:pval)  =\n+  let got =\n+    match v with\n+        PVAL_str s -> \"str \\\"\" ^ (String.escaped s) ^ \"\\\"\"\n+      | PVAL_num i -> \"num \" ^ (Int64.to_string i)\n+      | PVAL_bool b -> if b then \"bool true\" else \"bool false\"\n+  in\n+    (* FIXME: proper error reporting, please. *)\n+    bug () \"expected %s, got %s\" expected got\n+;;\n+\n+let rewrap_items id items =\n+  let item = decl [||] (Ast.MOD_ITEM_mod items) in\n+    { id = id; node = item }\n+;;\n+\n+\n+let rec eval_cexps (env:env) (exps:cexp array) : cdir array =\n+  Parser.arj (Array.map (eval_cexp env) exps)\n+\n+and eval_cexp (env:env) (exp:cexp) : cdir array =\n+  match exp with\n+      CEXP_alt {node=ca} ->\n+        let v = eval_pexp env ca.alt_val in\n+        let rec try_arm i =\n+          if i >= Array.length ca.alt_arms\n+          then ca.alt_else\n+          else\n+            let (arm_head, arm_body) = ca.alt_arms.(i) in\n+            let v' = eval_pexp env arm_head in\n+              if v' = v\n+              then arm_body\n+              else try_arm (i+1)\n+        in\n+          eval_cexps env (try_arm 0)\n+\n+    | CEXP_let {node=cl} ->\n+        let ident = cl.let_ident in\n+        let v = eval_pexp env cl.let_value in\n+        let env = { env with\n+                      env_bindings = ((ident,v)::env.env_bindings ) }\n+        in\n+          eval_cexps env cl.let_body\n+\n+    | CEXP_src_mod {node=s; id=id} ->\n+        let name = s.src_ident in\n+        let path =\n+          match s.src_path with\n+              None -> name ^ \".rs\"\n+            | Some p -> eval_pexp_to_str env p\n+        in\n+        let full_path =\n+          List.fold_left Filename.concat \"\"\n+            (List.rev (path :: env.env_prefix))\n+        in\n+        let ps = env.env_ps in\n+        let p =\n+          make_parser\n+            ps.pstate_temp_id\n+            ps.pstate_node_id\n+            ps.pstate_opaque_id\n+            ps.pstate_sess\n+            ps.pstate_get_mod\n+            ps.pstate_infer_lib_name\n+            env.env_required\n+            env.env_required_syms\n+            full_path\n+        in\n+        let items = Item.parse_mod_items p EOF in\n+          htab_put env.env_files id full_path;\n+          [| CDIR_mod (name, rewrap_items id items) |]\n+\n+    | CEXP_dir_mod {node=d; id=id} ->\n+        let items = Hashtbl.create 0 in\n+        let name = d.dir_ident in\n+        let path =\n+          match d.dir_path with\n+              None -> name\n+            | Some p -> eval_pexp_to_str env p\n+        in\n+        let env = { env with\n+                      env_prefix = path :: env.env_prefix } in\n+        let sub_directives = eval_cexps env d.dir_body in\n+        let add d =\n+          match d with\n+              CDIR_mod (name, item) ->\n+                htab_put items name item\n+            | _ -> raise (err \"non-'mod' directive found in 'dir' directive\"\n+                            env.env_ps)\n+        in\n+          Array.iter add sub_directives;\n+          [| CDIR_mod (name, rewrap_items id (Item.empty_view, items)) |]\n+\n+    | CEXP_use_mod {node=u; id=id} ->\n+        let ps = env.env_ps in\n+        let name = u.use_ident in\n+        let (path, items) =\n+          let meta_pat =\n+            Array.map\n+              begin\n+                fun (k,vo) ->\n+                  match vo with\n+                      None -> (k, None)\n+                    | Some p -> (k, Some (eval_pexp_to_str env p))\n+              end\n+              u.use_meta\n+          in\n+          ps.pstate_get_mod meta_pat id ps.pstate_node_id ps.pstate_opaque_id\n+        in\n+          iflog ps\n+            begin\n+              fun _ ->\n+                log ps \"extracted mod signature from %s (binding to %s)\"\n+                  path name;\n+                log ps \"%a\" Ast.sprintf_mod_items items;\n+            end;\n+          let rlib = REQUIRED_LIB_rust { required_libname = path;\n+                                         required_prefix = 1 }\n+          in\n+          let item = decl [||] (Ast.MOD_ITEM_mod (Item.empty_view, items)) in\n+          let item = { id = id; node = item } in\n+          let span = Hashtbl.find ps.pstate_sess.Session.sess_spans id in\n+            Item.note_required_mod env.env_ps span CONV_rust rlib item;\n+            [| CDIR_mod (name, item) |]\n+\n+    | CEXP_nat_mod {node=cn;id=id} ->\n+        let conv =\n+          let v = cn.nat_abi in\n+          match string_to_conv v with\n+              None -> unexpected_val \"calling convention\" (PVAL_str v)\n+            | Some c -> c\n+        in\n+        let name = cn.nat_ident in\n+        let filename =\n+          match cn.nat_path with\n+              None -> env.env_ps.pstate_infer_lib_name name\n+            | Some p -> eval_pexp_to_str env p\n+        in\n+        let item =\n+          decl [||] (Ast.MOD_ITEM_mod (Item.empty_view, cn.nat_items))\n+        in\n+        let item = { id = id; node = item } in\n+        let rlib = REQUIRED_LIB_c { required_libname = filename;\n+                                    required_prefix = 1 }\n+        in\n+        let ps = env.env_ps in\n+        let span = Hashtbl.find ps.pstate_sess.Session.sess_spans id in\n+          Item.note_required_mod env.env_ps span conv rlib item;\n+          [| CDIR_mod (name, item) |]\n+\n+    | CEXP_meta m ->\n+        [| CDIR_meta\n+             begin\n+               Array.map\n+                 begin\n+                   fun (id, p) -> (id, eval_pexp_to_str env p)\n+                 end\n+                 m.node\n+             end |]\n+\n+    | CEXP_auth a -> [| CDIR_auth a.node |]\n+\n+\n+and eval_pexp (env:env) (exp:Pexp.pexp) : pval =\n+  match exp.node with\n+    | Pexp.PEXP_binop (bop, a, b) ->\n+        begin\n+          let av = eval_pexp env a in\n+          let bv = eval_pexp env b in\n+            match (bop, av, bv) with\n+                (Ast.BINOP_add, PVAL_str az, PVAL_str bz) ->\n+                  PVAL_str (az ^ bz)\n+              | _ ->\n+                  let av = (need_num av) in\n+                  let bv = (need_num bv) in\n+                    PVAL_num\n+                      begin\n+                        match bop with\n+                            Ast.BINOP_add -> Int64.add av bv\n+                          | Ast.BINOP_sub -> Int64.sub av bv\n+                          | Ast.BINOP_mul -> Int64.mul av bv\n+                          | Ast.BINOP_div -> Int64.div av bv\n+                          | _ ->\n+                              bug ()\n+                                \"unhandled arithmetic op in Cexp.eval_pexp\"\n+                      end\n+        end\n+\n+    | Pexp.PEXP_unop (uop, a) ->\n+        begin\n+          match uop with\n+              Ast.UNOP_not ->\n+                PVAL_bool (not (eval_pexp_to_bool env a))\n+            | Ast.UNOP_neg ->\n+                PVAL_num (Int64.neg (eval_pexp_to_num env a))\n+            | _ -> bug () \"Unexpected unop in Cexp.eval_pexp\"\n+        end\n+\n+    | Pexp.PEXP_lval (Pexp.PLVAL_ident ident) ->\n+        begin\n+          match ltab_search env.env_bindings ident with\n+              None -> raise (err (Printf.sprintf \"no binding for '%s' found\"\n+                                    ident) env.env_ps)\n+            | Some v -> v\n+        end\n+\n+    | Pexp.PEXP_lit (Ast.LIT_bool b) ->\n+        PVAL_bool b\n+\n+    | Pexp.PEXP_lit (Ast.LIT_int (i, _)) ->\n+        PVAL_num i\n+\n+    | Pexp.PEXP_str s ->\n+        PVAL_str s\n+\n+    | _ -> bug () \"unexpected Pexp in Cexp.eval_pexp\"\n+\n+\n+and eval_pexp_to_str (env:env) (exp:Pexp.pexp) : string =\n+  match eval_pexp env exp with\n+      PVAL_str s -> s\n+    | v -> unexpected_val \"str\" v\n+\n+and need_num (cv:pval) : int64 =\n+  match cv with\n+      PVAL_num n -> n\n+    | v -> unexpected_val \"num\" v\n+\n+and eval_pexp_to_num (env:env) (exp:Pexp.pexp) : int64 =\n+  need_num (eval_pexp env exp)\n+\n+and eval_pexp_to_bool (env:env) (exp:Pexp.pexp) : bool =\n+  match eval_pexp env exp with\n+      PVAL_bool b -> b\n+    | v -> unexpected_val \"bool\" v\n+\n+;;\n+\n+\n+let find_main_fn\n+    (ps:pstate)\n+    (crate_items:Ast.mod_items)\n+    : Ast.name =\n+  let fns = ref [] in\n+  let extend prefix_name ident =\n+    match prefix_name with\n+        None -> Ast.NAME_base (Ast.BASE_ident ident)\n+      | Some n -> Ast.NAME_ext (n, Ast.COMP_ident ident)\n+  in\n+  let rec dig prefix_name items =\n+    Hashtbl.iter (extract_fn prefix_name) items\n+  and extract_fn prefix_name ident item =\n+    if not (Array.length item.node.Ast.decl_params = 0) ||\n+      Hashtbl.mem ps.pstate_required item.id\n+    then ()\n+    else\n+      match item.node.Ast.decl_item with\n+          Ast.MOD_ITEM_mod (_, items) ->\n+            dig (Some (extend prefix_name ident)) items\n+\n+       | Ast.MOD_ITEM_fn _ ->\n+            if ident = \"main\"\n+            then fns := (extend prefix_name ident) :: (!fns)\n+            else ()\n+\n+        | _ -> ()\n+  in\n+    dig None crate_items;\n+    match !fns with\n+        [] -> raise (err \"no 'main' function found\" ps)\n+      | [x] -> x\n+      | _ -> raise (err \"multiple 'main' functions found\" ps)\n+;;\n+\n+\n+let with_err_handling sess thunk =\n+  try\n+    thunk ()\n+  with\n+      Parse_err (ps, str) ->\n+        Session.fail sess \"Parse error: %s\\n%!\" str;\n+        List.iter\n+          (fun (cx,pos) ->\n+             Session.fail sess \"%s:E (parse context): %s\\n%!\"\n+               (Session.string_of_pos pos) cx)\n+          ps.pstate_ctxt;\n+        let apos = lexpos ps in\n+          span ps apos apos\n+            { Ast.crate_items = (Item.empty_view, Hashtbl.create 0);\n+              Ast.crate_meta = [||];\n+              Ast.crate_auth = Hashtbl.create 0;\n+              Ast.crate_required = Hashtbl.create 0;\n+              Ast.crate_required_syms = Hashtbl.create 0;\n+              Ast.crate_main = None;\n+              Ast.crate_files = Hashtbl.create 0 }\n+;;\n+\n+\n+let parse_crate_file\n+    (sess:Session.sess)\n+    (get_mod:get_mod_fn)\n+    (infer_lib_name:(Ast.ident -> filename))\n+    : Ast.crate =\n+  let fname = Session.filename_of sess.Session.sess_in in\n+  let tref = ref (Temp 0) in\n+  let nref = ref (Node 0) in\n+  let oref = ref (Opaque 0) in\n+  let required = Hashtbl.create 4 in\n+  let required_syms = Hashtbl.create 4 in\n+  let ps =\n+    make_parser tref nref oref sess get_mod\n+      infer_lib_name required required_syms fname\n+  in\n+\n+  let files = Hashtbl.create 0 in\n+  let items = Hashtbl.create 4 in\n+  let target_bindings =\n+    let (os, arch, libc) =\n+      match sess.Session.sess_targ with\n+          Linux_x86_elf -> (\"linux\", \"x86\", \"libc.so.6\")\n+        | Win32_x86_pe -> (\"win32\", \"x86\", \"msvcrt.dll\")\n+        | MacOS_x86_macho -> (\"macos\", \"x86\", \"libc.dylib\")\n+    in\n+      [\n+        (\"target_os\", PVAL_str os);\n+        (\"target_arch\", PVAL_str arch);\n+        (\"target_libc\", PVAL_str libc)\n+      ]\n+  in\n+  let build_bindings =\n+    [\n+      (\"build_compiler\", PVAL_str Sys.executable_name);\n+      (\"build_input\", PVAL_str fname);\n+    ]\n+  in\n+  let initial_bindings =\n+    target_bindings\n+    @ build_bindings\n+  in\n+  let env = { env_bindings = initial_bindings;\n+              env_prefix = [Filename.dirname fname];\n+              env_items = Hashtbl.create 0;\n+              env_files = files;\n+              env_required = required;\n+              env_required_syms = required_syms;\n+              env_ps = ps; }\n+  in\n+  let auth = Hashtbl.create 0 in\n+    with_err_handling sess\n+      begin\n+        fun _ ->\n+          let apos = lexpos ps in\n+          let cexps = parse_cexps ps EOF in\n+          let cdirs = eval_cexps env cexps in\n+          let meta = Queue.create () in\n+          let _ =\n+            Array.iter\n+              begin\n+                fun d ->\n+                  match d with\n+                      CDIR_mod (name, item) -> htab_put items name item\n+                    | CDIR_meta metas ->\n+                        Array.iter (fun m -> Queue.add m meta) metas\n+                    | CDIR_auth (n,e) ->\n+                        if Hashtbl.mem auth n\n+                        then raise (err \"duplicate 'auth' clause\" ps)\n+                        else Hashtbl.add auth n e\n+                    | _ ->\n+                        raise\n+                          (err \"unhandled directive at top level\" ps)\n+              end\n+              cdirs\n+          in\n+          let bpos = lexpos ps in\n+          let main =\n+            if ps.pstate_sess.Session.sess_library_mode\n+            then None\n+            else Some (find_main_fn ps items) in\n+          let crate = { Ast.crate_items = (Item.empty_view, items);\n+                        Ast.crate_meta = queue_to_arr meta;\n+                        Ast.crate_auth = auth;\n+                        Ast.crate_required = required;\n+                        Ast.crate_required_syms = required_syms;\n+                        Ast.crate_main = main;\n+                        Ast.crate_files = files }\n+          in\n+          let cratei = span ps apos bpos crate in\n+            htab_put files cratei.id fname;\n+            cratei\n+      end\n+;;\n+\n+let parse_src_file\n+    (sess:Session.sess)\n+    (get_mod:get_mod_fn)\n+    (infer_lib_name:(Ast.ident -> filename))\n+    : Ast.crate =\n+  let fname = Session.filename_of sess.Session.sess_in in\n+  let tref = ref (Temp 0) in\n+  let nref = ref (Node 0) in\n+  let oref = ref (Opaque 0) in\n+  let required = Hashtbl.create 0 in\n+  let required_syms = Hashtbl.create 0 in\n+  let ps =\n+    make_parser tref nref oref sess get_mod\n+      infer_lib_name required required_syms fname\n+  in\n+    with_err_handling sess\n+      begin\n+        fun _ ->\n+          let apos = lexpos ps in\n+          let items = Item.parse_mod_items ps EOF in\n+          let bpos = lexpos ps in\n+          let files = Hashtbl.create 0 in\n+          let main =\n+            if ps.pstate_sess.Session.sess_library_mode\n+            then None\n+            else Some (find_main_fn ps (snd items))\n+          in\n+          let crate = { Ast.crate_items = items;\n+                        Ast.crate_required = required;\n+                        Ast.crate_required_syms = required_syms;\n+                        Ast.crate_auth = Hashtbl.create 0;\n+                        Ast.crate_meta = [||];\n+                        Ast.crate_main = main;\n+                        Ast.crate_files = files }\n+          in\n+          let cratei = span ps apos bpos crate in\n+            htab_put files cratei.id fname;\n+            cratei\n+      end\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "75f86a58947a6bdc60dff29b5f8b664f46f7b8ba", "filename": "src/boot/fe/item.ml", "status": "added", "additions": 1139, "deletions": 0, "changes": 1139, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fitem.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fitem.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fitem.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1139 @@\n+\n+open Common;;\n+open Token;;\n+open Parser;;\n+\n+(* Item grammar. *)\n+\n+let default_exports =\n+  let e = Hashtbl.create 0 in\n+    Hashtbl.add e Ast.EXPORT_all_decls ();\n+    e\n+;;\n+\n+let empty_view = { Ast.view_imports = Hashtbl.create 0;\n+                   Ast.view_exports = default_exports }\n+;;\n+\n+let rec parse_expr (ps:pstate) : (Ast.stmt array * Ast.expr) =\n+  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n+    Pexp.desugar_expr ps pexp\n+\n+and parse_expr_atom (ps:pstate) : (Ast.stmt array * Ast.atom) =\n+  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n+    Pexp.desugar_expr_atom ps pexp\n+\n+and parse_expr_atom_list\n+    (bra:token)\n+    (ket:token)\n+    (ps:pstate)\n+    : (Ast.stmt array * Ast.atom array) =\n+  arj1st (bracketed_zero_or_more bra ket (Some COMMA)\n+            (ctxt \"expr-atom list\" parse_expr_atom) ps)\n+\n+and parse_expr_init (lv:Ast.lval) (ps:pstate) : (Ast.stmt array) =\n+  let pexp = ctxt \"expr\" Pexp.parse_pexp ps in\n+    Pexp.desugar_expr_init ps lv pexp\n+\n+and parse_lval (ps:pstate) : (Ast.stmt array * Ast.lval) =\n+  let pexp = Pexp.parse_pexp ps in\n+    Pexp.desugar_lval ps pexp\n+\n+and parse_identified_slot_and_ident\n+    (aliases_ok:bool)\n+    (ps:pstate)\n+    : (Ast.slot identified * Ast.ident) =\n+  let slot =\n+    ctxt \"identified slot and ident: slot\"\n+      (Pexp.parse_identified_slot aliases_ok) ps\n+  in\n+  let ident =\n+    ctxt \"identified slot and ident: ident\" Pexp.parse_ident ps\n+  in\n+    (slot, ident)\n+\n+and parse_zero_or_more_identified_slot_ident_pairs\n+    (aliases_ok:bool)\n+    (ps:pstate)\n+    : (((Ast.slot identified) * Ast.ident) array) =\n+  ctxt \"zero+ slots and idents\"\n+    (paren_comma_list\n+       (parse_identified_slot_and_ident aliases_ok)) ps\n+\n+and parse_block (ps:pstate) : Ast.block =\n+  let apos = lexpos ps in\n+  let stmts =\n+    arj (ctxt \"block: stmts\"\n+           (bracketed_zero_or_more LBRACE RBRACE\n+              None parse_stmts) ps)\n+  in\n+  let bpos = lexpos ps in\n+    span ps apos bpos stmts\n+\n+and parse_block_stmt (ps:pstate) : Ast.stmt =\n+  let apos = lexpos ps in\n+  let block = parse_block ps in\n+  let bpos = lexpos ps in\n+    span ps apos bpos (Ast.STMT_block block)\n+\n+and parse_init\n+    (lval:Ast.lval)\n+    (ps:pstate)\n+    : Ast.stmt array =\n+  let apos = lexpos ps in\n+  let stmts =\n+    match peek ps with\n+        EQ ->\n+          bump ps;\n+          parse_expr_init lval ps\n+      | LARROW ->\n+          bump ps;\n+          let (stmts, rhs) = ctxt \"init: port\" parse_lval ps in\n+          let bpos = lexpos ps in\n+          let stmt = Ast.STMT_recv (lval, rhs) in\n+            Array.append stmts [| (span ps apos bpos stmt) |]\n+      | _ -> arr []\n+  in\n+  let _ = expect ps SEMI in\n+    stmts\n+\n+and parse_slot_and_ident_and_init\n+    (ps:pstate)\n+    : (Ast.stmt array * Ast.slot * Ast.ident) =\n+  let apos = lexpos ps in\n+  let (slot, ident) =\n+    ctxt \"slot, ident and init: slot and ident\"\n+      (Pexp.parse_slot_and_ident false) ps\n+  in\n+  let bpos = lexpos ps in\n+  let lval = Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident ident)) in\n+  let stmts = ctxt \"slot, ident and init: init\" (parse_init lval) ps in\n+    (stmts, slot, ident)\n+\n+and parse_auto_slot_and_init\n+    (ps:pstate)\n+    : (Ast.stmt array * Ast.slot * Ast.ident) =\n+  let apos = lexpos ps in\n+  let ident = Pexp.parse_ident ps in\n+  let bpos = lexpos ps in\n+  let lval = Ast.LVAL_base (span ps apos bpos (Ast.BASE_ident ident)) in\n+  let stmts = ctxt \"slot, ident and init: init\" (parse_init lval) ps in\n+    (stmts, slot_auto, ident)\n+\n+(*\n+ * We have no way to parse a single Ast.stmt; any incoming syntactic statement\n+ * may desugar to N>1 real Ast.stmts\n+ *)\n+\n+and parse_stmts (ps:pstate) : Ast.stmt array =\n+  let apos = lexpos ps in\n+    match peek ps with\n+\n+        LOG ->\n+          bump ps;\n+          let (stmts, atom) = ctxt \"stmts: log value\" parse_expr_atom ps in\n+            expect ps SEMI;\n+            spans ps stmts apos (Ast.STMT_log atom)\n+\n+      | CHECK ->\n+          bump ps;\n+          begin\n+\n+            let rec name_to_lval (bpos:pos) (name:Ast.name)\n+                : Ast.lval =\n+              match name with\n+                  Ast.NAME_base nb ->\n+                    Ast.LVAL_base (span ps apos bpos nb)\n+                | Ast.NAME_ext (n, nc) ->\n+                    Ast.LVAL_ext (name_to_lval bpos n, Ast.COMP_named nc)\n+            in\n+\n+            let rec carg_path_to_lval (bpos:pos) (path:Ast.carg_path)\n+                : Ast.lval =\n+              match path with\n+                  Ast.CARG_base Ast.BASE_formal ->\n+                    raise (err \"converting formal constraint-arg to atom\" ps)\n+                | Ast.CARG_base (Ast.BASE_named nb) ->\n+                    Ast.LVAL_base (span ps apos bpos nb)\n+                | Ast.CARG_ext (pth, nc) ->\n+                    Ast.LVAL_ext (carg_path_to_lval bpos pth,\n+                                  Ast.COMP_named nc)\n+            in\n+\n+            let carg_to_atom (bpos:pos) (carg:Ast.carg)\n+                : Ast.atom =\n+              match carg with\n+                  Ast.CARG_lit lit ->\n+                    Ast.ATOM_literal (span ps apos bpos lit)\n+                | Ast.CARG_path pth ->\n+                    Ast.ATOM_lval (carg_path_to_lval bpos pth)\n+            in\n+\n+            let synthesise_check_call (bpos:pos) (constr:Ast.constr)\n+                : (Ast.lval * (Ast.atom array)) =\n+              let lval = name_to_lval bpos constr.Ast.constr_name in\n+              let args =\n+                Array.map (carg_to_atom bpos) constr.Ast.constr_args\n+              in\n+                (lval, args)\n+            in\n+\n+            let synthesise_check_calls (bpos:pos) (constrs:Ast.constrs)\n+                : Ast.check_calls =\n+              Array.map (synthesise_check_call bpos) constrs\n+            in\n+\n+              match peek ps with\n+                  LPAREN ->\n+                    bump ps;\n+                    let (stmts, expr) =\n+                      ctxt \"stmts: check value\" parse_expr ps\n+                    in\n+                      expect ps RPAREN;\n+                      expect ps SEMI;\n+                      spans ps stmts apos (Ast.STMT_check_expr expr)\n+\n+                | IF ->\n+                    bump ps;\n+                    expect ps LPAREN;\n+                    let constrs = Pexp.parse_constrs ps in\n+                      expect ps RPAREN;\n+                      let block = parse_block ps in\n+                      let bpos = lexpos ps in\n+                      let calls = synthesise_check_calls bpos constrs in\n+                        [| span ps apos bpos\n+                             (Ast.STMT_check_if (constrs, calls, block))\n+                        |]\n+\n+                | _ ->\n+                    let constrs = Pexp.parse_constrs ps in\n+                      expect ps SEMI;\n+                      let bpos = lexpos ps in\n+                      let calls = synthesise_check_calls bpos constrs in\n+                        [| span ps apos bpos\n+                             (Ast.STMT_check (constrs, calls))\n+                        |]\n+          end\n+\n+      | ALT ->\n+          bump ps;\n+          begin\n+            match peek ps with\n+                TYPE -> [| |]\n+              | LPAREN ->\n+                  let (stmts, lval) = bracketed LPAREN RPAREN parse_lval ps in\n+                  let rec parse_pat ps =\n+                    match peek ps with\n+                        IDENT ident ->\n+                          let apos = lexpos ps in\n+                          bump ps;\n+                          let bpos = lexpos ps in\n+\n+                          (* TODO: nullary constructors *)\n+                          if peek ps != LPAREN then\n+                            let slot =\n+                              { Ast.slot_mode = Ast.MODE_interior;\n+                                Ast.slot_mutable = false;\n+                                Ast.slot_ty = None }\n+                            in\n+                            Ast.PAT_slot ((span ps apos bpos slot), ident)\n+                          else\n+                            let pats =\n+                              paren_comma_list parse_pat ps\n+                            in\n+                            Ast.PAT_tag (ident, pats)\n+                      | LIT_INT _ | LIT_CHAR _ | LIT_BOOL _ ->\n+                          Ast.PAT_lit (Pexp.parse_lit ps)\n+                      | UNDERSCORE -> bump ps; Ast.PAT_wild\n+                      | tok -> raise (Parse_err (ps,\n+                          \"Expected pattern but found '\" ^\n+                            (string_of_tok tok) ^ \"'\"))\n+                  in\n+                  let rec parse_arms ps =\n+                    match peek ps with\n+                        CASE ->\n+                          bump ps;\n+                          let pat = bracketed LPAREN RPAREN parse_pat ps in\n+                          let block = parse_block ps in\n+                          let arm = (pat, block) in\n+                          (span ps apos (lexpos ps) arm)::(parse_arms ps)\n+                      | _ -> []\n+                  in\n+                  let parse_alt_block ps =\n+                    let arms = ctxt \"alt tag arms\" parse_arms ps in\n+                    spans ps stmts apos begin\n+                      Ast.STMT_alt_tag {\n+                        Ast.alt_tag_lval = lval;\n+                        Ast.alt_tag_arms = Array.of_list arms\n+                      }\n+                    end\n+                  in\n+                  bracketed LBRACE RBRACE parse_alt_block ps\n+              | _ -> [| |]\n+          end\n+\n+      | IF ->\n+          let final_else = ref None in\n+          let rec parse_stmt_if _ =\n+            bump ps;\n+            let (stmts, expr) =\n+              ctxt \"stmts: if cond\"\n+                (bracketed LPAREN RPAREN parse_expr) ps\n+            in\n+            let then_block = ctxt \"stmts: if-then\" parse_block ps in\n+              begin\n+                match peek ps with\n+                    ELSE ->\n+                      begin\n+                        bump ps;\n+                        match peek ps with\n+                            IF ->\n+                              let nested_if = parse_stmt_if () in\n+                              let bpos = lexpos ps in\n+                                final_else :=\n+                                  Some (span ps apos bpos nested_if)\n+                          | _ ->\n+                              final_else :=\n+                                Some (ctxt \"stmts: if-else\" parse_block ps)\n+                      end\n+                  | _ -> ()\n+              end;\n+              let res =\n+                spans ps stmts apos\n+                  (Ast.STMT_if\n+                     { Ast.if_test = expr;\n+                       Ast.if_then = then_block;\n+                       Ast.if_else = !final_else; })\n+              in\n+                final_else := None;\n+                res\n+          in\n+            parse_stmt_if()\n+\n+      | FOR ->\n+          bump ps;\n+          begin\n+            match peek ps with\n+                EACH ->\n+                  bump ps;\n+                  let inner ps : ((Ast.slot identified * Ast.ident)\n+                                  * Ast.stmt array\n+                                  * (Ast.lval * Ast.atom array)) =\n+                    let slot = (parse_identified_slot_and_ident true ps) in\n+                    let _    = (expect ps IN) in\n+                    let (stmts1, iter) = (rstr true parse_lval) ps in\n+                    let (stmts2, args) =\n+                      parse_expr_atom_list LPAREN RPAREN ps\n+                    in\n+                      (slot, Array.append stmts1 stmts2, (iter, args))\n+                  in\n+                  let (slot, stmts, call) = ctxt \"stmts: foreach head\"\n+                    (bracketed LPAREN RPAREN inner) ps\n+                  in\n+                  let body_block =\n+                    ctxt \"stmts: foreach body\" parse_block ps\n+                  in\n+                  let bpos = lexpos ps in\n+                  let head_block =\n+                    (* \n+                     * Slightly weird, but we put an extra nesting level of\n+                     * block here to separate the part that lives in our frame\n+                     * (the iter slot) from the part that lives in the callee\n+                     * frame (the body block).\n+                     *)\n+                    span ps apos bpos [|\n+                      span ps apos bpos (Ast.STMT_block body_block);\n+                    |]\n+                  in\n+                    Array.append stmts\n+                      [| span ps apos bpos\n+                           (Ast.STMT_for_each\n+                              { Ast.for_each_slot = slot;\n+                                Ast.for_each_call = call;\n+                                Ast.for_each_head = head_block;\n+                                Ast.for_each_body = body_block; }) |]\n+              | _ ->\n+                  let inner ps =\n+                    let slot = (parse_identified_slot_and_ident false ps) in\n+                    let _    = (expect ps IN) in\n+                    let lval = (parse_lval ps) in\n+                      (slot, lval) in\n+                  let (slot, seq) =\n+                    ctxt \"stmts: for head\" (bracketed LPAREN RPAREN inner) ps\n+                  in\n+                  let body_block = ctxt \"stmts: for body\" parse_block ps in\n+                  let bpos = lexpos ps in\n+                    [| span ps apos bpos\n+                         (Ast.STMT_for\n+                            { Ast.for_slot = slot;\n+                              Ast.for_seq = seq;\n+                              Ast.for_body = body_block; }) |]\n+          end\n+\n+      | WHILE ->\n+          bump ps;\n+          let (stmts, test) =\n+            ctxt \"stmts: while cond\" (bracketed LPAREN RPAREN parse_expr) ps\n+          in\n+          let body_block = ctxt \"stmts: while body\" parse_block ps in\n+          let bpos = lexpos ps in\n+            [| span ps apos bpos\n+                 (Ast.STMT_while\n+                    { Ast.while_lval = (stmts, test);\n+                      Ast.while_body = body_block; }) |]\n+\n+      | PUT ->\n+          begin\n+            bump ps;\n+            match peek ps with\n+                EACH ->\n+                  bump ps;\n+                  let (lstmts, lval) =\n+                    ctxt \"put each: lval\" (rstr true parse_lval) ps\n+                  in\n+                  let (astmts, args) =\n+                    ctxt \"put each: args\"\n+                      (parse_expr_atom_list LPAREN RPAREN) ps\n+                  in\n+                  let bpos = lexpos ps in\n+                  let be =\n+                    span ps apos bpos (Ast.STMT_put_each (lval, args))\n+                  in\n+                    expect ps SEMI;\n+                    Array.concat [ lstmts; astmts; [| be |] ]\n+\n+              | _ ->\n+                  begin\n+                    let (stmts, e) =\n+                      match peek ps with\n+                          SEMI -> (arr [], None)\n+                        | _ ->\n+                            let (stmts, expr) =\n+                              ctxt \"stmts: put expr\" parse_expr_atom ps\n+                            in\n+                              expect ps SEMI;\n+                              (stmts, Some expr)\n+                    in\n+                      spans ps stmts apos (Ast.STMT_put e)\n+                  end\n+          end\n+\n+      | RET ->\n+          bump ps;\n+          let (stmts, e) =\n+            match peek ps with\n+                SEMI -> (bump ps; (arr [], None))\n+              | _ ->\n+                  let (stmts, expr) =\n+                    ctxt \"stmts: ret expr\" parse_expr_atom ps\n+                  in\n+                    expect ps SEMI;\n+                    (stmts, Some expr)\n+          in\n+            spans ps stmts apos (Ast.STMT_ret e)\n+\n+      | BE ->\n+          bump ps;\n+          let (lstmts, lval) = ctxt \"be: lval\" (rstr true parse_lval) ps in\n+          let (astmts, args) =\n+            ctxt \"be: args\" (parse_expr_atom_list LPAREN RPAREN) ps\n+          in\n+          let bpos = lexpos ps in\n+          let be = span ps apos bpos (Ast.STMT_be (lval, args)) in\n+            expect ps SEMI;\n+            Array.concat [ lstmts; astmts; [| be |] ]\n+\n+      | LBRACE -> [| ctxt \"stmts: block\" parse_block_stmt ps |]\n+\n+      | LET ->\n+          bump ps;\n+          let (stmts, slot, ident) =\n+            ctxt \"stmt slot\" parse_slot_and_ident_and_init ps in\n+          let slot = Pexp.apply_mutability slot true in\n+          let bpos = lexpos ps in\n+          let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n+                                    (span ps apos bpos slot))\n+          in\n+            Array.concat [[| span ps apos bpos (Ast.STMT_decl decl) |]; stmts]\n+\n+      | AUTO ->\n+          bump ps;\n+          let (stmts, slot, ident) =\n+            ctxt \"stmt slot\" parse_auto_slot_and_init ps in\n+          let slot = Pexp.apply_mutability slot true in\n+          let bpos = lexpos ps in\n+          let decl = Ast.DECL_slot (Ast.KEY_ident ident,\n+                                    (span ps apos bpos slot))\n+          in\n+            Array.concat [[| span ps apos bpos (Ast.STMT_decl decl) |]; stmts]\n+\n+      | YIELD ->\n+          bump ps;\n+          expect ps SEMI;\n+          let bpos = lexpos ps in\n+            [| span ps apos bpos Ast.STMT_yield |]\n+\n+      | FAIL ->\n+          bump ps;\n+          expect ps SEMI;\n+          let bpos = lexpos ps in\n+            [| span ps apos bpos Ast.STMT_fail |]\n+\n+      | JOIN ->\n+          bump ps;\n+          let (stmts, lval) = ctxt \"stmts: task expr\" parse_lval ps in\n+            expect ps SEMI;\n+            spans ps stmts apos (Ast.STMT_join lval)\n+\n+      | MOD | OBJ | TYPE | FN | USE | NATIVE ->\n+          let (ident, item) = ctxt \"stmt: decl\" parse_mod_item ps in\n+          let decl = Ast.DECL_mod_item (ident, item) in\n+          let stmts = expand_tags_to_stmts ps item in\n+            spans ps stmts apos (Ast.STMT_decl decl)\n+\n+      | _ ->\n+          let (lstmts, lval) = ctxt \"stmt: lval\" parse_lval ps in\n+            begin\n+              match peek ps with\n+\n+                  SEMI -> (bump ps; lstmts)\n+\n+                | EQ -> parse_init lval ps\n+\n+                | OPEQ binop_token ->\n+                    bump ps;\n+                    let (stmts, rhs) =\n+                      ctxt \"stmt: opeq rhs\" parse_expr_atom ps\n+                    in\n+                    let binop =\n+                      match binop_token with\n+                          PLUS    -> Ast.BINOP_add\n+                        | MINUS   -> Ast.BINOP_sub\n+                        | STAR    -> Ast.BINOP_mul\n+                        | SLASH   -> Ast.BINOP_div\n+                        | PERCENT -> Ast.BINOP_mod\n+                        | AND     -> Ast.BINOP_and\n+                        | OR      -> Ast.BINOP_or\n+                        | CARET   -> Ast.BINOP_xor\n+                        | LSL     -> Ast.BINOP_lsl\n+                        | LSR     -> Ast.BINOP_lsr\n+                        | ASR     -> Ast.BINOP_asr\n+                        | _       -> raise (err \"unknown opeq token\" ps)\n+                    in\n+                      expect ps SEMI;\n+                      spans ps stmts apos\n+                        (Ast.STMT_copy_binop (lval, binop, rhs))\n+\n+                | LARROW ->\n+                    bump ps;\n+                    let (stmts, rhs) = ctxt \"stmt: recv rhs\" parse_lval ps in\n+                    let _ = expect ps SEMI in\n+                      spans ps stmts apos (Ast.STMT_recv (lval, rhs))\n+\n+                | SEND ->\n+                    bump ps;\n+                    let (stmts, rhs) =\n+                      ctxt \"stmt: send rhs\" parse_expr_atom ps\n+                    in\n+                    let _ = expect ps SEMI in\n+                    let bpos = lexpos ps in\n+                    let (src, copy) = match rhs with\n+                        Ast.ATOM_lval lv -> (lv, [| |])\n+                      | _ ->\n+                          let (_, tmp, tempdecl) =\n+                            build_tmp ps slot_auto apos bpos\n+                          in\n+                          let copy = span ps apos bpos\n+                            (Ast.STMT_copy (tmp, Ast.EXPR_atom rhs)) in\n+                              ((clone_lval ps tmp), [| tempdecl; copy |])\n+                    in\n+                    let send =\n+                      span ps apos bpos\n+                        (Ast.STMT_send (lval, src))\n+                    in\n+                      Array.concat [ stmts; copy; [| send |] ]\n+\n+                | _ -> raise (unexpected ps)\n+            end\n+\n+\n+and parse_ty_param (iref:int ref) (ps:pstate) : Ast.ty_param identified =\n+  let apos = lexpos ps in\n+  let e = Pexp.parse_effect ps in\n+  let ident = Pexp.parse_ident ps in\n+  let i = !iref in\n+  let bpos = lexpos ps in\n+    incr iref;\n+    span ps apos bpos (ident, (i, e))\n+\n+and parse_ty_params (ps:pstate)\n+    : (Ast.ty_param identified) array =\n+  match peek ps with\n+      LBRACKET ->\n+        bracketed_zero_or_more LBRACKET RBRACKET (Some COMMA)\n+          (parse_ty_param (ref 0)) ps\n+    | _ -> arr []\n+\n+and parse_ident_and_params (ps:pstate) (cstr:string)\n+    : (Ast.ident * (Ast.ty_param identified) array) =\n+  let ident = ctxt (\"mod \" ^ cstr ^ \" item: ident\") Pexp.parse_ident ps in\n+  let params =\n+    ctxt (\"mod \" ^ cstr ^ \" item: type params\") parse_ty_params ps\n+  in\n+    (ident, params)\n+\n+and parse_inputs\n+    (ps:pstate)\n+    : ((Ast.slot identified * Ast.ident) array * Ast.constrs)  =\n+  let slots =\n+    match peek ps with\n+        LPAREN -> ctxt \"inputs: input idents and slots\"\n+          (parse_zero_or_more_identified_slot_ident_pairs true) ps\n+      | _ -> raise (unexpected ps)\n+  in\n+  let constrs =\n+    match peek ps with\n+        COLON -> (bump ps; ctxt \"inputs: constrs\" Pexp.parse_constrs ps)\n+      | _ -> [| |]\n+  in\n+  let rec rewrite_carg_path cp =\n+    match cp with\n+        Ast.CARG_base (Ast.BASE_named (Ast.BASE_ident ident)) ->\n+          begin\n+            let res = ref cp in\n+              for i = 0 to (Array.length slots) - 1\n+              do\n+                let (_, ident') = slots.(i) in\n+                  if ident' = ident\n+                  then res := Ast.CARG_ext (Ast.CARG_base Ast.BASE_formal,\n+                                            Ast.COMP_idx i)\n+                  else ()\n+              done;\n+              !res\n+          end\n+      | Ast.CARG_base _ -> cp\n+      | Ast.CARG_ext (cp, ext) ->\n+          Ast.CARG_ext (rewrite_carg_path cp, ext)\n+  in\n+    (* Rewrite constrs with input tuple as BASE_formal. *)\n+    Array.iter\n+      begin\n+        fun constr ->\n+          let args = constr.Ast.constr_args in\n+            Array.iteri\n+              begin\n+                fun i carg ->\n+                  match carg with\n+                      Ast.CARG_path cp ->\n+                        args.(i) <- Ast.CARG_path (rewrite_carg_path cp)\n+                    | _ -> ()\n+              end\n+              args\n+      end\n+      constrs;\n+    (slots, constrs)\n+\n+\n+and parse_in_and_out\n+    (ps:pstate)\n+    : ((Ast.slot identified * Ast.ident) array\n+       * Ast.constrs\n+       * Ast.slot identified) =\n+  let (inputs, constrs) = parse_inputs ps in\n+  let output =\n+    match peek ps with\n+        RARROW ->\n+          bump ps;\n+          ctxt \"fn in and out: output slot\"\n+            (Pexp.parse_identified_slot true) ps\n+      | _ ->\n+          let apos = lexpos ps in\n+            span ps apos apos slot_nil\n+  in\n+    (inputs, constrs, output)\n+\n+\n+(* parse_fn starts at the first lparen of the sig. *)\n+and parse_fn\n+    (is_iter:bool)\n+    (effect:Ast.effect)\n+    (ps:pstate)\n+    : Ast.fn =\n+    let (inputs, constrs, output) =\n+      ctxt \"fn: in_and_out\" parse_in_and_out ps\n+    in\n+    let body = ctxt \"fn: body\" parse_block ps in\n+      { Ast.fn_input_slots = inputs;\n+        Ast.fn_input_constrs = constrs;\n+        Ast.fn_output_slot = output;\n+        Ast.fn_aux = { Ast.fn_effect = effect;\n+                       Ast.fn_is_iter = is_iter; };\n+        Ast.fn_body = body; }\n+\n+and parse_meta_input (ps:pstate) : (Ast.ident * string option) =\n+  let lab = (ctxt \"meta input: label\" Pexp.parse_ident ps) in\n+    match peek ps with\n+        EQ ->\n+          bump ps;\n+          let v =\n+            match peek ps with\n+                UNDERSCORE -> bump ps; None\n+              | LIT_STR s -> bump ps; Some s\n+              | _ -> raise (unexpected ps)\n+          in\n+            (lab, v)\n+      | _ -> raise (unexpected ps)\n+\n+and parse_meta_pat (ps:pstate) : Ast.meta_pat =\n+  bracketed_zero_or_more LPAREN RPAREN\n+    (Some COMMA) parse_meta_input ps\n+\n+and parse_meta (ps:pstate) : Ast.meta =\n+  Array.map\n+    begin\n+      fun (id,v) ->\n+        match v with\n+            None ->\n+              raise (err (\"wildcard found in meta \"\n+                          ^ \"pattern where value expected\") ps)\n+          | Some v -> (id,v)\n+    end\n+    (parse_meta_pat ps)\n+\n+and parse_optional_meta_pat (ps:pstate) (ident:Ast.ident) : Ast.meta_pat =\n+  match peek ps with\n+      LPAREN -> parse_meta_pat ps\n+    | _ -> [| (\"name\", Some ident) |]\n+\n+\n+and parse_obj_item\n+    (ps:pstate)\n+    (apos:pos)\n+    (effect:Ast.effect)\n+    : (Ast.ident * Ast.mod_item) =\n+  expect ps OBJ;\n+  let (ident, params) = parse_ident_and_params ps \"obj\" in\n+  let (state, constrs) = (ctxt \"obj state\" parse_inputs ps) in\n+  let drop = ref None in\n+    expect ps LBRACE;\n+    let fns = Hashtbl.create 0 in\n+      while (not (peek ps = RBRACE))\n+      do\n+        let apos = lexpos ps in\n+          match peek ps with\n+              IO | STATE | UNSAFE | FN | ITER ->\n+                let effect = Pexp.parse_effect ps in\n+                let is_iter = (peek ps) = ITER in\n+                  bump ps;\n+                  let ident = ctxt \"obj fn: ident\" Pexp.parse_ident ps in\n+                  let fn = ctxt \"obj fn: fn\" (parse_fn is_iter effect) ps in\n+                  let bpos = lexpos ps in\n+                    htab_put fns ident (span ps apos bpos fn)\n+            | DROP ->\n+                bump ps;\n+                drop := Some (parse_block ps)\n+            | RBRACE -> ()\n+            | _ -> raise (unexpected ps)\n+      done;\n+      expect ps RBRACE;\n+      let bpos = lexpos ps in\n+      let obj = { Ast.obj_state = state;\n+                  Ast.obj_effect = effect;\n+                  Ast.obj_constrs = constrs;\n+                  Ast.obj_fns = fns;\n+                  Ast.obj_drop = !drop }\n+      in\n+        (ident,\n+         span ps apos bpos\n+           (decl params (Ast.MOD_ITEM_obj obj)))\n+\n+\n+and parse_mod_item (ps:pstate) : (Ast.ident * Ast.mod_item) =\n+  let apos = lexpos ps in\n+  let parse_lib_name ident =\n+    match peek ps with\n+        EQ ->\n+          begin\n+            bump ps;\n+            match peek ps with\n+                LIT_STR s -> (bump ps; s)\n+              | _ -> raise (unexpected ps)\n+          end\n+      | _ -> ps.pstate_infer_lib_name ident\n+  in\n+\n+    match peek ps with\n+\n+        IO | STATE | UNSAFE | OBJ | FN | ITER ->\n+          let effect = Pexp.parse_effect ps in\n+            begin\n+              match peek ps with\n+                  OBJ -> parse_obj_item ps apos effect\n+                | _ ->\n+                    let is_iter = (peek ps) = ITER in\n+                      bump ps;\n+                      let (ident, params) = parse_ident_and_params ps \"fn\" in\n+                      let fn =\n+                        ctxt \"mod fn item: fn\" (parse_fn is_iter effect) ps\n+                      in\n+                      let bpos = lexpos ps in\n+                        (ident,\n+                         span ps apos bpos\n+                           (decl params (Ast.MOD_ITEM_fn fn)))\n+            end\n+\n+      | TYPE ->\n+          bump ps;\n+          let (ident, params) = parse_ident_and_params ps \"type\" in\n+          let _ = expect ps EQ in\n+          let ty = ctxt \"mod type item: ty\" Pexp.parse_ty ps in\n+          let _ = expect ps SEMI in\n+          let bpos = lexpos ps in\n+          let item = Ast.MOD_ITEM_type ty in\n+            (ident, span ps apos bpos (decl params item))\n+\n+      | MOD ->\n+          bump ps;\n+          let (ident, params) = parse_ident_and_params ps \"mod\" in\n+            expect ps LBRACE;\n+            let items = parse_mod_items ps RBRACE in\n+            let bpos = lexpos ps in\n+              (ident,\n+               span ps apos bpos\n+                 (decl params (Ast.MOD_ITEM_mod items)))\n+\n+      | NATIVE ->\n+          begin\n+            bump ps;\n+            let conv =\n+              match peek ps with\n+                  LIT_STR s ->\n+                    bump ps;\n+                    begin\n+                      match string_to_conv s with\n+                          None -> raise (unexpected ps)\n+                        | Some c -> c\n+                    end\n+                | _ -> CONV_cdecl\n+            in\n+              expect ps MOD;\n+              let (ident, params) = parse_ident_and_params ps \"native mod\" in\n+              let path = parse_lib_name ident in\n+              let items = parse_mod_items_from_signature ps in\n+              let bpos = lexpos ps in\n+              let rlib = REQUIRED_LIB_c { required_libname = path;\n+                                          required_prefix = ps.pstate_depth }\n+              in\n+              let item = decl params (Ast.MOD_ITEM_mod items) in\n+              let item = span ps apos bpos item in\n+                note_required_mod ps {lo=apos; hi=bpos} conv rlib item;\n+                (ident, item)\n+          end\n+\n+      | USE ->\n+          begin\n+            bump ps;\n+            let ident = ctxt \"use mod: ident\" Pexp.parse_ident ps in\n+            let meta =\n+              ctxt \"use mod: meta\" parse_optional_meta_pat ps ident\n+            in\n+            let bpos = lexpos ps in\n+            let id = (span ps apos bpos ()).id in\n+            let (path, items) =\n+              ps.pstate_get_mod meta id ps.pstate_node_id ps.pstate_opaque_id\n+            in\n+            let bpos = lexpos ps in\n+              expect ps SEMI;\n+              let rlib =\n+                REQUIRED_LIB_rust { required_libname = path;\n+                                    required_prefix = ps.pstate_depth }\n+              in\n+                iflog ps\n+                  begin\n+                    fun _ ->\n+                      log ps \"extracted mod from %s (binding to %s)\"\n+                        path ident;\n+                      log ps \"%a\" Ast.sprintf_mod_items items;\n+                  end;\n+                let item = decl [||] (Ast.MOD_ITEM_mod (empty_view, items)) in\n+                let item = span ps apos bpos item in\n+                  note_required_mod ps {lo=apos; hi=bpos} CONV_rust rlib item;\n+                  (ident, item)\n+          end\n+\n+\n+\n+      | _ -> raise (unexpected ps)\n+\n+\n+and parse_mod_items_from_signature\n+    (ps:pstate)\n+    : (Ast.mod_view * Ast.mod_items) =\n+    let mis = Hashtbl.create 0 in\n+      expect ps LBRACE;\n+      while not (peek ps = RBRACE)\n+      do\n+        let (ident, mti) = ctxt \"mod items from sig: mod item\"\n+          parse_mod_item_from_signature ps\n+        in\n+          Hashtbl.add mis ident mti;\n+      done;\n+      expect ps RBRACE;\n+      (empty_view, mis)\n+\n+\n+and parse_mod_item_from_signature (ps:pstate)\n+    : (Ast.ident * Ast.mod_item) =\n+  let apos = lexpos ps in\n+    match peek ps with\n+        MOD ->\n+          bump ps;\n+          let (ident, params) = parse_ident_and_params ps \"mod signature\" in\n+          let items = parse_mod_items_from_signature ps in\n+          let bpos = lexpos ps in\n+          (ident, span ps apos bpos (decl params (Ast.MOD_ITEM_mod items)))\n+\n+      | IO | STATE | UNSAFE | FN | ITER ->\n+          let effect = Pexp.parse_effect ps in\n+          let is_iter = (peek ps) = ITER in\n+            bump ps;\n+            let (ident, params) = parse_ident_and_params ps \"fn signature\" in\n+            let (inputs, constrs, output) = parse_in_and_out ps in\n+            let bpos = lexpos ps in\n+            let body = span ps apos bpos [| |] in\n+            let fn =\n+              Ast.MOD_ITEM_fn\n+                { Ast.fn_input_slots = inputs;\n+                  Ast.fn_input_constrs = constrs;\n+                  Ast.fn_output_slot = output;\n+                  Ast.fn_aux = { Ast.fn_effect = effect;\n+                                 Ast.fn_is_iter = is_iter; };\n+                  Ast.fn_body = body; }\n+            in\n+            let node = span ps apos bpos (decl params fn) in\n+              begin\n+                match peek ps with\n+                    EQ ->\n+                      bump ps;\n+                      begin\n+                        match peek ps with\n+                            LIT_STR s ->\n+                              bump ps;\n+                              htab_put ps.pstate_required_syms node.id s\n+                          | _ -> raise (unexpected ps)\n+                      end;\n+                  | _ -> ()\n+              end;\n+              expect ps SEMI;\n+              (ident, node)\n+\n+    | TYPE ->\n+        bump ps;\n+        let (ident, params) = parse_ident_and_params ps \"type type\" in\n+        let t =\n+          match peek ps with\n+              SEMI -> Ast.TY_native (next_opaque_id ps)\n+            | _ -> Pexp.parse_ty ps\n+        in\n+          expect ps SEMI;\n+          let bpos = lexpos ps in\n+            (ident, span ps apos bpos (decl params (Ast.MOD_ITEM_type t)))\n+\n+    (* FIXME: parse obj. *)\n+    | _ -> raise (unexpected ps)\n+\n+\n+and expand_tags\n+    (ps:pstate)\n+    (item:Ast.mod_item)\n+    : (Ast.ident * Ast.mod_item) array =\n+  let handle_ty_tag id ttag =\n+    let tags = ref [] in\n+      Hashtbl.iter\n+        begin\n+          fun name tup ->\n+            let ident = match name with\n+                Ast.NAME_base (Ast.BASE_ident ident) -> ident\n+              | _ ->\n+                  raise (Parse_err\n+                           (ps, \"unexpected name type while expanding tag\"))\n+            in\n+            let header =\n+              Array.map (fun slot -> (clone_span ps item slot)) tup\n+            in\n+            let tag_item' = Ast.MOD_ITEM_tag (header, ttag, id) in\n+            let cloned_params =\n+              Array.map (fun p -> clone_span ps p p.node)\n+                item.node.Ast.decl_params\n+            in\n+            let tag_item =\n+              clone_span ps item (decl cloned_params tag_item')\n+            in\n+              tags := (ident, tag_item) :: (!tags)\n+        end\n+        ttag;\n+      arr (!tags)\n+  in\n+  let handle_ty_decl id tyd =\n+    match tyd with\n+        Ast.TY_tag ttag -> handle_ty_tag id ttag\n+      | _ -> [| |]\n+  in\n+    match item.node.Ast.decl_item with\n+        Ast.MOD_ITEM_type tyd -> handle_ty_decl item.id tyd\n+      | _ -> [| |]\n+\n+\n+and expand_tags_to_stmts\n+    (ps:pstate)\n+    (item:Ast.mod_item)\n+    : Ast.stmt array =\n+  let id_items = expand_tags ps item in\n+    Array.map\n+      (fun (ident, tag_item) ->\n+         clone_span ps item\n+           (Ast.STMT_decl\n+              (Ast.DECL_mod_item (ident, tag_item))))\n+      id_items\n+\n+\n+and expand_tags_to_items\n+    (ps:pstate)\n+    (item:Ast.mod_item)\n+    (items:Ast.mod_items)\n+    : unit =\n+  let id_items = expand_tags ps item in\n+    Array.iter\n+      (fun (ident, item) -> htab_put items ident item)\n+      id_items\n+\n+\n+and note_required_mod\n+    (ps:pstate)\n+    (sp:span)\n+    (conv:nabi_conv)\n+    (rlib:required_lib)\n+    (item:Ast.mod_item)\n+    : unit =\n+  iflog ps\n+    begin\n+      fun _ -> log ps \"marking item #%d as required\" (int_of_node item.id)\n+    end;\n+  htab_put ps.pstate_required item.id (rlib, conv);\n+  if not (Hashtbl.mem ps.pstate_sess.Session.sess_spans item.id)\n+  then Hashtbl.add ps.pstate_sess.Session.sess_spans item.id sp;\n+  match item.node.Ast.decl_item with\n+      Ast.MOD_ITEM_mod (_, items) ->\n+        Hashtbl.iter\n+          begin\n+            fun _ sub ->\n+              note_required_mod ps sp conv rlib sub\n+          end\n+          items\n+    | _ -> ()\n+\n+\n+and parse_import\n+    (ps:pstate)\n+    (imports:(Ast.ident, Ast.name) Hashtbl.t)\n+    : unit =\n+  let import a n =\n+    let a = match a with\n+        None ->\n+          begin\n+            match n with\n+                Ast.NAME_ext (_, Ast.COMP_ident i)\n+              | Ast.NAME_ext (_, Ast.COMP_app (i, _))\n+              | Ast.NAME_base (Ast.BASE_ident i)\n+              | Ast.NAME_base (Ast.BASE_app (i, _)) -> i\n+              | _ -> raise (Parse_err (ps, \"bad import specification\"))\n+          end\n+      | Some i -> i\n+    in\n+      Hashtbl.add imports a n\n+  in\n+    match peek ps with\n+        IDENT i ->\n+          begin\n+            bump ps;\n+            match peek ps with\n+                EQ ->\n+                  (* \n+                   * import x = ...\n+                   *)\n+                  bump ps;\n+                  import (Some i) (Pexp.parse_name ps)\n+              | _ ->\n+                  (*\n+                   * import x...\n+                   *)\n+                  import None (Pexp.parse_name_ext ps\n+                                 (Ast.NAME_base\n+                                    (Ast.BASE_ident i)))\n+          end\n+      | _ ->\n+          import None (Pexp.parse_name ps)\n+\n+\n+and parse_export\n+    (ps:pstate)\n+    (exports:(Ast.export, unit) Hashtbl.t)\n+    : unit =\n+  let e =\n+    match peek ps with\n+        STAR -> bump ps; Ast.EXPORT_all_decls\n+      | IDENT i -> bump ps; Ast.EXPORT_ident i\n+      | _ -> raise (unexpected ps)\n+  in\n+    Hashtbl.add exports e ()\n+\n+\n+and parse_mod_items\n+    (ps:pstate)\n+    (terminal:token)\n+    : (Ast.mod_view * Ast.mod_items) =\n+  ps.pstate_depth <- ps.pstate_depth + 1;\n+  let imports = Hashtbl.create 0 in\n+  let exports = Hashtbl.create 0 in\n+  let in_view = ref true in\n+  let items = Hashtbl.create 4 in\n+    while (not (peek ps = terminal))\n+    do\n+      if !in_view\n+      then\n+        match peek ps with\n+            IMPORT ->\n+              bump ps;\n+              parse_import ps imports;\n+              expect ps SEMI;\n+          | EXPORT ->\n+              bump ps;\n+              parse_export ps exports;\n+              expect ps SEMI;\n+          | _ ->\n+              in_view := false\n+      else\n+        let (ident, item) = parse_mod_item ps in\n+          htab_put items ident item;\n+          expand_tags_to_items ps item items;\n+    done;\n+    if (Hashtbl.length exports) = 0\n+    then Hashtbl.add exports Ast.EXPORT_all_decls ();\n+    expect ps terminal;\n+    ps.pstate_depth <- ps.pstate_depth - 1;\n+    let view = { Ast.view_imports = imports;\n+                 Ast.view_exports = exports }\n+    in\n+      (view, items)\n+;;\n+\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "fb4d58c567cb3aa49b11346beea136c0250441f0", "filename": "src/boot/fe/lexer.mll", "status": "added", "additions": 362, "deletions": 0, "changes": 362, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Flexer.mll", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Flexer.mll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Flexer.mll?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,362 @@\n+\n+\n+{\n+\n+  open Token;;\n+  open Common;;\n+\n+  exception Lex_err of (string * Common.pos);;\n+\n+  let fail lexbuf s =\n+    let p = lexbuf.Lexing.lex_start_p in\n+    let pos =\n+      (p.Lexing.pos_fname,\n+       p.Lexing.pos_lnum ,\n+       (p.Lexing.pos_cnum) - (p.Lexing.pos_bol))\n+    in\n+      raise (Lex_err (s, pos))\n+  ;;\n+\n+  let bump_line p = { p with\n+              Lexing.pos_lnum = p.Lexing.pos_lnum + 1;\n+              Lexing.pos_bol = p.Lexing.pos_cnum }\n+  ;;\n+\n+  let keyword_table = Hashtbl.create 100\n+  let _ =\n+    List.iter (fun (kwd, tok) -> Common.htab_put keyword_table kwd tok)\n+              [ (\"mod\", MOD);\n+                (\"use\", USE);\n+                (\"meta\", META);\n+                (\"auth\", AUTH);\n+\n+                (\"syntax\", SYNTAX);\n+\n+                (\"if\", IF);\n+                (\"else\", ELSE);\n+                (\"while\", WHILE);\n+                (\"do\", DO);\n+                (\"alt\", ALT);\n+                (\"case\", CASE);\n+\n+                (\"for\", FOR);\n+                (\"each\", EACH);\n+                (\"put\", PUT);\n+                (\"ret\", RET);\n+                (\"be\", BE);\n+\n+                (\"fail\", FAIL);\n+                (\"drop\", DROP);\n+\n+                (\"type\", TYPE);\n+                (\"check\", CHECK);\n+                (\"claim\", CLAIM);\n+                (\"prove\", PROVE);\n+\n+                (\"io\", IO);\n+                (\"state\", STATE);\n+                (\"unsafe\", UNSAFE);\n+\n+                (\"native\", NATIVE);\n+                (\"mutable\", MUTABLE);\n+                (\"auto\", AUTO);\n+\n+                (\"fn\", FN);\n+                (\"iter\", ITER);\n+\n+                (\"import\", IMPORT);\n+                (\"export\", EXPORT);\n+\n+                (\"let\", LET);\n+\n+                (\"log\", LOG);\n+                (\"spawn\", SPAWN);\n+                (\"thread\", THREAD);\n+                (\"yield\", YIELD);\n+                (\"join\", JOIN);\n+\n+                (\"bool\", BOOL);\n+\n+                (\"int\", INT);\n+                (\"uint\", UINT);\n+\n+                (\"char\", CHAR);\n+                (\"str\", STR);\n+\n+                (\"rec\", REC);\n+                (\"tup\", TUP);\n+                (\"tag\", TAG);\n+                (\"vec\", VEC);\n+                (\"any\", ANY);\n+\n+                (\"obj\", OBJ);\n+\n+                (\"port\", PORT);\n+                (\"chan\", CHAN);\n+\n+                (\"task\", TASK);\n+\n+                (\"true\", LIT_BOOL true);\n+                (\"false\", LIT_BOOL false);\n+\n+                (\"in\", IN);\n+\n+                (\"as\", AS);\n+                (\"with\", WITH);\n+\n+                (\"bind\", BIND);\n+\n+                (\"u8\", MACH TY_u8);\n+                (\"u16\", MACH TY_u16);\n+                (\"u32\", MACH TY_u32);\n+                (\"u64\", MACH TY_u64);\n+                (\"i8\", MACH TY_i8);\n+                (\"i16\", MACH TY_i16);\n+                (\"i32\", MACH TY_i32);\n+                (\"i64\", MACH TY_i64);\n+                (\"f32\", MACH TY_f32);\n+                (\"f64\", MACH TY_f64)\n+              ]\n+;;\n+}\n+\n+let hexdig = ['0'-'9' 'a'-'f' 'A'-'F']\n+let bin = \"0b\" ['0' '1']['0' '1' '_']*\n+let hex = \"0x\" hexdig ['0'-'9' 'a'-'f' 'A'-'F' '_']*\n+let dec = ['0'-'9']+\n+let exp = ['e''E']['-''+']? dec\n+let flo = (dec '.' dec (exp?)) | (dec exp)\n+\n+let ws = [ ' ' '\\t' '\\r' ]\n+\n+let id = ['a'-'z' 'A'-'Z' '_']['a'-'z' 'A'-'Z' '0'-'9' '_']*\n+\n+rule token = parse\n+  ws+                          { token lexbuf }\n+| '\\n'                         { lexbuf.Lexing.lex_curr_p\n+                                     <- (bump_line lexbuf.Lexing.lex_curr_p);\n+                                 token lexbuf }\n+| \"//\" [^'\\n']*                { token lexbuf }\n+\n+| '+'                          { PLUS       }\n+| '-'                          { MINUS      }\n+| '*'                          { STAR       }\n+| '/'                          { SLASH      }\n+| '%'                          { PERCENT    }\n+| '='                          { EQ         }\n+| '<'                          { LT         }\n+| \"<=\"                         { LE         }\n+| \"==\"                         { EQEQ       }\n+| \"!=\"                         { NE         }\n+| \">=\"                         { GE         }\n+| '>'                          { GT         }\n+| '!'                          { NOT        }\n+| '&'                          { AND        }\n+| \"&&\"                         { ANDAND     }\n+| '|'                          { OR         }\n+| \"||\"                         { OROR       }\n+| \"<<\"                         { LSL        }\n+| \">>\"                         { LSR        }\n+| \">>>\"                        { ASR        }\n+| '~'                          { TILDE      }\n+| '{'                          { LBRACE     }\n+| '_' (dec as n)               { IDX (int_of_string n) }\n+| '_'                          { UNDERSCORE }\n+| '}'                          { RBRACE     }\n+\n+| \"+=\"                         { OPEQ (PLUS)    }\n+| \"-=\"                         { OPEQ (MINUS)   }\n+| \"*=\"                         { OPEQ (STAR)    }\n+| \"/=\"                         { OPEQ (SLASH)   }\n+| \"%=\"                         { OPEQ (PERCENT) }\n+| \"&=\"                         { OPEQ (AND) }\n+| \"|=\"                         { OPEQ (OR)  }\n+| \"<<=\"                        { OPEQ (LSL) }\n+| \">>=\"                        { OPEQ (LSR) }\n+| \">>>=\"                       { OPEQ (ASR) }\n+| \"^=\"                         { OPEQ (CARET) }\n+\n+| '#'                          { POUND      }\n+| '@'                          { AT         }\n+| '^'                          { CARET      }\n+| '.'                          { DOT        }\n+| ','                          { COMMA      }\n+| ';'                          { SEMI       }\n+| ':'                          { COLON      }\n+| \"<-\"                         { LARROW     }\n+| \"<|\"                         { SEND       }\n+| \"->\"                         { RARROW     }\n+| '('                          { LPAREN     }\n+| ')'                          { RPAREN     }\n+| '['                          { LBRACKET   }\n+| ']'                          { RBRACKET   }\n+\n+| id as i\n+                               { try\n+                                     Hashtbl.find keyword_table i\n+                                 with\n+                                     Not_found -> IDENT (i)\n+                                            }\n+\n+| bin as n                      { LIT_INT (Int64.of_string n, n)    }\n+| hex as n                      { LIT_INT (Int64.of_string n, n)    }\n+| dec as n                      { LIT_INT (Int64.of_string n, n)    }\n+| flo as n                      { LIT_FLO n                         }\n+\n+| '\\''                          { char lexbuf                       }\n+| '\"'                           { let buf = Buffer.create 32 in\n+                                    str buf lexbuf                  }\n+\n+| eof                           { EOF        }\n+\n+and str buf = parse\n+    _ as ch\n+    {\n+      match ch with\n+          '\"' -> LIT_STR (Buffer.contents buf)\n+        | '\\\\' -> str_escape buf lexbuf\n+        | _ ->\n+            Buffer.add_char buf ch;\n+            let c = Char.code ch in\n+              if bounds 0 c 0x7f\n+              then str buf lexbuf\n+              else\n+                if ((c land 0b1110_0000) == 0b1100_0000)\n+                then ext_str 1 buf lexbuf\n+                else\n+                  if ((c land 0b1111_0000) == 0b1110_0000)\n+                  then ext_str 2 buf lexbuf\n+                  else\n+                    if ((c land 0b1111_1000) == 0b1111_0000)\n+                    then ext_str 3 buf lexbuf\n+                    else\n+                      if ((c land 0b1111_1100) == 0b1111_1000)\n+                      then ext_str 4 buf lexbuf\n+                      else\n+                        if ((c land 0b1111_1110) == 0b1111_1100)\n+                        then ext_str 5 buf lexbuf\n+                        else fail lexbuf \"bad initial utf-8 byte\"\n+    }\n+\n+and str_escape buf = parse\n+    'x' ((hexdig hexdig) as h)\n+  | 'u' ((hexdig hexdig hexdig hexdig) as h)\n+  | 'U'\n+      ((hexdig hexdig hexdig hexdig\n+        hexdig hexdig hexdig hexdig) as h)\n+      {\n+        Buffer.add_string buf (char_as_utf8 (int_of_string (\"0x\" ^ h)));\n+        str buf lexbuf\n+      }\n+  | 'n' { Buffer.add_char buf '\\n'; str buf lexbuf }\n+  | 'r' { Buffer.add_char buf '\\r'; str buf lexbuf }\n+  | 't' { Buffer.add_char buf '\\t'; str buf lexbuf }\n+  | '\\\\' { Buffer.add_char buf '\\\\'; str buf lexbuf }\n+  | '\"' { Buffer.add_char buf '\"'; str buf lexbuf }\n+  | _ as c { fail lexbuf (\"bad escape: \\\\\" ^ (Char.escaped c))  }\n+\n+\n+and ext_str n buf = parse\n+    _ as ch\n+      {\n+        let c = Char.code ch in\n+          if ((c land 0b1100_0000) == (0b1000_0000))\n+          then\n+            begin\n+              Buffer.add_char buf ch;\n+              if n = 1\n+              then str buf lexbuf\n+              else ext_str (n-1) buf lexbuf\n+            end\n+          else\n+            fail lexbuf \"bad trailing utf-8 byte\"\n+      }\n+\n+\n+and char = parse\n+    '\\\\' { char_escape lexbuf }\n+  | _ as c\n+    {\n+      let c = Char.code c in\n+        if bounds 0 c 0x7f\n+        then end_char c lexbuf\n+        else\n+          if ((c land 0b1110_0000) == 0b1100_0000)\n+          then ext_char 1 (c land 0b0001_1111) lexbuf\n+          else\n+            if ((c land 0b1111_0000) == 0b1110_0000)\n+            then ext_char 2 (c land 0b0000_1111) lexbuf\n+            else\n+              if ((c land 0b1111_1000) == 0b1111_0000)\n+              then ext_char 3 (c land 0b0000_0111) lexbuf\n+              else\n+                if ((c land 0b1111_1100) == 0b1111_1000)\n+                then ext_char 4 (c land 0b0000_0011) lexbuf\n+                else\n+                  if ((c land 0b1111_1110) == 0b1111_1100)\n+                  then ext_char 5 (c land 0b0000_0001) lexbuf\n+                  else fail lexbuf \"bad initial utf-8 byte\"\n+    }\n+\n+and char_escape = parse\n+    'x' ((hexdig hexdig) as h)\n+  | 'u' ((hexdig hexdig hexdig hexdig) as h)\n+  | 'U'\n+      ((hexdig hexdig hexdig hexdig\n+        hexdig hexdig hexdig hexdig) as h)\n+      {\n+        end_char (int_of_string (\"0x\" ^ h)) lexbuf\n+      }\n+  | 'n' { end_char (Char.code '\\n') lexbuf }\n+  | 'r' { end_char (Char.code '\\r') lexbuf }\n+  | 't' { end_char (Char.code '\\t') lexbuf }\n+  | '\\\\' { end_char (Char.code '\\\\') lexbuf }\n+  | '\\'' { end_char (Char.code '\\'') lexbuf }\n+  | _ as c { fail lexbuf (\"bad escape: \\\\\" ^ (Char.escaped c))  }\n+\n+\n+and ext_char n accum = parse\n+  _ as c\n+    {\n+      let c = Char.code c in\n+        if ((c land 0b1100_0000) == (0b1000_0000))\n+        then\n+          let accum = (accum lsl 6) lor (c land 0b0011_1111) in\n+            if n = 1\n+            then end_char accum lexbuf\n+            else ext_char (n-1) accum lexbuf\n+        else\n+          fail lexbuf \"bad trailing utf-8 byte\"\n+    }\n+\n+and end_char accum = parse\n+  '\\'' { LIT_CHAR accum }\n+\n+\n+and bracequote buf depth = parse\n+\n+  '\\\\' '{'                      { Buffer.add_char buf '{';\n+                                  bracequote buf depth lexbuf          }\n+\n+| '{'                           { Buffer.add_char buf '{';\n+                                  bracequote buf (depth+1) lexbuf      }\n+\n+| '\\\\' '}'                      { Buffer.add_char buf '}';\n+                                  bracequote buf depth lexbuf          }\n+\n+| '}'                           { if depth = 1\n+                                  then BRACEQUOTE (Buffer.contents buf)\n+                                  else\n+                                    begin\n+                                      Buffer.add_char buf '}';\n+                                      bracequote buf (depth-1) lexbuf\n+                                    end                                }\n+\n+| '\\\\' [^'{' '}']               { let s = Lexing.lexeme lexbuf in\n+                                    Buffer.add_string buf s;\n+                                    bracequote buf depth lexbuf        }\n+\n+\n+| [^'\\\\' '{' '}']+              { let s = Lexing.lexeme lexbuf in\n+                                    Buffer.add_string buf s;\n+                                    bracequote buf depth lexbuf        }"}, {"sha": "3dda93ac2577338533fb598bd11b1ad823e5e5d7", "filename": "src/boot/fe/parser.ml", "status": "added", "additions": 374, "deletions": 0, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fparser.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fparser.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fparser.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,374 @@\n+\n+open Common;;\n+open Token;;\n+\n+(* Fundamental parser types and actions *)\n+\n+type get_mod_fn = (Ast.meta_pat\n+                   -> node_id\n+                     -> (node_id ref)\n+                       -> (opaque_id ref)\n+                         -> (filename * Ast.mod_items))\n+;;\n+\n+type pstate =\n+    { mutable pstate_peek : token;\n+      mutable pstate_ctxt : (string * pos) list;\n+      mutable pstate_rstr : bool;\n+      mutable pstate_depth: int;\n+      pstate_lexbuf       : Lexing.lexbuf;\n+      pstate_file         : filename;\n+      pstate_sess         : Session.sess;\n+      pstate_temp_id      : temp_id ref;\n+      pstate_node_id      : node_id ref;\n+      pstate_opaque_id    : opaque_id ref;\n+      pstate_get_mod      : get_mod_fn;\n+      pstate_infer_lib_name : (Ast.ident -> filename);\n+      pstate_required       : (node_id, (required_lib * nabi_conv)) Hashtbl.t;\n+      pstate_required_syms  : (node_id, string) Hashtbl.t; }\n+;;\n+\n+let log (ps:pstate) = Session.log \"parse\"\n+  ps.pstate_sess.Session.sess_log_parse\n+  ps.pstate_sess.Session.sess_log_out\n+;;\n+\n+let iflog ps thunk =\n+  if ps.pstate_sess.Session.sess_log_parse\n+  then thunk ()\n+  else ()\n+;;\n+\n+let make_parser\n+    (tref:temp_id ref)\n+    (nref:node_id ref)\n+    (oref:opaque_id ref)\n+    (sess:Session.sess)\n+    (get_mod:get_mod_fn)\n+    (infer_lib_name:Ast.ident -> filename)\n+    (required:(node_id, (required_lib * nabi_conv)) Hashtbl.t)\n+    (required_syms:(node_id, string) Hashtbl.t)\n+    (fname:string)\n+    : pstate =\n+  let lexbuf = Lexing.from_channel (open_in fname) in\n+  let spos = { lexbuf.Lexing.lex_start_p with Lexing.pos_fname = fname } in\n+  let cpos = { lexbuf.Lexing.lex_curr_p with Lexing.pos_fname = fname } in\n+    lexbuf.Lexing.lex_start_p <- spos;\n+    lexbuf.Lexing.lex_curr_p <- cpos;\n+    let first = Lexer.token lexbuf in\n+    let ps =\n+      { pstate_peek = first;\n+        pstate_ctxt = [];\n+        pstate_rstr = false;\n+        pstate_depth = 0;\n+        pstate_lexbuf = lexbuf;\n+        pstate_file = fname;\n+        pstate_sess = sess;\n+        pstate_temp_id = tref;\n+        pstate_node_id = nref;\n+        pstate_opaque_id = oref;\n+        pstate_get_mod = get_mod;\n+        pstate_infer_lib_name = infer_lib_name;\n+        pstate_required = required;\n+        pstate_required_syms = required_syms; }\n+    in\n+      iflog ps (fun _ -> log ps \"made parser for: %s\\n%!\" fname);\n+      ps\n+;;\n+\n+exception Parse_err of (pstate * string)\n+;;\n+\n+let lexpos (ps:pstate) : pos =\n+  let p = ps.pstate_lexbuf.Lexing.lex_start_p in\n+    (p.Lexing.pos_fname,\n+     p.Lexing.pos_lnum ,\n+     (p.Lexing.pos_cnum) - (p.Lexing.pos_bol))\n+;;\n+\n+let next_node_id (ps:pstate) : node_id =\n+  let id = !(ps.pstate_node_id) in\n+    ps.pstate_node_id := Node ((int_of_node id)+1);\n+    id\n+;;\n+\n+let next_opaque_id (ps:pstate) : opaque_id =\n+  let id = !(ps.pstate_opaque_id) in\n+    ps.pstate_opaque_id := Opaque ((int_of_opaque id)+1);\n+    id\n+;;\n+\n+let span\n+    (ps:pstate)\n+    (apos:pos)\n+    (bpos:pos)\n+    (x:'a)\n+    : 'a identified =\n+  let span = { lo = apos; hi = bpos } in\n+  let id = next_node_id ps in\n+    iflog ps (fun _ -> log ps \"span for node #%d: %s\"\n+                (int_of_node id) (Session.string_of_span span));\n+    htab_put ps.pstate_sess.Session.sess_spans id span;\n+    { node = x; id = id }\n+;;\n+\n+let decl p i =\n+  { Ast.decl_params = p;\n+    Ast.decl_item = i }\n+;;\n+\n+let spans\n+    (ps:pstate)\n+    (things:('a identified) array)\n+    (apos:pos)\n+    (thing:'a)\n+    : ('a identified) array =\n+  Array.append things [| (span ps apos (lexpos ps) thing) |]\n+;;\n+\n+(* \n+ * The point of this is to make a new node_id entry for a node that is a\n+ * \"copy\" of an lval returned from somewhere else. For example if you create\n+ * a temp, the lval it returns can only be used in *one* place, for the\n+ * node_id denotes the place that lval is first used; subsequent uses of\n+ * 'the same' reference must clone_lval it into a new node_id. Otherwise\n+ * there is trouble.\n+ *)\n+\n+let clone_span\n+    (ps:pstate)\n+    (oldnode:'a identified)\n+    (newthing:'b)\n+    : 'b identified =\n+  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans oldnode.id in\n+    span ps s.lo s.hi newthing\n+;;\n+\n+let rec clone_lval (ps:pstate) (lval:Ast.lval) : Ast.lval =\n+  match lval with\n+      Ast.LVAL_base nb ->\n+        let nnb = clone_span ps nb nb.node in\n+          Ast.LVAL_base nnb\n+    | Ast.LVAL_ext (base, ext) ->\n+        Ast.LVAL_ext ((clone_lval ps base), ext)\n+;;\n+\n+let clone_atom (ps:pstate) (atom:Ast.atom) : Ast.atom =\n+  match atom with\n+      Ast.ATOM_literal _ -> atom\n+    | Ast.ATOM_lval lv -> Ast.ATOM_lval (clone_lval ps lv)\n+;;\n+\n+let ctxt (n:string) (f:pstate -> 'a) (ps:pstate) : 'a =\n+  (ps.pstate_ctxt <- (n, lexpos ps) :: ps.pstate_ctxt;\n+   let res = f ps in\n+     ps.pstate_ctxt <- List.tl ps.pstate_ctxt;\n+     res)\n+;;\n+\n+let rstr (r:bool) (f:pstate -> 'a) (ps:pstate) : 'a =\n+  let prev = ps.pstate_rstr in\n+    (ps.pstate_rstr <- r;\n+     let res = f ps in\n+       ps.pstate_rstr <- prev;\n+       res)\n+;;\n+\n+let err (str:string) (ps:pstate) =\n+  (Parse_err (ps, (str)))\n+;;\n+\n+\n+let (slot_nil:Ast.slot) =\n+  { Ast.slot_mode = Ast.MODE_interior;\n+    Ast.slot_mutable = false;\n+    Ast.slot_ty = Some Ast.TY_nil }\n+;;\n+\n+let (slot_auto:Ast.slot) =\n+  { Ast.slot_mode = Ast.MODE_interior;\n+    Ast.slot_mutable = true;\n+    Ast.slot_ty = None }\n+;;\n+\n+let build_tmp\n+    (ps:pstate)\n+    (slot:Ast.slot)\n+    (apos:pos)\n+    (bpos:pos)\n+    : (temp_id * Ast.lval * Ast.stmt) =\n+  let nonce = !(ps.pstate_temp_id) in\n+    ps.pstate_temp_id := Temp ((int_of_temp nonce)+1);\n+    iflog ps\n+      (fun _ -> log ps \"building temporary %d\" (int_of_temp nonce));\n+    let decl = Ast.DECL_slot (Ast.KEY_temp nonce, (span ps apos bpos slot)) in\n+    let declstmt = span ps apos bpos (Ast.STMT_decl decl) in\n+    let tmp = Ast.LVAL_base (span ps apos bpos (Ast.BASE_temp nonce)) in\n+      (nonce, tmp, declstmt)\n+;;\n+\n+(* Simple helpers *)\n+\n+(* FIXME: please rename these, they make eyes bleed. *)\n+\n+let arr (ls:'a list) : 'a array = Array.of_list ls ;;\n+let arl (ls:'a list) : 'a array = Array.of_list (List.rev ls) ;;\n+let arj (ar:('a array array)) = Array.concat (Array.to_list ar) ;;\n+let arj1st (pairs:(('a array) * 'b) array) : (('a array) * 'b array) =\n+  let (az, bz) = List.split (Array.to_list pairs) in\n+    (Array.concat az, Array.of_list bz)\n+\n+\n+(* Bottom-most parser actions. *)\n+\n+let peek (ps:pstate) : token =\n+  iflog ps\n+    begin\n+      fun _ ->\n+        log ps \"peeking at: %s     // %s\"\n+          (string_of_tok ps.pstate_peek)\n+          (match ps.pstate_ctxt with\n+               (s, _) :: _ -> s\n+             | _ -> \"<empty>\")\n+    end;\n+  ps.pstate_peek\n+;;\n+\n+\n+let bump (ps:pstate) : unit =\n+  begin\n+    iflog ps (fun _ -> log ps \"bumping past: %s\"\n+                (string_of_tok ps.pstate_peek));\n+    ps.pstate_peek <- Lexer.token ps.pstate_lexbuf\n+  end\n+;;\n+\n+let bump_bracequote (ps:pstate) : unit =\n+  begin\n+    assert (ps.pstate_peek = LBRACE);\n+    iflog ps (fun _ -> log ps \"bumping past: %s\"\n+                (string_of_tok ps.pstate_peek));\n+    let buf = Buffer.create 32 in\n+      ps.pstate_peek <- Lexer.bracequote buf 1 ps.pstate_lexbuf\n+  end\n+;;\n+\n+\n+let expect (ps:pstate) (t:token) : unit =\n+  let p = peek ps in\n+    if p == t\n+    then bump ps\n+    else\n+      let msg = (\"Expected '\" ^ (string_of_tok t) ^\n+                   \"', found '\" ^ (string_of_tok p ) ^ \"'\") in\n+        raise (Parse_err (ps, msg))\n+;;\n+\n+let unexpected (ps:pstate) =\n+  err (\"Unexpected token '\" ^ (string_of_tok (peek ps)) ^ \"'\") ps\n+;;\n+\n+\n+\n+(* Parser combinators. *)\n+\n+let one_or_more\n+    (sep:token)\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  let accum = ref [prule ps] in\n+    while peek ps == sep\n+    do\n+      bump ps;\n+      accum := (prule ps) :: !accum\n+    done;\n+    arl !accum\n+;;\n+\n+let bracketed_seq\n+    (mandatory:int)\n+    (bra:token)\n+    (ket:token)\n+    (sepOpt:token option)\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  expect ps bra;\n+  let accum = ref [] in\n+  let dosep _ =\n+    (match sepOpt with\n+         None -> ()\n+       | Some tok ->\n+           if (!accum = [])\n+           then ()\n+           else expect ps tok)\n+  in\n+    while mandatory > List.length (!accum) do\n+      dosep ();\n+      accum := (prule ps) :: (!accum)\n+    done;\n+    while (not (peek ps = ket))\n+    do\n+      dosep ();\n+      accum := (prule ps) :: !accum\n+    done;\n+    expect ps ket;\n+    arl !accum\n+;;\n+\n+\n+let bracketed_zero_or_more\n+    (bra:token)\n+    (ket:token)\n+    (sepOpt:token option)\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  bracketed_seq 0 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n+;;\n+\n+\n+let paren_comma_list\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  bracketed_zero_or_more LPAREN RPAREN (Some COMMA) prule ps\n+;;\n+\n+let bracketed_one_or_more\n+    (bra:token)\n+    (ket:token)\n+    (sepOpt:token option)\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  bracketed_seq 1 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n+;;\n+\n+let bracketed_two_or_more\n+    (bra:token)\n+    (ket:token)\n+    (sepOpt:token option)\n+    (prule:pstate -> 'a)\n+    (ps:pstate)\n+    : 'a array =\n+  bracketed_seq 2 bra ket sepOpt (ctxt \"bracketed_seq\" prule) ps\n+;;\n+\n+\n+let bracketed (bra:token) (ket:token) (prule:pstate -> 'a) (ps:pstate) : 'a =\n+  expect ps bra;\n+  let res = ctxt \"bracketed\" prule ps in\n+    expect ps ket;\n+    res\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "49eeeb5b648260665becce01cbb8a85787df0aa5", "filename": "src/boot/fe/pexp.ml", "status": "added", "additions": 1354, "deletions": 0, "changes": 1354, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fpexp.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Fpexp.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Fpexp.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,1354 @@\n+\n+open Common;;\n+open Token;;\n+open Parser;;\n+\n+(* NB: pexps (parser-expressions) are only used transiently during\n+ * parsing, static-evaluation and syntax-expansion.  They're desugared\n+ * into the general \"item\" AST and/or evaluated as part of the\n+ * outermost \"cexp\" expressions. Expressions that can show up in source\n+ * correspond to this loose grammar and have a wide-ish flexibility in\n+ * *theoretical* composition; only subsets of those compositions are\n+ * legal in various AST contexts.\n+ * \n+ * Desugaring on the fly is unfortunately complicated enough to require\n+ * -- or at least \"make much more convenient\" -- this two-pass\n+ * routine.\n+ *)\n+\n+type pexp' =\n+    PEXP_call of (pexp * pexp array)\n+  | PEXP_spawn of (Ast.domain * pexp)\n+  | PEXP_bind of (pexp * pexp option array)\n+  | PEXP_rec of ((Ast.ident * pexp) array * pexp option)\n+  | PEXP_tup of (pexp array)\n+  | PEXP_vec of (Ast.slot * (pexp array))\n+  | PEXP_port\n+  | PEXP_chan of (pexp option)\n+  | PEXP_binop of (Ast.binop * pexp * pexp)\n+  | PEXP_lazy_and of (pexp * pexp)\n+  | PEXP_lazy_or of (pexp * pexp)\n+  | PEXP_unop of (Ast.unop * pexp)\n+  | PEXP_lval of plval\n+  | PEXP_lit of Ast.lit\n+  | PEXP_str of string\n+  | PEXP_mutable of pexp\n+  | PEXP_exterior of pexp\n+  | PEXP_custom of Ast.name * (token array) * (string option)\n+\n+and plval =\n+    PLVAL_ident of Ast.ident\n+  | PLVAL_app of (Ast.ident * (Ast.ty array))\n+  | PLVAL_ext_name of (pexp * Ast.name_component)\n+  | PLVAL_ext_pexp of (pexp * pexp)\n+\n+and pexp = pexp' Common.identified\n+;;\n+\n+(* Pexp grammar. Includes names, idents, types, constrs, binops and unops,\n+   etc. *)\n+\n+let parse_ident (ps:pstate) : Ast.ident =\n+  match peek ps with\n+      IDENT id -> (bump ps; id)\n+    (* Decay IDX tokens to identifiers if they occur ousdide name paths. *)\n+    | IDX i -> (bump ps; string_of_tok (IDX i))\n+    | _ -> raise (unexpected ps)\n+;;\n+\n+(* Enforces the restricted pexp grammar when applicable (e.g. after \"bind\") *)\n+let check_rstr_start (ps:pstate) : 'a =\n+  if (ps.pstate_rstr) then\n+    match peek ps with\n+        IDENT _ | LPAREN -> ()\n+      | _ -> raise (unexpected ps)\n+;;\n+\n+let rec parse_name_component (ps:pstate) : Ast.name_component =\n+  match peek ps with\n+      IDENT id ->\n+        (bump ps;\n+         match peek ps with\n+             LBRACKET ->\n+               let tys =\n+                 ctxt \"name_component: apply\"\n+                   (bracketed_one_or_more LBRACKET RBRACKET\n+                      (Some COMMA) parse_ty) ps\n+               in\n+                 Ast.COMP_app (id, tys)\n+           | _ -> Ast.COMP_ident id)\n+\n+    | IDX i ->\n+        bump ps;\n+        Ast.COMP_idx i\n+    | _ -> raise (unexpected ps)\n+\n+and parse_name_base (ps:pstate) : Ast.name_base =\n+  match peek ps with\n+      IDENT i ->\n+        (bump ps;\n+         match peek ps with\n+             LBRACKET ->\n+               let tys =\n+                 ctxt \"name_base: apply\"\n+                   (bracketed_one_or_more LBRACKET RBRACKET\n+                      (Some COMMA) parse_ty) ps\n+               in\n+                 Ast.BASE_app (i, tys)\n+           | _ -> Ast.BASE_ident i)\n+    | _ -> raise (unexpected ps)\n+\n+and parse_name_ext (ps:pstate) (base:Ast.name) : Ast.name =\n+  match peek ps with\n+      DOT ->\n+        bump ps;\n+        let comps = one_or_more DOT parse_name_component ps in\n+          Array.fold_left (fun x y -> Ast.NAME_ext (x, y)) base comps\n+    | _ -> base\n+\n+\n+and parse_name (ps:pstate) : Ast.name =\n+  let base = Ast.NAME_base (parse_name_base ps) in\n+  let name = parse_name_ext ps base in\n+    if Ast.sane_name name\n+    then name\n+    else raise (err \"malformed name\" ps)\n+\n+and parse_carg_base (ps:pstate) : Ast.carg_base =\n+  match peek ps with\n+      STAR -> bump ps; Ast.BASE_formal\n+    | _ -> Ast.BASE_named (parse_name_base ps)\n+\n+and parse_carg (ps:pstate) : Ast.carg =\n+  match peek ps with\n+      IDENT _ ->\n+        begin\n+          let base = Ast.CARG_base (parse_carg_base ps) in\n+          let path =\n+            match peek ps with\n+                DOT ->\n+                  bump ps;\n+                  let comps = one_or_more DOT parse_name_component ps in\n+                    Array.fold_left\n+                      (fun x y -> Ast.CARG_ext (x, y)) base comps\n+              | _ -> base\n+          in\n+            Ast.CARG_path path\n+        end\n+    | _ ->\n+        Ast.CARG_lit (parse_lit ps)\n+\n+\n+and parse_constraint (ps:pstate) : Ast.constr =\n+  match peek ps with\n+\n+      (*\n+       * NB: A constraint *looks* a lot like an EXPR_call, but is restricted\n+       * syntactically: the constraint name needs to be a name (not an lval)\n+       * and the constraint args all need to be cargs, which are similar to\n+       * names but can begin with the 'formal' base anchor '*'.\n+       *)\n+\n+      IDENT _ ->\n+        let n = ctxt \"constraint: name\" parse_name ps in\n+        let args = ctxt \"constraint: args\"\n+          (bracketed_zero_or_more\n+             LPAREN RPAREN (Some COMMA)\n+             parse_carg) ps\n+        in\n+          { Ast.constr_name = n;\n+            Ast.constr_args = args }\n+    | _ -> raise (unexpected ps)\n+\n+\n+and parse_constrs (ps:pstate) : Ast.constrs =\n+  ctxt \"state: constraints\" (one_or_more COMMA parse_constraint) ps\n+\n+and parse_optional_trailing_constrs (ps:pstate) : Ast.constrs =\n+  match peek ps with\n+      COLON -> (bump ps; parse_constrs ps)\n+    | _ -> [| |]\n+\n+and parse_effect (ps:pstate) : Ast.effect =\n+  match peek ps with\n+      IO -> bump ps; Ast.IO\n+    | STATE -> bump ps; Ast.STATE\n+    | UNSAFE -> bump ps; Ast.UNSAFE\n+    | _ -> Ast.PURE\n+\n+and parse_ty_fn\n+    (effect:Ast.effect)\n+    (ps:pstate)\n+    : (Ast.ty_fn * Ast.ident option) =\n+  match peek ps with\n+      FN | ITER ->\n+        let is_iter = (peek ps) = ITER in\n+          bump ps;\n+          let ident =\n+            match peek ps with\n+                IDENT i -> bump ps; Some i\n+              | _ -> None\n+          in\n+          let in_slots =\n+            match peek ps with\n+                _ ->\n+                  bracketed_zero_or_more LPAREN RPAREN (Some COMMA)\n+                    (parse_slot_and_optional_ignored_ident true) ps\n+          in\n+          let out_slot =\n+            match peek ps with\n+                RARROW -> (bump ps; parse_slot false ps)\n+              | _ -> slot_nil\n+          in\n+          let constrs = parse_optional_trailing_constrs ps in\n+          let tsig = { Ast.sig_input_slots = in_slots;\n+                       Ast.sig_input_constrs = constrs;\n+                       Ast.sig_output_slot = out_slot; }\n+          in\n+          let taux = { Ast.fn_effect = effect;\n+                       Ast.fn_is_iter = is_iter; }\n+          in\n+          let tfn = (tsig, taux) in\n+            (tfn, ident)\n+\n+    | _ -> raise (unexpected ps)\n+\n+and check_dup_rec_labels ps labels =\n+  arr_check_dups labels\n+    (fun l _ ->\n+       raise (err (Printf.sprintf\n+                     \"duplicate record label: %s\" l) ps));\n+\n+\n+and parse_atomic_ty (ps:pstate) : Ast.ty =\n+  match peek ps with\n+\n+      BOOL ->\n+        bump ps;\n+        Ast.TY_bool\n+\n+    | INT ->\n+        bump ps;\n+        Ast.TY_int\n+\n+    | UINT ->\n+        bump ps;\n+        Ast.TY_uint\n+\n+    | CHAR ->\n+        bump ps;\n+        Ast.TY_char\n+\n+    | STR ->\n+        bump ps;\n+        Ast.TY_str\n+\n+    | ANY ->\n+        bump ps;\n+        Ast.TY_any\n+\n+    | TASK ->\n+        bump ps;\n+        Ast.TY_task\n+\n+    | CHAN ->\n+        bump ps;\n+        Ast.TY_chan (bracketed LBRACKET RBRACKET parse_ty ps)\n+\n+    | PORT ->\n+        bump ps;\n+        Ast.TY_port (bracketed LBRACKET RBRACKET parse_ty ps)\n+\n+    | VEC ->\n+        bump ps;\n+        Ast.TY_vec (bracketed LBRACKET RBRACKET (parse_slot false) ps)\n+\n+    | IDENT _ -> Ast.TY_named (parse_name ps)\n+\n+\n+    | TAG ->\n+        bump ps;\n+        let htab = Hashtbl.create 4 in\n+        let parse_tag_entry ps =\n+          let ident = parse_ident ps in\n+          let tup =\n+            match peek ps with\n+                LPAREN -> paren_comma_list (parse_slot false) ps\n+              | _ -> raise (err \"tag variant missing argument list\" ps)\n+          in\n+            htab_put htab (Ast.NAME_base (Ast.BASE_ident ident)) tup\n+        in\n+        let _ =\n+          bracketed_one_or_more LPAREN RPAREN\n+            (Some COMMA) (ctxt \"tag: variant\" parse_tag_entry) ps\n+        in\n+          Ast.TY_tag htab\n+\n+    | REC ->\n+        bump ps;\n+        let parse_rec_entry ps =\n+          let mut = parse_mutability ps in\n+          let (slot, ident) = parse_slot_and_ident false ps in\n+            (ident, apply_mutability slot mut)\n+        in\n+        let entries = paren_comma_list parse_rec_entry ps in\n+        let labels = Array.map (fun (l, _) -> l) entries in\n+          begin\n+            check_dup_rec_labels ps labels;\n+            Ast.TY_rec entries\n+          end\n+\n+    | TUP ->\n+        bump ps;\n+        let slots = paren_comma_list (parse_slot false) ps in\n+          Ast.TY_tup slots\n+\n+    | MACH m ->\n+        bump ps;\n+        Ast.TY_mach m\n+\n+    | IO | STATE | UNSAFE | OBJ | FN | ITER ->\n+        let effect = parse_effect ps in\n+          begin\n+            match peek ps with\n+                OBJ ->\n+                  bump ps;\n+                  let methods = Hashtbl.create 0 in\n+                  let parse_method ps =\n+                    let effect = parse_effect ps in\n+                    let (tfn, ident) = parse_ty_fn effect ps in\n+                      expect ps SEMI;\n+                      match ident with\n+                          None ->\n+                            raise (err (Printf.sprintf\n+                                          \"missing method identifier\") ps)\n+                        | Some i -> htab_put methods i tfn\n+                  in\n+                    ignore (bracketed_zero_or_more LBRACE RBRACE\n+                              None parse_method ps);\n+                    Ast.TY_obj (effect, methods)\n+\n+              | FN | ITER ->\n+                  Ast.TY_fn (fst (parse_ty_fn effect ps))\n+              | _ -> raise (unexpected ps)\n+          end\n+\n+    | LPAREN ->\n+        begin\n+          bump ps;\n+          match peek ps with\n+              RPAREN ->\n+                bump ps;\n+                Ast.TY_nil\n+            | _ ->\n+                let t = parse_ty ps in\n+                  expect ps RPAREN;\n+                  t\n+        end\n+\n+    | _ -> raise (unexpected ps)\n+\n+and flag (ps:pstate) (tok:token) : bool =\n+  if peek ps = tok\n+  then (bump ps; true)\n+  else false\n+\n+and parse_mutability (ps:pstate) : bool =\n+  flag ps MUTABLE\n+\n+and apply_mutability (slot:Ast.slot) (mut:bool) : Ast.slot =\n+  { slot with Ast.slot_mutable = mut }\n+\n+and parse_slot (aliases_ok:bool) (ps:pstate) : Ast.slot =\n+  let mut = parse_mutability ps in\n+  let mode =\n+  match (peek ps, aliases_ok) with\n+      (AT, _) -> bump ps; Ast.MODE_exterior\n+    | (AND, true) -> bump ps; Ast.MODE_alias\n+    | (AND, false) -> raise (err \"alias slot in prohibited context\" ps)\n+    | _ -> Ast.MODE_interior\n+  in\n+  let ty = parse_ty ps in\n+    { Ast.slot_mode = mode;\n+      Ast.slot_mutable = mut;\n+      Ast.slot_ty = Some ty }\n+\n+and parse_slot_and_ident\n+    (aliases_ok:bool)\n+    (ps:pstate)\n+    : (Ast.slot * Ast.ident) =\n+  let slot = ctxt \"slot and ident: slot\" (parse_slot aliases_ok) ps in\n+  let ident = ctxt \"slot and ident: ident\" parse_ident ps in\n+    (slot, ident)\n+\n+and parse_slot_and_optional_ignored_ident\n+    (aliases_ok:bool)\n+    (ps:pstate)\n+    : Ast.slot =\n+  let slot = parse_slot aliases_ok ps in\n+    begin\n+      match peek ps with\n+          IDENT _ -> bump ps\n+        | _ -> ()\n+    end;\n+    slot\n+\n+and parse_identified_slot\n+    (aliases_ok:bool)\n+    (ps:pstate)\n+    : Ast.slot identified =\n+  let apos = lexpos ps in\n+  let slot = parse_slot aliases_ok ps in\n+  let bpos = lexpos ps in\n+    span ps apos bpos slot\n+\n+and parse_constrained_ty (ps:pstate) : Ast.ty =\n+  let base = ctxt \"ty: base\" parse_atomic_ty ps in\n+    match peek ps with\n+        COLON ->\n+          bump ps;\n+          let constrs = ctxt \"ty: constrs\" parse_constrs ps in\n+            Ast.TY_constrained (base, constrs)\n+\n+      | _ -> base\n+\n+and parse_ty (ps:pstate) : Ast.ty =\n+  parse_constrained_ty ps\n+\n+\n+and parse_rec_input (ps:pstate) : (Ast.ident * pexp) =\n+  let lab = (ctxt \"rec input: label\" parse_ident ps) in\n+    match peek ps with\n+        EQ ->\n+          bump ps;\n+          let pexp = ctxt \"rec input: expr\" parse_pexp ps in\n+            (lab, pexp)\n+      | _ -> raise (unexpected ps)\n+\n+\n+and parse_rec_body (ps:pstate) : pexp' = (*((Ast.ident * pexp) array) =*)\n+  begin\n+    expect ps LPAREN;\n+    match peek ps with\n+        RPAREN -> PEXP_rec ([||], None)\n+      | WITH -> raise (err \"empty record extension\" ps)\n+      | _ ->\n+          let inputs = one_or_more COMMA parse_rec_input ps in\n+          let labels = Array.map (fun (l, _) -> l) inputs in\n+            begin\n+              check_dup_rec_labels ps labels;\n+              match peek ps with\n+                  RPAREN -> (bump ps; PEXP_rec (inputs, None))\n+                | WITH ->\n+                    begin\n+                      bump ps;\n+                      let base =\n+                        ctxt \"rec input: extension base\"\n+                          parse_pexp ps\n+                      in\n+                        expect ps RPAREN;\n+                        PEXP_rec (inputs, Some base)\n+                    end\n+                | _ -> raise (err \"expected 'with' or ')'\" ps)\n+            end\n+  end\n+\n+\n+and parse_lit (ps:pstate) : Ast.lit =\n+  match peek ps with\n+      LIT_INT (n,s) -> (bump ps; Ast.LIT_int (n,s))\n+    | LIT_CHAR c -> (bump ps; Ast.LIT_char c)\n+    | LIT_BOOL b -> (bump ps; Ast.LIT_bool b)\n+    | _ -> raise (unexpected ps)\n+\n+\n+and parse_bottom_pexp (ps:pstate) : pexp =\n+  check_rstr_start ps;\n+  let apos = lexpos ps in\n+  match peek ps with\n+\n+      MUTABLE ->\n+        bump ps;\n+        let inner = parse_pexp ps in\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_mutable inner)\n+\n+    | AT ->\n+        bump ps;\n+        let inner = parse_pexp ps in\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_exterior inner)\n+\n+    | TUP ->\n+        bump ps;\n+        let pexps = ctxt \"paren pexps(s)\" (rstr false parse_pexp_list) ps in\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_tup pexps)\n+\n+    | REC ->\n+          bump ps;\n+          let body = ctxt \"rec pexp: rec body\" parse_rec_body ps in\n+          let bpos = lexpos ps in\n+            span ps apos bpos body\n+\n+    | VEC ->\n+        bump ps;\n+        begin\n+          let slot =\n+            match peek ps with\n+                LBRACKET -> bracketed LBRACKET RBRACKET (parse_slot false) ps\n+              | _ -> { Ast.slot_mode = Ast.MODE_interior;\n+                       Ast.slot_mutable = false;\n+                       Ast.slot_ty = None }\n+          in\n+          let pexps = ctxt \"vec pexp: exprs\" parse_pexp_list ps in\n+          let bpos = lexpos ps in\n+            span ps apos bpos (PEXP_vec (slot, pexps))\n+        end\n+\n+\n+    | LIT_STR s ->\n+        bump ps;\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_str s)\n+\n+    | PORT ->\n+        begin\n+            bump ps;\n+            expect ps LPAREN;\n+            expect ps RPAREN;\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_port)\n+        end\n+\n+    | CHAN ->\n+        begin\n+            bump ps;\n+            let port =\n+              match peek ps with\n+                  LPAREN ->\n+                    begin\n+                      bump ps;\n+                      match peek ps with\n+                          RPAREN -> (bump ps; None)\n+                        | _ ->\n+                            let lv = parse_pexp ps in\n+                              expect ps RPAREN;\n+                              Some lv\n+                    end\n+                | _ -> raise (unexpected ps)\n+            in\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_chan port)\n+        end\n+\n+    | SPAWN ->\n+        bump ps;\n+        let domain =\n+          match peek ps with\n+              THREAD -> bump ps; Ast.DOMAIN_thread\n+            | _ -> Ast.DOMAIN_local\n+        in\n+        let pexp = ctxt \"spawn [domain] pexp: init call\" parse_pexp ps in\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_spawn (domain, pexp))\n+\n+    | BIND ->\n+        let apos = lexpos ps in\n+          begin\n+            bump ps;\n+            let pexp = ctxt \"bind pexp: function\" (rstr true parse_pexp) ps in\n+            let args =\n+              ctxt \"bind args\"\n+                (paren_comma_list parse_bind_arg) ps\n+            in\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_bind (pexp, args))\n+          end\n+\n+    | IDENT i ->\n+        begin\n+          bump ps;\n+          match peek ps with\n+              LBRACKET ->\n+                begin\n+                  let tys =\n+                    ctxt \"apply-type expr\"\n+                      (bracketed_one_or_more LBRACKET RBRACKET\n+                         (Some COMMA) parse_ty) ps\n+                  in\n+                  let bpos = lexpos ps in\n+                    span ps apos bpos (PEXP_lval (PLVAL_app (i, tys)))\n+                end\n+\n+            | _ ->\n+                begin\n+                  let bpos = lexpos ps in\n+                    span ps apos bpos (PEXP_lval (PLVAL_ident i))\n+                end\n+        end\n+\n+    | (INT | UINT | CHAR | BOOL) as tok ->\n+        begin\n+          bump ps;\n+          expect ps LPAREN;\n+          match peek ps with\n+              (LIT_INT _ | LIT_CHAR _ | LIT_BOOL _) as tok2 ->\n+                bump ps;\n+                expect ps RPAREN;\n+                let i = match tok2 with\n+                    LIT_INT i -> i\n+                  | LIT_CHAR c -> (Int64.of_int c,\n+                                   Common.escaped_char c)\n+                  | LIT_BOOL b -> if b then (1L, \"1\") else (0L, \"0\")\n+                  | _ -> bug () \"expected int/char literal\"\n+                in\n+                let bpos = lexpos ps in\n+                  span ps apos bpos\n+                    (PEXP_lit\n+                       (match tok with\n+                            INT -> Ast.LIT_int i\n+                          | UINT -> Ast.LIT_uint i\n+                          | CHAR ->\n+                              Ast.LIT_char\n+                                (Int64.to_int (fst i))\n+                          | BOOL -> Ast.LIT_bool (fst i <> 0L)\n+                          | _ -> bug () \"expected int/uint/char/bool token\"))\n+\n+          | _ ->\n+              let pexp = parse_pexp ps in\n+                expect ps RPAREN;\n+                let bpos = lexpos ps in\n+                let t =\n+                  match tok with\n+                      INT -> Ast.TY_int\n+                    | UINT -> Ast.TY_uint\n+                    | CHAR -> Ast.TY_char\n+                    | BOOL -> Ast.TY_bool\n+                    | _ -> bug () \"expected int/uint/char/bool token\"\n+                in\n+                let t = span ps apos bpos t in\n+                  span ps apos bpos\n+                    (PEXP_unop ((Ast.UNOP_cast t), pexp))\n+        end\n+\n+    | MACH m ->\n+        let literal (num, str) =\n+          let _ = bump ps in\n+          let _ = expect ps RPAREN in\n+          let bpos = lexpos ps in\n+          let check_range (lo:int64) (hi:int64) : unit =\n+            if (num < lo) or (num > hi)\n+            then raise (err (Printf.sprintf\n+                               \"integral literal %Ld out of range [%Ld,%Ld]\"\n+                               num lo hi) ps)\n+            else ()\n+          in\n+            begin\n+              match m with\n+                  TY_u8 -> check_range 0L 0xffL\n+                | TY_u16 -> check_range 0L 0xffffL\n+                | TY_u32 -> check_range 0L 0xffffffffL\n+                    (* | TY_u64 -> ... *)\n+                | TY_i8 -> check_range (-128L) 127L\n+                | TY_i16 -> check_range (-32768L) 32767L\n+                | TY_i32 -> check_range (-2147483648L) 2147483647L\n+                    (*\n+                      | TY_i64 -> ...\n+                      | TY_f32 -> ...\n+                      | TY_f64 -> ...\n+                    *)\n+                | _ -> ()\n+            end;\n+            span ps apos bpos\n+              (PEXP_lit\n+                 (Ast.LIT_mach\n+                    (m, num, str)))\n+\n+        in\n+          begin\n+            bump ps;\n+            expect ps LPAREN;\n+            match peek ps with\n+                LIT_INT (n,s) -> literal (n,s)\n+              | MINUS ->\n+                  begin\n+                    bump ps;\n+                    match peek ps with\n+                        LIT_INT (n,s) ->\n+                          literal (Int64.neg n, \"-\" ^ s)\n+                      | _ -> raise (unexpected ps)\n+                  end\n+              | _ ->\n+                  let pexp = parse_pexp ps in\n+                    expect ps RPAREN;\n+                    let bpos = lexpos ps in\n+                    let t = span ps apos bpos (Ast.TY_mach m) in\n+                      span ps apos bpos\n+                        (PEXP_unop ((Ast.UNOP_cast t), pexp))\n+          end\n+\n+    | POUND ->\n+        bump ps;\n+        let name = parse_name ps in\n+        let toks =\n+          match peek ps with\n+              LPAREN ->\n+                bump ps;\n+                let toks = Queue.create () in\n+                  while (peek ps) <> RPAREN\n+                  do\n+                    Queue.add (peek ps) toks;\n+                    bump ps;\n+                  done;\n+                  expect ps RPAREN;\n+                  queue_to_arr toks\n+            | _ -> [| |]\n+        in\n+        let str =\n+          match peek ps with\n+              LBRACE ->\n+                begin\n+                  bump_bracequote ps;\n+                  match peek ps with\n+                      BRACEQUOTE s -> bump ps; Some s\n+                    | _ -> raise (unexpected ps)\n+                end\n+            | _ -> None\n+        in\n+        let bpos = lexpos ps in\n+          span ps apos bpos\n+            (PEXP_custom (name, toks, str))\n+\n+    | LPAREN ->\n+        begin\n+          bump ps;\n+          match peek ps with\n+              RPAREN ->\n+                bump ps;\n+                let bpos = lexpos ps in\n+                  span ps apos bpos (PEXP_lit Ast.LIT_nil)\n+            | _ ->\n+                let pexp = parse_pexp ps in\n+                  expect ps RPAREN;\n+                  pexp\n+        end\n+\n+    | _ ->\n+        let lit = parse_lit ps in\n+        let bpos = lexpos ps in\n+          span ps apos bpos (PEXP_lit lit)\n+\n+\n+and parse_bind_arg (ps:pstate) : pexp option =\n+  match peek ps with\n+      UNDERSCORE -> (bump ps; None)\n+    | _ -> Some (parse_pexp ps)\n+\n+\n+and parse_ext_pexp (ps:pstate) (pexp:pexp) : pexp =\n+  let apos = lexpos ps in\n+    match peek ps with\n+        LPAREN ->\n+          if ps.pstate_rstr\n+          then pexp\n+          else\n+            let args = parse_pexp_list ps in\n+            let bpos = lexpos ps in\n+            let ext = span ps apos bpos (PEXP_call (pexp, args)) in\n+              parse_ext_pexp ps ext\n+\n+      | DOT ->\n+          begin\n+            bump ps;\n+            let ext =\n+              match peek ps with\n+                  LPAREN ->\n+                    bump ps;\n+                    let rhs = rstr false parse_pexp ps in\n+                      expect ps RPAREN;\n+                      let bpos = lexpos ps in\n+                        span ps apos bpos\n+                          (PEXP_lval (PLVAL_ext_pexp (pexp, rhs)))\n+                | _ ->\n+                    let rhs = parse_name_component ps in\n+                    let bpos = lexpos ps in\n+                      span ps apos bpos\n+                        (PEXP_lval (PLVAL_ext_name (pexp, rhs)))\n+            in\n+              parse_ext_pexp ps ext\n+          end\n+\n+      | _ -> pexp\n+\n+\n+and parse_negation_pexp (ps:pstate) : pexp =\n+    let apos = lexpos ps in\n+      match peek ps with\n+          NOT ->\n+            bump ps;\n+            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_unop (Ast.UNOP_not, rhs))\n+\n+        | TILDE ->\n+            bump ps;\n+            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_unop (Ast.UNOP_bitnot, rhs))\n+\n+        | MINUS ->\n+            bump ps;\n+            let rhs = ctxt \"negation pexp\" parse_negation_pexp ps in\n+            let bpos = lexpos ps in\n+              span ps apos bpos (PEXP_unop (Ast.UNOP_neg, rhs))\n+\n+        | _ ->\n+            let lhs = parse_bottom_pexp ps in\n+              parse_ext_pexp ps lhs\n+\n+\n+(* Binops are all left-associative,                *)\n+(* so we factor out some of the parsing code here. *)\n+and binop_rhs\n+    (ps:pstate)\n+    (name:string)\n+    (apos:pos)\n+    (lhs:pexp)\n+    (rhs_parse_fn:pstate -> pexp)\n+    (op:Ast.binop)\n+    : pexp =\n+  bump ps;\n+  let rhs = (ctxt (name ^ \" rhs\") rhs_parse_fn ps) in\n+  let bpos = lexpos ps in\n+    span ps apos bpos (PEXP_binop (op, lhs, rhs))\n+\n+\n+and parse_factor_pexp (ps:pstate) : pexp =\n+  let name = \"factor pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_negation_pexp ps in\n+    match peek ps with\n+        STAR    -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mul\n+      | SLASH   -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_div\n+      | PERCENT -> binop_rhs ps name apos lhs parse_factor_pexp Ast.BINOP_mod\n+      | _       -> lhs\n+\n+\n+and parse_term_pexp (ps:pstate) : pexp =\n+  let name = \"term pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_factor_pexp ps in\n+    match peek ps with\n+        PLUS  -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_add\n+      | MINUS -> binop_rhs ps name apos lhs parse_term_pexp Ast.BINOP_sub\n+      | _     -> lhs\n+\n+\n+and parse_shift_pexp (ps:pstate) : pexp =\n+  let name = \"shift pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_term_pexp ps in\n+    match peek ps with\n+        LSL -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsl\n+      | LSR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_lsr\n+      | ASR -> binop_rhs ps name apos lhs parse_shift_pexp Ast.BINOP_asr\n+      | _ -> lhs\n+\n+\n+and parse_and_pexp (ps:pstate) : pexp =\n+  let name = \"and pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_shift_pexp ps in\n+    match peek ps with\n+        AND -> binop_rhs ps name apos lhs parse_and_pexp Ast.BINOP_and\n+      | _   -> lhs\n+\n+\n+and parse_xor_pexp (ps:pstate) : pexp =\n+  let name = \"xor pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_and_pexp ps in\n+    match peek ps with\n+        CARET -> binop_rhs ps name apos lhs parse_xor_pexp Ast.BINOP_xor\n+      | _ -> lhs\n+\n+\n+and parse_or_pexp (ps:pstate) : pexp =\n+  let name = \"or pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_xor_pexp ps in\n+    match peek ps with\n+        OR -> binop_rhs ps name apos lhs parse_or_pexp Ast.BINOP_or\n+      | _  -> lhs\n+\n+\n+and parse_relational_pexp (ps:pstate) : pexp =\n+  let name = \"relational pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_or_pexp ps in\n+    match peek ps with\n+        LT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_lt\n+      | LE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_le\n+      | GE -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_ge\n+      | GT -> binop_rhs ps name apos lhs parse_relational_pexp Ast.BINOP_gt\n+      | _  -> lhs\n+\n+\n+and parse_equality_pexp (ps:pstate) : pexp =\n+  let name = \"equality pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_relational_pexp ps in\n+    match peek ps with\n+        EQEQ -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_eq\n+      | NE   -> binop_rhs ps name apos lhs parse_equality_pexp Ast.BINOP_ne\n+      | _    -> lhs\n+\n+\n+and parse_andand_pexp (ps:pstate) : pexp =\n+  let name = \"andand pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_equality_pexp ps in\n+    match peek ps with\n+        ANDAND ->\n+          bump ps;\n+          let rhs = parse_andand_pexp ps in\n+          let bpos = lexpos ps in\n+            span ps apos bpos (PEXP_lazy_and (lhs, rhs))\n+\n+      | _   -> lhs\n+\n+\n+and parse_oror_pexp (ps:pstate) : pexp =\n+  let name = \"oror pexp\" in\n+  let apos = lexpos ps in\n+  let lhs = ctxt (name ^ \" lhs\") parse_andand_pexp ps in\n+    match peek ps with\n+        OROR ->\n+          bump ps;\n+          let rhs = parse_oror_pexp ps in\n+          let bpos = lexpos ps in\n+            span ps apos bpos (PEXP_lazy_or (lhs, rhs))\n+\n+      | _  -> lhs\n+\n+and parse_as_pexp (ps:pstate) : pexp =\n+  let apos = lexpos ps in\n+  let pexp = ctxt \"as pexp\" parse_oror_pexp ps in\n+    match peek ps with\n+        AS ->\n+          bump ps;\n+          let tapos = lexpos ps in\n+          let t = parse_ty ps in\n+          let bpos = lexpos ps in\n+          let t = span ps tapos bpos t in\n+            span ps apos bpos\n+              (PEXP_unop ((Ast.UNOP_cast t), pexp))\n+\n+      | _       -> pexp\n+\n+and parse_pexp (ps:pstate) : pexp =\n+  parse_as_pexp ps\n+\n+\n+and parse_pexp_list (ps:pstate) : pexp array =\n+  match peek ps with\n+      LPAREN ->\n+        bracketed_zero_or_more LPAREN RPAREN (Some COMMA)\n+          (ctxt \"pexp list\" parse_pexp) ps\n+    | _ -> raise (unexpected ps)\n+\n+;;\n+\n+(* \n+ * FIXME: This is a crude approximation of the syntax-extension system,\n+ * for purposes of prototyping and/or hard-wiring any extensions we\n+ * wish to use in the bootstrap compiler. The eventual aim is to permit\n+ * loading rust crates to process extensions, but this will likely\n+ * require a rust-based frontend, or an ocaml-FFI-based connection to\n+ * rust crates. At the moment we have neither.\n+ *)\n+\n+let expand_pexp_custom\n+    (ps:pstate)\n+    (name:Ast.name)\n+    (args:token array)\n+    (body:string option)\n+    : pexp' =\n+  let nstr = Ast.fmt_to_str Ast.fmt_name name in\n+    match (nstr, (Array.length args), body) with\n+\n+        (\"shell\", 0, Some cmd) ->\n+          let c = Unix.open_process_in cmd in\n+          let b = Buffer.create 32 in\n+          let rec r _ =\n+            try\n+              Buffer.add_char b (input_char c);\n+              r ()\n+            with\n+                End_of_file ->\n+                  ignore (Unix.close_process_in c);\n+                  Buffer.contents b\n+          in\n+            PEXP_str (r ())\n+\n+      | _ ->\n+          raise (err (\"unsupported syntax extension: \" ^ nstr) ps)\n+;;\n+\n+(* \n+ * Desugarings depend on context:\n+ * \n+ *   - If a pexp is used on the RHS of an assignment, it's turned into\n+ *     an initialization statement such as STMT_init_rec or such. This\n+ *     removes the possibility of initializing into a temp only to\n+ *     copy out. If the topmost pexp in such a desugaring is an atom,\n+ *     unop or binop, of course, it will still just emit a STMT_copy\n+ *     on a primitive expression.\n+ * \n+ *   - If a pexp is used in the context where an atom is required, a \n+ *     statement declaring a temporary and initializing it with the \n+ *     result of the pexp is prepended, and the temporary atom is used.\n+ *)\n+\n+let rec desugar_lval (ps:pstate) (pexp:pexp) : (Ast.stmt array * Ast.lval) =\n+  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n+  let (apos, bpos) = (s.lo, s.hi) in\n+    match pexp.node with\n+\n+        PEXP_lval (PLVAL_ident ident) ->\n+          let nb = span ps apos bpos (Ast.BASE_ident ident) in\n+            ([||], Ast.LVAL_base nb)\n+\n+      | PEXP_lval (PLVAL_app (ident, tys)) ->\n+          let nb = span ps apos bpos (Ast.BASE_app (ident, tys)) in\n+            ([||], Ast.LVAL_base nb)\n+\n+      | PEXP_lval (PLVAL_ext_name (base_pexp, comp)) ->\n+          let (base_stmts, base_atom) = desugar_expr_atom ps base_pexp in\n+          let base_lval = atom_lval ps base_atom in\n+            (base_stmts, Ast.LVAL_ext (base_lval, Ast.COMP_named comp))\n+\n+      | PEXP_lval (PLVAL_ext_pexp (base_pexp, ext_pexp)) ->\n+          let (base_stmts, base_atom) = desugar_expr_atom ps base_pexp in\n+          let (ext_stmts, ext_atom) = desugar_expr_atom ps ext_pexp in\n+          let base_lval = atom_lval ps base_atom in\n+            (Array.append base_stmts ext_stmts,\n+             Ast.LVAL_ext (base_lval, Ast.COMP_atom (clone_atom ps ext_atom)))\n+\n+      | _ ->\n+          let (stmts, atom) = desugar_expr_atom ps pexp in\n+            (stmts, atom_lval ps atom)\n+\n+\n+and desugar_expr\n+    (ps:pstate)\n+    (pexp:pexp)\n+    : (Ast.stmt array * Ast.expr) =\n+  match pexp.node with\n+\n+      PEXP_unop (op, pe) ->\n+        let (stmts, at) = desugar_expr_atom ps pe in\n+          (stmts, Ast.EXPR_unary (op, at))\n+\n+    | PEXP_binop (op, lhs, rhs) ->\n+          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n+          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n+            (Array.append lhs_stmts rhs_stmts,\n+             Ast.EXPR_binary (op, lhs_atom, rhs_atom))\n+\n+    | _ ->\n+        let (stmts, at) = desugar_expr_atom ps pexp in\n+          (stmts, Ast.EXPR_atom at)\n+\n+\n+and desugar_opt_expr_atom\n+    (ps:pstate)\n+    (po:pexp option)\n+    : (Ast.stmt array * Ast.atom option) =\n+  match po with\n+      None -> ([| |], None)\n+    | Some pexp ->\n+        let (stmts, atom) = desugar_expr_atom ps pexp in\n+          (stmts, Some atom)\n+\n+\n+and desugar_expr_atom\n+    (ps:pstate)\n+    (pexp:pexp)\n+    : (Ast.stmt array * Ast.atom) =\n+  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n+  let (apos, bpos) = (s.lo, s.hi) in\n+    match pexp.node with\n+\n+        PEXP_unop _\n+      | PEXP_binop _\n+      | PEXP_lazy_or _\n+      | PEXP_lazy_and _\n+      | PEXP_rec _\n+      | PEXP_tup _\n+      | PEXP_str _\n+      | PEXP_vec _\n+      | PEXP_port\n+      | PEXP_chan _\n+      | PEXP_call _\n+      | PEXP_bind _\n+      | PEXP_spawn _ ->\n+          let (_, tmp, decl_stmt) = build_tmp ps slot_auto apos bpos in\n+          let stmts = desugar_expr_init ps tmp pexp in\n+            (Array.append [| decl_stmt |] stmts,\n+             Ast.ATOM_lval (clone_lval ps tmp))\n+\n+      | PEXP_lit lit ->\n+          ([||], Ast.ATOM_literal (span ps apos bpos lit))\n+\n+      | PEXP_lval _ ->\n+          let (stmts, lval) = desugar_lval ps pexp in\n+            (stmts, Ast.ATOM_lval lval)\n+\n+      | PEXP_exterior _ ->\n+          raise (err \"exterior symbol in atom context\" ps)\n+\n+      | PEXP_mutable _ ->\n+          raise (err \"mutable keyword in atom context\" ps)\n+\n+      | PEXP_custom (n, a, b) ->\n+          desugar_expr_atom ps\n+            { pexp with node = expand_pexp_custom ps n a b }\n+\n+\n+and desugar_expr_mode_mut_atom\n+    (ps:pstate)\n+    (pexp:pexp)\n+    : (Ast.stmt array * (Ast.mode * bool * Ast.atom)) =\n+  let desugar_inner mode mut e =\n+    let (stmts, atom) = desugar_expr_atom ps e in\n+      (stmts, (mode, mut, atom))\n+  in\n+    match pexp.node with\n+        PEXP_mutable {node=(PEXP_exterior e); id=_} ->\n+          desugar_inner Ast.MODE_exterior true e\n+      | PEXP_exterior e ->\n+          desugar_inner Ast.MODE_exterior false e\n+      | PEXP_mutable e ->\n+          desugar_inner Ast.MODE_interior true e\n+      | _ ->\n+          desugar_inner Ast.MODE_interior false pexp\n+\n+and desugar_expr_atoms\n+    (ps:pstate)\n+    (pexps:pexp array)\n+    : (Ast.stmt array * Ast.atom array) =\n+  arj1st (Array.map (desugar_expr_atom ps) pexps)\n+\n+and desugar_opt_expr_atoms\n+    (ps:pstate)\n+    (pexps:pexp option array)\n+    : (Ast.stmt array * Ast.atom option array) =\n+  arj1st (Array.map (desugar_opt_expr_atom ps) pexps)\n+\n+and desugar_expr_mode_mut_atoms\n+    (ps:pstate)\n+    (pexps:pexp array)\n+    : (Ast.stmt array * (Ast.mode * bool * Ast.atom) array) =\n+  arj1st (Array.map (desugar_expr_mode_mut_atom ps) pexps)\n+\n+and desugar_expr_init\n+    (ps:pstate)\n+    (dst_lval:Ast.lval)\n+    (pexp:pexp)\n+    : (Ast.stmt array) =\n+  let s = Hashtbl.find ps.pstate_sess.Session.sess_spans pexp.id in\n+  let (apos, bpos) = (s.lo, s.hi) in\n+\n+  (* Helpers. *)\n+  let ss x = span ps apos bpos x in\n+  let cp v = Ast.STMT_copy (clone_lval ps dst_lval, v) in\n+  let aa x y = Array.append x y in\n+  let ac xs = Array.concat xs in\n+\n+    match pexp.node with\n+\n+        PEXP_lit _\n+      | PEXP_lval _ ->\n+          let (stmts, atom) = desugar_expr_atom ps pexp in\n+            aa stmts [| ss (cp (Ast.EXPR_atom atom)) |]\n+\n+      | PEXP_binop (op, lhs, rhs) ->\n+          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n+          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n+          let copy_stmt =\n+            ss (cp (Ast.EXPR_binary (op, lhs_atom, rhs_atom)))\n+          in\n+            ac [ lhs_stmts; rhs_stmts; [| copy_stmt |] ]\n+\n+      (* x = a && b ==> if (a) { x = b; } else { x = false; } *)\n+\n+      | PEXP_lazy_and (lhs, rhs) ->\n+          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n+          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n+          let sthen =\n+            ss (aa rhs_stmts [| ss (cp (Ast.EXPR_atom rhs_atom)) |])\n+          in\n+          let selse =\n+            ss [| ss (cp (Ast.EXPR_atom\n+                            (Ast.ATOM_literal (ss (Ast.LIT_bool false))))) |]\n+          in\n+          let sif =\n+            ss (Ast.STMT_if { Ast.if_test = Ast.EXPR_atom lhs_atom;\n+                              Ast.if_then = sthen;\n+                              Ast.if_else = Some selse })\n+          in\n+            aa lhs_stmts [| sif |]\n+\n+      (* x = a || b ==> if (a) { x = true; } else { x = b; } *)\n+\n+      | PEXP_lazy_or (lhs, rhs) ->\n+          let (lhs_stmts, lhs_atom) = desugar_expr_atom ps lhs in\n+          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n+          let sthen =\n+            ss [| ss (cp (Ast.EXPR_atom\n+                            (Ast.ATOM_literal (ss (Ast.LIT_bool true))))) |]\n+          in\n+          let selse =\n+            ss (aa rhs_stmts [| ss (cp (Ast.EXPR_atom rhs_atom)) |])\n+          in\n+          let sif =\n+            ss (Ast.STMT_if { Ast.if_test = Ast.EXPR_atom lhs_atom;\n+                              Ast.if_then = sthen;\n+                              Ast.if_else = Some selse })\n+          in\n+            aa lhs_stmts [| sif |]\n+\n+\n+      | PEXP_unop (op, rhs) ->\n+          let (rhs_stmts, rhs_atom) = desugar_expr_atom ps rhs in\n+          let expr = Ast.EXPR_unary (op, rhs_atom) in\n+          let copy_stmt = ss (cp expr) in\n+            aa rhs_stmts [| copy_stmt |]\n+\n+      | PEXP_call (fn, args) ->\n+          let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n+          let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n+          let fn_lval = atom_lval ps fn_atom in\n+          let call_stmt = ss (Ast.STMT_call (dst_lval, fn_lval, arg_atoms)) in\n+            ac [ fn_stmts; arg_stmts; [| call_stmt |] ]\n+\n+      | PEXP_bind (fn, args) ->\n+          let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n+          let (arg_stmts, arg_atoms) = desugar_opt_expr_atoms ps args in\n+          let fn_lval = atom_lval ps fn_atom in\n+          let bind_stmt = ss (Ast.STMT_bind (dst_lval, fn_lval, arg_atoms)) in\n+            ac [ fn_stmts; arg_stmts; [| bind_stmt |] ]\n+\n+      | PEXP_spawn (domain, sub) ->\n+          begin\n+            match sub.node with\n+                PEXP_call (fn, args) ->\n+                  let (fn_stmts, fn_atom) = desugar_expr_atom ps fn in\n+                  let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n+                  let fn_lval = atom_lval ps fn_atom in\n+                  let spawn_stmt =\n+                    ss (Ast.STMT_spawn (dst_lval, domain, fn_lval, arg_atoms))\n+                  in\n+                    ac [ fn_stmts; arg_stmts; [| spawn_stmt |] ]\n+              | _ -> raise (err \"non-call spawn\" ps)\n+          end\n+\n+      | PEXP_rec (args, base) ->\n+          let (arg_stmts, entries) =\n+            arj1st\n+              begin\n+                Array.map\n+                  begin\n+                    fun (ident, pexp) ->\n+                      let (stmts, (mode, mut, atom)) =\n+                        desugar_expr_mode_mut_atom ps pexp\n+                      in\n+                        (stmts, (ident, mode, mut, atom))\n+                  end\n+                  args\n+              end\n+          in\n+            begin\n+              match base with\n+                  Some base ->\n+                    let (base_stmts, base_lval) = desugar_lval ps base in\n+                    let rec_stmt =\n+                      ss (Ast.STMT_init_rec\n+                            (dst_lval, entries, Some base_lval))\n+                    in\n+                      ac [ arg_stmts; base_stmts; [| rec_stmt |] ]\n+                | None ->\n+                    let rec_stmt =\n+                      ss (Ast.STMT_init_rec (dst_lval, entries, None))\n+                    in\n+                      aa arg_stmts [| rec_stmt |]\n+            end\n+\n+      | PEXP_tup args ->\n+          let (arg_stmts, arg_mode_atoms) =\n+            desugar_expr_mode_mut_atoms ps args\n+          in\n+          let stmt = ss (Ast.STMT_init_tup (dst_lval, arg_mode_atoms)) in\n+            aa arg_stmts [| stmt |]\n+\n+      | PEXP_str s ->\n+          let stmt = ss (Ast.STMT_init_str (dst_lval, s)) in\n+            [| stmt |]\n+\n+      | PEXP_vec (slot, args) ->\n+          let (arg_stmts, arg_atoms) = desugar_expr_atoms ps args in\n+          let stmt = ss (Ast.STMT_init_vec (dst_lval, slot, arg_atoms)) in\n+            aa arg_stmts [| stmt |]\n+\n+      | PEXP_port ->\n+          [| ss (Ast.STMT_init_port dst_lval) |]\n+\n+      | PEXP_chan pexp_opt ->\n+          let (port_stmts, port_opt) =\n+            match pexp_opt with\n+                None -> ([||], None)\n+              | Some port_pexp ->\n+                  begin\n+                    let (port_stmts, port_atom) =\n+                      desugar_expr_atom ps port_pexp\n+                    in\n+                    let port_lval = atom_lval ps port_atom in\n+                      (port_stmts, Some port_lval)\n+                  end\n+          in\n+          let chan_stmt =\n+            ss\n+              (Ast.STMT_init_chan (dst_lval, port_opt))\n+          in\n+            aa port_stmts [| chan_stmt |]\n+\n+      | PEXP_exterior _ ->\n+          raise (err \"exterior symbol in initialiser context\" ps)\n+\n+      | PEXP_mutable _ ->\n+          raise (err \"mutable keyword in initialiser context\" ps)\n+\n+      | PEXP_custom (n, a, b) ->\n+          desugar_expr_init ps dst_lval\n+            { pexp with node = expand_pexp_custom ps n a b }\n+\n+\n+and atom_lval (ps:pstate) (at:Ast.atom) : Ast.lval =\n+  match at with\n+      Ast.ATOM_lval lv -> lv\n+    | Ast.ATOM_literal _ -> raise (err \"literal where lval expected\" ps)\n+;;\n+\n+\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "636e1ac21790282b18be0b138b0c1d0ab1c20fc2", "filename": "src/boot/fe/token.ml", "status": "added", "additions": 308, "deletions": 0, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Ftoken.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Ffe%2Ftoken.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Ffe%2Ftoken.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,308 @@\n+type token =\n+\n+    (* Expression operator symbols *)\n+    PLUS\n+  | MINUS\n+  | STAR\n+  | SLASH\n+  | PERCENT\n+  | EQ\n+  | LT\n+  | LE\n+  | EQEQ\n+  | NE\n+  | GE\n+  | GT\n+  | NOT\n+  | TILDE\n+  | CARET\n+  | AND\n+  | ANDAND\n+  | OR\n+  | OROR\n+  | LSL\n+  | LSR\n+  | ASR\n+  | OPEQ of token\n+  | AS\n+  | WITH\n+\n+  (* Structural symbols *)\n+  | AT\n+  | DOT\n+  | COMMA\n+  | SEMI\n+  | COLON\n+  | RARROW\n+  | SEND\n+  | LARROW\n+  | LPAREN\n+  | RPAREN\n+  | LBRACKET\n+  | RBRACKET\n+  | LBRACE\n+  | RBRACE\n+\n+  (* Module and crate keywords *)\n+  | MOD\n+  | USE\n+  | AUTH\n+  | META\n+\n+  (* Metaprogramming keywords *)\n+  | SYNTAX\n+  | POUND\n+\n+  (* Statement keywords *)\n+  | IF\n+  | ELSE\n+  | DO\n+  | WHILE\n+  | ALT\n+  | CASE\n+\n+  | FAIL\n+  | DROP\n+\n+  | IN\n+  | FOR\n+  | EACH\n+  | PUT\n+  | RET\n+  | BE\n+\n+  (* Type and type-state keywords *)\n+  | TYPE\n+  | CHECK\n+  | CLAIM\n+  | PROVE\n+\n+  (* Effect keywords *)\n+  | IO\n+  | STATE\n+  | UNSAFE\n+\n+  (* Type qualifiers *)\n+  | NATIVE\n+  | AUTO\n+  | MUTABLE\n+\n+  (* Name management *)\n+  | IMPORT\n+  | EXPORT\n+\n+  (* Value / stmt declarators *)\n+  | LET\n+\n+  (* Magic runtime services *)\n+  | LOG\n+  | SPAWN\n+  | BIND\n+  | THREAD\n+  | YIELD\n+  | JOIN\n+\n+  (* Literals *)\n+  | LIT_INT       of (int64 * string)\n+  | LIT_FLO       of string\n+  | LIT_STR       of string\n+  | LIT_CHAR      of int\n+  | LIT_BOOL      of bool\n+\n+  (* Name components *)\n+  | IDENT         of string\n+  | IDX           of int\n+  | UNDERSCORE\n+\n+  (* Reserved type names *)\n+  | BOOL\n+  | INT\n+  | UINT\n+  | CHAR\n+  | STR\n+  | MACH          of Common.ty_mach\n+\n+  (* Algebraic type constructors *)\n+  | REC\n+  | TUP\n+  | TAG\n+  | VEC\n+  | ANY\n+\n+  (* Callable type constructors *)\n+  | FN\n+  | ITER\n+\n+  (* Object type *)\n+  | OBJ\n+\n+  (* Comm and task types *)\n+  | CHAN\n+  | PORT\n+  | TASK\n+\n+  | EOF\n+\n+  | BRACEQUOTE of string\n+\n+;;\n+\n+let rec string_of_tok t =\n+  match t with\n+      (* Operator symbols (mostly) *)\n+      PLUS       -> \"+\"\n+    | MINUS      -> \"-\"\n+    | STAR       -> \"*\"\n+    | SLASH      -> \"/\"\n+    | PERCENT    -> \"%\"\n+    | EQ         -> \"=\"\n+    | LT         -> \"<\"\n+    | LE         -> \"<=\"\n+    | EQEQ       -> \"==\"\n+    | NE         -> \"!=\"\n+    | GE         -> \">=\"\n+    | GT         -> \">\"\n+    | TILDE      -> \"~\"\n+    | CARET      -> \"^\"\n+    | NOT        -> \"!\"\n+    | AND        -> \"&\"\n+    | ANDAND     -> \"&&\"\n+    | OR         -> \"|\"\n+    | OROR       -> \"||\"\n+    | LSL        -> \"<<\"\n+    | LSR        -> \">>\"\n+    | ASR        -> \">>>\"\n+    | OPEQ op    -> string_of_tok op ^ \"=\"\n+    | AS         -> \"as\"\n+    | WITH       -> \"with\"\n+\n+    (* Structural symbols *)\n+    | AT         -> \"@\"\n+    | DOT        -> \".\"\n+    | COMMA      -> \",\"\n+    | SEMI       -> \";\"\n+    | COLON      -> \":\"\n+    | RARROW     -> \"->\"\n+    | SEND       -> \"<|\"\n+    | LARROW     -> \"<-\"\n+    | LPAREN     -> \"(\"\n+    | RPAREN     -> \")\"\n+    | LBRACKET   -> \"[\"\n+    | RBRACKET   -> \"]\"\n+    | LBRACE     -> \"{\"\n+    | RBRACE     -> \"}\"\n+\n+    (* Module and crate keywords *)\n+    | MOD        -> \"mod\"\n+    | USE        -> \"use\"\n+    | AUTH       -> \"auth\"\n+\n+    (* Metaprogramming keywords *)\n+    | SYNTAX     -> \"syntax\"\n+    | META       -> \"meta\"\n+    | POUND      -> \"#\"\n+\n+    (* Control-flow keywords *)\n+    | IF         -> \"if\"\n+    | ELSE       -> \"else\"\n+    | DO         -> \"do\"\n+    | WHILE      -> \"while\"\n+    | ALT        -> \"alt\"\n+    | CASE       -> \"case\"\n+\n+    | FAIL       -> \"fail\"\n+    | DROP       -> \"drop\"\n+\n+    | IN         -> \"in\"\n+    | FOR        -> \"for\"\n+    | EACH       -> \"each\"\n+    | PUT        -> \"put\"\n+    | RET        -> \"ret\"\n+    | BE         -> \"be\"\n+\n+    (* Type and type-state keywords *)\n+    | TYPE       -> \"type\"\n+    | CHECK      -> \"check\"\n+    | CLAIM      -> \"claim\"\n+    | PROVE      -> \"prove\"\n+\n+    (* Effect keywords *)\n+    | IO         -> \"io\"\n+    | STATE      -> \"state\"\n+    | UNSAFE     -> \"unsafe\"\n+\n+    (* Type qualifiers *)\n+    | NATIVE     -> \"native\"\n+    | AUTO       -> \"auto\"\n+    | MUTABLE    -> \"mutable\"\n+\n+    (* Name management *)\n+    | IMPORT     -> \"import\"\n+    | EXPORT     -> \"export\"\n+\n+    (* Value / stmt declarators. *)\n+    | LET        -> \"let\"\n+\n+    (* Magic runtime services *)\n+    | LOG        -> \"log\"\n+    | SPAWN      -> \"spawn\"\n+    | BIND       -> \"bind\"\n+    | THREAD     -> \"thread\"\n+    | YIELD      -> \"yield\"\n+    | JOIN       -> \"join\"\n+\n+    (* Literals *)\n+    | LIT_INT (_,s)  -> s\n+    | LIT_FLO n  -> n\n+    | LIT_STR s  -> (\"\\\"\" ^ (String.escaped s) ^ \"\\\"\")\n+    | LIT_CHAR c -> (\"'\" ^ (Common.escaped_char c) ^ \"'\")\n+    | LIT_BOOL b -> if b then \"true\" else \"false\"\n+\n+    (* Name components *)\n+    | IDENT s    -> s\n+    | IDX i      -> (\"_\" ^ (string_of_int i))\n+    | UNDERSCORE -> \"_\"\n+\n+    (* Reserved type names *)\n+    | BOOL       -> \"bool\"\n+    | INT        -> \"int\"\n+    | UINT       -> \"uint\"\n+    | CHAR       -> \"char\"\n+    | STR        -> \"str\"\n+    | MACH m     -> Common.string_of_ty_mach m\n+\n+    (* Algebraic type constructors *)\n+    | REC        -> \"rec\"\n+    | TUP        -> \"tup\"\n+    | TAG        -> \"tag\"\n+    | VEC        -> \"vec\"\n+    | ANY        -> \"any\"\n+\n+    (* Callable type constructors *)\n+    | FN         -> \"fn\"\n+    | ITER       -> \"fn\"\n+\n+    (* Object type *)\n+    | OBJ        -> \"obj\"\n+\n+    (* Ports and channels *)\n+    | CHAN          -> \"chan\"\n+    | PORT          -> \"port\"\n+\n+    (* Taskess types *)\n+    | TASK         -> \"task\"\n+\n+    | BRACEQUOTE _ -> \"{...bracequote...}\"\n+\n+    | EOF          -> \"<EOF>\"\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "fd5d92776a62050d523a8cdf224632a0b8492c0a", "filename": "src/boot/llvm/llabi.ml", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllabi.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllabi.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllabi.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,69 @@\n+(*\n+ * LLVM integration with the Rust runtime.\n+ *)\n+\n+type abi = {\n+  crate_ty:   Llvm.lltype;\n+  task_ty:    Llvm.lltype;\n+  word_ty:    Llvm.lltype;\n+  rust_start: Llvm.llvalue;\n+};;\n+\n+let declare_abi (llctx:Llvm.llcontext) (llmod:Llvm.llmodule) : abi =\n+  let i32 = Llvm.i32_type llctx in\n+\n+  let crate_ty =\n+    (* TODO: other architectures besides x86 *)\n+    let crate_opaque_ty = Llvm.opaque_type llctx in\n+    let crate_tyhandle = Llvm.handle_to_type (Llvm.struct_type llctx [|\n+        i32;                              (* ptrdiff_t image_base_off *)\n+        Llvm.pointer_type crate_opaque_ty;(* uintptr_t self_addr *)\n+        i32;                              (* ptrdiff_t debug_abbrev_off *)\n+        i32;                              (* size_t debug_abbrev_sz *)\n+        i32;                              (* ptrdiff_t debug_info_off *)\n+        i32;                              (* size_t debug_info_sz *)\n+        i32;                              (* size_t activate_glue_off *)\n+        i32;                              (* size_t main_exit_task_glue_off *)\n+        i32;                              (* size_t unwind_glue_off *)\n+        i32;                              (* size_t yield_glue_off *)\n+        i32;                              (* int n_rust_syms *)\n+        i32;                              (* int n_c_syms *)\n+        i32                               (* int n_libs *)\n+      |])\n+    in\n+    Llvm.refine_type crate_opaque_ty (Llvm.type_of_handle crate_tyhandle);\n+    Llvm.type_of_handle crate_tyhandle\n+  in\n+  ignore (Llvm.define_type_name \"rust_crate\" crate_ty llmod);\n+\n+  let task_ty =\n+    (* TODO: other architectures besides x86 *)\n+    Llvm.struct_type llctx [|\n+      i32;                    (* size_t refcnt *)\n+      Llvm.pointer_type i32;  (* stk_seg *stk *)\n+      Llvm.pointer_type i32;  (* uintptr_t runtime_sp *)\n+      Llvm.pointer_type i32;  (* uintptr_t rust_sp *)\n+      Llvm.pointer_type i32;  (* rust_rt *rt *)\n+      Llvm.pointer_type i32   (* rust_crate_cache *cache *)\n+    |]\n+  in\n+  ignore (Llvm.define_type_name \"rust_task\" task_ty llmod);\n+\n+  let rust_start_ty =\n+    let task_ptr_ty = Llvm.pointer_type task_ty in\n+    let llnilty = Llvm.array_type (Llvm.i1_type llctx) 0 in\n+    let main_ty = Llvm.function_type (Llvm.void_type llctx)\n+      [| Llvm.pointer_type llnilty; task_ptr_ty; |]\n+    in\n+    let args_ty = Array.map Llvm.pointer_type [| main_ty; crate_ty; |] in\n+    let args_ty = Array.append args_ty [| i32; i32 |] in\n+      Llvm.function_type i32 args_ty\n+  in\n+  {\n+    crate_ty = crate_ty;\n+    task_ty = task_ty;\n+    word_ty = i32;\n+    rust_start = Llvm.declare_function \"rust_start\" rust_start_ty llmod\n+  }\n+;;\n+"}, {"sha": "56448b079020086efbf28774e2febf427b172980", "filename": "src/boot/llvm/llasm.ml", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllasm.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllasm.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllasm.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,192 @@\n+(*\n+ * machine-specific assembler routines.\n+ *)\n+\n+open Common;;\n+\n+type asm_glue =\n+    {\n+      asm_activate_glue : Llvm.llvalue;\n+      asm_yield_glue : Llvm.llvalue;\n+      asm_upcall_glues : Llvm.llvalue array;\n+    }\n+;;\n+\n+let n_upcall_glues = 7\n+;;\n+\n+(* x86-specific asm. *)\n+\n+let x86_glue\n+  (llctx:Llvm.llcontext)\n+  (llmod:Llvm.llmodule)\n+  (abi:Llabi.abi)\n+  (sess:Session.sess)\n+  : asm_glue =\n+  let (prefix,align) =\n+    match sess.Session.sess_targ with\n+        Linux_x86_elf\n+      | Win32_x86_pe -> (\"\",4)\n+      | MacOS_x86_macho -> (\"_\", 16)\n+  in\n+  let save_callee_saves =\n+    [\"pushl %ebp\";\n+     \"pushl %edi\";\n+     \"pushl %esi\";\n+     \"pushl %ebx\";]\n+  in\n+  let restore_callee_saves =\n+    [\"popl  %ebx\";\n+     \"popl  %esi\";\n+     \"popl  %edi\";\n+     \"popl  %ebp\";]\n+  in\n+  let load_esp_from_rust_sp    = [\"movl  12(%edx), %esp\"] in\n+  let load_esp_from_runtime_sp = [\"movl   8(%edx), %esp\"] in\n+  let store_esp_to_rust_sp     = [\"movl  %esp, 12(%edx)\"] in\n+  let store_esp_to_runtime_sp  = [\"movl  %esp,  8(%edx)\"] in\n+  let list_init i f = (Array.to_list (Array.init i f)) in\n+  let list_init_concat i f = List.concat (list_init i f) in\n+\n+  let glue =\n+    [\n+      (\"rust_activate_glue\",\n+       String.concat \"\\n\\t\"\n+         ([\"movl  4(%esp), %edx    # edx = rust_task\"]\n+          @ save_callee_saves\n+          @ store_esp_to_runtime_sp\n+          @ load_esp_from_rust_sp\n+            (* \n+             * This 'add' instruction is a bit surprising.\n+             * See lengthy comment in boot/be/x86.ml activate_glue.\n+             *)\n+          @ [\"addl  $20, 12(%edx)\"]\n+          @ restore_callee_saves\n+          @ [\"ret\"]));\n+\n+      (\"rust_yield_glue\",\n+       String.concat \"\\n\\t\"\n+\n+         ([\"movl  0(%esp), %edx    # edx = rust_task\"]\n+          @ load_esp_from_rust_sp\n+          @ save_callee_saves\n+          @ store_esp_to_rust_sp\n+          @ load_esp_from_runtime_sp\n+          @ restore_callee_saves\n+          @ [\"ret\"]))\n+    ]\n+    @ list_init n_upcall_glues\n+      begin\n+        fun i ->\n+          (* \n+           * 0, 4, 8, 12 are callee-saves\n+           * 16 is retpc\n+           * 20 is taskptr\n+           * 24 is callee\n+           * 28 .. (7+i) * 4 are args\n+           *)\n+\n+          ((Printf.sprintf \"rust_upcall_%d\" i),\n+           String.concat \"\\n\\t\"\n+             (save_callee_saves\n+              @ [\"movl  %esp, %ebp     # ebp = rust_sp\";\n+                 \"movl  20(%esp), %edx # edx = rust_task\"]\n+              @ store_esp_to_rust_sp\n+              @ load_esp_from_runtime_sp\n+              @ [Printf.sprintf\n+                   \"subl  $%d, %%esp   # esp -= args\" ((i+1)*4);\n+                 \"andl  $~0xf, %esp    # align esp down\";\n+                 \"movl  %edx, (%esp)   # arg[0] = rust_task \"]\n+\n+              @ (list_init_concat i\n+                   begin\n+                     fun j ->\n+                       [ Printf.sprintf \"movl  %d(%%ebp),%%edx\" ((j+7)*4);\n+                         Printf.sprintf \"movl  %%edx,%d(%%esp)\" ((j+1)*4) ]\n+                   end)\n+\n+              @ [\"movl  24(%ebp), %edx # edx = callee\";\n+                 \"call  *%edx          # call *%edx\";\n+                 \"movl  20(%ebp), %edx # edx = rust_task\"]\n+              @ load_esp_from_rust_sp\n+              @ restore_callee_saves\n+              @ [\"ret\"]))\n+      end\n+  in\n+\n+  let _ =\n+    Llvm.set_module_inline_asm llmod\n+      begin\n+        String.concat \"\\n\"\n+          begin\n+            List.map\n+              begin\n+                fun (sym,asm) ->\n+                  Printf.sprintf\n+                    \"\\t.globl %s%s\\n\\t.balign %d\\n%s%s:\\n\\t%s\"\n+                    prefix sym align prefix sym asm\n+              end\n+              glue\n+          end\n+      end\n+  in\n+\n+  let decl_cdecl_fn name out_ty arg_tys =\n+    let ty = Llvm.function_type out_ty arg_tys in\n+    let fn = Llvm.declare_function name ty llmod in\n+      Llvm.set_function_call_conv Llvm.CallConv.c fn;\n+      fn\n+  in\n+\n+  let decl_glue s =\n+    let task_ptr_ty = Llvm.pointer_type abi.Llabi.task_ty in\n+    let void_ty = Llvm.void_type llctx in\n+      decl_cdecl_fn s void_ty [| task_ptr_ty |]\n+  in\n+\n+  let decl_upcall n =\n+    let task_ptr_ty = Llvm.pointer_type abi.Llabi.task_ty in\n+    let word_ty = abi.Llabi.word_ty in\n+    let callee_ty = word_ty in\n+    let args_ty =\n+      Array.append\n+        [| task_ptr_ty; callee_ty |]\n+        (Array.init n (fun _ -> word_ty))\n+    in\n+    let name = Printf.sprintf \"rust_upcall_%d\" n in\n+      decl_cdecl_fn name word_ty args_ty\n+  in\n+    {\n+      asm_activate_glue = decl_glue \"rust_activate_glue\";\n+      asm_yield_glue = decl_glue \"rust_yield_glue\";\n+      asm_upcall_glues = Array.init n_upcall_glues decl_upcall;\n+    }\n+;;\n+\n+(* x64-specific asm. *)\n+(* arm-specific asm. *)\n+(* ... *)\n+\n+\n+let get_glue\n+  (llctx:Llvm.llcontext)\n+  (llmod:Llvm.llmodule)\n+  (abi:Llabi.abi)\n+  (sess:Session.sess)\n+  : asm_glue =\n+  match sess.Session.sess_targ with\n+      Linux_x86_elf\n+    | Win32_x86_pe\n+    | MacOS_x86_macho ->\n+        x86_glue llctx llmod abi sess\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "2b229fde12e5c70f394498c0ebb0c6dd249ace34", "filename": "src/boot/llvm/llemit.ml", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllemit.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllemit.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllemit.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,36 @@\n+(*\n+ * LLVM emitter.\n+ *)\n+\n+(* The top-level interface to the LLVM translation subsystem. *)\n+let trans_and_process_crate\n+    (sess:Session.sess)\n+    (sem_cx:Semant.ctxt)\n+    (crate:Ast.crate)\n+    : unit =\n+  let llcontext = Llvm.create_context () in\n+  let emit_file (llmod:Llvm.llmodule) : unit =\n+    let filename = Session.filename_of sess.Session.sess_out in\n+    if not (Llvm_bitwriter.write_bitcode_file llmod filename)\n+    then raise (Failure (\"failed to write the LLVM bitcode '\" ^ filename\n+      ^ \"'\"))\n+  in\n+  let llmod = Lltrans.trans_crate sem_cx llcontext sess crate in\n+  begin\n+    try\n+      emit_file llmod\n+    with e -> Llvm.dispose_module llmod; raise e\n+  end;\n+  Llvm.dispose_module llmod;\n+  Llvm.dispose_context llcontext\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)\n+"}, {"sha": "64ea3d37a1e6c4daaeea7ed1240b4e8b6011653c", "filename": "src/boot/llvm/llfinal.ml", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllfinal.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Fllfinal.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Fllfinal.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,96 @@\n+(*\n+ * LLVM ABI-level stuff that needs to happen after modules have been\n+ * translated.\n+ *)\n+\n+let finalize_module\n+    (llctx:Llvm.llcontext)\n+    (llmod:Llvm.llmodule)\n+    (abi:Llabi.abi)\n+    (asm_glue:Llasm.asm_glue)\n+    (exit_task_glue:Llvm.llvalue)\n+    (crate_ptr:Llvm.llvalue)\n+    : unit =\n+  let i32 = Llvm.i32_type llctx in\n+\n+  (*\n+   * Count the number of Rust functions and the number of C functions by\n+   * simply (and crudely) testing whether each function in the module begins\n+   * with \"_rust_\".\n+   *)\n+\n+  let (rust_fn_count, c_fn_count) =\n+    let count (rust_fn_count, c_fn_count) fn =\n+      let begins_with prefix str =\n+        let (str_len, prefix_len) =\n+          (String.length str, String.length prefix)\n+        in\n+        prefix_len <= str_len && (String.sub str 0 prefix_len) = prefix\n+      in\n+      if begins_with \"_rust_\" (Llvm.value_name fn) then\n+        (rust_fn_count + 1, c_fn_count)\n+      else\n+        (rust_fn_count, c_fn_count + 1)\n+    in\n+    Llvm.fold_left_functions count (0, 0) llmod\n+  in\n+\n+  let crate_val =\n+    let crate_addr = Llvm.const_ptrtoint crate_ptr i32 in\n+    let glue_off glue =\n+      let addr = Llvm.const_ptrtoint glue i32 in\n+        Llvm.const_sub addr crate_addr\n+    in\n+    let activate_glue_off = glue_off asm_glue.Llasm.asm_activate_glue in\n+    let yield_glue_off = glue_off asm_glue.Llasm.asm_yield_glue in\n+    let exit_task_glue_off = glue_off exit_task_glue in\n+\n+    Llvm.const_struct llctx [|\n+      Llvm.const_int i32 0;             (* ptrdiff_t image_base_off *)\n+      crate_ptr;                        (* uintptr_t self_addr *)\n+      Llvm.const_int i32 0;             (* ptrdiff_t debug_abbrev_off *)\n+      Llvm.const_int i32 0;             (* size_t debug_abbrev_sz *)\n+      Llvm.const_int i32 0;             (* ptrdiff_t debug_info_off *)\n+      Llvm.const_int i32 0;             (* size_t debug_info_sz *)\n+      activate_glue_off;                (* size_t activate_glue_off *)\n+      exit_task_glue_off;               (* size_t main_exit_task_glue_off *)\n+      Llvm.const_int i32 0;             (* size_t unwind_glue_off *)\n+      yield_glue_off;                   (* size_t yield_glue_off *)\n+      Llvm.const_int i32 rust_fn_count; (* int n_rust_syms *)\n+      Llvm.const_int i32 c_fn_count;    (* int n_c_syms *)\n+      Llvm.const_int i32 0              (* int n_libs *)\n+    |]\n+  in\n+\n+  Llvm.set_initializer crate_val crate_ptr;\n+\n+  (* Define the main function for crt0 to call. *)\n+  let main_fn =\n+    let main_ty = Llvm.function_type i32 [| i32; i32 |] in\n+    Llvm.define_function \"main\" main_ty llmod\n+  in\n+  let argc = Llvm.param main_fn 0 in\n+  let argv = Llvm.param main_fn 1 in\n+  let main_builder = Llvm.builder_at_end llctx (Llvm.entry_block main_fn) in\n+  let rust_main_fn =\n+    match Llvm.lookup_function \"_rust_main\" llmod with\n+        None -> raise (Failure \"no main function found\")\n+      | Some fn -> fn\n+  in\n+  let rust_start = abi.Llabi.rust_start in\n+  let rust_start_args = [| rust_main_fn; crate_ptr; argc; argv |] in\n+    ignore (Llvm.build_call\n+              rust_start rust_start_args \"start_rust\" main_builder);\n+    ignore (Llvm.build_ret (Llvm.const_int i32 0) main_builder)\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)\n+"}, {"sha": "7f985d2592785542030d0d15aa5b6b4333817b4b", "filename": "src/boot/llvm/lltrans.ml", "status": "added", "additions": 938, "deletions": 0, "changes": 938, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Flltrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fllvm%2Flltrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fllvm%2Flltrans.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,938 @@\n+(*\n+ * LLVM translator.\n+ *)\n+\n+open Common;;\n+open Transutil;;\n+\n+let log cx = Session.log \"trans\"\n+  cx.Semant.ctxt_sess.Session.sess_log_trans\n+  cx.Semant.ctxt_sess.Session.sess_log_out\n+;;\n+\n+let trans_crate\n+    (sem_cx:Semant.ctxt)\n+    (llctx:Llvm.llcontext)\n+    (sess:Session.sess)\n+    (crate:Ast.crate)\n+    : Llvm.llmodule =\n+\n+  let iflog thunk =\n+    if sess.Session.sess_log_trans\n+    then thunk ()\n+    else ()\n+  in\n+\n+  (* Helpers for adding metadata. *)\n+  let (dbg_mdkind:int) = Llvm.mdkind_id llctx \"dbg\" in\n+  let set_dbg_metadata (inst:Llvm.llvalue) (md:Llvm.llvalue) : unit =\n+    Llvm.set_metadata inst dbg_mdkind md\n+  in\n+  let md_str (s:string) : Llvm.llvalue = Llvm.mdstring llctx s in\n+  let md_node (vals:Llvm.llvalue array) : Llvm.llvalue =\n+    Llvm.mdnode llctx vals\n+  in\n+  let const_i32 (i:int) : Llvm.llvalue =\n+    Llvm.const_int (Llvm.i32_type llctx) i\n+  in\n+  let const_i1 (i:int) : Llvm.llvalue =\n+    Llvm.const_int (Llvm.i1_type llctx) i\n+  in\n+  let llvm_debug_version : int = 0x8 lsl 16 in\n+  let const_dw_tag (tag:Dwarf.dw_tag) : Llvm.llvalue =\n+    const_i32 (llvm_debug_version lor (Dwarf.dw_tag_to_int tag))\n+  in\n+\n+  (* Translation of our node_ids into LLVM identifiers, which are strings. *)\n+  let next_anon_llid = ref 0 in\n+  let num_llid num klass = Printf.sprintf \"%s%d\" klass num in\n+  let anon_llid klass =\n+    let llid = num_llid !next_anon_llid klass in\n+    next_anon_llid := !next_anon_llid + 1;\n+    llid\n+  in\n+  let node_llid (node_id_opt:node_id option) : (string -> string) =\n+    match node_id_opt with\n+        None -> anon_llid\n+      | Some (Node num) -> num_llid num\n+  in\n+\n+  (*\n+   * Returns a bogus value for use in stub code that hasn't been implemented\n+   * yet.\n+   *\n+   * TODO: On some joyous day, remove me.\n+   *)\n+  let bogus = Llvm.const_null (Llvm.i32_type llctx) in\n+  let bogus_ptr = Llvm.const_null (Llvm.pointer_type (Llvm.i32_type llctx)) in\n+\n+  let llnilty = Llvm.array_type (Llvm.i1_type llctx) 0 in\n+  let llnil = Llvm.const_array (Llvm.i1_type llctx) [| |] in\n+\n+  let ty_of_item = Hashtbl.find sem_cx.Semant.ctxt_all_item_types in\n+  let ty_of_slot n = Semant.slot_ty (Semant.get_slot sem_cx n) in\n+\n+  let filename = Session.filename_of sess.Session.sess_in in\n+  let llmod = Llvm.create_module llctx filename in\n+\n+  let (abi:Llabi.abi) = Llabi.declare_abi llctx llmod in\n+  let (crate_ptr:Llvm.llvalue) =\n+    Llvm.declare_global abi.Llabi.crate_ty \"rust_crate\" llmod\n+  in\n+\n+  let (void_ty:Llvm.lltype) = Llvm.void_type llctx in\n+  let (word_ty:Llvm.lltype) = abi.Llabi.word_ty in\n+  let (wordptr_ty:Llvm.lltype) = Llvm.pointer_type word_ty in\n+  let (task_ty:Llvm.lltype) = abi.Llabi.task_ty in\n+  let (task_ptr_ty:Llvm.lltype) = Llvm.pointer_type task_ty in\n+  let fn_ty (out:Llvm.lltype) (args:Llvm.lltype array) : Llvm.lltype =\n+    Llvm.function_type out args\n+  in\n+\n+  let imm (i:int64) : Llvm.llvalue =\n+    Llvm.const_int word_ty (Int64.to_int i)\n+  in\n+\n+  let asm_glue = Llasm.get_glue llctx llmod abi sess in\n+\n+  let llty_str llty =\n+    Llvm.string_of_lltype llty\n+  in\n+\n+  let llval_str llv =\n+    let ts = llty_str (Llvm.type_of llv) in\n+      match Llvm.value_name llv with\n+          \"\" ->\n+            Printf.sprintf \"<anon=%s>\" ts\n+        | s -> Printf.sprintf \"<%s=%s>\" s ts\n+  in\n+\n+  let llvals_str llvals =\n+    (String.concat \", \"\n+       (Array.to_list\n+          (Array.map llval_str llvals)))\n+  in\n+\n+  let build_call callee args rvid builder =\n+    iflog\n+      begin\n+        fun _ ->\n+          let name = Llvm.value_name callee in\n+          log sem_cx \"build_call: %s(%s)\" name (llvals_str args);\n+          log sem_cx \"build_call: typeof(%s) = %s\"\n+            name (llty_str (Llvm.type_of callee))\n+      end;\n+    Llvm.build_call callee args rvid builder\n+  in\n+\n+  (* Upcall translation *)\n+\n+  let extern_upcalls = Hashtbl.create 0 in\n+  let trans_upcall\n+      (llbuilder:Llvm.llbuilder)\n+      (lltask:Llvm.llvalue)\n+      (name:string)\n+      (lldest:Llvm.llvalue option)\n+      (llargs:Llvm.llvalue array) =\n+    let n = Array.length llargs in\n+    let llglue = asm_glue.Llasm.asm_upcall_glues.(n) in\n+    let llupcall = htab_search_or_add extern_upcalls name\n+      begin\n+        fun _ ->\n+          let args_ty =\n+            Array.append\n+              [| task_ptr_ty |]\n+              (Array.init n (fun i -> Llvm.type_of llargs.(i)))\n+          in\n+          let out_ty = match lldest with\n+              None -> void_ty\n+            | Some v -> Llvm.type_of v\n+          in\n+          let fty = fn_ty out_ty args_ty in\n+            (* \n+             * NB: At this point it actually doesn't matter what type\n+             * we gave the upcall function, as we're just going to\n+             * pointercast it to a word and pass it to the upcall-glue\n+             * for now. But possibly in the future it might matter if\n+             * we develop a proper upcall calling convention.\n+             *)\n+            Llvm.declare_function name fty llmod\n+      end\n+    in\n+      (* Cast everything to plain words so we can hand off to the glue. *)\n+    let llupcall = Llvm.const_pointercast llupcall word_ty in\n+    let llargs =\n+      Array.map\n+        (fun arg ->\n+           Llvm.build_pointercast arg word_ty\n+             (anon_llid \"arg\") llbuilder)\n+        llargs\n+    in\n+    let llallargs = Array.append [| lltask; llupcall |] llargs in\n+    let llid = anon_llid \"rv\" in\n+    let llrv = build_call llglue llallargs llid llbuilder in\n+      Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n+      match lldest with\n+          None -> ()\n+        | Some lldest ->\n+            let lldest =\n+              Llvm.build_pointercast lldest wordptr_ty \"\" llbuilder\n+            in\n+              ignore (Llvm.build_store llrv lldest llbuilder);\n+  in\n+\n+  let upcall\n+      (llbuilder:Llvm.llbuilder)\n+      (lltask:Llvm.llvalue)\n+      (name:string)\n+      (lldest:Llvm.llvalue option)\n+      (llargs:Llvm.llvalue array)\n+      : unit =\n+    trans_upcall llbuilder lltask name lldest llargs\n+  in\n+\n+  let trans_free\n+      (llbuilder:Llvm.llbuilder)\n+      (lltask:Llvm.llvalue)\n+      (src:Llvm.llvalue)\n+      : unit =\n+    upcall llbuilder lltask \"upcall_free\" None [| src |]\n+  in\n+\n+  (*\n+   * let trans_malloc (llbuilder:Llvm.llbuilder)\n+   *                  (dst:Llvm.llvalue) (nbytes:int64) : unit =\n+   *   upcall llbuilder \"upcall_malloc\" (Some dst) [| imm nbytes |]\n+   * in\n+   *)\n+\n+  (* Type translation *)\n+\n+  let lltys = Hashtbl.create 0 in\n+\n+  let trans_mach_ty (mty:ty_mach) : Llvm.lltype =\n+    let tycon =\n+      match mty with\n+          TY_u8 | TY_i8 -> Llvm.i8_type\n+        | TY_u16 | TY_i16 -> Llvm.i16_type\n+        | TY_u32 | TY_i32 -> Llvm.i32_type\n+        | TY_u64 | TY_i64 -> Llvm.i64_type\n+        | TY_f32 -> Llvm.float_type\n+        | TY_f64 -> Llvm.double_type\n+    in\n+      tycon llctx\n+  in\n+\n+\n+  let rec trans_ty_full (ty:Ast.ty) : Llvm.lltype =\n+    let p t = Llvm.pointer_type t in\n+    let s ts = Llvm.struct_type llctx ts in\n+    let opaque _ = Llvm.opaque_type llctx in\n+    let vec_body_ty _ =\n+      s [| word_ty; word_ty; word_ty; (opaque()) |]\n+    in\n+    let rc_opaque_ty =\n+      s [| word_ty; (opaque()) |]\n+    in\n+    match ty with\n+        Ast.TY_any -> opaque ()\n+      | Ast.TY_nil -> llnilty\n+      | Ast.TY_bool -> Llvm.i1_type llctx\n+      | Ast.TY_mach mty -> trans_mach_ty mty\n+      | Ast.TY_int -> word_ty\n+      | Ast.TY_uint -> word_ty\n+      | Ast.TY_char -> Llvm.i32_type llctx\n+      | Ast.TY_vec _\n+      | Ast.TY_str -> p (vec_body_ty())\n+\n+      | Ast.TY_fn tfn ->\n+          let (tsig, _) = tfn in\n+          let lloutptr = p (trans_slot None tsig.Ast.sig_output_slot) in\n+          let lltaskty = p abi.Llabi.task_ty in\n+          let llins = Array.map (trans_slot None) tsig.Ast.sig_input_slots in\n+            fn_ty void_ty (Array.append [| lloutptr; lltaskty |] llins)\n+\n+      | Ast.TY_tup slots ->\n+          s (Array.map (trans_slot None) slots)\n+\n+      | Ast.TY_rec entries ->\n+          s (Array.map (fun e -> trans_slot None (snd e)) entries)\n+\n+      | Ast.TY_constrained (ty', _) -> trans_ty ty'\n+\n+      | Ast.TY_chan _ | Ast.TY_port _ | Ast.TY_task  ->\n+          p rc_opaque_ty\n+\n+      | Ast.TY_native _ ->\n+          word_ty\n+\n+      | Ast.TY_tag _ | Ast.TY_iso _ | Ast.TY_idx _\n+      | Ast.TY_obj _ | Ast.TY_type -> (opaque()) (* TODO *)\n+\n+      | Ast.TY_param _ | Ast.TY_named _ ->\n+          bug () \"unresolved type in lltrans\"\n+\n+  and trans_ty t =\n+    htab_search_or_add lltys t (fun _ -> trans_ty_full t)\n+\n+  (* Translates the type of a slot into the corresponding LLVM type. If the\n+   * id_opt parameter is specified, then the type will be fetched from the\n+   * context. *)\n+  and trans_slot (id_opt:node_id option) (slot:Ast.slot) : Llvm.lltype =\n+    let ty =\n+      match id_opt with\n+          Some id -> ty_of_slot id\n+        | None -> Semant.slot_ty slot\n+    in\n+    let base_llty = trans_ty ty in\n+      match slot.Ast.slot_mode with\n+          Ast.MODE_exterior _\n+        | Ast.MODE_alias _ ->\n+            Llvm.pointer_type base_llty\n+        | Ast.MODE_interior _ -> base_llty\n+  in\n+\n+  let get_element_ptr\n+      (llbuilder:Llvm.llbuilder)\n+      (ptr:Llvm.llvalue)\n+      (i:int)\n+      : Llvm.llvalue =\n+    (* \n+     * GEP takes a first-index of zero. Because it must! And this is\n+     * sufficiently surprising that the GEP FAQ exists. And you must\n+     * read it.\n+     *)\n+    let deref_ptr = Llvm.const_int (Llvm.i32_type llctx) 0 in\n+    let idx = Llvm.const_int (Llvm.i32_type llctx) i in\n+      Llvm.build_gep ptr [| deref_ptr; idx |] (anon_llid \"gep\") llbuilder\n+  in\n+\n+  let free_ty\n+      (llbuilder:Llvm.llbuilder)\n+      (lltask:Llvm.llvalue)\n+      (ty:Ast.ty)\n+      (ptr:Llvm.llvalue)\n+      : unit =\n+    match ty with\n+        Ast.TY_port _\n+      | Ast.TY_chan _\n+      | Ast.TY_task -> bug () \"unimplemented ty in Lltrans.free_ty\"\n+      | _ -> trans_free llbuilder lltask ptr\n+  in\n+\n+  let rec iter_ty_slots_full\n+      (llbuilder:Llvm.llbuilder ref)\n+      (ty:Ast.ty)\n+      (dst_ptr:Llvm.llvalue)\n+      (src_ptr:Llvm.llvalue)\n+      (f:(Llvm.llvalue\n+          -> Llvm.llvalue\n+            -> Ast.slot\n+              -> (Ast.ty_iso option)\n+                -> unit))\n+      (curr_iso:Ast.ty_iso option)\n+      : unit =\n+\n+    (* NB: must deref llbuilder at call-time; don't curry this. *)\n+    let gep p i = get_element_ptr (!llbuilder) p i in\n+\n+    match ty with\n+        Ast.TY_rec entries ->\n+          iter_rec_slots gep dst_ptr src_ptr entries f curr_iso\n+\n+      | Ast.TY_tup slots ->\n+          iter_tup_slots gep dst_ptr src_ptr slots f curr_iso\n+\n+      | Ast.TY_tag _\n+      | Ast.TY_iso _\n+      | Ast.TY_fn _\n+      | Ast.TY_obj _ ->\n+          bug () \"unimplemented ty in Lltrans.iter_ty_slots_full\"\n+\n+      | _ -> ()\n+\n+  and iter_ty_slots\n+      (llbuilder:Llvm.llbuilder ref)\n+      (ty:Ast.ty)\n+      (ptr:Llvm.llvalue)\n+      (f:Llvm.llvalue -> Ast.slot -> (Ast.ty_iso option) -> unit)\n+      (curr_iso:Ast.ty_iso option)\n+      : unit =\n+    iter_ty_slots_full llbuilder ty ptr ptr\n+      (fun _ src_ptr slot curr_iso -> f src_ptr slot curr_iso)\n+      curr_iso\n+\n+  and drop_ty\n+      (llbuilder:Llvm.llbuilder ref)\n+      (lltask:Llvm.llvalue)\n+      (ty:Ast.ty)\n+      (ptr:Llvm.llvalue)\n+      (curr_iso:Ast.ty_iso option)\n+      : unit =\n+    iter_ty_slots llbuilder ty ptr (drop_slot llbuilder lltask) curr_iso\n+\n+  and drop_slot\n+      (llbuilder:Llvm.llbuilder ref)\n+      (lltask:Llvm.llvalue)\n+      (slot_ptr:Llvm.llvalue)\n+      (slot:Ast.slot)\n+      (curr_iso:Ast.ty_iso option)\n+      : unit =\n+\n+    let llfn = Llvm.block_parent (Llvm.insertion_block (!llbuilder)) in\n+    let llty = trans_slot None slot in\n+    let ty = Semant.slot_ty slot in\n+\n+    let new_block klass =\n+      let llblock = Llvm.append_block llctx (anon_llid klass) llfn in\n+      let llbuilder = Llvm.builder_at_end llctx llblock in\n+        (llblock, llbuilder)\n+    in\n+\n+    let if_ptr_in_slot_not_null\n+        (inner:Llvm.llvalue -> Llvm.llbuilder -> Llvm.llbuilder)\n+        (llbuilder:Llvm.llbuilder)\n+        : Llvm.llbuilder =\n+      let ptr = Llvm.build_load slot_ptr (anon_llid \"tmp\") llbuilder in\n+      let null = Llvm.const_pointer_null llty in\n+      let test =\n+        Llvm.build_icmp Llvm.Icmp.Ne null ptr (anon_llid \"nullp\") llbuilder\n+      in\n+      let (llthen, llthen_builder) = new_block \"then\" in\n+      let (llnext, llnext_builder) = new_block \"next\" in\n+        ignore (Llvm.build_cond_br test llthen llnext llbuilder);\n+        let llthen_builder = inner ptr llthen_builder in\n+          ignore (Llvm.build_br llnext llthen_builder);\n+          llnext_builder\n+    in\n+\n+    let decr_refcnt_and_if_zero\n+        (rc_elt:int)\n+        (inner:Llvm.llvalue -> Llvm.llbuilder -> Llvm.llbuilder)\n+        (ptr:Llvm.llvalue)\n+        (llbuilder:Llvm.llbuilder)\n+        : Llvm.llbuilder  =\n+      let rc_ptr = get_element_ptr llbuilder ptr rc_elt in\n+      let rc = Llvm.build_load rc_ptr (anon_llid \"rc\") llbuilder in\n+      let rc = Llvm.build_sub rc (imm 1L) (anon_llid \"tmp\") llbuilder in\n+      let _ = Llvm.build_store rc rc_ptr llbuilder in\n+        log sem_cx \"rc type: %s\" (llval_str rc);\n+      let test =\n+        Llvm.build_icmp Llvm.Icmp.Eq\n+          rc (imm 0L) (anon_llid \"zerop\") llbuilder\n+      in\n+      let (llthen, llthen_builder) = new_block \"then\" in\n+      let (llnext, llnext_builder) = new_block \"next\" in\n+        ignore (Llvm.build_cond_br test llthen llnext llbuilder);\n+        let llthen_builder = inner ptr llthen_builder in\n+          ignore (Llvm.build_br llnext llthen_builder);\n+          llnext_builder\n+    in\n+\n+    let free_and_null_out_slot\n+        (ptr:Llvm.llvalue)\n+        (llbuilder:Llvm.llbuilder)\n+        : Llvm.llbuilder =\n+      free_ty llbuilder lltask ty ptr;\n+      let null = Llvm.const_pointer_null llty in\n+        ignore (Llvm.build_store null slot_ptr llbuilder);\n+        llbuilder\n+    in\n+\n+      begin\n+          match slot_mem_ctrl slot with\n+              MEM_rc_struct\n+            | MEM_gc ->\n+                llbuilder :=\n+                  if_ptr_in_slot_not_null\n+                    (decr_refcnt_and_if_zero\n+                       Abi.exterior_rc_slot_field_refcnt\n+                       free_and_null_out_slot)\n+                    (!llbuilder)\n+\n+            | MEM_rc_opaque ->\n+                llbuilder :=\n+                  if_ptr_in_slot_not_null\n+                    (decr_refcnt_and_if_zero\n+                       Abi.exterior_rc_slot_field_refcnt\n+                       free_and_null_out_slot)\n+                    (!llbuilder)\n+\n+            | MEM_interior when Semant.type_is_structured ty ->\n+                (* FIXME: to handle recursive types, need to call drop\n+                   glue here, not inline. *)\n+                drop_ty llbuilder lltask ty slot_ptr curr_iso\n+\n+            | _ -> ()\n+        end\n+  in\n+\n+  let (llitems:(node_id, Llvm.llvalue) Hashtbl.t) = Hashtbl.create 0 in\n+  let declare_mod_item\n+      (name:Ast.ident)\n+      { node = { Ast.decl_item = (item:Ast.mod_item') }; id = id }\n+      : unit =\n+    let full_name = Semant.item_str sem_cx id in\n+    let line_num =\n+      match Session.get_span sess id with\n+          None -> 0\n+        | Some span ->\n+            let (_, line, _) = span.lo in\n+              line\n+    in\n+      match item with\n+          Ast.MOD_ITEM_fn _ ->\n+            let llty = trans_ty (ty_of_item id) in\n+            let llfn = Llvm.declare_function (\"_rust_\" ^ name) llty llmod in\n+            let meta =\n+              md_node\n+                [|\n+                  const_dw_tag Dwarf.DW_TAG_subprogram;\n+                  const_i32 0; (* unused *)\n+                  const_i32 0; (* context metadata llvalue *)\n+                  md_str name;\n+                  md_str full_name;\n+                  md_str full_name;\n+                  const_i32 0; (* file metadata llvalue *)\n+                  const_i32 line_num;\n+                  const_i32 0; (* type descriptor metadata llvalue *)\n+                  const_i1 1;  (* flag: local to compile unit? *)\n+                  const_i1 1;  (* flag: defined in compile unit? *)\n+                |]\n+            in\n+              Llvm.set_function_call_conv Llvm.CallConv.c llfn;\n+              Hashtbl.add llitems id llfn;\n+\n+              (* FIXME: Adding metadata does not work yet. . *)\n+              let _ = fun _ -> set_dbg_metadata llfn meta in\n+                ()\n+\n+        | _ -> () (* TODO *)\n+  in\n+\n+  let trans_fn\n+      ({\n+        Ast.fn_input_slots = (header_slots:Ast.header_slots);\n+        Ast.fn_body = (body:Ast.block)\n+      }:Ast.fn)\n+      (fn_id:node_id)\n+      : unit =\n+    let llfn = Hashtbl.find llitems fn_id in\n+    let lloutptr = Llvm.param llfn 0 in\n+    let lltask = Llvm.param llfn 1 in\n+\n+    (* LLVM requires that functions be grouped into basic blocks terminated by\n+     * terminator instructions, while our AST is less strict. So we have to do\n+     * a little trickery here to wrangle the statement sequence into LLVM's\n+     * format. *)\n+\n+    let new_block id_opt klass =\n+      let llblock = Llvm.append_block llctx (node_llid id_opt klass) llfn in\n+      let llbuilder = Llvm.builder_at_end llctx llblock in\n+      (llblock, llbuilder)\n+    in\n+\n+    (* Build up the slot-to-llvalue mapping, allocating space along the\n+     * way. *)\n+    let slot_to_llvalue = Hashtbl.create 0 in\n+    let (_, llinitbuilder) = new_block None \"init\" in\n+\n+    (* Allocate space for arguments (needed because arguments are lvalues in\n+     * Rust), and store them in the slot-to-llvalue mapping. *)\n+    let n_implicit_args = 2 in\n+    let build_arg idx llargval =\n+      if idx >= n_implicit_args\n+      then\n+        let ({ id = id }, ident) = header_slots.(idx - 2) in\n+        Llvm.set_value_name ident llargval;\n+        let llarg =\n+          let llty = Llvm.type_of llargval in\n+          Llvm.build_alloca llty (ident ^ \"_ptr\") llinitbuilder\n+        in\n+        ignore (Llvm.build_store llargval llarg llinitbuilder);\n+        Hashtbl.add slot_to_llvalue id llarg\n+    in\n+    Array.iteri build_arg (Llvm.params llfn);\n+\n+    (* Allocate space for all the blocks' slots.\n+     * and zero the exteriors. *)\n+    let init_block (block_id:node_id) : unit =\n+      let init_slot\n+          (key:Ast.slot_key)\n+          (slot_id:node_id)\n+          (slot:Ast.slot)\n+          : unit =\n+        let name = Ast.sprintf_slot_key () key in\n+        let llty = trans_slot (Some slot_id) slot in\n+        let llptr = Llvm.build_alloca llty name llinitbuilder in\n+          begin\n+            match slot_mem_ctrl slot with\n+                MEM_rc_struct\n+              | MEM_rc_opaque\n+              | MEM_gc ->\n+                  ignore (Llvm.build_store\n+                            (Llvm.const_pointer_null llty)\n+                            llptr llinitbuilder);\n+              | _ -> ()\n+          end;\n+          Hashtbl.add slot_to_llvalue slot_id llptr\n+      in\n+        iter_block_slots sem_cx block_id init_slot\n+    in\n+\n+    let exit_block\n+        (llbuilder:Llvm.llbuilder)\n+        (block_id:node_id)\n+        : Llvm.llbuilder =\n+      let r = ref llbuilder in\n+        iter_block_slots sem_cx block_id\n+          begin\n+            fun _ slot_id slot ->\n+              if (not (Semant.slot_is_obj_state sem_cx slot_id))\n+              then\n+                let ptr = Hashtbl.find slot_to_llvalue slot_id in\n+                  drop_slot r lltask ptr slot None\n+          end;\n+        !r\n+    in\n+\n+    List.iter init_block (Hashtbl.find sem_cx.Semant.ctxt_frame_blocks fn_id);\n+\n+    let static_str (s:string) : Llvm.llvalue =\n+      Llvm.define_global (anon_llid \"str\") (Llvm.const_stringz llctx s) llmod\n+    in\n+\n+\n+    (* Translates a list of AST statements to a sequence of LLVM instructions.\n+     * The supplied \"terminate\" function appends the appropriate terminator\n+     * instruction to the instruction stream. It may or may not be called,\n+     * depending on whether the AST contains a terminating instruction\n+     * explicitly. *)\n+    let rec trans_stmts\n+        (block_id:node_id)\n+        (llbuilder:Llvm.llbuilder)\n+        (stmts:Ast.stmt list)\n+        (terminate:(Llvm.llbuilder -> node_id -> unit))\n+        : unit =\n+      let trans_literal\n+          (lit:Ast.lit)\n+          : Llvm.llvalue =\n+        match lit with\n+            Ast.LIT_nil -> llnil\n+          | Ast.LIT_bool value ->\n+            Llvm.const_int (Llvm.i1_type llctx) (if value then 1 else 0)\n+          | Ast.LIT_mach (mty, value, _) ->\n+            let llty = trans_mach_ty mty in\n+            Llvm.const_of_int64 llty value (mach_is_signed mty)\n+          | Ast.LIT_int (value, _) ->\n+            Llvm.const_of_int64 (Llvm.i32_type llctx) value true\n+          | Ast.LIT_uint (value, _) ->\n+            Llvm.const_of_int64 (Llvm.i32_type llctx) value false\n+          | Ast.LIT_char ch ->\n+            Llvm.const_int (Llvm.i32_type llctx) ch\n+      in\n+\n+      (* Translates an lval by reference into the appropriate pointer\n+       * value. *)\n+      let trans_lval (lval:Ast.lval) : Llvm.llvalue =\n+        iflog (fun _ -> log sem_cx \"trans_lval: %a\" Ast.sprintf_lval lval);\n+        match lval with\n+            Ast.LVAL_base { id = base_id } ->\n+              let id =\n+                Hashtbl.find sem_cx.Semant.ctxt_lval_to_referent base_id\n+              in\n+              let referent = Hashtbl.find sem_cx.Semant.ctxt_all_defns id in\n+              begin\n+                match referent with\n+                    Semant.DEFN_slot _ -> Hashtbl.find slot_to_llvalue id\n+                  | Semant.DEFN_item _ -> Hashtbl.find llitems id\n+                  | _ -> bogus_ptr (* TODO *)\n+              end\n+          | Ast.LVAL_ext _ -> bogus_ptr (* TODO *)\n+      in\n+\n+      let trans_atom (atom:Ast.atom) : Llvm.llvalue =\n+        iflog (fun _ -> log sem_cx \"trans_atom: %a\" Ast.sprintf_atom atom);\n+        match atom with\n+            Ast.ATOM_literal { node = lit } -> trans_literal lit\n+          | Ast.ATOM_lval lval ->\n+              Llvm.build_load (trans_lval lval) (anon_llid \"tmp\") llbuilder\n+      in\n+\n+      let trans_binary_expr\n+          ((op:Ast.binop), (lhs:Ast.atom), (rhs:Ast.atom))\n+          : Llvm.llvalue =\n+        (* Evaluate the operands in the proper order. *)\n+        let (lllhs, llrhs) =\n+          match op with\n+              Ast.BINOP_or | Ast.BINOP_and | Ast.BINOP_eq | Ast.BINOP_ne\n+                  | Ast.BINOP_lt | Ast.BINOP_le | Ast.BINOP_ge | Ast.BINOP_gt\n+                  | Ast.BINOP_lsl | Ast.BINOP_lsr | Ast.BINOP_asr\n+                  | Ast.BINOP_add | Ast.BINOP_sub | Ast.BINOP_mul\n+                  | Ast.BINOP_div | Ast.BINOP_mod | Ast.BINOP_xor ->\n+                (trans_atom lhs, trans_atom rhs)\n+            | Ast.BINOP_send ->\n+                let llrhs = trans_atom rhs in\n+                let lllhs = trans_atom lhs in\n+                (lllhs, llrhs)\n+        in\n+        let llid = anon_llid \"expr\" in\n+        match op with\n+            Ast.BINOP_eq ->\n+              (* TODO: equality works on more than just integers *)\n+              Llvm.build_icmp Llvm.Icmp.Eq lllhs llrhs llid llbuilder\n+\n+            (* TODO: signed/unsigned distinction, floating point *)\n+          | Ast.BINOP_add -> Llvm.build_add lllhs llrhs llid llbuilder\n+          | Ast.BINOP_sub -> Llvm.build_sub lllhs llrhs llid llbuilder\n+          | Ast.BINOP_mul -> Llvm.build_mul lllhs llrhs llid llbuilder\n+          | Ast.BINOP_div -> Llvm.build_sdiv lllhs llrhs llid llbuilder\n+          | Ast.BINOP_mod -> Llvm.build_srem lllhs llrhs llid llbuilder\n+\n+          | _ -> bogus (* TODO *)\n+      in\n+\n+      let trans_unary_expr _ = bogus in (* TODO *)\n+\n+      let trans_expr (expr:Ast.expr) : Llvm.llvalue =\n+        iflog (fun _ -> log sem_cx \"trans_expr: %a\" Ast.sprintf_expr expr);\n+        match expr with\n+            Ast.EXPR_binary binexp -> trans_binary_expr binexp\n+          | Ast.EXPR_unary unexp -> trans_unary_expr unexp\n+          | Ast.EXPR_atom atom -> trans_atom atom\n+      in\n+\n+      let trans_log_str (atom:Ast.atom) : unit =\n+        upcall llbuilder lltask \"upcall_log_str\" None [| trans_atom atom |]\n+      in\n+\n+      let trans_log_int (atom:Ast.atom) : unit =\n+        upcall llbuilder lltask \"upcall_log_int\" None [| trans_atom atom |]\n+      in\n+\n+      let trans_fail\n+          (llbuilder:Llvm.llbuilder)\n+          (lltask:Llvm.llvalue)\n+          (reason:string)\n+          (stmt_id:node_id)\n+          : unit =\n+        let (file, line, _) =\n+          match Session.get_span sem_cx.Semant.ctxt_sess stmt_id with\n+              None -> (\"<none>\", 0, 0)\n+            | Some sp -> sp.lo\n+        in\n+        upcall llbuilder lltask \"upcall_fail\" None [|\n+          static_str reason;\n+          static_str file;\n+          Llvm.const_int (Llvm.i32_type llctx) line\n+        |];\n+        ignore (Llvm.build_unreachable llbuilder)\n+      in\n+\n+      (* FIXME: this may be irrelevant; possibly LLVM will wind up\n+       * using GOT and such wherever it needs to to achieve PIC\n+       * data.\n+       *)\n+      (*\n+        let crate_rel (v:Llvm.llvalue) : Llvm.llvalue =\n+        let v_int = Llvm.const_pointercast v word_ty in\n+        let c_int = Llvm.const_pointercast crate_ptr word_ty in\n+        Llvm.const_sub v_int c_int\n+        in\n+      *)\n+\n+      match stmts with\n+          [] -> terminate llbuilder block_id\n+        | head::tail ->\n+\n+            iflog (fun _ ->\n+                     log sem_cx \"trans_stmt: %a\" Ast.sprintf_stmt head);\n+\n+            let trans_tail_with_builder llbuilder' : unit =\n+              trans_stmts block_id llbuilder' tail terminate\n+            in\n+            let trans_tail () = trans_tail_with_builder llbuilder in\n+\n+            match head.node with\n+                Ast.STMT_init_tup (dest, atoms) ->\n+                  let zero = const_i32 0 in\n+                  let lldest = trans_lval dest in\n+                  let trans_tup_atom idx (_, _, atom) =\n+                    let indices = [| zero; const_i32 idx |] in\n+                    let gep_id = anon_llid \"init_tup_gep\" in\n+                    let ptr =\n+                      Llvm.build_gep lldest indices gep_id llbuilder\n+                    in\n+                    ignore (Llvm.build_store (trans_atom atom) ptr llbuilder)\n+                  in\n+                  Array.iteri trans_tup_atom atoms;\n+                  trans_tail ()\n+\n+              | Ast.STMT_copy (dest, src) ->\n+                  let llsrc = trans_expr src in\n+                  let lldest = trans_lval dest in\n+                  ignore (Llvm.build_store llsrc lldest llbuilder);\n+                  trans_tail ()\n+\n+              | Ast.STMT_call (dest, fn, args) ->\n+                  let llargs = Array.map trans_atom args in\n+                  let lldest = trans_lval dest in\n+                  let llfn = trans_lval fn in\n+                  let llallargs = Array.append [| lldest; lltask |] llargs in\n+                  let llrv = build_call llfn llallargs \"\" llbuilder in\n+                    Llvm.set_instruction_call_conv Llvm.CallConv.c llrv;\n+                    trans_tail ()\n+\n+              | Ast.STMT_if sif ->\n+                  let llexpr = trans_expr sif.Ast.if_test in\n+                  let (llnext, llnextbuilder) = new_block None \"next\" in\n+                  let branch_to_next llbuilder' _ =\n+                    ignore (Llvm.build_br llnext llbuilder')\n+                  in\n+                  let llthen = trans_block sif.Ast.if_then branch_to_next in\n+                  let llelse =\n+                    match sif.Ast.if_else with\n+                        None -> llnext\n+                      | Some if_else -> trans_block if_else branch_to_next\n+                  in\n+                  ignore (Llvm.build_cond_br llexpr llthen llelse llbuilder);\n+                  trans_tail_with_builder llnextbuilder\n+\n+              | Ast.STMT_ret atom_opt ->\n+                  begin\n+                    match atom_opt with\n+                        None -> ()\n+                      | Some atom ->\n+                          ignore (Llvm.build_store (trans_atom atom)\n+                                    lloutptr llbuilder)\n+                  end;\n+                  let llbuilder = exit_block llbuilder block_id in\n+                    ignore (Llvm.build_ret_void llbuilder)\n+\n+              | Ast.STMT_fail ->\n+                  trans_fail llbuilder lltask \"explicit failure\" head.id\n+\n+              | Ast.STMT_log a ->\n+                  begin\n+                    match Semant.atom_type sem_cx a with\n+                        (* NB: If you extend this, be sure to update the\n+                         * typechecking code in type.ml as well. *)\n+                        Ast.TY_str -> trans_log_str a\n+                      | Ast.TY_int | Ast.TY_uint | Ast.TY_bool | Ast.TY_char\n+                      | Ast.TY_mach (TY_u8) | Ast.TY_mach (TY_u16)\n+                      | Ast.TY_mach (TY_u32) | Ast.TY_mach (TY_i8)\n+                      | Ast.TY_mach (TY_i16) | Ast.TY_mach (TY_i32) ->\n+                          trans_log_int a\n+                      | _ -> Semant.bugi sem_cx head.id\n+                          \"unimplemented logging type\"\n+                  end;\n+                  trans_tail ()\n+\n+              | Ast.STMT_check_expr expr ->\n+                  let llexpr = trans_expr expr in\n+                  let (llfail, llfailbuilder) = new_block None \"fail\" in\n+                  let reason = Ast.fmt_to_str Ast.fmt_expr expr in\n+                  trans_fail llfailbuilder lltask reason head.id;\n+                  let (llok, llokbuilder) = new_block None \"ok\" in\n+                  ignore (Llvm.build_cond_br llexpr llok llfail llbuilder);\n+                  trans_tail_with_builder llokbuilder\n+\n+              | Ast.STMT_init_str (dst, str) ->\n+                  let d = trans_lval dst in\n+                  let s = static_str str in\n+                  let len =\n+                    Llvm.const_int word_ty ((String.length str) + 1)\n+                  in\n+                    upcall llbuilder lltask \"upcall_new_str\"\n+                      (Some d) [| s; len |];\n+                    trans_tail ()\n+\n+              | _ -> trans_stmts block_id llbuilder tail terminate\n+\n+    (* \n+     * Translates an AST block to one or more LLVM basic blocks and returns\n+     * the first basic block. The supplied callback is expected to add a\n+     * terminator instruction.\n+     *)\n+\n+    and trans_block\n+        ({ node = (stmts:Ast.stmt array); id = id }:Ast.block)\n+        (terminate:Llvm.llbuilder -> node_id -> unit)\n+        : Llvm.llbasicblock =\n+      let (llblock, llbuilder) = new_block (Some id) \"bb\" in\n+        trans_stmts id llbuilder (Array.to_list stmts) terminate;\n+        llblock\n+    in\n+\n+    (* \"Falling off the end\" of a function needs to turn into an explicit\n+     * return instruction. *)\n+    let default_terminate llbuilder block_id =\n+      let llbuilder = exit_block llbuilder block_id in\n+        ignore (Llvm.build_ret_void llbuilder)\n+    in\n+\n+    (* Build up the first body block, and link it to the end of the\n+     * initialization block. *)\n+    let llbodyblock = (trans_block body default_terminate) in\n+      ignore (Llvm.build_br llbodyblock llinitbuilder)\n+  in\n+\n+  let trans_mod_item\n+      (_:Ast.ident)\n+      { node = { Ast.decl_item = (item:Ast.mod_item') }; id = id }\n+      : unit =\n+    match item with\n+        Ast.MOD_ITEM_fn fn -> trans_fn fn id\n+      | _ -> ()\n+  in\n+\n+  let exit_task_glue =\n+    (* The exit-task glue does not get called.\n+     * \n+     * Rather, control arrives at it by *returning* to the first\n+     * instruction of it, when control falls off the end of the task's\n+     * root function.\n+     * \n+     * There is a \"fake\" frame set up by the runtime, underneath us,\n+     * that we find ourselves in. This frame has the shape of a frame\n+     * entered with 2 standard arguments (outptr + taskptr), then a\n+     * retpc and N callee-saves sitting on the stack; all this is under\n+     * ebp. Then there are 2 *outgoing* args at sp[0] and sp[1].\n+     * \n+     * All these are fake except the taskptr, which is the one bit we\n+     * want. So we construct an equally fake cdecl llvm signature here\n+     * to crudely *get* the taskptr that's sitting 2 words up from sp,\n+     * and pass it to upcall_exit.\n+     * \n+     * The latter never returns.\n+     *)\n+    let llty = fn_ty void_ty [| task_ptr_ty |] in\n+    let llfn = Llvm.declare_function \"rust_exit_task_glue\" llty llmod in\n+    let lltask = Llvm.param llfn 0 in\n+    let llblock = Llvm.append_block llctx \"body\" llfn in\n+    let llbuilder = Llvm.builder_at_end llctx llblock in\n+      trans_upcall llbuilder lltask \"upcall_exit\" None [||];\n+      ignore (Llvm.build_ret_void llbuilder);\n+      llfn\n+  in\n+\n+    try\n+      let crate' = crate.node in\n+      let items = snd (crate'.Ast.crate_items) in\n+        Hashtbl.iter declare_mod_item items;\n+        Hashtbl.iter trans_mod_item items;\n+        Llfinal.finalize_module\n+          llctx llmod abi asm_glue exit_task_glue crate_ptr;\n+        llmod\n+    with e -> Llvm.dispose_module llmod; raise e\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)\n+"}, {"sha": "7009fe1061880e2d93d5076b8812c92df29952f0", "filename": "src/boot/me/alias.ml", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Falias.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Falias.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Falias.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,134 @@\n+open Semant;;\n+open Common;;\n+\n+let log cx = Session.log \"alias\"\n+  cx.ctxt_sess.Session.sess_log_alias\n+  cx.ctxt_sess.Session.sess_log_out\n+;;\n+\n+let alias_analysis_visitor\n+    (cx:ctxt)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+  let curr_stmt = Stack.create () in\n+\n+  let alias_slot (slot_id:node_id) : unit =\n+    begin\n+      log cx \"noting slot #%d as aliased\" (int_of_node slot_id);\n+      Hashtbl.replace cx.ctxt_slot_aliased slot_id ()\n+    end\n+  in\n+\n+  let alias lval =\n+    match lval with\n+        Ast.LVAL_base nb ->\n+          let referent = Hashtbl.find cx.ctxt_lval_to_referent nb.id in\n+            if (referent_is_slot cx referent)\n+            then alias_slot referent\n+      | _ -> err None \"unhandled form of lval %a in alias analysis\"\n+          Ast.sprintf_lval lval\n+  in\n+\n+  let alias_atom at =\n+    match at with\n+        Ast.ATOM_lval lv -> alias lv\n+      | _ -> err None \"aliasing literal\"\n+  in\n+\n+  let alias_call_args dst callee args =\n+    alias dst;\n+    let callee_ty = lval_ty cx callee in\n+      match callee_ty with\n+          Ast.TY_fn (tsig,_) ->\n+            Array.iteri\n+              begin\n+                fun i slot ->\n+                  match slot.Ast.slot_mode with\n+                      Ast.MODE_alias _ ->\n+                        alias_atom args.(i)\n+                    | _ -> ()\n+              end\n+              tsig.Ast.sig_input_slots\n+        | _ -> ()\n+  in\n+\n+  let visit_stmt_pre s =\n+    Stack.push s.id curr_stmt;\n+    begin\n+      try\n+        match s.node with\n+            (* FIXME (issue #26): actually all these *existing* cases\n+             * can probably go now that we're using Trans.aliasing to\n+             * form short-term spill-based aliases. Only aliases that\n+             * survive 'into' a sub-block (those formed during iteration)\n+             * need to be handled in this module.  *)\n+            Ast.STMT_call (dst, callee, args)\n+          | Ast.STMT_spawn (dst, _, callee, args)\n+            -> alias_call_args dst callee args\n+\n+          | Ast.STMT_send (_, src) -> alias src\n+          | Ast.STMT_recv (dst, _) -> alias dst\n+          | Ast.STMT_init_port (dst) -> alias dst\n+          | Ast.STMT_init_chan (dst, _) -> alias dst\n+          | Ast.STMT_init_vec (dst, _, _) -> alias dst\n+          | Ast.STMT_init_str (dst, _) -> alias dst\n+          | Ast.STMT_for_each sfe ->\n+              let (slot, _) = sfe.Ast.for_each_slot in\n+                alias_slot slot.id\n+          | _ -> () (* FIXME (issue #29): plenty more to handle here. *)\n+      with\n+          Semant_err (None, msg) ->\n+            raise (Semant_err ((Some s.id), msg))\n+    end;\n+    inner.Walk.visit_stmt_pre s\n+  in\n+  let visit_stmt_post s =\n+    inner.Walk.visit_stmt_post s;\n+    ignore (Stack.pop curr_stmt);\n+  in\n+\n+  let visit_lval_pre lv =\n+    let slot_id = lval_to_referent cx (lval_base_id lv) in\n+      if (not (Stack.is_empty curr_stmt)) && (referent_is_slot cx slot_id)\n+      then\n+        begin\n+          let slot_depth = get_slot_depth cx slot_id in\n+          let stmt_depth = get_stmt_depth cx (Stack.top curr_stmt) in\n+            if slot_depth <> stmt_depth\n+            then\n+              begin\n+                let _ = assert (slot_depth < stmt_depth) in\n+                  alias_slot slot_id\n+              end\n+        end\n+  in\n+\n+    { inner with\n+        Walk.visit_stmt_pre = visit_stmt_pre;\n+        Walk.visit_stmt_post = visit_stmt_post;\n+        Walk.visit_lval_pre = visit_lval_pre\n+    }\n+;;\n+\n+let process_crate\n+    (cx:ctxt)\n+    (crate:Ast.crate)\n+    : unit =\n+  let path = Stack.create () in\n+  let passes =\n+    [|\n+      (alias_analysis_visitor cx\n+         Walk.empty_visitor);\n+    |]\n+  in\n+    run_passes cx \"alias\" path passes (log cx \"%s\") crate\n+;;\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "47e5616628f68fcd7d25763919ede85a5a801252", "filename": "src/boot/me/dead.ml", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fdead.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fdead.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdead.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04", "patch": "@@ -0,0 +1,121 @@\n+(* \n+ * A simple dead-code analysis that rejects code following unconditional\n+ * 'ret' or 'be'. \n+ *)\n+\n+open Semant;;\n+open Common;;\n+\n+let log cx = Session.log \"dead\"\n+  cx.ctxt_sess.Session.sess_log_dead\n+  cx.ctxt_sess.Session.sess_log_out\n+;;\n+\n+let dead_code_visitor\n+    ((*cx*)_:ctxt)\n+    (inner:Walk.visitor)\n+    : Walk.visitor =\n+\n+  (* FIXME: create separate table for each fn body for less garbage *)\n+  let must_exit = Hashtbl.create 100 in\n+\n+  let all_must_exit ids =\n+    arr_for_all (fun _ id -> Hashtbl.mem must_exit id) ids\n+  in\n+\n+  let visit_block_post block =\n+    let stmts = block.node in\n+    let len = Array.length stmts in\n+      if len > 0 then\n+        Array.iteri\n+          begin\n+            fun i s ->\n+              if (i < (len - 1)) && (Hashtbl.mem must_exit s.id) then\n+                err (Some stmts.(i + 1).id) \"dead statement\"\n+          end\n+          stmts;\n+      inner.Walk.visit_block_post block\n+  in\n+\n+  let visit_stmt_post s =\n+    begin\n+      match s.node with\n+        | Ast.STMT_block block ->\n+            if Hashtbl.mem must_exit block.id then\n+              Hashtbl.add must_exit s.id ()\n+\n+        | Ast.STMT_while { Ast.while_body = body }\n+        | Ast.STMT_do_while { Ast.while_body = body }\n+        | Ast.STMT_for_each { Ast.for_each_body = body }\n+        | Ast.STMT_for { Ast.for_body = body } ->\n+            if (Hashtbl.mem must_exit body.id) then\n+              Hashtbl.add must_exit s.id ()\n+\n+        | Ast.STMT_if { Ast.if_then = b1; Ast.if_else = Some b2 } ->\n+            if (Hashtbl.mem must_exit b1.id) && (Hashtbl.mem must_exit b2.id)\n+            then Hashtbl.add must_exit s.id ()\n+\n+        | Ast.STMT_if _ -> ()\n+\n+        | Ast.STMT_ret _\n+        | Ast.STMT_be _ ->\n+            Hashtbl.add must_exit s.id ()\n+\n+        | Ast.STMT_alt_tag { Ast.alt_tag_arms = arms } ->\n+            let arm_ids =\n+              Array.map (fun { node = (_, block) } -> block.id) arms\n+            in\n+              if all_must_exit arm_ids\n+              then Hashtbl.add must_exit s.id ()\n+\n+        | Ast.STMT_alt_type { Ast.alt_type_arms = arms;\n+                              Ast.alt_type_else = alt_type_else } ->\n+            let arm_ids = Array.map (fun (_, _, block) -> block.id) arms in\n+            let else_ids =\n+              begin\n+                match alt_type_else with\n+                    Some stmt -> [| stmt.id |]\n+                  | None -> [| |]\n+              end\n+            in\n+              if all_must_exit (Array.append arm_ids else_ids) then\n+                Hashtbl.add must_exit s.id ()\n+\n+        (* FIXME: figure this one out *)\n+        | Ast.STMT_alt_port _ -> ()\n+\n+        | _ -> ()\n+    end;\n+    inner.Walk.visit_stmt_post s\n+\n+  in\n+    { inner with\n+        Walk.visit_block_post = visit_block_post;\n+        Walk.visit_stmt_post = visit_stmt_post }\n+;;\n+\n+let process_crate\n+    (cx:ctxt)\n+    (crate:Ast.crate)\n+    : unit =\n+  let path = Stack.create () in\n+  let passes =\n+    [|\n+      (dead_code_visitor cx\n+         Walk.empty_visitor)\n+    |]\n+  in\n+\n+    run_passes cx \"dead\" path passes (log cx \"%s\") crate;\n+    ()\n+;;\n+\n+\n+(*\n+ * Local Variables:\n+ * fill-column: 78;\n+ * indent-tabs-mode: nil\n+ * buffer-file-coding-system: utf-8-unix\n+ * compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+ * End:\n+ *)"}, {"sha": "9423d4ee7f3279a78446bcbb19d1c7ca3e9bce3f", "filename": "src/boot/me/dwarf.ml", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fdwarf.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fdwarf.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fdwarf.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "515cfa21ed5a78ffb1fcf300d034c51c85ac9de0", "filename": "src/boot/me/effect.ml", "status": "added", "additions": 313, "deletions": 0, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Feffect.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Feffect.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Feffect.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "6c4567fdae7ae9fbaeee62010e1827e9e5ccc576", "filename": "src/boot/me/layout.ml", "status": "added", "additions": 470, "deletions": 0, "changes": 470, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Flayout.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Flayout.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Flayout.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c23c4afd24ccbf886c9ecf250b90cf76b37d4b65", "filename": "src/boot/me/loop.ml", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Floop.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Floop.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Floop.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8f034aee3a31aac398b67c78179494fec1ea7b86", "filename": "src/boot/me/resolve.ml", "status": "added", "additions": 959, "deletions": 0, "changes": 959, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fresolve.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fresolve.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fresolve.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b5000ff38cec40cb6828be583f3482f552a2519e", "filename": "src/boot/me/semant.ml", "status": "added", "additions": 1969, "deletions": 0, "changes": 1969, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fsemant.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fsemant.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fsemant.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "bca15136389475a0247a9a4be3e49a8ac8ddd22a", "filename": "src/boot/me/trans.ml", "status": "added", "additions": 5031, "deletions": 0, "changes": 5031, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftrans.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftrans.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftrans.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c430e034ca99573f3a3fbd98c8eea85a0b4c42d2", "filename": "src/boot/me/transutil.ml", "status": "added", "additions": 238, "deletions": 0, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftransutil.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftransutil.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftransutil.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "2d4dd94aa7a40a4fe84c1cc3729236f619dc5bf0", "filename": "src/boot/me/type.ml", "status": "added", "additions": 1294, "deletions": 0, "changes": 1294, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4671d0f4d0a7060219bf9374314213655c12392c", "filename": "src/boot/me/typestate.ml", "status": "added", "additions": 1089, "deletions": 0, "changes": 1089, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftypestate.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Ftypestate.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftypestate.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3486bb16421e360ba46f779f66f4f3f8ba1b956d", "filename": "src/boot/me/walk.ml", "status": "added", "additions": 687, "deletions": 0, "changes": 687, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fwalk.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Fme%2Fwalk.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Fwalk.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3114bd661444fc559adf6e58dbf9bece175db187", "filename": "src/boot/util/bits.ml", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Futil%2Fbits.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Futil%2Fbits.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fbits.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "f33a6ea16495fe19bcba5cf772268996d3d46f15", "filename": "src/boot/util/common.ml", "status": "added", "additions": 709, "deletions": 0, "changes": 709, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Futil%2Fcommon.ml", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fboot%2Futil%2Fcommon.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fcommon.ml?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "35ebba1f6c14531275dd3b1ce3244b781f67d9c2", "filename": "src/comp/driver/rustc.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/comp/fe/lexer.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Ffe%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Ffe%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Flexer.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/comp/fe/parser.rs", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Ffe%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Ffe%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffe%2Fparser.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3bf3bbcc9bc9d3ef38ebee967b859409deeedcac", "filename": "src/comp/rustc.rc", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "eff967bf6cea827bf2dc6917c3d110f50ece5d2c", "filename": "src/etc/tidy.py", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fetc%2Ftidy.py", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fetc%2Ftidy.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Ftidy.py?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "f829f2ad2346506161ec7143f319875abe9d6cf6", "filename": "src/etc/x86.supp", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fetc%2Fx86.supp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Fetc%2Fx86.supp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fx86.supp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "1bb6cb45b1e3f8e7f5753db77e7362ab668abcfa", "filename": "src/lib/_int.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_int.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "1f01c3b3a0179205ea141772790fda384f9cf542", "filename": "src/lib/_io.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_io.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "ac27f294b29557ff9ade19d8d4351c4afc3625ee", "filename": "src/lib/_str.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_str.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e1f671e752a0f3fbba5657fff5bbcd7aa746a092", "filename": "src/lib/_u8.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_u8.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c938e6fb94230d986881220233b092d0f1950fb6", "filename": "src/lib/_vec.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "a775a97ab7c6c50afa7dfb1941b64b040730f316", "filename": "src/lib/linux_os.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Flinux_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Flinux_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flinux_os.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8b30c8bc6b08707f6d697c50fdc635bd3f1e7d71", "filename": "src/lib/macos_os.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fmacos_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fmacos_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmacos_os.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3ddfc04cfc8fa370701358c01ee8800b60395457", "filename": "src/lib/std.rc", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "84da28f72536f9f0b533563785692995ba05d96c", "filename": "src/lib/sys.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fsys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fsys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fsys.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "f770a5de4edec8d1c0df4a9252a80ef2bc534439", "filename": "src/lib/win32_os.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fwin32_os.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Flib%2Fwin32_os.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fwin32_os.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b4c48f0376c9fbfd99228ee53a91b96767ab38c2", "filename": "src/rt/bigint/bigint.h", "status": "added", "additions": 294, "deletions": 0, "changes": 294, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fbigint%2Fbigint.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "66d79106f48d424556807f832f91ecc64c9a3ced", "filename": "src/rt/bigint/bigint_ext.cpp", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint_ext.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint_ext.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fbigint%2Fbigint_ext.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "194ddcb56002b582ae8c01c65f33a6c610641c7f", "filename": "src/rt/bigint/bigint_int.cpp", "status": "added", "additions": 1428, "deletions": 0, "changes": 1428, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint_int.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Fbigint_int.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fbigint%2Fbigint_int.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c9d3df0b3f403e1594b72adb131da13b9f2eb4c2", "filename": "src/rt/bigint/low_primes.h", "status": "added", "additions": 1069, "deletions": 0, "changes": 1069, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Flow_primes.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fbigint%2Flow_primes.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fbigint%2Flow_primes.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "018496f676ef59f3e1d5a34fd6f7307d14f6b04e", "filename": "src/rt/isaac/rand.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Frand.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Frand.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frand.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "45ec590dd0608ab6c47f1a57f568453df9401791", "filename": "src/rt/isaac/randport.cpp", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Frandport.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Frandport.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Frandport.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "202a5d658c504b1c324b11872b3e1ff0f45ebfc3", "filename": "src/rt/isaac/standard.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Fstandard.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fisaac%2Fstandard.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fisaac%2Fstandard.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "fc50dabfbb0a8c76d955277c36179f060a1b383e", "filename": "src/rt/memcheck.h", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fmemcheck.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fmemcheck.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fmemcheck.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8c725bfbc0754765a594cd69a2579514794965cd", "filename": "src/rt/rust.cpp", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "135a1799d32d2a935c0533c9f7bef1e1beba2b9f", "filename": "src/rt/rust.h", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "71aa644b144cba93a4905b3fb530e3051f5f2950", "filename": "src/rt/rust_builtin.cpp", "status": "added", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "38f93a7da9feb307de8338b8293e13e882169a74", "filename": "src/rt/rust_chan.cpp", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_chan.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_chan.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "a56ba0ca48170166b56ed084564d4a3137f1f533", "filename": "src/rt/rust_chan.h", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_chan.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_chan.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_chan.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "58b9ef4c424d8ea2966c34b9ae7955b8ed590dea", "filename": "src/rt/rust_comm.cpp", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_comm.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_comm.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_comm.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "d609ac64718789dbf3dda942b43c3b0ab3399b11", "filename": "src/rt/rust_crate.cpp", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "fa10b91b97f94b2461b26710fb02409d7baf0d34", "filename": "src/rt/rust_crate_cache.cpp", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate_cache.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate_cache.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_cache.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3c36729ff2695f3cfc3b4935fb9140cfe80b42a9", "filename": "src/rt/rust_crate_reader.cpp", "status": "added", "additions": 578, "deletions": 0, "changes": 578, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate_reader.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_crate_reader.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate_reader.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3b5e23b20c5ca7fd9c388b115428d590240fa495", "filename": "src/rt/rust_dom.cpp", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_dom.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_dom.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dom.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8eff3b8ce2b67bb43962aeebd2d2cb86fef98428", "filename": "src/rt/rust_dwarf.h", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_dwarf.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_dwarf.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_dwarf.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c393b210a30e11258a6de0f28afa852f91b24fb0", "filename": "src/rt/rust_internal.h", "status": "added", "additions": 730, "deletions": 0, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "102a26237f7540b75518ec857e1b89a9e5504724", "filename": "src/rt/rust_log.cpp", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b0c5fbeca77104575a72ca9e962c7dc791ad6dc1", "filename": "src/rt/rust_log.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_log.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_log.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "beba11a0931e43fb8aeab4659a436da4c3e07892", "filename": "src/rt/rust_task.cpp", "status": "added", "additions": 474, "deletions": 0, "changes": 474, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "897b773018210f5ba9ae73d4040d777e44b23367", "filename": "src/rt/rust_timer.cpp", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_timer.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_timer.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_timer.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3a17ea1ce9a0194473fa5cb72449731bd9ec68bd", "filename": "src/rt/rust_upcall.cpp", "status": "added", "additions": 654, "deletions": 0, "changes": 654, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "6f34dad928a176fb1bb1fd60593253000a7692b8", "filename": "src/rt/rust_util.h", "status": "added", "additions": 155, "deletions": 0, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_util.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Frust_util.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_util.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "0306ee1df39537a8fe0d3ca488ddbd6e6b7083bb", "filename": "src/rt/sync/fair_ticket_lock.cpp", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ffair_ticket_lock.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c34c9041657c67618a5fff85b29abfa37131a393", "filename": "src/rt/sync/fair_ticket_lock.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Ffair_ticket_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Ffair_ticket_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Ffair_ticket_lock.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9d1081de88b6b6fc4f70efdbe29d8f15c373aba7", "filename": "src/rt/sync/lock_free_queue.cpp", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Flock_free_queue.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Flock_free_queue.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "fba4aa9ae66c12861f332ca85fc4cd13d777eb12", "filename": "src/rt/sync/lock_free_queue.h", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Flock_free_queue.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Flock_free_queue.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Flock_free_queue.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "11a5cb201afb146936092919c8631c8ca769b0f2", "filename": "src/rt/sync/spin_lock.cpp", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Fspin_lock.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Fspin_lock.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.cpp?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3684c23a68d20ef493d700681b218d25e07e9926", "filename": "src/rt/sync/spin_lock.h", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Fspin_lock.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fsync%2Fspin_lock.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsync%2Fspin_lock.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "28021b61611910dd28fd7650936c7a651f5fa457", "filename": "src/rt/uthash/uthash.h", "status": "added", "additions": 766, "deletions": 0, "changes": 766, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futhash%2Futhash.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futhash%2Futhash.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futhash%2Futhash.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "a33615e1ba05456850425423077b82a6043d1ef1", "filename": "src/rt/uthash/utlist.h", "status": "added", "additions": 280, "deletions": 0, "changes": 280, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futhash%2Futlist.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futhash%2Futlist.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futhash%2Futlist.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "0d112575ce78bffb542b87867db27f86e3f24eb3", "filename": "src/rt/util/array_list.h", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futil%2Farray_list.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Futil%2Farray_list.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Futil%2Farray_list.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "530fa184e528e91a162820f73da5b29b392b5e91", "filename": "src/rt/valgrind.h", "status": "added", "additions": 3926, "deletions": 0, "changes": 3926, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fvalgrind.h", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Frt%2Fvalgrind.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvalgrind.h?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "27b4c3c05a7b7bec18d7b515b38afdb144f05784", "filename": "src/test/bench/shootout/ackermann.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fackermann.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "bb3ab602ef0a2282d1cdbbf844f6bdecfc491d9b", "filename": "src/test/bench/shootout/binary-trees.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Fbinary-trees.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9045f3815b3f27224720568ca72e0ed0b516d3f9", "filename": "src/test/bench/shootout/fibo.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout%2Ffibo.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "18f4104e33caee2a94348f805bd29281a7b75403", "filename": "src/test/compile-fail/arg-count-mismatch.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-count-mismatch.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3a61992ad72ac73a8493f41916f415b61e7ee582", "filename": "src/test/compile-fail/arg-type-mismatch.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Farg-type-mismatch.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "013bb56e445811312f51d0c2c9d054f12872fea0", "filename": "src/test/compile-fail/bad-env-capture.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-env-capture.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8e3fa503eaf9bf3b7b1c593fe0e868fe1e6281e7", "filename": "src/test/compile-fail/bad-main.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-main.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-main.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "44a30219f1d59cc5b3e1b3c9dc5ddeecb146fa00", "filename": "src/test/compile-fail/bad-name.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-name.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e18e63a76afcd10a03986dac846716afa7aa5eb3", "filename": "src/test/compile-fail/bad-type-env-capture.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-type-env-capture.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "35c5736c84f82fe9c0cf165f20bfbc264ea72403", "filename": "src/test/compile-fail/bogus-tag.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbogus-tag.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "50f87d0cacb6bd6b53cd27dca3a8de34a0873b3a", "filename": "src/test/compile-fail/comm-makes-io.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcomm-makes-io.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "060b466ac1205cf224af7a02f39943ceab58c5e8", "filename": "src/test/compile-fail/dead-code-be.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-be.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7fbdcb0e34ee09ae106026e1857777829611bcb6", "filename": "src/test/compile-fail/dead-code-ret.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdead-code-ret.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e13db876ae52c92c0170aaa80720a2d228df13c8", "filename": "src/test/compile-fail/direct-obj-fn-call.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdirect-obj-fn-call.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7a00f22191db659adde15e830eb4404194fbae37", "filename": "src/test/compile-fail/export.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fexport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fexport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fexport.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "2762b54f98dc6c8f97d22d234362301e824c5501", "filename": "src/test/compile-fail/fru-extra-field.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-extra-field.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c15683c85f46dba2c6221626d3400b2fbc2691fe", "filename": "src/test/compile-fail/fru-typestate.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffru-typestate.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "811d595aade10c69ab341ffb5e5a6de02a2f9128", "filename": "src/test/compile-fail/impure-pred.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "19aea09032fbc6f0208eea9f662ad5a665652718", "filename": "src/test/compile-fail/infinite-tag-type-recursion.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-tag-type-recursion.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7c82700accb7f7a1d71f4eb1a5da0abfefce83ea", "filename": "src/test/compile-fail/infinite-vec-type-recursion.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Finfinite-vec-type-recursion.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "2f5f003fae2879df60230dc000baa227c9b15c91", "filename": "src/test/compile-fail/io-infects-caller.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fio-infects-caller.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c8a5df9c325a558eb6b4f26cd049209283c8ffc4", "filename": "src/test/compile-fail/log-type-error.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Flog-type-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Flog-type-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flog-type-error.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "d6e77b0d991002a1a3f82a294b4aa6a707800819", "filename": "src/test/compile-fail/native-makes-unsafe.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fnative-makes-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fnative-makes-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnative-makes-unsafe.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4a899512e31ea5819fcb32882276b9d097a6aab8", "filename": "src/test/compile-fail/not-a-pred.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c979f06596267256884468ed5fd1deb60f44fec6", "filename": "src/test/compile-fail/output-type-mismatch.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Foutput-type-mismatch.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "cf31b8bdf0b4c9c57d2ff3deb8d7a713ea7506c1", "filename": "src/test/compile-fail/pred-on-wrong-slots.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "83736d5e1660500f143dc019dbd088b6d89b2c56", "filename": "src/test/compile-fail/rec-missing-fields.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frec-missing-fields.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3711716927a39b6dc5ebec4b71daa455f3acf804", "filename": "src/test/compile-fail/return-uninit.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Freturn-uninit.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "1da8df840c1b4d2324b32fcb20fb19beb3a4fd76", "filename": "src/test/compile-fail/slot-as-pred.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4d869bba2399d06f8bb754591047b5fe6aea033a", "filename": "src/test/compile-fail/spawn-non-nil-fn.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fspawn-non-nil-fn.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8f8aff9a623c5b6c284a653e9ad6e5c5dfe1ea31", "filename": "src/test/compile-fail/type-shadow.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-shadow.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "45a93798fed4e7459c1a61603f26a7746858639a", "filename": "src/test/compile-fail/unnecessary-io.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-io.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "6705bf3464582789730fec2c19d75c667100377c", "filename": "src/test/compile-fail/unnecessary-unsafe.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funnecessary-unsafe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funnecessary-unsafe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funnecessary-unsafe.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "28daea6c9f5a23cc51d79f71cddb6a3785d44dbb", "filename": "src/test/compile-fail/unsafe-infects-caller.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funsafe-infects-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Funsafe-infects-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe-infects-caller.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "1de89e909dafb3593aae63bd4053341dfe9885af", "filename": "src/test/compile-fail/while-bypass.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-bypass.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9077c18fd62f42c5d9bb8665e942108ad37df500", "filename": "src/test/compile-fail/while-expr.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-expr.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "07d7867e9901838fd3b915a36f1e3c2550d64bd1", "filename": "src/test/compile-fail/while-type-error.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-type-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwhile-type-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwhile-type-error.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b3d21521abf4923e7c23f982d79cdbfa5bb7ada0", "filename": "src/test/compile-fail/writing-through-read-alias.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwriting-through-read-alias.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "cb0e37e5ce875d2da5f1c2bc2a971de6cf0b2f60", "filename": "src/test/run-fail/explicit-fail.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fexplicit-fail.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8808b8c890f9003459f21a03a1bb97069be0e4dc", "filename": "src/test/run-fail/fail.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Ffail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Ffail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffail.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "419fa0f3fd460579ac70cdc89a995d0f8c24701c", "filename": "src/test/run-fail/linked-failure.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Flinked-failure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Flinked-failure.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e5456a5eebd6637f9a921f46062beeb301d81402", "filename": "src/test/run-fail/pred.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpred.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7d5a12cb89a5e4722be24ddbfbc61ee0721d097c", "filename": "src/test/run-fail/str-overrun.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fstr-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fstr-overrun.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e646a107113849cde1ba3ac39b6dd7ccce92948b", "filename": "src/test/run-fail/vec-overrun.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fvec-overrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-overrun.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c9073030300d7c9684f97be00fe0a2b8008045b4", "filename": "src/test/run-fail/vec-underrun.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-fail%2Fvec-underrun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fvec-underrun.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b549cffeef6e279bc5a8bedd356d0db129585a14", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "d40c4eecbc7adb8667db0e3247507e6bb27566b3", "filename": "src/test/run-pass/alt-tag.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Falt-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Falt-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falt-tag.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "92d5fcc6e664865d6e3d9011b623d4ebd188576f", "filename": "src/test/run-pass/argv.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fargv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fargv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fargv.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "95e4bff89e477962aa813826510a82f00e5ffe38", "filename": "src/test/run-pass/basic.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbasic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbasic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbasic.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8780b22a002d891b38f591cd86bb2264d24e71e4", "filename": "src/test/run-pass/bind-obj-ctor.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-obj-ctor.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "be6e1b24e133e70402749234a0a473082f40b1f5", "filename": "src/test/run-pass/bind-thunk.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-thunk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-thunk.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "fbd6e78d797bd7ecb6bfc664b4e2bf2f071f1519", "filename": "src/test/run-pass/bind-trivial.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbind-trivial.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbind-trivial.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "36b58a9172632a71d05f61c89b4c2b508bb7690c", "filename": "src/test/run-pass/bitwise.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbitwise.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbitwise.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbitwise.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "821ac74cc05dfdfbbed87a49a43c41d652569324", "filename": "src/test/run-pass/box-unbox.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fbox-unbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbox-unbox.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "ee2fb186d9409abf30bd625ed8463e94843f3d57", "filename": "src/test/run-pass/cast.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcast.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "123f2eb26c42ea017a405d1ed2627a5be7c3fabc", "filename": "src/test/run-pass/char.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fchar.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7de90425a35b3d241ac96028c4e277de35548961", "filename": "src/test/run-pass/clone-with-exterior.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclone-with-exterior.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "129b3bdc18e3c4982c3ada11e90dde7f415e5b2f", "filename": "src/test/run-pass/comm.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomm.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "5801f34cf15d1e0bbdd115a8dd2115ae0770d615", "filename": "src/test/run-pass/command-line-args.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcommand-line-args.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3a6c13f3136fcfee1efae350cea66a5c512f3767", "filename": "src/test/run-pass/complex.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcomplex.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "208d62e4296918235227d6abdf9de06eb24f2670", "filename": "src/test/run-pass/dead-code-one-arm-if.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdead-code-one-arm-if.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "5131c42b0fe001b5dc8a62f125251076066fdcf8", "filename": "src/test/run-pass/deep.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdeep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdeep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeep.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "cfa0fbe9c1776ed1fc81e87cf4a13ff0409b106c", "filename": "src/test/run-pass/div-mod.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdiv-mod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiv-mod.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9ebbe3ae47e183ee097fa017f20a25679daf7af5", "filename": "src/test/run-pass/drop-on-ret.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdrop-on-ret.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9e3eac149fd803af352bb22c363971c178989855", "filename": "src/test/run-pass/else-if.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Felse-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Felse-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Felse-if.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c0f1843fb1506375b8fb124f76f85fdaf5ac68a5", "filename": "src/test/run-pass/export-non-interference.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexport-non-interference.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "bb0b91eb52cff5f528d425b301d531a17657985a", "filename": "src/test/run-pass/exterior.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fexterior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fexterior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexterior.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "91cf099c3acb09e51cdf79c6a3a486bfe2d96002", "filename": "src/test/run-pass/fact.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffact.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffact.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffact.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "43d8b5c33a897c81de8127973792d464600e32ad", "filename": "src/test/run-pass/foreach-put-structured.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-put-structured.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "efc6e8ca7025c8c933002888648e67b168bf77a2", "filename": "src/test/run-pass/foreach-simple-outer-slot.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple-outer-slot.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "df0551aa6a9670cb39c14e0e9020eac4fa4fa553", "filename": "src/test/run-pass/foreach-simple.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fforeach-simple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fforeach-simple.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "59446b4a771eb8edaa268b7967b9c23b88c7b2c6", "filename": "src/test/run-pass/fun-call-variants.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-call-variants.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "10c2cf40505504b43815d84c4e4a176ed2917d0d", "filename": "src/test/run-pass/fun-indirect-call.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffun-indirect-call.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9ed493a2322f38c5da7e5273adc211a58dbb172a", "filename": "src/test/run-pass/generic-derived-type.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-derived-type.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3b439b817babb589bf6879293d10c2d41e779390", "filename": "src/test/run-pass/generic-drop-glue.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-drop-glue.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "797b0f6f28c1ad0ff32b2ab4b1c3eadb32a5287f", "filename": "src/test/run-pass/generic-exterior-box.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-exterior-box.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e24cf845f9c6a9b891ae8c84aa4641fac927a124", "filename": "src/test/run-pass/generic-fn-infer.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn-infer.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "68e5fa5b37928c838e283cad30582bc5a95cc1cc", "filename": "src/test/run-pass/generic-fn.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-fn.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c902420e9ce3194097e26b9dd2d1003757a6b099", "filename": "src/test/run-pass/generic-obj-with-derived-type.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj-with-derived-type.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "f67fef4fe10bfe42ab184cb61731dd03375bd085", "filename": "src/test/run-pass/generic-obj.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-obj.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "7cae581ba71f4fc83b81f0bbd47a11609357c9fd", "filename": "src/test/run-pass/generic-recursive-tag.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-recursive-tag.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "1fcf2c3872e59d3e6c553199bfa2d75ca7ca4b3b", "filename": "src/test/run-pass/generic-tag-alt.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag-alt.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9a98ead5073e27d85862302acf9ac4f859257864", "filename": "src/test/run-pass/generic-tag.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-tag.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4ddc8946ba413f4ba195d52233a69e54eb733010", "filename": "src/test/run-pass/generic-type-synonym.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type-synonym.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "6638cebfeeaf76497c20a6f1714da18af3d8cd82", "filename": "src/test/run-pass/generic-type.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fgeneric-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-type.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8535f74eb4792f1c3b7665871734617ca709961e", "filename": "src/test/run-pass/hello.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fhello.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fhello.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhello.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "99bd39364596b9bae8568552074473c0cbd35241", "filename": "src/test/run-pass/i32-sub.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fi32-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi32-sub.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "57029a13ae937fe8b6a01d03ea36d6c8aef2a88d", "filename": "src/test/run-pass/i8-incr.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fi8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi8-incr.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "76de0d18707118df38ca188307efd2507d80cc80", "filename": "src/test/run-pass/import.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fimport.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "f5066b6e038ccb8848985689666a0e3ea8f871a9", "filename": "src/test/run-pass/inner-module.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Finner-module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Finner-module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finner-module.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "39cd48f022fc9c8e5cd28cb565c598e5d27583a1", "filename": "src/test/run-pass/int.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fint.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "0de2aa1bf198490bb9898aee97e423af87e0d554", "filename": "src/test/run-pass/large-records.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flarge-records.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flarge-records.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flarge-records.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "81f09843826bc5a846112c161a141c337900168a", "filename": "src/test/run-pass/lazy-and-or.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flazy-and-or.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazy-and-or.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "9d560bd916a2ef46319a431860e0511f9217dc37", "filename": "src/test/run-pass/lazychan.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flazychan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flazychan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flazychan.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4312aea86d82cd2a6fa8beee2d9a3e310cfef127", "filename": "src/test/run-pass/linear-for-loop.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flinear-for-loop.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "38601f8f4e6f4aba144bb1842aa036fbc2ae2840", "filename": "src/test/run-pass/list.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flist.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3776d38e1124d9b1ad77adf84ac4c369750c57dd", "filename": "src/test/run-pass/many.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmany.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "3875c5c25023843fa8f699b6cda114a584f4ba9d", "filename": "src/test/run-pass/mlist-cycle.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist-cycle.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "ba71aa5837a0d6bbc96d70af7287051b0369ebc4", "filename": "src/test/run-pass/mlist.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmlist.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "df3b55ee6d7f6d38c83dfdd2a890170b8a2a3f11", "filename": "src/test/run-pass/mutable-vec-drop.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutable-vec-drop.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "850858a3b23c556a1f1b74cc131fe0707a262841", "filename": "src/test/run-pass/mutual-recursion-group.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmutual-recursion-group.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "546b22916cac9c970e4caa49cf64900969bf71af", "filename": "src/test/run-pass/native-mod-src/inner.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-mod-src%2Finner.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4fcf4499e75b44c6663c0c3b8a7ef1d627923f97", "filename": "src/test/run-pass/native-mod.rc", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-mod.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-mod.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-mod.rc?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "19c2c074f9d7cb5fc0b5749430606c03b267e653", "filename": "src/test/run-pass/native-opaque-type.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-opaque-type.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "226580955d3fb607f93aabecb553b8ab70fba582", "filename": "src/test/run-pass/native-src/native.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative-src%2Fnative.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c0f019c54998025b452ffcec5f0c2f9cb34cb5d7", "filename": "src/test/run-pass/native.rc", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative.rc", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fnative.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnative.rc?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "62eda294838961bd8778cffef875f833a4426568", "filename": "src/test/run-pass/obj-as.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-as.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-as.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-as.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "6d4ca3d457b0857d071c6270d53ad8550dc69774", "filename": "src/test/run-pass/obj-drop.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-drop.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "8b79047b16d38ca8e2306bc2fad811994acd375d", "filename": "src/test/run-pass/obj-dtor.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-dtor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-dtor.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "169889a37a8b2a7893a8f96b9e3f592659dbbe12", "filename": "src/test/run-pass/obj-with-vec.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fobj-with-vec.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "d99ebb0449a3187c2e81594df52b1e77f0810a00", "filename": "src/test/run-pass/opeq.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fopeq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fopeq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fopeq.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b3338f383d3e1e18358737cce1aecb5545735044", "filename": "src/test/run-pass/pred.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpred.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "00fc29cae729c99361486a699ecf656bfe905ba4", "filename": "src/test/run-pass/preempt.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fpreempt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fpreempt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpreempt.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "15fa142a77a5a76acc3331965dd42b15a5c17cf3", "filename": "src/test/run-pass/readalias.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Freadalias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Freadalias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freadalias.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "01390acd551d7f943c3c5bd69a57636075f23eb6", "filename": "src/test/run-pass/rec-auto.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-auto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-auto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-auto.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "db81278b35c7b63c7a47d7d3ab6ad2ed3209404b", "filename": "src/test/run-pass/rec-extend.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-extend.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e25439a974daa1aa5e6da4b1b75fb49d33f38c89", "filename": "src/test/run-pass/rec-tup.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-tup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec-tup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec-tup.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "0f6b7d79196ab3641a468dc6f73709a71a588910", "filename": "src/test/run-pass/rec.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Frec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frec.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c3c8a085b77189afeda8231ed1b4d99ad27a1a14", "filename": "src/test/run-pass/return-nil.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Freturn-nil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Freturn-nil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Freturn-nil.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b465a7d3754ee39d7fb2d2142c1238c2d4c7439a", "filename": "src/test/run-pass/simple-obj.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fsimple-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fsimple-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsimple-obj.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "894a8321528ef33b0375f703e67d9abcdf54d039", "filename": "src/test/run-pass/spawn-fn.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fspawn-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn-fn.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "765d4c9e25af0ee4d0eda3b1b270746b5862f5dc", "filename": "src/test/run-pass/spawn.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fspawn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fspawn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspawn.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c1d96cc3debee5e453521dee215d62da88e6f02b", "filename": "src/test/run-pass/stateful-obj.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstateful-obj.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstateful-obj.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "92d8ab89c6a585a5b40cd4a7e46ae3c63f11dee4", "filename": "src/test/run-pass/str-append.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-append.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "874a379b9d99b39cd38710aecd589f04c708f9ae", "filename": "src/test/run-pass/str-concat.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-concat.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "2f39dea9480859abd50fca9106370ac055f6f052", "filename": "src/test/run-pass/str-idx.rs", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fstr-idx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstr-idx.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "35f0f2d8deaddebe03a3221fb6fa5f909699bba7", "filename": "src/test/run-pass/syntax-extension.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fsyntax-extension.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fsyntax-extension.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsyntax-extension.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "0d345b2d98852ac17e1cbaaa4b11d471159e972a", "filename": "src/test/run-pass/tag.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftag.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "795a105ad92721b449fc6ba1f41d3c4c33f3fd41", "filename": "src/test/run-pass/tail-cps.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftail-cps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-cps.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "345a322eb171a8ed11ef7115394b3f4d78d42646", "filename": "src/test/run-pass/tail-direct.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftail-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftail-direct.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4a21b4e4388bf359d4f1d6c2c36399022eb248da", "filename": "src/test/run-pass/task-comm.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftask-comm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-comm.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b0fee65f8f38c172af99c77aa29bb1420d00607d", "filename": "src/test/run-pass/threads.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fthreads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fthreads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthreads.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "234066460eff3366cdf54bc7edd6a4c700435b54", "filename": "src/test/run-pass/tup.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftup.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "40f9dbad9975f06f70da14842f31f626db1eb7c4", "filename": "src/test/run-pass/type-sizes.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Ftype-sizes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftype-sizes.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "15d5bcaa17a400d233b3b24f244dbedaacb1e4ad", "filename": "src/test/run-pass/u32-decr.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu32-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu32-decr.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "e8c29d4fe83f386c51731be10d58b55091cba2bc", "filename": "src/test/run-pass/u8-incr-decr.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr-decr.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "c3c1aef48577b90c673e6db8c31c1f2485f8d4db", "filename": "src/test/run-pass/u8-incr.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fu8-incr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu8-incr.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "924ff469f56bff8d65a7b524e546b078b0ffa9c6", "filename": "src/test/run-pass/uint.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuint.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "ce24eabe96fb7e842f69b349c6ca36150046d956", "filename": "src/test/run-pass/unit.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Funit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Funit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funit.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "82d3234a133cb7bcd47d6c0be767a231078522d1", "filename": "src/test/run-pass/user.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fuser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fuser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fuser.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "fd70423ac10cd74167416794e0ae71a07a4d44d2", "filename": "src/test/run-pass/utf8.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Futf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Futf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Futf8.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "4324ee252823514f31f300cd7a33dffdb4a639c5", "filename": "src/test/run-pass/vec-append.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-append.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "b6c52c3e08d7404656bd4ded8042eb8af0009040", "filename": "src/test/run-pass/vec-concat.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-concat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-concat.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "267c7a7864ea69e068d18bd3a55e19180cbfc29d", "filename": "src/test/run-pass/vec-drop.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-drop.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "332eff346f9c99581a831e5049728289a2ccda69", "filename": "src/test/run-pass/vec-slice.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec-slice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-slice.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "67a41eabcf6e29a288726234f7d3961afd00fa04", "filename": "src/test/run-pass/vec.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "96b2a9d7f330932fce9077fac5cab2d431300cc9", "filename": "src/test/run-pass/writealias.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fwritealias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fwritealias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwritealias.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "d2ae592a80acd02de78cd61b3035e2d368d68dfa", "filename": "src/test/run-pass/yield.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fyield.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fyield.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}, {"sha": "11285822a7e8449699b55c4c213c54ee24a0319d", "filename": "src/test/run-pass/yield2.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fyield2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6b7c96c3eb29b9244ece0c046d3f372ff432d04/src%2Ftest%2Frun-pass%2Fyield2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fyield2.rs?ref=d6b7c96c3eb29b9244ece0c046d3f372ff432d04"}]}