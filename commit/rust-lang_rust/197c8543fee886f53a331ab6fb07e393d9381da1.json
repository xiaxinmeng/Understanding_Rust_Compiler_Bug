{"sha": "197c8543fee886f53a331ab6fb07e393d9381da1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5N2M4NTQzZmVlODg2ZjUzYTMzMWFiNmZiMDdlMzkzZDkzODFkYTE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-26T18:28:23Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-10-26T18:47:42Z"}, "message": "Add more std documentation", "tree": {"sha": "41c9a156b5f6f2f11889957346051f3d57a9db58", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41c9a156b5f6f2f11889957346051f3d57a9db58"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/197c8543fee886f53a331ab6fb07e393d9381da1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/197c8543fee886f53a331ab6fb07e393d9381da1", "html_url": "https://github.com/rust-lang/rust/commit/197c8543fee886f53a331ab6fb07e393d9381da1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/197c8543fee886f53a331ab6fb07e393d9381da1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c0b0309e3e86ba917df2a1424630f0b34483410", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c0b0309e3e86ba917df2a1424630f0b34483410", "html_url": "https://github.com/rust-lang/rust/commit/4c0b0309e3e86ba917df2a1424630f0b34483410"}], "stats": {"total": 232, "additions": 212, "deletions": 20}, "files": [{"sha": "c83e0d86ca96edb1bc98fae0bf04cec966717df9", "filename": "doc/Languages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/197c8543fee886f53a331ab6fb07e393d9381da1/doc%2FLanguages.txt", "raw_url": "https://github.com/rust-lang/rust/raw/197c8543fee886f53a331ab6fb07e393d9381da1/doc%2FLanguages.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2FLanguages.txt?ref=197c8543fee886f53a331ab6fb07e393d9381da1", "patch": "@@ -122,3 +122,4 @@ Language: Rust\n    Function Prototype Enders: ; {\n    Type Prototype Enders: ; }\n    Class Prototype Enders: {\n+   Variant Prototype Enders: ;"}, {"sha": "d368b609275e3818c30f9453629732d1073858f0", "filename": "src/lib/list.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Flist.rs?ref=197c8543fee886f53a331ab6fb07e393d9381da1", "patch": "@@ -1,7 +1,30 @@\n+/*\n+Module: list\n+\n+A standard linked list\n+*/\n+\n import option::{some, none};\n \n-tag list<T> { cons(T, @list<T>); nil; }\n+/* Section: Types */\n+\n+/*\n+Tag: list\n+*/\n+tag list<T> {\n+    /* Variant: cons */\n+    cons(T, @list<T>);\n+    /* Variant: nil */\n+    nil;\n+}\n+\n+/*Section: Operations */\n \n+/*\n+Function: from_vec\n+\n+Create a list from a vector\n+*/\n fn from_vec<T>(v: [T]) -> list<T> {\n     let l = nil::<T>;\n     // FIXME: This would be faster and more space efficient if it looped over\n@@ -12,6 +35,21 @@ fn from_vec<T>(v: [T]) -> list<T> {\n     ret l;\n }\n \n+/*\n+Function: foldl\n+\n+Left fold\n+\n+Applies `f` to the first argument in the list and `u`, then applies\n+`f` to the second argument and the result of the previous call,\n+and so on, returning the accumulated result.\n+\n+Parameters:\n+\n+ls_ - The list to fold\n+u - The initial value\n+f - The function to apply\n+*/\n fn foldl<T, U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n     let accum: U = u;\n     let ls = ls_;\n@@ -24,6 +62,15 @@ fn foldl<T, U>(ls_: list<T>, u: U, f: block(T, U) -> U) -> U {\n     ret accum;\n }\n \n+/*\n+Function: find\n+\n+Search for an element that matches a given predicate\n+\n+Apply function `f` to each element of `v`, starting from the first.\n+When function `f` returns true then an option containing the element\n+is returned. If `f` matches no elements then none is returned.\n+*/\n fn find<T, U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n     let ls = ls_;\n     while true {\n@@ -37,6 +84,11 @@ fn find<T, U>(ls_: list<T>, f: block(T) -> option::t<U>) -> option::t<U> {\n     ret none;\n }\n \n+/*\n+Function: has\n+\n+Returns true if a list contains an element with the given value\n+*/\n fn has<T>(ls_: list<T>, elt: T) -> bool {\n     let ls = ls_;\n     while true {\n@@ -48,19 +100,39 @@ fn has<T>(ls_: list<T>, elt: T) -> bool {\n     ret false;\n }\n \n+/*\n+Function: length\n+\n+Returns the length of a list\n+*/\n fn length<T>(ls: list<T>) -> uint {\n     fn count<T>(_t: T, &&u: uint) -> uint { ret u + 1u; }\n     ret foldl(ls, 0u, bind count(_, _));\n }\n \n+/*\n+Function: cdr\n+\n+Returns all but the first element of a list\n+*/\n fn cdr<T>(ls: list<T>) -> list<T> {\n     alt ls { cons(_, tl) { ret *tl; } nil. { fail \"list empty\" } }\n }\n \n+/*\n+Function: car\n+\n+Returns the first element of a list\n+*/\n fn car<T>(ls: list<T>) -> T {\n     alt ls { cons(hd, _) { ret hd; } nil. { fail \"list empty\" } }\n }\n \n+/*\n+Function: append\n+\n+Appends one list to another\n+*/\n fn append<T>(l: list<T>, m: list<T>) -> list<T> {\n     alt l {\n       nil. { ret m; }"}, {"sha": "b89e5817688baabda67d2aadcd81ae0763690098", "filename": "src/lib/map.rs", "status": "modified", "additions": 130, "deletions": 18, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmap.rs?ref=197c8543fee886f53a331ab6fb07e393d9381da1", "patch": "@@ -1,27 +1,119 @@\n-/**\n- * Hashmap implementation.\n- */\n+/*\n+Module: map\n+\n+A hashmap\n+*/\n+\n+/* Section: Types */\n+\n+/*\n+Type: hashfn\n+\n+A function that returns a hash of a value\n+*/\n type hashfn<K> = fn(K) -> uint;\n \n+/*\n+Type: eqfn\n+\n+Equality\n+*/\n type eqfn<K> = fn(K, K) -> bool;\n \n-type hashmap<K, V> =\n-    obj {\n-        fn size() -> uint;\n-        fn insert(K, V) -> bool;\n-        fn contains_key(K) -> bool;\n-        fn get(K) -> V;\n-        fn find(K) -> option::t<V>;\n-        fn remove(K) -> option::t<V>;\n-        fn rehash();\n-        fn items(block(K, V));\n-        fn keys(block(K));\n-        fn values(block(V));\n-    };\n+/*\n+Type: hashset\n+\n+A convenience type to treat a hashmap as a set\n+*/\n type hashset<K> = hashmap<K, ()>;\n \n-fn set_add<K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n+/*\n+Obj: hashmap\n+*/\n+type hashmap<K, V> = obj {\n+    /*\n+    Method: size\n+\n+    Return the number of elements in the map\n+    */\n+    fn size() -> uint;\n+    /*\n+    Method: insert\n+\n+    Add a value to the map. If the map already contains a value for\n+    the specified key then the original value is replaced.\n+\n+    Returns:\n+\n+    True if the key did not already exist in the map\n+    */\n+    fn insert(K, V) -> bool;\n+    /*\n+    Method: contains_key\n+\n+    Returns true if the map contains a value for the specified key\n+    */\n+    fn contains_key(K) -> bool;\n+    /*\n+    Method: get\n+\n+    Get the value for the specified key\n+\n+    Failure:\n+\n+    If the key does not exist in the map\n+    */\n+    fn get(K) -> V;\n+    /*\n+    Method: find\n \n+    Get the value for the specified key. If the key does not exist\n+    in the map then returns none.\n+    */\n+    fn find(K) -> option::t<V>;\n+    /*\n+    Method: remove\n+\n+    Remove and return a value from the map. If the key does not exist\n+    in the map then returns none.\n+    */\n+    fn remove(K) -> option::t<V>;\n+    /*\n+    Method: rehash\n+\n+    Force map growth and rehashing\n+    */\n+    fn rehash();\n+    /*\n+    Method: items\n+\n+    Iterate over all the key/value pairs in the map\n+    */\n+    fn items(block(K, V));\n+    /*\n+    Method: keys\n+\n+    Iterate over all the keys in the map\n+    */\n+    fn keys(block(K));\n+    /*\n+    Iterate over all the values in the map\n+    */\n+    fn values(block(V));\n+};\n+\n+/* Section: Operations */\n+\n+/*\n+Function: mk_hashmap\n+\n+Construct a hashmap\n+\n+Parameters:\n+\n+hasher - The hash function for key type K\n+eqer - The equality function for key type K\n+*/\n fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n     let initial_capacity: uint = 32u; // 2^5\n \n@@ -194,24 +286,44 @@ fn mk_hashmap<K, V>(hasher: hashfn<K>, eqer: eqfn<K>) -> hashmap<K, V> {\n     ret hashmap(hasher, eqer, bkts, initial_capacity, 0u, load_factor);\n }\n \n-// Hash map constructors for basic types\n+/*\n+Function: new_str_hash\n \n+Construct a hashmap for string keys\n+*/\n fn new_str_hash<V>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n+/*\n+Function: new_int_hash\n+\n+Construct a hashmap for int keys\n+*/\n fn new_int_hash<V>() -> hashmap<int, V> {\n     fn hash_int(&&x: int) -> uint { ret x as uint; }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n \n+/*\n+Function: new_uint_hash\n+\n+Construct a hashmap for uint keys\n+*/\n fn new_uint_hash<V>() -> hashmap<uint, V> {\n     fn hash_uint(&&x: uint) -> uint { ret x; }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n }\n \n+/*\n+Function: set_add\n+\n+Convenience function for adding keys to a hashmap with nil type keys\n+*/\n+fn set_add<K>(set: hashset<K>, key: K) -> bool { ret set.insert(key, ()); }\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "c9a27f0eca9a673923f63dcdf746dfc5faad7ced", "filename": "src/lib/math.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fmath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fmath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fmath.rs?ref=197c8543fee886f53a331ab6fb07e393d9381da1", "patch": "@@ -1,3 +1,5 @@\n+/* Module: math */\n+\n native \"llvm\" mod llvm {\n     fn sqrt(n: float) -> float = \"sqrt.f64\";\n     fn sin(n: float) -> float = \"sin.f64\";"}, {"sha": "c4d68590b4d891b4dc2c1fa3d7b7f3fc87803abf", "filename": "src/lib/vec.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/197c8543fee886f53a331ab6fb07e393d9381da1/src%2Flib%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fvec.rs?ref=197c8543fee886f53a331ab6fb07e393d9381da1", "patch": "@@ -36,6 +36,11 @@ fn reserve<T>(&v: [mutable? T], n: uint) {\n     rustrt::vec_reserve_shared(sys::get_type_desc::<T>(), v, n);\n }\n \n+/*\n+Function: len\n+\n+Returns the length of a vector\n+*/\n pure fn len<T>(v: [mutable? T]) -> uint { unchecked { rusti::vec_len(v) } }\n \n /*\n@@ -479,7 +484,7 @@ Function: find\n Search for an element that matches a given predicate\n \n Apply function `f` to each element of `v`, starting from the first.\n-When function `f` matches then an option containing the element\n+When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n */\n fn find<T>(f: block(T) -> bool, v: [T]) -> option::t<T> {"}]}