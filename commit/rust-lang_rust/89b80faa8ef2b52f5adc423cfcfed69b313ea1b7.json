{"sha": "89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5YjgwZmFhOGVmMmI1MmY1YWRjNDIzY2ZjZmVkNjliMzEzZWExYjc=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-16T15:01:02Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2015-01-18T00:37:34Z"}, "message": "Register new snapshots.", "tree": {"sha": "6398229035eb8fac2a35fe6eb3a72d3efad3dd12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6398229035eb8fac2a35fe6eb3a72d3efad3dd12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "html_url": "https://github.com/rust-lang/rust/commit/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f4f10dba2975b51c2d2c92157018db3ac13d4d4a", "html_url": "https://github.com/rust-lang/rust/commit/f4f10dba2975b51c2d2c92157018db3ac13d4d4a"}], "stats": {"total": 650, "additions": 173, "deletions": 477}, "files": [{"sha": "8e3b19ad70aff7ff16b52c822515759a01d4ef5b", "filename": "mk/main.mk", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -333,7 +333,6 @@ export CFG_DISABLE_UNSTABLE_FEATURES\n endif\n # Subvert unstable feature lints to do the self-build\n export CFG_BOOTSTRAP_KEY\n-export RUSTC_BOOTSTRAP_KEY:=$(CFG_BOOTSTRAP_KEY)\n \n ######################################################################\n # Per-stage targets and runner\n@@ -404,8 +403,13 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n ifeq ($(1),0)\n # Don't run the stage0 compiler under valgrind - that ship has sailed\n CFG_VALGRIND_COMPILE$(1) =\n+# FIXME(21230) HACK Extract the key from the snapshot\n+CFG_BOOSTRAP_KEY_ENV$(1) = RUSTC_BOOTSTRAP_KEY=$$$$((grep -a 'save analysis[0-9]' \\\n+\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) || echo N) |\\\n+\tsed 's/.*save analysis\\([0-9]*\\).*/\\1/')\n else\n CFG_VALGRIND_COMPILE$(1) = $$(CFG_VALGRIND_COMPILE)\n+CFG_BOOSTRAP_KEY_ENV$(1) = RUSTC_BOOTSTRAP_KEY=$$(CFG_BOOTSTRAP_KEY)\n endif\n \n # Add RUSTFLAGS_STAGEN values to the build command\n@@ -478,6 +482,7 @@ STAGE$(1)_T_$(2)_H_$(3) := \\\n \t$$(Q)$$(RPATH_VAR$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(call CFG_RUN_TARG_$(3),$(1), \\\n \t\t$$(CFG_VALGRIND_COMPILE$(1)) \\\n+\t\t$$(CFG_BOOSTRAP_KEY_ENV$(1)) \\\n \t\t$$(HBIN$(1)_H_$(3))/rustc$$(X_$(3)) \\\n \t\t--cfg $$(CFGFLAG$(1)_T_$(2)_H_$(3)) \\\n \t\t$$(CFG_RUSTC_FLAGS) $$(EXTRAFLAGS_STAGE$(1)) --target=$(2)) \\"}, {"sha": "8ad0c152dc8ed61a5758a35148f46556f161bf6d", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -117,14 +117,6 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n #[stable]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "7191a7af346b08eccf908429b31d48df07405d50", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -686,14 +686,6 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n-#[cfg(stage0)]\n-impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "3ac6b2775bfa86ece9816ae21b5e30d85c1ad312", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -24,8 +24,6 @@ use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n use core::hash::{Hash, Hasher};\n-#[cfg(stage0)]\n-use core::hash::Writer;\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n@@ -822,16 +820,6 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n }\n \n #[stable]\n-#[cfg(stage0)]\n-impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n-    fn hash(&self, state: &mut S) {\n-        for elt in self.iter() {\n-            elt.hash(state);\n-        }\n-    }\n-}\n-#[stable]\n-#[cfg(not(stage0))]\n impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {"}, {"sha": "5d35d8a86795a57ad50202612c75ddc52d5a4d6d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -830,15 +830,6 @@ impl fmt::Show for String {\n }\n \n #[unstable = \"waiting on Hash stabilization\"]\n-#[cfg(stage0)]\n-impl<H: hash::Writer> hash::Hash<H> for String {\n-    #[inline]\n-    fn hash(&self, hasher: &mut H) {\n-        (**self).hash(hasher)\n-    }\n-}\n-#[unstable = \"waiting on Hash stabilization\"]\n-#[cfg(not(stage0))]\n impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {"}, {"sha": "38658a17e9b4dc71dd8a8e2b1352ccbc2164b9f3", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -1185,14 +1185,6 @@ impl<T:Clone> Clone for Vec<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.as_slice().hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {"}, {"sha": "535722f93bfd62382e580c9c85c67dade92f4891", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -180,25 +180,6 @@ impl<'a> Arguments<'a> {\n     /// unsafety, but will ignore invalid .\n     #[doc(hidden)] #[inline]\n     #[unstable = \"implementation detail of the `format_args!` macro\"]\n-    #[cfg(stage0)] // SNAP 9e4e524\n-    pub fn with_placeholders(pieces: &'a [&'a str],\n-                             fmt: &'a [rt::Argument<'a>],\n-                             args: &'a [Argument<'a>]) -> Arguments<'a> {\n-        Arguments {\n-            pieces: pieces,\n-            fmt: Some(fmt),\n-            args: args\n-        }\n-    }\n-    /// This function is used to specify nonstandard formatting parameters.\n-    /// The `pieces` array must be at least as long as `fmt` to construct\n-    /// a valid Arguments structure. Also, any `Count` within `fmt` that is\n-    /// `CountIsParam` or `CountIsNextParam` has to point to an argument\n-    /// created with `argumentuint`. However, failing to do so doesn't cause\n-    /// unsafety, but will ignore invalid .\n-    #[doc(hidden)] #[inline]\n-    #[unstable = \"implementation detail of the `format_args!` macro\"]\n-    #[cfg(not(stage0))]\n     pub fn with_placeholders(pieces: &'a [&'a str],\n                              fmt: &'a [rt::Argument],\n                              args: &'a [Argument<'a>]) -> Arguments<'a> {\n@@ -226,10 +207,6 @@ pub struct Arguments<'a> {\n     pieces: &'a [&'a str],\n \n     // Placeholder specs, or `None` if all specs are default (as in \"{}{}\").\n-    // SNAP 9e4e524\n-    #[cfg(stage0)]\n-    fmt: Option<&'a [rt::Argument<'a>]>,\n-    #[cfg(not(stage0))]\n     fmt: Option<&'a [rt::Argument]>,\n \n     // Dynamic arguments for interpolation, to be interleaved with string"}, {"sha": "bea322191552b5719703ccc1e0efe5cd938245e3", "filename": "src/libcore/fmt/rt.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -21,21 +21,12 @@ pub use self::Count::*;\n pub use self::Position::*;\n pub use self::Flag::*;\n \n-// SNAP 9e4e524\n #[doc(hidden)]\n #[derive(Copy)]\n-#[cfg(not(stage0))]\n pub struct Argument {\n     pub position: Position,\n     pub format: FormatSpec,\n }\n-#[doc(hidden)]\n-#[derive(Copy)]\n-#[cfg(stage0)]\n-pub struct Argument<'a> {\n-    pub position: Position,\n-    pub format: FormatSpec,\n-}\n \n #[doc(hidden)]\n #[derive(Copy)]"}, {"sha": "37e4a105a30cb3b8ad27257a45ffd27790a0b208", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 118, "deletions": 292, "changes": 410, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -58,7 +58,13 @@\n \n #![unstable = \"module was recently redesigned\"]\n \n+use prelude::*;\n+\n+use borrow::{Cow, ToOwned};\n use default::Default;\n+use intrinsics::TypeId;\n+use mem;\n+use num::Int;\n \n pub use self::sip::SipHasher;\n \n@@ -70,19 +76,6 @@ mod sip;\n /// to compute the hash. Specific implementations of this trait may specialize\n /// for particular instances of `H` in order to be able to optimize the hashing\n /// behavior.\n-#[cfg(stage0)]\n-pub trait Hash<H> {\n-    /// Feeds this value into the state given, updating the hasher as necessary.\n-    fn hash(&self, state: &mut H);\n-}\n-\n-/// A hashable type.\n-///\n-/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n-/// to compute the hash. Specific implementations of this trait may specialize\n-/// for particular instances of `H` in order to be able to optimize the hashing\n-/// behavior.\n-#[cfg(not(stage0))]\n pub trait Hash<H: Hasher> {\n     /// Feeds this value into the state given, updating the hasher as necessary.\n     fn hash(&self, state: &mut H);\n@@ -121,314 +114,147 @@ pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n \n //////////////////////////////////////////////////////////////////////////////\n \n-#[cfg(stage0)]\n-mod impls {\n-    use prelude::*;\n-\n-    use borrow::{Cow, ToOwned};\n-    use intrinsics::TypeId;\n-    use mem;\n-    use super::{Hash, Writer};\n-    use num::Int;\n-\n-    macro_rules! impl_hash {\n-        ($ty:ident, $uty:ident) => {\n-            impl<S: Writer> Hash<S> for $ty {\n-                #[inline]\n-                fn hash(&self, state: &mut S) {\n-                    let a: [u8; ::$ty::BYTES] = unsafe {\n-                        mem::transmute((*self as $uty).to_le() as $ty)\n-                    };\n-                    state.write(a.as_slice())\n-                }\n-            }\n-        }\n-    }\n-\n-    impl_hash! { u8, u8 }\n-    impl_hash! { u16, u16 }\n-    impl_hash! { u32, u32 }\n-    impl_hash! { u64, u64 }\n-    impl_hash! { uint, uint }\n-    impl_hash! { i8, u8 }\n-    impl_hash! { i16, u16 }\n-    impl_hash! { i32, u32 }\n-    impl_hash! { i64, u64 }\n-    impl_hash! { int, uint }\n-\n-    impl<S: Writer> Hash<S> for bool {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u8).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer> Hash<S> for char {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u32).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer> Hash<S> for str {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            state.write(self.as_bytes());\n-            0xffu8.hash(state)\n-        }\n-    }\n-\n-    macro_rules! impl_hash_tuple {\n-        () => (\n-            impl<S> Hash<S> for () {\n-                #[inline]\n-                fn hash(&self, _state: &mut S) {}\n-            }\n-        );\n-\n-        ( $($name:ident)+) => (\n-            impl<S, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-                #[inline]\n-                #[allow(non_snake_case)]\n-                fn hash(&self, state: &mut S) {\n-                    match *self {\n-                        ($(ref $name,)*) => {\n-                            $(\n-                                $name.hash(state);\n-                            )*\n-                        }\n-                    }\n-                }\n-            }\n-        );\n-    }\n-\n-    impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-    impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.len().hash(state);\n-            for elt in self.iter() {\n-                elt.hash(state);\n+macro_rules! impl_hash {\n+    ($ty:ident, $uty:ident) => {\n+        impl<S: Writer + Hasher> Hash<S> for $ty {\n+            #[inline]\n+            fn hash(&self, state: &mut S) {\n+                let a: [u8; ::$ty::BYTES] = unsafe {\n+                    mem::transmute((*self as $uty).to_le() as $ty)\n+                };\n+                state.write(a.as_slice())\n             }\n         }\n     }\n-\n-\n-    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer, T> Hash<S> for *const T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer, T> Hash<S> for *mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n-    }\n-\n-    impl<S: Writer> Hash<S> for TypeId {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.hash().hash(state)\n-        }\n-    }\n-\n-    impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B>\n-        where B: Hash<S> + ToOwned<T>\n-    {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            Hash::hash(&**self, state)\n-        }\n-    }\n }\n \n-#[cfg(not(stage0))]\n-mod impls {\n-    use prelude::*;\n-\n-    use borrow::{Cow, ToOwned};\n-    use intrinsics::TypeId;\n-    use mem;\n-    use super::{Hash, Writer, Hasher};\n-    use num::Int;\n-\n-    macro_rules! impl_hash {\n-        ($ty:ident, $uty:ident) => {\n-            impl<S: Writer + Hasher> Hash<S> for $ty {\n-                #[inline]\n-                fn hash(&self, state: &mut S) {\n-                    let a: [u8; ::$ty::BYTES] = unsafe {\n-                        mem::transmute((*self as $uty).to_le() as $ty)\n-                    };\n-                    state.write(a.as_slice())\n-                }\n-            }\n-        }\n+impl_hash! { u8, u8 }\n+impl_hash! { u16, u16 }\n+impl_hash! { u32, u32 }\n+impl_hash! { u64, u64 }\n+impl_hash! { uint, uint }\n+impl_hash! { i8, u8 }\n+impl_hash! { i16, u16 }\n+impl_hash! { i32, u32 }\n+impl_hash! { i64, u64 }\n+impl_hash! { int, uint }\n+\n+impl<S: Writer + Hasher> Hash<S> for bool {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (*self as u8).hash(state);\n     }\n+}\n \n-    impl_hash! { u8, u8 }\n-    impl_hash! { u16, u16 }\n-    impl_hash! { u32, u32 }\n-    impl_hash! { u64, u64 }\n-    impl_hash! { uint, uint }\n-    impl_hash! { i8, u8 }\n-    impl_hash! { i16, u16 }\n-    impl_hash! { i32, u32 }\n-    impl_hash! { i64, u64 }\n-    impl_hash! { int, uint }\n-\n-    impl<S: Writer + Hasher> Hash<S> for bool {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u8).hash(state);\n-        }\n+impl<S: Writer + Hasher> Hash<S> for char {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (*self as u32).hash(state);\n     }\n+}\n \n-    impl<S: Writer + Hasher> Hash<S> for char {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (*self as u32).hash(state);\n-        }\n+impl<S: Writer + Hasher> Hash<S> for str {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        state.write(self.as_bytes());\n+        0xffu8.hash(state)\n     }\n+}\n \n-    impl<S: Writer + Hasher> Hash<S> for str {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            state.write(self.as_bytes());\n-            0xffu8.hash(state)\n+macro_rules! impl_hash_tuple {\n+    () => (\n+        impl<S: Hasher> Hash<S> for () {\n+            #[inline]\n+            fn hash(&self, _state: &mut S) {}\n         }\n-    }\n-\n-    macro_rules! impl_hash_tuple {\n-        () => (\n-            impl<S: Hasher> Hash<S> for () {\n-                #[inline]\n-                fn hash(&self, _state: &mut S) {}\n-            }\n-        );\n-\n-        ( $($name:ident)+) => (\n-            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-                #[inline]\n-                #[allow(non_snake_case)]\n-                fn hash(&self, state: &mut S) {\n-                    match *self {\n-                        ($(ref $name,)*) => {\n-                            $(\n-                                $name.hash(state);\n-                            )*\n-                        }\n+    );\n+\n+    ( $($name:ident)+) => (\n+        impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+            #[inline]\n+            #[allow(non_snake_case)]\n+            fn hash(&self, state: &mut S) {\n+                match *self {\n+                    ($(ref $name,)*) => {\n+                        $(\n+                            $name.hash(state);\n+                        )*\n                     }\n                 }\n             }\n-        );\n-    }\n-\n-    impl_hash_tuple! {}\n-    impl_hash_tuple! { A }\n-    impl_hash_tuple! { A B }\n-    impl_hash_tuple! { A B C }\n-    impl_hash_tuple! { A B C D }\n-    impl_hash_tuple! { A B C D E }\n-    impl_hash_tuple! { A B C D E F }\n-    impl_hash_tuple! { A B C D E F G }\n-    impl_hash_tuple! { A B C D E F G H }\n-    impl_hash_tuple! { A B C D E F G H I }\n-    impl_hash_tuple! { A B C D E F G H I J }\n-    impl_hash_tuple! { A B C D E F G H I J K }\n-    impl_hash_tuple! { A B C D E F G H I J K L }\n+        }\n+    );\n+}\n \n-    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.len().hash(state);\n-            for elt in self.iter() {\n-                elt.hash(state);\n-            }\n+impl_hash_tuple! {}\n+impl_hash_tuple! { A }\n+impl_hash_tuple! { A B }\n+impl_hash_tuple! { A B C }\n+impl_hash_tuple! { A B C D }\n+impl_hash_tuple! { A B C D E }\n+impl_hash_tuple! { A B C D E F }\n+impl_hash_tuple! { A B C D E F G }\n+impl_hash_tuple! { A B C D E F G H }\n+impl_hash_tuple! { A B C D E F G H I }\n+impl_hash_tuple! { A B C D E F G H I J }\n+impl_hash_tuple! { A B C D E F G H I J K }\n+impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.len().hash(state);\n+        for elt in self.iter() {\n+            elt.hash(state);\n         }\n     }\n+}\n \n \n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n+impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n     }\n+}\n \n-    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            (**self).hash(state);\n-        }\n+impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n     }\n+}\n \n-    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n+impl<S: Writer + Hasher, T> Hash<S> for *const T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        // NB: raw-pointer Hash does _not_ dereference\n+        // to the target; it just gives you the pointer-bytes.\n+        (*self as uint).hash(state);\n     }\n+}\n \n-    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            // NB: raw-pointer Hash does _not_ dereference\n-            // to the target; it just gives you the pointer-bytes.\n-            (*self as uint).hash(state);\n-        }\n+impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        // NB: raw-pointer Hash does _not_ dereference\n+        // to the target; it just gives you the pointer-bytes.\n+        (*self as uint).hash(state);\n     }\n+}\n \n-    impl<S: Writer + Hasher> Hash<S> for TypeId {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            self.hash().hash(state)\n-        }\n+impl<S: Writer + Hasher> Hash<S> for TypeId {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.hash().hash(state)\n     }\n+}\n \n-    impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n-        where B: Hash<S> + ToOwned<T>\n-    {\n-        #[inline]\n-        fn hash(&self, state: &mut S) {\n-            Hash::hash(&**self, state)\n-        }\n+impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n+    where B: Hash<S> + ToOwned<T>\n+{\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        Hash::hash(&**self, state)\n     }\n }"}, {"sha": "40db0def626675478b99b42c2fa835b2b8e69b64", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -42,7 +42,6 @@\n #![unstable]\n #![allow(missing_docs)]\n \n-#[cfg(not(stage0))]\n use marker::Sized;\n \n pub type GlueFn = extern \"Rust\" fn(*const i8);\n@@ -207,12 +206,8 @@ extern \"rust-intrinsic\" {\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n-    #[cfg(not(stage0))]\n     pub fn type_id<T: ?Sized + 'static>() -> TypeId;\n \n-    #[cfg(stage0)]\n-    pub fn type_id<T: 'static>() -> TypeId;\n-\n     /// Create a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,\n@@ -562,15 +557,9 @@ pub struct TypeId {\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n-    #[cfg(not(stage0))]\n     pub fn of<T: ?Sized + 'static>() -> TypeId {\n         unsafe { type_id::<T>() }\n     }\n \n-    #[cfg(stage0)]\n-    pub fn of<T: 'static>() -> TypeId {\n-        unsafe { type_id::<T>() }\n-    }\n-\n     pub fn hash(&self) -> u64 { self.t }\n }"}, {"sha": "0005db36c278a2ef78970551deea9705bfac4693", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -2753,9 +2753,9 @@ macro_rules! step_impl_no_between {\n }\n \n step_impl!(uint u8 u16 u32 int i8 i16 i32);\n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n step_impl!(u64 i64);\n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n step_impl_no_between!(u64 i64);\n \n "}, {"sha": "0b150d1ecf90bd9c7358593446f75f5f06b7761e", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -58,7 +58,6 @@\n \n #![no_std]\n #![allow(unknown_features, raw_pointer_derive)]\n-#![cfg_attr(stage0, allow(unused_attributes))]\n #![allow(unknown_features)] #![feature(intrinsics, lang_items)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]"}, {"sha": "83011db35cec85d777fefbaad7cab129db204c76", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -16,8 +16,5 @@\n \n #![deprecated = \"replaced by isize\"]\n \n-#[cfg(stage0)] #[cfg(target_word_size = \"32\")] int_module! { int, 32 }\n-#[cfg(stage0)] #[cfg(target_word_size = \"64\")] int_module! { int, 64 }\n-\n-#[cfg(not(stage0))] #[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n-#[cfg(not(stage0))] #[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }\n+#[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n+#[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "e4711c92c599c499125b123fedd04113a0308268", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -17,9 +17,7 @@\n #![stable]\n #![doc(primitive = \"isize\")]\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"),\n-          all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n int_module! { isize, 32 }\n-#[cfg(any(all(stage0, target_word_size = \"64\"),\n-          all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n int_module! { isize, 64 }"}, {"sha": "599a5515e3b48c37fd9501cbff763e2b83802d40", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -496,7 +496,7 @@ uint_impl! { u64 = u64, 64,\n     intrinsics::u64_sub_with_overflow,\n     intrinsics::u64_mul_with_overflow }\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n uint_impl! { uint = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n@@ -506,7 +506,7 @@ uint_impl! { uint = u32, 32,\n     intrinsics::u32_sub_with_overflow,\n     intrinsics::u32_mul_with_overflow }\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n uint_impl! { uint = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n@@ -601,13 +601,13 @@ int_impl! { i64 = i64, u64, 64,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow }\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n int_impl! { int = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow }\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n int_impl! { int = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,"}, {"sha": "db7177e26fa2746013c3d84499f6a96c0779cc45", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -719,8 +719,6 @@ macro_rules! shl_impl {\n     )\n }\n \n-// SNAP 9e4e524e0\n-#[cfg(not(stage0))]\n macro_rules! shl_impl_all {\n     ($($t:ty)*) => ($(\n         shl_impl! { $t, u8 }\n@@ -737,13 +735,6 @@ macro_rules! shl_impl_all {\n     )*)\n }\n \n-#[cfg(stage0)]\n-macro_rules! shl_impl_all {\n-    ($($t:ty)*) => ($(\n-        shl_impl! { $t, usize }\n-    )*)\n-}\n-\n shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n@@ -798,8 +789,6 @@ macro_rules! shr_impl {\n     )\n }\n \n-// SNAP 9e4e524e0\n-#[cfg(not(stage0))]\n macro_rules! shr_impl_all {\n     ($($t:ty)*) => ($(\n         shr_impl! { $t, u8 }\n@@ -816,13 +805,6 @@ macro_rules! shr_impl_all {\n     )*)\n }\n \n-#[cfg(stage0)]\n-macro_rules! shr_impl_all {\n-    ($($t:ty)*) => ($(\n-        shr_impl! { $t, usize }\n-    )*)\n-}\n-\n shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n \n /// The `Index` trait is used to specify the functionality of indexing operations"}, {"sha": "ddee1f79d6a6856b5ce71175424d849f03eec65d", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -274,12 +274,12 @@ fn find_libdir(sysroot: &Path) -> String {\n         }\n     }\n \n-    #[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+    #[cfg(target_pointer_width = \"64\")]\n     fn primary_libdir_name() -> String {\n         \"lib64\".to_string()\n     }\n \n-    #[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+    #[cfg(target_pointer_width = \"32\")]\n     fn primary_libdir_name() -> String {\n         \"lib32\".to_string()\n     }"}, {"sha": "34e4993c54da30e16f8cde71055e2693d7b7c9bc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -947,13 +947,6 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n-#[cfg(stage0)]\n-impl<'tcx, S: Writer> Hash<S> for TyS<'tcx> {\n-    fn hash(&self, s: &mut S) {\n-        (self as *const _).hash(s)\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)"}, {"sha": "70aac61b6bf47b9a62cfaa724c3e23bec5db2be1", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -24,7 +24,6 @@ Core encoding and decoding interfaces.\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![cfg_attr(stage0, allow(unused_attributes))]\n #![feature(box_syntax)]\n #![feature(old_impl_check)]\n #![feature(slicing_syntax)]"}, {"sha": "3432767d6cd8ce1e68475e703bc5e3e3e6ad96f5", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 14, "deletions": 28, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -424,14 +424,12 @@ mod tests {\n         assert_eq!(int::MIN.to_u32(),  None);\n         assert_eq!(int::MIN.to_u64(),  None);\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(int::MIN.to_i32(), Some(int::MIN as i32));\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(int::MIN.to_i32(), None);\n         }\n@@ -494,14 +492,12 @@ mod tests {\n         assert_eq!(i64::MIN.to_u32(),  None);\n         assert_eq!(i64::MIN.to_u64(),  None);\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(i64::MIN.to_int(), None);\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(i64::MIN.to_int(), Some(i64::MIN as int));\n         }\n@@ -521,15 +517,13 @@ mod tests {\n         // int::MAX.to_u32() is word-size specific\n         assert_eq!(int::MAX.to_u64(),  Some(int::MAX as u64));\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(int::MAX.to_i32(), Some(int::MAX as i32));\n             assert_eq!(int::MAX.to_u32(), Some(int::MAX as u32));\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(int::MAX.to_i32(), None);\n             assert_eq!(int::MAX.to_u32(), None);\n@@ -593,15 +587,13 @@ mod tests {\n         assert_eq!(i64::MAX.to_u32(),  None);\n         assert_eq!(i64::MAX.to_u64(),  Some(i64::MAX as u64));\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(i64::MAX.to_int(),  None);\n             assert_eq!(i64::MAX.to_uint(), None);\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(i64::MAX.to_int(),  Some(i64::MAX as int));\n             assert_eq!(i64::MAX.to_uint(), Some(i64::MAX as uint));\n@@ -692,15 +684,13 @@ mod tests {\n         // uint::MAX.to_u32() is word-size specific\n         assert_eq!(uint::MAX.to_u64(),  Some(uint::MAX as u64));\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(uint::MAX.to_u32(), Some(uint::MAX as u32));\n             assert_eq!(uint::MAX.to_i64(), Some(uint::MAX as i64));\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(uint::MAX.to_u32(), None);\n             assert_eq!(uint::MAX.to_i64(), None);\n@@ -750,14 +740,12 @@ mod tests {\n         assert_eq!(u32::MAX.to_u32(),  Some(u32::MAX as u32));\n         assert_eq!(u32::MAX.to_u64(),  Some(u32::MAX as u64));\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(u32::MAX.to_int(),  None);\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(u32::MAX.to_int(),  Some(u32::MAX as int));\n         }\n@@ -778,14 +766,12 @@ mod tests {\n         assert_eq!(u64::MAX.to_u32(),  None);\n         assert_eq!(u64::MAX.to_u64(),  Some(u64::MAX as u64));\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         fn check_word_size() {\n             assert_eq!(u64::MAX.to_uint(), None);\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         fn check_word_size() {\n             assert_eq!(u64::MAX.to_uint(), Some(u64::MAX as uint));\n         }"}, {"sha": "23387d29553137cd36de3c52653e84276ea7d040", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -230,9 +230,9 @@ use rc::Rc;\n use result::Result::{Ok, Err};\n use vec::Vec;\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n use core_rand::IsaacRng as IsaacWordRng;\n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n use core_rand::Isaac64Rng as IsaacWordRng;\n \n pub use core_rand::{Rand, Rng, SeedableRng, Open01, Closed01};"}, {"sha": "d8b8598723607a6d256376f55ad1b9f84a714c6d", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -12,10 +12,10 @@ use prelude::v1::*;\n \n use io::IoResult;\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n pub const HEX_WIDTH: uint = 18;\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n pub const HEX_WIDTH: uint = 10;\n \n // All rust symbols are in theory lists of \"::\"-separated identifiers. Some"}, {"sha": "9016d1a2c99cab743260fd85d83f28d7697e3779", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -173,13 +173,13 @@ mod signal {\n     unsafe impl ::marker::Sync for sigaction { }\n \n     #[repr(C)]\n-    #[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+    #[cfg(target_pointer_width = \"32\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 32],\n     }\n \n     #[repr(C)]\n-    #[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+    #[cfg(target_pointer_width = \"64\")]\n     pub struct sigset_t {\n         __val: [libc::c_ulong; 16],\n     }"}, {"sha": "2b5ced5085bbe8dff987e25e9cd63ce582e0f464", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -183,14 +183,12 @@ mod imp {\n             sa_restorer: *mut libc::c_void,\n         }\n \n-        #[cfg(any(all(stage0, target_word_size = \"32\"),\n-                  all(not(stage0), target_pointer_width = \"32\")))]\n+        #[cfg(target_pointer_width = \"32\")]\n         #[repr(C)]\n         pub struct sigset_t {\n             __val: [libc::c_ulong; 32],\n         }\n-        #[cfg(any(all(stage0, target_word_size = \"64\"),\n-                  all(not(stage0), target_pointer_width = \"64\")))]\n+        #[cfg(target_pointer_width = \"64\")]\n         #[repr(C)]\n         pub struct sigset_t {\n             __val: [libc::c_ulong; 16],"}, {"sha": "37fa8703706e07aece792932b1eaba8fb09cb5b9", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -38,7 +38,6 @@\n \n use std::fmt::{self, Show};\n use std::hash::{Hash, Hasher};\n-#[cfg(stage0)] use std::hash::Writer;\n use std::ops::Deref;\n use std::ptr;\n \n@@ -107,13 +106,6 @@ impl<T: Show> Show for P<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<S: Writer, T: Hash<S>> Hash<S> for P<T> {\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n-    }\n-}\n-#[cfg(not(stage0))]\n impl<S: Hasher, T: Hash<S>> Hash<S> for P<T> {\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);"}, {"sha": "16fb109bb7d2be3a9a37dd51ccac9fa752254381", "filename": "src/snapshots.txt", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fsnapshots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Fsnapshots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsnapshots.txt?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -1,3 +1,12 @@\n+S 2015-01-15 9ade482\n+  freebsd-x86_64 eb8f52c6e8dc24a293456d5e4dc5d1072442e758\n+  linux-i386 0197ad7179d74eba06a8b46432548caf226aa03d\n+  linux-x86_64 03459f8b216e96ed8b9abe25a42a75859195103d\n+  macos-i386 b5c004883ddff84159f11a3329cde682e0b7f75b\n+  macos-x86_64 b69ea42e1c995682adf0390ed4ef8a762c001a4e\n+  winnt-i386 7fa6e35d26bbffa3888d440a0d5f116414ef8c0a\n+  winnt-x86_64 ac04a4f1f26e0219d91e7eae6f580ca3cfee4231\n+\n S 2015-01-07 9e4e524\n   freebsd-x86_64 2563d33151bce1bbe08a85d712564bddc7503fc6\n   linux-i386 d8b73fc9aa3ad72ce1408a41e35d78dba10eb4d4"}, {"sha": "6e7c05370b99d17d410226e42fa1c6a9ebfd281a", "filename": "src/test/compile-fail/huge-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhuge-enum.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -12,12 +12,12 @@\n \n // FIXME: work properly with higher limits\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n fn main() {\n     let big: Option<[u32; (1<<29)-1]> = None;\n }\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n fn main() {\n     let big: Option<[u32; (1<<45)-1]> = None;\n }"}, {"sha": "1f5264aef6113856cdd778c49adbcab20486e5d6", "filename": "src/test/compile-fail/issue-17913.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17913.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -13,14 +13,14 @@\n \n #![feature(box_syntax)]\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n fn main() {\n     let n = 0us;\n     let a = box [&n; 0xF000000000000000us];\n     println!(\"{}\", a[0xFFFFFFu]);\n }\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n fn main() {\n     let n = 0us;\n     let a = box [&n; 0xFFFFFFFFu];"}, {"sha": "5083bd23207306be0fe056e17c259dde134666c0", "filename": "src/test/run-pass/huge-largest-array.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/89b80faa8ef2b52f5adc423cfcfed69b313ea1b7/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fhuge-largest-array.rs?ref=89b80faa8ef2b52f5adc423cfcfed69b313ea1b7", "patch": "@@ -10,12 +10,12 @@\n \n use std::mem::size_of;\n \n-#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n+#[cfg(target_pointer_width = \"32\")]\n pub fn main() {\n     assert_eq!(size_of::<[u8; (1 << 31) - 1]>(), (1 << 31) - 1);\n }\n \n-#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n+#[cfg(target_pointer_width = \"64\")]\n pub fn main() {\n     assert_eq!(size_of::<[u8; (1 << 47) - 1]>(), (1 << 47) - 1);\n }"}]}