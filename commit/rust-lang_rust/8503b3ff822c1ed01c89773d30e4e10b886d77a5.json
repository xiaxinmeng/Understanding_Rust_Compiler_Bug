{"sha": "8503b3ff822c1ed01c89773d30e4e10b886d77a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MDNiM2ZmODIyYzFlZDAxYzg5NzczZDMwZTRlMTBiODg2ZDc3YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-04T19:07:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-12-04T19:07:52Z"}, "message": "Auto merge of #46319 - nikomatsakis:nll-master-to-rust-master-2, r=pnkfelix\n\nNLL: improve inference with flow results, represent regions with bitsets, and more\n\nThis PR begins with a number of edits to the NLL code and then includes a large number of smaller refactorings (these refactorings ought not to change behavior). There are a lot of commits here, but each is individually simple. The goal is to land everything up to but not including the changes to how we handle closures, which are conceptually more complex.\n\nThe NLL specific changes are as follows (in order of appearance):\n\n**Modify the region inferencer's approach to free regions.** Previously, for each free region (lifetime parameter) `'a`, it would compute the set of other free regions that `'a` outlives (e.g., if we have `where 'a: 'b`, then this set would be `{'a, 'b}`). Then it would mark those free regions as \"constants\" and report an error if inference tried to extend `'a` to include any other region (e.g., `'c`) that is not in that outlives set. In this way, the value of `'a` would never grow beyond the maximum that could type check. The new approach is to allow `'a` to grow larger. Then, after the fact, we check over the value of `'a` and see what other free regions it is required to outlive, and we check that those outlives relationships are justified by the where clauses in scope etc.\n\n**Modify constraint generation to consider maybe-init.** When we have a \"drop-live\" variable `x` (i.e., a variable that will be dropped but will not be otherwise used), we now consider whether `x` is \"maybe initialized\" at that point. If not, then we know the drop is a no-op, and we can allow its regions to be dead. Due to limitations in the fragment code, this currently only works at the level of entire variables.\n\n**Change representation of regions to use a `BitMatrix`.** We used to use a `BTreeSet`, which was rather silly. We now use a MxN matrix of bits, where `M` is the number of variables and `N` is the number of possible elements in each set (size of the CFG + number of free regions).\n\nThe remaining commits (starting from\nextract the `implied_bounds` code into a helper function \") are all \"no-op\" refactorings, I believe.\n\n~~One concern I have is with the commit \"with -Zverbose, print all details of closure substs\"; this commit seems to include some \"internal\" stuff in the mir-dump files, such as internal interner numbers, that I fear may vary by platform. Annoying. I guess we will see.~~ (I removed this commit.)\n\nAs for reviewer, @arielb1 has been reviewing the PRs, and they are certainly welcome to review this one too. But I figured it'd maybe be good to have more people taking a look and being familiar with this code, so I'll \"nominate\" @pnkfelix .\n\nr? @pnkfelix", "tree": {"sha": "eee81c2a68d770eaebab6e98deda95e06b6b2a96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee81c2a68d770eaebab6e98deda95e06b6b2a96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8503b3ff822c1ed01c89773d30e4e10b886d77a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8503b3ff822c1ed01c89773d30e4e10b886d77a5", "html_url": "https://github.com/rust-lang/rust/commit/8503b3ff822c1ed01c89773d30e4e10b886d77a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8503b3ff822c1ed01c89773d30e4e10b886d77a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "226656ff72e3ecd3f715d1bbd4f3b25576a7bc61", "url": "https://api.github.com/repos/rust-lang/rust/commits/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61", "html_url": "https://github.com/rust-lang/rust/commit/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61"}, {"sha": "a6adc74e8726dd0fa0260964d0d7c03e9b48c655", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6adc74e8726dd0fa0260964d0d7c03e9b48c655", "html_url": "https://github.com/rust-lang/rust/commit/a6adc74e8726dd0fa0260964d0d7c03e9b48c655"}], "stats": {"total": 5404, "additions": 3289, "deletions": 2115}, "files": [{"sha": "96a980a15457e1715f8278960f8cdf90950015ed", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -18,7 +18,7 @@ pub use ty::IntVarValue;\n pub use self::freshen::TypeFreshener;\n \n use hir::def_id::DefId;\n-use middle::free_region::{FreeRegionMap, RegionRelations};\n+use middle::free_region::RegionRelations;\n use middle::region;\n use middle::lang_items;\n use mir::tcx::PlaceTy;\n@@ -44,6 +44,7 @@ use self::higher_ranked::HrMatchResult;\n use self::region_constraints::{RegionConstraintCollector, RegionSnapshot};\n use self::region_constraints::{GenericKind, VerifyBound, RegionConstraintData, VarOrigins};\n use self::lexical_region_resolve::LexicalRegionResolutions;\n+use self::outlives::env::OutlivesEnvironment;\n use self::type_variable::TypeVariableOrigin;\n use self::unify_key::ToType;\n \n@@ -58,15 +59,13 @@ pub mod lattice;\n mod lub;\n pub mod region_constraints;\n mod lexical_region_resolve;\n-mod outlives;\n+pub mod outlives;\n pub mod resolve;\n mod freshen;\n mod sub;\n pub mod type_variable;\n pub mod unify_key;\n \n-pub use self::outlives::env::OutlivesEnvironment;\n-\n #[must_use]\n pub struct InferOk<'tcx, T> {\n     pub value: T,\n@@ -1157,15 +1156,15 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_regions_and_report_errors(&self,\n                                              region_context: DefId,\n                                              region_map: &region::ScopeTree,\n-                                             free_regions: &FreeRegionMap<'tcx>) {\n+                                             outlives_env: &OutlivesEnvironment<'tcx>) {\n         assert!(self.is_tainted_by_errors() || self.region_obligations.borrow().is_empty(),\n                 \"region_obligations not empty: {:#?}\",\n                 self.region_obligations.borrow());\n \n         let region_rels = &RegionRelations::new(self.tcx,\n                                                 region_context,\n                                                 region_map,\n-                                                free_regions);\n+                                                outlives_env.free_region_map());\n         let (var_origins, data) = self.region_constraints.borrow_mut()\n                                                          .take()\n                                                          .expect(\"regions already resolved\")"}, {"sha": "8a562471ac5d038b7d5211eb06bc992910372e66", "filename": "src/librustc/infer/outlives/bounds.rs", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fbounds.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use infer::InferCtxt;\n+use syntax::ast;\n+use syntax::codemap::Span;\n+use traits::FulfillmentContext;\n+use ty::{self, Ty, TypeFoldable};\n+use ty::outlives::Component;\n+use ty::wf;\n+\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`).  These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n+#[derive(Debug)]\n+pub enum OutlivesBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n+    /// Implied bounds are region relationships that we deduce\n+    /// automatically.  The idea is that (e.g.) a caller must check that a\n+    /// function's argument types are well-formed immediately before\n+    /// calling that fn, and hence the *callee* can assume that its\n+    /// argument types are well-formed. This may imply certain relationships\n+    /// between generic parameters. For example:\n+    ///\n+    ///     fn foo<'a,T>(x: &'a T)\n+    ///\n+    /// can only be called with a `'a` and `T` such that `&'a T` is WF.\n+    /// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n+    ///\n+    /// # Parameters\n+    ///\n+    /// - `param_env`, the where-clauses in scope\n+    /// - `body_id`, the body-id to use when normalizing assoc types.\n+    ///   Note that this may cause outlives obligations to be injected\n+    ///   into the inference context with this body-id.\n+    /// - `ty`, the type that we are supposed to assume is WF.\n+    /// - `span`, a span to use when normalizing, hopefully not important,\n+    ///   might be useful if a `bug!` occurs.\n+    pub fn implied_outlives_bounds(\n+        &self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        body_id: ast::NodeId,\n+        ty: Ty<'tcx>,\n+        span: Span,\n+    ) -> Vec<OutlivesBound<'tcx>> {\n+        let tcx = self.tcx;\n+\n+        // Sometimes when we ask what it takes for T: WF, we get back that\n+        // U: WF is required; in that case, we push U onto this stack and\n+        // process it next. Currently (at least) these resulting\n+        // predicates are always guaranteed to be a subset of the original\n+        // type, so we need not fear non-termination.\n+        let mut wf_types = vec![ty];\n+\n+        let mut implied_bounds = vec![];\n+\n+        let mut fulfill_cx = FulfillmentContext::new();\n+\n+        while let Some(ty) = wf_types.pop() {\n+            // Compute the obligations for `ty` to be well-formed. If `ty` is\n+            // an unresolved inference variable, just substituted an empty set\n+            // -- because the return type here is going to be things we *add*\n+            // to the environment, it's always ok for this set to be smaller\n+            // than the ultimate set. (Note: normally there won't be\n+            // unresolved inference variables here anyway, but there might be\n+            // during typeck under some circumstances.)\n+            let obligations = wf::obligations(self, param_env, body_id, ty, span).unwrap_or(vec![]);\n+\n+            // NB: All of these predicates *ought* to be easily proven\n+            // true. In fact, their correctness is (mostly) implied by\n+            // other parts of the program. However, in #42552, we had\n+            // an annoying scenario where:\n+            //\n+            // - Some `T::Foo` gets normalized, resulting in a\n+            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n+            //   (not sure why it couldn't immediately get\n+            //   solved). This result of `_1` got cached.\n+            // - These obligations were dropped on the floor here,\n+            //   rather than being registered.\n+            // - Then later we would get a request to normalize\n+            //   `T::Foo` which would result in `_1` being used from\n+            //   the cache, but hence without the `T: Trait<Foo=_1>`\n+            //   constraint. As a result, `_1` never gets resolved,\n+            //   and we get an ICE (in dropck).\n+            //\n+            // Therefore, we register any predicates involving\n+            // inference variables. We restrict ourselves to those\n+            // involving inference variables both for efficiency and\n+            // to avoids duplicate errors that otherwise show up.\n+            fulfill_cx.register_predicate_obligations(\n+                self,\n+                obligations\n+                    .iter()\n+                    .filter(|o| o.predicate.has_infer_types())\n+                    .cloned(),\n+            );\n+\n+            // From the full set of obligations, just filter down to the\n+            // region relationships.\n+            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n+                assert!(!obligation.has_escaping_regions());\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(..) |\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::Subtype(..) |\n+                    ty::Predicate::Projection(..) |\n+                    ty::Predicate::ClosureKind(..) |\n+                    ty::Predicate::ObjectSafe(..) |\n+                    ty::Predicate::ConstEvaluatable(..) => vec![],\n+\n+                    ty::Predicate::WellFormed(subty) => {\n+                        wf_types.push(subty);\n+                        vec![]\n+                    }\n+\n+                    ty::Predicate::RegionOutlives(ref data) => match data.no_late_bound_regions() {\n+                        None => vec![],\n+                        Some(ty::OutlivesPredicate(r_a, r_b)) => {\n+                            vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n+                        }\n+                    },\n+\n+                    ty::Predicate::TypeOutlives(ref data) => match data.no_late_bound_regions() {\n+                        None => vec![],\n+                        Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                            let ty_a = self.resolve_type_vars_if_possible(&ty_a);\n+                            let components = tcx.outlives_components(ty_a);\n+                            Self::implied_bounds_from_components(r_b, components)\n+                        }\n+                    },\n+                }\n+            }));\n+        }\n+\n+        // Ensure that those obligations that we had to solve\n+        // get solved *here*.\n+        match fulfill_cx.select_all_or_error(self) {\n+            Ok(()) => (),\n+            Err(errors) => self.report_fulfillment_errors(&errors, None),\n+        }\n+\n+        implied_bounds\n+    }\n+\n+    /// When we have an implied bound that `T: 'a`, we can further break\n+    /// this down to determine what relationships would have to hold for\n+    /// `T: 'a` to hold. We get to assume that the caller has validated\n+    /// those relationships.\n+    fn implied_bounds_from_components(\n+        sub_region: ty::Region<'tcx>,\n+        sup_components: Vec<Component<'tcx>>,\n+    ) -> Vec<OutlivesBound<'tcx>> {\n+        sup_components\n+            .into_iter()\n+            .flat_map(|component| {\n+                match component {\n+                    Component::Region(r) =>\n+                        vec![OutlivesBound::RegionSubRegion(sub_region, r)],\n+                    Component::Param(p) =>\n+                        vec![OutlivesBound::RegionSubParam(sub_region, p)],\n+                    Component::Projection(p) =>\n+                        vec![OutlivesBound::RegionSubProjection(sub_region, p)],\n+                    Component::EscapingProjection(_) =>\n+                    // If the projection has escaping regions, don't\n+                    // try to infer any implied bounds even for its\n+                    // free components. This is conservative, because\n+                    // the caller will still have to prove that those\n+                    // free components outlive `sub_region`. But the\n+                    // idea is that the WAY that the caller proves\n+                    // that may change in the future and we want to\n+                    // give ourselves room to get smarter here.\n+                        vec![],\n+                    Component::UnresolvedInferenceVariable(..) =>\n+                        vec![],\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+pub fn explicit_outlives_bounds<'tcx>(\n+    param_env: ty::ParamEnv<'tcx>,\n+) -> impl Iterator<Item = OutlivesBound<'tcx>> + 'tcx {\n+    debug!(\"explicit_outlives_bounds()\");\n+    param_env\n+        .caller_bounds\n+        .into_iter()\n+        .filter_map(move |predicate| match predicate {\n+            ty::Predicate::Projection(..) |\n+            ty::Predicate::Trait(..) |\n+            ty::Predicate::Equate(..) |\n+            ty::Predicate::Subtype(..) |\n+            ty::Predicate::WellFormed(..) |\n+            ty::Predicate::ObjectSafe(..) |\n+            ty::Predicate::ClosureKind(..) |\n+            ty::Predicate::TypeOutlives(..) |\n+            ty::Predicate::ConstEvaluatable(..) => None,\n+            ty::Predicate::RegionOutlives(ref data) => data.no_late_bound_regions().map(\n+                |ty::OutlivesPredicate(r_a, r_b)| OutlivesBound::RegionSubRegion(r_b, r_a),\n+            ),\n+        })\n+}"}, {"sha": "d47507592f80d4585d8d2cfd664e7ec527c4b311", "filename": "src/librustc/infer/outlives/env.rs", "status": "modified", "additions": 55, "deletions": 212, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fenv.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -8,12 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use middle::free_region::FreeRegionMap;\n-use infer::{InferCtxt, GenericKind};\n-use traits::FulfillmentContext;\n-use ty::{self, Ty, TypeFoldable};\n-use ty::outlives::Component;\n-use ty::wf;\n+use infer::{GenericKind, InferCtxt};\n+use infer::outlives::free_region_map::FreeRegionMap;\n+use infer::outlives::bounds::{self, OutlivesBound};\n+use ty::{self, Ty};\n \n use syntax::ast;\n use syntax_pos::Span;\n@@ -44,34 +42,17 @@ pub struct OutlivesEnvironment<'tcx> {\n     region_bound_pairs: Vec<(ty::Region<'tcx>, GenericKind<'tcx>)>,\n }\n \n-/// Implied bounds are region relationships that we deduce\n-/// automatically.  The idea is that (e.g.) a caller must check that a\n-/// function's argument types are well-formed immediately before\n-/// calling that fn, and hence the *callee* can assume that its\n-/// argument types are well-formed. This may imply certain relationships\n-/// between generic parameters. For example:\n-///\n-///     fn foo<'a,T>(x: &'a T)\n-///\n-/// can only be called with a `'a` and `T` such that `&'a T` is WF.\n-/// For `&'a T` to be WF, `T: 'a` must hold. So we can assume `T: 'a`.\n-#[derive(Debug)]\n-enum ImpliedBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n     pub fn new(param_env: ty::ParamEnv<'tcx>) -> Self {\n-        let mut free_region_map = FreeRegionMap::new();\n-        free_region_map.relate_free_regions_from_predicates(&param_env.caller_bounds);\n-\n-        OutlivesEnvironment {\n+        let mut env = OutlivesEnvironment {\n             param_env,\n-            free_region_map,\n+            free_region_map: FreeRegionMap::new(),\n             region_bound_pairs: vec![],\n-        }\n+        };\n+\n+        env.add_outlives_bounds(None, bounds::explicit_outlives_bounds(param_env));\n+\n+        env\n     }\n \n     /// Borrows current value of the `free_region_map`.\n@@ -163,193 +144,55 @@ impl<'a, 'gcx: 'tcx, 'tcx: 'a> OutlivesEnvironment<'tcx> {\n         for &ty in fn_sig_tys {\n             let ty = infcx.resolve_type_vars_if_possible(&ty);\n             debug!(\"add_implied_bounds: ty = {}\", ty);\n-            let implied_bounds = self.implied_bounds(infcx, body_id, ty, span);\n-\n-            // But also record other relationships, such as `T:'x`,\n-            // that don't go into the free-region-map but which we use\n-            // here.\n-            for implication in implied_bounds {\n-                debug!(\"add_implied_bounds: implication={:?}\", implication);\n-                match implication {\n-                    ImpliedBound::RegionSubRegion(\n-                        r_a @ &ty::ReEarlyBound(_),\n-                        &ty::ReVar(vid_b),\n-                    ) |\n-                    ImpliedBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n-                        infcx.add_given(r_a, vid_b);\n-                    }\n-                    ImpliedBound::RegionSubParam(r_a, param_b) => {\n-                        self.region_bound_pairs\n-                            .push((r_a, GenericKind::Param(param_b)));\n-                    }\n-                    ImpliedBound::RegionSubProjection(r_a, projection_b) => {\n-                        self.region_bound_pairs\n-                            .push((r_a, GenericKind::Projection(projection_b)));\n-                    }\n-                    ImpliedBound::RegionSubRegion(r_a, r_b) => {\n-                        // In principle, we could record (and take\n-                        // advantage of) every relationship here, but\n-                        // we are also free not to -- it simply means\n-                        // strictly less that we can successfully type\n-                        // check. Right now we only look for things\n-                        // relationships between free regions. (It may\n-                        // also be that we should revise our inference\n-                        // system to be more general and to make use\n-                        // of *every* relationship that arises here,\n-                        // but presently we do not.)\n-                        self.free_region_map.relate_regions(r_a, r_b);\n-                    }\n-                }\n-            }\n+            let implied_bounds = infcx.implied_outlives_bounds(self.param_env, body_id, ty, span);\n+            self.add_outlives_bounds(Some(infcx), implied_bounds)\n         }\n     }\n \n-    /// Compute the implied bounds that a callee/impl can assume based on\n-    /// the fact that caller/projector has ensured that `ty` is WF.  See\n-    /// the `ImpliedBound` type for more details.\n-    fn implied_bounds(\n+    /// Processes outlives bounds that are known to hold, whether from implied or other sources.\n+    ///\n+    /// The `infcx` parameter is optional; if the implied bounds may\n+    /// contain inference variables, it must be supplied, in which\n+    /// case we will register \"givens\" on the inference context. (See\n+    /// `RegionConstraintData`.)\n+    fn add_outlives_bounds<I>(\n         &mut self,\n-        infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-        body_id: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        span: Span,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n-        let tcx = infcx.tcx;\n-\n-        // Sometimes when we ask what it takes for T: WF, we get back that\n-        // U: WF is required; in that case, we push U onto this stack and\n-        // process it next. Currently (at least) these resulting\n-        // predicates are always guaranteed to be a subset of the original\n-        // type, so we need not fear non-termination.\n-        let mut wf_types = vec![ty];\n-\n-        let mut implied_bounds = vec![];\n-\n-        let mut fulfill_cx = FulfillmentContext::new();\n-\n-        while let Some(ty) = wf_types.pop() {\n-            // Compute the obligations for `ty` to be well-formed. If `ty` is\n-            // an unresolved inference variable, just substituted an empty set\n-            // -- because the return type here is going to be things we *add*\n-            // to the environment, it's always ok for this set to be smaller\n-            // than the ultimate set. (Note: normally there won't be\n-            // unresolved inference variables here anyway, but there might be\n-            // during typeck under some circumstances.)\n-            let obligations =\n-                wf::obligations(infcx, self.param_env, body_id, ty, span).unwrap_or(vec![]);\n-\n-            // NB: All of these predicates *ought* to be easily proven\n-            // true. In fact, their correctness is (mostly) implied by\n-            // other parts of the program. However, in #42552, we had\n-            // an annoying scenario where:\n-            //\n-            // - Some `T::Foo` gets normalized, resulting in a\n-            //   variable `_1` and a `T: Trait<Foo=_1>` constraint\n-            //   (not sure why it couldn't immediately get\n-            //   solved). This result of `_1` got cached.\n-            // - These obligations were dropped on the floor here,\n-            //   rather than being registered.\n-            // - Then later we would get a request to normalize\n-            //   `T::Foo` which would result in `_1` being used from\n-            //   the cache, but hence without the `T: Trait<Foo=_1>`\n-            //   constraint. As a result, `_1` never gets resolved,\n-            //   and we get an ICE (in dropck).\n-            //\n-            // Therefore, we register any predicates involving\n-            // inference variables. We restrict ourselves to those\n-            // involving inference variables both for efficiency and\n-            // to avoids duplicate errors that otherwise show up.\n-            fulfill_cx.register_predicate_obligations(\n-                infcx,\n-                obligations\n-                    .iter()\n-                    .filter(|o| o.predicate.has_infer_types())\n-                    .cloned());\n-\n-            // From the full set of obligations, just filter down to the\n-            // region relationships.\n-            implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n-                assert!(!obligation.has_escaping_regions());\n-                match obligation.predicate {\n-                    ty::Predicate::Trait(..) |\n-                    ty::Predicate::Equate(..) |\n-                    ty::Predicate::Subtype(..) |\n-                    ty::Predicate::Projection(..) |\n-                    ty::Predicate::ClosureKind(..) |\n-                    ty::Predicate::ObjectSafe(..) |\n-                    ty::Predicate::ConstEvaluatable(..) => vec![],\n-\n-                    ty::Predicate::WellFormed(subty) => {\n-                        wf_types.push(subty);\n-                        vec![]\n-                    }\n-\n-                    ty::Predicate::RegionOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(r_a, r_b)) => {\n-                                vec![ImpliedBound::RegionSubRegion(r_b, r_a)]\n-                            }\n-                        }\n-                    }\n-\n-                    ty::Predicate::TypeOutlives(ref data) => {\n-                        match tcx.no_late_bound_regions(data) {\n-                            None => vec![],\n-                            Some(ty::OutlivesPredicate(ty_a, r_b)) => {\n-                                let ty_a = infcx.resolve_type_vars_if_possible(&ty_a);\n-                                let components = tcx.outlives_components(ty_a);\n-                                self.implied_bounds_from_components(r_b, components)\n-                            }\n-                        }\n-                    }\n+        infcx: Option<&InferCtxt<'a, 'gcx, 'tcx>>,\n+        outlives_bounds: I,\n+    ) where\n+        I: IntoIterator<Item = OutlivesBound<'tcx>>,\n+    {\n+        // Record relationships such as `T:'x` that don't go into the\n+        // free-region-map but which we use here.\n+        for outlives_bound in outlives_bounds {\n+            debug!(\"add_outlives_bounds: outlives_bound={:?}\", outlives_bound);\n+            match outlives_bound {\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReEarlyBound(_), &ty::ReVar(vid_b)) |\n+                OutlivesBound::RegionSubRegion(r_a @ &ty::ReFree(_), &ty::ReVar(vid_b)) => {\n+                    infcx.expect(\"no infcx provided but region vars found\").add_given(r_a, vid_b);\n                 }\n-            }));\n-        }\n-\n-        // Ensure that those obligations that we had to solve\n-        // get solved *here*.\n-        match fulfill_cx.select_all_or_error(infcx) {\n-            Ok(()) => (),\n-            Err(errors) => infcx.report_fulfillment_errors(&errors, None),\n-        }\n-\n-        implied_bounds\n-    }\n-\n-    /// When we have an implied bound that `T: 'a`, we can further break\n-    /// this down to determine what relationships would have to hold for\n-    /// `T: 'a` to hold. We get to assume that the caller has validated\n-    /// those relationships.\n-    fn implied_bounds_from_components(\n-        &self,\n-        sub_region: ty::Region<'tcx>,\n-        sup_components: Vec<Component<'tcx>>,\n-    ) -> Vec<ImpliedBound<'tcx>> {\n-        sup_components\n-            .into_iter()\n-            .flat_map(|component| {\n-                match component {\n-                    Component::Region(r) =>\n-                        vec![ImpliedBound::RegionSubRegion(sub_region, r)],\n-                    Component::Param(p) =>\n-                        vec![ImpliedBound::RegionSubParam(sub_region, p)],\n-                    Component::Projection(p) =>\n-                        vec![ImpliedBound::RegionSubProjection(sub_region, p)],\n-                    Component::EscapingProjection(_) =>\n-                    // If the projection has escaping regions, don't\n-                    // try to infer any implied bounds even for its\n-                    // free components. This is conservative, because\n-                    // the caller will still have to prove that those\n-                    // free components outlive `sub_region`. But the\n-                    // idea is that the WAY that the caller proves\n-                    // that may change in the future and we want to\n-                    // give ourselves room to get smarter here.\n-                        vec![],\n-                    Component::UnresolvedInferenceVariable(..) =>\n-                        vec![],\n+                OutlivesBound::RegionSubParam(r_a, param_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Param(param_b)));\n                 }\n-            })\n-            .collect()\n+                OutlivesBound::RegionSubProjection(r_a, projection_b) => {\n+                    self.region_bound_pairs\n+                        .push((r_a, GenericKind::Projection(projection_b)));\n+                }\n+                OutlivesBound::RegionSubRegion(r_a, r_b) => {\n+                    // In principle, we could record (and take\n+                    // advantage of) every relationship here, but\n+                    // we are also free not to -- it simply means\n+                    // strictly less that we can successfully type\n+                    // check. Right now we only look for things\n+                    // relationships between free regions. (It may\n+                    // also be that we should revise our inference\n+                    // system to be more general and to make use\n+                    // of *every* relationship that arises here,\n+                    // but presently we do not.)\n+                    self.free_region_map.relate_regions(r_a, r_b);\n+                }\n+            }\n+        }\n     }\n }"}, {"sha": "2127c4714aef0674ffad256759e8427e2da18540", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,102 @@\n+// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use ty::{self, Lift, TyCtxt, Region};\n+use rustc_data_structures::transitive_relation::TransitiveRelation;\n+\n+#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n+pub struct FreeRegionMap<'tcx> {\n+    // Stores the relation `a < b`, where `a` and `b` are regions.\n+    //\n+    // Invariant: only free regions like `'x` or `'static` are stored\n+    // in this relation, not scopes.\n+    relation: TransitiveRelation<Region<'tcx>>\n+}\n+\n+impl<'tcx> FreeRegionMap<'tcx> {\n+    pub fn new() -> Self {\n+        FreeRegionMap { relation: TransitiveRelation::new() }\n+    }\n+\n+    pub fn is_empty(&self) -> bool {\n+        self.relation.is_empty()\n+    }\n+\n+    // Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n+    // (with the exception that `'static: 'x` is not notable)\n+    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n+        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n+        if is_free_or_static(sub) && is_free(sup) {\n+            self.relation.add(sub, sup)\n+        }\n+    }\n+\n+    /// Tests whether `r_a <= r_b`. Both must be free regions or\n+    /// `'static`.\n+    pub fn sub_free_regions<'a, 'gcx>(&self,\n+                                      r_a: Region<'tcx>,\n+                                      r_b: Region<'tcx>)\n+                                      -> bool {\n+        assert!(is_free_or_static(r_a) && is_free_or_static(r_b));\n+        if let ty::ReStatic = r_b {\n+            true // `'a <= 'static` is just always true, and not stored in the relation explicitly\n+        } else {\n+            r_a == r_b || self.relation.contains(&r_a, &r_b)\n+        }\n+    }\n+\n+    /// Compute the least-upper-bound of two free regions. In some\n+    /// cases, this is more conservative than necessary, in order to\n+    /// avoid making arbitrary choices. See\n+    /// `TransitiveRelation::postdom_upper_bound` for more details.\n+    pub fn lub_free_regions<'a, 'gcx>(&self,\n+                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                      r_a: Region<'tcx>,\n+                                      r_b: Region<'tcx>)\n+                                      -> Region<'tcx> {\n+        debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n+        assert!(is_free(r_a));\n+        assert!(is_free(r_b));\n+        let result = if r_a == r_b { r_a } else {\n+            match self.relation.postdom_upper_bound(&r_a, &r_b) {\n+                None => tcx.mk_region(ty::ReStatic),\n+                Some(r) => *r,\n+            }\n+        };\n+        debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n+        result\n+    }\n+}\n+\n+fn is_free(r: Region) -> bool {\n+    match *r {\n+        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n+        _ => false\n+    }\n+}\n+\n+fn is_free_or_static(r: Region) -> bool {\n+    match *r {\n+        ty::ReStatic => true,\n+        _ => is_free(r),\n+    }\n+}\n+\n+impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n+    relation\n+});\n+\n+impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n+    type Lifted = FreeRegionMap<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n+        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+                     .map(|relation| FreeRegionMap { relation })\n+    }\n+}"}, {"sha": "6aafebe79c6717de4eeb87cba1b73886c4d8a222", "filename": "src/librustc/infer/outlives/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -8,5 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+//! Various code related to computing outlives relations.\n+\n pub mod env;\n+pub mod free_region_map;\n+pub mod bounds;\n mod obligations;"}, {"sha": "07eacde0aab883239308208e7ace5b3c790e9ddc", "filename": "src/librustc/infer/outlives/obligations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Fobligations.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -604,7 +604,7 @@ impl<'cx, 'gcx, 'tcx> TypeOutlives<'cx, 'gcx, 'tcx> {\n         predicates\n             .into_iter()\n             .filter_map(|p| p.as_ref().to_opt_type_outlives())\n-            .filter_map(|p| self.tcx().no_late_bound_regions(&p))\n+            .filter_map(|p| p.no_late_bound_regions())\n             .filter(|p| p.0 == ty)\n             .map(|p| p.1)\n             .collect()"}, {"sha": "ca6a5dd7f5b0b95ca42deaa9861c1655eefceee0", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 16, "deletions": 134, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -15,10 +15,10 @@\n //! `TransitiveRelation` type and use that to decide when one free\n //! region outlives another and so forth.\n \n+use infer::outlives::free_region_map::FreeRegionMap;\n use hir::def_id::DefId;\n use middle::region;\n-use ty::{self, Lift, TyCtxt, Region};\n-use rustc_data_structures::transitive_relation::TransitiveRelation;\n+use ty::{self, TyCtxt, Region};\n \n /// Combines a `region::ScopeTree` (which governs relationships between\n /// scopes) and a `FreeRegionMap` (which governs relationships between\n@@ -63,28 +63,28 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n                            -> bool {\n         let result = sub_region == super_region || {\n             match (sub_region, super_region) {\n-                (&ty::ReEmpty, _) |\n-                (_, &ty::ReStatic) =>\n+                (ty::ReEmpty, _) |\n+                (_, ty::ReStatic) =>\n                     true,\n \n-                (&ty::ReScope(sub_scope), &ty::ReScope(super_scope)) =>\n-                    self.region_scope_tree.is_subscope_of(sub_scope, super_scope),\n+                (ty::ReScope(sub_scope), ty::ReScope(super_scope)) =>\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, *super_scope),\n \n-                (&ty::ReScope(sub_scope), &ty::ReEarlyBound(ref br)) => {\n+                (ty::ReScope(sub_scope), ty::ReEarlyBound(ref br)) => {\n                     let fr_scope = self.region_scope_tree.early_free_scope(self.tcx, br);\n-                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n                 }\n \n-                (&ty::ReScope(sub_scope), &ty::ReFree(ref fr)) => {\n+                (ty::ReScope(sub_scope), ty::ReFree(fr)) => {\n                     let fr_scope = self.region_scope_tree.free_scope(self.tcx, fr);\n-                    self.region_scope_tree.is_subscope_of(sub_scope, fr_scope)\n+                    self.region_scope_tree.is_subscope_of(*sub_scope, fr_scope)\n                 }\n \n-                (&ty::ReEarlyBound(_), &ty::ReEarlyBound(_)) |\n-                (&ty::ReFree(_), &ty::ReEarlyBound(_)) |\n-                (&ty::ReEarlyBound(_), &ty::ReFree(_)) |\n-                (&ty::ReFree(_), &ty::ReFree(_)) =>\n-                    self.free_regions.sub_free_regions(&sub_region, &super_region),\n+                (ty::ReEarlyBound(_), ty::ReEarlyBound(_)) |\n+                (ty::ReFree(_), ty::ReEarlyBound(_)) |\n+                (ty::ReEarlyBound(_), ty::ReFree(_)) |\n+                (ty::ReFree(_), ty::ReFree(_)) =>\n+                    self.free_regions.sub_free_regions(sub_region, super_region),\n \n                 _ =>\n                     false,\n@@ -103,7 +103,7 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n             ty::ReStatic => true,\n             ty::ReEarlyBound(_) | ty::ReFree(_) => {\n                 let re_static = self.tcx.mk_region(ty::ReStatic);\n-                self.free_regions.relation.contains(&re_static, &super_region)\n+                self.free_regions.sub_free_regions(&re_static, &super_region)\n             }\n             _ => false\n         }\n@@ -117,121 +117,3 @@ impl<'a, 'gcx, 'tcx> RegionRelations<'a, 'gcx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct FreeRegionMap<'tcx> {\n-    // Stores the relation `a < b`, where `a` and `b` are regions.\n-    //\n-    // Invariant: only free regions like `'x` or `'static` are stored\n-    // in this relation, not scopes.\n-    relation: TransitiveRelation<Region<'tcx>>\n-}\n-\n-impl<'tcx> FreeRegionMap<'tcx> {\n-    pub fn new() -> Self {\n-        FreeRegionMap { relation: TransitiveRelation::new() }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.relation.is_empty()\n-    }\n-\n-    pub fn relate_free_regions_from_predicates(&mut self,\n-                                               predicates: &[ty::Predicate<'tcx>]) {\n-        debug!(\"relate_free_regions_from_predicates(predicates={:?})\", predicates);\n-        for predicate in predicates {\n-            match *predicate {\n-                ty::Predicate::Projection(..) |\n-                ty::Predicate::Trait(..) |\n-                ty::Predicate::Equate(..) |\n-                ty::Predicate::Subtype(..) |\n-                ty::Predicate::WellFormed(..) |\n-                ty::Predicate::ObjectSafe(..) |\n-                ty::Predicate::ClosureKind(..) |\n-                ty::Predicate::TypeOutlives(..) |\n-                ty::Predicate::ConstEvaluatable(..) => {\n-                    // No region bounds here\n-                }\n-                ty::Predicate::RegionOutlives(ty::Binder(ty::OutlivesPredicate(r_a, r_b))) => {\n-                    self.relate_regions(r_b, r_a);\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Record that `'sup:'sub`. Or, put another way, `'sub <= 'sup`.\n-    /// (with the exception that `'static: 'x` is not notable)\n-    pub fn relate_regions(&mut self, sub: Region<'tcx>, sup: Region<'tcx>) {\n-        debug!(\"relate_regions(sub={:?}, sup={:?})\", sub, sup);\n-        if (is_free(sub) || *sub == ty::ReStatic) && is_free(sup) {\n-            self.relation.add(sub, sup)\n-        }\n-    }\n-\n-    /// True if `r_a <= r_b` is known to hold. Both `r_a` and `r_b`\n-    /// must be free regions from the function header.\n-    pub fn sub_free_regions<'a, 'gcx>(&self,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> bool {\n-        debug!(\"sub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n-        let result = r_a == r_b || self.relation.contains(&r_a, &r_b);\n-        debug!(\"sub_free_regions: result={}\", result);\n-        result\n-    }\n-\n-    /// Compute the least-upper-bound of two free regions. In some\n-    /// cases, this is more conservative than necessary, in order to\n-    /// avoid making arbitrary choices. See\n-    /// `TransitiveRelation::postdom_upper_bound` for more details.\n-    pub fn lub_free_regions<'a, 'gcx>(&self,\n-                                      tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                      r_a: Region<'tcx>,\n-                                      r_b: Region<'tcx>)\n-                                      -> Region<'tcx> {\n-        debug!(\"lub_free_regions(r_a={:?}, r_b={:?})\", r_a, r_b);\n-        assert!(is_free(r_a));\n-        assert!(is_free(r_b));\n-        let result = if r_a == r_b { r_a } else {\n-            match self.relation.postdom_upper_bound(&r_a, &r_b) {\n-                None => tcx.mk_region(ty::ReStatic),\n-                Some(r) => *r,\n-            }\n-        };\n-        debug!(\"lub_free_regions(r_a={:?}, r_b={:?}) = {:?}\", r_a, r_b, result);\n-        result\n-    }\n-\n-    /// Returns all regions that are known to outlive `r_a`. For\n-    /// example, in a function:\n-    ///\n-    /// ```\n-    /// fn foo<'a, 'b: 'a, 'c: 'b>() { .. }\n-    /// ```\n-    ///\n-    /// if `r_a` represents `'a`, this function would return `{'b, 'c}`.\n-    pub fn regions_that_outlive<'a, 'gcx>(&self, r_a: Region<'tcx>) -> Vec<&Region<'tcx>> {\n-        assert!(is_free(r_a) || *r_a == ty::ReStatic);\n-        self.relation.greater_than(&r_a)\n-    }\n-}\n-\n-fn is_free(r: Region) -> bool {\n-    match *r {\n-        ty::ReEarlyBound(_) | ty::ReFree(_) => true,\n-        _ => false\n-    }\n-}\n-\n-impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n-    relation\n-});\n-\n-impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n-    type Lifted = FreeRegionMap<'tcx>;\n-    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n-                     .map(|relation| FreeRegionMap { relation })\n-    }\n-}"}, {"sha": "93e33836818ce9d9f75559694b9fe7a6175db078", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -400,14 +400,14 @@ fn process_predicate<'a, 'gcx, 'tcx>(\n \n         ty::Predicate::TypeOutlives(ref binder) => {\n             // Check if there are higher-ranked regions.\n-            match selcx.tcx().no_late_bound_regions(binder) {\n+            match binder.no_late_bound_regions() {\n                 // If there are, inspect the underlying type further.\n                 None => {\n                     // Convert from `Binder<OutlivesPredicate<Ty, Region>>` to `Binder<Ty>`.\n                     let binder = binder.map_bound_ref(|pred| pred.0);\n \n                     // Check if the type has any bound regions.\n-                    match selcx.tcx().no_late_bound_regions(&binder) {\n+                    match binder.no_late_bound_regions() {\n                         // If so, this obligation is an error (for now). Eventually we should be\n                         // able to support additional cases here, like `for<'a> &'a str: 'a`.\n                         None => {"}, {"sha": "d6f8a5f9cc6a152a58a203e698cc0c47cb0c609c", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -17,9 +17,9 @@ pub use self::ObligationCauseCode::*;\n \n use hir;\n use hir::def_id::DefId;\n+use infer::outlives::env::OutlivesEnvironment;\n use middle::const_val::ConstEvalErr;\n use middle::region;\n-use middle::free_region::FreeRegionMap;\n use ty::subst::Substs;\n use ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable, ToPredicate};\n use ty::error::{ExpectedFound, TypeError};\n@@ -554,9 +554,13 @@ pub fn normalize_param_env_or_error<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             predicates);\n \n         let region_scope_tree = region::ScopeTree::default();\n-        let free_regions = FreeRegionMap::new();\n \n-        infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &free_regions);\n+        // We can use the `elaborated_env` here; the region code only\n+        // cares about declarations like `'a: 'b`.\n+        let outlives_env = OutlivesEnvironment::new(elaborated_env);\n+\n+        infcx.resolve_regions_and_report_errors(region_context, &region_scope_tree, &outlives_env);\n+\n         let predicates = match infcx.fully_resolve(&predicates) {\n             Ok(predicates) => predicates,\n             Err(fixup_err) => {"}, {"sha": "429771cca9844c831f787868ee0e9a1618f2ad7e", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -1559,7 +1559,7 @@ impl<'cx, 'gcx, 'tcx> ProjectionCacheKey<'tcx> {\n         let infcx = selcx.infcx();\n         // We don't do cross-snapshot caching of obligations with escaping regions,\n         // so there's no cache key to use\n-        infcx.tcx.no_late_bound_regions(&predicate)\n+        predicate.no_late_bound_regions()\n             .map(|predicate| ProjectionCacheKey {\n                 // We don't attempt to match up with a specific type-variable state\n                 // from a specific call to `opt_normalize_projection_type` - if"}, {"sha": "91e6c4270b32a24b0b504d4060b0bc68a4d51424", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -1834,7 +1834,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         //     T: Trait\n         // so it seems ok if we (conservatively) fail to accept that `Unsize`\n         // obligation above. Should be possible to extend this in the future.\n-        let source = match self.tcx().no_late_bound_regions(&obligation.self_ty()) {\n+        let source = match obligation.self_ty().no_late_bound_regions() {\n             Some(t) => t,\n             None => {\n                 // Don't add any candidates if there are bound regions.\n@@ -2784,7 +2784,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // assemble_candidates_for_unsizing should ensure there are no late bound\n         // regions here. See the comment there for more details.\n         let source = self.infcx.shallow_resolve(\n-            tcx.no_late_bound_regions(&obligation.self_ty()).unwrap());\n+            obligation.self_ty().no_late_bound_regions().unwrap());\n         let target = obligation.predicate.skip_binder().trait_ref.substs.type_at(1);\n         let target = self.infcx.shallow_resolve(target);\n "}, {"sha": "ce05acb01b001af9f5028045397da02206790f77", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -23,10 +23,10 @@ use hir::map as hir_map;\n use hir::map::DefPathHash;\n use lint::{self, Lint};\n use ich::{StableHashingContext, NodeIdHashingMode};\n+use infer::outlives::free_region_map::FreeRegionMap;\n use middle::const_val::ConstVal;\n use middle::cstore::{CrateStore, LinkMeta};\n use middle::cstore::EncodedMetadata;\n-use middle::free_region::FreeRegionMap;\n use middle::lang_items;\n use middle::resolve_lifetime::{self, ObjectLifetimeDefault};\n use middle::stability;"}, {"sha": "069dc0275cbb17f8e70fd94870c8033615c43962", "filename": "src/librustc/ty/fold.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ffold.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -40,6 +40,7 @@\n //! and does not need to visit anything else.\n \n use middle::const_val::ConstVal;\n+use hir::def_id::DefId;\n use ty::{self, Binder, Ty, TyCtxt, TypeFlags};\n \n use std::fmt;\n@@ -246,7 +247,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n                 match *r {\n-                    ty::ReLateBound(debruijn, _) if debruijn.depth < self.current_depth => {\n+                    ty::ReLateBound(debruijn, _) if debruijn.depth <= self.current_depth => {\n                         /* ignore bound regions */\n                     }\n                     _ => (self.callback)(r),\n@@ -329,6 +330,14 @@ struct RegionReplacer<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    /// Replace all regions bound by the given `Binder` with the\n+    /// results returned by the closure; the closure is expected to\n+    /// return a free region (relative to this binder), and hence the\n+    /// binder is removed in the return type. The closure is invoked\n+    /// once for each unique `BoundRegion`; multiple references to the\n+    /// same `BoundRegion` will reuse the previous result.  A map is\n+    /// returned at the end with each bound region and the free region\n+    /// that replaced it.\n     pub fn replace_late_bound_regions<T,F>(self,\n         value: &Binder<T>,\n         mut f: F)\n@@ -341,6 +350,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         (result, replacer.map)\n     }\n \n+    /// Replace any late-bound regions bound in `value` with\n+    /// free variants attached to `all_outlive_scope`.\n+    pub fn liberate_late_bound_regions<T>(\n+        &self,\n+        all_outlive_scope: DefId,\n+        value: &ty::Binder<T>\n+    ) -> T\n+    where T: TypeFoldable<'tcx> {\n+        self.replace_late_bound_regions(value, |br| {\n+            self.mk_region(ty::ReFree(ty::FreeRegion {\n+                scope: all_outlive_scope,\n+                bound_region: br\n+            }))\n+        }).0\n+    }\n+\n     /// Flattens two binding levels into one. So `for<'a> for<'b> Foo`\n     /// becomes `for<'a,'b> Foo`.\n     pub fn flatten_late_bound_regions<T>(self, bound2_value: &Binder<Binder<T>>)\n@@ -364,16 +389,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         Binder(value)\n     }\n \n-    pub fn no_late_bound_regions<T>(self, value: &Binder<T>) -> Option<T>\n-        where T : TypeFoldable<'tcx>\n-    {\n-        if value.0.has_escaping_regions() {\n-            None\n-        } else {\n-            Some(value.0.clone())\n-        }\n-    }\n-\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those"}, {"sha": "afe999cede70d2d3e57b4b7ea2bae07d1d9ce976", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -1921,6 +1921,12 @@ impl<'a, 'gcx, 'tcx> FieldDef {\n     }\n }\n \n+/// Represents the various closure traits in the Rust language. This\n+/// will determine the type of the environment (`self`, in the\n+/// desuaring) argument that the closure expects.\n+///\n+/// You can get the environment type of a closure using\n+/// `tcx.closure_env_ty()`.\n #[derive(Clone, Copy, PartialOrd, Ord, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n pub enum ClosureKind {\n     // Warning: Ordering is significant here! The ordering is chosen"}, {"sha": "c115b573a1c062390edfd224421bf9990f6261ab", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -680,6 +680,26 @@ impl<T> Binder<T> {\n     {\n         ty::Binder(f(self.0))\n     }\n+\n+    /// Unwraps and returns the value within, but only if it contains\n+    /// no bound regions at all. (In other words, if this binder --\n+    /// and indeed any enclosing binder -- doesn't bind anything at\n+    /// all.) Otherwise, returns `None`.\n+    ///\n+    /// (One could imagine having a method that just unwraps a single\n+    /// binder, but permits late-bound regions bound by enclosing\n+    /// binders, but that would require adjusting the debruijn\n+    /// indices, and given the shallow binding structure we often use,\n+    /// would not be that useful.)\n+    pub fn no_late_bound_regions<'tcx>(self) -> Option<T>\n+        where T : TypeFoldable<'tcx>\n+    {\n+        if self.skip_binder().has_escaping_regions() {\n+            None\n+        } else {\n+            Some(self.skip_binder().clone())\n+        }\n+    }\n }\n \n /// Represents the projection of an associated type. In explicit UFCS"}, {"sha": "129badc46d8c10fff1fdb43b34560f5cb28be330", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -624,6 +624,13 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         self.def_key(def_id).disambiguated_data.data == DefPathData::ClosureExpr\n     }\n \n+    /// Given the `DefId` of a fn or closure, returns the `DefId` of\n+    /// the innermost fn item that the closure is contained within.\n+    /// This is a significant def-id because, when we do\n+    /// type-checking, we type-check this fn item and all of its\n+    /// (transitive) closures together.  Therefore, when we fetch the\n+    /// `typeck_tables_of` the closure, for example, we really wind up\n+    /// fetching the `typeck_tables_of` the enclosing fn item.\n     pub fn closure_base_def_id(self, def_id: DefId) -> DefId {\n         let mut def_id = def_id;\n         while self.is_closure(def_id) {\n@@ -634,6 +641,33 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         def_id\n     }\n \n+    /// Given the def-id and substs a closure, creates the type of\n+    /// `self` argument that the closure expects. For example, for a\n+    /// `Fn` closure, this would return a reference type `&T` where\n+    /// `T=closure_ty`.\n+    ///\n+    /// Returns `None` if this closure's kind has not yet been inferred.\n+    /// This should only be possible during type checking.\n+    ///\n+    /// Note that the return value is a late-bound region and hence\n+    /// wrapped in a binder.\n+    pub fn closure_env_ty(self,\n+                          closure_def_id: DefId,\n+                          closure_substs: ty::ClosureSubsts<'tcx>)\n+                          -> Option<ty::Binder<Ty<'tcx>>>\n+    {\n+        let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n+        let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n+        let closure_kind_ty = closure_substs.closure_kind_ty(closure_def_id, self);\n+        let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n+        let env_ty = match closure_kind {\n+            ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n+            ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n+            ty::ClosureKind::FnOnce => closure_ty,\n+        };\n+        Some(ty::Binder(env_ty))\n+    }\n+\n     /// Given the def-id of some item that has no type parameters, make\n     /// a suitable \"empty substs\" for it.\n     pub fn empty_substs_for_def_id(self, item_def_id: DefId) -> &'tcx ty::Substs<'tcx> {"}, {"sha": "ba7ab0c07c66a6a606cae6f99ac98965e3d620ac", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 131, "deletions": 4, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -134,12 +134,13 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n         }\n     }\n \n-    /// Returns a vector of all things greater than `a`.\n+    /// Thinking of `x R y` as an edge `x -> y` in a graph, this\n+    /// returns all things reachable from `a`.\n     ///\n     /// Really this probably ought to be `impl Iterator<Item=&T>`, but\n     /// I'm too lazy to make that work, and -- given the caching\n     /// strategy -- it'd be a touch tricky anyhow.\n-    pub fn greater_than(&self, a: &T) -> Vec<&T> {\n+    pub fn reachable_from(&self, a: &T) -> Vec<&T> {\n         match self.index(a) {\n             Some(a) => self.with_closure(|closure| {\n                 closure.iter(a.0).map(|i| &self.elements[i]).collect()\n@@ -184,7 +185,14 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n     /// b -> b1\n     /// ```\n     pub fn postdom_upper_bound(&self, a: &T, b: &T) -> Option<&T> {\n-        let mut mubs = self.minimal_upper_bounds(a, b);\n+        let mubs = self.minimal_upper_bounds(a, b);\n+        self.mutual_immediate_postdominator(mubs)\n+    }\n+\n+    /// Viewing the relation as a graph, computes the \"mutual\n+    /// immediate postdominator\" of a set of points (if one\n+    /// exists). See `postdom_upper_bound` for details.\n+    pub fn mutual_immediate_postdominator<'a>(&'a self, mut mubs: Vec<&'a T>) -> Option<&'a T> {\n         loop {\n             match mubs.len() {\n                 0 => return None,\n@@ -276,6 +284,8 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n             // After step 3, we know that no element can reach any of\n             // its predecesssors (because of step 2) nor successors\n             // (because we just called `pare_down`)\n+            //\n+            // This same algorithm is used in `parents` below.\n \n             let mut candidates = closure.intersection(a.0, b.0); // (1)\n             pare_down(&mut candidates, closure); // (2)\n@@ -290,6 +300,59 @@ impl<T: Clone + Debug + Eq + Hash + Clone> TransitiveRelation<T> {\n                    .collect()\n     }\n \n+    /// Given an element A, returns the maximal set {B} of elements B\n+    /// such that\n+    ///\n+    /// - A != B\n+    /// - A R B is true\n+    /// - for each i, j: B[i] R B[j] does not hold\n+    ///\n+    /// The intuition is that this moves \"one step up\" through a lattice\n+    /// (where the relation is encoding the `<=` relation for the lattice).\n+    /// So e.g. if the relation is `->` and we have\n+    ///\n+    /// ```\n+    /// a -> b -> d -> f\n+    /// |              ^\n+    /// +--> c -> e ---+\n+    /// ```\n+    ///\n+    /// then `parents(a)` returns `[b, c]`. The `postdom_parent` function\n+    /// would further reduce this to just `f`.\n+    pub fn parents(&self, a: &T) -> Vec<&T> {\n+        let a = match self.index(a) {\n+            Some(a) => a,\n+            None => return vec![]\n+        };\n+\n+        // Steal the algorithm for `minimal_upper_bounds` above, but\n+        // with a slight tweak. In the case where `a R a`, we remove\n+        // that from the set of candidates.\n+        let ancestors = self.with_closure(|closure| {\n+            let mut ancestors = closure.intersection(a.0, a.0);\n+\n+            // Remove anything that can reach `a`. If this is a\n+            // reflexive relation, this will include `a` itself.\n+            ancestors.retain(|&e| !closure.contains(e, a.0));\n+\n+            pare_down(&mut ancestors, closure); // (2)\n+            ancestors.reverse(); // (3a)\n+            pare_down(&mut ancestors, closure); // (3b)\n+            ancestors\n+        });\n+\n+        ancestors.into_iter()\n+                 .rev() // (4)\n+                 .map(|i| &self.elements[i])\n+                 .collect()\n+    }\n+\n+    /// A \"best\" parent in some sense. See `parents` and\n+    /// `postdom_upper_bound` for more details.\n+    pub fn postdom_parent(&self, a: &T) -> Option<&T> {\n+        self.mutual_immediate_postdominator(self.parents(a))\n+    }\n+\n     fn with_closure<OP, R>(&self, op: OP) -> R\n         where OP: FnOnce(&BitMatrix) -> R\n     {\n@@ -468,11 +531,17 @@ fn test_many_steps() {\n }\n \n #[test]\n-fn mubs_triange() {\n+fn mubs_triangle() {\n+    // a -> tcx\n+    //      ^\n+    //      |\n+    //      b\n     let mut relation = TransitiveRelation::new();\n     relation.add(\"a\", \"tcx\");\n     relation.add(\"b\", \"tcx\");\n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"a\"), vec![&\"tcx\"]);\n+    assert_eq!(relation.parents(&\"b\"), vec![&\"tcx\"]);\n }\n \n #[test]\n@@ -498,6 +567,9 @@ fn mubs_best_choice1() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"2\"]);\n+    assert_eq!(relation.parents(&\"2\"), vec![&\"1\"]);\n+    assert!(relation.parents(&\"1\").is_empty());\n }\n \n #[test]\n@@ -522,6 +594,9 @@ fn mubs_best_choice2() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"1\"), vec![&\"2\"]);\n+    assert!(relation.parents(&\"2\").is_empty());\n }\n \n #[test]\n@@ -536,10 +611,15 @@ fn mubs_no_best_choice() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\", &\"2\"]);\n+    assert_eq!(relation.parents(&\"3\"), vec![&\"1\", &\"2\"]);\n }\n \n #[test]\n fn mubs_best_choice_scc() {\n+    // in this case, 1 and 2 form a cycle; we pick arbitrarily (but\n+    // consistently).\n+\n     let mut relation = TransitiveRelation::new();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");\n@@ -551,6 +631,7 @@ fn mubs_best_choice_scc() {\n     relation.add(\"3\", \"2\");\n \n     assert_eq!(relation.minimal_upper_bounds(&\"0\", &\"3\"), vec![&\"1\"]);\n+    assert_eq!(relation.parents(&\"0\"), vec![&\"1\"]);\n }\n \n #[test]\n@@ -572,6 +653,8 @@ fn pdub_crisscross() {\n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"),\n                vec![&\"a1\", &\"b1\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -603,6 +686,9 @@ fn pdub_crisscross_more() {\n     assert_eq!(relation.minimal_upper_bounds(&\"a1\", &\"b1\"),\n                vec![&\"a2\", &\"b2\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -620,6 +706,11 @@ fn pdub_lub() {\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"x\"]);\n     assert_eq!(relation.postdom_upper_bound(&\"a\", &\"b\"), Some(&\"x\"));\n+\n+    assert_eq!(relation.postdom_parent(&\"a\"), Some(&\"a1\"));\n+    assert_eq!(relation.postdom_parent(&\"b\"), Some(&\"b1\"));\n+    assert_eq!(relation.postdom_parent(&\"a1\"), Some(&\"x\"));\n+    assert_eq!(relation.postdom_parent(&\"b1\"), Some(&\"x\"));\n }\n \n #[test]\n@@ -721,3 +812,39 @@ fn mubs_scc_4() {\n \n     assert_eq!(relation.minimal_upper_bounds(&\"a\", &\"b\"), vec![&\"c\"]);\n }\n+\n+#[test]\n+fn parent() {\n+    // An example that was misbehaving in the compiler.\n+    //\n+    // 4 -> 1 -> 3\n+    //   \\  |   /\n+    //    \\ v  /\n+    // 2 -> 0\n+    //\n+    // plus a bunch of self-loops\n+    //\n+    // Here `->` represents `<=` and `0` is `'static`.\n+\n+    let pairs = vec![\n+        (2, /*->*/ 0),\n+        (2, /*->*/ 2),\n+        (0, /*->*/ 0),\n+        (0, /*->*/ 0),\n+        (1, /*->*/ 0),\n+        (1, /*->*/ 1),\n+        (3, /*->*/ 0),\n+        (3, /*->*/ 3),\n+        (4, /*->*/ 0),\n+        (4, /*->*/ 1),\n+        (1, /*->*/ 3),\n+    ];\n+\n+    let mut relation = TransitiveRelation::new();\n+    for (a, b) in pairs {\n+        relation.add(a, b);\n+    }\n+\n+    let p = relation.postdom_parent(&3);\n+    assert_eq!(p, Some(&0));\n+}"}, {"sha": "0818b929ee7ad0f07f3100ba3bf2cb468fcece83", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -17,14 +17,14 @@ use driver;\n use rustc_lint;\n use rustc_resolve::MakeGlobMap;\n use rustc_trans;\n-use rustc::middle::free_region::FreeRegionMap;\n use rustc::middle::region;\n use rustc::middle::resolve_lifetime;\n use rustc::ty::subst::{Kind, Subst};\n use rustc::traits::{ObligationCause, Reveal};\n use rustc::ty::{self, Ty, TyCtxt, TypeFoldable};\n use rustc::ty::maps::OnDiskCache;\n use rustc::infer::{self, InferOk, InferResult};\n+use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc_metadata::cstore::CStore;\n use rustc::hir::map as hir_map;\n@@ -162,14 +162,15 @@ fn test_env<F>(source_string: &str,\n                              |tcx| {\n         tcx.infer_ctxt().enter(|infcx| {\n             let mut region_scope_tree = region::ScopeTree::default();\n+            let param_env = ty::ParamEnv::empty(Reveal::UserFacing);\n             body(Env {\n                 infcx: &infcx,\n                 region_scope_tree: &mut region_scope_tree,\n-                param_env: ty::ParamEnv::empty(Reveal::UserFacing),\n+                param_env: param_env,\n             });\n-            let free_regions = FreeRegionMap::new();\n+            let outlives_env = OutlivesEnvironment::new(param_env);\n             let def_id = tcx.hir.local_def_id(ast::CRATE_NODE_ID);\n-            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &free_regions);\n+            infcx.resolve_regions_and_report_errors(def_id, &region_scope_tree, &outlives_env);\n             assert_eq!(tcx.sess.err_count(), expected_err_count);\n         });\n     });"}, {"sha": "446aba3d3d72c595b042b7a1d500a222c11e92bc", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "renamed", "additions": 1067, "deletions": 699, "changes": 1766, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "previous_filename": "src/librustc_mir/borrow_check.rs"}, {"sha": "42225536357dae585d6252aa7a962ae2740692c7", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,337 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use rustc::hir;\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Place, Mir, Rvalue};\n+use rustc::mir::visit::Visitor;\n+use rustc::mir::Place::Projection;\n+use rustc::mir::{Local, PlaceProjection, ProjectionElem};\n+use rustc::mir::visit::TyContext;\n+use rustc::infer::InferCtxt;\n+use rustc::traits::{self, ObligationCause};\n+use rustc::ty::{self, ClosureSubsts, Ty};\n+use rustc::ty::subst::Substs;\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::util::common::ErrorReported;\n+use rustc_data_structures::fx::FxHashSet;\n+use syntax::codemap::DUMMY_SP;\n+use borrow_check::FlowInProgress;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::{HasMoveData, MoveData};\n+\n+use super::LivenessResults;\n+use super::ToRegionVid;\n+use super::region_infer::RegionInferenceContext;\n+\n+pub(super) fn generate_constraints<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    regioncx: &mut RegionInferenceContext<'tcx>,\n+    mir: &Mir<'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    liveness: &LivenessResults,\n+    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) {\n+    let mut cg = ConstraintGeneration {\n+        infcx,\n+        regioncx,\n+        mir,\n+        liveness,\n+        param_env,\n+        flow_inits,\n+        move_data,\n+    };\n+\n+    for (bb, data) in mir.basic_blocks().iter_enumerated() {\n+        cg.visit_basic_block_data(bb, data);\n+    }\n+}\n+\n+/// 'cg = the duration of the constraint generation process itself.\n+struct ConstraintGeneration<'cg, 'cx: 'cg, 'gcx: 'tcx, 'tcx: 'cx> {\n+    infcx: &'cg InferCtxt<'cx, 'gcx, 'tcx>,\n+    regioncx: &'cg mut RegionInferenceContext<'tcx>,\n+    mir: &'cg Mir<'tcx>,\n+    liveness: &'cg LivenessResults,\n+    param_env: ty::ParamEnv<'tcx>,\n+    flow_inits: &'cg mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &'cg MoveData<'tcx>,\n+}\n+\n+\n+impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx, 'tcx> {\n+    fn visit_basic_block_data(&mut self, bb: BasicBlock, data: &BasicBlockData<'tcx>) {\n+        self.add_liveness_constraints(bb);\n+        self.super_basic_block_data(bb, data);\n+    }\n+\n+    /// We sometimes have `substs` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_substs(&mut self, substs: &&'tcx Substs<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*substs, location);\n+        self.super_substs(substs);\n+    }\n+\n+    /// We sometimes have `region` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_region(&mut self, region: &ty::Region<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*region, location);\n+        self.super_region(region);\n+    }\n+\n+    /// We sometimes have `ty` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_ty(&mut self, ty: &ty::Ty<'tcx>, ty_context: TyContext) {\n+        match ty_context {\n+            TyContext::ReturnTy(source_info) |\n+            TyContext::LocalDecl { source_info, .. } => {\n+                span_bug!(source_info.span,\n+                          \"should not be visiting outside of the CFG: {:?}\",\n+                          ty_context);\n+            }\n+            TyContext::Location(location) => {\n+                self.add_regular_live_constraint(*ty, location);\n+            }\n+        }\n+\n+        self.super_ty(ty);\n+    }\n+\n+    /// We sometimes have `closure_substs` within an rvalue, or within a\n+    /// call. Make them live at the location where they appear.\n+    fn visit_closure_substs(&mut self, substs: &ClosureSubsts<'tcx>, location: Location) {\n+        self.add_regular_live_constraint(*substs, location);\n+        self.super_closure_substs(substs);\n+    }\n+\n+    fn visit_rvalue(&mut self, rvalue: &Rvalue<'tcx>, location: Location) {\n+        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n+\n+        // Look for an rvalue like:\n+        //\n+        //     & L\n+        //\n+        // where L is the path that is borrowed. In that case, we have\n+        // to add the reborrow constraints (which don't fall out\n+        // naturally from the type-checker).\n+        if let Rvalue::Ref(region, _bk, ref borrowed_lv) = *rvalue {\n+            self.add_reborrow_constraint(location, region, borrowed_lv);\n+        }\n+\n+        self.super_rvalue(rvalue, location);\n+    }\n+}\n+\n+impl<'cx, 'cg, 'gcx, 'tcx> ConstraintGeneration<'cx, 'cg, 'gcx, 'tcx> {\n+    /// Liveness constraints:\n+    ///\n+    /// > If a variable V is live at point P, then all regions R in the type of V\n+    /// > must include the point P.\n+    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n+        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n+\n+        self.liveness\n+            .regular\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                for live_local in live_locals.iter() {\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_regular_live_constraint(live_local_ty, location);\n+                }\n+            });\n+\n+        let mut all_live_locals: Vec<(Location, Vec<Local>)> = vec![];\n+        self.liveness\n+            .drop\n+            .simulate_block(self.mir, bb, |location, live_locals| {\n+                all_live_locals.push((location, live_locals.iter().collect()));\n+            });\n+        debug!(\n+            \"add_liveness_constraints: all_live_locals={:#?}\",\n+            all_live_locals\n+        );\n+\n+        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n+        self.flow_inits.reset_to_entry_of(bb);\n+        while let Some((location, live_locals)) = all_live_locals.pop() {\n+            for live_local in live_locals {\n+                debug!(\n+                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n+                    location,\n+                    live_local\n+                );\n+\n+                self.flow_inits.each_state_bit(|mpi_init| {\n+                    debug!(\n+                        \"add_liveness_constraints: location={:?} initialized={:?}\",\n+                        location,\n+                        &self.flow_inits\n+                            .base_results\n+                            .operator()\n+                            .move_data()\n+                            .move_paths[mpi_init]\n+                    );\n+                });\n+\n+                let mpi = self.move_data.rev_lookup.find_local(live_local);\n+                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n+                    debug!(\n+                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n+                        self.move_data.move_paths[mpi],\n+                        self.move_data.move_paths[initialized_child]\n+                    );\n+\n+                    let live_local_ty = self.mir.local_decls[live_local].ty;\n+                    self.add_drop_live_constraint(live_local_ty, location);\n+                }\n+            }\n+\n+            if location.statement_index == terminator_index {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_terminator_effect(location);\n+            } else {\n+                debug!(\n+                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n+                    location\n+                );\n+                self.flow_inits.reconstruct_statement_effect(location);\n+            }\n+            self.flow_inits.apply_local_effect();\n+        }\n+    }\n+\n+    /// Some variable with type `live_ty` is \"regular live\" at\n+    /// `location` -- i.e., it may be used later. This means that all\n+    /// regions appearing in the type `live_ty` must be live at\n+    /// `location`.\n+    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        debug!(\n+            \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n+            live_ty,\n+            location\n+        );\n+\n+        self.infcx\n+            .tcx\n+            .for_each_free_region(&live_ty, |live_region| {\n+                let vid = live_region.to_region_vid();\n+                self.regioncx.add_live_point(vid, location);\n+            });\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n+        debug!(\n+            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n+            dropped_ty,\n+            location\n+        );\n+\n+        let tcx = self.infcx.tcx;\n+        let mut types = vec![(dropped_ty, 0)];\n+        let mut known = FxHashSet();\n+        while let Some((ty, depth)) = types.pop() {\n+            let span = DUMMY_SP; // FIXME\n+            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n+                Ok(result) => result,\n+                Err(ErrorReported) => {\n+                    continue;\n+                }\n+            };\n+\n+            let ty::DtorckConstraint {\n+                outlives,\n+                dtorck_types,\n+            } = result;\n+\n+            // All things in the `outlives` array may be touched by\n+            // the destructor and must be live at this point.\n+            for outlive in outlives {\n+                self.add_regular_live_constraint(outlive, location);\n+            }\n+\n+            // However, there may also be some types that\n+            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n+            // associated types and parameters). We need to normalize\n+            // associated types here and possibly recursively process.\n+            for ty in dtorck_types {\n+                let cause = ObligationCause::dummy();\n+                // We know that our original `dropped_ty` is well-formed,\n+                // so region obligations resulting from this normalization\n+                // should always hold.\n+                //\n+                // Therefore we ignore them instead of trying to match\n+                // them up with a location.\n+                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n+                match traits::fully_normalize_with_fulfillcx(\n+                    self.infcx, fulfillcx, cause, self.param_env, &ty\n+                ) {\n+                    Ok(ty) => match ty.sty {\n+                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n+                            self.add_regular_live_constraint(ty, location);\n+                        }\n+\n+                        _ => if known.insert(ty) {\n+                            types.push((ty, depth + 1));\n+                        },\n+                    },\n+\n+                    Err(errors) => {\n+                        self.infcx.report_fulfillment_errors(&errors, None);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    fn add_reborrow_constraint(\n+        &mut self,\n+        location: Location,\n+        borrow_region: ty::Region<'tcx>,\n+        borrowed_place: &Place<'tcx>,\n+    ) {\n+        if let Projection(ref proj) = *borrowed_place {\n+            let PlaceProjection { ref base, ref elem } = **proj;\n+\n+            if let ProjectionElem::Deref = *elem {\n+                let tcx = self.infcx.tcx;\n+                let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n+                let base_sty = &base_ty.sty;\n+\n+                if let ty::TyRef(base_region, ty::TypeAndMut { ty: _, mutbl }) = *base_sty {\n+                    match mutbl {\n+                        hir::Mutability::MutImmutable => {}\n+\n+                        hir::Mutability::MutMutable => {\n+                            self.add_reborrow_constraint(location, borrow_region, base);\n+                        }\n+                    }\n+\n+                    let span = self.mir.source_info(location).span;\n+                    self.regioncx.add_outlives(\n+                        span,\n+                        base_region.to_region_vid(),\n+                        borrow_region.to_region_vid(),\n+                        location.successor_within_block(),\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "804f5e2687597521cddac9ea77566c12ce8d4aae", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "renamed", "additions": 48, "deletions": 16, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -17,43 +17,67 @@ use std::collections::BTreeSet;\n use transform::MirSource;\n use transform::type_check;\n use util::liveness::{self, LivenessMode, LivenessResult, LocalSet};\n+use borrow_check::FlowInProgress;\n+use dataflow::MaybeInitializedLvals;\n+use dataflow::move_paths::MoveData;\n \n use util as mir_util;\n use self::mir_util::PassWhere;\n \n mod constraint_generation;\n mod subtype_constraint_generation;\n-mod free_regions;\n+mod universal_regions;\n+use self::universal_regions::UniversalRegions;\n \n pub(crate) mod region_infer;\n use self::region_infer::RegionInferenceContext;\n \n mod renumber;\n \n-/// Computes the (non-lexical) regions from the input MIR.\n-///\n-/// This may result in errors being reported.\n-pub fn compute_regions<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+/// Rewrites the regions in the MIR to use NLL variables, also\n+/// scraping out the set of free regions (e.g., region parameters)\n+/// declared on the function. That set will need to be given to\n+/// `compute_regions`.\n+pub(in borrow_check) fn replace_regions_in_mir<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n     def_id: DefId,\n-    param_env: ty::ParamEnv<'gcx>,\n     mir: &mut Mir<'tcx>,\n-) -> RegionInferenceContext<'tcx> {\n+) -> UniversalRegions<'tcx> {\n     // Compute named region information.\n-    let free_regions = &free_regions::free_regions(infcx, def_id);\n+    let universal_regions = universal_regions::universal_regions(infcx, def_id);\n \n     // Replace all regions with fresh inference variables.\n-    renumber::renumber_mir(infcx, free_regions, mir);\n+    renumber::renumber_mir(infcx, &universal_regions, mir);\n+\n+    universal_regions\n+}\n \n+/// Computes the (non-lexical) regions from the input MIR.\n+///\n+/// This may result in errors being reported.\n+pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'cx, 'gcx, 'tcx>,\n+    def_id: DefId,\n+    universal_regions: UniversalRegions<'tcx>,\n+    mir: &Mir<'tcx>,\n+    param_env: ty::ParamEnv<'gcx>,\n+    flow_inits: &mut FlowInProgress<MaybeInitializedLvals<'cx, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+) -> RegionInferenceContext<'tcx> {\n     // Run the MIR type-checker.\n     let mir_node_id = infcx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let constraint_sets = &type_check::type_check(infcx, mir_node_id, param_env, mir);\n \n     // Create the region inference context, taking ownership of the region inference\n     // data that was contained in `infcx`.\n     let var_origins = infcx.take_region_var_origins();\n-    let mut regioncx = RegionInferenceContext::new(var_origins, free_regions, mir);\n-    subtype_constraint_generation::generate(&mut regioncx, free_regions, mir, constraint_sets);\n+    let mut regioncx = RegionInferenceContext::new(var_origins, &universal_regions, mir);\n+    subtype_constraint_generation::generate(\n+        &mut regioncx,\n+        &universal_regions,\n+        mir,\n+        constraint_sets,\n+    );\n \n     // Compute what is live where.\n     let liveness = &LivenessResults {\n@@ -75,7 +99,15 @@ pub fn compute_regions<'a, 'gcx, 'tcx>(\n     };\n \n     // Generate non-subtyping constraints.\n-    constraint_generation::generate_constraints(infcx, &mut regioncx, &mir, param_env, liveness);\n+    constraint_generation::generate_constraints(\n+        infcx,\n+        &mut regioncx,\n+        &mir,\n+        param_env,\n+        liveness,\n+        flow_inits,\n+        move_data,\n+    );\n \n     // Solve the region constraints.\n     regioncx.solve(infcx, &mir);\n@@ -133,7 +165,7 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         match pass_where {\n             // Before the CFG, dump out the values for each region variable.\n             PassWhere::BeforeCFG => for region in regioncx.regions() {\n-                writeln!(out, \"| {:?}: {:?}\", region, regioncx.region_value(region))?;\n+                writeln!(out, \"| {:?}: {}\", region, regioncx.region_value_str(region))?;\n             },\n \n             // Before each basic block, dump out the values\n@@ -143,15 +175,15 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                 writeln!(out, \"    | Live variables on entry to {:?}: {}\", bb, s)?;\n             }\n \n-            PassWhere::InCFG(location) => {\n+            PassWhere::BeforeLocation(location) => {\n                 let s = live_variable_set(\n                     &regular_liveness_per_location[&location],\n                     &drop_liveness_per_location[&location],\n                 );\n                 writeln!(out, \"            | Live variables at {:?}: {}\", location, s)?;\n             }\n \n-            PassWhere::AfterCFG => {}\n+            PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n         }\n         Ok(())\n     });", "previous_filename": "src/librustc_mir/transform/nll/mod.rs"}, {"sha": "d1faaf75a53233fd5940f6044ce7973996daf28d", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "added", "additions": 553, "deletions": 0, "changes": 553, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,553 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::universal_regions::UniversalRegions;\n+use rustc::infer::InferCtxt;\n+use rustc::infer::RegionVariableOrigin;\n+use rustc::infer::NLLRegionVariableOrigin;\n+use rustc::infer::region_constraints::VarOrigins;\n+use rustc::infer::outlives::free_region_map::FreeRegionMap;\n+use rustc::mir::{Location, Mir};\n+use rustc::ty::{self, RegionVid};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::bitvec::BitMatrix;\n+use rustc_data_structures::indexed_vec::Idx;\n+use std::collections::BTreeMap;\n+use std::fmt;\n+use syntax_pos::Span;\n+\n+pub struct RegionInferenceContext<'tcx> {\n+    /// Contains the definition for every region variable.  Region\n+    /// variables are identified by their index (`RegionVid`). The\n+    /// definition contains information about where the region came\n+    /// from as well as its final inferred value.\n+    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n+\n+    /// The liveness constraints added to each region. For most\n+    /// regions, these start out empty and steadily grow, though for\n+    /// each universally quantified region R they start out containing\n+    /// the entire CFG and `end(R)`.\n+    ///\n+    /// In this `BitMatrix` representation, the rows are the region\n+    /// variables and the columns are the free regions and MIR locations.\n+    liveness_constraints: BitMatrix,\n+\n+    /// The final inferred values of the inference variables; `None`\n+    /// until `solve` is invoked.\n+    inferred_values: Option<BitMatrix>,\n+\n+    /// The constraints we have accumulated and used during solving.\n+    constraints: Vec<Constraint>,\n+\n+    /// A map from each MIR Location to its column index in\n+    /// `liveness_constraints`/`inferred_values`. (The first N columns are\n+    /// the free regions.)\n+    point_indices: BTreeMap<Location, usize>,\n+\n+    /// Number of universally quantified regions. This is used to\n+    /// determine the meaning of the bits in `inferred_values` and\n+    /// friends.\n+    num_universal_regions: usize,\n+\n+    free_region_map: &'tcx FreeRegionMap<'tcx>,\n+}\n+\n+struct RegionDefinition<'tcx> {\n+    /// Why we created this variable. Mostly these will be\n+    /// `RegionVariableOrigin::NLL`, but some variables get created\n+    /// elsewhere in the code with other causes (e.g., instantiation\n+    /// late-bound-regions).\n+    origin: RegionVariableOrigin,\n+\n+    /// If this is a free-region, then this is `Some(X)` where `X` is\n+    /// the name of the region.\n+    name: Option<ty::Region<'tcx>>,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct Constraint {\n+    // NB. The ordering here is not significant for correctness, but\n+    // it is for convenience. Before we dump the constraints in the\n+    // debugging logs, we sort them, and we'd like the \"super region\"\n+    // to be first, etc. (In particular, span should remain last.)\n+    /// The region SUP must outlive SUB...\n+    sup: RegionVid,\n+\n+    /// Region that must be outlived.\n+    sub: RegionVid,\n+\n+    /// At this location.\n+    point: Location,\n+\n+    /// Where did this constraint arise?\n+    span: Span,\n+}\n+\n+impl<'tcx> RegionInferenceContext<'tcx> {\n+    /// Creates a new region inference context with a total of\n+    /// `num_region_variables` valid inference variables; the first N\n+    /// of those will be constant regions representing the free\n+    /// regions defined in `universal_regions`.\n+    pub fn new(\n+        var_origins: VarOrigins,\n+        universal_regions: &UniversalRegions<'tcx>,\n+        mir: &Mir<'tcx>,\n+    ) -> Self {\n+        let num_region_variables = var_origins.len();\n+        let num_universal_regions = universal_regions.indices.len();\n+\n+        let mut num_points = 0;\n+        let mut point_indices = BTreeMap::new();\n+\n+        for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n+            for statement_index in 0..block_data.statements.len() + 1 {\n+                let location = Location {\n+                    block,\n+                    statement_index,\n+                };\n+                point_indices.insert(location, num_universal_regions + num_points);\n+                num_points += 1;\n+            }\n+        }\n+\n+        // Create a RegionDefinition for each inference variable.\n+        let definitions = var_origins\n+            .into_iter()\n+            .map(|origin| RegionDefinition::new(origin))\n+            .collect();\n+\n+        let mut result = Self {\n+            definitions,\n+            liveness_constraints: BitMatrix::new(\n+                num_region_variables,\n+                num_universal_regions + num_points,\n+            ),\n+            inferred_values: None,\n+            constraints: Vec::new(),\n+            point_indices,\n+            num_universal_regions,\n+            free_region_map: universal_regions.free_region_map,\n+        };\n+\n+        result.init_universal_regions(universal_regions);\n+\n+        result\n+    }\n+\n+    /// Initializes the region variables for each universally\n+    /// quantified region (lifetime parameter). The first N variables\n+    /// always correspond to the regions appearing in the function\n+    /// signature (both named and anonymous) and where clauses. This\n+    /// function iterates over those regions and initializes them with\n+    /// minimum values.\n+    ///\n+    /// For example:\n+    ///\n+    ///     fn foo<'a, 'b>(..) where 'a: 'b\n+    ///\n+    /// would initialize two variables like so:\n+    ///\n+    ///     R0 = { CFG, R0 } // 'a\n+    ///     R1 = { CFG, R0, R1 } // 'b\n+    ///\n+    /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n+    /// and (b) any free regions that it outlives, which in this case\n+    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n+    /// hence contains R0 and R1.\n+    fn init_universal_regions(&mut self, universal_regions: &UniversalRegions<'tcx>) {\n+        let UniversalRegions {\n+            indices,\n+            free_region_map: _,\n+        } = universal_regions;\n+\n+        // For each universally quantified region X:\n+        for (free_region, &variable) in indices {\n+            // These should be free-region variables.\n+            assert!(match self.definitions[variable].origin {\n+                RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n+                _ => false,\n+            });\n+\n+            // Initialize the name and a few other details.\n+            self.definitions[variable].name = Some(free_region);\n+\n+            // Add all nodes in the CFG to liveness constraints\n+            for (_location, point_index) in &self.point_indices {\n+                self.liveness_constraints\n+                    .add(variable.index(), *point_index);\n+            }\n+\n+            // Add `end(X)` into the set for X.\n+            self.liveness_constraints\n+                .add(variable.index(), variable.index());\n+        }\n+    }\n+\n+    /// Returns an iterator over all the region indices.\n+    pub fn regions(&self) -> impl Iterator<Item = RegionVid> {\n+        self.definitions.indices()\n+    }\n+\n+    /// Returns true if the region `r` contains the point `p`.\n+    ///\n+    /// Panics if called before `solve()` executes,\n+    pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+        self.region_contains_point_in_matrix(inferred_values, r, p)\n+    }\n+\n+    /// True if given region `r` contains the point `p`, when\n+    /// evaluated in the set of region values `matrix`.\n+    fn region_contains_point_in_matrix(\n+        &self,\n+        matrix: &BitMatrix,\n+        r: RegionVid,\n+        p: Location,\n+    ) -> bool {\n+        let point_index = self.point_indices\n+            .get(&p)\n+            .expect(\"point index should be known\");\n+        matrix.contains(r.index(), *point_index)\n+    }\n+\n+    /// True if given region `r` contains the `end(s)`, when\n+    /// evaluated in the set of region values `matrix`.\n+    fn region_contains_region_in_matrix(\n+        &self,\n+        matrix: &BitMatrix,\n+        r: RegionVid,\n+        s: RegionVid,\n+    ) -> bool {\n+        matrix.contains(r.index(), s.index())\n+    }\n+\n+    /// Returns access to the value of `r` for debugging purposes.\n+    pub(super) fn region_value_str(&self, r: RegionVid) -> String {\n+        let inferred_values = self.inferred_values\n+            .as_ref()\n+            .expect(\"region values not yet inferred\");\n+\n+        let mut result = String::new();\n+        result.push_str(\"{\");\n+        let mut sep = \"\";\n+\n+        for &point in self.point_indices.keys() {\n+            if self.region_contains_point_in_matrix(inferred_values, r, point) {\n+                result.push_str(&format!(\"{}{:?}\", sep, point));\n+                sep = \", \";\n+            }\n+        }\n+\n+        for fr in (0..self.num_universal_regions).map(RegionVid::new) {\n+            if self.region_contains_region_in_matrix(inferred_values, r, fr) {\n+                result.push_str(&format!(\"{}{:?}\", sep, fr));\n+                sep = \", \";\n+            }\n+        }\n+\n+        result.push_str(\"}\");\n+\n+        result\n+    }\n+\n+    /// Indicates that the region variable `v` is live at the point `point`.\n+    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) -> bool {\n+        debug!(\"add_live_point({:?}, {:?})\", v, point);\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        let point_index = self.point_indices\n+            .get(&point)\n+            .expect(\"point index should be known\");\n+        self.liveness_constraints.add(v.index(), *point_index)\n+    }\n+\n+    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n+    pub(super) fn add_outlives(\n+        &mut self,\n+        span: Span,\n+        sup: RegionVid,\n+        sub: RegionVid,\n+        point: Location,\n+    ) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        self.constraints.push(Constraint {\n+            span,\n+            sup,\n+            sub,\n+            point,\n+        });\n+    }\n+\n+    /// Perform region inference.\n+    pub(super) fn solve(&mut self, infcx: &InferCtxt<'_, '_, 'tcx>, mir: &Mir<'tcx>) {\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+\n+        // Find the minimal regions that can solve the constraints. This is infallible.\n+        self.propagate_constraints(mir);\n+\n+        // Now, see whether any of the constraints were too strong. In\n+        // particular, we want to check for a case where a universally\n+        // quantified region exceeded its bounds.  Consider:\n+        //\n+        //     fn foo<'a, 'b>(x: &'a u32) -> &'b u32 { x }\n+        //\n+        // In this case, returning `x` requires `&'a u32 <: &'b u32`\n+        // and hence we establish (transitively) a constraint that\n+        // `'a: 'b`. The `propagate_constraints` code above will\n+        // therefore add `end('a)` into the region for `'b` -- but we\n+        // have no evidence that `'a` outlives `'b`, so we want to report\n+        // an error.\n+\n+        // The universal regions are always found in a prefix of the\n+        // full list.\n+        let free_region_definitions = self.definitions\n+            .iter_enumerated()\n+            .take_while(|(_, fr_definition)| fr_definition.name.is_some());\n+\n+        for (fr, fr_definition) in free_region_definitions {\n+            self.check_free_region(infcx, fr, fr_definition);\n+        }\n+    }\n+\n+    fn check_free_region(\n+        &self,\n+        infcx: &InferCtxt<'_, '_, 'tcx>,\n+        longer_fr: RegionVid,\n+        longer_definition: &RegionDefinition<'tcx>,\n+    ) {\n+        let inferred_values = self.inferred_values.as_ref().unwrap();\n+        let longer_name = longer_definition.name.unwrap();\n+        let longer_value = inferred_values.iter(longer_fr.index());\n+\n+        // Find every region `shorter` such that `longer: shorter`\n+        // (because `longer` includes `end(shorter)`).\n+        for shorter_fr in longer_value.take_while(|&i| i < self.num_universal_regions) {\n+            let shorter_fr = RegionVid::new(shorter_fr);\n+\n+            // `fr` includes `end(fr)`, that's not especially\n+            // interesting.\n+            if longer_fr == shorter_fr {\n+                continue;\n+            }\n+\n+            let shorter_definition = &self.definitions[shorter_fr];\n+            let shorter_name = shorter_definition.name.unwrap();\n+\n+            // Check that `o <= fr`. If not, report an error.\n+            if !self.free_region_map\n+                .sub_free_regions(shorter_name, longer_name)\n+            {\n+                // FIXME: worst error msg ever\n+                let blame_span = self.blame_span(longer_fr, shorter_fr);\n+                infcx.tcx.sess.span_err(\n+                    blame_span,\n+                    &format!(\n+                        \"free region `{}` does not outlive `{}`\",\n+                        longer_name,\n+                        shorter_name\n+                    ),\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Propagate the region constraints: this will grow the values\n+    /// for each region variable until all the constraints are\n+    /// satisfied. Note that some values may grow **too** large to be\n+    /// feasible, but we check this later.\n+    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n+        let mut changed = true;\n+\n+        debug!(\"propagate_constraints()\");\n+        debug!(\"propagate_constraints: constraints={:#?}\", {\n+            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            constraints.sort();\n+            constraints\n+        });\n+\n+        // The initial values for each region are derived from the liveness\n+        // constraints we have accumulated.\n+        let mut inferred_values = self.liveness_constraints.clone();\n+\n+        while changed {\n+            changed = false;\n+            debug!(\"propagate_constraints: --------------------\");\n+            for constraint in &self.constraints {\n+                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+\n+                // Grow the value as needed to accommodate the\n+                // outlives constraint.\n+\n+                if self.copy(\n+                    &mut inferred_values,\n+                    mir,\n+                    constraint.sub,\n+                    constraint.sup,\n+                    constraint.point,\n+                ) {\n+                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n+                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n+                    changed = true;\n+                }\n+            }\n+            debug!(\"\\n\");\n+        }\n+\n+        self.inferred_values = Some(inferred_values);\n+    }\n+\n+    fn copy(\n+        &self,\n+        inferred_values: &mut BitMatrix,\n+        mir: &Mir<'tcx>,\n+        from_region: RegionVid,\n+        to_region: RegionVid,\n+        start_point: Location,\n+    ) -> bool {\n+        let mut changed = false;\n+\n+        let mut stack = vec![];\n+        let mut visited = FxHashSet();\n+\n+        stack.push(start_point);\n+        while let Some(p) = stack.pop() {\n+            debug!(\"        copy: p={:?}\", p);\n+\n+            if !self.region_contains_point_in_matrix(inferred_values, from_region, p) {\n+                debug!(\"            not in from-region\");\n+                continue;\n+            }\n+\n+            if !visited.insert(p) {\n+                debug!(\"            already visited\");\n+                continue;\n+            }\n+\n+            let point_index = self.point_indices.get(&p).unwrap();\n+            changed |= inferred_values.add(to_region.index(), *point_index);\n+\n+            let block_data = &mir[p.block];\n+            let successor_points = if p.statement_index < block_data.statements.len() {\n+                vec![\n+                    Location {\n+                        statement_index: p.statement_index + 1,\n+                        ..p\n+                    },\n+                ]\n+            } else {\n+                block_data\n+                    .terminator()\n+                    .successors()\n+                    .iter()\n+                    .map(|&basic_block| {\n+                        Location {\n+                            statement_index: 0,\n+                            block: basic_block,\n+                        }\n+                    })\n+                    .collect::<Vec<_>>()\n+            };\n+\n+            if successor_points.is_empty() {\n+                // If we reach the END point in the graph, then copy\n+                // over any skolemized end points in the `from_region`\n+                // and make sure they are included in the `to_region`.\n+                let universal_region_indices = inferred_values\n+                    .iter(from_region.index())\n+                    .take_while(|&i| i < self.num_universal_regions)\n+                    .collect::<Vec<_>>();\n+                for fr in &universal_region_indices {\n+                    changed |= inferred_values.add(to_region.index(), *fr);\n+                }\n+            } else {\n+                stack.extend(successor_points);\n+            }\n+        }\n+\n+        changed\n+    }\n+\n+    /// Tries to finds a good span to blame for the fact that `fr1`\n+    /// contains `fr2`.\n+    fn blame_span(&self, fr1: RegionVid, fr2: RegionVid) -> Span {\n+        // Find everything that influenced final value of `fr`.\n+        let influenced_fr1 = self.dependencies(fr1);\n+\n+        // Try to find some outlives constraint `'X: fr2` where `'X`\n+        // influenced `fr1`. Blame that.\n+        //\n+        // NB, this is a pretty bad choice most of the time. In\n+        // particular, the connection between `'X` and `fr1` may not\n+        // be obvious to the user -- not to mention the naive notion\n+        // of dependencies, which doesn't account for the locations of\n+        // contraints at all. But it will do for now.\n+        for constraint in &self.constraints {\n+            if constraint.sub == fr2 && influenced_fr1[constraint.sup] {\n+                return constraint.span;\n+            }\n+        }\n+\n+        bug!(\n+            \"could not find any constraint to blame for {:?}: {:?}\",\n+            fr1,\n+            fr2\n+        );\n+    }\n+\n+    /// Finds all regions whose values `'a` may depend on in some way.\n+    /// Basically if there exists a constraint `'a: 'b @ P`, then `'b`\n+    /// and `dependencies('b)` will be in the final set.\n+    ///\n+    /// Used during error reporting, extremely naive and inefficient.\n+    fn dependencies(&self, r0: RegionVid) -> IndexVec<RegionVid, bool> {\n+        let mut result_set = IndexVec::from_elem(false, &self.definitions);\n+        let mut changed = true;\n+        result_set[r0] = true;\n+\n+        while changed {\n+            changed = false;\n+            for constraint in &self.constraints {\n+                if result_set[constraint.sup] {\n+                    if !result_set[constraint.sub] {\n+                        result_set[constraint.sub] = true;\n+                        changed = true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        result_set\n+    }\n+}\n+\n+impl<'tcx> RegionDefinition<'tcx> {\n+    fn new(origin: RegionVariableOrigin) -> Self {\n+        // Create a new region definition. Note that, for free\n+        // regions, these fields get updated later in\n+        // `init_universal_regions`.\n+        Self { origin, name: None }\n+    }\n+}\n+\n+impl fmt::Debug for Constraint {\n+    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n+        write!(\n+            formatter,\n+            \"({:?}: {:?} @ {:?}) due to {:?}\",\n+            self.sup,\n+            self.sub,\n+            self.point,\n+            self.span\n+        )\n+    }\n+}"}, {"sha": "371419da0244871fd4d6114ca53296eda0024180", "filename": "src/librustc_mir/borrow_check/nll/renumber.rs", "status": "renamed", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Frenumber.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -16,18 +16,18 @@ use rustc::mir::visit::{MutVisitor, TyContext};\n use rustc::infer::{InferCtxt, NLLRegionVariableOrigin};\n \n use super::ToRegionVid;\n-use super::free_regions::FreeRegions;\n+use super::universal_regions::UniversalRegions;\n \n /// Replaces all free regions appearing in the MIR with fresh\n /// inference variables, returning the number of variables created.\n pub fn renumber_mir<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    free_regions: &FreeRegions<'tcx>,\n+    universal_regions: &UniversalRegions<'tcx>,\n     mir: &mut Mir<'tcx>,\n ) {\n     // Create inference variables for each of the free regions\n     // declared on the function signature.\n-    let free_region_inference_vars = (0..free_regions.indices.len())\n+    let free_region_inference_vars = (0..universal_regions.indices.len())\n         .map(RegionVid::new)\n         .map(|vid_expected| {\n             let r = infcx.next_nll_region_var(NLLRegionVariableOrigin::FreeRegion);\n@@ -37,12 +37,12 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n         .collect();\n \n     debug!(\"renumber_mir()\");\n-    debug!(\"renumber_mir: free_regions={:#?}\", free_regions);\n+    debug!(\"renumber_mir: universal_regions={:#?}\", universal_regions);\n     debug!(\"renumber_mir: mir.arg_count={:?}\", mir.arg_count);\n \n     let mut visitor = NLLVisitor {\n         infcx,\n-        free_regions,\n+        universal_regions,\n         free_region_inference_vars,\n         arg_count: mir.arg_count,\n     };\n@@ -51,7 +51,7 @@ pub fn renumber_mir<'a, 'gcx, 'tcx>(\n \n struct NLLVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n-    free_regions: &'a FreeRegions<'tcx>,\n+    universal_regions: &'a UniversalRegions<'tcx>,\n     free_region_inference_vars: IndexVec<RegionVid, ty::Region<'tcx>>,\n     arg_count: usize,\n }\n@@ -76,16 +76,16 @@ impl<'a, 'gcx, 'tcx> NLLVisitor<'a, 'gcx, 'tcx> {\n \n     /// Renumbers the regions appearing in `value`, but those regions\n     /// are expected to be free regions from the function signature.\n-    fn renumber_free_regions<T>(&mut self, value: &T) -> T\n+    fn renumber_universal_regions<T>(&mut self, value: &T) -> T\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        debug!(\"renumber_free_regions(value={:?})\", value);\n+        debug!(\"renumber_universal_regions(value={:?})\", value);\n \n         self.infcx\n             .tcx\n             .fold_regions(value, &mut false, |region, _depth| {\n-                let index = self.free_regions.indices[&region];\n+                let index = self.universal_regions.indices[&region];\n                 self.free_region_inference_vars[index]\n             })\n     }\n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> MutVisitor<'tcx> for NLLVisitor<'a, 'gcx, 'tcx> {\n \n         let old_ty = *ty;\n         *ty = if is_arg {\n-            self.renumber_free_regions(&old_ty)\n+            self.renumber_universal_regions(&old_ty)\n         } else {\n             self.renumber_regions(ty_context, &old_ty)\n         };", "previous_filename": "src/librustc_mir/transform/nll/renumber.rs"}, {"sha": "dbae40be6fe1da1a15a9a5a1a5801b96b5cbc0f5", "filename": "src/librustc_mir/borrow_check/nll/subtype_constraint_generation.rs", "status": "renamed", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fsubtype_constraint_generation.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -15,7 +15,7 @@ use rustc::ty;\n use transform::type_check::MirTypeckRegionConstraints;\n use transform::type_check::OutlivesSet;\n \n-use super::free_regions::FreeRegions;\n+use super::universal_regions::UniversalRegions;\n use super::region_infer::RegionInferenceContext;\n \n /// When the MIR type-checker executes, it validates all the types in\n@@ -25,20 +25,20 @@ use super::region_infer::RegionInferenceContext;\n /// them into the NLL `RegionInferenceContext`.\n pub(super) fn generate<'tcx>(\n     regioncx: &mut RegionInferenceContext<'tcx>,\n-    free_regions: &FreeRegions<'tcx>,\n+    universal_regions: &UniversalRegions<'tcx>,\n     mir: &Mir<'tcx>,\n     constraints: &MirTypeckRegionConstraints<'tcx>,\n ) {\n     SubtypeConstraintGenerator {\n         regioncx,\n-        free_regions,\n+        universal_regions,\n         mir,\n     }.generate(constraints);\n }\n \n struct SubtypeConstraintGenerator<'cx, 'tcx: 'cx> {\n     regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    free_regions: &'cx FreeRegions<'tcx>,\n+    universal_regions: &'cx UniversalRegions<'tcx>,\n     mir: &'cx Mir<'tcx>,\n }\n \n@@ -102,11 +102,11 @@ impl<'cx, 'tcx> SubtypeConstraintGenerator<'cx, 'tcx> {\n         // Every region that we see in the constraints came from the\n         // MIR or from the parameter environment. If the former, it\n         // will be a region variable.  If the latter, it will be in\n-        // the set of free regions *somewhere*.\n+        // the set of universal regions *somewhere*.\n         if let ty::ReVar(vid) = r {\n             *vid\n         } else {\n-            self.free_regions.indices[&r]\n+            self.universal_regions.indices[&r]\n         }\n     }\n }", "previous_filename": "src/librustc_mir/transform/nll/subtype_constraint_generation.rs"}, {"sha": "3be95a114c3bc287dd010f92dd76c9dc9533b487", "filename": "src/librustc_mir/borrow_check/nll/universal_regions.rs", "status": "renamed", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Funiversal_regions.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -8,8 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Code to extract the free regions declared on a function and the\n-//! relationships between them. For example:\n+//! Code to extract the universally quantified regions declared on a\n+//! function and the relationships between them. For example:\n //!\n //! ```\n //! fn foo<'a, 'b, 'c: 'b>() { }\n@@ -24,29 +24,29 @@\n \n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n-use rustc::middle::free_region::FreeRegionMap;\n+use rustc::infer::outlives::free_region_map::FreeRegionMap;\n use rustc::ty::{self, RegionVid};\n use rustc::ty::subst::Substs;\n use rustc::util::nodemap::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n \n #[derive(Debug)]\n-pub struct FreeRegions<'tcx> {\n-    /// Given a free region defined on this function (either early- or\n-    /// late-bound), this maps it to its internal region index. When\n-    /// the region context is created, the first N variables will be\n-    /// created based on these indices.\n+pub struct UniversalRegions<'tcx> {\n+    /// Given a universally quantified region defined on this function\n+    /// (either early- or late-bound), this maps it to its internal\n+    /// region index. When the region context is created, the first N\n+    /// variables will be created based on these indices.\n     pub indices: FxHashMap<ty::Region<'tcx>, RegionVid>,\n \n-    /// The map from the typeck tables telling us how to relate free regions.\n+    /// The map from the typeck tables telling us how to relate universal regions.\n     pub free_region_map: &'tcx FreeRegionMap<'tcx>,\n }\n \n-pub fn free_regions<'a, 'gcx, 'tcx>(\n+pub fn universal_regions<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n     item_def_id: DefId,\n-) -> FreeRegions<'tcx> {\n-    debug!(\"free_regions(item_def_id={:?})\", item_def_id);\n+) -> UniversalRegions<'tcx> {\n+    debug!(\"universal_regions(item_def_id={:?})\", item_def_id);\n \n     let mut indices = FxHashMap();\n \n@@ -76,15 +76,15 @@ pub fn free_regions<'a, 'gcx, 'tcx>(\n             }\n         });\n \n-    debug!(\"free_regions: indices={:#?}\", indices);\n+    debug!(\"universal_regions: indices={:#?}\", indices);\n \n-    FreeRegions { indices, free_region_map: &tables.free_region_map }\n+    UniversalRegions { indices, free_region_map: &tables.free_region_map }\n }\n \n fn insert_free_region<'tcx>(\n-    free_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n+    universal_regions: &mut FxHashMap<ty::Region<'tcx>, RegionVid>,\n     region: ty::Region<'tcx>,\n ) {\n-    let next = RegionVid::new(free_regions.len());\n-    free_regions.entry(region).or_insert(next);\n+    let next = RegionVid::new(universal_regions.len());\n+    universal_regions.entry(region).or_insert(next);\n }", "previous_filename": "src/librustc_mir/transform/nll/free_regions.rs"}, {"sha": "d814b092c9d69159050611833d1d3971afb348f6", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 7, "deletions": 23, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -100,7 +100,7 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n                     // HACK(eddyb) Avoid having RustCall on closures,\n                     // as it adds unnecessary (and wrong) auto-tupling.\n                     abi = Abi::Rust;\n-                    Some((closure_self_ty(tcx, id, body_id), None))\n+                    Some((liberated_closure_env_ty(tcx, id, body_id), None))\n                 }\n                 ty::TyGenerator(..) => {\n                     let gen_ty = tcx.body_tables(body_id).node_id_to_type(fn_hir_id);\n@@ -246,10 +246,10 @@ fn create_constructor_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n ///////////////////////////////////////////////////////////////////////////\n // BuildMir -- walks a crate, looking for fn items and methods to build MIR from\n \n-pub fn closure_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       closure_expr_id: ast::NodeId,\n-                                       body_id: hir::BodyId)\n-                                       -> Ty<'tcx> {\n+fn liberated_closure_env_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                            closure_expr_id: ast::NodeId,\n+                                            body_id: hir::BodyId)\n+                                            -> Ty<'tcx> {\n     let closure_expr_hir_id = tcx.hir.node_to_hir_id(closure_expr_id);\n     let closure_ty = tcx.body_tables(body_id).node_id_to_type(closure_expr_hir_id);\n \n@@ -258,24 +258,8 @@ pub fn closure_self_ty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty)\n     };\n \n-    let region = ty::ReFree(ty::FreeRegion {\n-        scope: closure_def_id,\n-        bound_region: ty::BoundRegion::BrEnv,\n-    });\n-    let region = tcx.mk_region(region);\n-\n-    match closure_substs.closure_kind_ty(closure_def_id, tcx).to_opt_closure_kind().unwrap() {\n-        ty::ClosureKind::Fn =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutImmutable }),\n-        ty::ClosureKind::FnMut =>\n-            tcx.mk_ref(region,\n-                       ty::TypeAndMut { ty: closure_ty,\n-                                        mutbl: hir::MutMutable }),\n-        ty::ClosureKind::FnOnce =>\n-            closure_ty\n-    }\n+    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n+    tcx.liberate_late_bound_regions(closure_def_id, &closure_env_ty)\n }\n \n struct Builder<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {"}, {"sha": "2bba3e263f3c63df89c7a3fbc4cbeb8136dc4044", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -21,8 +21,8 @@ use rustc_data_structures::indexed_vec::{IndexVec};\n \n use dataflow::{BitDenotation, BlockSets, DataflowOperator};\n pub use dataflow::indexes::BorrowIndex;\n-use transform::nll::region_infer::RegionInferenceContext;\n-use transform::nll::ToRegionVid;\n+use borrow_check::nll::region_infer::RegionInferenceContext;\n+use borrow_check::nll::ToRegionVid;\n \n use syntax_pos::Span;\n \n@@ -38,7 +38,7 @@ pub struct Borrows<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     location_map: FxHashMap<Location, BorrowIndex>,\n     region_map: FxHashMap<Region<'tcx>, FxHashSet<BorrowIndex>>,\n     region_span_map: FxHashMap<RegionKind, Span>,\n-    nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>,\n+    nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>,\n }\n \n // temporarily allow some dead fields: `kind` and `region` will be\n@@ -69,7 +69,7 @@ impl<'tcx> fmt::Display for BorrowData<'tcx> {\n impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                mir: &'a Mir<'tcx>,\n-               nonlexical_regioncx: Option<&'a RegionInferenceContext<'tcx>>)\n+               nonlexical_regioncx: Option<RegionInferenceContext<'tcx>>)\n                -> Self {\n         let mut visitor = GatherBorrows {\n             tcx,\n@@ -132,10 +132,6 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n         &self.borrows[idx].location\n     }\n \n-    pub fn nonlexical_regioncx(&self) -> Option<&'a RegionInferenceContext<'tcx>> {\n-        self.nonlexical_regioncx\n-    }\n-\n     /// Returns the span for the \"end point\" given region. This will\n     /// return `None` if NLL is enabled, since that concept has no\n     /// meaning there.  Otherwise, return region span if it exists and\n@@ -156,7 +152,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     fn kill_loans_out_of_scope_at_location(&self,\n                                            sets: &mut BlockSets<BorrowIndex>,\n                                            location: Location) {\n-        if let Some(regioncx) = self.nonlexical_regioncx {\n+        if let Some(ref regioncx) = self.nonlexical_regioncx {\n             for (borrow_index, borrow_data) in self.borrows.iter_enumerated() {\n                 let borrow_region = borrow_data.region.to_region_vid();\n                 if !regioncx.region_contains_point(borrow_region, location) {"}, {"sha": "9d91e1344dc373b16f27c6a2b58a3ea47f0e516d", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -263,6 +263,10 @@ impl<'tcx> MovePathLookup<'tcx> {\n             }\n         }\n     }\n+\n+    pub fn find_local(&self, local: Local) -> MovePathIndex {\n+        self.locals[local]\n+    }\n }\n \n #[derive(Debug)]"}, {"sha": "53f9b885ac6c62481a456e05b37bd16611e0edd9", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -18,12 +18,15 @@ Rust MIR: a lowered representation of Rust. Also: an experiment!\n \n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(catch_expr)]\n #![feature(conservative_impl_trait)]\n #![feature(const_fn)]\n #![feature(core_intrinsics)]\n #![feature(decl_macro)]\n #![feature(i128_type)]\n+#![feature(inclusive_range_syntax)]\n #![feature(match_default_bindings)]\n+#![feature(range_contains)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(placement_in_syntax)]\n #![feature(collection_placement)]"}, {"sha": "46193dedf8968055b62a2e7ac04b4929f5eb1e6c", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -833,7 +833,7 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n     let tcx = infcx.tcx;\n     let gcx = tcx.global_tcx();\n     let def_id = tcx.hir.local_def_id(ctor_id);\n-    let sig = gcx.no_late_bound_regions(&gcx.fn_sig(def_id))\n+    let sig = gcx.fn_sig(def_id).no_late_bound_regions()\n         .expect(\"LBR in ADT constructor signature\");\n     let sig = gcx.erase_regions(&sig);\n     let param_env = gcx.param_env(def_id);"}, {"sha": "981b0b854bdabf2a347e18c897bae47a4c053322", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -146,7 +146,7 @@ fn check_lang_item_type<'a, 'tcx, D>(\n {\n     let did = tcx.require_lang_item(lang_item);\n     let poly_sig = tcx.fn_sig(did);\n-    let sig = tcx.no_late_bound_regions(&poly_sig).unwrap();\n+    let sig = poly_sig.no_late_bound_regions().unwrap();\n     let lhs_ty = lhs.ty(local_decls, tcx);\n     let rhs_ty = rhs.ty(local_decls, tcx);\n     let place_ty = place.ty(local_decls, tcx).to_ty(tcx);"}, {"sha": "fb9daf07c71dc735a894c260d482496bec3e0a3c", "filename": "src/librustc_mir/transform/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -43,7 +43,6 @@ pub mod instcombine;\n pub mod copy_prop;\n pub mod generator;\n pub mod inline;\n-pub mod nll;\n pub mod lower_128bit;\n \n pub(crate) fn provide(providers: &mut Providers) {"}, {"sha": "73d5a610dbd537ac8e2e2353ad3f34629b386e50", "filename": "src/librustc_mir/transform/nll/constraint_generation.rs", "status": "removed", "additions": 0, "deletions": 241, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fconstraint_generation.rs?ref=226656ff72e3ecd3f715d1bbd4f3b25576a7bc61", "patch": "@@ -1,241 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use rustc::hir;\n-use rustc::mir::{Location, Place, Mir, Rvalue};\n-use rustc::mir::visit::Visitor;\n-use rustc::mir::Place::Projection;\n-use rustc::mir::{PlaceProjection, ProjectionElem};\n-use rustc::infer::InferCtxt;\n-use rustc::traits::{self, ObligationCause};\n-use rustc::ty::{self, Ty};\n-use rustc::ty::fold::TypeFoldable;\n-use rustc::util::common::ErrorReported;\n-use rustc_data_structures::fx::FxHashSet;\n-use syntax::codemap::DUMMY_SP;\n-\n-use super::LivenessResults;\n-use super::ToRegionVid;\n-use super::region_infer::RegionInferenceContext;\n-\n-pub(super) fn generate_constraints<'a, 'gcx, 'tcx>(\n-    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    regioncx: &mut RegionInferenceContext<'tcx>,\n-    mir: &Mir<'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n-    liveness: &LivenessResults,\n-) {\n-    ConstraintGeneration {\n-        infcx,\n-        regioncx,\n-        mir,\n-        liveness,\n-        param_env,\n-    }.add_constraints();\n-}\n-\n-struct ConstraintGeneration<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n-    infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    regioncx: &'cx mut RegionInferenceContext<'tcx>,\n-    mir: &'cx Mir<'tcx>,\n-    liveness: &'cx LivenessResults,\n-    param_env: ty::ParamEnv<'tcx>,\n-}\n-\n-impl<'cx, 'gcx, 'tcx> ConstraintGeneration<'cx, 'gcx, 'tcx> {\n-    fn add_constraints(&mut self) {\n-        self.add_liveness_constraints();\n-        self.add_borrow_constraints();\n-    }\n-\n-    /// Liveness constraints:\n-    ///\n-    /// > If a variable V is live at point P, then all regions R in the type of V\n-    /// > must include the point P.\n-    fn add_liveness_constraints(&mut self) {\n-        debug!(\"add_liveness_constraints()\");\n-        for bb in self.mir.basic_blocks().indices() {\n-            debug!(\"add_liveness_constraints: bb={:?}\", bb);\n-\n-            self.liveness\n-                .regular\n-                .simulate_block(self.mir, bb, |location, live_locals| {\n-                    for live_local in live_locals.iter() {\n-                        let live_local_ty = self.mir.local_decls[live_local].ty;\n-                        self.add_regular_live_constraint(live_local_ty, location);\n-                    }\n-                });\n-\n-            self.liveness\n-                .drop\n-                .simulate_block(self.mir, bb, |location, live_locals| {\n-                    for live_local in live_locals.iter() {\n-                        let live_local_ty = self.mir.local_decls[live_local].ty;\n-                        self.add_drop_live_constraint(live_local_ty, location);\n-                    }\n-                });\n-        }\n-    }\n-\n-    /// Some variable with type `live_ty` is \"regular live\" at\n-    /// `location` -- i.e., it may be used later. This means that all\n-    /// regions appearing in the type `live_ty` must be live at\n-    /// `location`.\n-    fn add_regular_live_constraint<T>(&mut self, live_ty: T, location: Location)\n-    where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"add_regular_live_constraint(live_ty={:?}, location={:?})\",\n-            live_ty,\n-            location\n-        );\n-\n-        self.infcx\n-            .tcx\n-            .for_each_free_region(&live_ty, |live_region| {\n-                let vid = live_region.to_region_vid();\n-                self.regioncx.add_live_point(vid, location);\n-            });\n-    }\n-\n-    /// Some variable with type `live_ty` is \"drop live\" at `location`\n-    /// -- i.e., it may be dropped later. This means that *some* of\n-    /// the regions in its type must be live at `location`. The\n-    /// precise set will depend on the dropck constraints, and in\n-    /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(&mut self, dropped_ty: Ty<'tcx>, location: Location) {\n-        debug!(\n-            \"add_drop_live_constraint(dropped_ty={:?}, location={:?})\",\n-            dropped_ty,\n-            location\n-        );\n-\n-        let tcx = self.infcx.tcx;\n-        let mut types = vec![(dropped_ty, 0)];\n-        let mut known = FxHashSet();\n-        while let Some((ty, depth)) = types.pop() {\n-            let span = DUMMY_SP; // FIXME\n-            let result = match tcx.dtorck_constraint_for_ty(span, dropped_ty, depth, ty) {\n-                Ok(result) => result,\n-                Err(ErrorReported) => {\n-                    continue;\n-                }\n-            };\n-\n-            let ty::DtorckConstraint {\n-                outlives,\n-                dtorck_types,\n-            } = result;\n-\n-            // All things in the `outlives` array may be touched by\n-            // the destructor and must be live at this point.\n-            for outlive in outlives {\n-                if let Some(ty) = outlive.as_type() {\n-                    self.add_regular_live_constraint(ty, location);\n-                } else if let Some(r) = outlive.as_region() {\n-                    self.add_regular_live_constraint(r, location);\n-                } else {\n-                    bug!()\n-                }\n-            }\n-\n-            // However, there may also be some types that\n-            // `dtorck_constraint_for_ty` could not resolve (e.g.,\n-            // associated types and parameters). We need to normalize\n-            // associated types here and possibly recursively process.\n-            for ty in dtorck_types {\n-                let cause = ObligationCause::dummy();\n-                // We know that our original `dropped_ty` is well-formed,\n-                // so region obligations resulting from this normalization\n-                // should always hold.\n-                //\n-                // Therefore we ignore them instead of trying to match\n-                // them up with a location.\n-                let fulfillcx = traits::FulfillmentContext::new_ignoring_regions();\n-                match traits::fully_normalize_with_fulfillcx(\n-                    self.infcx, fulfillcx, cause, self.param_env, &ty\n-                ) {\n-                    Ok(ty) => match ty.sty {\n-                        ty::TyParam(..) | ty::TyProjection(..) | ty::TyAnon(..) => {\n-                            self.add_regular_live_constraint(ty, location);\n-                        }\n-\n-                        _ => if known.insert(ty) {\n-                            types.push((ty, depth + 1));\n-                        },\n-                    },\n-\n-                    Err(errors) => {\n-                        self.infcx.report_fulfillment_errors(&errors, None);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    fn add_borrow_constraints(&mut self) {\n-        self.visit_mir(self.mir);\n-    }\n-\n-    fn add_reborrow_constraint(\n-        &mut self,\n-        location: Location,\n-        borrow_region: ty::Region<'tcx>,\n-        borrowed_place: &Place<'tcx>,\n-    ) {\n-        if let Projection(ref proj) = *borrowed_place {\n-            let PlaceProjection { ref base, ref elem } = **proj;\n-\n-            if let ProjectionElem::Deref = *elem {\n-                let tcx = self.infcx.tcx;\n-                let base_ty = base.ty(self.mir, tcx).to_ty(tcx);\n-                let base_sty = &base_ty.sty;\n-\n-                if let ty::TyRef(base_region, ty::TypeAndMut{ ty: _, mutbl }) = *base_sty {\n-                    match mutbl {\n-                        hir::Mutability::MutImmutable => { },\n-\n-                        hir::Mutability::MutMutable => {\n-                            self.add_reborrow_constraint(location, borrow_region, base);\n-                        },\n-                    }\n-\n-                    let span = self.mir.source_info(location).span;\n-                    self.regioncx.add_outlives(span,\n-                                               base_region.to_region_vid(),\n-                                               borrow_region.to_region_vid(),\n-                                               location.successor_within_block());\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-impl<'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cx, 'gcx, 'tcx> {\n-    fn visit_rvalue(&mut self,\n-                    rvalue: &Rvalue<'tcx>,\n-                    location: Location) {\n-        debug!(\"visit_rvalue(rvalue={:?}, location={:?})\", rvalue, location);\n-\n-        // Look for an rvalue like:\n-        //\n-        //     & L\n-        //\n-        // where L is the path that is borrowed. In that case, we have\n-        // to add the reborrow constraints (which don't fall out\n-        // naturally from the type-checker).\n-        if let Rvalue::Ref(region, _bk, ref borrowed_place) = *rvalue {\n-            self.add_reborrow_constraint(location, region, borrowed_place);\n-        }\n-\n-        self.super_rvalue(rvalue, location);\n-    }\n-}"}, {"sha": "1609c1236b0ca9b22fd90774dc40e261637a899d", "filename": "src/librustc_mir/transform/nll/region_infer.rs", "status": "removed", "additions": 0, "deletions": 443, "changes": 443, "blob_url": "https://github.com/rust-lang/rust/blob/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/226656ff72e3ecd3f715d1bbd4f3b25576a7bc61/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fnll%2Fregion_infer.rs?ref=226656ff72e3ecd3f715d1bbd4f3b25576a7bc61", "patch": "@@ -1,443 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use super::free_regions::FreeRegions;\n-use rustc::infer::InferCtxt;\n-use rustc::infer::RegionVariableOrigin;\n-use rustc::infer::NLLRegionVariableOrigin;\n-use rustc::infer::region_constraints::VarOrigins;\n-use rustc::mir::{Location, Mir};\n-use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::indexed_vec::IndexVec;\n-use rustc_data_structures::fx::FxHashSet;\n-use std::collections::BTreeSet;\n-use std::fmt;\n-use syntax_pos::Span;\n-\n-pub struct RegionInferenceContext<'tcx> {\n-    /// Contains the definition for every region variable.  Region\n-    /// variables are identified by their index (`RegionVid`). The\n-    /// definition contains information about where the region came\n-    /// from as well as its final inferred value.\n-    definitions: IndexVec<RegionVid, RegionDefinition<'tcx>>,\n-\n-    /// The constraints we have accumulated and used during solving.\n-    constraints: Vec<Constraint>,\n-}\n-\n-struct RegionDefinition<'tcx> {\n-    /// Why we created this variable. Mostly these will be\n-    /// `RegionVariableOrigin::NLL`, but some variables get created\n-    /// elsewhere in the code with other causes (e.g., instantiation\n-    /// late-bound-regions).\n-    origin: RegionVariableOrigin,\n-\n-    /// If this is a free-region, then this is `Some(X)` where `X` is\n-    /// the name of the region.\n-    name: Option<ty::Region<'tcx>>,\n-\n-    /// If true, this is a constant region which cannot grow larger.\n-    /// This is used for named regions as well as `'static`.\n-    constant: bool,\n-\n-    /// The current value of this inference variable. This starts out\n-    /// empty, but grows as we add constraints. The final value is\n-    /// determined when `solve()` is executed.\n-    value: Region,\n-}\n-\n-/// The value of an individual region variable. Region variables\n-/// consist of a set of points in the CFG as well as a set of \"free\n-/// regions\", which are sometimes written as `end(R)`. These\n-/// correspond to the named lifetimes and refer to portions of the\n-/// caller's control-flow graph -- specifically some portion that can\n-/// be reached after we return.\n-#[derive(Clone, Default, PartialEq, Eq)]\n-struct Region {\n-    points: BTreeSet<Location>,\n-    free_regions: BTreeSet<RegionVid>,\n-}\n-\n-impl fmt::Debug for Region {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        formatter\n-            .debug_set()\n-            .entries(&self.points)\n-            .entries(&self.free_regions)\n-            .finish()\n-    }\n-}\n-\n-impl Region {\n-    fn add_point(&mut self, point: Location) -> bool {\n-        self.points.insert(point)\n-    }\n-\n-    fn add_free_region(&mut self, region: RegionVid) -> bool {\n-        self.free_regions.insert(region)\n-    }\n-\n-    fn contains_point(&self, point: Location) -> bool {\n-        self.points.contains(&point)\n-    }\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct Constraint {\n-    // NB. The ordering here is not significant for correctness, but\n-    // it is for convenience. Before we dump the constraints in the\n-    // debugging logs, we sort them, and we'd like the \"super region\"\n-    // to be first, etc. (In particular, span should remain last.)\n-\n-    /// The region SUP must outlive SUB...\n-    sup: RegionVid,\n-\n-    /// Region that must be outlived.\n-    sub: RegionVid,\n-\n-    /// At this location.\n-    point: Location,\n-\n-    /// Where did this constraint arise?\n-    span: Span,\n-}\n-\n-impl<'a, 'gcx, 'tcx> RegionInferenceContext<'tcx> {\n-    /// Creates a new region inference context with a total of\n-    /// `num_region_variables` valid inference variables; the first N\n-    /// of those will be constant regions representing the free\n-    /// regions defined in `free_regions`.\n-    pub fn new(var_origins: VarOrigins, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) -> Self {\n-        // Create a RegionDefinition for each inference variable.\n-        let definitions = var_origins\n-            .into_iter()\n-            .map(|origin| RegionDefinition::new(origin))\n-            .collect();\n-\n-        let mut result = Self {\n-            definitions: definitions,\n-            constraints: Vec::new(),\n-        };\n-\n-        result.init_free_regions(free_regions, mir);\n-\n-        result\n-    }\n-\n-    /// Initializes the region variables for each free region\n-    /// (lifetime parameter). The first N variables always correspond\n-    /// to the free regions appearing in the function signature (both\n-    /// named and anonymous) and where clauses. This function iterates\n-    /// over those regions and initializes them with minimum values.\n-    ///\n-    /// For example:\n-    ///\n-    ///     fn foo<'a, 'b>(..) where 'a: 'b\n-    ///\n-    /// would initialize two variables like so:\n-    ///\n-    ///     R0 = { CFG, R0 } // 'a\n-    ///     R1 = { CFG, R0, R1 } // 'b\n-    ///\n-    /// Here, R0 represents `'a`, and it contains (a) the entire CFG\n-    /// and (b) any free regions that it outlives, which in this case\n-    /// is just itself. R1 (`'b`) in contrast also outlives `'a` and\n-    /// hence contains R0 and R1.\n-    fn init_free_regions(&mut self, free_regions: &FreeRegions<'tcx>, mir: &Mir<'tcx>) {\n-        let FreeRegions {\n-            indices,\n-            free_region_map,\n-        } = free_regions;\n-\n-        // For each free region X:\n-        for (free_region, &variable) in indices {\n-            // These should be free-region variables.\n-            assert!(match self.definitions[variable].origin {\n-                RegionVariableOrigin::NLL(NLLRegionVariableOrigin::FreeRegion) => true,\n-                _ => false,\n-            });\n-\n-            // Initialize the name and a few other details.\n-            self.definitions[variable].name = Some(free_region);\n-            self.definitions[variable].constant = true;\n-\n-            // Add all nodes in the CFG to `definition.value`.\n-            for (block, block_data) in mir.basic_blocks().iter_enumerated() {\n-                let definition = &mut self.definitions[variable];\n-                for statement_index in 0..block_data.statements.len() + 1 {\n-                    let location = Location {\n-                        block,\n-                        statement_index,\n-                    };\n-                    definition.value.add_point(location);\n-                }\n-            }\n-\n-            // Add `end(X)` into the set for X.\n-            self.definitions[variable].value.add_free_region(variable);\n-\n-            // `'static` outlives all other free regions as well.\n-            if let ty::ReStatic = free_region {\n-                for &other_variable in indices.values() {\n-                    self.definitions[variable]\n-                        .value\n-                        .add_free_region(other_variable);\n-                }\n-            }\n-\n-            // Go through each region Y that outlives X (i.e., where\n-            // Y: X is true). Add `end(X)` into the set for `Y`.\n-            for superregion in free_region_map.regions_that_outlive(&free_region) {\n-                let superregion_index = indices[superregion];\n-                self.definitions[superregion_index]\n-                    .value\n-                    .add_free_region(variable);\n-            }\n-\n-            debug!(\n-                \"init_free_regions: region variable for `{:?}` is `{:?}` with value `{:?}`\",\n-                free_region,\n-                variable,\n-                self.definitions[variable].value\n-            );\n-        }\n-    }\n-\n-    /// Returns an iterator over all the region indices.\n-    pub fn regions(&self) -> impl Iterator<Item = RegionVid> {\n-        self.definitions.indices()\n-    }\n-\n-    /// Returns true if the region `r` contains the point `p`.\n-    ///\n-    /// Until `solve()` executes, this value is not particularly meaningful.\n-    pub fn region_contains_point(&self, r: RegionVid, p: Location) -> bool {\n-        self.definitions[r].value.contains_point(p)\n-    }\n-\n-    /// Returns access to the value of `r` for debugging purposes.\n-    pub(super) fn region_value(&self, r: RegionVid) -> &fmt::Debug {\n-        &self.definitions[r].value\n-    }\n-\n-    /// Indicates that the region variable `v` is live at the point `point`.\n-    pub(super) fn add_live_point(&mut self, v: RegionVid, point: Location) {\n-        debug!(\"add_live_point({:?}, {:?})\", v, point);\n-        let definition = &mut self.definitions[v];\n-        if !definition.constant {\n-            definition.value.add_point(point);\n-        } else {\n-            // Constants are used for free regions, which already\n-            // contain all the points in the control-flow graph.\n-            assert!(definition.value.contains_point(point));\n-        }\n-    }\n-\n-    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    pub(super) fn add_outlives(\n-        &mut self,\n-        span: Span,\n-        sup: RegionVid,\n-        sub: RegionVid,\n-        point: Location,\n-    ) {\n-        debug!(\"add_outlives({:?}: {:?} @ {:?}\", sup, sub, point);\n-        self.constraints.push(Constraint {\n-            span,\n-            sup,\n-            sub,\n-            point,\n-        });\n-    }\n-\n-    /// Perform region inference.\n-    pub(super) fn solve(&mut self, infcx: &InferCtxt<'a, 'gcx, 'tcx>, mir: &Mir<'tcx>) {\n-        let errors = self.propagate_constraints(mir);\n-\n-        // worst error msg ever\n-        for (fr1, span, fr2) in errors {\n-            infcx.tcx.sess.span_err(\n-                span,\n-                &format!(\n-                    \"free region `{}` does not outlive `{}`\",\n-                    self.definitions[fr1].name.unwrap(),\n-                    self.definitions[fr2].name.unwrap()\n-                ),\n-            );\n-        }\n-    }\n-\n-    /// Propagate the region constraints: this will grow the values\n-    /// for each region variable until all the constraints are\n-    /// satisfied. Note that some values may grow **too** large to be\n-    /// feasible, but we check this later.\n-    fn propagate_constraints(&mut self, mir: &Mir<'tcx>) -> Vec<(RegionVid, Span, RegionVid)> {\n-        let mut changed = true;\n-        let mut dfs = Dfs::new(mir);\n-        let mut error_regions = FxHashSet();\n-        let mut errors = vec![];\n-\n-        debug!(\"propagate_constraints()\");\n-        debug!(\"propagate_constraints: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iter().collect();\n-            constraints.sort();\n-            constraints\n-        });\n-\n-        while changed {\n-            changed = false;\n-            for constraint in &self.constraints {\n-                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n-                let sub = &self.definitions[constraint.sub].value.clone();\n-                let sup_def = &mut self.definitions[constraint.sup];\n-\n-                debug!(\"propagate_constraints:    sub (before): {:?}\", sub);\n-                debug!(\"propagate_constraints:    sup (before): {:?}\", sup_def.value);\n-\n-                if !sup_def.constant {\n-                    // If this is not a constant, then grow the value as needed to\n-                    // accommodate the outlives constraint.\n-\n-                    if dfs.copy(sub, &mut sup_def.value, constraint.point) {\n-                        changed = true;\n-                    }\n-\n-                    debug!(\"propagate_constraints:    sup (after) : {:?}\", sup_def.value);\n-                    debug!(\"propagate_constraints:    changed     : {:?}\", changed);\n-                } else {\n-                    // If this is a constant, check whether it *would\n-                    // have* to grow in order for the constraint to be\n-                    // satisfied. If so, create an error.\n-\n-                    let mut sup_value = sup_def.value.clone();\n-                    if dfs.copy(sub, &mut sup_value, constraint.point) {\n-                        // Constant values start out with the entire\n-                        // CFG, so it must be some new free region\n-                        // that was added. Find one.\n-                        let &new_region = sup_value\n-                            .free_regions\n-                            .difference(&sup_def.value.free_regions)\n-                            .next()\n-                            .unwrap();\n-                        debug!(\"propagate_constraints:    new_region : {:?}\", new_region);\n-                        if error_regions.insert(constraint.sup) {\n-                            errors.push((constraint.sup, constraint.span, new_region));\n-                        }\n-                    }\n-                }\n-            }\n-            debug!(\"\\n\");\n-        }\n-        errors\n-    }\n-}\n-\n-struct Dfs<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-}\n-\n-impl<'a, 'tcx> Dfs<'a, 'tcx> {\n-    fn new(mir: &'a Mir<'tcx>) -> Self {\n-        Self { mir }\n-    }\n-\n-    fn copy(\n-        &mut self,\n-        from_region: &Region,\n-        to_region: &mut Region,\n-        start_point: Location,\n-    ) -> bool {\n-        let mut changed = false;\n-\n-        let mut stack = vec![];\n-        let mut visited = FxHashSet();\n-\n-        stack.push(start_point);\n-        while let Some(p) = stack.pop() {\n-            debug!(\"        dfs: p={:?}\", p);\n-\n-            if !from_region.contains_point(p) {\n-                debug!(\"            not in from-region\");\n-                continue;\n-            }\n-\n-            if !visited.insert(p) {\n-                debug!(\"            already visited\");\n-                continue;\n-            }\n-\n-            changed |= to_region.add_point(p);\n-\n-            let block_data = &self.mir[p.block];\n-            let successor_points = if p.statement_index < block_data.statements.len() {\n-                vec![\n-                    Location {\n-                        statement_index: p.statement_index + 1,\n-                        ..p\n-                    },\n-                ]\n-            } else {\n-                block_data\n-                    .terminator()\n-                    .successors()\n-                    .iter()\n-                    .map(|&basic_block| {\n-                        Location {\n-                            statement_index: 0,\n-                            block: basic_block,\n-                        }\n-                    })\n-                    .collect::<Vec<_>>()\n-            };\n-\n-            if successor_points.is_empty() {\n-                // If we reach the END point in the graph, then copy\n-                // over any skolemized end points in the `from_region`\n-                // and make sure they are included in the `to_region`.\n-\n-                debug!(\"        dfs: free_regions={:?}\", from_region.free_regions);\n-                for &fr in &from_region.free_regions {\n-                    changed |= to_region.free_regions.insert(fr);\n-                }\n-            } else {\n-                stack.extend(successor_points);\n-            }\n-        }\n-\n-        changed\n-    }\n-}\n-\n-impl<'tcx> RegionDefinition<'tcx> {\n-    fn new(origin: RegionVariableOrigin) -> Self {\n-        // Create a new region definition. Note that, for free\n-        // regions, these fields get updated later in\n-        // `init_free_regions`.\n-        Self {\n-            origin,\n-            name: None,\n-            constant: false,\n-            value: Region::default(),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for Constraint {\n-    fn fmt(&self, formatter: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        write!(\n-            formatter,\n-            \"({:?}: {:?} @ {:?}) due to {:?}\",\n-            self.sup,\n-            self.sub,\n-            self.point,\n-            self.span\n-        )\n-    }\n-}"}, {"sha": "f0b62e28a0da618c2725caf2dab597ef130f180e", "filename": "src/librustc_mir/transform/type_check.rs", "status": "modified", "additions": 77, "deletions": 85, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ftype_check.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -104,12 +104,7 @@ impl<'a, 'b, 'gcx, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_place(\n-        &mut self,\n-        place: &Place<'tcx>,\n-        context: PlaceContext,\n-        location: Location,\n-    ) {\n+    fn visit_place(&mut self, place: &Place<'tcx>, context: PlaceContext, location: Location) {\n         self.sanitize_place(place, location, context);\n     }\n \n@@ -164,11 +159,12 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn sanitize_place(&mut self,\n-                       place: &Place<'tcx>,\n-                       location: Location,\n-                       context: PlaceContext)\n-                       -> PlaceTy<'tcx> {\n+    fn sanitize_place(\n+        &mut self,\n+        place: &Place<'tcx>,\n+        location: Location,\n+        context: PlaceContext,\n+    ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n         let place_ty = match *place {\n             Place::Local(index) => PlaceTy::Ty {\n@@ -178,9 +174,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(&ty, location);\n-                if let Err(terr) = self.cx\n-                    .eq_types(self.last_span, ty, sty, location.at_self())\n-                {\n+                if let Err(terr) = self.cx.eq_types(ty, sty, location.at_self()) {\n                     span_mirbug!(\n                         self,\n                         place,\n@@ -212,9 +206,11 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         };\n         if let PlaceContext::Copy = context {\n             let ty = place_ty.to_ty(self.tcx());\n-            if self.cx.infcx.type_moves_by_default(self.cx.param_env, ty, DUMMY_SP) {\n-                span_mirbug!(self, place,\n-                             \"attempted copy of non-Copy type ({:?})\", ty);\n+            if self.cx\n+                .infcx\n+                .type_moves_by_default(self.cx.param_env, ty, DUMMY_SP)\n+            {\n+                span_mirbug!(self, place, \"attempted copy of non-Copy type ({:?})\", ty);\n             }\n         }\n         place_ty\n@@ -230,7 +226,6 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         debug!(\"sanitize_projection: {:?} {:?} {:?}\", base, pi, place);\n         let tcx = self.tcx();\n         let base_ty = base.to_ty(tcx);\n-        let span = self.last_span;\n         match *pi {\n             ProjectionElem::Deref => {\n                 let deref_ty = base_ty.builtin_deref(true, ty::LvaluePreference::NoPreference);\n@@ -315,18 +310,16 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n             ProjectionElem::Field(field, fty) => {\n                 let fty = self.sanitize_type(place, fty);\n                 match self.field_ty(place, base, field, location) {\n-                    Ok(ty) => {\n-                        if let Err(terr) = self.cx.eq_types(span, ty, fty, location.at_self()) {\n-                            span_mirbug!(\n-                                self,\n-                                place,\n-                                \"bad field access ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                fty,\n-                                terr\n-                            );\n-                        }\n-                    }\n+                    Ok(ty) => if let Err(terr) = self.cx.eq_types(ty, fty, location.at_self()) {\n+                        span_mirbug!(\n+                            self,\n+                            place,\n+                            \"bad field access ({:?}: {:?}): {:?}\",\n+                            ty,\n+                            fty,\n+                            terr\n+                        );\n+                    },\n                     Err(FieldAccessError::OutOfRange { field_count }) => span_mirbug!(\n                         self,\n                         place,\n@@ -361,9 +354,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 variant_index,\n             } => (&adt_def.variants[variant_index], substs),\n             PlaceTy::Ty { ty } => match ty.sty {\n-                ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => {\n-                    (&adt_def.variants[0], substs)\n-                }\n+                ty::TyAdt(adt_def, substs) if !adt_def.is_enum() => (&adt_def.variants[0], substs),\n                 ty::TyClosure(def_id, substs) => {\n                     return match substs.upvar_tys(def_id, tcx).nth(field.index()) {\n                         Some(ty) => Ok(ty),\n@@ -529,13 +520,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         })\n     }\n \n-    fn eq_types(\n-        &mut self,\n-        _span: Span,\n-        a: Ty<'tcx>,\n-        b: Ty<'tcx>,\n-        locations: Locations,\n-    ) -> UnitResult<'tcx> {\n+    fn eq_types(&mut self, a: Ty<'tcx>, b: Ty<'tcx>, locations: Locations) -> UnitResult<'tcx> {\n         self.fully_perform_op(locations, |this| {\n             this.infcx\n                 .at(&this.misc(this.last_span), this.param_env)\n@@ -1031,13 +1016,13 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n \n     fn aggregate_field_ty(\n         &mut self,\n-        ak: &Box<AggregateKind<'tcx>>,\n+        ak: &AggregateKind<'tcx>,\n         field_index: usize,\n         location: Location,\n     ) -> Result<Ty<'tcx>, FieldAccessError> {\n         let tcx = self.tcx();\n \n-        match **ak {\n+        match *ak {\n             AggregateKind::Adt(def, variant_index, substs, active_field_index) => {\n                 let variant = &def.variants[variant_index];\n                 let adj_field_index = active_field_index.unwrap_or(field_index);\n@@ -1069,56 +1054,17 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     }\n                 }\n             }\n-            AggregateKind::Array(ty) => {\n-                Ok(ty)\n-            }\n+            AggregateKind::Array(ty) => Ok(ty),\n             AggregateKind::Tuple => {\n                 unreachable!(\"This should have been covered in check_rvalues\");\n             }\n         }\n     }\n \n-    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rv: &Rvalue<'tcx>, location: Location) {\n-        let tcx = self.tcx();\n-        match rv {\n+    fn check_rvalue(&mut self, mir: &Mir<'tcx>, rvalue: &Rvalue<'tcx>, location: Location) {\n+        match rvalue {\n             Rvalue::Aggregate(ak, ops) => {\n-                match **ak {\n-                    // tuple rvalue field type is always the type of the op. Nothing to check here.\n-                    AggregateKind::Tuple => {}\n-                    _ => {\n-                        for (i, op) in ops.iter().enumerate() {\n-                            let field_ty = match self.aggregate_field_ty(ak, i, location) {\n-                                Ok(field_ty) => field_ty,\n-                                Err(FieldAccessError::OutOfRange { field_count }) => {\n-                                    span_mirbug!(\n-                                        self,\n-                                        rv,\n-                                        \"accessed field #{} but variant only has {}\",\n-                                        i,\n-                                        field_count\n-                                    );\n-                                    continue;\n-                                }\n-                            };\n-                            let op_ty = op.ty(mir, tcx);\n-                            if let Err(terr) = self.sub_types(\n-                                op_ty,\n-                                field_ty,\n-                                location.at_successor_within_block(),\n-                            )\n-                                {\n-                                    span_mirbug!(\n-                                    self,\n-                                    rv,\n-                                    \"{:?} is not a subtype of {:?}: {:?}\",\n-                                    op_ty,\n-                                    field_ty,\n-                                    terr\n-                                );\n-                                }\n-                        }\n-                    }\n-                }\n+                self.check_aggregate_rvalue(mir, rvalue, ak, ops, location)\n             }\n             // FIXME: These other cases have to be implemented in future PRs\n             Rvalue::Use(..) |\n@@ -1134,6 +1080,52 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n         }\n     }\n \n+    fn check_aggregate_rvalue(\n+        &mut self,\n+        mir: &Mir<'tcx>,\n+        rvalue: &Rvalue<'tcx>,\n+        aggregate_kind: &AggregateKind<'tcx>,\n+        operands: &[Operand<'tcx>],\n+        location: Location,\n+    ) {\n+        match aggregate_kind {\n+            // tuple rvalue field type is always the type of the op. Nothing to check here.\n+            AggregateKind::Tuple => return,\n+            _ => {}\n+        }\n+\n+        let tcx = self.tcx();\n+\n+        for (i, operand) in operands.iter().enumerate() {\n+            let field_ty = match self.aggregate_field_ty(aggregate_kind, i, location) {\n+                Ok(field_ty) => field_ty,\n+                Err(FieldAccessError::OutOfRange { field_count }) => {\n+                    span_mirbug!(\n+                        self,\n+                        rvalue,\n+                        \"accessed field #{} but variant only has {}\",\n+                        i,\n+                        field_count\n+                    );\n+                    continue;\n+                }\n+            };\n+            let operand_ty = operand.ty(mir, tcx);\n+            if let Err(terr) =\n+                self.sub_types(operand_ty, field_ty, location.at_successor_within_block())\n+            {\n+                span_mirbug!(\n+                    self,\n+                    rvalue,\n+                    \"{:?} is not a subtype of {:?}: {:?}\",\n+                    operand_ty,\n+                    field_ty,\n+                    terr\n+                );\n+            }\n+        }\n+    }\n+\n     fn typeck_mir(&mut self, mir: &Mir<'tcx>) {\n         self.last_span = mir.span;\n         debug!(\"run_on_mir: {:?}\", mir.span);"}, {"sha": "eebe5a86018ea6ebb2a8eab45e6441ed48134d8a", "filename": "src/librustc_mir/util/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -15,7 +15,7 @@ pub mod patch;\n \n mod alignment;\n mod graphviz;\n-mod pretty;\n+pub(crate) mod pretty;\n pub mod liveness;\n \n pub use self::alignment::is_disaligned;"}, {"sha": "8a3db0eb25b99b0d921ff4b907b6add7f3cb6b17", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 240, "deletions": 131, "changes": 371, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -14,17 +14,17 @@ use rustc::mir::*;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::indexed_vec::{Idx};\n+use rustc_data_structures::indexed_vec::Idx;\n use std::fmt::Display;\n use std::fs;\n use std::io::{self, Write};\n-use std::path::{PathBuf, Path};\n+use std::path::{Path, PathBuf};\n use super::graphviz::write_mir_fn_graphviz;\n use transform::MirSource;\n \n const INDENT: &'static str = \"    \";\n /// Alignment for lining up comments following MIR statements\n-const ALIGN: usize = 40;\n+pub(crate) const ALIGN: usize = 40;\n \n /// An indication of where we are in the control flow graph. Used for printing\n /// extra information in `dump_mir`\n@@ -38,8 +38,11 @@ pub enum PassWhere {\n     /// We are about to start dumping the given basic block.\n     BeforeBlock(BasicBlock),\n \n-    /// We are just about to dumpt the given statement or terminator.\n-    InCFG(Location),\n+    /// We are just about to dump the given statement or terminator.\n+    BeforeLocation(Location),\n+\n+    /// We just dumped the given statement or terminator.\n+    AfterLocation(Location),\n }\n \n /// If the session is properly configured, dumps a human-readable\n@@ -56,64 +59,124 @@ pub enum PassWhere {\n /// - `substring1&substring2,...` -- `&`-separated list of substrings\n ///   that can appear in the pass-name or the `item_path_str` for the given\n ///   node-id. If any one of the substrings match, the data is dumped out.\n-pub fn dump_mir<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   pass_num: Option<&Display>,\n-                                   pass_name: &str,\n-                                   disambiguator: &Display,\n-                                   source: MirSource,\n-                                   mir: &Mir<'tcx>,\n-                                   extra_data: F)\n-where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+pub fn dump_mir<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    extra_data: F,\n+) where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n     }\n \n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    dump_matched_mir_node(tcx, pass_num, pass_name, &node_path,\n-                          disambiguator, source, mir, extra_data);\n+    dump_matched_mir_node(\n+        tcx,\n+        pass_num,\n+        pass_name,\n+        &node_path,\n+        disambiguator,\n+        source,\n+        mir,\n+        extra_data,\n+    );\n }\n \n-pub fn dump_enabled<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                    pass_name: &str,\n-                                    source: MirSource)\n-                                    -> bool {\n+pub fn dump_enabled<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_name: &str,\n+    source: MirSource,\n+) -> bool {\n     let filters = match tcx.sess.opts.debugging_opts.dump_mir {\n         None => return false,\n         Some(ref filters) => filters,\n     };\n-    let node_path = item_path::with_forced_impl_filename_line(|| { // see notes on #41697 below\n+    let node_path = item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 below\n         tcx.item_path_str(source.def_id)\n     });\n-    filters.split(\"&\")\n-           .any(|filter| {\n-               filter == \"all\" ||\n-                   pass_name.contains(filter) ||\n-                   node_path.contains(filter)\n-           })\n+    filters.split(\"&\").any(|filter| {\n+        filter == \"all\" || pass_name.contains(filter) || node_path.contains(filter)\n+    })\n }\n \n // #41697 -- we use `with_forced_impl_filename_line()` because\n // `item_path_str()` would otherwise trigger `type_of`, and this can\n // run while we are already attempting to evaluate `type_of`.\n \n-fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                            pass_num: Option<&Display>,\n-                                            pass_name: &str,\n-                                            node_path: &str,\n-                                            disambiguator: &Display,\n-                                            source: MirSource,\n-                                            mir: &Mir<'tcx>,\n-                                            mut extra_data: F)\n-where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+fn dump_matched_mir_node<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    node_path: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+    mir: &Mir<'tcx>,\n+    mut extra_data: F,\n+) where\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n+    let _: io::Result<()> = do catch {\n+        let mut file = create_dump_file(\n+            tcx,\n+            \"mir\",\n+            pass_num,\n+            pass_name,\n+            disambiguator,\n+            source,\n+        )?;\n+        writeln!(file, \"// MIR for `{}`\", node_path)?;\n+        writeln!(file, \"// source = {:?}\", source)?;\n+        writeln!(file, \"// pass_name = {}\", pass_name)?;\n+        writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n+        if let Some(ref layout) = mir.generator_layout {\n+            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n+        }\n+        writeln!(file, \"\")?;\n+        extra_data(PassWhere::BeforeCFG, &mut file)?;\n+        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n+        extra_data(PassWhere::AfterCFG, &mut file)?;\n+        Ok(())\n+    };\n+\n+    if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n+    let _: io::Result<()> = do catch {\n+            let mut file = create_dump_file(\n+                tcx,\n+                \"dot\",\n+                pass_num,\n+                pass_name,\n+                disambiguator,\n+                source,\n+            )?;\n+            write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n+            Ok(())\n+        };\n+    }\n+}\n+\n+/// Returns the path to the filename where we should dump a given MIR.\n+/// Also used by other bits of code (e.g., NLL inference) that dump\n+/// graphviz data or other things.\n+fn dump_path(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    extension: &str,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+) -> PathBuf {\n     let promotion_id = match source.promoted {\n         Some(id) => format!(\"-{:?}\", id),\n-        None => String::new()\n+        None => String::new(),\n     };\n \n     let pass_num = if tcx.sess.opts.debugging_opts.dump_mir_exclude_pass_number {\n@@ -126,48 +189,64 @@ where\n     };\n \n     let mut file_path = PathBuf::new();\n+\n     if let Some(ref file_dir) = tcx.sess.opts.debugging_opts.dump_mir_dir {\n         let p = Path::new(file_dir);\n         file_path.push(p);\n     };\n \n-    let _ = fs::create_dir_all(&file_path);\n-    let item_name = tcx.hir.def_path(source.def_id).to_filename_friendly_no_crate();\n-    let file_name = format!(\"rustc.{}{}{}.{}.{}.mir\",\n-                            item_name, promotion_id, pass_num, pass_name, disambiguator);\n+    let item_name = tcx.hir\n+        .def_path(source.def_id)\n+        .to_filename_friendly_no_crate();\n+\n+    let file_name = format!(\n+        \"rustc.{}{}{}.{}.{}.{}\",\n+        item_name,\n+        promotion_id,\n+        pass_num,\n+        pass_name,\n+        disambiguator,\n+        extension,\n+    );\n+\n     file_path.push(&file_name);\n-    let _ = fs::File::create(&file_path).and_then(|mut file| {\n-        writeln!(file, \"// MIR for `{}`\", node_path)?;\n-        writeln!(file, \"// source = {:?}\", source)?;\n-        writeln!(file, \"// pass_name = {}\", pass_name)?;\n-        writeln!(file, \"// disambiguator = {}\", disambiguator)?;\n-        if let Some(ref layout) = mir.generator_layout {\n-            writeln!(file, \"// generator_layout = {:?}\", layout)?;\n-        }\n-        writeln!(file, \"\")?;\n-        extra_data(PassWhere::BeforeCFG, &mut file)?;\n-        write_mir_fn(tcx, source, mir, &mut extra_data, &mut file)?;\n-        extra_data(PassWhere::AfterCFG, &mut file)?;\n-        Ok(())\n-    });\n \n-    if tcx.sess.opts.debugging_opts.dump_mir_graphviz {\n-        file_path.set_extension(\"dot\");\n-        let _ = fs::File::create(&file_path).and_then(|mut file| {\n-            write_mir_fn_graphviz(tcx, source.def_id, mir, &mut file)?;\n-            Ok(())\n-        });\n+    file_path\n+}\n+\n+/// Attempts to open a file where we should dump a given MIR or other\n+/// bit of MIR-related data. Used by `mir-dump`, but also by other\n+/// bits of code (e.g., NLL inference) that dump graphviz data or\n+/// other things, and hence takes the extension as an argument.\n+pub(crate) fn create_dump_file(\n+    tcx: TyCtxt<'_, '_, '_>,\n+    extension: &str,\n+    pass_num: Option<&Display>,\n+    pass_name: &str,\n+    disambiguator: &Display,\n+    source: MirSource,\n+) -> io::Result<fs::File> {\n+    let file_path = dump_path(tcx, extension, pass_num, pass_name, disambiguator, source);\n+    if let Some(parent) = file_path.parent() {\n+        fs::create_dir_all(parent)?;\n     }\n+    fs::File::create(&file_path)\n }\n \n /// Write out a human-readable textual representation for the given MIR.\n-pub fn write_mir_pretty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                        single: Option<DefId>,\n-                                        w: &mut Write)\n-                                        -> io::Result<()>\n-{\n-    writeln!(w, \"// WARNING: This output format is intended for human consumers only\")?;\n-    writeln!(w, \"// and is subject to change without notice. Knock yourself out.\")?;\n+pub fn write_mir_pretty<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    single: Option<DefId>,\n+    w: &mut Write,\n+) -> io::Result<()> {\n+    writeln!(\n+        w,\n+        \"// WARNING: This output format is intended for human consumers only\"\n+    )?;\n+    writeln!(\n+        w,\n+        \"// and is subject to change without notice. Knock yourself out.\"\n+    )?;\n \n     let mut first = true;\n     for def_id in dump_mir_def_ids(tcx, single) {\n@@ -186,22 +265,23 @@ pub fn write_mir_pretty<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n             writeln!(w, \"\")?;\n             let src = MirSource {\n                 def_id,\n-                promoted: Some(i)\n+                promoted: Some(i),\n             };\n             write_mir_fn(tcx, src, mir, &mut |_, _| Ok(()), w)?;\n         }\n     }\n     Ok(())\n }\n \n-pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       src: MirSource,\n-                                       mir: &Mir<'tcx>,\n-                                       extra_data: &mut F,\n-                                       w: &mut Write)\n-                                       -> io::Result<()>\n+pub fn write_mir_fn<'a, 'gcx, 'tcx, F>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir<'tcx>,\n+    extra_data: &mut F,\n+    w: &mut Write,\n+) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n@@ -217,14 +297,15 @@ where\n }\n \n /// Write out a human-readable textual representation for the given basic block.\n-pub fn write_basic_block<F>(tcx: TyCtxt,\n-                            block: BasicBlock,\n-                            mir: &Mir,\n-                            extra_data: &mut F,\n-                            w: &mut Write)\n-                            -> io::Result<()>\n+pub fn write_basic_block<F>(\n+    tcx: TyCtxt,\n+    block: BasicBlock,\n+    mir: &Mir,\n+    extra_data: &mut F,\n+    w: &mut Write,\n+) -> io::Result<()>\n where\n-    F: FnMut(PassWhere, &mut Write) -> io::Result<()>\n+    F: FnMut(PassWhere, &mut Write) -> io::Result<()>,\n {\n     let data = &mir[block];\n \n@@ -234,43 +315,61 @@ where\n     writeln!(w, \"{0:1$}{2}\", lbl, ALIGN, cleanup_text)?;\n \n     // List of statements in the middle.\n-    let mut current_location = Location { block: block, statement_index: 0 };\n+    let mut current_location = Location {\n+        block: block,\n+        statement_index: 0,\n+    };\n     for statement in &data.statements {\n-        extra_data(PassWhere::InCFG(current_location), w)?;\n+        extra_data(PassWhere::BeforeLocation(current_location), w)?;\n         let indented_mir = format!(\"{0}{0}{1:?};\", INDENT, statement);\n-        writeln!(w, \"{0:1$} // {2}\",\n-                 indented_mir,\n-                 ALIGN,\n-                 comment(tcx, statement.source_info))?;\n+        writeln!(\n+            w,\n+            \"{:A$} // {:?}: {}\",\n+            indented_mir,\n+            current_location,\n+            comment(tcx, statement.source_info),\n+            A = ALIGN,\n+        )?;\n+        extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n         current_location.statement_index += 1;\n     }\n \n     // Terminator at the bottom.\n-    extra_data(PassWhere::InCFG(current_location), w)?;\n+    extra_data(PassWhere::BeforeLocation(current_location), w)?;\n     let indented_terminator = format!(\"{0}{0}{1:?};\", INDENT, data.terminator().kind);\n-    writeln!(w, \"{0:1$} // {2}\",\n-             indented_terminator,\n-             ALIGN,\n-             comment(tcx, data.terminator().source_info))?;\n+    writeln!(\n+        w,\n+        \"{:A$} // {:?}: {}\",\n+        indented_terminator,\n+        current_location,\n+        comment(tcx, data.terminator().source_info),\n+        A = ALIGN,\n+    )?;\n+    extra_data(PassWhere::AfterLocation(current_location), w)?;\n \n     writeln!(w, \"{}}}\", INDENT)\n }\n \n fn comment(tcx: TyCtxt, SourceInfo { span, scope }: SourceInfo) -> String {\n-    format!(\"scope {} at {}\", scope.index(), tcx.sess.codemap().span_to_string(span))\n+    format!(\n+        \"scope {} at {}\",\n+        scope.index(),\n+        tcx.sess.codemap().span_to_string(span)\n+    )\n }\n \n /// Prints user-defined variables in a scope tree.\n ///\n /// Returns the total number of variables printed.\n-fn write_scope_tree(tcx: TyCtxt,\n-                    mir: &Mir,\n-                    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n-                    w: &mut Write,\n-                    parent: VisibilityScope,\n-                    depth: usize)\n-                    -> io::Result<()> {\n+fn write_scope_tree(\n+    tcx: TyCtxt,\n+    mir: &Mir,\n+    scope_tree: &FxHashMap<VisibilityScope, Vec<VisibilityScope>>,\n+    w: &mut Write,\n+    parent: VisibilityScope,\n+    depth: usize,\n+) -> io::Result<()> {\n     let indent = depth * INDENT.len();\n \n     let children = match scope_tree.get(&parent) {\n@@ -300,17 +399,22 @@ fn write_scope_tree(tcx: TyCtxt,\n             };\n \n             let indent = indent + INDENT.len();\n-            let indented_var = format!(\"{0:1$}let {2}{3:?}: {4};\",\n-                                       INDENT,\n-                                       indent,\n-                                       mut_str,\n-                                       local,\n-                                       var.ty);\n-            writeln!(w, \"{0:1$} // \\\"{2}\\\" in {3}\",\n-                     indented_var,\n-                     ALIGN,\n-                     name,\n-                     comment(tcx, source_info))?;\n+            let indented_var = format!(\n+                \"{0:1$}let {2}{3:?}: {4:?};\",\n+                INDENT,\n+                indent,\n+                mut_str,\n+                local,\n+                var.ty\n+            );\n+            writeln!(\n+                w,\n+                \"{0:1$} // \\\"{2}\\\" in {3}\",\n+                indented_var,\n+                ALIGN,\n+                name,\n+                comment(tcx, source_info)\n+            )?;\n         }\n \n         write_scope_tree(tcx, mir, scope_tree, w, child, depth + 1)?;\n@@ -323,21 +427,23 @@ fn write_scope_tree(tcx: TyCtxt,\n \n /// Write out a human-readable textual representation of the MIR's `fn` type and the types of its\n /// local variables (both user-defined bindings and compiler temporaries).\n-pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       src: MirSource,\n-                                       mir: &Mir,\n-                                       w: &mut Write)\n-                                       -> io::Result<()> {\n+pub fn write_mir_intro<'a, 'gcx, 'tcx>(\n+    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+    src: MirSource,\n+    mir: &Mir,\n+    w: &mut Write,\n+) -> io::Result<()> {\n     write_mir_sig(tcx, src, mir, w)?;\n     writeln!(w, \" {{\")?;\n \n     // construct a scope tree and write it out\n     let mut scope_tree: FxHashMap<VisibilityScope, Vec<VisibilityScope>> = FxHashMap();\n     for (index, scope_data) in mir.visibility_scopes.iter().enumerate() {\n         if let Some(parent) = scope_data.parent_scope {\n-            scope_tree.entry(parent)\n-                      .or_insert(vec![])\n-                      .push(VisibilityScope::new(index));\n+            scope_tree\n+                .entry(parent)\n+                .or_insert(vec![])\n+                .push(VisibilityScope::new(index));\n         } else {\n             // Only the argument scope has no parent, because it's the root.\n             assert_eq!(index, ARGUMENT_VISIBILITY_SCOPE.index());\n@@ -363,9 +469,7 @@ pub fn write_mir_intro<'a, 'gcx, 'tcx>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n     Ok(())\n }\n \n-fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n-                 -> io::Result<()>\n-{\n+fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write) -> io::Result<()> {\n     let id = tcx.hir.as_local_node_id(src.def_id).unwrap();\n     let body_owner_kind = tcx.hir.body_owner_kind(id);\n     match (body_owner_kind, src.promoted) {\n@@ -376,7 +480,8 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n         (hir::BodyOwnerKind::Static(hir::MutMutable), _) => write!(w, \"static mut\")?,\n     }\n \n-    item_path::with_forced_impl_filename_line(|| { // see notes on #41697 elsewhere\n+    item_path::with_forced_impl_filename_line(|| {\n+        // see notes on #41697 elsewhere\n         write!(w, \" {}\", tcx.item_path_str(src.def_id))\n     })?;\n \n@@ -394,9 +499,7 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n \n             write!(w, \") -> {}\", mir.return_ty())\n         }\n-        (hir::BodyOwnerKind::Const, _) |\n-        (hir::BodyOwnerKind::Static(_), _) |\n-        (_, Some(_)) => {\n+        (hir::BodyOwnerKind::Const, _) | (hir::BodyOwnerKind::Static(_), _) | (_, Some(_)) => {\n             assert_eq!(mir.arg_count, 0);\n             write!(w, \": {} =\", mir.return_ty())\n         }\n@@ -406,7 +509,13 @@ fn write_mir_sig(tcx: TyCtxt, src: MirSource, mir: &Mir, w: &mut Write)\n fn write_temp_decls(mir: &Mir, w: &mut Write) -> io::Result<()> {\n     // Compiler-introduced temporary types.\n     for temp in mir.temps_iter() {\n-        writeln!(w, \"{}let mut {:?}: {};\", INDENT, temp, mir.local_decls[temp].ty)?;\n+        writeln!(\n+            w,\n+            \"{}let mut {:?}: {};\",\n+            INDENT,\n+            temp,\n+            mir.local_decls[temp].ty\n+        )?;\n     }\n \n     Ok(())"}, {"sha": "405647af324d6709de5e6969b9c1714f0a9ea62f", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -395,15 +395,9 @@ pub fn ty_fn_sig<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             let tcx = ccx.tcx();\n             let sig = tcx.fn_sig(def_id).subst(tcx, substs.substs);\n \n-            let env_region = ty::ReLateBound(ty::DebruijnIndex::new(1), ty::BrEnv);\n-            let env_ty = match substs.closure_kind(def_id, tcx) {\n-                ty::ClosureKind::Fn => tcx.mk_imm_ref(tcx.mk_region(env_region), ty),\n-                ty::ClosureKind::FnMut => tcx.mk_mut_ref(tcx.mk_region(env_region), ty),\n-                ty::ClosureKind::FnOnce => ty,\n-            };\n-\n+            let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n             sig.map_bound(|sig| tcx.mk_fn_sig(\n-                iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n+                iter::once(*env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n                 sig.output(),\n                 sig.variadic,\n                 sig.unsafety,"}, {"sha": "d5e4aa69c5b4e54d1bc60d7fea73ccbc761558f4", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -800,7 +800,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let pat_ty = self.instantiate_value_path(segments, opt_ty, def, pat.span, pat.id);\n         // Replace constructor type with constructed type for tuple struct patterns.\n         let pat_ty = pat_ty.fn_sig(tcx).output();\n-        let pat_ty = tcx.no_late_bound_regions(&pat_ty).expect(\"expected fn type\");\n+        let pat_ty = pat_ty.no_late_bound_regions().expect(\"expected fn type\");\n \n         self.demand_eqtype(pat.span, expected, pat_ty);\n "}, {"sha": "147347a75abe8264f04a1f140240ae809fb7189d", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -562,7 +562,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         body: &hir::Body,\n         bound_sig: ty::PolyFnSig<'tcx>,\n     ) -> ClosureSignatures<'tcx> {\n-        let liberated_sig = self.liberate_late_bound_regions(expr_def_id, &bound_sig);\n+        let liberated_sig = self.tcx().liberate_late_bound_regions(expr_def_id, &bound_sig);\n         let liberated_sig = self.inh.normalize_associated_types_in(\n             body.value.span,\n             body.value.id,"}, {"sha": "70607bf4842a55e1c3c5dbb25863d7d0638f0267", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -270,7 +270,7 @@ fn compare_predicate_entailment<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         let impl_fty = tcx.mk_fn_ptr(ty::Binder(impl_sig));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n-        let trait_sig = inh.liberate_late_bound_regions(\n+        let trait_sig = tcx.liberate_late_bound_regions(\n             impl_m.def_id,\n             &tcx.fn_sig(trait_m.def_id));\n         let trait_sig ="}, {"sha": "55700c452e57bced37f5f58402d696fdec52c3b5", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -11,12 +11,12 @@\n use check::regionck::RegionCtxt;\n \n use hir::def_id::DefId;\n-use middle::free_region::FreeRegionMap;\n use rustc::infer::{self, InferOk};\n+use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::ty::subst::{Subst, Substs};\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::traits::{self, ObligationCause};\n+use rustc::traits::{self, Reveal, ObligationCause};\n use util::common::ErrorReported;\n use util::nodemap::FxHashSet;\n \n@@ -115,8 +115,18 @@ fn ensure_drop_params_and_item_params_correspond<'a, 'tcx>(\n         }\n \n         let region_scope_tree = region::ScopeTree::default();\n-        let free_regions = FreeRegionMap::new();\n-        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &free_regions);\n+\n+        // NB. It seems a bit... suspicious to use an empty param-env\n+        // here. The correct thing, I imagine, would be\n+        // `OutlivesEnvironment::new(impl_param_env)`, which would\n+        // allow region solving to take any `a: 'b` relations on the\n+        // impl into account. But I could not create a test case where\n+        // it did the wrong thing, so I chose to preserve existing\n+        // behavior, since it ought to be simply more\n+        // conservative. -nmatsakis\n+        let outlives_env = OutlivesEnvironment::new(ty::ParamEnv::empty(Reveal::UserFacing));\n+\n+        infcx.resolve_regions_and_report_errors(drop_impl_did, &region_scope_tree, &outlives_env);\n         Ok(())\n     })\n }"}, {"sha": "23243c3ad66c0e49422b242e732bdcb33e37132e", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -389,7 +389,7 @@ pub fn check_platform_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     let mut structural_to_nomimal = FxHashMap();\n \n                     let sig = tcx.fn_sig(def_id);\n-                    let sig = tcx.no_late_bound_regions(&sig).unwrap();\n+                    let sig = sig.no_late_bound_regions().unwrap();\n                     if intr.inputs.len() != sig.inputs().len() {\n                         span_err!(tcx.sess, it.span, E0444,\n                                   \"platform-specific intrinsic has invalid number of \\"}, {"sha": "27a0e4f6dfe6330e36a760aa30eb3a688bf68658", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 17, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -698,22 +698,6 @@ impl<'a, 'gcx, 'tcx> Inherited<'a, 'gcx, 'tcx> {\n         let ok = self.partially_normalize_associated_types_in(span, body_id, param_env, value);\n         self.register_infer_ok_obligations(ok)\n     }\n-\n-    /// Replace any late-bound regions bound in `value` with\n-    /// free variants attached to `all_outlive_scope`.\n-    fn liberate_late_bound_regions<T>(&self,\n-        all_outlive_scope: DefId,\n-        value: &ty::Binder<T>)\n-        -> T\n-        where T: TypeFoldable<'tcx>\n-    {\n-        self.tcx.replace_late_bound_regions(value, |br| {\n-            self.tcx.mk_region(ty::ReFree(ty::FreeRegion {\n-                scope: all_outlive_scope,\n-                bound_region: br\n-            }))\n-        }).0\n-    }\n }\n \n struct CheckItemTypesVisitor<'a, 'tcx: 'a> { tcx: TyCtxt<'a, 'tcx, 'tcx> }\n@@ -882,7 +866,7 @@ fn typeck_tables_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n             // Compute the fty from point of view of inside fn.\n             let fn_sig =\n-                inh.liberate_late_bound_regions(def_id, &fn_sig);\n+                tcx.liberate_late_bound_regions(def_id, &fn_sig);\n             let fn_sig =\n                 inh.normalize_associated_types_in(body.value.span,\n                                                   body_id.node_id,"}, {"sha": "7ef6027772be2deeb5658a60f84f40096f37ff06", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -90,7 +90,8 @@ use middle::region;\n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n-use rustc::infer::{self, OutlivesEnvironment};\n+use rustc::infer;\n+use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::ty::adjustment;\n use rustc::ty::outlives::Component;\n \n@@ -553,7 +554,7 @@ impl<'a, 'gcx, 'tcx> RegionCtxt<'a, 'gcx, 'tcx> {\n     fn resolve_regions_and_report_errors(&self) {\n         self.fcx.resolve_regions_and_report_errors(self.subject_def_id,\n                                                    &self.region_scope_tree,\n-                                                   self.outlives_environment.free_region_map());\n+                                                   &self.outlives_environment);\n     }\n \n     fn constrain_bindings_in_pat(&mut self, pat: &hir::Pat) {"}, {"sha": "d4625bb58c33878efa04a2a885d4d57b16098025", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -451,7 +451,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n                                       implied_bounds: &mut Vec<Ty<'tcx>>)\n     {\n         let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.liberate_late_bound_regions(def_id, &sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(def_id, &sig);\n \n         for input_ty in sig.inputs() {\n             fcx.register_wf_obligation(&input_ty, span, self.code.clone());\n@@ -484,12 +484,12 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let sig = fcx.tcx.fn_sig(method.def_id);\n         let sig = fcx.normalize_associated_types_in(span, &sig);\n-        let sig = fcx.liberate_late_bound_regions(method.def_id, &sig);\n+        let sig = fcx.tcx.liberate_late_bound_regions(method.def_id, &sig);\n \n         debug!(\"check_method_receiver: sig={:?}\", sig);\n \n         let self_ty = fcx.normalize_associated_types_in(span, &self_ty);\n-        let self_ty = fcx.liberate_late_bound_regions(\n+        let self_ty = fcx.tcx.liberate_late_bound_regions(\n             method.def_id,\n             &ty::Binder(self_ty)\n         );\n@@ -498,7 +498,7 @@ impl<'a, 'gcx> CheckTypeWellFormedVisitor<'a, 'gcx> {\n \n         let cause = fcx.cause(span, ObligationCauseCode::MethodReceiver);\n         let self_arg_ty = fcx.normalize_associated_types_in(span, &self_arg_ty);\n-        let self_arg_ty = fcx.liberate_late_bound_regions(\n+        let self_arg_ty = fcx.tcx.liberate_late_bound_regions(\n             method.def_id,\n             &ty::Binder(self_arg_ty)\n         );"}, {"sha": "d63980eaa506b8d79912cab5b68add9df5fc5319", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -11,7 +11,7 @@\n //! Check properties that are required by built-in traits and set\n //! up data structures required by type-checking/translation.\n \n-use rustc::middle::free_region::FreeRegionMap;\n+use rustc::infer::outlives::env::OutlivesEnvironment;\n use rustc::middle::region;\n use rustc::middle::lang_items::UnsizeTraitLangItem;\n \n@@ -391,9 +391,12 @@ pub fn coerce_unsized_info<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n         // Finally, resolve all regions.\n         let region_scope_tree = region::ScopeTree::default();\n-        let mut free_regions = FreeRegionMap::new();\n-        free_regions.relate_free_regions_from_predicates(&param_env.caller_bounds);\n-        infcx.resolve_regions_and_report_errors(impl_did, &region_scope_tree, &free_regions);\n+        let outlives_env = OutlivesEnvironment::new(param_env);\n+        infcx.resolve_regions_and_report_errors(\n+            impl_did,\n+            &region_scope_tree,\n+            &outlives_env,\n+        );\n \n         CoerceUnsizedInfo {\n             custom_kind: kind"}, {"sha": "b754c981b2101ce8b96be5da95901e98df99b700", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'tcx> AstConv<'tcx, 'tcx> for ItemCtxt<'a, 'tcx> {\n                                         poly_trait_ref: ty::PolyTraitRef<'tcx>)\n                                         -> Ty<'tcx>\n     {\n-        if let Some(trait_ref) = self.tcx().no_late_bound_regions(&poly_trait_ref) {\n+        if let Some(trait_ref) = poly_trait_ref.no_late_bound_regions() {\n             self.tcx().mk_projection(item_def_id, trait_ref.substs)\n         } else {\n             // no late-bound regions, we can just ignore the binder"}, {"sha": "68642598ed2df765ed776145d546e125309b7964", "filename": "src/test/compile-fail/regions-normalize-in-where-clause-list.rs", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fcompile-fail%2Fregions-normalize-in-where-clause-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fcompile-fail%2Fregions-normalize-in-where-clause-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-normalize-in-where-clause-list.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we are able to normalize in the list of where-clauses,\n+// even if `'a: 'b` is required.\n+\n+trait Project<'a, 'b> {\n+    type Item;\n+}\n+\n+impl<'a, 'b> Project<'a, 'b> for ()\n+    where 'a: 'b\n+{\n+    type Item = ();\n+}\n+\n+// No error here, we have 'a: 'b. We used to report an error here\n+// though, see https://github.com/rust-lang/rust/issues/45937.\n+fn foo<'a: 'b, 'b>()\n+    where <() as Project<'a, 'b>>::Item : Eq\n+{\n+}\n+\n+// Here we get an error: we need `'a: 'b`.\n+fn bar<'a, 'b>() //~ ERROR cannot infer\n+    where <() as Project<'a, 'b>>::Item : Eq\n+{\n+}\n+\n+fn main() { }"}, {"sha": "7039de727faa98b7b6b319bb12145e85ce9d3f65", "filename": "src/test/mir-opt/nll/named-lifetimes-basic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fnamed-lifetimes-basic.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -26,9 +26,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.use_x.nll.0.mir\n-// | '_#0r: {bb0[0], bb0[1], '_#0r, '_#1r, '_#2r, '_#3r}\n+// | '_#0r: {bb0[0], bb0[1], '_#0r}\n // | '_#1r: {bb0[0], bb0[1], '_#1r}\n-// | '_#2r: {bb0[0], bb0[1], '_#1r, '_#2r}\n+// | '_#2r: {bb0[0], bb0[1], '_#2r}\n // | '_#3r: {bb0[0], bb0[1], '_#3r}\n // fn use_x(_1: &'_#1r mut i32, _2: &'_#2r u32, _3: &'_#1r u32, _4: &'_#3r u32) -> bool {\n // END rustc.use_x.nll.0.mir"}, {"sha": "cfbc51f9e18613ee5430548235daa6846612ebee", "filename": "src/test/mir-opt/nll/region-liveness-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-basic.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -31,7 +31,7 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n // | '_#2r: {bb2[1], bb3[0], bb3[1]}\n // ...\n //             let _2: &'_#2r usize;"}, {"sha": "679f31fdab9035161302651afba534ba69044b31", "filename": "src/test/mir-opt/nll/region-liveness-two-disjoint-uses.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-liveness-two-disjoint-uses.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -36,9 +36,9 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb3[0], bb3[1]}\n // ...\n-// | '_#3r: {bb8[2], bb8[3], bb8[4]}\n+// | '_#3r: {bb8[1], bb8[2], bb8[3], bb8[4]}\n // | '_#4r: {bb2[1], bb3[0], bb3[1], bb8[2], bb8[3], bb8[4]}\n // ...\n // let mut _2: &'_#4r usize;"}, {"sha": "471d77aefac622bc0e5a2286e6de587a4dd25c4f", "filename": "src/test/mir-opt/nll/region-subtyping-basic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fnll%2Fregion-subtyping-basic.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -32,7 +32,7 @@ fn main() {\n \n // END RUST SOURCE\n // START rustc.main.nll.0.mir\n-// | '_#1r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n+// | '_#1r: {bb2[0], bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n // | '_#2r: {bb2[1], bb2[2], bb2[3], bb2[4], bb2[5], bb2[6], bb3[0], bb3[1]}\n // | '_#3r: {bb2[5], bb2[6], bb3[0], bb3[1]}\n // END rustc.main.nll.0.mir"}, {"sha": "0047f6d59237c5d20e5282c9453e442ce6f01c17", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.b);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+    // FIXME ^ Should not error in the future with implicit dtors, only manually implemented ones\n+}"}, {"sha": "389334f9c1d8debb5033bfc8b6ce32c7414c0c4c", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:31:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "64a4d391000630ed5672184dba12ebf42473e783", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    std::mem::drop(wrap);\n+    x = 1; // OK, drop is inert\n+}"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "src/test/ui/nll/maybe-initialized-drop-uninitialized.stderr", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-uninitialized.stderr?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5"}, {"sha": "3242136f005e713190e84a898f76c932534282c6", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.a);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "9edeca2d18801512fe7d73e8c64ca1c30bbeece3", "filename": "src/test/ui/nll/maybe-initialized-drop-with-fragment.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-fragment.stderr?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-with-fragment.rs:31:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+31 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "3e32818b8dcf33b651b1854e88679f0b837301b4", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+struct Foo<'p> { a: String, b: Wrap<'p> }\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    let s = String::from(\"str\");\n+    let foo = Foo { a: s, b: wrap };\n+    std::mem::drop(foo.a);\n+    std::mem::drop(foo.b);\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+    // FIXME ^ This currently errors and it should not.\n+}"}, {"sha": "24d0d6d04c8da34eef27e9814f6d9bae9ee8be7c", "filename": "src/test/ui/nll/maybe-initialized-drop-with-uninitialized-fragments.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-with-uninitialized-fragments.stderr?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,11 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop-with-uninitialized-fragments.rs:32:5\n+   |\n+27 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+...\n+32 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}, {"sha": "291fcbd73f3e1e23406025aea6a2029d8779eb52", "filename": "src/test/ui/nll/maybe-initialized-drop.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.rs?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//compile-flags: -Z emit-end-regions -Zborrowck=mir -Z nll\n+\n+#![allow(warnings)]\n+\n+struct Wrap<'p> { p: &'p mut i32 }\n+\n+impl<'p> Drop for Wrap<'p> {\n+    fn drop(&mut self) {\n+        *self.p += 1;\n+    }\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let wrap = Wrap { p: &mut x };\n+    x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+}"}, {"sha": "7b1b55d133ac56f467bf89f3c1845db0d2f8dc2b", "filename": "src/test/ui/nll/maybe-initialized-drop.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8503b3ff822c1ed01c89773d30e4e10b886d77a5/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop.stderr?ref=8503b3ff822c1ed01c89773d30e4e10b886d77a5", "patch": "@@ -0,0 +1,10 @@\n+error[E0506]: cannot assign to `x` because it is borrowed\n+  --> $DIR/maybe-initialized-drop.rs:26:5\n+   |\n+25 |     let wrap = Wrap { p: &mut x };\n+   |                          ------ borrow of `x` occurs here\n+26 |     x = 1; //~ ERROR cannot assign to `x` because it is borrowed [E0506]\n+   |     ^^^^^ assignment to borrowed `x` occurs here\n+\n+error: aborting due to previous error\n+"}]}