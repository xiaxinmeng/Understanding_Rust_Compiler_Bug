{"sha": "e7a9c1141698bc4557b9da3d3fce2bf75339427f", "node_id": "C_kwDOAAsO6NoAKGU3YTljMTE0MTY5OGJjNDU1N2I5ZGEzZDNmY2UyYmY3NTMzOTQyN2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T07:12:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-22T07:12:19Z"}, "message": "Auto merge of #99592 - Dylan-DPC:rollup-xlw4wax, r=Dylan-DPC\n\nRollup of 6 pull requests\n\nSuccessful merges:\n\n - #98174 (Rename `<*{mut,const} T>::as_{const,mut}` to `cast_`)\n - #98868 (Fix unreachable coverage generation for inlined functions)\n - #99393 (feat: omit suffixes in const generics (e.g. `1_i32`))\n - #99423 (Group CSS font rule)\n - #99539 (Improve suggestions for returning binding)\n - #99579 (Add same warning to Result::expect as Result::unwrap)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "f33a2c0b026c5ef7ac34d14e3453d729ea3dfbf3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f33a2c0b026c5ef7ac34d14e3453d729ea3dfbf3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e7a9c1141698bc4557b9da3d3fce2bf75339427f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a9c1141698bc4557b9da3d3fce2bf75339427f", "html_url": "https://github.com/rust-lang/rust/commit/e7a9c1141698bc4557b9da3d3fce2bf75339427f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e7a9c1141698bc4557b9da3d3fce2bf75339427f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa0189170057a6b56f445f05b9840caf6f260212", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa0189170057a6b56f445f05b9840caf6f260212", "html_url": "https://github.com/rust-lang/rust/commit/aa0189170057a6b56f445f05b9840caf6f260212"}, {"sha": "5df3b983218e136e995df5a7210535bddbdfca52", "url": "https://api.github.com/repos/rust-lang/rust/commits/5df3b983218e136e995df5a7210535bddbdfca52", "html_url": "https://github.com/rust-lang/rust/commit/5df3b983218e136e995df5a7210535bddbdfca52"}], "stats": {"total": 1655, "additions": 949, "deletions": 706}, "files": [{"sha": "f1fe495282abc45f56e38de8cda5bf1ea2adbc7d", "filename": "compiler/rustc_codegen_ssa/src/mir/coverageinfo.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fcoverageinfo.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -9,11 +9,8 @@ use super::FunctionCx;\n impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     pub fn codegen_coverage(&self, bx: &mut Bx, coverage: Coverage, scope: SourceScope) {\n         // Determine the instance that coverage data was originally generated for.\n-        let scope_data = &self.mir.source_scopes[scope];\n-        let instance = if let Some((inlined_instance, _)) = scope_data.inlined {\n-            self.monomorphize(inlined_instance)\n-        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n-            self.monomorphize(self.mir.source_scopes[inlined_scope].inlined.unwrap().0)\n+        let instance = if let Some(inlined) = scope.inlined_instance(&self.mir.source_scopes) {\n+            self.monomorphize(inlined)\n         } else {\n             self.instance\n         };"}, {"sha": "18ffc227fed869e71de9fb50df4482263b38ffa4", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -954,6 +954,16 @@ pub struct Block<'hir> {\n     pub targeted_by_break: bool,\n }\n \n+impl<'hir> Block<'hir> {\n+    pub fn innermost_block(&self) -> &Block<'hir> {\n+        let mut block = self;\n+        while let Some(Expr { kind: ExprKind::Block(inner_block, _), .. }) = block.expr {\n+            block = inner_block;\n+        }\n+        block\n+    }\n+}\n+\n #[derive(Debug, HashStable_Generic)]\n pub struct Pat<'hir> {\n     #[stable_hasher(ignore)]"}, {"sha": "4e87ec86658f81503f29af7340dae6dbee9b6705", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 422, "deletions": 117, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -316,37 +316,6 @@ pub fn unexpected_hidden_region_diagnostic<'tcx>(\n     err\n }\n \n-/// Structurally compares two types, modulo any inference variables.\n-///\n-/// Returns `true` if two types are equal, or if one type is an inference variable compatible\n-/// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n-/// FloatVar inference type are compatible with themselves or their concrete types (Int and\n-/// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n-pub fn same_type_modulo_infer<'tcx>(a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n-    match (&a.kind(), &b.kind()) {\n-        (&ty::Adt(did_a, substs_a), &ty::Adt(did_b, substs_b)) => {\n-            if did_a != did_b {\n-                return false;\n-            }\n-\n-            substs_a.types().zip(substs_b.types()).all(|(a, b)| same_type_modulo_infer(a, b))\n-        }\n-        (&ty::Int(_), &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Infer(ty::InferTy::IntVar(_)), &ty::Int(_) | &ty::Infer(ty::InferTy::IntVar(_)))\n-        | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n-        | (\n-            &ty::Infer(ty::InferTy::FloatVar(_)),\n-            &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n-        )\n-        | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n-        | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n-        (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n-            mut_a == mut_b && same_type_modulo_infer(*ty_a, *ty_b)\n-        }\n-        _ => a == b,\n-    }\n-}\n-\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn report_region_errors(\n         &self,\n@@ -645,13 +614,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 err.span_label(span, \"expected due to this\");\n             }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                semi_span,\n+                arm_block_id,\n+                arm_span,\n+                arm_ty,\n+                prior_arm_block_id,\n+                prior_arm_span,\n+                prior_arm_ty,\n                 source,\n                 ref prior_arms,\n-                last_ty,\n                 scrut_hir_id,\n                 opt_suggest_box_span,\n-                arm_span,\n                 scrut_span,\n                 ..\n             }) => match source {\n@@ -682,10 +654,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    // `last_ty` can be `!`, `expected` will have better info when present.\n+                    // `prior_arm_ty` can be `!`, `expected` will have better info when present.\n                     let t = self.resolve_vars_if_possible(match exp_found {\n                         Some(ty::error::ExpectedFound { expected, .. }) => expected,\n-                        _ => last_ty,\n+                        _ => prior_arm_ty,\n                     });\n                     let source_map = self.tcx.sess.source_map();\n                     let mut any_multiline_arm = source_map.is_multiline(arm_span);\n@@ -710,37 +682,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     };\n                     let msg = \"`match` arms have incompatible types\";\n                     err.span_label(outer_error_span, msg);\n-                    if let Some((sp, boxed)) = semi_span {\n-                        if let (StatementAsExpression::NeedsBoxing, [.., prior_arm]) =\n-                            (boxed, &prior_arms[..])\n-                        {\n-                            err.multipart_suggestion(\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                vec![\n-                                    (prior_arm.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (prior_arm.shrink_to_hi(), \")\".to_string()),\n-                                    (arm_span.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                    (arm_span.shrink_to_hi(), \")\".to_string()),\n-                                    (sp, String::new()),\n-                                ],\n-                                Applicability::HasPlaceholders,\n-                            );\n-                        } else if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon and boxing the expressions\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"consider removing this semicolon\",\n-                                \"\",\n-                                Applicability::MachineApplicable,\n-                            );\n-                        }\n-                    }\n+                    self.suggest_remove_semi_or_return_binding(\n+                        err,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n+                        arm_block_id,\n+                        arm_ty,\n+                        arm_span,\n+                    );\n                     if let Some(ret_sp) = opt_suggest_box_span {\n                         // Get return type span and point to it.\n                         self.suggest_boxing_for_return_impl_trait(\n@@ -752,43 +702,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n             },\n             ObligationCauseCode::IfExpression(box IfExpressionCause {\n-                then,\n-                else_sp,\n-                outer,\n-                semicolon,\n+                then_id,\n+                else_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             }) => {\n-                err.span_label(then, \"expected because of this\");\n-                if let Some(sp) = outer {\n+                let then_span = self.find_block_span_from_hir_id(then_id);\n+                let else_span = self.find_block_span_from_hir_id(then_id);\n+                err.span_label(then_span, \"expected because of this\");\n+                if let Some(sp) = outer_span {\n                     err.span_label(sp, \"`if` and `else` have incompatible types\");\n                 }\n-                if let Some((sp, boxed)) = semicolon {\n-                    if matches!(boxed, StatementAsExpression::NeedsBoxing) {\n-                        err.multipart_suggestion(\n-                            \"consider removing this semicolon and boxing the expression\",\n-                            vec![\n-                                (then.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (then.shrink_to_hi(), \")\".to_string()),\n-                                (else_sp.shrink_to_lo(), \"Box::new(\".to_string()),\n-                                (else_sp.shrink_to_hi(), \")\".to_string()),\n-                                (sp, String::new()),\n-                            ],\n-                            Applicability::MachineApplicable,\n-                        );\n-                    } else {\n-                        err.span_suggestion_short(\n-                            sp,\n-                            \"consider removing this semicolon\",\n-                            \"\",\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n+                self.suggest_remove_semi_or_return_binding(\n+                    err,\n+                    Some(then_id),\n+                    then_ty,\n+                    then_span,\n+                    Some(else_id),\n+                    else_ty,\n+                    else_span,\n+                );\n                 if let Some(ret_sp) = opt_suggest_box_span {\n                     self.suggest_boxing_for_return_impl_trait(\n                         err,\n                         ret_sp,\n-                        [then, else_sp].into_iter(),\n+                        [then_span, else_span].into_iter(),\n                     );\n                 }\n             }\n@@ -808,6 +748,56 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n     }\n \n+    fn suggest_remove_semi_or_return_binding(\n+        &self,\n+        err: &mut Diagnostic,\n+        first_id: Option<hir::HirId>,\n+        first_ty: Ty<'tcx>,\n+        first_span: Span,\n+        second_id: Option<hir::HirId>,\n+        second_ty: Ty<'tcx>,\n+        second_span: Span,\n+    ) {\n+        let remove_semicolon =\n+            [(first_id, second_ty), (second_id, first_ty)].into_iter().find_map(|(id, ty)| {\n+                let hir::Node::Block(blk) = self.tcx.hir().get(id?) else { return None };\n+                self.could_remove_semicolon(blk, ty)\n+            });\n+        match remove_semicolon {\n+            Some((sp, StatementAsExpression::NeedsBoxing)) => {\n+                err.multipart_suggestion(\n+                    \"consider removing this semicolon and boxing the expressions\",\n+                    vec![\n+                        (first_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (first_span.shrink_to_hi(), \")\".to_string()),\n+                        (second_span.shrink_to_lo(), \"Box::new(\".to_string()),\n+                        (second_span.shrink_to_hi(), \")\".to_string()),\n+                        (sp, String::new()),\n+                    ],\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            Some((sp, StatementAsExpression::CorrectType)) => {\n+                err.span_suggestion_short(\n+                    sp,\n+                    \"consider removing this semicolon\",\n+                    \"\",\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            None => {\n+                for (id, ty) in [(first_id, second_ty), (second_id, first_ty)] {\n+                    if let Some(id) = id\n+                        && let hir::Node::Block(blk) = self.tcx.hir().get(id)\n+                        && self.consider_returning_binding(blk, ty, err)\n+                    {\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n     fn suggest_boxing_for_return_impl_trait(\n         &self,\n         err: &mut Diagnostic,\n@@ -1723,15 +1713,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         };\n         debug!(\"exp_found {:?} terr {:?} cause.code {:?}\", exp_found, terr, cause.code());\n         if let Some(exp_found) = exp_found {\n-            let should_suggest_fixes = if let ObligationCauseCode::Pattern { root_ty, .. } =\n-                cause.code()\n-            {\n-                // Skip if the root_ty of the pattern is not the same as the expected_ty.\n-                // If these types aren't equal then we've probably peeled off a layer of arrays.\n-                same_type_modulo_infer(self.resolve_vars_if_possible(*root_ty), exp_found.expected)\n-            } else {\n-                true\n-            };\n+            let should_suggest_fixes =\n+                if let ObligationCauseCode::Pattern { root_ty, .. } = cause.code() {\n+                    // Skip if the root_ty of the pattern is not the same as the expected_ty.\n+                    // If these types aren't equal then we've probably peeled off a layer of arrays.\n+                    self.same_type_modulo_infer(*root_ty, exp_found.expected)\n+                } else {\n+                    true\n+                };\n \n             if should_suggest_fixes {\n                 self.suggest_tuple_pattern(cause, &exp_found, diag);\n@@ -1786,7 +1775,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     .filter_map(|variant| {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n-                        if same_type_modulo_infer(sole_field_ty, exp_found.found) {\n+                        if self.same_type_modulo_infer(sole_field_ty, exp_found.found) {\n                             let variant_path =\n                                 with_no_trimmed_paths!(self.tcx.def_path_str(variant.def_id));\n                             // FIXME #56861: DRYer prelude filtering\n@@ -1902,12 +1891,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             self.get_impl_future_output_ty(exp_found.expected).map(Binder::skip_binder),\n             self.get_impl_future_output_ty(exp_found.found).map(Binder::skip_binder),\n         ) {\n-            (Some(exp), Some(found)) if same_type_modulo_infer(exp, found) => match cause.code() {\n-                ObligationCauseCode::IfExpression(box IfExpressionCause { then, .. }) => {\n+            (Some(exp), Some(found)) if self.same_type_modulo_infer(exp, found) => match cause\n+                .code()\n+            {\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n                     diag.multipart_suggestion(\n                         \"consider `await`ing on both `Future`s\",\n                         vec![\n-                            (then.shrink_to_hi(), \".await\".to_string()),\n+                            (then_span.shrink_to_hi(), \".await\".to_string()),\n                             (exp_span.shrink_to_hi(), \".await\".to_string()),\n                         ],\n                         Applicability::MaybeIncorrect,\n@@ -1934,19 +1926,28 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     diag.help(\"consider `await`ing on both `Future`s\");\n                 }\n             },\n-            (_, Some(ty)) if same_type_modulo_infer(exp_found.expected, ty) => {\n+            (_, Some(ty)) if self.same_type_modulo_infer(exp_found.expected, ty) => {\n                 diag.span_suggestion_verbose(\n                     exp_span.shrink_to_hi(),\n                     \"consider `await`ing on the `Future`\",\n                     \".await\",\n                     Applicability::MaybeIncorrect,\n                 );\n             }\n-            (Some(ty), _) if same_type_modulo_infer(ty, exp_found.found) => match cause.code() {\n-                ObligationCauseCode::Pattern { span: Some(span), .. }\n-                | ObligationCauseCode::IfExpression(box IfExpressionCause { then: span, .. }) => {\n+            (Some(ty), _) if self.same_type_modulo_infer(ty, exp_found.found) => match cause.code()\n+            {\n+                ObligationCauseCode::Pattern { span: Some(then_span), .. } => {\n                     diag.span_suggestion_verbose(\n-                        span.shrink_to_hi(),\n+                        then_span.shrink_to_hi(),\n+                        \"consider `await`ing on the `Future`\",\n+                        \".await\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                ObligationCauseCode::IfExpression(box IfExpressionCause { then_id, .. }) => {\n+                    let then_span = self.find_block_span_from_hir_id(*then_id);\n+                    diag.span_suggestion_verbose(\n+                        then_span.shrink_to_hi(),\n                         \"consider `await`ing on the `Future`\",\n                         \".await\",\n                         Applicability::MaybeIncorrect,\n@@ -1992,7 +1993,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 .iter()\n                 .filter(|field| field.vis.is_accessible_from(field.did, self.tcx))\n                 .map(|field| (field.name, field.ty(self.tcx, expected_substs)))\n-                .find(|(_, ty)| same_type_modulo_infer(*ty, exp_found.found))\n+                .find(|(_, ty)| self.same_type_modulo_infer(*ty, exp_found.found))\n             {\n                 if let ObligationCauseCode::Pattern { span: Some(span), .. } = *cause.code() {\n                     if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(span) {\n@@ -2057,7 +2058,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                                         | (_, ty::Infer(_))\n                                         | (ty::Param(_), _)\n                                         | (ty::Infer(_), _) => {}\n-                                        _ if same_type_modulo_infer(exp_ty, found_ty) => {}\n+                                        _ if self.same_type_modulo_infer(exp_ty, found_ty) => {}\n                                         _ => show_suggestion = false,\n                                     };\n                                 }\n@@ -2179,7 +2180,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     ) {\n         let [expected_tup_elem] = expected_fields[..] else { return };\n \n-        if !same_type_modulo_infer(expected_tup_elem, found) {\n+        if !self.same_type_modulo_infer(expected_tup_elem, found) {\n             return;\n         }\n \n@@ -2647,6 +2648,76 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         span.is_desugaring(DesugaringKind::QuestionMark)\n             && self.tcx.is_diagnostic_item(sym::From, trait_def_id)\n     }\n+\n+    /// Structurally compares two types, modulo any inference variables.\n+    ///\n+    /// Returns `true` if two types are equal, or if one type is an inference variable compatible\n+    /// with the other type. A TyVar inference type is compatible with any type, and an IntVar or\n+    /// FloatVar inference type are compatible with themselves or their concrete types (Int and\n+    /// Float types, respectively). When comparing two ADTs, these rules apply recursively.\n+    pub fn same_type_modulo_infer(&self, a: Ty<'tcx>, b: Ty<'tcx>) -> bool {\n+        let (a, b) = self.resolve_vars_if_possible((a, b));\n+        match (a.kind(), b.kind()) {\n+            (&ty::Adt(def_a, substs_a), &ty::Adt(def_b, substs_b)) => {\n+                if def_a != def_b {\n+                    return false;\n+                }\n+\n+                substs_a\n+                    .types()\n+                    .zip(substs_b.types())\n+                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::FnDef(did_a, substs_a), &ty::FnDef(did_b, substs_b)) => {\n+                if did_a != did_b {\n+                    return false;\n+                }\n+\n+                substs_a\n+                    .types()\n+                    .zip(substs_b.types())\n+                    .all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::Int(_) | &ty::Uint(_), &ty::Infer(ty::InferTy::IntVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::IntVar(_)),\n+                &ty::Int(_) | &ty::Uint(_) | &ty::Infer(ty::InferTy::IntVar(_)),\n+            )\n+            | (&ty::Float(_), &ty::Infer(ty::InferTy::FloatVar(_)))\n+            | (\n+                &ty::Infer(ty::InferTy::FloatVar(_)),\n+                &ty::Float(_) | &ty::Infer(ty::InferTy::FloatVar(_)),\n+            )\n+            | (&ty::Infer(ty::InferTy::TyVar(_)), _)\n+            | (_, &ty::Infer(ty::InferTy::TyVar(_))) => true,\n+            (&ty::Ref(_, ty_a, mut_a), &ty::Ref(_, ty_b, mut_b)) => {\n+                mut_a == mut_b && self.same_type_modulo_infer(ty_a, ty_b)\n+            }\n+            (&ty::RawPtr(a), &ty::RawPtr(b)) => {\n+                a.mutbl == b.mutbl && self.same_type_modulo_infer(a.ty, b.ty)\n+            }\n+            (&ty::Slice(a), &ty::Slice(b)) => self.same_type_modulo_infer(a, b),\n+            (&ty::Array(a_ty, a_ct), &ty::Array(b_ty, b_ct)) => {\n+                self.same_type_modulo_infer(a_ty, b_ty) && a_ct == b_ct\n+            }\n+            (&ty::Tuple(a), &ty::Tuple(b)) => {\n+                if a.len() != b.len() {\n+                    return false;\n+                }\n+                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            (&ty::FnPtr(a), &ty::FnPtr(b)) => {\n+                let a = a.skip_binder().inputs_and_output;\n+                let b = b.skip_binder().inputs_and_output;\n+                if a.len() != b.len() {\n+                    return false;\n+                }\n+                std::iter::zip(a.iter(), b.iter()).all(|(a, b)| self.same_type_modulo_infer(a, b))\n+            }\n+            // FIXME(compiler-errors): This needs to be generalized more\n+            _ => a == b,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -2798,3 +2869,237 @@ impl TyCategory {\n         }\n     }\n }\n+\n+impl<'tcx> InferCtxt<'_, 'tcx> {\n+    /// Given a [`hir::Block`], get the span of its last expression or\n+    /// statement, peeling off any inner blocks.\n+    pub fn find_block_span(&self, block: &'tcx hir::Block<'tcx>) -> Span {\n+        let block = block.innermost_block();\n+        if let Some(expr) = &block.expr {\n+            expr.span\n+        } else if let Some(stmt) = block.stmts.last() {\n+            // possibly incorrect trailing `;` in the else arm\n+            stmt.span\n+        } else {\n+            // empty block; point at its entirety\n+            block.span\n+        }\n+    }\n+\n+    /// Given a [`hir::HirId`] for a block, get the span of its last expression\n+    /// or statement, peeling off any inner blocks.\n+    pub fn find_block_span_from_hir_id(&self, hir_id: hir::HirId) -> Span {\n+        match self.tcx.hir().get(hir_id) {\n+            hir::Node::Block(blk) => self.find_block_span(blk),\n+            // The parser was in a weird state if either of these happen, but\n+            // it's better not to panic.\n+            hir::Node::Expr(e) => e.span,\n+            _ => rustc_span::DUMMY_SP,\n+        }\n+    }\n+\n+    /// Be helpful when the user wrote `{... expr; }` and taking the `;` off\n+    /// is enough to fix the error.\n+    pub fn could_remove_semicolon(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+    ) -> Option<(Span, StatementAsExpression)> {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return None;\n+        }\n+        let last_stmt = blk.stmts.last()?;\n+        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n+            return None;\n+        };\n+        let last_expr_ty = self.in_progress_typeck_results?.borrow().expr_ty_opt(*last_expr)?;\n+        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n+            _ if last_expr_ty.references_error() => return None,\n+            _ if self.same_type_modulo_infer(last_expr_ty, expected_ty) => {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n+                if last_def_id == exp_def_id =>\n+            {\n+                StatementAsExpression::CorrectType\n+            }\n+            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n+                debug!(\n+                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n+                    last_def_id, last_bounds, exp_def_id, exp_bounds\n+                );\n+\n+                let last_local_id = last_def_id.as_local()?;\n+                let exp_local_id = exp_def_id.as_local()?;\n+\n+                match (\n+                    &self.tcx.hir().expect_item(last_local_id).kind,\n+                    &self.tcx.hir().expect_item(exp_local_id).kind,\n+                ) {\n+                    (\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n+                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n+                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n+                        match (left, right) {\n+                            (\n+                                hir::GenericBound::Trait(tl, ml),\n+                                hir::GenericBound::Trait(tr, mr),\n+                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n+                                && ml == mr =>\n+                            {\n+                                true\n+                            }\n+                            (\n+                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n+                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n+                            ) if langl == langr => {\n+                                // FIXME: consider the bounds!\n+                                debug!(\"{:?} {:?}\", argsl, argsr);\n+                                true\n+                            }\n+                            _ => false,\n+                        }\n+                    }) =>\n+                    {\n+                        StatementAsExpression::NeedsBoxing\n+                    }\n+                    _ => StatementAsExpression::CorrectType,\n+                }\n+            }\n+            _ => return None,\n+        };\n+        let span = if last_stmt.span.from_expansion() {\n+            let mac_call = rustc_span::source_map::original_sp(last_stmt.span, blk.span);\n+            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n+        } else {\n+            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n+        };\n+        Some((span, needs_box))\n+    }\n+\n+    /// Suggest returning a local binding with a compatible type if the block\n+    /// has no return expression.\n+    pub fn consider_returning_binding(\n+        &self,\n+        blk: &'tcx hir::Block<'tcx>,\n+        expected_ty: Ty<'tcx>,\n+        err: &mut Diagnostic,\n+    ) -> bool {\n+        let blk = blk.innermost_block();\n+        // Do not suggest if we have a tail expr.\n+        if blk.expr.is_some() {\n+            return false;\n+        }\n+        let mut shadowed = FxHashSet::default();\n+        let mut candidate_idents = vec![];\n+        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n+            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n+                && let Some(pat_ty) = self\n+                    .in_progress_typeck_results\n+                    .and_then(|typeck_results| typeck_results.borrow().node_type_opt(*hir_id))\n+            {\n+                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n+                if self.same_type_modulo_infer(pat_ty, expected_ty)\n+                    && !(pat_ty, expected_ty).references_error()\n+                    && shadowed.insert(ident.name)\n+                {\n+                    candidate_idents.push((*ident, pat_ty));\n+                }\n+            }\n+            true\n+        };\n+\n+        let hir = self.tcx.hir();\n+        for stmt in blk.stmts.iter().rev() {\n+            let hir::StmtKind::Local(local) = &stmt.kind else { continue; };\n+            local.pat.walk(&mut find_compatible_candidates);\n+        }\n+        match hir.find(hir.get_parent_node(blk.hir_id)) {\n+            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n+                match hir.find(hir.get_parent_node(*hir_id)) {\n+                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n+                        pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    Some(\n+                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n+                        | hir::Node::ImplItem(hir::ImplItem {\n+                            kind: hir::ImplItemKind::Fn(_, body),\n+                            ..\n+                        })\n+                        | hir::Node::TraitItem(hir::TraitItem {\n+                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n+                            ..\n+                        })\n+                        | hir::Node::Expr(hir::Expr {\n+                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n+                            ..\n+                        }),\n+                    ) => {\n+                        for param in hir.body(*body).params {\n+                            param.pat.walk(&mut find_compatible_candidates);\n+                        }\n+                    }\n+                    Some(hir::Node::Expr(hir::Expr {\n+                        kind:\n+                            hir::ExprKind::If(\n+                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n+                                then_block,\n+                                _,\n+                            ),\n+                        ..\n+                    })) if then_block.hir_id == *hir_id => {\n+                        let_.pat.walk(&mut find_compatible_candidates);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        match &candidate_idents[..] {\n+            [(ident, _ty)] => {\n+                let sm = self.tcx.sess.source_map();\n+                if let Some(stmt) = blk.stmts.last() {\n+                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(stmt_span)\n+                    {\n+                        format!(\"\\n{spacing}{ident}\")\n+                    } else {\n+                        format!(\" {ident}\")\n+                    };\n+                    err.span_suggestion_verbose(\n+                        stmt_span.shrink_to_hi(),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                } else {\n+                    let sugg = if sm.is_multiline(blk.span)\n+                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n+                    {\n+                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n+                    } else {\n+                        format!(\" {ident} \")\n+                    };\n+                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n+                    err.span_suggestion_verbose(\n+                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n+                        format!(\"consider returning the local binding `{ident}`\"),\n+                        sugg,\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                true\n+            }\n+            values if (1..3).contains(&values.len()) => {\n+                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n+                err.span_note(spans, \"consider returning one of these bindings\");\n+                true\n+            }\n+            _ => false,\n+        }\n+    }\n+}"}, {"sha": "702cc48ff7bb3cc13b37b84af5c92fdc1c837221", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1662,6 +1662,22 @@ impl SourceScope {\n             ClearCrossCrate::Clear => None,\n         }\n     }\n+\n+    /// The instance this source scope was inlined from, if any.\n+    #[inline]\n+    pub fn inlined_instance<'tcx>(\n+        self,\n+        source_scopes: &IndexVec<SourceScope, SourceScopeData<'tcx>>,\n+    ) -> Option<ty::Instance<'tcx>> {\n+        let scope_data = &source_scopes[self];\n+        if let Some((inlined_instance, _)) = scope_data.inlined {\n+            Some(inlined_instance)\n+        } else if let Some(inlined_scope) = scope_data.inlined_parent_scope {\n+            Some(source_scopes[inlined_scope].inlined.unwrap().0)\n+        } else {\n+            None\n+        }\n+    }\n }\n \n #[derive(Clone, Debug, TyEncodable, TyDecodable, HashStable, TypeFoldable, TypeVisitable)]"}, {"sha": "c55971557fac1967551d819554b9ffc0e8d947c8", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -351,7 +351,7 @@ pub enum ObligationCauseCode<'tcx> {\n     ConstPatternStructural,\n \n     /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n+    IfExpression(Box<IfExpressionCause<'tcx>>),\n \n     /// Computing common supertype of an if expression with no else counter-part\n     IfExpressionWithNoElse,\n@@ -488,22 +488,27 @@ impl<'tcx> ty::Lift<'tcx> for StatementAsExpression {\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_block_id: Option<hir::HirId>,\n+    pub arm_ty: Ty<'tcx>,\n     pub arm_span: Span,\n+    pub prior_arm_block_id: Option<hir::HirId>,\n+    pub prior_arm_ty: Ty<'tcx>,\n+    pub prior_arm_span: Span,\n     pub scrut_span: Span,\n-    pub semi_span: Option<(Span, StatementAsExpression)>,\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n     pub scrut_hir_id: hir::HirId,\n     pub opt_suggest_box_span: Option<Span>,\n }\n \n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub else_sp: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<(Span, StatementAsExpression)>,\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+#[derive(Lift, TypeFoldable, TypeVisitable)]\n+pub struct IfExpressionCause<'tcx> {\n+    pub then_id: hir::HirId,\n+    pub else_id: hir::HirId,\n+    pub then_ty: Ty<'tcx>,\n+    pub else_ty: Ty<'tcx>,\n+    pub outer_span: Option<Span>,\n     pub opt_suggest_box_span: Option<Span>,\n }\n "}, {"sha": "7fbd57ac7354aa2691dfec008de1a25618e355ea", "filename": "compiler/rustc_middle/src/traits/structural_impls.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fstructural_impls.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -130,7 +130,6 @@ impl<N: fmt::Debug> fmt::Debug for traits::ImplSourceConstDestructData<N> {\n // Lift implementations\n \n TrivialTypeTraversalAndLiftImpls! {\n-    super::IfExpressionCause,\n     super::ImplSourceDiscriminantKindData,\n     super::ImplSourcePointeeData,\n }"}, {"sha": "03bb515904cd01e0b5719e035582785b5941de26", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1729,7 +1729,7 @@ impl<'tcx> Printer<'tcx> for FmtPrinter<'_, 'tcx> {\n     }\n \n     fn print_const(self, ct: ty::Const<'tcx>) -> Result<Self::Const, Self::Error> {\n-        self.pretty_print_const(ct, true)\n+        self.pretty_print_const(ct, false)\n     }\n \n     fn path_crate(mut self, cnum: CrateNum) -> Result<Self::Path, Self::Error> {"}, {"sha": "d305960b4856d23540a251ba2689ccbf0d8a9c54", "filename": "compiler/rustc_mir_transform/src/simplify.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fsimplify.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -28,6 +28,7 @@\n //! return.\n \n use crate::MirPass;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_middle::mir::coverage::*;\n use rustc_middle::mir::visit::{MutVisitor, MutatingUseContext, PlaceContext, Visitor};\n@@ -267,7 +268,8 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n         return;\n     }\n \n-    let basic_blocks = body.basic_blocks_mut();\n+    let basic_blocks = body.basic_blocks.as_mut();\n+    let source_scopes = &body.source_scopes;\n     let mut replacements: Vec<_> = (0..num_blocks).map(BasicBlock::new).collect();\n     let mut used_blocks = 0;\n     for alive_index in reachable.iter() {\n@@ -282,7 +284,7 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n     }\n \n     if tcx.sess.instrument_coverage() {\n-        save_unreachable_coverage(basic_blocks, used_blocks);\n+        save_unreachable_coverage(basic_blocks, source_scopes, used_blocks);\n     }\n \n     basic_blocks.raw.truncate(used_blocks);\n@@ -311,56 +313,62 @@ pub fn remove_dead_blocks<'tcx>(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>) {\n /// `Unreachable` coverage statements. These are non-executable statements whose\n /// code regions are still recorded in the coverage map, representing regions\n /// with `0` executions.\n+///\n+/// If there are no live `Counter` `Coverage` statements remaining, we remove\n+/// dead `Coverage` statements along with the dead blocks. Since at least one\n+/// counter per function is required by LLVM (and necessary, to add the\n+/// `function_hash` to the counter's call to the LLVM intrinsic\n+/// `instrprof.increment()`).\n+///\n+/// The `generator::StateTransform` MIR pass and MIR inlining can create\n+/// atypical conditions, where all live `Counter`s are dropped from the MIR.\n+///\n+/// With MIR inlining we can have coverage counters belonging to different\n+/// instances in a single body, so the strategy described above is applied to\n+/// coverage counters from each instance individually.\n fn save_unreachable_coverage(\n     basic_blocks: &mut IndexVec<BasicBlock, BasicBlockData<'_>>,\n+    source_scopes: &IndexVec<SourceScope, SourceScopeData<'_>>,\n     first_dead_block: usize,\n ) {\n-    let has_live_counters = basic_blocks.raw[0..first_dead_block].iter().any(|live_block| {\n-        live_block.statements.iter().any(|statement| {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                matches!(coverage.kind, CoverageKind::Counter { .. })\n-            } else {\n-                false\n-            }\n-        })\n-    });\n-    if !has_live_counters {\n-        // If there are no live `Counter` `Coverage` statements anymore, don't\n-        // move dead coverage to the `START_BLOCK`. Just allow the dead\n-        // `Coverage` statements to be dropped with the dead blocks.\n-        //\n-        // The `generator::StateTransform` MIR pass can create atypical\n-        // conditions, where all live `Counter`s are dropped from the MIR.\n-        //\n-        // At least one Counter per function is required by LLVM (and necessary,\n-        // to add the `function_hash` to the counter's call to the LLVM\n-        // intrinsic `instrprof.increment()`).\n+    // Identify instances that still have some live coverage counters left.\n+    let mut live = FxHashSet::default();\n+    for basic_block in &basic_blocks.raw[0..first_dead_block] {\n+        for statement in &basic_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let CoverageKind::Counter { .. } = coverage.kind else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            live.insert(instance);\n+        }\n+    }\n+\n+    if live.is_empty() {\n         return;\n     }\n \n-    // Retain coverage info for dead blocks, so coverage reports will still\n-    // report `0` executions for the uncovered code regions.\n-    let mut dropped_coverage = Vec::new();\n-    for dead_block in basic_blocks.raw[first_dead_block..].iter() {\n-        for statement in dead_block.statements.iter() {\n-            if let StatementKind::Coverage(coverage) = &statement.kind {\n-                if let Some(code_region) = &coverage.code_region {\n-                    dropped_coverage.push((statement.source_info, code_region.clone()));\n-                }\n+    // Retain coverage for instances that still have some live counters left.\n+    let mut retained_coverage = Vec::new();\n+    for dead_block in &basic_blocks.raw[first_dead_block..] {\n+        for statement in &dead_block.statements {\n+            let StatementKind::Coverage(coverage) = &statement.kind else { continue };\n+            let Some(code_region) = &coverage.code_region else { continue };\n+            let instance = statement.source_info.scope.inlined_instance(source_scopes);\n+            if live.contains(&instance) {\n+                retained_coverage.push((statement.source_info, code_region.clone()));\n             }\n         }\n     }\n \n     let start_block = &mut basic_blocks[START_BLOCK];\n-    for (source_info, code_region) in dropped_coverage {\n-        start_block.statements.push(Statement {\n+    start_block.statements.extend(retained_coverage.into_iter().map(\n+        |(source_info, code_region)| Statement {\n             source_info,\n             kind: StatementKind::Coverage(Box::new(Coverage {\n                 kind: CoverageKind::Unreachable,\n                 code_region: Some(code_region),\n             })),\n-        })\n-    }\n+        },\n+    ));\n }\n \n pub struct SimplifyLocals;"}, {"sha": "ff2d386932858d76af2afc08778da8832819ff75", "filename": "compiler/rustc_monomorphize/src/partitioning/mod.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fpartitioning%2Fmod.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -98,6 +98,7 @@ mod merging;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync;\n use rustc_hir::def_id::DefIdSet;\n+use rustc_middle::mir;\n use rustc_middle::mir::mono::MonoItem;\n use rustc_middle::mir::mono::{CodegenUnit, Linkage};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n@@ -479,9 +480,14 @@ fn codegened_and_inlined_items<'tcx>(tcx: TyCtxt<'tcx>, (): ()) -> &'tcx DefIdSe\n                 if !visited.insert(did) {\n                     continue;\n                 }\n-                for scope in &tcx.instance_mir(instance.def).source_scopes {\n-                    if let Some((ref inlined, _)) = scope.inlined {\n-                        result.insert(inlined.def_id());\n+                let body = tcx.instance_mir(instance.def);\n+                for block in body.basic_blocks() {\n+                    for statement in &block.statements {\n+                        let mir::StatementKind::Coverage(_) = statement.kind else { continue };\n+                        let scope = statement.source_info.scope;\n+                        if let Some(inlined) = scope.inlined_instance(&body.source_scopes) {\n+                            result.insert(inlined.def_id());\n+                        }\n                     }\n                 }\n             }"}, {"sha": "2f92a77a7957d886185adb768ea2c4f09ef8671b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -22,7 +22,6 @@ use rustc_hir::intravisit::Visitor;\n use rustc_hir::GenericParam;\n use rustc_hir::Item;\n use rustc_hir::Node;\n-use rustc_infer::infer::error_reporting::same_type_modulo_infer;\n use rustc_infer::traits::TraitEngine;\n use rustc_middle::traits::select::OverflowError;\n use rustc_middle::ty::abstract_const::NotConstEvaluatable;\n@@ -640,7 +639,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                             if expected.len() == 1 { \"\" } else { \"s\" },\n                                         )\n                                     );\n-                                } else if !same_type_modulo_infer(given_ty, expected_ty) {\n+                                } else if !self.same_type_modulo_infer(given_ty, expected_ty) {\n                                     // Print type mismatch\n                                     let (expected_args, given_args) =\n                                         self.cmp(given_ty, expected_ty);"}, {"sha": "f629f6a0099d7a86d19cbd2f1c604b7b325c1024", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 68, "deletions": 101, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -9,7 +9,6 @@ use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt;\n use rustc_trait_selection::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n-    StatementAsExpression,\n };\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -75,8 +74,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         let mut other_arms = vec![]; // Used only for diagnostics.\n-        let mut prior_arm_ty = None;\n-        for (i, arm) in arms.iter().enumerate() {\n+        let mut prior_arm = None;\n+        for arm in arms {\n             if let Some(g) = &arm.guard {\n                 self.diverges.set(Diverges::Maybe);\n                 match g {\n@@ -96,21 +95,28 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n             let opt_suggest_box_span = self.opt_suggest_box_span(arm_ty, orig_expected);\n \n-            let (arm_span, semi_span) =\n-                self.get_appropriate_arm_semicolon_removal_span(&arms, i, prior_arm_ty, arm_ty);\n-            let (span, code) = match i {\n+            let (arm_block_id, arm_span) = if let hir::ExprKind::Block(blk, _) = arm.body.kind {\n+                (Some(blk.hir_id), self.find_block_span(blk))\n+            } else {\n+                (None, arm.body.span)\n+            };\n+\n+            let (span, code) = match prior_arm {\n                 // The reason for the first arm to fail is not that the match arms diverge,\n                 // but rather that there's a prior obligation that doesn't hold.\n-                0 => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n-                _ => (\n+                None => (arm_span, ObligationCauseCode::BlockTailExpression(arm.body.hir_id)),\n+                Some((prior_arm_block_id, prior_arm_ty, prior_arm_span)) => (\n                     expr.span,\n                     ObligationCauseCode::MatchExpressionArm(Box::new(MatchExpressionArmCause {\n+                        arm_block_id,\n                         arm_span,\n+                        arm_ty,\n+                        prior_arm_block_id,\n+                        prior_arm_ty,\n+                        prior_arm_span,\n                         scrut_span: scrut.span,\n-                        semi_span,\n                         source: match_src,\n                         prior_arms: other_arms.clone(),\n-                        last_ty: prior_arm_ty.unwrap(),\n                         scrut_hir_id: scrut.hir_id,\n                         opt_suggest_box_span,\n                     })),\n@@ -139,7 +145,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             let ret_ty = ret_coercion.borrow().expected_ty();\n                             let ret_ty = self.inh.infcx.shallow_resolve(ret_ty);\n                             self.can_coerce(arm_ty, ret_ty)\n-                                && prior_arm_ty.map_or(true, |t| self.can_coerce(t, ret_ty))\n+                                && prior_arm.map_or(true, |(_, t, _)| self.can_coerce(t, ret_ty))\n                                 // The match arms need to unify for the case of `impl Trait`.\n                                 && !matches!(ret_ty.kind(), ty::Opaque(..))\n                         }\n@@ -181,7 +187,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if other_arms.len() > 5 {\n                 other_arms.remove(0);\n             }\n-            prior_arm_ty = Some(arm_ty);\n+\n+            prior_arm = Some((arm_block_id, arm_ty, arm_span));\n         }\n \n         // If all of the arms in the `match` diverge,\n@@ -207,28 +214,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match_ty\n     }\n \n-    fn get_appropriate_arm_semicolon_removal_span(\n-        &self,\n-        arms: &'tcx [hir::Arm<'tcx>],\n-        i: usize,\n-        prior_arm_ty: Option<Ty<'tcx>>,\n-        arm_ty: Ty<'tcx>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        let arm = &arms[i];\n-        let (arm_span, mut semi_span) = if let hir::ExprKind::Block(blk, _) = &arm.body.kind {\n-            self.find_block_span(blk, prior_arm_ty)\n-        } else {\n-            (arm.body.span, None)\n-        };\n-        if semi_span.is_none() && i > 0 {\n-            if let hir::ExprKind::Block(blk, _) = &arms[i - 1].body.kind {\n-                let (_, semi_span_prev) = self.find_block_span(blk, Some(arm_ty));\n-                semi_span = semi_span_prev;\n-            }\n-        }\n-        (arm_span, semi_span)\n-    }\n-\n     /// When the previously checked expression (the scrutinee) diverges,\n     /// warn the user about the match arms being unreachable.\n     fn warn_arms_when_scrutinee_diverges(&self, arms: &'tcx [hir::Arm<'tcx>]) {\n@@ -313,7 +298,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         else_ty: Ty<'tcx>,\n         opt_suggest_box_span: Option<Span>,\n     ) -> ObligationCause<'tcx> {\n-        let mut outer_sp = if self.tcx.sess.source_map().is_multiline(span) {\n+        let mut outer_span = if self.tcx.sess.source_map().is_multiline(span) {\n             // The `if`/`else` isn't in one line in the output, include some context to make it\n             // clear it is an if/else expression:\n             // ```\n@@ -339,69 +324,67 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None\n         };\n \n-        let mut remove_semicolon = None;\n-        let error_sp = if let ExprKind::Block(block, _) = &else_expr.kind {\n-            let (error_sp, semi_sp) = self.find_block_span(block, Some(then_ty));\n-            remove_semicolon = semi_sp;\n-            if block.expr.is_none() && block.stmts.is_empty() {\n-                // Avoid overlapping spans that aren't as readable:\n-                // ```\n-                // 2 |        let x = if true {\n-                //   |   _____________-\n-                // 3 |  |         3\n-                //   |  |         - expected because of this\n-                // 4 |  |     } else {\n-                //   |  |____________^\n-                // 5 | ||\n-                // 6 | ||     };\n-                //   | ||     ^\n-                //   | ||_____|\n-                //   | |______if and else have incompatible types\n-                //   |        expected integer, found `()`\n-                // ```\n-                // by not pointing at the entire expression:\n-                // ```\n-                // 2 |       let x = if true {\n-                //   |               ------- `if` and `else` have incompatible types\n-                // 3 |           3\n-                //   |           - expected because of this\n-                // 4 |       } else {\n-                //   |  ____________^\n-                // 5 | |\n-                // 6 | |     };\n-                //   | |_____^ expected integer, found `()`\n-                // ```\n-                if outer_sp.is_some() {\n-                    outer_sp = Some(self.tcx.sess.source_map().guess_head_span(span));\n-                }\n+        let (error_sp, else_id) = if let ExprKind::Block(block, _) = &else_expr.kind {\n+            let block = block.innermost_block();\n+\n+            // Avoid overlapping spans that aren't as readable:\n+            // ```\n+            // 2 |        let x = if true {\n+            //   |   _____________-\n+            // 3 |  |         3\n+            //   |  |         - expected because of this\n+            // 4 |  |     } else {\n+            //   |  |____________^\n+            // 5 | ||\n+            // 6 | ||     };\n+            //   | ||     ^\n+            //   | ||_____|\n+            //   | |______if and else have incompatible types\n+            //   |        expected integer, found `()`\n+            // ```\n+            // by not pointing at the entire expression:\n+            // ```\n+            // 2 |       let x = if true {\n+            //   |               ------- `if` and `else` have incompatible types\n+            // 3 |           3\n+            //   |           - expected because of this\n+            // 4 |       } else {\n+            //   |  ____________^\n+            // 5 | |\n+            // 6 | |     };\n+            //   | |_____^ expected integer, found `()`\n+            // ```\n+            if block.expr.is_none() && block.stmts.is_empty()\n+                && let Some(outer_span) = &mut outer_span\n+            {\n+                *outer_span = self.tcx.sess.source_map().guess_head_span(*outer_span);\n             }\n-            error_sp\n+\n+            (self.find_block_span(block), block.hir_id)\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            else_expr.span\n+            (else_expr.span, else_expr.hir_id)\n         };\n \n-        // Compute `Span` of `then` part of `if`-expression.\n-        let then_sp = if let ExprKind::Block(block, _) = &then_expr.kind {\n-            let (then_sp, semi_sp) = self.find_block_span(block, Some(else_ty));\n-            remove_semicolon = remove_semicolon.or(semi_sp);\n+        let then_id = if let ExprKind::Block(block, _) = &then_expr.kind {\n+            let block = block.innermost_block();\n+            // Exclude overlapping spans\n             if block.expr.is_none() && block.stmts.is_empty() {\n-                outer_sp = None; // same as in `error_sp`; cleanup output\n+                outer_span = None;\n             }\n-            then_sp\n+            block.hir_id\n         } else {\n-            // shouldn't happen unless the parser has done something weird\n-            then_expr.span\n+            then_expr.hir_id\n         };\n \n         // Finally construct the cause:\n         self.cause(\n             error_sp,\n             ObligationCauseCode::IfExpression(Box::new(IfExpressionCause {\n-                then: then_sp,\n-                else_sp: error_sp,\n-                outer: outer_sp,\n-                semicolon: remove_semicolon,\n+                else_id,\n+                then_id,\n+                then_ty,\n+                else_ty,\n+                outer_span,\n                 opt_suggest_box_span,\n             })),\n         )\n@@ -482,22 +465,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn find_block_span(\n-        &self,\n-        block: &'tcx hir::Block<'tcx>,\n-        expected_ty: Option<Ty<'tcx>>,\n-    ) -> (Span, Option<(Span, StatementAsExpression)>) {\n-        if let Some(expr) = &block.expr {\n-            (expr.span, None)\n-        } else if let Some(stmt) = block.stmts.last() {\n-            // possibly incorrect trailing `;` in the else arm\n-            (stmt.span, expected_ty.and_then(|ty| self.could_remove_semicolon(block, ty)))\n-        } else {\n-            // empty block; point at its entirety\n-            (block.span, None)\n-        }\n-    }\n-\n     // When we have a `match` as a tail expression in a `fn` with a returned `impl Trait`\n     // we check if the different arms would work with boxed trait objects instead and\n     // provide a structured suggestion in that case."}, {"sha": "21b3c9063a78a85331e4caf8ed7a5c252efce94f", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 2, "deletions": 82, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -30,17 +30,15 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::source_map::{original_sp, DUMMY_SP};\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{self, BytePos, Span};\n+use rustc_span::{Span, DUMMY_SP};\n use rustc_trait_selection::infer::InferCtxtExt as _;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n-    self, ObligationCause, ObligationCauseCode, StatementAsExpression, TraitEngine, TraitEngineExt,\n+    self, ObligationCause, ObligationCauseCode, TraitEngine, TraitEngineExt,\n };\n \n use std::collections::hash_map::Entry;\n-use std::iter;\n use std::slice;\n \n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n@@ -1059,84 +1057,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ));\n     }\n \n-    pub(in super::super) fn could_remove_semicolon(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-    ) -> Option<(Span, StatementAsExpression)> {\n-        // Be helpful when the user wrote `{... expr;}` and\n-        // taking the `;` off is enough to fix the error.\n-        let last_stmt = blk.stmts.last()?;\n-        let hir::StmtKind::Semi(ref last_expr) = last_stmt.kind else {\n-            return None;\n-        };\n-        let last_expr_ty = self.node_ty(last_expr.hir_id);\n-        let needs_box = match (last_expr_ty.kind(), expected_ty.kind()) {\n-            (ty::Opaque(last_def_id, _), ty::Opaque(exp_def_id, _))\n-                if last_def_id == exp_def_id =>\n-            {\n-                StatementAsExpression::CorrectType\n-            }\n-            (ty::Opaque(last_def_id, last_bounds), ty::Opaque(exp_def_id, exp_bounds)) => {\n-                debug!(\n-                    \"both opaque, likely future {:?} {:?} {:?} {:?}\",\n-                    last_def_id, last_bounds, exp_def_id, exp_bounds\n-                );\n-\n-                let last_local_id = last_def_id.as_local()?;\n-                let exp_local_id = exp_def_id.as_local()?;\n-\n-                match (\n-                    &self.tcx.hir().expect_item(last_local_id).kind,\n-                    &self.tcx.hir().expect_item(exp_local_id).kind,\n-                ) {\n-                    (\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: last_bounds, .. }),\n-                        hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds: exp_bounds, .. }),\n-                    ) if iter::zip(*last_bounds, *exp_bounds).all(|(left, right)| {\n-                        match (left, right) {\n-                            (\n-                                hir::GenericBound::Trait(tl, ml),\n-                                hir::GenericBound::Trait(tr, mr),\n-                            ) if tl.trait_ref.trait_def_id() == tr.trait_ref.trait_def_id()\n-                                && ml == mr =>\n-                            {\n-                                true\n-                            }\n-                            (\n-                                hir::GenericBound::LangItemTrait(langl, _, _, argsl),\n-                                hir::GenericBound::LangItemTrait(langr, _, _, argsr),\n-                            ) if langl == langr => {\n-                                // FIXME: consider the bounds!\n-                                debug!(\"{:?} {:?}\", argsl, argsr);\n-                                true\n-                            }\n-                            _ => false,\n-                        }\n-                    }) =>\n-                    {\n-                        StatementAsExpression::NeedsBoxing\n-                    }\n-                    _ => StatementAsExpression::CorrectType,\n-                }\n-            }\n-            _ => StatementAsExpression::CorrectType,\n-        };\n-        if (matches!(last_expr_ty.kind(), ty::Error(_))\n-            || self.can_sub(self.param_env, last_expr_ty, expected_ty).is_err())\n-            && matches!(needs_box, StatementAsExpression::CorrectType)\n-        {\n-            return None;\n-        }\n-        let span = if last_stmt.span.from_expansion() {\n-            let mac_call = original_sp(last_stmt.span, blk.span);\n-            self.tcx.sess.source_map().mac_call_stmt_semi_span(mac_call)?\n-        } else {\n-            last_stmt.span.with_lo(last_stmt.span.hi() - BytePos(1))\n-        };\n-        Some((span, needs_box))\n-    }\n-\n     // Instantiates the given path, which must refer to an item with the given\n     // number of type parameters and type.\n     #[instrument(skip(self, span), level = \"debug\")]"}, {"sha": "3e6ff72204f4c49b6c02349d8588058d0ccd4566", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 115, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -3,7 +3,6 @@ use crate::astconv::AstConv;\n use crate::errors::{AddReturnTypeSuggestion, ExpectedReturnTypeLabel};\n \n use rustc_ast::util::parser::ExprPrecedence;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, Diagnostic, MultiSpan};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorOf, DefKind};\n@@ -14,7 +13,7 @@ use rustc_hir::{\n use rustc_infer::infer::{self, TyCtxtInferExt};\n use rustc_infer::traits::{self, StatementAsExpression};\n use rustc_middle::lint::in_external_macro;\n-use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty, TypeVisitable};\n+use rustc_middle::ty::{self, Binder, IsSuggestable, Subst, ToPredicate, Ty};\n use rustc_span::symbol::sym;\n use rustc_span::Span;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n@@ -904,117 +903,4 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             false\n         }\n     }\n-\n-    pub(crate) fn consider_returning_binding(\n-        &self,\n-        blk: &'tcx hir::Block<'tcx>,\n-        expected_ty: Ty<'tcx>,\n-        err: &mut Diagnostic,\n-    ) {\n-        let mut shadowed = FxHashSet::default();\n-        let mut candidate_idents = vec![];\n-        let mut find_compatible_candidates = |pat: &hir::Pat<'_>| {\n-            if let hir::PatKind::Binding(_, hir_id, ident, _) = &pat.kind\n-                && let Some(pat_ty) = self.typeck_results.borrow().node_type_opt(*hir_id)\n-            {\n-                let pat_ty = self.resolve_vars_if_possible(pat_ty);\n-                if self.can_coerce(pat_ty, expected_ty)\n-                    && !(pat_ty, expected_ty).references_error()\n-                    && shadowed.insert(ident.name)\n-                {\n-                    candidate_idents.push((*ident, pat_ty));\n-                }\n-            }\n-            true\n-        };\n-\n-        let hir = self.tcx.hir();\n-        for stmt in blk.stmts.iter().rev() {\n-            let StmtKind::Local(local) = &stmt.kind else { continue; };\n-            local.pat.walk(&mut find_compatible_candidates);\n-        }\n-        match hir.find(hir.get_parent_node(blk.hir_id)) {\n-            Some(hir::Node::Expr(hir::Expr { hir_id, .. })) => {\n-                match hir.find(hir.get_parent_node(*hir_id)) {\n-                    Some(hir::Node::Arm(hir::Arm { pat, .. })) => {\n-                        pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    Some(\n-                        hir::Node::Item(hir::Item { kind: hir::ItemKind::Fn(_, _, body), .. })\n-                        | hir::Node::ImplItem(hir::ImplItem {\n-                            kind: hir::ImplItemKind::Fn(_, body),\n-                            ..\n-                        })\n-                        | hir::Node::TraitItem(hir::TraitItem {\n-                            kind: hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body)),\n-                            ..\n-                        })\n-                        | hir::Node::Expr(hir::Expr {\n-                            kind: hir::ExprKind::Closure(hir::Closure { body, .. }),\n-                            ..\n-                        }),\n-                    ) => {\n-                        for param in hir.body(*body).params {\n-                            param.pat.walk(&mut find_compatible_candidates);\n-                        }\n-                    }\n-                    Some(hir::Node::Expr(hir::Expr {\n-                        kind:\n-                            hir::ExprKind::If(\n-                                hir::Expr { kind: hir::ExprKind::Let(let_), .. },\n-                                then_block,\n-                                _,\n-                            ),\n-                        ..\n-                    })) if then_block.hir_id == *hir_id => {\n-                        let_.pat.walk(&mut find_compatible_candidates);\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        match &candidate_idents[..] {\n-            [(ident, _ty)] => {\n-                let sm = self.tcx.sess.source_map();\n-                if let Some(stmt) = blk.stmts.last() {\n-                    let stmt_span = sm.stmt_span(stmt.span, blk.span);\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(stmt_span)\n-                    {\n-                        format!(\"\\n{spacing}{ident}\")\n-                    } else {\n-                        format!(\" {ident}\")\n-                    };\n-                    err.span_suggestion_verbose(\n-                        stmt_span.shrink_to_hi(),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                } else {\n-                    let sugg = if sm.is_multiline(blk.span)\n-                        && let Some(spacing) = sm.indentation_before(blk.span.shrink_to_lo())\n-                    {\n-                        format!(\"\\n{spacing}    {ident}\\n{spacing}\")\n-                    } else {\n-                        format!(\" {ident} \")\n-                    };\n-                    let left_span = sm.span_through_char(blk.span, '{').shrink_to_hi();\n-                    err.span_suggestion_verbose(\n-                        sm.span_extend_while(left_span, |c| c.is_whitespace()).unwrap_or(left_span),\n-                        format!(\"consider returning the local binding `{ident}`\"),\n-                        sugg,\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-            }\n-            values if (1..3).contains(&values.len()) => {\n-                let spans = values.iter().map(|(ident, _)| ident.span).collect::<Vec<_>>();\n-                err.span_note(spans, \"consider returning one of these bindings\");\n-            }\n-            _ => {}\n-        }\n-    }\n }"}, {"sha": "55f781ce0222a3d634cf0c72fa30d512c7e128fb", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -97,7 +97,7 @@ impl<T: ?Sized> *const T {\n     /// refactored.\n     #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n     #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n-    pub const fn as_mut(self) -> *mut T {\n+    pub const fn cast_mut(self) -> *mut T {\n         self as _\n     }\n "}, {"sha": "27e8b20b3c52d23b2832abf086044d606d5b0eb9", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -96,11 +96,13 @@ impl<T: ?Sized> *mut T {\n     /// refactored.\n     ///\n     /// While not strictly required (`*mut T` coerces to `*const T`), this is provided for symmetry\n-    /// with `as_mut()` on `*const T` and may have documentation value if used instead of implicit\n+    /// with [`cast_mut`] on `*const T` and may have documentation value if used instead of implicit\n     /// coercion.\n+    ///\n+    /// [`cast_mut`]: #method.cast_mut\n     #[unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n     #[rustc_const_unstable(feature = \"ptr_const_cast\", issue = \"92675\")]\n-    pub const fn as_const(self) -> *const T {\n+    pub const fn cast_const(self) -> *const T {\n         self as _\n     }\n \n@@ -289,7 +291,7 @@ impl<T: ?Sized> *mut T {\n     /// For the mutable counterpart see [`as_mut`].\n     ///\n     /// [`as_uninit_ref`]: #method.as_uninit_ref-1\n-    /// [`as_mut`]: #method.as_mut-1\n+    /// [`as_mut`]: #method.as_mut\n     ///\n     /// # Safety\n     ///"}, {"sha": "45b052c824d315fe7dba344e615fab7aa9aef2d9", "filename": "library/core/src/result.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1009,6 +1009,15 @@ impl<T, E> Result<T, E> {\n \n     /// Returns the contained [`Ok`] value, consuming the `self` value.\n     ///\n+    /// Because this function may panic, its use is generally discouraged.\n+    /// Instead, prefer to use pattern matching and handle the [`Err`]\n+    /// case explicitly, or call [`unwrap_or`], [`unwrap_or_else`], or\n+    /// [`unwrap_or_default`].\n+    ///\n+    /// [`unwrap_or`]: Result::unwrap_or\n+    /// [`unwrap_or_else`]: Result::unwrap_or_else\n+    /// [`unwrap_or_default`]: Result::unwrap_or_default\n+    ///\n     /// # Panics\n     ///\n     /// Panics if the value is an [`Err`], with a panic message including the"}, {"sha": "70b7a47bcd58bf65aca0bfba557d6b5db0931552", "filename": "src/librustdoc/html/static/css/rustdoc.css", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fcss%2Frustdoc.css?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -216,6 +216,15 @@ details.rustdoc-toggle > summary::before,\n div.impl-items > div:not(.docblock):not(.item-info),\n .content ul.crate a.crate,\n a.srclink,\n+#main-content > .since,\n+#help-button > button,\n+details.rustdoc-toggle.top-doc > summary,\n+details.rustdoc-toggle.top-doc > summary::before,\n+details.rustdoc-toggle.non-exhaustive > summary,\n+details.rustdoc-toggle.non-exhaustive > summary::before,\n+.scraped-example-title,\n+.more-examples-toggle summary, .more-examples-toggle .hide-more,\n+.example-links a,\n /* This selector is for the items listed in the \"all items\" page. */\n #main-content > ul.docblock > li > a {\n \tfont-family: \"Fira Sans\", Arial, NanumBarunGothic, sans-serif;\n@@ -702,7 +711,6 @@ pre, .rustdoc.source .example-wrap {\n }\n #main-content > .since {\n \ttop: inherit;\n-\tfont-family: \"Fira Sans\", Arial, sans-serif;\n }\n \n .content table:not(.table-display) {\n@@ -1518,7 +1526,6 @@ input:checked + .slider {\n }\n \n #help-button > button {\n-\tfont-family: \"Fira Sans\", Arial, sans-serif;\n \ttext-align: center;\n \t/* Rare exception to specifying font sizes in rem. Since this is acting\n \t   as an icon, it's okay to specify their sizes in pixels. */\n@@ -1690,7 +1697,6 @@ details.rustdoc-toggle.top-doc > summary,\n details.rustdoc-toggle.top-doc > summary::before,\n details.rustdoc-toggle.non-exhaustive > summary,\n details.rustdoc-toggle.non-exhaustive > summary::before {\n-\tfont-family: 'Fira Sans';\n \tfont-size: 1rem;\n }\n \n@@ -2176,10 +2182,6 @@ in storage.js plus the media query with (min-width: 701px)\n \tborder-radius: 50px;\n }\n \n-.scraped-example-title {\n-\tfont-family: 'Fira Sans';\n-}\n-\n .scraped-example .code-wrapper {\n \tposition: relative;\n \tdisplay: flex;\n@@ -2283,10 +2285,6 @@ in storage.js plus the media query with (min-width: 701px)\n \tcursor: pointer;\n }\n \n-.more-examples-toggle summary, .more-examples-toggle .hide-more {\n-\tfont-family: 'Fira Sans';\n-}\n-\n .more-scraped-examples {\n \tmargin-left: 5px;\n \tdisplay: flex;\n@@ -2321,7 +2319,6 @@ in storage.js plus the media query with (min-width: 701px)\n \n .example-links a {\n \tmargin-top: 20px;\n-\tfont-family: 'Fira Sans';\n }\n \n .example-links ul {"}, {"sha": "d102d9ecf7d14f53b4cc970cc03903dfa4c830e1", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.inline-dead.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.inline-dead.txt?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -0,0 +1,21 @@\n+    1|       |// Regression test for issue #98833.\n+    2|       |// compile-flags: -Zinline-mir\n+    3|       |\n+    4|      1|fn main() {\n+    5|      1|    println!(\"{}\", live::<false>());\n+    6|      1|}\n+    7|       |\n+    8|       |#[inline]\n+    9|      1|fn live<const B: bool>() -> u32 {\n+   10|      1|    if B {\n+   11|      0|        dead()\n+   12|       |    } else {\n+   13|      1|        0\n+   14|       |    }\n+   15|      1|}\n+   16|       |\n+   17|       |#[inline]\n+   18|      0|fn dead() -> u32 {\n+   19|      0|    42\n+   20|      0|}\n+"}, {"sha": "cd1ae911a5f7e44dc8037a818862907dfb4e2277", "filename": "src/test/run-make-fulldeps/coverage/inline-dead.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Finline-dead.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -0,0 +1,20 @@\n+// Regression test for issue #98833.\n+// compile-flags: -Zinline-mir\n+\n+fn main() {\n+    println!(\"{}\", live::<false>());\n+}\n+\n+#[inline]\n+fn live<const B: bool>() -> u32 {\n+    if B {\n+        dead()\n+    } else {\n+        0\n+    }\n+}\n+\n+#[inline]\n+fn dead() -> u32 {\n+    42\n+}"}, {"sha": "591139523456eb2fbfafe4fa9abf3c9f868480af", "filename": "src/test/rustdoc/const-generics/add-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fadd-impl.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -7,7 +7,7 @@ pub struct Simd<T, const WIDTH: usize> {\n     inner: T,\n }\n \n-// @has foo/struct.Simd.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header in-band\"]' 'impl Add<Simd<u8, 16_usize>> for Simd<u8, 16>'\n+// @has foo/struct.Simd.html '//div[@id=\"trait-implementations-list\"]//h3[@class=\"code-header in-band\"]' 'impl Add<Simd<u8, 16>> for Simd<u8, 16>'\n impl Add for Simd<u8, 16> {\n     type Output = Self;\n "}, {"sha": "2693d9b596993ff1e75a5e411fbbecb2c0330a79", "filename": "src/test/rustdoc/const-generics/const-generic-defaults.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generic-defaults.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generic-defaults.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generic-defaults.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,5 +1,5 @@\n #![crate_name = \"foo\"]\n \n // @has foo/struct.Foo.html '//pre[@class=\"rust struct\"]' \\\n-//      'pub struct Foo<const M: usize = 10_usize, const N: usize = M, T = i32>(_);'\n+//      'pub struct Foo<const M: usize = 10, const N: usize = M, T = i32>(_);'\n pub struct Foo<const M: usize = 10, const N: usize = M, T = i32>(T);"}, {"sha": "352a8e646bb49fe76e9fc548a87be15378b2dd20", "filename": "src/test/rustdoc/const-generics/const-generics-docs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fconst-generics%2Fconst-generics-docs.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -19,8 +19,8 @@ pub use extern_crate::WTrait;\n \n // @has foo/trait.Trait.html '//pre[@class=\"rust trait\"]' \\\n //      'pub trait Trait<const N: usize>'\n-// @has - '//*[@id=\"impl-Trait%3C1_usize%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<1_usize> for u8'\n-// @has - '//*[@id=\"impl-Trait%3C2_usize%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<2_usize> for u8'\n+// @has - '//*[@id=\"impl-Trait%3C1%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<1> for u8'\n+// @has - '//*[@id=\"impl-Trait%3C2%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<2> for u8'\n // @has - '//*[@id=\"impl-Trait%3C{1%20+%202}%3E-for-u8\"]//h3[@class=\"code-header in-band\"]' 'impl Trait<{1 + 2}> for u8'\n // @has - '//*[@id=\"impl-Trait%3CN%3E-for-%5Bu8%3B%20N%5D\"]//h3[@class=\"code-header in-band\"]' \\\n //      'impl<const N: usize> Trait<N> for [u8; N]'"}, {"sha": "6ce67dcaf1d9b1c81a688e2f43c61a8110a5d18f", "filename": "src/test/ui-fulldeps/internal-lints/rustc_pass_by_value_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -44,11 +44,11 @@ struct WithParameters<T, const N: usize, M = u32> {\n }\n \n impl<T> WithParameters<T, 1> {\n-    fn with_ref(&self) {} //~ ERROR passing `WithParameters<T, 1_usize>` by reference\n+    fn with_ref(&self) {} //~ ERROR passing `WithParameters<T, 1>` by reference\n }\n \n impl<T> WithParameters<T, 1, u8> {\n-    fn with_ref(&self) {} //~ ERROR passing `WithParameters<T, 1_usize, u8>` by reference\n+    fn with_ref(&self) {} //~ ERROR passing `WithParameters<T, 1, u8>` by reference\n }\n \n fn main() {}"}, {"sha": "fb39ed60b82353a2d996562e7d3104448bc909e7", "filename": "src/test/ui-fulldeps/internal-lints/rustc_pass_by_value_self.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Frustc_pass_by_value_self.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -22,17 +22,17 @@ error: passing `Foo` by reference\n LL |     fn with_ref(&self) {}\n    |                 ^^^^^ help: try passing by value: `Foo`\n \n-error: passing `WithParameters<T, 1_usize>` by reference\n+error: passing `WithParameters<T, 1>` by reference\n   --> $DIR/rustc_pass_by_value_self.rs:47:17\n    |\n LL |     fn with_ref(&self) {}\n-   |                 ^^^^^ help: try passing by value: `WithParameters<T, 1_usize>`\n+   |                 ^^^^^ help: try passing by value: `WithParameters<T, 1>`\n \n-error: passing `WithParameters<T, 1_usize, u8>` by reference\n+error: passing `WithParameters<T, 1, u8>` by reference\n   --> $DIR/rustc_pass_by_value_self.rs:51:17\n    |\n LL |     fn with_ref(&self) {}\n-   |                 ^^^^^ help: try passing by value: `WithParameters<T, 1_usize, u8>`\n+   |                 ^^^^^ help: try passing by value: `WithParameters<T, 1, u8>`\n \n error: aborting due to 5 previous errors\n "}, {"sha": "5e531a993c62c9f253c9dfe292e1fa53496dcfbf", "filename": "src/test/ui/array-slice-vec/match_arr_unknown_len.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Farray-slice-vec%2Fmatch_arr_unknown_len.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/match_arr_unknown_len.rs:3:9\n    |\n LL |         [1, 2] => true,\n-   |         ^^^^^^ expected `2_usize`, found `N`\n+   |         ^^^^^^ expected `2`, found `N`\n    |\n    = note: expected array `[u32; 2]`\n               found array `[u32; N]`"}, {"sha": "e5887689690e76fd5066d2193ae5613782cfe0b2", "filename": "src/test/ui/async-await/async-block-control-flow-static-semantics.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fasync-block-control-flow-static-semantics.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -18,14 +18,6 @@ LL | |             break 0u8;\n LL | |         };\n    | |_________- enclosing `async` block\n \n-error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n-   |\n-LL |     let _: &dyn Future<Output = ()> = &block;\n-   |                                       ^^^^^^ expected `()`, found `u8`\n-   |\n-   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n-\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:21:58\n    |\n@@ -40,7 +32,7 @@ LL | | }\n    | |_^ expected `u8`, found `()`\n \n error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n-  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+  --> $DIR/async-block-control-flow-static-semantics.rs:26:39\n    |\n LL |     let _: &dyn Future<Output = ()> = &block;\n    |                                       ^^^^^^ expected `()`, found `u8`\n@@ -55,6 +47,14 @@ LL | fn return_targets_async_block_not_fn() -> u8 {\n    |    |\n    |    implicitly returns `()` as its body has no tail or `return` expression\n \n+error[E0271]: type mismatch resolving `<impl Future<Output = u8> as Future>::Output == ()`\n+  --> $DIR/async-block-control-flow-static-semantics.rs:17:39\n+   |\n+LL |     let _: &dyn Future<Output = ()> = &block;\n+   |                                       ^^^^^^ expected `()`, found `u8`\n+   |\n+   = note: required for the cast from `impl Future<Output = u8>` to the object type `dyn Future<Output = ()>`\n+\n error[E0308]: mismatched types\n   --> $DIR/async-block-control-flow-static-semantics.rs:47:44\n    |"}, {"sha": "e5e7ee26e44bc5ae66c87297b22dd159ffe5343c", "filename": "src/test/ui/const-generics/associated-type-bound-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fassociated-type-bound-fail.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -4,7 +4,7 @@ error[E0277]: the trait bound `u16: Bar<N>` is not satisfied\n LL |     type Assoc = u16;\n    |                  ^^^ the trait `Bar<N>` is not implemented for `u16`\n    |\n-   = help: the trait `Bar<3_usize>` is implemented for `u16`\n+   = help: the trait `Bar<3>` is implemented for `u16`\n note: required by a bound in `Foo::Assoc`\n   --> $DIR/associated-type-bound-fail.rs:4:17\n    |"}, {"sha": "e8826ce4335e78c388da61b9efb7837b4f9d525c", "filename": "src/test/ui/const-generics/defaults/generic-expr-default-concrete.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fgeneric-expr-default-concrete.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/generic-expr-default-concrete.rs:10:5\n    |\n LL |     Foo::<10, 12>\n-   |     ^^^^^^^^^^^^^ expected `11_usize`, found `12_usize`\n+   |     ^^^^^^^^^^^^^ expected `11`, found `12`\n    |\n-   = note: expected type `11_usize`\n-              found type `12_usize`\n+   = note: expected type `11`\n+              found type `12`\n \n error: aborting due to previous error\n "}, {"sha": "ec131505ed75577ed2507f97db4a65df89b0d58f", "filename": "src/test/ui/const-generics/defaults/mismatch.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,22 +1,22 @@\n-pub struct Example<const N: usize=13>;\n-pub struct Example2<T=u32, const N: usize=13>(T);\n-pub struct Example3<const N: usize=13, T=u32>(T);\n-pub struct Example4<const N: usize=13, const M: usize=4>;\n+pub struct Example<const N: usize = 13>;\n+pub struct Example2<T = u32, const N: usize = 13>(T);\n+pub struct Example3<const N: usize = 13, T = u32>(T);\n+pub struct Example4<const N: usize = 13, const M: usize = 4>;\n \n fn main() {\n-    let e: Example::<13> = ();\n+    let e: Example<13> = ();\n     //~^ Error: mismatched types\n     //~| expected struct `Example`\n-    let e: Example2::<u32, 13> = ();\n+    let e: Example2<u32, 13> = ();\n     //~^ Error: mismatched types\n     //~| expected struct `Example2`\n-    let e: Example3::<13, u32> = ();\n+    let e: Example3<13, u32> = ();\n     //~^ Error: mismatched types\n     //~| expected struct `Example3`\n-    let e: Example3::<7> = ();\n+    let e: Example3<7> = ();\n     //~^ Error: mismatched types\n-    //~| expected struct `Example3<7_usize>`\n-    let e: Example4::<7> = ();\n+    //~| expected struct `Example3<7>`\n+    let e: Example4<7> = ();\n     //~^ Error: mismatched types\n-    //~| expected struct `Example4<7_usize>`\n+    //~| expected struct `Example4<7>`\n }"}, {"sha": "52c54aace5f16726356081b592aee88581f5e180", "filename": "src/test/ui/const-generics/defaults/mismatch.stderr", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fmismatch.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,56 +1,56 @@\n error[E0308]: mismatched types\n-  --> $DIR/mismatch.rs:7:28\n+  --> $DIR/mismatch.rs:7:26\n    |\n-LL |     let e: Example::<13> = ();\n-   |            -------------   ^^ expected struct `Example`, found `()`\n+LL |     let e: Example<13> = ();\n+   |            -----------   ^^ expected struct `Example`, found `()`\n    |            |\n    |            expected due to this\n    |\n    = note: expected struct `Example`\n            found unit type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/mismatch.rs:10:34\n+  --> $DIR/mismatch.rs:10:32\n    |\n-LL |     let e: Example2::<u32, 13> = ();\n-   |            -------------------   ^^ expected struct `Example2`, found `()`\n+LL |     let e: Example2<u32, 13> = ();\n+   |            -----------------   ^^ expected struct `Example2`, found `()`\n    |            |\n    |            expected due to this\n    |\n    = note: expected struct `Example2`\n            found unit type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/mismatch.rs:13:34\n+  --> $DIR/mismatch.rs:13:32\n    |\n-LL |     let e: Example3::<13, u32> = ();\n-   |            -------------------   ^^ expected struct `Example3`, found `()`\n+LL |     let e: Example3<13, u32> = ();\n+   |            -----------------   ^^ expected struct `Example3`, found `()`\n    |            |\n    |            expected due to this\n    |\n    = note: expected struct `Example3`\n            found unit type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/mismatch.rs:16:28\n+  --> $DIR/mismatch.rs:16:26\n    |\n-LL |     let e: Example3::<7> = ();\n-   |            -------------   ^^ expected struct `Example3`, found `()`\n+LL |     let e: Example3<7> = ();\n+   |            -----------   ^^ expected struct `Example3`, found `()`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Example3<7_usize>`\n+   = note: expected struct `Example3<7>`\n            found unit type `()`\n \n error[E0308]: mismatched types\n-  --> $DIR/mismatch.rs:19:28\n+  --> $DIR/mismatch.rs:19:26\n    |\n-LL |     let e: Example4::<7> = ();\n-   |            -------------   ^^ expected struct `Example4`, found `()`\n+LL |     let e: Example4<7> = ();\n+   |            -----------   ^^ expected struct `Example4`, found `()`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `Example4<7_usize>`\n+   = note: expected struct `Example4<7>`\n            found unit type `()`\n \n error: aborting due to 5 previous errors"}, {"sha": "80013e7b4b2306e77d81cd3ce709d41407bf05c2", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -4,16 +4,15 @@ trait Trait {}\n impl<const N: u32> Trait for Uwu<N> {}\n \n fn rawr() -> impl Trait {\n-    //~^ error: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n+    //~^ error: the trait bound `Uwu<10, 12>: Trait` is not satisfied\n     Uwu::<10, 12>\n }\n \n-trait Traitor<const N: u8 = 1, const M: u8 = N> { }\n+trait Traitor<const N: u8 = 1, const M: u8 = N> {}\n \n impl<const N: u8> Traitor<N, 2> for u32 {}\n impl Traitor<1, 2> for u64 {}\n \n-\n fn uwu<const N: u8>() -> impl Traitor<N> {\n     //~^ error: the trait bound `u32: Traitor<N>` is not satisfied\n     1_u32"}, {"sha": "f2e7777ce681411bb79372ae32a58eb91276c56c", "filename": "src/test/ui/const-generics/defaults/rp_impl_trait_fail.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Frp_impl_trait_fail.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,16 +1,16 @@\n-error[E0277]: the trait bound `Uwu<10_u32, 12_u32>: Trait` is not satisfied\n+error[E0277]: the trait bound `Uwu<10, 12>: Trait` is not satisfied\n   --> $DIR/rp_impl_trait_fail.rs:6:14\n    |\n LL | fn rawr() -> impl Trait {\n-   |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10_u32, 12_u32>`\n+   |              ^^^^^^^^^^ the trait `Trait` is not implemented for `Uwu<10, 12>`\n LL |\n LL |     Uwu::<10, 12>\n-   |     ------------- return type was inferred to be `Uwu<10_u32, 12_u32>` here\n+   |     ------------- return type was inferred to be `Uwu<10, 12>` here\n    |\n    = help: the trait `Trait` is implemented for `Uwu<N>`\n \n error[E0277]: the trait bound `u32: Traitor<N>` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:17:26\n+  --> $DIR/rp_impl_trait_fail.rs:16:26\n    |\n LL | fn uwu<const N: u8>() -> impl Traitor<N> {\n    |                          ^^^^^^^^^^^^^^^ the trait `Traitor<N>` is not implemented for `u32`\n@@ -19,11 +19,11 @@ LL |     1_u32\n    |     ----- return type was inferred to be `u32` here\n    |\n    = help: the following other types implement trait `Traitor<N, M>`:\n-             <u32 as Traitor<N, 2_u8>>\n-             <u64 as Traitor<1_u8, 2_u8>>\n+             <u32 as Traitor<N, 2>>\n+             <u64 as Traitor<1, 2>>\n \n error[E0277]: the trait bound `u64: Traitor` is not satisfied\n-  --> $DIR/rp_impl_trait_fail.rs:22:13\n+  --> $DIR/rp_impl_trait_fail.rs:21:13\n    |\n LL | fn owo() -> impl Traitor {\n    |             ^^^^^^^^^^^^ the trait `Traitor` is not implemented for `u64`\n@@ -32,8 +32,8 @@ LL |     1_u64\n    |     ----- return type was inferred to be `u64` here\n    |\n    = help: the following other types implement trait `Traitor<N, M>`:\n-             <u32 as Traitor<N, 2_u8>>\n-             <u64 as Traitor<1_u8, 2_u8>>\n+             <u32 as Traitor<N, 2>>\n+             <u64 as Traitor<1, 2>>\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6ab803f99092069443bd545e8b23b60194886c31", "filename": "src/test/ui/const-generics/defaults/trait_objects_fail.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -16,7 +16,7 @@ trait Traitor<const N: u8 = 1, const M: u8 = N> {\n     }\n }\n \n-impl Traitor<2, 3> for bool { }\n+impl Traitor<2, 3> for bool {}\n \n fn bar<const N: u8>(arg: &dyn Traitor<N>) -> u8 {\n     arg.owo()\n@@ -26,5 +26,5 @@ fn main() {\n     foo(&10_u32);\n     //~^ error: the trait bound `u32: Trait` is not satisfied\n     bar(&true);\n-    //~^ error: the trait bound `bool: Traitor<{_: u8}>` is not satisfied\n+    //~^ error: the trait bound `bool: Traitor<_>` is not satisfied\n }"}, {"sha": "a9c185e5fcbd15577036eeaf1bc4068331c9c626", "filename": "src/test/ui/const-generics/defaults/trait_objects_fail.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Ftrait_objects_fail.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -6,19 +6,19 @@ LL |     foo(&10_u32);\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `Trait<2_u8>` is implemented for `u32`\n+   = help: the trait `Trait<2>` is implemented for `u32`\n    = note: required for the cast from `u32` to the object type `dyn Trait`\n \n-error[E0277]: the trait bound `bool: Traitor<{_: u8}>` is not satisfied\n+error[E0277]: the trait bound `bool: Traitor<_>` is not satisfied\n   --> $DIR/trait_objects_fail.rs:28:9\n    |\n LL |     bar(&true);\n-   |     --- ^^^^^ the trait `Traitor<{_: u8}>` is not implemented for `bool`\n+   |     --- ^^^^^ the trait `Traitor<_>` is not implemented for `bool`\n    |     |\n    |     required by a bound introduced by this call\n    |\n-   = help: the trait `Traitor<2_u8, 3_u8>` is implemented for `bool`\n-   = note: required for the cast from `bool` to the object type `dyn Traitor<{_: u8}>`\n+   = help: the trait `Traitor<2, 3>` is implemented for `bool`\n+   = note: required for the cast from `bool` to the object type `dyn Traitor<_>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "a93f670815a03d9515a8559418e10767977f432d", "filename": "src/test/ui/const-generics/defaults/wfness.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -3,16 +3,20 @@ struct Ooopsies<const N: u8 = { u8::MAX + 1 }>;\n \n trait Trait<const N: u8> {}\n impl Trait<3> for () {}\n-struct WhereClause<const N: u8 = 2> where (): Trait<N>;\n-//~^ error: the trait bound `(): Trait<2_u8>` is not satisfied\n+struct WhereClause<const N: u8 = 2>\n+where\n+    (): Trait<N>;\n+//~^ error: the trait bound `(): Trait<2>` is not satisfied\n \n trait Traitor<T, const N: u8> {}\n-struct WhereClauseTooGeneric<T = u32, const N: u8 = 2>(T) where (): Traitor<T, N>;\n+struct WhereClauseTooGeneric<T = u32, const N: u8 = 2>(T)\n+where\n+    (): Traitor<T, N>;\n \n // no error on struct def\n struct DependentDefaultWfness<const N: u8 = 1, T = WhereClause<N>>(T);\n fn foo() -> DependentDefaultWfness {\n-    //~^ error: the trait bound `(): Trait<1_u8>` is not satisfied\n+    //~^ error: the trait bound `(): Trait<1>` is not satisfied\n     loop {}\n }\n "}, {"sha": "25038f830befc4a9538759c79bab486cf4fcacb2", "filename": "src/test/ui/const-generics/defaults/wfness.stderr", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fwfness.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -4,26 +4,29 @@ error[E0080]: evaluation of constant value failed\n LL | struct Ooopsies<const N: u8 = { u8::MAX + 1 }>;\n    |                                 ^^^^^^^^^^^ attempt to compute `u8::MAX + 1_u8`, which would overflow\n \n-error[E0277]: the trait bound `(): Trait<2_u8>` is not satisfied\n-  --> $DIR/wfness.rs:6:47\n+error[E0277]: the trait bound `(): Trait<2>` is not satisfied\n+  --> $DIR/wfness.rs:8:9\n    |\n-LL | struct WhereClause<const N: u8 = 2> where (): Trait<N>;\n-   |                                               ^^^^^^^^ the trait `Trait<2_u8>` is not implemented for `()`\n+LL |     (): Trait<N>;\n+   |         ^^^^^^^^ the trait `Trait<2>` is not implemented for `()`\n    |\n-   = help: the trait `Trait<3_u8>` is implemented for `()`\n+   = help: the trait `Trait<3>` is implemented for `()`\n \n-error[E0277]: the trait bound `(): Trait<1_u8>` is not satisfied\n-  --> $DIR/wfness.rs:14:13\n+error[E0277]: the trait bound `(): Trait<1>` is not satisfied\n+  --> $DIR/wfness.rs:18:13\n    |\n LL | fn foo() -> DependentDefaultWfness {\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<1_u8>` is not implemented for `()`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ the trait `Trait<1>` is not implemented for `()`\n    |\n-   = help: the trait `Trait<3_u8>` is implemented for `()`\n+   = help: the trait `Trait<3>` is implemented for `()`\n note: required by a bound in `WhereClause`\n-  --> $DIR/wfness.rs:6:47\n+  --> $DIR/wfness.rs:8:9\n    |\n-LL | struct WhereClause<const N: u8 = 2> where (): Trait<N>;\n-   |                                               ^^^^^^^^ required by this bound in `WhereClause`\n+LL | struct WhereClause<const N: u8 = 2>\n+   |        ----------- required by a bound in this\n+LL | where\n+LL |     (): Trait<N>;\n+   |         ^^^^^^^^ required by this bound in `WhereClause`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "eba1768f7dda34e466fbe20582222c4dec12e93c", "filename": "src/test/ui/const-generics/different_generic_args.full.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.full.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/different_generic_args.rs:11:9\n    |\n LL |     u = ConstUsize::<4> {};\n-   |         ^^^^^^^^^^^^^^^^^^ expected `3_usize`, found `4_usize`\n+   |         ^^^^^^^^^^^^^^^^^^ expected `3`, found `4`\n    |\n-   = note: expected struct `ConstUsize<3_usize>`\n-              found struct `ConstUsize<4_usize>`\n+   = note: expected struct `ConstUsize<3>`\n+              found struct `ConstUsize<4>`\n \n error: aborting due to previous error\n "}, {"sha": "eba1768f7dda34e466fbe20582222c4dec12e93c", "filename": "src/test/ui/const-generics/different_generic_args.min.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args.min.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/different_generic_args.rs:11:9\n    |\n LL |     u = ConstUsize::<4> {};\n-   |         ^^^^^^^^^^^^^^^^^^ expected `3_usize`, found `4_usize`\n+   |         ^^^^^^^^^^^^^^^^^^ expected `3`, found `4`\n    |\n-   = note: expected struct `ConstUsize<3_usize>`\n-              found struct `ConstUsize<4_usize>`\n+   = note: expected struct `ConstUsize<3>`\n+              found struct `ConstUsize<4>`\n \n error: aborting due to previous error\n "}, {"sha": "4c5b5ada4f13286839ba067e69acce63bf8ccba2", "filename": "src/test/ui/const-generics/different_generic_args_array.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdifferent_generic_args_array.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/different_generic_args_array.rs:9:9\n    |\n LL |     x = Const::<{ [4] }> {};\n-   |         ^^^^^^^^^^^^^^^^^^^ expected `[3_usize]`, found `[4_usize]`\n+   |         ^^^^^^^^^^^^^^^^^^^ expected `[3]`, found `[4]`\n    |\n-   = note: expected struct `Const<[3_usize]>`\n-              found struct `Const<[4_usize]>`\n+   = note: expected struct `Const<[3]>`\n+              found struct `Const<[4]>`\n \n error: aborting due to previous error\n "}, {"sha": "76a83ba67ce79d00c1e2916b376168fcf3be3d0b", "filename": "src/test/ui/const-generics/exhaustive-value.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fexhaustive-value.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -5,14 +5,14 @@ LL |     <() as Foo<N>>::test()\n    |     ^^^^^^^^^^^^^^^^^^^^ the trait `Foo<N>` is not implemented for `()`\n    |\n    = help: the following other types implement trait `Foo<N>`:\n-             <() as Foo<0_u8>>\n-             <() as Foo<100_u8>>\n-             <() as Foo<101_u8>>\n-             <() as Foo<102_u8>>\n-             <() as Foo<103_u8>>\n-             <() as Foo<104_u8>>\n-             <() as Foo<105_u8>>\n-             <() as Foo<106_u8>>\n+             <() as Foo<0>>\n+             <() as Foo<100>>\n+             <() as Foo<101>>\n+             <() as Foo<102>>\n+             <() as Foo<103>>\n+             <() as Foo<104>>\n+             <() as Foo<105>>\n+             <() as Foo<106>>\n            and 248 others\n \n error: aborting due to previous error"}, {"sha": "52d1b29f93222a7704493ad480038ea6ba372630", "filename": "src/test/ui/const-generics/generic_arg_infer/in-signature.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_arg_infer%2Fin-signature.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -14,7 +14,7 @@ LL | fn ty_fn() -> Bar<i32, _> {\n    |               ---------^-\n    |               |        |\n    |               |        not allowed in type signatures\n-   |               help: replace with the correct return type: `Bar<i32, 3_usize>`\n+   |               help: replace with the correct return type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for return types\n   --> $DIR/in-signature.rs:17:25\n@@ -24,7 +24,7 @@ LL | fn ty_fn_mixed() -> Bar<_, _> {\n    |                     |   |  |\n    |                     |   |  not allowed in type signatures\n    |                     |   not allowed in type signatures\n-   |                     help: replace with the correct return type: `Bar<i32, 3_usize>`\n+   |                     help: replace with the correct return type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/in-signature.rs:22:15\n@@ -45,7 +45,7 @@ LL | const TY_CT: Bar<i32, _> = Bar::<i32, 3>(0);\n    |              ^^^^^^^^^^^\n    |              |\n    |              not allowed in type signatures\n-   |              help: replace with the correct type: `Bar<i32, 3_usize>`\n+   |              help: replace with the correct type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/in-signature.rs:28:19\n@@ -54,7 +54,7 @@ LL | static TY_STATIC: Bar<i32, _> = Bar::<i32, 3>(0);\n    |                   ^^^^^^^^^^^\n    |                   |\n    |                   not allowed in type signatures\n-   |                   help: replace with the correct type: `Bar<i32, 3_usize>`\n+   |                   help: replace with the correct type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/in-signature.rs:30:20\n@@ -63,7 +63,7 @@ LL | const TY_CT_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n    |                    ^^^^^^^^^\n    |                    |\n    |                    not allowed in type signatures\n-   |                    help: replace with the correct type: `Bar<i32, 3_usize>`\n+   |                    help: replace with the correct type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for static variables\n   --> $DIR/in-signature.rs:32:25\n@@ -72,7 +72,7 @@ LL | static TY_STATIC_MIXED: Bar<_, _> = Bar::<i32, 3>(0);\n    |                         ^^^^^^^^^\n    |                         |\n    |                         not allowed in type signatures\n-   |                         help: replace with the correct type: `Bar<i32, 3_usize>`\n+   |                         help: replace with the correct type: `Bar<i32, 3>`\n \n error[E0121]: the placeholder `_` is not allowed within types on item signatures for constants\n   --> $DIR/in-signature.rs:35:21"}, {"sha": "ababb27a869d65baa0880778c7059f872a0f87c5", "filename": "src/test/ui/const-generics/generic_const_exprs/abstract-const-as-cast-3.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fabstract-const-as-cast-3.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -56,19 +56,19 @@ error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:23:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<13, { 12 as u128 }>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12_u128`, found `13_u128`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12`, found `13`\n    |\n-   = note: expected type `12_u128`\n-              found type `13_u128`\n+   = note: expected type `12`\n+              found type `13`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:25:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<14, 13>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13_u128`, found `14_u128`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13`, found `14`\n    |\n-   = note: expected type `13_u128`\n-              found type `14_u128`\n+   = note: expected type `13`\n+              found type `14`\n \n error: unconstrained generic constant\n   --> $DIR/abstract-const-as-cast-3.rs:35:5\n@@ -128,19 +128,19 @@ error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:41:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<13, { 12 as u128 }>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12_u128`, found `13_u128`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `12`, found `13`\n    |\n-   = note: expected type `12_u128`\n-              found type `13_u128`\n+   = note: expected type `12`\n+              found type `13`\n \n error[E0308]: mismatched types\n   --> $DIR/abstract-const-as-cast-3.rs:43:5\n    |\n LL |     assert_impl::<HasCastInTraitImpl<14, 13>>();\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13_u128`, found `14_u128`\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `13`, found `14`\n    |\n-   = note: expected type `13_u128`\n-              found type `14_u128`\n+   = note: expected type `13`\n+              found type `14`\n \n error: aborting due to 12 previous errors\n "}, {"sha": "b8f9827ec918730218710b046be68918eb2c08b1", "filename": "src/test/ui/const-generics/generic_const_exprs/from-sig-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,7 +2,7 @@\n #![allow(incomplete_features)]\n \n fn test<const N: usize>() -> [u8; N - 1] {\n-    //~^ ERROR evaluation of `test::<0_usize>::{constant#0}` failed\n+    //~^ ERROR evaluation of `test::<0>::{constant#0}` failed\n     todo!()\n }\n "}, {"sha": "bd71b49ee238bf01e1bf0519e5f45310a6a445a0", "filename": "src/test/ui/const-generics/generic_const_exprs/from-sig-fail.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ffrom-sig-fail.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,4 +1,4 @@\n-error[E0080]: evaluation of `test::<0_usize>::{constant#0}` failed\n+error[E0080]: evaluation of `test::<0>::{constant#0}` failed\n   --> $DIR/from-sig-fail.rs:4:35\n    |\n LL | fn test<const N: usize>() -> [u8; N - 1] {"}, {"sha": "7a083733a2cd18a98a175dd80c98e6dc6563f70a", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-69654.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-69654.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-69654.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-69654.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -4,14 +4,14 @@ error[E0423]: expected value, found type parameter `T`\n LL | impl<T> Bar<T> for [u8; T] {}\n    |                         ^ not a value\n \n-error[E0599]: the function or associated item `foo` exists for struct `Foo<{_: usize}>`, but its trait bounds were not satisfied\n+error[E0599]: the function or associated item `foo` exists for struct `Foo<_>`, but its trait bounds were not satisfied\n   --> $DIR/issue-69654.rs:17:10\n    |\n LL | struct Foo<const N: usize> {}\n    | -------------------------- function or associated item `foo` not found for this struct\n ...\n LL |     Foo::foo();\n-   |          ^^^ function or associated item cannot be called on `Foo<{_: usize}>` due to unsatisfied trait bounds\n+   |          ^^^ function or associated item cannot be called on `Foo<_>` due to unsatisfied trait bounds\n    |\n    = note: the following trait bounds were not satisfied:\n            `[u8; _]: Bar<[(); _]>`"}, {"sha": "4d0d0253f1b6d4a08206836089a6ee89fda0f6f6", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-72787.min.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-72787.min.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -34,21 +34,21 @@ LL |     IsLessOrEqual<{ 8 - I }, { 8 - J }>: True,\n    = help: const parameters may only be used as standalone arguments, i.e. `J`\n    = help: use `#![feature(generic_const_exprs)]` to allow generic const expressions\n \n-error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8_u32>: True`\n+error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8>: True`\n   --> $DIR/issue-72787.rs:21:26\n    |\n LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n-   = note: cannot satisfy `IsLessOrEqual<I, 8_u32>: True`\n+   = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n \n-error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8_u32>: True`\n+error[E0283]: type annotations needed: cannot satisfy `IsLessOrEqual<I, 8>: True`\n   --> $DIR/issue-72787.rs:21:26\n    |\n LL |     IsLessOrEqual<I, 8>: True,\n    |                          ^^^^\n    |\n-   = note: cannot satisfy `IsLessOrEqual<I, 8_u32>: True`\n+   = note: cannot satisfy `IsLessOrEqual<I, 8>: True`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "cae54df4c121099577cc8d119cd88c38eb67ff22", "filename": "src/test/ui/const-generics/generic_const_exprs/simple_fail.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,13 @@\n #![allow(incomplete_features)]\n \n type Arr<const N: usize> = [u8; N - 1];\n-//~^ ERROR evaluation of `Arr::<0_usize>::{constant#0}` failed\n+//~^ ERROR evaluation of `Arr::<0>::{constant#0}` failed\n \n-fn test<const N: usize>() -> Arr<N> where [u8; N - 1]: Sized {\n-//~^ ERROR evaluation of `test::<0_usize>::{constant#0}` failed\n+fn test<const N: usize>() -> Arr<N>\n+where\n+    [u8; N - 1]: Sized,\n+    //~^ ERROR evaluation of `test::<0>::{constant#0}` failed\n+{\n     todo!()\n }\n "}, {"sha": "a25fa56b7d49813399c1746b4091f7de07cec513", "filename": "src/test/ui/const-generics/generic_const_exprs/simple_fail.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fsimple_fail.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,10 +1,10 @@\n-error[E0080]: evaluation of `test::<0_usize>::{constant#0}` failed\n-  --> $DIR/simple_fail.rs:7:48\n+error[E0080]: evaluation of `test::<0>::{constant#0}` failed\n+  --> $DIR/simple_fail.rs:9:10\n    |\n-LL | fn test<const N: usize>() -> Arr<N> where [u8; N - 1]: Sized {\n-   |                                                ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n+LL |     [u8; N - 1]: Sized,\n+   |          ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n \n-error[E0080]: evaluation of `Arr::<0_usize>::{constant#0}` failed\n+error[E0080]: evaluation of `Arr::<0>::{constant#0}` failed\n   --> $DIR/simple_fail.rs:4:33\n    |\n LL | type Arr<const N: usize> = [u8; N - 1];"}, {"sha": "cf70c2181395025a56e5d91ed0ec6d8ba632c01c", "filename": "src/test/ui/const-generics/infer/one-param-uninferred.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Finfer%2Fone-param-uninferred.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -6,8 +6,8 @@ LL |     let _: [u8; 17] = foo();\n    |\n help: consider specifying the generic arguments\n    |\n-LL |     let _: [u8; 17] = foo::<17_usize, M>();\n-   |                          +++++++++++++++\n+LL |     let _: [u8; 17] = foo::<17, M>();\n+   |                          +++++++++\n \n error: aborting due to previous error\n "}, {"sha": "e0cb0b661ff6549b9e2513c3383080eb50d61c0e", "filename": "src/test/ui/const-generics/issue-66451.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66451.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66451.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-66451.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -8,12 +8,12 @@ LL | |             value: 3,\n LL | |             nested: &Bar(5),\n LL | |         }\n LL | |     }> = x;\n-   | |      -   ^ expected `Foo { value: 3_i32, nested: &Bar::<i32>(5_i32) }`, found `Foo { value: 3_i32, nested: &Bar::<i32>(4_i32) }`\n+   | |      -   ^ expected `Foo { value: 3, nested: &Bar::<i32>(5) }`, found `Foo { value: 3, nested: &Bar::<i32>(4) }`\n    | |______|\n    |        expected due to this\n    |\n-   = note: expected struct `Test<Foo { value: 3_i32, nested: &Bar::<i32>(5_i32) }>`\n-              found struct `Test<Foo { value: 3_i32, nested: &Bar::<i32>(4_i32) }>`\n+   = note: expected struct `Test<Foo { value: 3, nested: &Bar::<i32>(5) }>`\n+              found struct `Test<Foo { value: 3, nested: &Bar::<i32>(4) }>`\n \n error: aborting due to previous error\n "}, {"sha": "6d9f4406504ee7b2e98d603bf06b6cc0ca1427a9", "filename": "src/test/ui/const-generics/nested-type.full.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,4 +1,4 @@\n-error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17>::value` in constants\n   --> $DIR/nested-type.rs:15:5\n    |\n LL |     Foo::<17>::value()"}, {"sha": "a3c011d927b5a4659b7e57fe77569ceea1d0c6d8", "filename": "src/test/ui/const-generics/occurs-check/unused-substs-1.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Foccurs-check%2Funused-substs-1.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,10 +1,10 @@\n-error[E0277]: the trait bound `A<{_: usize}>: Bar<{_: usize}>` is not satisfied\n+error[E0277]: the trait bound `A<_>: Bar<_>` is not satisfied\n   --> $DIR/unused-substs-1.rs:12:13\n    |\n LL |     let _ = A;\n-   |             ^ the trait `Bar<{_: usize}>` is not implemented for `A<{_: usize}>`\n+   |             ^ the trait `Bar<_>` is not implemented for `A<_>`\n    |\n-   = help: the trait `Bar<N>` is implemented for `A<7_usize>`\n+   = help: the trait `Bar<N>` is implemented for `A<7>`\n note: required by a bound in `A`\n   --> $DIR/unused-substs-1.rs:9:11\n    |"}, {"sha": "486506239ddfdd24076cdd5e6e3cfb516f4c4b28", "filename": "src/test/ui/const-generics/types-mismatch-const-args.full.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.full.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,10 +2,10 @@ error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:14:41\n    |\n LL |     let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {2u32 + 2u32}, {3u32}> { data: PhantomData };\n-   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2_u32`, found `4_u32`\n+   |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2`, found `4`\n    |\n-   = note: expected type `2_u32`\n-              found type `4_u32`\n+   = note: expected type `2`\n+              found type `4`\n \n error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:16:41\n@@ -26,8 +26,8 @@ LL |     let _: A<'a, u16, {4u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `A<'a, u16, 4_u32, _>`\n-              found struct `A<'b, u32, 2_u32, _>`\n+   = note: expected struct `A<'a, u16, 4, _>`\n+              found struct `A<'b, u32, 2, _>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "6ac93a08d5d68af34f939cdc2f202b7c802e75e3", "filename": "src/test/ui/const-generics/types-mismatch-const-args.min.stderr", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Ftypes-mismatch-const-args.min.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,12 +2,12 @@ error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:14:41\n    |\n LL |     let _: A<'a, u32, {2u32}, {3u32}> = A::<'a, u32, {2u32 + 2u32}, {3u32}> { data: PhantomData };\n-   |            --------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2_u32`, found `4_u32`\n+   |            --------------------------   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `2`, found `4`\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `A<'_, _, 2_u32, _>`\n-              found struct `A<'_, _, 4_u32, _>`\n+   = note: expected struct `A<'_, _, 2, _>`\n+              found struct `A<'_, _, 4, _>`\n \n error[E0308]: mismatched types\n   --> $DIR/types-mismatch-const-args.rs:16:41\n@@ -28,8 +28,8 @@ LL |     let _: A<'a, u16, {4u32}, {3u32}> = A::<'b, u32, {2u32}, {3u32}> { data\n    |            |\n    |            expected due to this\n    |\n-   = note: expected struct `A<'a, u16, 4_u32, _>`\n-              found struct `A<'b, u32, 2_u32, _>`\n+   = note: expected struct `A<'a, u16, 4, _>`\n+              found struct `A<'b, u32, 2, _>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "3d2c76b7ed0403f20ee1485d15020329539a8b1c", "filename": "src/test/ui/consts/const-eval/issue-85155.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,10 +1,10 @@\n-error[E0080]: evaluation of `post_monomorphization_error::ValidateConstImm::<2_i32, 0_i32, 1_i32>::VALID` failed\n+error[E0080]: evaluation of `post_monomorphization_error::ValidateConstImm::<2, 0, 1>::VALID` failed\n   --> $DIR/auxiliary/post_monomorphization_error.rs:7:17\n    |\n LL |         let _ = 1 / ((IMM >= MIN && IMM <= MAX) as usize);\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to divide `1_usize` by zero\n \n-note: the above error was encountered while instantiating `fn post_monomorphization_error::stdarch_intrinsic::<2_i32>`\n+note: the above error was encountered while instantiating `fn post_monomorphization_error::stdarch_intrinsic::<2>`\n   --> $DIR/issue-85155.rs:19:5\n    |\n LL |     post_monomorphization_error::stdarch_intrinsic::<2>();"}, {"sha": "cb48221c67a8285036afc11c339723b4f949b395", "filename": "src/test/ui/dropck/reject-specialized-drops-8142.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdropck%2Freject-specialized-drops-8142.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -104,7 +104,7 @@ error[E0366]: `Drop` impls cannot be specialized\n LL | impl              Drop for X<3>           { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: `3_usize` is not a generic parameter\n+   = note: `3` is not a generic parameter\n note: use the same sequence of generic lifetime, type and const parameters as the struct definition\n   --> $DIR/reject-specialized-drops-8142.rs:17:1\n    |"}, {"sha": "fc0b6cc4451645a5817cfa94ef3e02b107805c60", "filename": "src/test/ui/inline-const/const-expr-generic-err.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finline-const%2Fconst-expr-generic-err.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -12,13 +12,13 @@ note: the above error was encountered while instantiating `fn foo::<i32>`\n LL |     foo::<i32>();\n    |     ^^^^^^^^^^^^\n \n-error[E0080]: evaluation of `bar::<0_usize>::{constant#0}` failed\n+error[E0080]: evaluation of `bar::<0>::{constant#0}` failed\n   --> $DIR/const-expr-generic-err.rs:9:13\n    |\n LL |     const { N - 1 }\n    |             ^^^^^ attempt to compute `0_usize - 1_usize`, which would overflow\n \n-note: the above error was encountered while instantiating `fn bar::<0_usize>`\n+note: the above error was encountered while instantiating `fn bar::<0>`\n   --> $DIR/const-expr-generic-err.rs:14:5\n    |\n LL |     bar::<0>();"}, {"sha": "a9284535e4dc4221a6c1faf198fc113706f2ec5c", "filename": "src/test/ui/issues/issue-59494.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-59494.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -7,8 +7,6 @@ LL |     let t8 = t8n(t7, t7p(f, g));\n    |              required by a bound introduced by this call\n    |\n    = help: the trait `Fn<(_,)>` is not implemented for `impl Fn(((_, _), _))`\n-   = note: expected a closure with arguments `(((_, _), _),)`\n-              found a closure with arguments `(_,)`\n note: required by a bound in `t8n`\n   --> $DIR/issue-59494.rs:5:45\n    |"}, {"sha": "a9d18bb6a4743a61f00eebd7b49ecd4484f929f7", "filename": "src/test/ui/lint/function-item-references.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Ffunction-item-references.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -116,7 +116,7 @@ warning: taking a reference to a function item does not give a function pointer\n   --> $DIR/function-item-references.rs:118:22\n    |\n LL |     println!(\"{:p}\", &take_generic_array::<u32, 4>);\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: cast `take_generic_array` to obtain a function pointer: `take_generic_array::<u32, 4_usize> as fn(_)`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: cast `take_generic_array` to obtain a function pointer: `take_generic_array::<u32, 4> as fn(_)`\n \n warning: taking a reference to a function item does not give a function pointer\n   --> $DIR/function-item-references.rs:120:22\n@@ -128,7 +128,7 @@ warning: taking a reference to a function item does not give a function pointer\n   --> $DIR/function-item-references.rs:122:22\n    |\n LL |     println!(\"{:p}\", &multiple_generic_arrays::<u32, f32, 4, 8>);\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: cast `multiple_generic_arrays` to obtain a function pointer: `multiple_generic_arrays::<u32, f32, 4_usize, 8_usize> as fn(_, _)`\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: cast `multiple_generic_arrays` to obtain a function pointer: `multiple_generic_arrays::<u32, f32, 4, 8> as fn(_, _)`\n \n warning: taking a reference to a function item does not give a function pointer\n   --> $DIR/function-item-references.rs:124:22"}, {"sha": "799ced5e9c460430be76383825c4489028653300", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -61,13 +61,13 @@ impl Other {\n     fn other(&self) {}\n }\n \n-struct Struct<T>{\n-    _phatom: PhantomData<T>\n+struct Struct<T> {\n+    _phatom: PhantomData<T>,\n }\n \n impl<T> Default for Struct<T> {\n     fn default() -> Self {\n-        Self{ _phatom: PhantomData }\n+        Self { _phatom: PhantomData }\n     }\n }\n \n@@ -76,9 +76,9 @@ impl<T: Clone + Copy + PartialEq + Eq + PartialOrd + Ord> Struct<T> {\n }\n \n fn main() {\n-    let point_f64 = Point{ x: 1_f64, y: 1_f64};\n+    let point_f64 = Point { x: 1_f64, y: 1_f64 };\n     let d = point_f64.distance();\n-    let point_i32 = Point{ x: 1_i32, y: 1_i32};\n+    let point_i32 = Point { x: 1_i32, y: 1_i32 };\n     let d = point_i32.distance();\n     //~^ ERROR no method named `distance` found for struct `Point<i32>\n     let d = point_i32.other();\n@@ -92,9 +92,9 @@ fn main() {\n     wrapper.other();\n     //~^ ERROR no method named `other` found for struct `Wrapper\n     let boolean = true;\n-    let wrapper = Wrapper2::<'_, _, 3> {x: &boolean};\n+    let wrapper = Wrapper2::<'_, _, 3> { x: &boolean };\n     wrapper.method();\n-    //~^ ERROR no method named `method` found for struct `Wrapper2<'_, bool, 3_usize>\n+    //~^ ERROR no method named `method` found for struct `Wrapper2<'_, bool, 3>\n     wrapper.other();\n     //~^ ERROR no method named `other` found for struct `Wrapper2\n     let a = vec![1, 2, 3];"}, {"sha": "fc42d1a4dcd08136374b9ab6203cd4de854dbd23", "filename": "src/test/ui/methods/method-not-found-generic-arg-elision.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmethods%2Fmethod-not-found-generic-arg-elision.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -50,14 +50,14 @@ LL | struct Wrapper<T>(T);\n LL |     wrapper.other();\n    |             ^^^^^ method not found in `Wrapper<bool>`\n \n-error[E0599]: no method named `method` found for struct `Wrapper2<'_, bool, 3_usize>` in the current scope\n+error[E0599]: no method named `method` found for struct `Wrapper2<'_, bool, 3>` in the current scope\n   --> $DIR/method-not-found-generic-arg-elision.rs:96:13\n    |\n LL | struct Wrapper2<'a, T, const C: usize> {\n    | -------------------------------------- method `method` not found for this struct\n ...\n LL |     wrapper.method();\n-   |             ^^^^^^ method not found in `Wrapper2<'_, bool, 3_usize>`\n+   |             ^^^^^^ method not found in `Wrapper2<'_, bool, 3>`\n    |\n    = note: the method was found for\n            - `Wrapper2<'a, i8, C>`\n@@ -71,7 +71,7 @@ LL | struct Wrapper2<'a, T, const C: usize> {\n    | -------------------------------------- method `other` not found for this struct\n ...\n LL |     wrapper.other();\n-   |             ^^^^^ method not found in `Wrapper2<'_, bool, 3_usize>`\n+   |             ^^^^^ method not found in `Wrapper2<'_, bool, 3>`\n \n error[E0599]: no method named `not_found` found for struct `Vec<{integer}>` in the current scope\n   --> $DIR/method-not-found-generic-arg-elision.rs:101:7\n@@ -82,7 +82,7 @@ LL |     a.not_found();\n error[E0599]: the method `method` exists for struct `Struct<f64>`, but its trait bounds were not satisfied\n   --> $DIR/method-not-found-generic-arg-elision.rs:104:7\n    |\n-LL | struct Struct<T>{\n+LL | struct Struct<T> {\n    | ---------------- method `method` not found for this struct\n ...\n LL |     s.method();"}, {"sha": "81e641612ce00b72a10c26c55477e424fa1d0c77", "filename": "src/test/ui/simd/intrinsic/generic-shuffle.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-shuffle.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-shuffle.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Fintrinsic%2Fgeneric-shuffle.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,10 +1,10 @@\n-error[E0511]: invalid monomorphization of `simd_shuffle` intrinsic: expected return type of length 2, found `Simd<u32, 4_usize>` with length 4\n+error[E0511]: invalid monomorphization of `simd_shuffle` intrinsic: expected return type of length 2, found `Simd<u32, 4>` with length 4\n   --> $DIR/generic-shuffle.rs:24:31\n    |\n LL |         let _: Simd<u32, 4> = simd_shuffle(v, v, I);\n    |                               ^^^^^^^^^^^^^^^^^^^^^\n \n-error[E0511]: invalid monomorphization of `simd_shuffle` intrinsic: expected return element type `u32` (element of input `Simd<u32, 4_usize>`), found `Simd<f32, 2_usize>` with element type `f32`\n+error[E0511]: invalid monomorphization of `simd_shuffle` intrinsic: expected return element type `u32` (element of input `Simd<u32, 4>`), found `Simd<f32, 2>` with element type `f32`\n   --> $DIR/generic-shuffle.rs:27:31\n    |\n LL |         let _: Simd<f32, 2> = simd_shuffle(v, v, I);"}, {"sha": "7249914256cd97ec2e6efbfaf9b3e4064e2b3a08", "filename": "src/test/ui/simd/libm_no_std_cant_float.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Flibm_no_std_cant_float.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,37 +2,37 @@ error[E0599]: no method named `ceil` found for struct `Simd` in the current scop\n   --> $DIR/libm_no_std_cant_float.rs:14:17\n    |\n LL |     let _xc = x.ceil();\n-   |                 ^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                 ^^^^ method not found in `Simd<f32, 4>`\n \n error[E0599]: no method named `floor` found for struct `Simd` in the current scope\n   --> $DIR/libm_no_std_cant_float.rs:15:17\n    |\n LL |     let _xf = x.floor();\n-   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                 ^^^^^ method not found in `Simd<f32, 4>`\n \n error[E0599]: no method named `round` found for struct `Simd` in the current scope\n   --> $DIR/libm_no_std_cant_float.rs:16:17\n    |\n LL |     let _xr = x.round();\n-   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                 ^^^^^ method not found in `Simd<f32, 4>`\n \n error[E0599]: no method named `trunc` found for struct `Simd` in the current scope\n   --> $DIR/libm_no_std_cant_float.rs:17:17\n    |\n LL |     let _xt = x.trunc();\n-   |                 ^^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                 ^^^^^ method not found in `Simd<f32, 4>`\n \n error[E0599]: no method named `mul_add` found for struct `Simd` in the current scope\n   --> $DIR/libm_no_std_cant_float.rs:18:19\n    |\n LL |     let _xfma = x.mul_add(x, x);\n-   |                   ^^^^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                   ^^^^^^^ method not found in `Simd<f32, 4>`\n \n error[E0599]: no method named `sqrt` found for struct `Simd` in the current scope\n   --> $DIR/libm_no_std_cant_float.rs:19:20\n    |\n LL |     let _xsqrt = x.sqrt();\n-   |                    ^^^^ method not found in `Simd<f32, 4_usize>`\n+   |                    ^^^^ method not found in `Simd<f32, 4>`\n \n error: aborting due to 6 previous errors\n "}, {"sha": "2bf6641e9c91c0007e908b05568a4cec332c0a79", "filename": "src/test/ui/simd/type-generic-monomorphisation-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(repr_simd, platform_intrinsics)]\n \n-// error-pattern:monomorphising SIMD type `Simd<0_usize>` of zero length\n+// error-pattern:monomorphising SIMD type `Simd<0>` of zero length\n \n #[repr(simd)]\n struct Simd<const N: usize>([f32; N]);"}, {"sha": "b334b1f4b589328f349fcfe480af629d5ef6f08a", "filename": "src/test/ui/simd/type-generic-monomorphisation-empty.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-empty.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,4 +1,4 @@\n-error: monomorphising SIMD type `Simd<0_usize>` of zero length\n+error: monomorphising SIMD type `Simd<0>` of zero length\n \n error: aborting due to previous error\n "}, {"sha": "a7dc482f3cb1d5932e4d99a237d3a1d2c7c82271", "filename": "src/test/ui/simd/type-generic-monomorphisation-oversized.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(repr_simd, platform_intrinsics)]\n \n-// error-pattern:monomorphising SIMD type `Simd<65536_usize>` of length greater than 32768\n+// error-pattern:monomorphising SIMD type `Simd<65536>` of length greater than 32768\n \n #[repr(simd)]\n struct Simd<const N: usize>([f32; N]);"}, {"sha": "a2dba1222eecd4e3772b1f39ee6981299b1f419d", "filename": "src/test/ui/simd/type-generic-monomorphisation-oversized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsimd%2Ftype-generic-monomorphisation-oversized.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,4 +1,4 @@\n-error: monomorphising SIMD type `Simd<65536_usize>` of length greater than 32768\n+error: monomorphising SIMD type `Simd<65536>` of length greater than 32768\n \n error: aborting due to previous error\n "}, {"sha": "4fabc411abcbe8c8b4e16935d4853079194a6018", "filename": "src/test/ui/suggestions/return-bindings.fixed", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/aa0189170057a6b56f445f05b9840caf6f260212/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.fixed?ref=aa0189170057a6b56f445f05b9840caf6f260212", "patch": "@@ -1,23 +0,0 @@\n-// run-rustfix\n-\n-#![allow(unused)]\n-\n-fn a(i: i32) -> i32 { i }\n-//~^ ERROR mismatched types\n-\n-fn b(opt_str: Option<String>) {\n-    let s: String = if let Some(s) = opt_str {\n-        s\n-    //~^ ERROR mismatched types\n-    } else {\n-        String::new()\n-    };\n-}\n-\n-fn c() -> Option<i32> {\n-    //~^ ERROR mismatched types\n-    let x = Some(1);\n-    x\n-}\n-\n-fn main() {}"}, {"sha": "fa1bad37699f36fcba63fc02407d3c7af87fd00a", "filename": "src/test/ui/suggestions/return-bindings.rs", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.rs?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,5 +1,3 @@\n-// run-rustfix\n-\n #![allow(unused)]\n \n fn a(i: i32) -> i32 {}\n@@ -18,4 +16,36 @@ fn c() -> Option<i32> {\n     let x = Some(1);\n }\n \n+fn d(opt_str: Option<String>) {\n+    let s: String = if let Some(s) = opt_str {\n+        //~^ ERROR mismatched types\n+    } else {\n+        String::new()\n+    };\n+}\n+\n+fn d2(opt_str: Option<String>) {\n+    let s = if let Some(s) = opt_str {\n+    } else {\n+        String::new()\n+        //~^ ERROR `if` and `else` have incompatible types\n+    };\n+}\n+\n+fn e(opt_str: Option<String>) {\n+    let s: String = match opt_str {\n+        Some(s) => {}\n+        //~^ ERROR mismatched types\n+        None => String::new(),\n+    };\n+}\n+\n+fn e2(opt_str: Option<String>) {\n+    let s = match opt_str {\n+        Some(s) => {}\n+        None => String::new(),\n+        //~^ ERROR `match` arms have incompatible types\n+    };\n+}\n+\n fn main() {}"}, {"sha": "c14fb336773d1f79791c5ebd88cc0909c5a438dd", "filename": "src/test/ui/suggestions/return-bindings.stderr", "status": "modified", "additions": 66, "deletions": 4, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Freturn-bindings.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -1,5 +1,5 @@\n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:5:17\n+  --> $DIR/return-bindings.rs:3:17\n    |\n LL | fn a(i: i32) -> i32 {}\n    |    -            ^^^ expected `i32`, found `()`\n@@ -12,7 +12,7 @@ LL | fn a(i: i32) -> i32 { i }\n    |                       +\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:9:46\n+  --> $DIR/return-bindings.rs:7:46\n    |\n LL |       let s: String = if let Some(s) = opt_str {\n    |  ______________________________________________^\n@@ -28,7 +28,7 @@ LL ~\n    |\n \n error[E0308]: mismatched types\n-  --> $DIR/return-bindings.rs:16:11\n+  --> $DIR/return-bindings.rs:14:11\n    |\n LL | fn c() -> Option<i32> {\n    |    -      ^^^^^^^^^^^ expected enum `Option`, found `()`\n@@ -43,6 +43,68 @@ LL ~     let x = Some(1);\n LL +     x\n    |\n \n-error: aborting due to 3 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:20:46\n+   |\n+LL |       let s: String = if let Some(s) = opt_str {\n+   |  ______________________________________________^\n+LL | |\n+LL | |     } else {\n+   | |_____^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s: String = if let Some(s) = opt_str {\n+LL +         s\n+LL ~\n+   |\n+\n+error[E0308]: `if` and `else` have incompatible types\n+  --> $DIR/return-bindings.rs:30:9\n+   |\n+LL |       let s = if let Some(s) = opt_str {\n+   |  ______________________________________-\n+LL | |     } else {\n+   | |_____- expected because of this\n+LL |           String::new()\n+   |           ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL ~     let s = if let Some(s) = opt_str {\n+LL +         s\n+LL ~     } else {\n+   |\n+\n+error[E0308]: mismatched types\n+  --> $DIR/return-bindings.rs:37:20\n+   |\n+LL |         Some(s) => {}\n+   |                    ^^ expected struct `String`, found `()`\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error[E0308]: `match` arms have incompatible types\n+  --> $DIR/return-bindings.rs:46:17\n+   |\n+LL |       let s = match opt_str {\n+   |  _____________-\n+LL | |         Some(s) => {}\n+   | |                    -- this is found to be of type `()`\n+LL | |         None => String::new(),\n+   | |                 ^^^^^^^^^^^^^ expected `()`, found struct `String`\n+LL | |\n+LL | |     };\n+   | |_____- `match` arms have incompatible types\n+   |\n+help: consider returning the local binding `s`\n+   |\n+LL |         Some(s) => { s }\n+   |                      +\n+\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0308`."}, {"sha": "e7565525ad3387396ac5c7f9d2efd85ae366943f", "filename": "src/test/ui/type-alias-impl-trait/generic_nondefining_use.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e7a9c1141698bc4557b9da3d3fce2bf75339427f/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fgeneric_nondefining_use.stderr?ref=e7a9c1141698bc4557b9da3d3fce2bf75339427f", "patch": "@@ -25,7 +25,7 @@ error: non-defining opaque type use in defining scope\n LL |     7u32\n    |     ^^^^\n    |\n-note: used non-generic constant `123_usize` for generic parameter\n+note: used non-generic constant `123` for generic parameter\n   --> $DIR/generic_nondefining_use.rs:11:15\n    |\n LL | type OneConst<const X: usize> = impl Debug;"}]}