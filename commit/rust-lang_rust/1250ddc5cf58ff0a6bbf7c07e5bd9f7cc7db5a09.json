{"sha": "1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyNTBkZGM1Y2Y1OGZmMGE2YmJmN2MwN2U1YmQ5ZjdjYzdkYjVhMDk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-16T13:50:28Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-05-21T15:48:34Z"}, "message": "Rework obligation handling\n\nWe can't do the easy hack that we did before anymore, where we kept\ntrack of whether any inference variables changed since the last time we\nrechecked obligations. Instead, we store the obligations in\ncanonicalized form; that way we can easily check the inference variables\nto see whether they have changed since the goal was canonicalized.", "tree": {"sha": "51c6ed040c2b1ec6b33321501ced866d87701c71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c6ed040c2b1ec6b33321501ced866d87701c71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "html_url": "https://github.com/rust-lang/rust/commit/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3d9cac69057db700c4f6e01b84dc59529ea6dfd", "html_url": "https://github.com/rust-lang/rust/commit/a3d9cac69057db700c4f6e01b84dc59529ea6dfd"}], "stats": {"total": 383, "additions": 240, "deletions": 143}, "files": [{"sha": "52d72c3c529b25d3c1077df96c96d9031ffb0ecf", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -1712,15 +1712,17 @@ impl Type {\n         resolver: &Resolver,\n         ty: Ty,\n     ) -> Type {\n-        let environment =\n-            resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n+        let environment = resolver\n+            .generic_def()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         Type { krate, env: environment, ty }\n     }\n \n     fn new(db: &dyn HirDatabase, krate: CrateId, lexical_env: impl HasResolver, ty: Ty) -> Type {\n         let resolver = lexical_env.resolver(db.upcast());\n-        let environment =\n-            resolver.generic_def().map_or_else(Default::default, |d| db.trait_environment(d));\n+        let environment = resolver\n+            .generic_def()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         Type { krate, env: environment, ty }\n     }\n "}, {"sha": "be5b9110ed95fe4335bb1619ff333fd9677037b1", "filename": "crates/hir_ty/src/db.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdb.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -134,14 +134,14 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n     fn trait_solve(\n         &self,\n         krate: CrateId,\n-        goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(crate::traits::trait_solve_query)]\n     fn trait_solve_query(\n         &self,\n         krate: CrateId,\n-        goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+        goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n     ) -> Option<crate::Solution>;\n \n     #[salsa::invoke(chalk_db::program_clauses_for_chalk_env_query)]\n@@ -168,7 +168,7 @@ fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult>\n fn trait_solve_wait(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n-    goal: crate::Canonical<crate::InEnvironment<crate::DomainGoal>>,\n+    goal: crate::Canonical<crate::InEnvironment<crate::Goal>>,\n ) -> Option<crate::Solution> {\n     let _p = profile::span(\"trait_solve::wait\");\n     db.trait_solve_query(krate, goal)"}, {"sha": "97e7c5f8c09a3e8ceb45f396e896da516853ed88", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 15, "deletions": 69, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -14,7 +14,7 @@\n //! the `ena` crate, which is extracted from rustc.\n \n use std::borrow::Cow;\n-use std::mem;\n+\n use std::ops::Index;\n use std::sync::Arc;\n \n@@ -27,22 +27,20 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, Resolver, TypeNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, Lookup, TraitId,\n-    TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n+    TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::{diagnostics::DiagnosticSink, name::name};\n use la_arena::ArenaMap;\n use rustc_hash::FxHashMap;\n use stdx::impl_from;\n use syntax::SmolStr;\n \n-use super::{\n-    DomainGoal, Guidance, InEnvironment, ProjectionTy, Solution, TraitEnvironment, TraitRef, Ty,\n-};\n+use super::{DomainGoal, InEnvironment, ProjectionTy, TraitEnvironment, TraitRef, Ty};\n use crate::{\n     db::HirDatabase, fold_tys, infer::diagnostics::InferenceDiagnostic,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Canonical, Interner,\n-    TyBuilder, TyExt, TyKind,\n+    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Interner, TyBuilder, TyExt,\n+    TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -227,8 +225,6 @@ struct InferenceContext<'a> {\n     resolver: Resolver,\n     table: unify::InferenceTable<'a>,\n     trait_env: Arc<TraitEnvironment>,\n-    obligations: Vec<DomainGoal>,\n-    last_obligations_check: Option<u32>,\n     result: InferenceResult,\n     /// The return type of the function being inferred, or the closure if we're\n     /// currently within one.\n@@ -260,15 +256,15 @@ fn find_breakable<'c>(\n \n impl<'a> InferenceContext<'a> {\n     fn new(db: &'a dyn HirDatabase, owner: DefWithBodyId, resolver: Resolver) -> Self {\n-        let trait_env =\n-            owner.as_generic_def_id().map_or_else(Default::default, |d| db.trait_environment(d));\n+        let krate = owner.module(db.upcast()).krate();\n+        let trait_env = owner\n+            .as_generic_def_id()\n+            .map_or_else(|| Arc::new(TraitEnvironment::empty(krate)), |d| db.trait_environment(d));\n         InferenceContext {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(db, trait_env.clone()),\n-            obligations: Vec::default(),\n-            last_obligations_check: None,\n-            return_ty: TyKind::Error.intern(&Interner), // set in collect_fn_signature\n             trait_env,\n+            return_ty: TyKind::Error.intern(&Interner), // set in collect_fn_signature\n             db,\n             owner,\n             body: db.body(owner),\n@@ -284,6 +280,7 @@ impl<'a> InferenceContext<'a> {\n \n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n+        self.table.resolve_obligations_as_possible();\n \n         // make sure diverging type variables are marked as such\n         self.table.propagate_diverging_flag();\n@@ -357,44 +354,11 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn resolve_obligations_as_possible(&mut self) {\n-        let _span = profile::span(\"resolve_obligations_as_possible\");\n-\n-        let obligations = mem::replace(&mut self.obligations, Vec::new());\n-        for obligation in obligations {\n-            let in_env = InEnvironment::new(&self.trait_env.env, obligation.clone());\n-            let canonicalized = self.canonicalize(in_env);\n-            let solution =\n-                self.db.trait_solve(self.resolver.krate().unwrap(), canonicalized.value.clone());\n-\n-            match solution {\n-                Some(Solution::Unique(canonical_subst)) => {\n-                    canonicalized.apply_solution(\n-                        self,\n-                        Canonical {\n-                            binders: canonical_subst.binders,\n-                            // FIXME: handle constraints\n-                            value: canonical_subst.value.subst,\n-                        },\n-                    );\n-                }\n-                Some(Solution::Ambig(Guidance::Definite(substs))) => {\n-                    canonicalized.apply_solution(self, substs);\n-                    self.obligations.push(obligation);\n-                }\n-                Some(_) => {\n-                    // FIXME use this when trying to resolve everything at the end\n-                    self.obligations.push(obligation);\n-                }\n-                None => {\n-                    // FIXME obligation cannot be fulfilled => diagnostic\n-                }\n-            };\n-        }\n+        self.table.resolve_obligations_as_possible();\n     }\n \n     fn push_obligation(&mut self, o: DomainGoal) {\n-        self.obligations.push(o);\n-        self.last_obligations_check = None;\n+        self.table.register_obligation(o.cast(&Interner));\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -467,25 +431,7 @@ impl<'a> InferenceContext<'a> {\n     /// call). `make_ty` handles this already, but e.g. for field types we need\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n-        let ty = self.resolve_ty_as_possible(ty);\n-        fold_tys(\n-            ty,\n-            |ty, _| match ty.kind(&Interner) {\n-                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n-                    self.normalize_projection_ty(proj_ty.clone())\n-                }\n-                _ => ty,\n-            },\n-            DebruijnIndex::INNERMOST,\n-        )\n-    }\n-\n-    fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n-        let var = self.table.new_type_var();\n-        let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n-        let obligation = alias_eq.cast(&Interner);\n-        self.push_obligation(obligation);\n-        var\n+        self.table.normalize_associated_types_in(ty)\n     }\n \n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {"}, {"sha": "911343cb9544cc4824f4e62cb5e10df52fc71326", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -402,12 +402,15 @@ impl<'a> InferenceContext<'a> {\n         // solve `CoerceUnsized` and `Unsize` goals at this point and leaves the\n         // rest for later. Also, there's some logic about sized type variables.\n         // Need to find out in what cases this is necessary\n-        let solution = self.db.trait_solve(krate, canonicalized.value.clone()).ok_or(TypeError)?;\n+        let solution = self\n+            .db\n+            .trait_solve(krate, canonicalized.value.clone().cast(&Interner))\n+            .ok_or(TypeError)?;\n \n         match solution {\n             Solution::Unique(v) => {\n                 canonicalized.apply_solution(\n-                    self,\n+                    &mut self.table,\n                     Canonical {\n                         binders: v.binders,\n                         // FIXME handle constraints"}, {"sha": "6eaccd9b45e793db6e6c5ff0356a0e3a80bb6583", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -99,9 +99,9 @@ impl<'a> InferenceContext<'a> {\n             environment: trait_env,\n         };\n         let canonical = self.canonicalize(obligation.clone());\n-        if self.db.trait_solve(krate, canonical.value).is_some() {\n+        if self.db.trait_solve(krate, canonical.value.cast(&Interner)).is_some() {\n             self.push_obligation(obligation.goal);\n-            let return_ty = self.normalize_projection_ty(projection);\n+            let return_ty = self.table.normalize_projection_ty(projection);\n             Some((arg_tys, return_ty))\n         } else {\n             None\n@@ -306,7 +306,7 @@ impl<'a> InferenceContext<'a> {\n                     self.resolver.krate(),\n                     InEnvironment {\n                         goal: canonicalized.value.clone(),\n-                        environment: self.trait_env.env.clone(),\n+                        environment: self.table.trait_env.env.clone(),\n                     },\n                 );\n                 let (param_tys, ret_ty): (Vec<Ty>, Ty) = derefs"}, {"sha": "fd366e1211a7099391927fcd1ff84e5679ddb0db", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -225,7 +225,7 @@ impl<'a> InferenceContext<'a> {\n         method_resolution::iterate_method_candidates(\n             &canonical_ty.value,\n             self.db,\n-            self.trait_env.clone(),\n+            self.table.trait_env.clone(),\n             krate,\n             &traits_in_scope,\n             None,"}, {"sha": "75e04e8b50f427790aced8e8cb9de5679757c3ee", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 148, "deletions": 25, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -1,6 +1,6 @@\n //! Unification and canonicalization logic.\n \n-use std::{borrow::Cow, fmt, sync::Arc};\n+use std::{borrow::Cow, fmt, mem, sync::Arc};\n \n use chalk_ir::{\n     cast::Cast, fold::Fold, interner::HasInterner, zip::Zip, FloatTy, IntTy, TyVariableKind,\n@@ -11,8 +11,9 @@ use ena::unify::UnifyKey;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, BoundVar, Canonical, DebruijnIndex, GenericArg,\n-    InferenceVar, Interner, Scalar, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, static_lifetime, AliasEq, AliasTy, BoundVar, Canonical,\n+    DebruijnIndex, GenericArg, Goal, Guidance, InEnvironment, InferenceVar, Interner, ProjectionTy,\n+    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -23,17 +24,11 @@ impl<'a> InferenceContext<'a> {\n     where\n         T::Result: HasInterner<Interner = Interner>,\n     {\n-        let result = self.table.var_unification_table.canonicalize(&Interner, t);\n-        let free_vars = result\n-            .free_vars\n-            .into_iter()\n-            .map(|free_var| free_var.to_generic_arg(&Interner))\n-            .collect();\n-        Canonicalized { value: result.quantified, free_vars }\n+        self.table.canonicalize(t)\n     }\n }\n \n-#[derive(Debug)]\n+#[derive(Debug, Clone)]\n pub(super) struct Canonicalized<T>\n where\n     T: HasInterner<Interner = Interner>,\n@@ -49,22 +44,16 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n \n     pub(super) fn apply_solution(\n         &self,\n-        ctx: &mut InferenceContext<'_>,\n+        ctx: &mut InferenceTable,\n         solution: Canonical<Substitution>,\n     ) {\n         // the solution may contain new variables, which we need to convert to new inference vars\n         let new_vars = Substitution::from_iter(\n             &Interner,\n             solution.binders.iter(&Interner).map(|k| match k.kind {\n-                VariableKind::Ty(TyVariableKind::General) => {\n-                    ctx.table.new_type_var().cast(&Interner)\n-                }\n-                VariableKind::Ty(TyVariableKind::Integer) => {\n-                    ctx.table.new_integer_var().cast(&Interner)\n-                }\n-                VariableKind::Ty(TyVariableKind::Float) => {\n-                    ctx.table.new_float_var().cast(&Interner)\n-                }\n+                VariableKind::Ty(TyVariableKind::General) => ctx.new_type_var().cast(&Interner),\n+                VariableKind::Ty(TyVariableKind::Integer) => ctx.new_integer_var().cast(&Interner),\n+                VariableKind::Ty(TyVariableKind::Float) => ctx.new_float_var().cast(&Interner),\n                 // Chalk can sometimes return new lifetime variables. We just use the static lifetime everywhere\n                 VariableKind::Lifetime => static_lifetime().cast(&Interner),\n                 _ => panic!(\"const variable in solution\"),\n@@ -76,9 +65,9 @@ impl<T: HasInterner<Interner = Interner>> Canonicalized<T> {\n                 // eagerly replace projections in the type; we may be getting types\n                 // e.g. from where clauses where this hasn't happened yet\n                 let ty = ctx.normalize_associated_types_in(new_vars.apply(ty.clone(), &Interner));\n-                ctx.table.unify(var.assert_ty_ref(&Interner), &ty);\n+                ctx.unify(var.assert_ty_ref(&Interner), &ty);\n             } else {\n-                let _ = ctx.table.unify_inner(&var, &new_vars.apply(v.clone(), &Interner));\n+                let _ = ctx.unify_inner(&var, &new_vars.apply(v.clone(), &Interner));\n             }\n         }\n     }\n@@ -167,10 +156,11 @@ type ChalkInferenceTable = chalk_solve::infer::InferenceTable<Interner>;\n \n #[derive(Clone)]\n pub(crate) struct InferenceTable<'a> {\n-    db: &'a dyn HirDatabase,\n-    trait_env: Arc<TraitEnvironment>,\n+    pub db: &'a dyn HirDatabase,\n+    pub trait_env: Arc<TraitEnvironment>,\n     pub(super) var_unification_table: ChalkInferenceTable,\n     pub(super) type_variable_table: TypeVariableTable,\n+    pending_obligations: Vec<Canonicalized<InEnvironment<Goal>>>,\n }\n \n impl<'a> InferenceTable<'a> {\n@@ -180,6 +170,7 @@ impl<'a> InferenceTable<'a> {\n             trait_env,\n             var_unification_table: ChalkInferenceTable::new(),\n             type_variable_table: TypeVariableTable { inner: Vec::new() },\n+            pending_obligations: Vec::new(),\n         }\n     }\n \n@@ -202,6 +193,50 @@ impl<'a> InferenceTable<'a> {\n         }\n     }\n \n+    pub(super) fn canonicalize<T: Fold<Interner> + HasInterner<Interner = Interner>>(\n+        &mut self,\n+        t: T,\n+    ) -> Canonicalized<T::Result>\n+    where\n+        T::Result: HasInterner<Interner = Interner>,\n+    {\n+        let result = self.var_unification_table.canonicalize(&Interner, t);\n+        let free_vars = result\n+            .free_vars\n+            .into_iter()\n+            .map(|free_var| free_var.to_generic_arg(&Interner))\n+            .collect();\n+        Canonicalized { value: result.quantified, free_vars }\n+    }\n+\n+    /// Recurses through the given type, normalizing associated types mentioned\n+    /// in it by replacing them by type variables and registering obligations to\n+    /// resolve later. This should be done once for every type we get from some\n+    /// type annotation (e.g. from a let type annotation, field type or function\n+    /// call). `make_ty` handles this already, but e.g. for field types we need\n+    /// to do it as well.\n+    pub(super) fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n+        let ty = self.resolve_ty_as_possible(ty);\n+        fold_tys(\n+            ty,\n+            |ty, _| match ty.kind(&Interner) {\n+                TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n+                    self.normalize_projection_ty(proj_ty.clone())\n+                }\n+                _ => ty,\n+            },\n+            DebruijnIndex::INNERMOST,\n+        )\n+    }\n+\n+    pub(super) fn normalize_projection_ty(&mut self, proj_ty: ProjectionTy) -> Ty {\n+        let var = self.new_type_var();\n+        let alias_eq = AliasEq { alias: AliasTy::Projection(proj_ty), ty: var.clone() };\n+        let obligation = alias_eq.cast(&Interner);\n+        self.register_obligation(obligation);\n+        var\n+    }\n+\n     fn new_var(&mut self, kind: TyVariableKind, diverging: bool) -> Ty {\n         let var = self.var_unification_table.new_variable(UniverseIndex::ROOT);\n         // Chalk might have created some type variables for its own purposes that we don't know about...\n@@ -341,6 +376,94 @@ impl<'a> InferenceTable<'a> {\n             DebruijnIndex::INNERMOST,\n         )\n     }\n+\n+    pub fn register_obligation(&mut self, goal: Goal) {\n+        let in_env = InEnvironment::new(&self.trait_env.env, goal);\n+        self.register_obligation_in_env(in_env)\n+    }\n+\n+    fn register_obligation_in_env(&mut self, goal: InEnvironment<Goal>) {\n+        let canonicalized = self.canonicalize(goal);\n+        if !self.try_resolve_obligation(&canonicalized) {\n+            self.pending_obligations.push(canonicalized);\n+        }\n+    }\n+\n+    pub fn resolve_obligations_as_possible(&mut self) {\n+        let _span = profile::span(\"resolve_obligations_as_possible\");\n+        let mut changed = true;\n+        let mut obligations = Vec::new();\n+        while changed {\n+            changed = false;\n+            mem::swap(&mut self.pending_obligations, &mut obligations);\n+            for canonicalized in obligations.drain(..) {\n+                if !self.check_changed(&canonicalized) {\n+                    self.pending_obligations.push(canonicalized);\n+                    continue;\n+                }\n+                changed = true;\n+                let uncanonical = chalk_ir::Substitute::apply(\n+                    &canonicalized.free_vars,\n+                    canonicalized.value.value,\n+                    &Interner,\n+                );\n+                self.register_obligation_in_env(uncanonical);\n+            }\n+        }\n+    }\n+\n+    /// This checks whether any of the free variables in the `canonicalized`\n+    /// have changed (either been unified with another variable, or with a\n+    /// value). If this is not the case, we don't need to try to solve the goal\n+    /// again -- it'll give the same result as last time.\n+    fn check_changed(&mut self, canonicalized: &Canonicalized<InEnvironment<Goal>>) -> bool {\n+        canonicalized.free_vars.iter().any(|var| {\n+            let iv = match var.data(&Interner) {\n+                chalk_ir::GenericArgData::Ty(ty) => ty.inference_var(&Interner),\n+                chalk_ir::GenericArgData::Lifetime(lt) => lt.inference_var(&Interner),\n+                chalk_ir::GenericArgData::Const(c) => c.inference_var(&Interner),\n+            }\n+            .expect(\"free var is not inference var\");\n+            if self.var_unification_table.probe_var(iv).is_some() {\n+                return true;\n+            }\n+            let root = self.var_unification_table.inference_var_root(iv);\n+            iv != root\n+        })\n+    }\n+\n+    fn try_resolve_obligation(\n+        &mut self,\n+        canonicalized: &Canonicalized<InEnvironment<Goal>>,\n+    ) -> bool {\n+        let solution = self.db.trait_solve(self.trait_env.krate, canonicalized.value.clone());\n+\n+        match solution {\n+            Some(Solution::Unique(canonical_subst)) => {\n+                canonicalized.apply_solution(\n+                    self,\n+                    Canonical {\n+                        binders: canonical_subst.binders,\n+                        // FIXME: handle constraints\n+                        value: canonical_subst.value.subst,\n+                    },\n+                );\n+                true\n+            }\n+            Some(Solution::Ambig(Guidance::Definite(substs))) => {\n+                canonicalized.apply_solution(self, substs);\n+                false\n+            }\n+            Some(_) => {\n+                // FIXME use this when trying to resolve everything at the end\n+                false\n+            }\n+            None => {\n+                // FIXME obligation cannot be fulfilled => diagnostic\n+                true\n+            }\n+        }\n+    }\n }\n \n impl<'a> fmt::Debug for InferenceTable<'a> {"}, {"sha": "72093d75a2e03528e0fa67eaf0eedb4609e8740f", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -45,7 +45,7 @@ use hir_def::{\n };\n use stdx::always;\n \n-use crate::{db::HirDatabase, display::HirDisplay, utils::generics};\n+use crate::{db::HirDatabase, utils::generics};\n \n pub use autoderef::autoderef;\n pub use builder::TyBuilder;\n@@ -114,6 +114,7 @@ pub type FnSig = chalk_ir::FnSig<Interner>;\n \n pub type InEnvironment<T> = chalk_ir::InEnvironment<T>;\n pub type DomainGoal = chalk_ir::DomainGoal<Interner>;\n+pub type Goal = chalk_ir::Goal<Interner>;\n pub type AliasEq = chalk_ir::AliasEq<Interner>;\n pub type Solution = chalk_solve::Solution<Interner>;\n pub type ConstrainedSubst = chalk_ir::ConstrainedSubst<Interner>;"}, {"sha": "8a375b97348072c4ad6a897ae1186a0930af1d98", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -1035,9 +1035,11 @@ pub(crate) fn trait_environment_query(\n         clauses.push(program_clause.into_from_env_clause(&Interner));\n     }\n \n+    let krate = def.module(db.upcast()).krate();\n+\n     let env = chalk_ir::Environment::new(&Interner).add_clauses(&Interner, clauses);\n \n-    Arc::new(TraitEnvironment { traits_from_clauses: traits_in_scope, env })\n+    Arc::new(TraitEnvironment { krate, traits_from_clauses: traits_in_scope, env })\n }\n \n /// Resolve the where clause(s) of an item with generics."}, {"sha": "08e385a42c8019b187cdb449311c22e699706177", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -577,6 +577,7 @@ fn iterate_method_candidates_by_receiver(\n         if iterate_inherent_methods(\n             self_ty,\n             db,\n+            env.clone(),\n             name,\n             Some(receiver_ty),\n             krate,\n@@ -613,8 +614,16 @@ fn iterate_method_candidates_for_self_ty(\n     name: Option<&Name>,\n     mut callback: &mut dyn FnMut(&Ty, AssocItemId) -> bool,\n ) -> bool {\n-    if iterate_inherent_methods(self_ty, db, name, None, krate, visible_from_module, &mut callback)\n-    {\n+    if iterate_inherent_methods(\n+        self_ty,\n+        db,\n+        env.clone(),\n+        name,\n+        None,\n+        krate,\n+        visible_from_module,\n+        &mut callback,\n+    ) {\n         return true;\n     }\n     iterate_trait_method_candidates(self_ty, db, env, krate, traits_in_scope, name, None, callback)\n@@ -653,12 +662,12 @@ fn iterate_trait_method_candidates(\n         for (_name, item) in data.items.iter() {\n             // Don't pass a `visible_from_module` down to `is_valid_candidate`,\n             // since only inherent methods should be included into visibility checking.\n-            if !is_valid_candidate(db, name, receiver_ty, *item, self_ty, None) {\n+            if !is_valid_candidate(db, env.clone(), name, receiver_ty, *item, self_ty, None) {\n                 continue;\n             }\n             if !known_implemented {\n                 let goal = generic_implements_goal(db, env.clone(), t, self_ty.clone());\n-                if db.trait_solve(krate, goal).is_none() {\n+                if db.trait_solve(krate, goal.cast(&Interner)).is_none() {\n                     continue 'traits;\n                 }\n             }\n@@ -675,6 +684,7 @@ fn iterate_trait_method_candidates(\n fn iterate_inherent_methods(\n     self_ty: &Canonical<Ty>,\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     krate: CrateId,\n@@ -690,14 +700,24 @@ fn iterate_inherent_methods(\n \n         for &impl_def in impls.for_self_ty(&self_ty.value) {\n             for &item in db.impl_data(impl_def).items.iter() {\n-                if !is_valid_candidate(db, name, receiver_ty, item, self_ty, visible_from_module) {\n+                if !is_valid_candidate(\n+                    db,\n+                    env.clone(),\n+                    name,\n+                    receiver_ty,\n+                    item,\n+                    self_ty,\n+                    visible_from_module,\n+                ) {\n                     continue;\n                 }\n                 // we have to check whether the self type unifies with the type\n                 // that the impl is for. If we have a receiver type, this\n                 // already happens in `is_valid_candidate` above; if not, we\n                 // check it here\n-                if receiver_ty.is_none() && inherent_impl_substs(db, impl_def, self_ty).is_none() {\n+                if receiver_ty.is_none()\n+                    && inherent_impl_substs(db, env.clone(), impl_def, self_ty).is_none()\n+                {\n                     cov_mark::hit!(impl_self_type_match_without_receiver);\n                     continue;\n                 }\n@@ -722,7 +742,7 @@ pub fn resolve_indexing_op(\n     let deref_chain = autoderef_method_receiver(db, krate, ty);\n     for ty in deref_chain {\n         let goal = generic_implements_goal(db, env.clone(), index_trait, ty.clone());\n-        if db.trait_solve(krate, goal).is_some() {\n+        if db.trait_solve(krate, goal.cast(&Interner)).is_some() {\n             return Some(ty);\n         }\n     }\n@@ -731,6 +751,7 @@ pub fn resolve_indexing_op(\n \n fn is_valid_candidate(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     name: Option<&Name>,\n     receiver_ty: Option<&Canonical<Ty>>,\n     item: AssocItemId,\n@@ -749,7 +770,7 @@ fn is_valid_candidate(\n                 if !data.has_self_param() {\n                     return false;\n                 }\n-                let transformed_receiver_ty = match transform_receiver_ty(db, m, self_ty) {\n+                let transformed_receiver_ty = match transform_receiver_ty(db, env, m, self_ty) {\n                     Some(ty) => ty,\n                     None => return false,\n                 };\n@@ -776,6 +797,7 @@ fn is_valid_candidate(\n \n pub(crate) fn inherent_impl_substs(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     impl_id: ImplId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Substitution> {\n@@ -798,8 +820,7 @@ pub(crate) fn inherent_impl_substs(\n         binders: CanonicalVarKinds::from_iter(&Interner, kinds),\n         value: (self_ty_with_vars, self_ty.value.clone()),\n     };\n-    let trait_env = Arc::new(TraitEnvironment::default()); // FIXME\n-    let substs = super::infer::unify(db, trait_env, &tys)?;\n+    let substs = super::infer::unify(db, env, &tys)?;\n     // We only want the substs for the vars we added, not the ones from self_ty.\n     // Also, if any of the vars we added are still in there, we replace them by\n     // Unknown. I think this can only really happen if self_ty contained\n@@ -824,6 +845,7 @@ fn fallback_bound_vars(s: Substitution, num_vars_to_keep: usize) -> Substitution\n \n fn transform_receiver_ty(\n     db: &dyn HirDatabase,\n+    env: Arc<TraitEnvironment>,\n     function_id: FunctionId,\n     self_ty: &Canonical<Ty>,\n ) -> Option<Ty> {\n@@ -833,7 +855,7 @@ fn transform_receiver_ty(\n             .fill_with_unknown()\n             .build(),\n         AssocContainerId::ImplId(impl_id) => {\n-            let impl_substs = inherent_impl_substs(db, impl_id, &self_ty)?;\n+            let impl_substs = inherent_impl_substs(db, env, impl_id, &self_ty)?;\n             TyBuilder::subst_for_def(db, function_id)\n                 .use_parent_substs(&impl_substs)\n                 .fill_with_unknown()\n@@ -853,7 +875,7 @@ pub fn implements_trait(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate, goal.cast(&Interner));\n \n     solution.is_some()\n }\n@@ -866,7 +888,7 @@ pub fn implements_trait_unique(\n     trait_: TraitId,\n ) -> bool {\n     let goal = generic_implements_goal(db, env, trait_, ty.clone());\n-    let solution = db.trait_solve(krate, goal);\n+    let solution = db.trait_solve(krate, goal.cast(&Interner));\n \n     matches!(solution, Some(crate::Solution::Unique(_)))\n }"}, {"sha": "294cb531c8b0e85605ece79e8dcc8d727ed0f04e", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=1250ddc5cf58ff0a6bbf7c07e5bd9f7cc7db5a09", "patch": "@@ -2,15 +2,15 @@\n \n use std::env::var;\n \n-use chalk_ir::cast::Cast;\n+use chalk_ir::GoalData;\n use chalk_solve::{logging_db::LoggingRustIrDatabase, Solver};\n \n use base_db::CrateId;\n use hir_def::{lang_item::LangItemTarget, TraitId};\n use stdx::panic_context;\n \n use crate::{\n-    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Guidance, HirDisplay, InEnvironment,\n+    db::HirDatabase, AliasEq, AliasTy, Canonical, DomainGoal, Goal, Guidance, InEnvironment,\n     Interner, Solution, TraitRefExt, Ty, TyKind, WhereClause,\n };\n \n@@ -38,13 +38,22 @@ fn create_chalk_solver() -> chalk_recursive::RecursiveSolver<Interner> {\n /// we assume that `T: Default`.\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct TraitEnvironment {\n+    pub krate: CrateId,\n     // When we're using Chalk's Ty we can make this a BTreeMap since it's Ord,\n     // but for now it's too annoying...\n     pub(crate) traits_from_clauses: Vec<(Ty, TraitId)>,\n     pub env: chalk_ir::Environment<Interner>,\n }\n \n impl TraitEnvironment {\n+    pub fn empty(krate: CrateId) -> Self {\n+        TraitEnvironment {\n+            krate,\n+            traits_from_clauses: Vec::new(),\n+            env: chalk_ir::Environment::new(&Interner),\n+        }\n+    }\n+\n     pub(crate) fn traits_in_scope_from_clauses<'a>(\n         &'a self,\n         ty: &'a Ty,\n@@ -59,46 +68,35 @@ impl TraitEnvironment {\n     }\n }\n \n-impl Default for TraitEnvironment {\n-    fn default() -> Self {\n-        TraitEnvironment {\n-            traits_from_clauses: Vec::new(),\n-            env: chalk_ir::Environment::new(&Interner),\n-        }\n-    }\n-}\n-\n /// Solve a trait goal using Chalk.\n pub(crate) fn trait_solve_query(\n     db: &dyn HirDatabase,\n     krate: CrateId,\n-    goal: Canonical<InEnvironment<DomainGoal>>,\n+    goal: Canonical<InEnvironment<Goal>>,\n ) -> Option<Solution> {\n-    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal {\n-        DomainGoal::Holds(WhereClause::Implemented(it)) => {\n+    let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(&Interner) {\n+        GoalData::DomainGoal(DomainGoal::Holds(WhereClause::Implemented(it))) => {\n             db.trait_data(it.hir_trait_id()).name.to_string()\n         }\n-        DomainGoal::Holds(WhereClause::AliasEq(_)) => \"alias_eq\".to_string(),\n+        GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(_))) => \"alias_eq\".to_string(),\n         _ => \"??\".to_string(),\n     });\n-    log::info!(\"trait_solve_query({})\", goal.value.goal.display(db));\n+    log::info!(\"trait_solve_query({:?})\", goal.value.goal);\n \n-    if let DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n+    if let GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(AliasEq {\n         alias: AliasTy::Projection(projection_ty),\n         ..\n-    })) = &goal.value.goal\n+    }))) = &goal.value.goal.data(&Interner)\n     {\n         if let TyKind::BoundVar(_) = projection_ty.self_type_parameter(&Interner).kind(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }\n     }\n \n-    let canonical = goal.cast(&Interner);\n-\n     // We currently don't deal with universes (I think / hope they're not yet\n     // relevant for our use cases?)\n-    let u_canonical = chalk_ir::UCanonical { canonical, universes: 1 };\n+    let u_canonical = chalk_ir::UCanonical { canonical: goal, universes: 1 };\n     solve(db, krate, &u_canonical)\n }\n "}]}