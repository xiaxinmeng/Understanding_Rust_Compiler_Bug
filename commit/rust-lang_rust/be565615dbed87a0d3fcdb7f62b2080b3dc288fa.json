{"sha": "be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNTY1NjE1ZGJlZDg3YTBkM2ZjZGI3ZjYyYjIwODBiM2RjMjg4ZmE=", "commit": {"author": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-25T07:41:04Z"}, "committer": {"name": "Jethro Beekman", "email": "jethro@fortanix.com", "date": "2018-12-25T07:41:04Z"}, "message": "Add `io` and `arch` modules to `std::os::fortanix_sgx`", "tree": {"sha": "fd49ea1e8e61dc68a7e081caf509021cbdff0c31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fd49ea1e8e61dc68a7e081caf509021cbdff0c31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "html_url": "https://github.com/rust-lang/rust/commit/be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/comments", "author": null, "committer": null, "parents": [{"sha": "505167d7c58f68170118f96436c85e0587e6d3f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/505167d7c58f68170118f96436c85e0587e6d3f5", "html_url": "https://github.com/rust-lang/rust/commit/505167d7c58f68170118f96436c85e0587e6d3f5"}], "stats": {"total": 315, "additions": 305, "deletions": 10}, "files": [{"sha": "0f32602043411a183ed3ce9ec9e2c7688b5264ab", "filename": "src/libstd/os/fortanix_sgx/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos%2Ffortanix_sgx%2Fmod.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -65,3 +65,5 @@ pub mod usercalls {\n pub mod mem {\n     pub use sys::abi::mem::*;\n }\n+\n+pub use sys::ext::{io, arch};"}, {"sha": "377210f5d699cf697543abea7215bf5c1dcd729d", "filename": "src/libstd/sys/sgx/ext/arch.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Farch.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! SGX-specific access to architectural features.\n+//!\n+//! The functionality in this module is further documented in the Intel\n+//! Software Developer's Manual, Volume 3, Chapter 40.\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+use mem::MaybeUninit;\n+\n+/// Wrapper struct to force 16-byte alignment.\n+#[repr(align(16))]\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub struct Align16<T>(pub T);\n+\n+/// Wrapper struct to force 128-byte alignment.\n+#[repr(align(128))]\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub struct Align128<T>(pub T);\n+\n+/// Wrapper struct to force 512-byte alignment.\n+#[repr(align(512))]\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub struct Align512<T>(pub T);\n+\n+const ENCLU_EREPORT: u32 = 0;\n+const ENCLU_EGETKEY: u32 = 1;\n+\n+/// Call the `EGETKEY` instruction to obtain a 128-bit secret key.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn egetkey(request: &Align512<[u8; 512]>) -> Result<Align16<[u8; 16]>, u32> {\n+    unsafe {\n+        let mut out = MaybeUninit::uninitialized();\n+        let error;\n+\n+        asm!(\n+            \"enclu\"\n+            : \"={eax}\"(error)\n+            : \"{eax}\"(ENCLU_EGETKEY),\n+              \"{rbx}\"(request),\n+              \"{rcx}\"(out.get_mut())\n+            : \"flags\"\n+        );\n+\n+        match error {\n+            0 => Ok(out.into_inner()),\n+            err => Err(err),\n+        }\n+    }\n+}\n+\n+/// Call the `EREPORT` instruction.\n+///\n+/// This creates a cryptographic report describing the contents of the current\n+/// enclave. The report may be verified by the enclave described in\n+/// `targetinfo`.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub fn ereport(\n+    targetinfo: &Align512<[u8; 512]>,\n+    reportdata: &Align128<[u8; 64]>,\n+) -> Align512<[u8; 432]> {\n+    unsafe {\n+        let mut report = MaybeUninit::uninitialized();\n+\n+        asm!(\n+            \"enclu\"\n+            : /* no output registers */\n+            : \"{eax}\"(ENCLU_EREPORT),\n+              \"{rbx}\"(targetinfo),\n+              \"{rcx}\"(reportdata),\n+              \"{rdx}\"(report.get_mut())\n+        );\n+\n+        report.into_inner()\n+    }\n+}"}, {"sha": "55cc4c9ba1ffb6dfccea08f239aba02c09202fb7", "filename": "src/libstd/sys/sgx/ext/io.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fio.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -0,0 +1,119 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! SGX-specific extensions to general I/O primitives\n+//!\n+//! SGX file descriptors behave differently from Unix file descriptors. See the\n+//! description of [`TryIntoRawFd`](trait.TryIntoRawFd.html) for more details.\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+pub use sys::abi::usercalls::raw::Fd as RawFd;\n+use net;\n+use sys::{self, AsInner, FromInner, IntoInner, TryIntoInner};\n+\n+/// A trait to extract the raw SGX file descriptor from an underlying\n+/// object.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub trait AsRawFd {\n+    /// Extracts the raw file descriptor.\n+    ///\n+    /// This method does **not** pass ownership of the raw file descriptor\n+    /// to the caller. The descriptor is only guaranteed to be valid while\n+    /// the original object has not yet been destroyed.\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    fn as_raw_fd(&self) -> RawFd;\n+}\n+\n+/// A trait to express the ability to construct an object from a raw file\n+/// descriptor.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub trait FromRawFd {\n+    /// Constructs a new instance of `Self` from the given raw file\n+    /// descriptor.\n+    ///\n+    /// This function **consumes ownership** of the specified file\n+    /// descriptor. The returned object will take responsibility for closing\n+    /// it when the object goes out of scope.\n+    ///\n+    /// This function is also unsafe as the primitives currently returned\n+    /// have the contract that they are the sole owner of the file\n+    /// descriptor they are wrapping. Usage of this function could\n+    /// accidentally allow violating this contract which can cause memory\n+    /// unsafety in code that relies on it being true.\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    unsafe fn from_raw_fd(fd: RawFd) -> Self;\n+}\n+\n+/// A trait to express the ability to consume an object and acquire ownership of\n+/// its raw file descriptor.\n+#[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+pub trait TryIntoRawFd: Sized {\n+    /// Consumes this object, returning the raw underlying file descriptor, if\n+    /// this object is not cloned.\n+    ///\n+    /// This function **transfers ownership** of the underlying file descriptor\n+    /// to the caller. Callers are then the unique owners of the file descriptor\n+    /// and must close the descriptor once it's no longer needed.\n+    ///\n+    /// Unlike other platforms, on SGX, the file descriptor is shared between\n+    /// all clones of an object. To avoid race conditions, this function will\n+    /// only return `Ok` when called on the final clone.\n+    #[unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+    fn try_into_raw_fd(self) -> Result<RawFd, Self>;\n+}\n+\n+impl AsRawFd for net::TcpStream {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+}\n+\n+impl AsRawFd for net::TcpListener {\n+    fn as_raw_fd(&self) -> RawFd { *self.as_inner().as_inner().as_inner().as_inner() }\n+}\n+\n+impl FromRawFd for net::TcpStream {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpStream {\n+        let fd = sys::fd::FileDesc::from_inner(fd);\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpStream::from_inner(sys::net::TcpStream::from_inner((socket, None)))\n+    }\n+}\n+\n+impl FromRawFd for net::TcpListener {\n+    unsafe fn from_raw_fd(fd: RawFd) -> net::TcpListener {\n+        let fd = sys::fd::FileDesc::from_inner(fd);\n+        let socket = sys::net::Socket::from_inner(fd);\n+        net::TcpListener::from_inner(sys::net::TcpListener::from_inner(socket))\n+    }\n+}\n+\n+impl TryIntoRawFd for net::TcpStream {\n+    fn try_into_raw_fd(self) -> Result<RawFd, Self> {\n+        let (socket, peer_addr) = self.into_inner().into_inner();\n+        match socket.try_into_inner() {\n+            Ok(fd) => Ok(fd.into_inner()),\n+            Err(socket) => {\n+                let sys = sys::net::TcpStream::from_inner((socket, peer_addr));\n+                Err(net::TcpStream::from_inner(sys))\n+            }\n+        }\n+    }\n+}\n+\n+impl TryIntoRawFd for net::TcpListener {\n+    fn try_into_raw_fd(self) -> Result<RawFd, Self> {\n+        match self.into_inner().into_inner().try_into_inner() {\n+            Ok(fd) => Ok(fd.into_inner()),\n+            Err(socket) => {\n+                let sys = sys::net::TcpListener::from_inner(socket);\n+                Err(net::TcpListener::from_inner(sys))\n+            }\n+        }\n+    }\n+}"}, {"sha": "8e505a23c422d9d22db9f0666eb6a1033e487872", "filename": "src/libstd/sys/sgx/ext/mod.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fext%2Fmod.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -0,0 +1,14 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"sgx_platform\", issue = \"56975\")]\n+\n+pub mod arch;\n+pub mod io;"}, {"sha": "1f7024b2c462ebf4a0864a405132bb7238fb5220", "filename": "src/libstd/sys/sgx/fd.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Ffd.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -12,7 +12,7 @@ use fortanix_sgx_abi::Fd;\n \n use io;\n use mem;\n-use sys_common::AsInner;\n+use sys::{AsInner, FromInner, IntoInner};\n use super::abi::usercalls;\n \n #[derive(Debug)]\n@@ -51,6 +51,20 @@ impl AsInner<Fd> for FileDesc {\n     fn as_inner(&self) -> &Fd { &self.fd }\n }\n \n+impl IntoInner<Fd> for FileDesc {\n+    fn into_inner(self) -> Fd {\n+        let fd = self.fd;\n+        mem::forget(self);\n+        fd\n+    }\n+}\n+\n+impl FromInner<Fd> for FileDesc {\n+    fn from_inner(fd: Fd) -> FileDesc {\n+        FileDesc { fd }\n+    }\n+}\n+\n impl Drop for FileDesc {\n     fn drop(&mut self) {\n         usercalls::close(self.fd)"}, {"sha": "f2b569e17660da2df614119c1110c5b44f76e33a", "filename": "src/libstd/sys/sgx/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fmod.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -27,6 +27,7 @@ pub mod backtrace;\n pub mod cmath;\n pub mod condvar;\n pub mod env;\n+pub mod ext;\n pub mod fd;\n pub mod fs;\n pub mod memchr;\n@@ -151,3 +152,9 @@ pub fn hashmap_random_keys() -> (u64, u64) {\n     }\n     (rdrand64(), rdrand64())\n }\n+\n+pub use sys_common::{AsInner, FromInner, IntoInner};\n+\n+pub trait TryIntoInner<Inner>: Sized {\n+    fn try_into_inner(self) -> Result<Inner, Self>;\n+}"}, {"sha": "bb33a8aca79ae0a795b060ea554cd9bacf46f549", "filename": "src/libstd/sys/sgx/net.rs", "status": "modified", "additions": 64, "deletions": 9, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be565615dbed87a0d3fcdb7f62b2080b3dc288fa/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fnet.rs?ref=be565615dbed87a0d3fcdb7f62b2080b3dc288fa", "patch": "@@ -12,7 +12,7 @@ use fmt;\n use io;\n use net::{SocketAddr, Shutdown, Ipv4Addr, Ipv6Addr, ToSocketAddrs};\n use time::Duration;\n-use sys::{unsupported, Void, sgx_ineffective};\n+use sys::{unsupported, Void, sgx_ineffective, AsInner, FromInner, IntoInner, TryIntoInner};\n use sys::fd::FileDesc;\n use convert::TryFrom;\n use error;\n@@ -23,21 +23,38 @@ use super::abi::usercalls;\n const DEFAULT_FAKE_TTL: u32 = 64;\n \n #[derive(Debug, Clone)]\n-struct Socket {\n+pub struct Socket {\n     inner: Arc<FileDesc>,\n-    local_addr: String,\n+    local_addr: Option<String>,\n }\n \n impl Socket {\n     fn new(fd: usercalls::raw::Fd, local_addr: String) -> Socket {\n-        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr }\n+        Socket { inner: Arc::new(FileDesc::new(fd)), local_addr: Some(local_addr) }\n+    }\n+}\n+\n+impl AsInner<FileDesc> for Socket {\n+    fn as_inner(&self) -> &FileDesc { &self.inner }\n+}\n+\n+impl TryIntoInner<FileDesc> for Socket {\n+    fn try_into_inner(self) -> Result<FileDesc, Socket> {\n+        let Socket { inner, local_addr } = self;\n+        Arc::try_unwrap(inner).map_err(|inner| Socket { inner, local_addr } )\n+    }\n+}\n+\n+impl FromInner<FileDesc> for Socket {\n+    fn from_inner(inner: FileDesc) -> Socket {\n+        Socket { inner: Arc::new(inner), local_addr: None }\n     }\n }\n \n #[derive(Debug, Clone)]\n pub struct TcpStream {\n     inner: Socket,\n-    peer_addr: String,\n+    peer_addr: Option<String>,\n }\n \n fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n@@ -53,16 +70,19 @@ fn io_err_to_addr(result: io::Result<&SocketAddr>) -> io::Result<String> {\n     }\n }\n \n-fn addr_to_sockaddr(addr: &str) -> io::Result<SocketAddr> {\n-    // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n-    addr.to_socket_addrs().map(|mut it| it.next().unwrap())\n+fn addr_to_sockaddr(addr: &Option<String>) -> io::Result<SocketAddr> {\n+    addr.as_ref()\n+        .ok_or(io::ErrorKind::AddrNotAvailable)?\n+        .to_socket_addrs()\n+        // unwrap OK: if an iterator is returned, we're guaranteed to get exactly one entry\n+        .map(|mut it| it.next().unwrap())\n }\n \n impl TcpStream {\n     pub fn connect(addr: io::Result<&SocketAddr>) -> io::Result<TcpStream> {\n         let addr = io_err_to_addr(addr)?;\n         let (fd, local_addr, peer_addr) = usercalls::connect_stream(&addr)?;\n-        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr })\n+        Ok(TcpStream { inner: Socket::new(fd, local_addr), peer_addr: Some(peer_addr) })\n     }\n \n     pub fn connect_timeout(addr: &SocketAddr, _: Duration) -> io::Result<TcpStream> {\n@@ -138,6 +158,24 @@ impl TcpStream {\n     }\n }\n \n+impl AsInner<Socket> for TcpStream {\n+    fn as_inner(&self) -> &Socket { &self.inner }\n+}\n+\n+// `Inner` includes `peer_addr` so that a `TcpStream` maybe correctly\n+// reconstructed if `Socket::try_into_inner` fails.\n+impl IntoInner<(Socket, Option<String>)> for TcpStream {\n+    fn into_inner(self) -> (Socket, Option<String>) {\n+        (self.inner, self.peer_addr)\n+    }\n+}\n+\n+impl FromInner<(Socket, Option<String>)> for TcpStream {\n+    fn from_inner((inner, peer_addr): (Socket, Option<String>)) -> TcpStream {\n+        TcpStream { inner, peer_addr }\n+    }\n+}\n+\n #[derive(Debug, Clone)]\n pub struct TcpListener {\n     inner: Socket,\n@@ -156,6 +194,7 @@ impl TcpListener {\n \n     pub fn accept(&self) -> io::Result<(TcpStream, SocketAddr)> {\n         let (fd, local_addr, peer_addr) = usercalls::accept_stream(self.inner.inner.raw())?;\n+        let peer_addr = Some(peer_addr);\n         let ret_peer = addr_to_sockaddr(&peer_addr).unwrap_or_else(|_| ([0; 4], 0).into());\n         Ok((TcpStream { inner: Socket::new(fd, local_addr), peer_addr }, ret_peer))\n     }\n@@ -189,6 +228,22 @@ impl TcpListener {\n     }\n }\n \n+impl AsInner<Socket> for TcpListener {\n+    fn as_inner(&self) -> &Socket { &self.inner }\n+}\n+\n+impl IntoInner<Socket> for TcpListener {\n+    fn into_inner(self) -> Socket {\n+        self.inner\n+    }\n+}\n+\n+impl FromInner<Socket> for TcpListener {\n+    fn from_inner(inner: Socket) -> TcpListener {\n+        TcpListener { inner }\n+    }\n+}\n+\n pub struct UdpSocket(Void);\n \n impl UdpSocket {"}]}