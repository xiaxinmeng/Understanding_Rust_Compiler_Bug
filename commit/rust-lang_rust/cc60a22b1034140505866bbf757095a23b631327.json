{"sha": "cc60a22b1034140505866bbf757095a23b631327", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjNjBhMjJiMTAzNDE0MDUwNTg2NmJiZjc1NzA5NWEyM2I2MzEzMjc=", "commit": {"author": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-23T15:45:50Z"}, "committer": {"name": "Oliver Schneider", "email": "github35764891676564198441@oli-obk.de", "date": "2018-05-24T18:49:37Z"}, "message": "Get rid of `scalar_size`", "tree": {"sha": "dbf64f73ba63af03ee3345922d9c134c8e7cbbba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbf64f73ba63af03ee3345922d9c134c8e7cbbba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc60a22b1034140505866bbf757095a23b631327", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc60a22b1034140505866bbf757095a23b631327", "html_url": "https://github.com/rust-lang/rust/commit/cc60a22b1034140505866bbf757095a23b631327", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc60a22b1034140505866bbf757095a23b631327/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0da702a6d4f63744b18343c274bcd838c77e2449", "url": "https://api.github.com/repos/rust-lang/rust/commits/0da702a6d4f63744b18343c274bcd838c77e2449", "html_url": "https://github.com/rust-lang/rust/commit/0da702a6d4f63744b18343c274bcd838c77e2449"}], "stats": {"total": 193, "additions": 108, "deletions": 85}, "files": [{"sha": "763c5fbff5f82235919b9a0f743758e6ddb79b89", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -1906,8 +1906,12 @@ pub fn print_miri_value<W: Write>(value: Value, ty: Ty, f: &mut W) -> fmt::Resul\n         (Value::Scalar(Scalar::Bits { bits, defined: 64 }), &TyFloat(ast::FloatTy::F64)) =>\n             write!(f, \"{}f64\", Double::from_bits(bits)),\n         (Value::Scalar(Scalar::Bits { bits, .. }), &TyUint(ui)) => write!(f, \"{:?}{}\", bits, ui),\n-        (Value::Scalar(Scalar::Bits { bits, defined }), &TyInt(i)) => {\n-            let amt = 128 - defined;\n+        (Value::Scalar(Scalar::Bits { bits, .. }), &TyInt(i)) => {\n+            let bit_width = ty::tls::with(|tcx| {\n+                 let ty = tcx.global_tcx().lift(&ty).unwrap();\n+                 tcx.global_tcx().layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits()\n+            });\n+            let amt = 128 - bit_width;\n             write!(f, \"{:?}{}\", ((bits as i128) << amt) >> amt, i)\n         },\n         (Value::Scalar(Scalar::Bits { bits, defined: 32 }), &TyChar) =>"}, {"sha": "b3598bcdc045d5ee9bb9397d1cc0d895774510f4", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -1514,28 +1514,28 @@ impl<'a, 'tcx> LayoutOf for LayoutCx<'tcx, ty::maps::TyCtxtAt<'a, 'tcx, 'tcx>> {\n }\n \n // Helper (inherent) `layout_of` methods to avoid pushing `LayoutCx` to users.\n-impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx, 'empty> TyCtxt<'a, 'tcx, 'empty> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self,\n+            tcx: self.global_tcx(),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)\n     }\n }\n \n-impl<'a, 'tcx> ty::maps::TyCtxtAt<'a, 'tcx, 'tcx> {\n+impl<'a, 'tcx, 'empty> ty::maps::TyCtxtAt<'a, 'tcx, 'empty> {\n     /// Computes the layout of a type. Note that this implicitly\n     /// executes in \"reveal all\" mode.\n     #[inline]\n     pub fn layout_of(self, param_env_and_ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>)\n                      -> Result<TyLayout<'tcx>, LayoutError<'tcx>> {\n         let cx = LayoutCx {\n-            tcx: self,\n+            tcx: self.global_tcx().at(self.span),\n             param_env: param_env_and_ty.param_env\n         };\n         cx.layout_of(param_env_and_ty.value)"}, {"sha": "5ee6329e860e56545e80db88819b95844c02d64a", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -1982,7 +1982,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n         match tcx.const_eval(param_env.and(cid)) {\n             Ok(val) => {\n                 // FIXME: Find the right type and use it instead of `val.ty` here\n-                if let Some(b) = val.assert_bits(tcx, val.ty) {\n+                if let Some(b) = val.assert_bits(tcx.global_tcx(), param_env.and(val.ty)) {\n                     trace!(\"discriminants: {} ({:?})\", b, repr_type);\n                     Some(Discr {\n                         val: b,"}, {"sha": "4c03b708648dc868771dcb3254b07224184d0648", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 33, "deletions": 39, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -17,17 +17,15 @@ use middle::region;\n use rustc_data_structures::indexed_vec::Idx;\n use ty::subst::{Substs, Subst, Kind, UnpackedKind};\n use ty::{self, AdtDef, TypeFlags, Ty, TyCtxt, TypeFoldable};\n-use ty::{Slice, TyS, layout};\n+use ty::{Slice, TyS, ParamEnvAnd, ParamEnv};\n use util::captures::Captures;\n use mir::interpret::{Scalar, Pointer, Value, ConstValue};\n-use rustc_target::abi::{Size, HasDataLayout};\n \n use std::iter;\n use std::cmp::Ordering;\n use rustc_target::spec::abi;\n use syntax::ast::{self, Name};\n use syntax::symbol::{keywords, InternedString};\n-use syntax::attr;\n \n use serialize;\n \n@@ -1757,25 +1755,6 @@ impl<'a, 'gcx, 'tcx> TyS<'tcx> {\n             _ => bug!(\"cannot convert type `{:?}` to a closure kind\", self),\n         }\n     }\n-\n-    /// If this type is a scalar, compute its size without\n-    /// going through `tcx.layout_of`\n-    pub fn scalar_size<C: HasDataLayout>(\n-        &self,\n-        cx: C,\n-    ) -> Option<Size> {\n-        let ty = match self.sty {\n-            ty::TyBool => return Some(Size::from_bytes(1)),\n-            ty::TyChar => return Some(Size::from_bytes(4)),\n-            ty::TyInt(ity) => attr::IntType::SignedInt(ity),\n-            ty::TyUint(uty) => attr::IntType::UnsignedInt(uty),\n-            ty::TyFloat(ast::FloatTy::F32) => return Some(Size::from_bytes(4)),\n-            ty::TyFloat(ast::FloatTy::F64) => return Some(Size::from_bytes(8)),\n-            _ => return None,\n-        };\n-        use ty::layout::IntegerExt;\n-        Some(layout::Integer::from_attr(cx, ty).size())\n-    }\n }\n \n /// Typed constant value.\n@@ -1842,12 +1821,13 @@ impl<'tcx> Const<'tcx> {\n     pub fn from_bits(\n         tcx: TyCtxt<'_, '_, 'tcx>,\n         bits: u128,\n-        ty: Ty<'tcx>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n     ) -> &'tcx Self {\n-        let defined = ty.scalar_size(tcx).unwrap_or_else(|| {\n-            panic!(\"non-scalar type in from_bits: {:?}\", ty)\n-        }).bits() as u8;\n-        Self::from_scalar(tcx, Scalar::Bits { bits, defined }, ty)\n+        let ty = tcx.global_tcx().lift(&ty).unwrap();\n+        let defined = tcx.global_tcx().layout_of(ty).unwrap_or_else(|e| {\n+            panic!(\"could not compute layout for {:?}: {:?}\", ty, e)\n+        }).size.bits() as u8;\n+        Self::from_scalar(tcx, Scalar::Bits { bits, defined }, ty.value)\n     }\n \n     #[inline]\n@@ -1857,20 +1837,25 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn from_bool(tcx: TyCtxt<'_, '_, 'tcx>, v: bool) -> &'tcx Self {\n-        Self::from_bits(tcx, v as u128, tcx.types.bool)\n+        Self::from_bits(tcx, v as u128, ParamEnv::empty().and(tcx.types.bool))\n     }\n \n     #[inline]\n     pub fn from_usize(tcx: TyCtxt<'_, '_, 'tcx>, n: u64) -> &'tcx Self {\n-        Self::from_bits(tcx, n as u128, tcx.types.usize)\n+        Self::from_bits(tcx, n as u128, ParamEnv::empty().and(tcx.types.usize))\n     }\n \n     #[inline]\n-    pub fn to_bits<C: HasDataLayout>(&self, cx: C, ty: Ty<'tcx>) -> Option<u128> {\n-        if self.ty != ty {\n+    pub fn to_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, 'tcx>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Option<u128> {\n+        if self.ty != ty.value {\n             return None;\n         }\n-        let size = ty.scalar_size(cx)?;\n+        let ty = tcx.global_tcx().lift(&ty).unwrap();\n+        let size = tcx.global_tcx().layout_of(ty).ok()?.size;\n         match self.val {\n             ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n@@ -1902,9 +1887,14 @@ impl<'tcx> Const<'tcx> {\n     }\n \n     #[inline]\n-    pub fn assert_bits<C: HasDataLayout>(&self, cx: C, ty: Ty<'tcx>) -> Option<u128> {\n-        assert_eq!(self.ty, ty);\n-        let size = ty.scalar_size(cx)?;\n+    pub fn assert_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> Option<u128> {\n+        assert_eq!(self.ty, ty.value);\n+        let ty = tcx.global_tcx().lift(&ty).unwrap();\n+        let size = tcx.global_tcx().layout_of(ty).ok()?.size;\n         match self.val {\n             ConstVal::Value(val) => val.to_bits(size),\n             _ => None,\n@@ -1913,7 +1903,7 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn assert_bool(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<bool> {\n-        self.assert_bits(tcx, tcx.types.bool).and_then(|v| match v {\n+        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.bool)).and_then(|v| match v {\n             0 => Some(false),\n             1 => Some(true),\n             _ => None,\n@@ -1922,14 +1912,18 @@ impl<'tcx> Const<'tcx> {\n \n     #[inline]\n     pub fn assert_usize(&self, tcx: TyCtxt<'_, '_, '_>) -> Option<u64> {\n-        self.assert_bits(tcx, tcx.types.usize).map(|v| v as u64)\n+        self.assert_bits(tcx, ParamEnv::empty().and(tcx.types.usize)).map(|v| v as u64)\n     }\n \n     #[inline]\n-    pub fn unwrap_bits(&self, tcx: TyCtxt<'_, '_, '_>, ty: Ty<'tcx>) -> u128 {\n+    pub fn unwrap_bits(\n+        &self,\n+        tcx: TyCtxt<'_, '_, '_>,\n+        ty: ParamEnvAnd<'tcx, Ty<'tcx>>,\n+    ) -> u128 {\n         match self.assert_bits(tcx, ty) {\n             Some(val) => val,\n-            None => bug!(\"expected bits of {}, got {:#?}\", ty, self),\n+            None => bug!(\"expected bits of {}, got {:#?}\", ty.value, self),\n         }\n     }\n "}, {"sha": "f00eb336b225e4db9b9aa4f466f4c71d7c271d3c", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -202,7 +202,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                                 value: ty::Const::from_bits(\n                                     this.hir.tcx(),\n                                     0,\n-                                    this.hir.tcx().types.u32),\n+                                    ty::ParamEnv::empty().and(this.hir.tcx().types.u32)),\n                             },\n                         }));\n                         box AggregateKind::Generator(closure_id, substs, movability)\n@@ -374,22 +374,26 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n     // Helper to get a `-1` value of the appropriate type\n     fn neg_1_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n-        let bits = ty.scalar_size(self.hir.tcx()).expect(\"neg_1_literal expects integers\").bits();\n+        let gcx = self.hir.tcx().global_tcx();\n+        let param_ty = ty::ParamEnv::empty().and(gcx.lift(&ty).unwrap());\n+        let bits = gcx.layout_of(param_ty).unwrap().size.bits();\n         let n = (!0u128) >> (128 - bits);\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n         };\n \n         self.literal_operand(span, ty, literal)\n     }\n \n     // Helper to get the minimum value of the appropriate type\n     fn minval_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n+        let gcx = self.hir.tcx().global_tcx();\n         assert!(ty.is_signed());\n-        let bits = ty.scalar_size(self.hir.tcx()).expect(\"minval_literal expects integers\").bits();\n+        let param_ty = ty::ParamEnv::empty().and(gcx.lift(&ty).unwrap());\n+        let bits = gcx.layout_of(param_ty).unwrap().size.bits();\n         let n = 1 << (bits - 1);\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), n, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), n, param_ty)\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "aa5727ee5c7ea67d1cce0032568ac73bfd17e17f", "filename": "src/librustc_mir/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Ftest.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -122,6 +122,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n \n         match *match_pair.pattern.kind {\n             PatternKind::Constant { value } => {\n+                let switch_ty = ty::ParamEnv::empty().and(switch_ty);\n                 indices.entry(value)\n                        .or_insert_with(|| {\n                            options.push(value.unwrap_bits(self.hir.tcx(), switch_ty));"}, {"sha": "5907a0cff8e6aa1bce7a252020cb37b0e4085791", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -53,7 +53,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     // bool, char and integers.\n     pub fn zero_literal(&mut self, span: Span, ty: Ty<'tcx>) -> Operand<'tcx> {\n         let literal = Literal::Value {\n-            value: ty::Const::from_bits(self.hir.tcx(), 0, ty)\n+            value: ty::Const::from_bits(self.hir.tcx(), 0, ty::ParamEnv::empty().and(ty))\n         };\n \n         self.literal_operand(span, ty, literal)"}, {"sha": "f6f98f0732e3ae525a96f8b313c75cc00c8d8bf9", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -635,7 +635,11 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                             },\n                         },\n                     }.to_ref();\n-                    let offset = mk_const(ty::Const::from_bits(cx.tcx, offset as u128, ty));\n+                    let offset = mk_const(ty::Const::from_bits(\n+                        cx.tcx,\n+                        offset as u128,\n+                        cx.param_env.and(ty),\n+                    ));\n                     match did {\n                         Some(did) => {\n                             // in case we are offsetting from a computed discriminant"}, {"sha": "d0965957f8bf1e167ced3d8ca9e062ebc0be6360", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -156,14 +156,16 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n         };\n \n         let clamp = |n| {\n-            let size = ty.scalar_size(self.tcx).expect(\"const_eval_lit::clamp expects ints\").bits();\n-            trace!(\"clamp {} with size {} and amt {}\", n, size, 128 - size);\n-            let amt = 128 - size;\n+            let gcx = self.tcx.global_tcx();\n+            let param_ty = self.param_env.and(gcx.lift(&ty).unwrap());\n+            let bit_width = gcx.layout_of(param_ty).unwrap().size.bits();\n+            trace!(\"clamp {} with size {} and amt {}\", n, bit_width, 128 - bit_width);\n+            let amt = 128 - bit_width;\n             let result = (n << amt) >> amt;\n             trace!(\"clamp result: {}\", result);\n             ConstValue::Scalar(Scalar::Bits {\n                 bits: result,\n-                defined: size as u8,\n+                defined: bit_width as u8,\n             })\n         };\n "}, {"sha": "a7b2e205d006df27c72eabc76e9fa03944abea89", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -198,7 +198,7 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n                                     value: ty::Const::from_bits(\n                                         tcx,\n                                         *b as u128,\n-                                        tcx.types.u8)\n+                                        ty::ParamEnv::empty().and(tcx.types.u8))\n                                 }\n                             })\n                         }).collect()\n@@ -958,7 +958,7 @@ fn slice_pat_covered_by_constructor<'tcx>(\n     {\n         match pat.kind {\n             box PatternKind::Constant { value } => {\n-                let b = value.unwrap_bits(tcx, pat.ty);\n+                let b = value.unwrap_bits(tcx, ty::ParamEnv::empty().and(pat.ty));\n                 assert_eq!(b as u8 as u128, b);\n                 if b as u8 != *ch {\n                     return Ok(false);\n@@ -979,9 +979,9 @@ fn constructor_covered_by_range<'a, 'tcx>(\n     ty: Ty<'tcx>,\n ) -> Result<bool, ErrorReported> {\n     trace!(\"constructor_covered_by_range {:#?}, {:#?}, {:#?}, {}\", ctor, from, to, ty);\n-    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty)\n+    let cmp_from = |c_from| compare_const_vals(tcx, c_from, from, ty::ParamEnv::empty().and(ty))\n         .map(|res| res != Ordering::Less);\n-    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, ty);\n+    let cmp_to = |c_to| compare_const_vals(tcx, c_to, to, ty::ParamEnv::empty().and(ty));\n     macro_rules! some_or_ok {\n         ($e:expr) => {\n             match $e {"}, {"sha": "dd79e0cdd0f774cfe4f2a29496b0cc92b9754b5a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -359,7 +359,13 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     (PatternKind::Constant { value: lo },\n                      PatternKind::Constant { value: hi }) => {\n                         use std::cmp::Ordering;\n-                        match (end, compare_const_vals(self.tcx, lo, hi, ty).unwrap()) {\n+                        let cmp = compare_const_vals(\n+                            self.tcx,\n+                            lo,\n+                            hi,\n+                            self.param_env.and(ty),\n+                        ).unwrap();\n+                        match (end, cmp) {\n                             (RangeEnd::Excluded, Ordering::Less) =>\n                                 PatternKind::Range { lo, hi, end },\n                             (RangeEnd::Excluded, _) => {\n@@ -1036,7 +1042,7 @@ pub fn compare_const_vals<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     a: &'tcx ty::Const<'tcx>,\n     b: &'tcx ty::Const<'tcx>,\n-    ty: Ty<'tcx>,\n+    ty: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n ) -> Option<Ordering> {\n     trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n \n@@ -1051,15 +1057,15 @@ pub fn compare_const_vals<'a, 'tcx>(\n     let fallback = || from_bool(a == b);\n \n     // Use the fallback if any type differs\n-    if a.ty != b.ty || a.ty != ty {\n+    if a.ty != b.ty || a.ty != ty.value {\n         return fallback();\n     }\n \n     // FIXME: This should use assert_bits(ty) instead of use_bits\n     // but triggers possibly bugs due to mismatching of arrays and slices\n     if let (Some(a), Some(b)) = (a.to_bits(tcx, ty), b.to_bits(tcx, ty)) {\n         use ::rustc_apfloat::Float;\n-        return match ty.sty {\n+        return match ty.value.sty {\n             ty::TyFloat(ast::FloatTy::F32) => {\n                 let l = ::rustc_apfloat::ieee::Single::from_bits(a);\n                 let r = ::rustc_apfloat::ieee::Single::from_bits(b);\n@@ -1071,15 +1077,15 @@ pub fn compare_const_vals<'a, 'tcx>(\n                 l.partial_cmp(&r)\n             },\n             ty::TyInt(_) => {\n-                let a = interpret::sign_extend(tcx, a, ty).expect(\"layout error for TyInt\");\n-                let b = interpret::sign_extend(tcx, b, ty).expect(\"layout error for TyInt\");\n+                let a = interpret::sign_extend(tcx, a, ty.value).expect(\"layout error for TyInt\");\n+                let b = interpret::sign_extend(tcx, b, ty.value).expect(\"layout error for TyInt\");\n                 Some((a as i128).cmp(&(b as i128)))\n             },\n             _ => Some(a.cmp(&b)),\n         }\n     }\n \n-    if let ty::TyRef(_, rty, _) = ty.sty {\n+    if let ty::TyRef(_, rty, _) = ty.value.sty {\n         if let ty::TyStr = rty.sty {\n             match (a.to_byval_value(), b.to_byval_value()) {\n                 (\n@@ -1177,9 +1183,10 @@ fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n                 Int::Signed(IntTy::I128)| Int::Unsigned(UintTy::U128) => n,\n                 _ => bug!(),\n             };\n+            let defined = tcx.layout_of(ty::ParamEnv::empty().and(ty)).unwrap().size.bits() as u8;\n             ConstValue::Scalar(Scalar::Bits {\n                 bits: n,\n-                defined: ty.scalar_size(tcx).unwrap().bits() as u8,\n+                defined,\n             })\n         },\n         LitKind::Float(n, fty) => {"}, {"sha": "e69e7a522ab73e62bfdc7d5014db72f3cb7392a5", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let v = self.truncate(v, dest_ty)?;\n                 Ok(Scalar::Bits {\n                     bits: v,\n-                    defined: dest_ty.scalar_size(self.tcx.tcx).unwrap().bits() as u8,\n+                    defined: self.layout_of(dest_ty).unwrap().size.bits() as u8,\n                 })\n             }\n "}, {"sha": "01170f0763645e55436a6bcbcd105c3f47dbd595", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -705,10 +705,11 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                                         let discr_val = def\n                                             .discriminant_for_variant(*self.tcx, index)\n                                             .val;\n-                                        let defined = dest_ty\n-                                                    .scalar_size(self.tcx.tcx)\n-                                                    .expect(\"can only cast variants to ints\")\n-                                                    .bits() as u8;\n+                                        let defined = self\n+                                            .layout_of(dest_ty)\n+                                            .unwrap()\n+                                            .size\n+                                            .bits() as u8;\n                                         return self.write_scalar(\n                                             dest,\n                                             Scalar::Bits {\n@@ -798,7 +799,7 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n                 let ty = self.place_ty(place);\n                 let place = self.eval_place(place)?;\n                 let discr_val = self.read_discriminant_value(place, ty)?;\n-                let defined = ty.scalar_size(self.tcx.tcx).expect(\"discriminant must be scalar\").bits() as u8;\n+                let defined = self.layout_of(ty).unwrap().size.bits() as u8;\n                 self.write_scalar(dest, Scalar::Bits {\n                     bits: discr_val,\n                     defined,"}, {"sha": "c8af638a54da44991cd5e5c5af0de0906fcfef8d", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -213,7 +213,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        let bitsize = left_ty.scalar_size(self).expect(\"operator type must be scalar\").bits() as u8;\n+        let bit_width = self.layout_of(left_ty).unwrap().size.bits() as u8;\n \n         // only ints left\n         let val = match bin_op {\n@@ -225,9 +225,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             Gt => Scalar::from_bool(l > r),\n             Ge => Scalar::from_bool(l >= r),\n \n-            BitOr => Scalar::Bits { bits: l | r, defined: bitsize },\n-            BitAnd => Scalar::Bits { bits: l & r, defined: bitsize },\n-            BitXor => Scalar::Bits { bits: l ^ r, defined: bitsize },\n+            BitOr => Scalar::Bits { bits: l | r, defined: bit_width },\n+            BitAnd => Scalar::Bits { bits: l & r, defined: bit_width },\n+            BitXor => Scalar::Bits { bits: l ^ r, defined: bit_width },\n \n             Add | Sub | Mul | Rem | Div => {\n                 let op: fn(u128, u128) -> (u128, bool) = match bin_op {\n@@ -244,7 +244,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let truncated = self.truncate(result, left_ty)?;\n                 return Ok((Scalar::Bits {\n                     bits: truncated,\n-                    defined: bitsize,\n+                    defined: bit_width,\n                 }, oflo || truncated != result));\n             }\n "}, {"sha": "cc250fb68c902a14013c35cefd9e0a639797b604", "filename": "src/librustc_mir/interpret/terminator/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator%2Fmod.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -44,7 +44,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 let mut target_block = targets[targets.len() - 1];\n \n                 for (index, &const_int) in values.iter().enumerate() {\n-                    if discr_prim.to_bits(discr_val.ty.scalar_size(self.tcx.tcx).expect(\"discr must be scalar\"))? == const_int {\n+                    if discr_prim.to_bits(self.layout_of(discr_val.ty).unwrap().size)? == const_int {\n                         target_block = targets[index];\n                         break;\n                     }"}, {"sha": "fa740876091ac099163070ae1722d67d14c7d0ee", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -330,8 +330,13 @@ impl<'b, 'a, 'tcx:'b> ConstPropagator<'b, 'a, 'tcx> {\n                 })?;\n                 if op == BinOp::Shr || op == BinOp::Shl {\n                     let left_ty = left.ty(self.mir, self.tcx);\n-                    let left_bits = left_ty.scalar_size(self.tcx).unwrap().bits();\n-                    let right_size = right.1.scalar_size(self.tcx).unwrap();\n+                    let left_bits = self\n+                        .tcx\n+                        .layout_of(self.param_env.and(left_ty))\n+                        .unwrap()\n+                        .size\n+                        .bits();\n+                    let right_size = self.tcx.layout_of(self.param_env.and(right.1)).unwrap().size;\n                     if r.to_bits(right_size).ok().map_or(false, |b| b >= left_bits as u128) {\n                         let scope_info = match self.mir.visibility_scope_info {\n                             ClearCrossCrate::Set(ref data) => data,"}, {"sha": "74b6d721882fa42e15b1b9fed1b26340a49e6862", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -181,7 +181,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n                 value: ty::Const::from_bits(\n                     self.tcx,\n                     state_disc.into(),\n-                    self.tcx.types.u32),\n+                    ty::ParamEnv::empty().and(self.tcx.types.u32)),\n             },\n         });\n         Statement {"}, {"sha": "2dbba897fa8a27bd742585540aa2b89a3806eeb8", "filename": "src/librustc_mir/transform/simplify_branches.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc60a22b1034140505866bbf757095a23b631327/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify_branches.rs?ref=cc60a22b1034140505866bbf757095a23b631327", "patch": "@@ -10,7 +10,7 @@\n \n //! A pass that simplifies branches when their condition is known.\n \n-use rustc::ty::TyCtxt;\n+use rustc::ty::{TyCtxt, ParamEnv};\n use rustc::mir::*;\n use transform::{MirPass, MirSource};\n \n@@ -39,6 +39,7 @@ impl MirPass for SimplifyBranches {\n                 TerminatorKind::SwitchInt { discr: Operand::Constant(box Constant {\n                     literal: Literal::Value { ref value }, ..\n                 }), switch_ty, ref values, ref targets, .. } => {\n+                    let switch_ty = ParamEnv::empty().and(switch_ty);\n                     if let Some(constint) = value.assert_bits(tcx, switch_ty) {\n                         let (otherwise, targets) = targets.split_last().unwrap();\n                         let mut ret = TerminatorKind::Goto { target: *otherwise };"}]}