{"sha": "102c0af5a75354acb21ebceb06765ae8d54a8270", "node_id": "C_kwDOAAsO6NoAKDEwMmMwYWY1YTc1MzU0YWNiMjFlYmNlYjA2NzY1YWU4ZDU0YTgyNzA", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-19T18:19:55Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2023-04-19T19:13:35Z"}, "message": " Add suggestion to use a closure arg instead of a capture on bck error", "tree": {"sha": "bd3d2cd62c93143f618259289a0ebdbfeff96ad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd3d2cd62c93143f618259289a0ebdbfeff96ad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/102c0af5a75354acb21ebceb06765ae8d54a8270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/102c0af5a75354acb21ebceb06765ae8d54a8270", "html_url": "https://github.com/rust-lang/rust/commit/102c0af5a75354acb21ebceb06765ae8d54a8270", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/102c0af5a75354acb21ebceb06765ae8d54a8270/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfe5c3ca6cb0f0b9ffa3f08c42ed12e39905fdb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfe5c3ca6cb0f0b9ffa3f08c42ed12e39905fdb5", "html_url": "https://github.com/rust-lang/rust/commit/cfe5c3ca6cb0f0b9ffa3f08c42ed12e39905fdb5"}], "stats": {"total": 245, "additions": 237, "deletions": 8}, "files": [{"sha": "88cdb2996ab94b4dc05db404613726d4d19157c8", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 182, "deletions": 3, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/102c0af5a75354acb21ebceb06765ae8d54a8270/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102c0af5a75354acb21ebceb06765ae8d54a8270/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=102c0af5a75354acb21ebceb06765ae8d54a8270", "patch": "@@ -1,3 +1,5 @@\n+use std::iter;\n+\n use either::Either;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fx::FxIndexSet;\n@@ -10,25 +12,25 @@ use rustc_hir::intravisit::{walk_block, walk_expr, Visitor};\n use rustc_hir::{AsyncGeneratorKind, GeneratorKind, LangItem};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_infer::traits::ObligationCause;\n+use rustc_middle::hir::nested_filter::OnlyBodies;\n use rustc_middle::mir::tcx::PlaceTy;\n use rustc_middle::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, ConstraintCategory,\n     FakeReadCause, LocalDecl, LocalInfo, LocalKind, Location, Operand, Place, PlaceRef,\n     ProjectionElem, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, VarBindingForm,\n };\n-use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty};\n+use rustc_middle::ty::{self, suggest_constraining_type_params, PredicateKind, Ty, TypeckResults};\n use rustc_middle::util::CallKind;\n use rustc_mir_dataflow::move_paths::{InitKind, MoveOutIndex, MovePathIndex};\n use rustc_span::def_id::LocalDefId;\n use rustc_span::hygiene::DesugaringKind;\n-use rustc_span::symbol::{kw, sym};\n+use rustc_span::symbol::{kw, sym, Ident};\n use rustc_span::{BytePos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n use rustc_trait_selection::traits::ObligationCtxt;\n \n use crate::borrow_set::TwoPhaseActivation;\n use crate::borrowck_errors;\n-\n use crate::diagnostics::conflict_errors::StorageDeadOrDrop::LocalStorageDead;\n use crate::diagnostics::{find_all_local_uses, CapturedMessageOpt};\n use crate::{\n@@ -959,6 +961,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     None,\n                 );\n                 self.suggest_binding_for_closure_capture_self(&mut err, &issued_spans);\n+                self.suggest_using_closure_argument_instead_of_capture(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n                 err\n             }\n \n@@ -977,6 +984,11 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     place,\n                     issued_borrow.borrowed_place,\n                 );\n+                self.suggest_using_closure_argument_instead_of_capture(\n+                    &mut err,\n+                    issued_borrow.borrowed_place,\n+                    &issued_spans,\n+                );\n                 err\n             }\n \n@@ -1263,6 +1275,173 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         }\n     }\n \n+    /// Suggest using closure argument instead of capture.\n+    ///\n+    /// For example:\n+    /// ```ignore (illustrative)\n+    /// struct S;\n+    ///\n+    /// impl S {\n+    ///     fn call(&mut self, f: impl Fn(&mut Self)) { /* ... */ }\n+    ///     fn x(&self) {}\n+    /// }\n+    ///\n+    ///     let mut v = S;\n+    ///     v.call(|this: &mut S| v.x());\n+    /// //  ^\\                    ^-- help: try using the closure argument: `this`\n+    /// //    *-- error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    /// ```\n+    fn suggest_using_closure_argument_instead_of_capture(\n+        &self,\n+        err: &mut Diagnostic,\n+        borrowed_place: Place<'tcx>,\n+        issued_spans: &UseSpans<'tcx>,\n+    ) {\n+        let &UseSpans::ClosureUse { capture_kind_span, .. } = issued_spans else { return };\n+        let tcx = self.infcx.tcx;\n+        let hir = tcx.hir();\n+\n+        // Get the type of the local that we are trying to borrow\n+        let local = borrowed_place.local;\n+        let local_ty = self.body.local_decls[local].ty;\n+\n+        // Get the body the error happens in\n+        let &body_id =\n+            if let hir::Node::Item(hir::Item { kind, .. }) = hir.get(self.mir_hir_id())\n+                && let hir::ItemKind::Static(_, _, body_id)\n+                     | hir::ItemKind::Const(_, body_id)\n+                     | hir::ItemKind::Fn(_, _, body_id) = kind\n+            {\n+                body_id\n+            } else if let hir::Node::TraitItem(hir::TraitItem { kind, .. }) = hir.get(self.mir_hir_id())\n+                && let hir::TraitItemKind::Const(_, Some(body_id))\n+                     | hir::TraitItemKind::Fn(_, hir::TraitFn::Provided(body_id)) = kind\n+            {\n+                body_id\n+            }else if let hir::Node::ImplItem(hir::ImplItem { kind, .. }) = hir.get(self.mir_hir_id())\n+                && let hir::ImplItemKind::Const(_, body_id)\n+                     | hir::ImplItemKind::Fn(_, body_id) = kind\n+            {\n+                body_id\n+            } else {\n+                return\n+            };\n+\n+        let body_expr = hir.body(body_id).value;\n+\n+        struct ClosureFinder<'hir> {\n+            hir: rustc_middle::hir::map::Map<'hir>,\n+            borrow_span: Span,\n+            res: Option<(&'hir hir::Expr<'hir>, &'hir hir::Closure<'hir>)>,\n+            /// The path expression with the `borrow_span` span\n+            error_path: Option<(&'hir hir::Expr<'hir>, &'hir hir::QPath<'hir>)>,\n+        }\n+        impl<'hir> Visitor<'hir> for ClosureFinder<'hir> {\n+            type NestedFilter = OnlyBodies;\n+\n+            fn nested_visit_map(&mut self) -> Self::Map {\n+                self.hir\n+            }\n+\n+            fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                if let hir::ExprKind::Path(qpath) = &ex.kind\n+                    && ex.span == self.borrow_span\n+                {\n+                    self.error_path = Some((ex, qpath));\n+                }\n+\n+                if let hir::ExprKind::Closure(closure) = ex.kind\n+                    && ex.span.contains(self.borrow_span)\n+                    // To support cases like `|| { v.call(|this| v.get()) }`\n+                    // FIXME: actually support such cases (need to figure out how to move from the capture place to original local)\n+                    && self.res.as_ref().map_or(true, |(prev_res, _)| prev_res.span.contains(ex.span))\n+                {\n+                    self.res = Some((ex, closure));\n+                }\n+\n+                hir::intravisit::walk_expr(self, ex);\n+            }\n+        }\n+\n+        // Find the closure that most tightly wraps `capture_kind_span`\n+        let mut finder =\n+            ClosureFinder { hir, borrow_span: capture_kind_span, res: None, error_path: None };\n+        finder.visit_expr(body_expr);\n+        let Some((closure_expr, closure)) = finder.res else { return };\n+\n+        let typeck_results: &TypeckResults<'_> =\n+            tcx.typeck_opt_const_arg(self.body.source.with_opt_param().as_local().unwrap());\n+\n+        // Check that the parent of the closure is a method call,\n+        // with receiver matching with local's type (modulo refs)\n+        let parent = hir.parent_id(closure_expr.hir_id);\n+        if let hir::Node::Expr(parent) = hir.get(parent) {\n+            if let hir::ExprKind::MethodCall(_, recv, ..) = parent.kind {\n+                let recv_ty = typeck_results.expr_ty(recv);\n+\n+                if recv_ty.peel_refs() != local_ty {\n+                    return;\n+                }\n+            }\n+        }\n+\n+        // Get closure's arguments\n+        let ty::Closure(_, substs) = typeck_results.expr_ty(closure_expr).kind() else { unreachable!() };\n+        let sig = substs.as_closure().sig();\n+        let tupled_params =\n+            tcx.erase_late_bound_regions(sig.inputs().iter().next().unwrap().map_bound(|&b| b));\n+        let ty::Tuple(params) = tupled_params.kind() else { return };\n+\n+        // Find the first argument with a matching type, get its name\n+        let Some((_, this_name)) = params\n+            .iter()\n+            .zip(hir.body_param_names(closure.body))\n+            .find(|(param_ty, name)|{\n+                // FIXME: also support deref for stuff like `Rc` arguments\n+                param_ty.peel_refs() == local_ty && name != &Ident::empty()\n+            })\n+            else { return };\n+\n+        let spans;\n+        if let Some((_path_expr, qpath)) = finder.error_path\n+            && let hir::QPath::Resolved(_, path) = qpath\n+            && let hir::def::Res::Local(local_id) = path.res\n+        {\n+            // Find all references to the problematic variable in this closure body\n+\n+            struct VariableUseFinder {\n+                local_id: hir::HirId,\n+                spans: Vec<Span>,\n+            }\n+            impl<'hir> Visitor<'hir> for VariableUseFinder {\n+                fn visit_expr(&mut self, ex: &'hir hir::Expr<'hir>) {\n+                    if let hir::ExprKind::Path(qpath) = &ex.kind\n+                        && let hir::QPath::Resolved(_, path) = qpath\n+                        && let hir::def::Res::Local(local_id) = path.res\n+                        && local_id == self.local_id\n+                    {\n+                        self.spans.push(ex.span);\n+                    }\n+\n+                    hir::intravisit::walk_expr(self, ex);\n+                }\n+            }\n+\n+            let mut finder = VariableUseFinder { local_id, spans: Vec::new() };\n+            finder.visit_expr(hir.body(closure.body).value);\n+\n+            spans = finder.spans;\n+        } else {\n+            spans = vec![capture_kind_span];\n+        }\n+\n+        err.multipart_suggestion(\n+            \"try using the closure argument\",\n+            iter::zip(spans, iter::repeat(this_name.to_string())).collect(),\n+            Applicability::MaybeIncorrect,\n+        );\n+    }\n+\n     fn suggest_binding_for_closure_capture_self(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "4a8831dab95676dc6dcf708ecfea7857bdc64028", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.fixed", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.fixed?ref=102c0af5a75354acb21ebceb06765ae8d54a8270", "patch": "@@ -0,0 +1,39 @@\n+// run-rustfix\n+#![allow(unused)]\n+struct S;\n+\n+impl S {\n+    fn call(&mut self, f: impl FnOnce((), &mut Self)) {\n+        // change state or something ...\n+        f((), self);\n+        // change state or something ...\n+    }\n+\n+    fn get(&self) {}\n+    fn set(&mut self) {}\n+}\n+\n+fn main() {\n+    let mut v = S;\n+\n+    v.call(|(), this: &mut S| this.get());\n+    //~^ error: cannot borrow `v` as mutable because it is also borrowed as immutable\n+    v.call(|(), this: &mut S| this.set());\n+    //~^ error: cannot borrow `v` as mutable more than once at a time\n+    //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+    v.call(|(), this: &mut S| {\n+        //~^ error: cannot borrow `v` as mutable more than once at a time\n+        //~| error: cannot borrow `v` as mutable more than once at a time\n+\n+        _ = this;\n+        this.set();\n+        this.get();\n+        S::get(&this);\n+\n+        use std::ops::Add;\n+        let v = 0u32;\n+        _ = v + v;\n+        _ = v.add(3);\n+    });\n+}"}, {"sha": "fcd855f862d71cc4834c255b6090853ded8676cb", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.rs?ref=102c0af5a75354acb21ebceb06765ae8d54a8270", "patch": "@@ -1,3 +1,4 @@\n+// run-rustfix\n #![allow(unused)]\n struct S;\n "}, {"sha": "25974e0d00831d9992a48be2a675fc9c697d7581", "filename": "tests/ui/borrowck/issue-109271-pass-self-into-closure.stderr", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/102c0af5a75354acb21ebceb06765ae8d54a8270/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fborrowck%2Fissue-109271-pass-self-into-closure.stderr?ref=102c0af5a75354acb21ebceb06765ae8d54a8270", "patch": "@@ -1,27 +1,29 @@\n error[E0502]: cannot borrow `v` as mutable because it is also borrowed as immutable\n-  --> $DIR/issue-109271-pass-self-into-closure.rs:18:5\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:19:5\n    |\n LL |     v.call(|(), this: &mut S| v.get());\n    |     ^^----^------------------^-^^^^^^^\n    |     | |    |                  |\n    |     | |    |                  first borrow occurs due to use of `v` in closure\n+   |     | |    |                  help: try using the closure argument: `this`\n    |     | |    immutable borrow occurs here\n    |     | immutable borrow later used by call\n    |     mutable borrow occurs here\n \n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/issue-109271-pass-self-into-closure.rs:20:5\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:21:5\n    |\n LL |     v.call(|(), this: &mut S| v.set());\n    |     ^^----^------------------^-^^^^^^^\n    |     | |    |                  |\n    |     | |    |                  first borrow occurs due to use of `v` in closure\n+   |     | |    |                  help: try using the closure argument: `this`\n    |     | |    first mutable borrow occurs here\n    |     | first borrow later used by call\n    |     second mutable borrow occurs here\n \n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/issue-109271-pass-self-into-closure.rs:20:12\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:21:12\n    |\n LL |     v.call(|(), this: &mut S| v.set());\n    |     -------^^^^^^^^^^^^^^^^^^---------\n@@ -32,7 +34,7 @@ LL |     v.call(|(), this: &mut S| v.set());\n    |     first mutable borrow occurs here\n \n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/issue-109271-pass-self-into-closure.rs:24:5\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:25:5\n    |\n LL |       v.call(|(), this: &mut S| {\n    |       ^ ---- ------------------ first mutable borrow occurs here\n@@ -49,9 +51,17 @@ LL | |         v.set();\n LL | |         _ = v.add(3);\n LL | |     });\n    | |______^ second mutable borrow occurs here\n+   |\n+help: try using the closure argument\n+   |\n+LL ~         _ = this;\n+LL ~         this.set();\n+LL ~         this.get();\n+LL ~         S::get(&this);\n+   |\n \n error[E0499]: cannot borrow `v` as mutable more than once at a time\n-  --> $DIR/issue-109271-pass-self-into-closure.rs:24:12\n+  --> $DIR/issue-109271-pass-self-into-closure.rs:25:12\n    |\n LL |       v.call(|(), this: &mut S| {\n    |       - ---- ^^^^^^^^^^^^^^^^^^ second mutable borrow occurs here"}]}