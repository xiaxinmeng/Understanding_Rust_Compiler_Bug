{"sha": "e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ZTFlMGNlYThjM2EyYjEwZGJhZDRjY2U3ZDc5ZDdjMjRmODM2NGI=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-06-25T06:24:00Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2018-06-25T06:24:00Z"}, "message": "Fix compile errors from breaking changes in libsyntax\n\ncc https://github.com/rust-lang/rust/pull/48149.", "tree": {"sha": "509b16f140b12864b375a6253deecf01602a5171", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/509b16f140b12864b375a6253deecf01602a5171"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "html_url": "https://github.com/rust-lang/rust/commit/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ceda3679ccd922c7b04168901166ec8bc8f569c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceda3679ccd922c7b04168901166ec8bc8f569c0", "html_url": "https://github.com/rust-lang/rust/commit/ceda3679ccd922c7b04168901166ec8bc8f569c0"}], "stats": {"total": 233, "additions": 120, "deletions": 113}, "files": [{"sha": "52999635cf125ce4fa1dc1a6f2b8550e9056a740", "filename": "src/chains.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -70,6 +70,7 @@ use expr::rewrite_call;\n use macros::convert_try_mac;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n+use spanned::Spanned;\n use utils::{\n     first_line_width, last_line_extendable, last_line_width, mk_sp, trimmed_last_line_width,\n     wrap_str,\n@@ -436,9 +437,9 @@ fn rewrite_chain_subexpr(\n \n     match expr.node {\n         ast::ExprKind::MethodCall(ref segment, ref expressions) => {\n-            let types = match segment.parameters {\n+            let types = match segment.args {\n                 Some(ref params) => match **params {\n-                    ast::PathParameters::AngleBracketed(ref data) => &data.types[..],\n+                    ast::GenericArgs::AngleBracketed(ref data) => &data.args[..],\n                     _ => &[],\n                 },\n                 _ => &[],\n@@ -484,7 +485,7 @@ fn is_try(expr: &ast::Expr) -> bool {\n \n fn rewrite_method_call(\n     method_name: ast::Ident,\n-    types: &[ptr::P<ast::Ty>],\n+    types: &[ast::GenericArg],\n     args: &[ptr::P<ast::Expr>],\n     span: Span,\n     context: &RewriteContext,\n@@ -500,7 +501,7 @@ fn rewrite_method_call(\n \n         let type_str = format!(\"::<{}>\", type_list.join(\", \"));\n \n-        (types.last().unwrap().span.hi(), type_str)\n+        (types.last().unwrap().span().hi(), type_str)\n     };\n \n     let callee_str = format!(\".{}{}\", method_name, type_str);"}, {"sha": "b8a323f73a24e464a8201f0f66086d2b776798df", "filename": "src/expr.rs", "status": "modified", "additions": 22, "deletions": 7, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -2014,8 +2014,8 @@ fn rewrite_assignment(\n pub enum RhsTactics {\n     /// Use heuristics.\n     Default,\n-    /// Put the rhs on the next line if it uses multiple line.\n-    ForceNextLine,\n+    /// Put the rhs on the next line if it uses multiple line, without extra indentation.\n+    ForceNextLineWithoutIndent,\n }\n \n // The left hand side must contain everything up to, and including, the\n@@ -2072,11 +2072,12 @@ fn choose_rhs<R: Rewrite>(\n         _ => {\n             // Expression did not fit on the same line as the identifier.\n             // Try splitting the line and see if that works better.\n-            let new_shape =\n-                Shape::indented(shape.indent.block_indent(context.config), context.config)\n-                    .sub_width(shape.rhs_overhead(context.config))?;\n+            let new_shape = shape_from_rhs_tactic(context, shape, rhs_tactics)?;\n             let new_rhs = expr.rewrite(context, new_shape);\n-            let new_indent_str = &new_shape.indent.to_string_with_newline(context.config);\n+            let new_indent_str = &shape\n+                .indent\n+                .block_indent(context.config)\n+                .to_string_with_newline(context.config);\n \n             match (orig_rhs, new_rhs) {\n                 (Some(ref orig_rhs), Some(ref new_rhs))\n@@ -2098,8 +2099,22 @@ fn choose_rhs<R: Rewrite>(\n     }\n }\n \n+fn shape_from_rhs_tactic(\n+    context: &RewriteContext,\n+    shape: Shape,\n+    rhs_tactic: RhsTactics,\n+) -> Option<Shape> {\n+    match rhs_tactic {\n+        RhsTactics::ForceNextLineWithoutIndent => Some(shape.with_max_width(context.config)),\n+        RhsTactics::Default => {\n+            Shape::indented(shape.indent.block_indent(context.config), context.config)\n+                .sub_width(shape.rhs_overhead(context.config))\n+        }\n+    }\n+}\n+\n pub fn prefer_next_line(orig_rhs: &str, next_line_rhs: &str, rhs_tactics: RhsTactics) -> bool {\n-    rhs_tactics == RhsTactics::ForceNextLine\n+    rhs_tactics == RhsTactics::ForceNextLineWithoutIndent\n         || !next_line_rhs.contains('\\n')\n         || count_newlines(orig_rhs) > count_newlines(next_line_rhs) + 1\n }"}, {"sha": "b8639fdd67e127413789443c3f900127e83d7d35", "filename": "src/imports.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fimports.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -346,7 +346,7 @@ impl UseTree {\n                         .collect(),\n                 ));\n             }\n-            UseTreeKind::Simple(ref rename) => {\n+            UseTreeKind::Simple(ref rename, ..) => {\n                 let mut name = (*path_to_imported_ident(&a.prefix).name.as_str()).to_owned();\n                 let alias = rename.and_then(|ident| {\n                     if ident == path_to_imported_ident(&a.prefix) {"}, {"sha": "05ac3a3fe36c0af6b6a06539d8e639db014b5d94", "filename": "src/items.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -36,7 +36,6 @@ use overflow;\n use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use spanned::Spanned;\n-use types::TraitTyParamBounds;\n use utils::*;\n use vertical::rewrite_with_alignment;\n use visitor::FmtVisitor;\n@@ -971,7 +970,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         is_auto,\n         unsafety,\n         ref generics,\n-        ref type_param_bounds,\n+        ref generic_bounds,\n         ref trait_items,\n     ) = item.node\n     {\n@@ -997,23 +996,22 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         result.push_str(&generics_str);\n \n         // FIXME(#2055): rustfmt fails to format when there are comments between trait bounds.\n-        if !type_param_bounds.is_empty() {\n+        if !generic_bounds.is_empty() {\n             let ident_hi = context\n                 .snippet_provider\n                 .span_after(item.span, &format!(\"{}\", item.ident));\n-            let bound_hi = type_param_bounds.last().unwrap().span().hi();\n+            let bound_hi = generic_bounds.last().unwrap().span().hi();\n             let snippet = context.snippet(mk_sp(ident_hi, bound_hi));\n             if contains_comment(snippet) {\n                 return None;\n             }\n-        }\n-        if !type_param_bounds.is_empty() {\n+\n             result = rewrite_assign_rhs_with(\n                 context,\n                 result + \":\",\n-                &TraitTyParamBounds::new(type_param_bounds),\n+                generic_bounds,\n                 shape,\n-                RhsTactics::ForceNextLine,\n+                RhsTactics::ForceNextLineWithoutIndent,\n             )?;\n         }\n \n@@ -1026,10 +1024,10 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n             };\n \n             let where_budget = context.budget(last_line_width(&result));\n-            let pos_before_where = if type_param_bounds.is_empty() {\n+            let pos_before_where = if generic_bounds.is_empty() {\n                 generics.where_clause.span.lo()\n             } else {\n-                type_param_bounds[type_param_bounds.len() - 1].span().hi()\n+                generic_bounds[generic_bounds.len() - 1].span().hi()\n             };\n             let option = WhereClauseOption::snuggled(&generics_str);\n             let where_clause_str = rewrite_where_clause(\n@@ -1134,7 +1132,7 @@ pub fn format_trait_alias(\n     context: &RewriteContext,\n     ident: ast::Ident,\n     generics: &ast::Generics,\n-    ty_param_bounds: &ast::TyParamBounds,\n+    generic_bounds: &ast::GenericBounds,\n     shape: Shape,\n ) -> Option<String> {\n     let alias = ident.name.as_str();\n@@ -1143,7 +1141,7 @@ pub fn format_trait_alias(\n     let generics_str = rewrite_generics(context, &alias, generics, g_shape, generics.span)?;\n     let lhs = format!(\"trait {} =\", generics_str);\n     // 1 = \";\"\n-    rewrite_assign_rhs(context, lhs, ty_param_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n+    rewrite_assign_rhs(context, lhs, generic_bounds, shape.sub_width(1)?).map(|s| s + \";\")\n }\n \n fn format_unit_struct(context: &RewriteContext, p: &StructParts, offset: Indent) -> Option<String> {\n@@ -1671,13 +1669,13 @@ fn rewrite_static(\n pub fn rewrite_associated_type(\n     ident: ast::Ident,\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n-    ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n+    generic_bounds_opt: Option<&ast::GenericBounds>,\n     context: &RewriteContext,\n     indent: Indent,\n ) -> Option<String> {\n     let prefix = format!(\"type {}\", ident);\n \n-    let type_bounds_str = if let Some(bounds) = ty_param_bounds_opt {\n+    let type_bounds_str = if let Some(bounds) = generic_bounds_opt {\n         if bounds.is_empty() {\n             String::new()\n         } else {\n@@ -1703,11 +1701,11 @@ pub fn rewrite_associated_impl_type(\n     ident: ast::Ident,\n     defaultness: ast::Defaultness,\n     ty_opt: Option<&ptr::P<ast::Ty>>,\n-    ty_param_bounds_opt: Option<&ast::TyParamBounds>,\n+    generic_bounds_opt: Option<&ast::GenericBounds>,\n     context: &RewriteContext,\n     indent: Indent,\n ) -> Option<String> {\n-    let result = rewrite_associated_type(ident, ty_opt, ty_param_bounds_opt, context, indent)?;\n+    let result = rewrite_associated_type(ident, ty_opt, generic_bounds_opt, context, indent)?;\n \n     match defaultness {\n         ast::Defaultness::Default => Some(format!(\"default {}\", result)),\n@@ -2698,7 +2696,7 @@ fn format_generics(\n         }\n         // If the generics are not parameterized then generics.span.hi() == 0,\n         // so we use span.lo(), which is the position after `struct Foo`.\n-        let span_end_before_where = if generics.is_parameterized() {\n+        let span_end_before_where = if !generics.params.is_empty() {\n             generics.span.hi()\n         } else {\n             span.lo()\n@@ -2804,15 +2802,6 @@ impl Rewrite for ast::ForeignItem {\n     }\n }\n \n-impl Rewrite for ast::GenericParam {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match *self {\n-            ast::GenericParam::Lifetime(ref lifetime_def) => lifetime_def.rewrite(context, shape),\n-            ast::GenericParam::Type(ref ty) => ty.rewrite(context, shape),\n-        }\n-    }\n-}\n-\n /// Rewrite an inline mod.\n pub fn rewrite_mod(item: &ast::Item) -> String {\n     let mut result = String::with_capacity(32);"}, {"sha": "c2886fcdd8fb4023a007a5036565aa722d8a0cc8", "filename": "src/spanned.rs", "status": "modified", "additions": 28, "deletions": 32, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fspanned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fspanned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fspanned.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -14,6 +14,8 @@ use syntax::codemap::Span;\n use macros::MacroArg;\n use utils::{mk_sp, outer_attributes};\n \n+use std::cmp::max;\n+\n /// Spanned returns a span including attributes, if available.\n pub trait Spanned {\n     fn span(&self) -> Span;\n@@ -110,10 +112,25 @@ impl Spanned for ast::Arg {\n \n impl Spanned for ast::GenericParam {\n     fn span(&self) -> Span {\n-        match *self {\n-            ast::GenericParam::Lifetime(ref lifetime_def) => lifetime_def.span(),\n-            ast::GenericParam::Type(ref ty) => ty.span(),\n-        }\n+        let lo = if self.attrs.is_empty() {\n+            self.ident.span.lo()\n+        } else {\n+            self.attrs[0].span.lo()\n+        };\n+        let hi = if self.bounds.is_empty() {\n+            self.ident.span.hi()\n+        } else {\n+            self.bounds.last().unwrap().span().hi()\n+        };\n+        let ty_hi = if let ast::GenericParamKind::Type {\n+            default: Some(ref ty),\n+        } = self.kind\n+        {\n+            ty.span().hi()\n+        } else {\n+            hi\n+        };\n+        mk_sp(lo, max(hi, ty_hi))\n     }\n }\n \n@@ -142,45 +159,24 @@ impl Spanned for ast::FunctionRetTy {\n     }\n }\n \n-impl Spanned for ast::TyParam {\n+impl Spanned for ast::GenericArg {\n     fn span(&self) -> Span {\n-        // Note that ty.span is the span for ty.ident, not the whole item.\n-        let lo = if self.attrs.is_empty() {\n-            self.ident.span.lo()\n-        } else {\n-            self.attrs[0].span.lo()\n-        };\n-        if let Some(ref def) = self.default {\n-            return mk_sp(lo, def.span.hi());\n-        }\n-        if self.bounds.is_empty() {\n-            return mk_sp(lo, self.ident.span.hi());\n+        match *self {\n+            ast::GenericArg::Lifetime(ref lt) => lt.ident.span,\n+            ast::GenericArg::Type(ref ty) => ty.span(),\n         }\n-        let hi = self.bounds[self.bounds.len() - 1].span().hi();\n-        mk_sp(lo, hi)\n     }\n }\n \n-impl Spanned for ast::TyParamBound {\n+impl Spanned for ast::GenericBound {\n     fn span(&self) -> Span {\n         match *self {\n-            ast::TyParamBound::TraitTyParamBound(ref ptr, _) => ptr.span,\n-            ast::TyParamBound::RegionTyParamBound(ref l) => l.ident.span,\n+            ast::GenericBound::Trait(ref ptr, _) => ptr.span,\n+            ast::GenericBound::Outlives(ref l) => l.ident.span,\n         }\n     }\n }\n \n-impl Spanned for ast::LifetimeDef {\n-    fn span(&self) -> Span {\n-        let hi = if self.bounds.is_empty() {\n-            self.lifetime.ident.span.hi()\n-        } else {\n-            self.bounds[self.bounds.len() - 1].ident.span.hi()\n-        };\n-        mk_sp(self.lifetime.ident.span.lo(), hi)\n-    }\n-}\n-\n impl Spanned for MacroArg {\n     fn span(&self) -> Span {\n         match *self {"}, {"sha": "20c6cebeefdbb21b874884608ddc804d8c02ca9e", "filename": "src/types.rs", "status": "modified", "additions": 45, "deletions": 39, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -148,6 +148,15 @@ enum SegmentParam<'a> {\n     Binding(&'a ast::TypeBinding),\n }\n \n+impl<'a> SegmentParam<'a> {\n+    fn from_generic_arg(arg: &ast::GenericArg) -> SegmentParam {\n+        match arg {\n+            ast::GenericArg::Lifetime(ref lt) => SegmentParam::LifeTime(lt),\n+            ast::GenericArg::Type(ref ty) => SegmentParam::Type(ty),\n+        }\n+    }\n+}\n+\n impl<'a> Spanned for SegmentParam<'a> {\n     fn span(&self) -> Span {\n         match *self {\n@@ -220,18 +229,15 @@ fn rewrite_segment(\n         shape.shrink_left(ident_len)?\n     };\n \n-    if let Some(ref params) = segment.parameters {\n-        match **params {\n-            ast::PathParameters::AngleBracketed(ref data)\n-                if !data.lifetimes.is_empty()\n-                    || !data.types.is_empty()\n-                    || !data.bindings.is_empty() =>\n+    if let Some(ref args) = segment.args {\n+        match **args {\n+            ast::GenericArgs::AngleBracketed(ref data)\n+                if !data.args.is_empty() || !data.bindings.is_empty() =>\n             {\n                 let param_list = data\n-                    .lifetimes\n+                    .args\n                     .iter()\n-                    .map(SegmentParam::LifeTime)\n-                    .chain(data.types.iter().map(|x| SegmentParam::Type(&*x)))\n+                    .map(SegmentParam::from_generic_arg)\n                     .chain(data.bindings.iter().map(|x| SegmentParam::Binding(&*x)))\n                     .collect::<Vec<_>>();\n \n@@ -257,7 +263,7 @@ fn rewrite_segment(\n \n                 result.push_str(&generics_str)\n             }\n-            ast::PathParameters::Parenthesized(ref data) => {\n+            ast::GenericArgs::Parenthesized(ref data) => {\n                 let output = match data.output {\n                     Some(ref ty) => FunctionRetTy::Ty(ty.clone()),\n                     None => FunctionRetTy::Default(codemap::DUMMY_SP),\n@@ -457,15 +463,18 @@ impl Rewrite for ast::WherePredicate {\n     }\n }\n \n-impl Rewrite for ast::LifetimeDef {\n+impl Rewrite for ast::GenericArg {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        rewrite_bounded_lifetime(&self.lifetime, &self.bounds, context, shape)\n+        match *self {\n+            ast::GenericArg::Lifetime(ref lt) => lt.rewrite(context, shape),\n+            ast::GenericArg::Type(ref ty) => ty.rewrite(context, shape),\n+        }\n     }\n }\n \n fn rewrite_bounded_lifetime(\n     lt: &ast::Lifetime,\n-    bounds: &[ast::Lifetime],\n+    bounds: &[ast::GenericBound],\n     context: &RewriteContext,\n     shape: Shape,\n ) -> Option<String> {\n@@ -486,45 +495,36 @@ fn rewrite_bounded_lifetime(\n     }\n }\n \n-impl Rewrite for ast::TyParamBound {\n-    fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        match *self {\n-            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::None) => {\n-                tref.rewrite(context, shape)\n-            }\n-            ast::TyParamBound::TraitTyParamBound(ref tref, ast::TraitBoundModifier::Maybe) => Some(\n-                format!(\"?{}\", tref.rewrite(context, shape.offset_left(1)?)?),\n-            ),\n-            ast::TyParamBound::RegionTyParamBound(ref l) => l.rewrite(context, shape),\n-        }\n-    }\n-}\n-\n impl Rewrite for ast::Lifetime {\n     fn rewrite(&self, _: &RewriteContext, _: Shape) -> Option<String> {\n         Some(self.ident.to_string())\n     }\n }\n \n-/// A simple wrapper over type param bounds in trait.\n-#[derive(new)]\n-pub struct TraitTyParamBounds<'a> {\n-    inner: &'a ast::TyParamBounds,\n-}\n-\n-impl<'a> Rewrite for TraitTyParamBounds<'a> {\n+impl Rewrite for ast::GenericBound {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        join_bounds(context, shape, self.inner, false)\n+        match *self {\n+            ast::GenericBound::Trait(ref poly_trait_ref, trait_bound_modifier) => {\n+                match trait_bound_modifier {\n+                    ast::TraitBoundModifier::None => poly_trait_ref.rewrite(context, shape),\n+                    ast::TraitBoundModifier::Maybe => {\n+                        let rw = poly_trait_ref.rewrite(context, shape.offset_left(1)?)?;\n+                        Some(format!(\"?{}\", rw))\n+                    }\n+                }\n+            }\n+            ast::GenericBound::Outlives(ref lifetime) => lifetime.rewrite(context, shape),\n+        }\n     }\n }\n \n-impl Rewrite for ast::TyParamBounds {\n+impl Rewrite for ast::GenericBounds {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         join_bounds(context, shape, self, true)\n     }\n }\n \n-impl Rewrite for ast::TyParam {\n+impl Rewrite for ast::GenericParam {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n         let mut result = String::with_capacity(128);\n         // FIXME: If there are more than one attributes, this will force multiline.\n@@ -537,7 +537,10 @@ impl Rewrite for ast::TyParam {\n             result.push_str(type_bound_colon(context));\n             result.push_str(&self.bounds.rewrite(context, shape)?)\n         }\n-        if let Some(ref def) = self.default {\n+        if let ast::GenericParamKind::Type {\n+            default: Some(ref def),\n+        } = self.kind\n+        {\n             let eq_str = match context.config.type_punctuation_density() {\n                 TypeDensity::Compressed => \"=\",\n                 TypeDensity::Wide => \" = \",\n@@ -786,7 +789,10 @@ fn rewrite_lifetime_param(\n ) -> Option<String> {\n     let result = generic_params\n         .iter()\n-        .filter(|p| p.is_lifetime_param())\n+        .filter(|p| match p.kind {\n+            ast::GenericParamKind::Lifetime => true,\n+            _ => false,\n+        })\n         .map(|lt| lt.rewrite(context, shape))\n         .collect::<Option<Vec<_>>>()?\n         .join(\", \");"}, {"sha": "c58122025de7d37dad91502cf25550255c4a34da", "filename": "src/visitor.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=e5e1e0cea8c3a2b10dbad4cce7d79d7c24f8364b", "patch": "@@ -354,13 +354,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                 let rw = format_trait(&self.get_context(), item, self.block_indent);\n                 self.push_rewrite(item.span, rw);\n             }\n-            ast::ItemKind::TraitAlias(ref generics, ref ty_param_bounds) => {\n+            ast::ItemKind::TraitAlias(ref generics, ref generic_bounds) => {\n                 let shape = Shape::indented(self.block_indent, self.config);\n                 let rw = format_trait_alias(\n                     &self.get_context(),\n                     item.ident,\n                     generics,\n-                    ty_param_bounds,\n+                    generic_bounds,\n                     shape,\n                 );\n                 self.push_rewrite(item.span, rw);\n@@ -461,11 +461,11 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     Some(&inner_attrs),\n                 );\n             }\n-            ast::TraitItemKind::Type(ref type_param_bounds, ref type_default) => {\n+            ast::TraitItemKind::Type(ref generic_bounds, ref type_default) => {\n                 let rewrite = rewrite_associated_type(\n                     ti.ident,\n                     type_default.as_ref(),\n-                    Some(type_param_bounds),\n+                    Some(generic_bounds),\n                     &self.get_context(),\n                     self.block_indent,\n                 );"}]}