{"sha": "46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZmQzMzNkYWE4ZGM3MWYxYzYxYWE4N2VjYmY5ODgxZmFlOTIwYzY=", "commit": {"author": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-18T22:39:53Z"}, "committer": {"name": "Vytautas Astrauskas", "email": "astrauv@amazon.com", "date": "2020-04-27T21:26:36Z"}, "message": "Implement thread::yield_now.", "tree": {"sha": "a0f17365e602e4d1b55384197c1ab5e6d787c43f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a0f17365e602e4d1b55384197c1ab5e6d787c43f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "html_url": "https://github.com/rust-lang/rust/commit/46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/comments", "author": null, "committer": null, "parents": [{"sha": "134533d066a4ab57d1a3e7ed9590052db313b5e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/134533d066a4ab57d1a3e7ed9590052db313b5e6", "html_url": "https://github.com/rust-lang/rust/commit/134533d066a4ab57d1a3e7ed9590052db313b5e6"}], "stats": {"total": 45, "additions": 40, "deletions": 5}, "files": [{"sha": "4574d203efb7972b9470e88f30f3b1fd7f499020", "filename": "src/shims/foreign_items/posix.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fshims%2Fforeign_items%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fshims%2Fforeign_items%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items%2Fposix.rs?ref=46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "patch": "@@ -318,6 +318,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let result = this.prctl(args[0], args[1], args[2], args[3], args[4])?;\n                 this.write_scalar(Scalar::from_i32(result), dest)?;\n             }\n+            \"sched_yield\" => {\n+                assert_eq!(args.len(), 0);\n+                let result = this.sched_yield()?;\n+                this.write_scalar(Scalar::from_i32(result), dest)?;\n+            }\n \n             // Miscellaneous\n             \"isatty\" => {"}, {"sha": "ccdf6df3f9d6f76dfb3c43a28d3cba0228e04b4f", "filename": "src/shims/thread.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fshims%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fshims%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fthread.rs?ref=46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "patch": "@@ -111,4 +111,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         Ok(0)\n     }\n+\n+    fn sched_yield(&mut self) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        this.yield_active_thread()?;\n+\n+        Ok(0)\n+    }\n }"}, {"sha": "31296ad96ff0ff3b2b6a6b62024f98d91b320141", "filename": "src/thread.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46fd333daa8dc71f1c61aa87ecbf9881fae920c6/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=46fd333daa8dc71f1c61aa87ecbf9881fae920c6", "patch": "@@ -143,6 +143,8 @@ pub struct ThreadManager<'mir, 'tcx> {\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n     thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), AllocId>>,\n+    /// A flag that indicates that we should change the active thread.\n+    yield_active_thread: bool,\n }\n \n impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n@@ -154,6 +156,7 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n             threads: threads,\n             blockset_counter: 0,\n             thread_local_alloc_ids: Default::default(),\n+            yield_active_thread: false,\n         }\n     }\n }\n@@ -275,6 +278,11 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n         None\n     }\n \n+    /// Change the active thread to some enabled thread.\n+    fn yield_active_thread(&mut self) {\n+        self.yield_active_thread = true;\n+    }\n+\n     /// Decide which action to take next and on which thread.\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         if self.threads[self.active_thread].check_terminated() {\n@@ -287,13 +295,21 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n             }\n             return Ok(SchedulingAction::ExecuteDtors);\n         }\n-        if self.threads[self.active_thread].state == ThreadState::Enabled {\n+        if self.threads[self.active_thread].state == ThreadState::Enabled\n+            && !self.yield_active_thread\n+        {\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n-        if let Some(enabled_thread) =\n-            self.threads.iter().position(|thread| thread.state == ThreadState::Enabled)\n-        {\n-            self.active_thread = ThreadId::new(enabled_thread);\n+        for (id, thread) in self.threads.iter_enumerated() {\n+            if thread.state == ThreadState::Enabled {\n+                if !(self.yield_active_thread && id == self.active_thread) {\n+                    self.active_thread = id;\n+                    break;\n+                }\n+            }\n+        }\n+        self.yield_active_thread = false;\n+        if self.threads[self.active_thread].state == ThreadState::Enabled {\n             return Ok(SchedulingAction::ExecuteStep);\n         }\n         if self.threads.iter().all(|thread| thread.state == ThreadState::Terminated) {\n@@ -453,6 +469,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(this.machine.threads.unblock_random_thread(set))\n     }\n \n+    fn yield_active_thread(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        this.machine.threads.yield_active_thread();\n+        Ok(())\n+    }\n+\n     /// Decide which action to take next and on which thread.\n     fn schedule(&mut self) -> InterpResult<'tcx, SchedulingAction> {\n         let this = self.eval_context_mut();"}]}