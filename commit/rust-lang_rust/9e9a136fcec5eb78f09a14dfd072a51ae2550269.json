{"sha": "9e9a136fcec5eb78f09a14dfd072a51ae2550269", "node_id": "MDY6Q29tbWl0NzI0NzEyOjllOWExMzZmY2VjNWViNzhmMDlhMTRkZmQwNzJhNTFhZTI1NTAyNjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T00:32:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-08-15T00:32:05Z"}, "message": "Auto merge of #63575 - Centril:rollup-anlv9g5, r=Centril\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #62984 (Add lint for excess trailing semicolons)\n - #63075 (Miri: Check that a ptr is aligned and inbounds already when evaluating `*`)\n - #63490 (libsyntax: cleanup and refactor `pat.rs`)\n - #63507 (When needing type annotations in local bindings, account for impl Trait and closures)\n - #63509 (Point at the right enclosing scope when using `await` in non-async fn)\n - #63528 (syntax: Remove `DummyResult::expr_only`)\n - #63537 (expand: Unimplement `MutVisitor` on `MacroExpander`)\n - #63542 (Add NodeId for Arm, Field and FieldPat)\n - #63543 (Merge Variant and Variant_)\n - #63560 (move test that shouldn't be in test/run-pass/)\n - #63570 (Adjust tracking issues for `MaybeUninit<T>` gates)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "b193fe082d78583740df368de6f546ca35890cbb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b193fe082d78583740df368de6f546ca35890cbb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9e9a136fcec5eb78f09a14dfd072a51ae2550269", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9e9a136fcec5eb78f09a14dfd072a51ae2550269", "html_url": "https://github.com/rust-lang/rust/commit/9e9a136fcec5eb78f09a14dfd072a51ae2550269", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9e9a136fcec5eb78f09a14dfd072a51ae2550269/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "082cf2f9d136166cd1d552d3fb5abb1c46c99a14", "url": "https://api.github.com/repos/rust-lang/rust/commits/082cf2f9d136166cd1d552d3fb5abb1c46c99a14", "html_url": "https://github.com/rust-lang/rust/commit/082cf2f9d136166cd1d552d3fb5abb1c46c99a14"}, {"sha": "78cd9d1fd5cd59fbab62325b1bcb4bb21c2cb30a", "url": "https://api.github.com/repos/rust-lang/rust/commits/78cd9d1fd5cd59fbab62325b1bcb4bb21c2cb30a", "html_url": "https://github.com/rust-lang/rust/commit/78cd9d1fd5cd59fbab62325b1bcb4bb21c2cb30a"}], "stats": {"total": 1635, "additions": 1077, "deletions": 558}, "files": [{"sha": "9e9e901c76d3ff0d02213e27f5677873c6eabe02", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -312,7 +312,7 @@ impl<T> MaybeUninit<T> {\n     /// without dropping it, so be careful not to use this twice unless you want to\n     /// skip running the destructor. For your convenience, this also returns a mutable\n     /// reference to the (now safely initialized) contents of `self`.\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub fn write(&mut self, val: T) -> &mut T {\n         unsafe {\n@@ -502,7 +502,7 @@ impl<T> MaybeUninit<T> {\n     /// // We now created two copies of the same vector, leading to a double-free when\n     /// // they both get dropped!\n     /// ```\n-    #[unstable(feature = \"maybe_uninit_extra\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_extra\", issue = \"63567\")]\n     #[inline(always)]\n     pub unsafe fn read(&self) -> T {\n         intrinsics::panic_if_uninhabited::<T>();\n@@ -516,7 +516,7 @@ impl<T> MaybeUninit<T> {\n     /// It is up to the caller to guarantee that the `MaybeUninit<T>` really is in an initialized\n     /// state. Calling this when the content is not yet fully initialized causes undefined\n     /// behavior.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_ref(&self) -> &T {\n         &*self.value\n@@ -532,21 +532,21 @@ impl<T> MaybeUninit<T> {\n     // FIXME(#53491): We currently rely on the above being incorrect, i.e., we have references\n     // to uninitialized data (e.g., in `libcore/fmt/float.rs`).  We should make\n     // a final decision about the rules before stabilization.\n-    #[unstable(feature = \"maybe_uninit_ref\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_ref\", issue = \"63568\")]\n     #[inline(always)]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut *self.value\n     }\n \n     /// Gets a pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr(this: &[MaybeUninit<T>]) -> *const T {\n         this as *const [MaybeUninit<T>] as *const T\n     }\n \n     /// Gets a mutable pointer to the first element of the array.\n-    #[unstable(feature = \"maybe_uninit_slice\", issue = \"53491\")]\n+    #[unstable(feature = \"maybe_uninit_slice\", issue = \"63569\")]\n     #[inline(always)]\n     pub fn first_ptr_mut(this: &mut [MaybeUninit<T>]) -> *mut T {\n         this as *mut [MaybeUninit<T>] as *mut T"}, {"sha": "eae956c978a8e08823b46cc2c1b98c1b8e769175", "filename": "src/librustc/hir/check_attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fcheck_attr.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -336,7 +336,7 @@ impl Visitor<'tcx> for CheckAttrVisitor<'tcx> {\n fn is_c_like_enum(item: &hir::Item) -> bool {\n     if let hir::ItemKind::Enum(ref def, _) = item.node {\n         for variant in &def.variants {\n-            match variant.node.data {\n+            match variant.data {\n                 hir::VariantData::Unit(..) => { /* continue */ }\n                 _ => { return false; }\n             }"}, {"sha": "71d7464540a4c158153fd29ac6b77df7abd18d99", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -577,15 +577,15 @@ pub fn walk_variant<'v, V: Visitor<'v>>(visitor: &mut V,\n                                         variant: &'v Variant,\n                                         generics: &'v Generics,\n                                         parent_item_id: HirId) {\n-    visitor.visit_ident(variant.node.ident);\n-    visitor.visit_id(variant.node.id);\n-    visitor.visit_variant_data(&variant.node.data,\n-                               variant.node.ident.name,\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_id(variant.id);\n+    visitor.visit_variant_data(&variant.data,\n+                               variant.ident.name,\n                                generics,\n                                parent_item_id,\n                                variant.span);\n-    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {"}, {"sha": "e3a5400942d1a625363e06698b7654f77d340c1c", "filename": "src/librustc/hir/lowering/expr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fexpr.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -677,6 +677,7 @@ impl LoweringContext<'_> {\n         let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n         self.with_new_scopes(|this| {\n+            let prev = this.current_item;\n             this.current_item = Some(fn_decl_span);\n             let mut generator_kind = None;\n             let body_id = this.lower_fn_body(decl, |this| {\n@@ -690,8 +691,10 @@ impl LoweringContext<'_> {\n                 generator_kind,\n                 movability,\n             );\n+            let capture_clause = this.lower_capture_clause(capture_clause);\n+            this.current_item = prev;\n             hir::ExprKind::Closure(\n-                this.lower_capture_clause(capture_clause),\n+                capture_clause,\n                 fn_decl,\n                 body_id,\n                 fn_decl_span,"}, {"sha": "51a0c4184f9ef86ffd455ff507d5ea0516404fc4", "filename": "src/librustc/hir/lowering/item.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering%2Fitem.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -757,14 +757,12 @@ impl LoweringContext<'_> {\n     }\n \n     fn lower_variant(&mut self, v: &Variant) -> hir::Variant {\n-        Spanned {\n-            node: hir::VariantKind {\n-                ident: v.node.ident,\n-                id: self.lower_node_id(v.node.id),\n-                attrs: self.lower_attrs(&v.node.attrs),\n-                data: self.lower_variant_data(&v.node.data),\n-                disr_expr: v.node.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n-            },\n+        hir::Variant {\n+            attrs: self.lower_attrs(&v.attrs),\n+            data: self.lower_variant_data(&v.data),\n+            disr_expr: v.disr_expr.as_ref().map(|e| self.lower_anon_const(e)),\n+            id: self.lower_node_id(v.id),\n+            ident: v.ident,\n             span: v.span,\n         }\n     }"}, {"sha": "effe2c0cc6a76f1dde4be58fa7b145fbc3fdad90", "filename": "src/librustc/hir/map/collector.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fcollector.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -544,11 +544,11 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n     }\n \n     fn visit_variant(&mut self, v: &'hir Variant, g: &'hir Generics, item_id: HirId) {\n-        self.insert(v.span, v.node.id, Node::Variant(v));\n-        self.with_parent(v.node.id, |this| {\n+        self.insert(v.span, v.id, Node::Variant(v));\n+        self.with_parent(v.id, |this| {\n             // Register the constructor of this variant.\n-            if let Some(ctor_hir_id) = v.node.data.ctor_hir_id() {\n-                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.node.data));\n+            if let Some(ctor_hir_id) = v.data.ctor_hir_id() {\n+                this.insert(v.span, ctor_hir_id, Node::Ctor(&v.data));\n             }\n             intravisit::walk_variant(this, v, g, item_id);\n         });"}, {"sha": "df9bd3a35a6219db4aca1c4e778cfd12f2b07023", "filename": "src/librustc/hir/map/def_collector.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fdef_collector.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -155,11 +155,11 @@ impl<'a> visit::Visitor<'a> for DefCollector<'a> {\n     }\n \n     fn visit_variant(&mut self, v: &'a Variant, g: &'a Generics, item_id: NodeId) {\n-        let def = self.create_def(v.node.id,\n-                                  DefPathData::TypeNs(v.node.ident.as_interned_str()),\n+        let def = self.create_def(v.id,\n+                                  DefPathData::TypeNs(v.ident.as_interned_str()),\n                                   v.span);\n         self.with_parent(def, |this| {\n-            if let Some(ctor_hir_id) = v.node.data.ctor_id() {\n+            if let Some(ctor_hir_id) = v.data.ctor_id() {\n                 this.create_def(ctor_hir_id, DefPathData::Ctor, v.span);\n             }\n             visit::walk_variant(this, v, g, item_id)"}, {"sha": "7292428ec378c62be57090a7e2d7e2532d80e265", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -649,12 +649,34 @@ impl<'hir> Map<'hir> {\n         }\n     }\n \n-    pub fn is_const_scope(&self, hir_id: HirId) -> bool {\n-        self.walk_parent_nodes(hir_id, |node| match *node {\n-            Node::Item(Item { node: ItemKind::Const(_, _), .. }) => true,\n-            Node::Item(Item { node: ItemKind::Fn(_, header, _, _), .. }) => header.is_const(),\n+    /// Whether the expression pointed at by `hir_id` belongs to a `const` evaluation context.\n+    /// Used exclusively for diagnostics, to avoid suggestion function calls.\n+    pub fn is_const_context(&self, hir_id: HirId) -> bool {\n+        let parent_id = self.get_parent_item(hir_id);\n+        match self.get(parent_id) {\n+            Node::Item(&Item {\n+                node: ItemKind::Const(..),\n+                ..\n+            })\n+            | Node::TraitItem(&TraitItem {\n+                node: TraitItemKind::Const(..),\n+                ..\n+            })\n+            | Node::ImplItem(&ImplItem {\n+                node: ImplItemKind::Const(..),\n+                ..\n+            })\n+            | Node::AnonConst(_)\n+            | Node::Item(&Item {\n+                node: ItemKind::Static(..),\n+                ..\n+            }) => true,\n+            Node::Item(&Item {\n+                node: ItemKind::Fn(_, header, ..),\n+                ..\n+            }) => header.constness == Constness::Const,\n             _ => false,\n-        }, |_| false).map(|id| id != CRATE_HIR_ID).unwrap_or(false)\n+        }\n     }\n \n     /// If there is some error when walking the parents (e.g., a node does not\n@@ -885,7 +907,7 @@ impl<'hir> Map<'hir> {\n                     _ => bug!(\"struct ID bound to non-struct {}\", self.node_to_string(id))\n                 }\n             }\n-            Some(Node::Variant(variant)) => &variant.node.data,\n+            Some(Node::Variant(variant)) => &variant.data,\n             Some(Node::Ctor(data)) => data,\n             _ => bug!(\"expected struct or variant, found {}\", self.node_to_string(id))\n         }\n@@ -918,7 +940,7 @@ impl<'hir> Map<'hir> {\n             Node::ForeignItem(fi) => fi.ident.name,\n             Node::ImplItem(ii) => ii.ident.name,\n             Node::TraitItem(ti) => ti.ident.name,\n-            Node::Variant(v) => v.node.ident.name,\n+            Node::Variant(v) => v.ident.name,\n             Node::Field(f) => f.ident.name,\n             Node::Lifetime(lt) => lt.name.ident().name,\n             Node::GenericParam(param) => param.name.ident().name,\n@@ -939,7 +961,7 @@ impl<'hir> Map<'hir> {\n             Some(Node::ForeignItem(fi)) => Some(&fi.attrs[..]),\n             Some(Node::TraitItem(ref ti)) => Some(&ti.attrs[..]),\n             Some(Node::ImplItem(ref ii)) => Some(&ii.attrs[..]),\n-            Some(Node::Variant(ref v)) => Some(&v.node.attrs[..]),\n+            Some(Node::Variant(ref v)) => Some(&v.attrs[..]),\n             Some(Node::Field(ref f)) => Some(&f.attrs[..]),\n             Some(Node::Expr(ref e)) => Some(&*e.attrs),\n             Some(Node::Stmt(ref s)) => Some(s.node.attrs()),\n@@ -1133,7 +1155,7 @@ impl<T:Named> Named for Spanned<T> { fn name(&self) -> Name { self.node.name() }\n \n impl Named for Item { fn name(&self) -> Name { self.ident.name } }\n impl Named for ForeignItem { fn name(&self) -> Name { self.ident.name } }\n-impl Named for VariantKind { fn name(&self) -> Name { self.ident.name } }\n+impl Named for Variant { fn name(&self) -> Name { self.ident.name } }\n impl Named for StructField { fn name(&self) -> Name { self.ident.name } }\n impl Named for TraitItem { fn name(&self) -> Name { self.ident.name } }\n impl Named for ImplItem { fn name(&self) -> Name { self.ident.name } }\n@@ -1310,7 +1332,7 @@ fn hir_id_to_string(map: &Map<'_>, id: HirId, include_id: bool) -> String {\n         }\n         Some(Node::Variant(ref variant)) => {\n             format!(\"variant {} in {}{}\",\n-                    variant.node.ident,\n+                    variant.ident,\n                     path_str(), id_str)\n         }\n         Some(Node::Field(ref field)) => {"}, {"sha": "dccc2774f5261e4ebe1f003bb707c4c51131879c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1541,7 +1541,7 @@ pub enum ExprKind {\n     Match(P<Expr>, HirVec<Arm>, MatchSource),\n     /// A closure (e.g., `move |a, b, c| {a + b + c}`).\n     ///\n-    /// The final span is the span of the argument block `|...|`.\n+    /// The `Span` is the argument block `|...|`.\n     ///\n     /// This may also be a generator literal or an `async block` as indicated by the\n     /// `Option<GeneratorMovability>`.\n@@ -2193,7 +2193,7 @@ pub struct EnumDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable, Debug, HashStable)]\n-pub struct VariantKind {\n+pub struct Variant {\n     /// Name of the variant.\n     #[stable_hasher(project(name))]\n     pub ident: Ident,\n@@ -2205,10 +2205,10 @@ pub struct VariantKind {\n     pub data: VariantData,\n     /// Explicit discriminant (e.g., `Foo = 1`).\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span\n }\n \n-pub type Variant = Spanned<VariantKind>;\n-\n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, HashStable)]\n pub enum UseKind {\n     /// One import, e.g., `use foo::bar` or `use foo::bar as baz`."}, {"sha": "0cbfe4d75f1c626bad184b9506579db47fc80f7b", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -737,7 +737,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.node.attrs);\n+            self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -829,8 +829,8 @@ impl<'a> State<'a> {\n     pub fn print_variant(&mut self, v: &hir::Variant) {\n         self.head(\"\");\n         let generics = hir::Generics::empty();\n-        self.print_struct(&v.node.data, &generics, v.node.ident.name, v.span, false);\n-        if let Some(ref d) = v.node.disr_expr {\n+        self.print_struct(&v.data, &generics, v.ident.name, v.span, false);\n+        if let Some(ref d) = v.disr_expr {\n             self.s.space();\n             self.word_space(\"=\");\n             self.print_anon_const(d);"}, {"sha": "1fd4e00de497f40738f8bb5907482e5c8615ce90", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -304,7 +304,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for hir::Mod {\n     }\n }\n \n-impl_stable_hash_for_spanned!(hir::VariantKind);\n+impl_stable_hash_for_spanned!(hir::Variant);\n \n \n impl<'a> HashStable<StableHashingContext<'a>> for hir::Item {"}, {"sha": "3267505708b8100dfcee4e45cf7fc2423828e423", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 161, "deletions": 51, "changes": 212, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1,13 +1,13 @@\n use crate::hir::def::Namespace;\n-use crate::hir::{self, Local, Pat, Body, HirId};\n+use crate::hir::{self, Body, FunctionRetTy, Expr, ExprKind, HirId, Local, Pat};\n use crate::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use crate::infer::InferCtxt;\n use crate::infer::type_variable::TypeVariableOriginKind;\n use crate::ty::{self, Ty, Infer, TyVar};\n use crate::ty::print::Print;\n use syntax::source_map::DesugaringKind;\n use syntax_pos::Span;\n-use errors::DiagnosticBuilder;\n+use errors::{Applicability, DiagnosticBuilder};\n \n struct FindLocalByTypeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n@@ -16,9 +16,26 @@ struct FindLocalByTypeVisitor<'a, 'tcx> {\n     found_local_pattern: Option<&'tcx Pat>,\n     found_arg_pattern: Option<&'tcx Pat>,\n     found_ty: Option<Ty<'tcx>>,\n+    found_closure: Option<&'tcx ExprKind>,\n }\n \n impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n+    fn new(\n+        infcx: &'a InferCtxt<'a, 'tcx>,\n+        target_ty: Ty<'tcx>,\n+        hir_map: &'a hir::map::Map<'tcx>,\n+    ) -> Self {\n+        Self {\n+            infcx,\n+            target_ty,\n+            hir_map,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n+            found_ty: None,\n+            found_closure: None,\n+        }\n+    }\n+\n     fn node_matches_type(&mut self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         let ty_opt = self.infcx.in_progress_tables.and_then(|tables| {\n             tables.borrow().node_type_opt(hir_id)\n@@ -72,6 +89,60 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n         }\n         intravisit::walk_body(self, body);\n     }\n+\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let (ExprKind::Closure(_, _fn_decl, _id, _sp, _), Some(_)) = (\n+            &expr.node,\n+            self.node_matches_type(expr.hir_id),\n+        ) {\n+            self.found_closure = Some(&expr.node);\n+        }\n+        intravisit::walk_expr(self, expr);\n+    }\n+}\n+\n+/// Suggest giving an appropriate return type to a closure expression.\n+fn closure_return_type_suggestion(\n+    span: Span,\n+    err: &mut DiagnosticBuilder<'_>,\n+    output: &FunctionRetTy,\n+    body: &Body,\n+    name: &str,\n+    ret: &str,\n+) {\n+    let (arrow, post) = match output {\n+        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+        _ => (\"\", \"\"),\n+    };\n+    let suggestion = match body.value.node {\n+        ExprKind::Block(..) => {\n+            vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+        }\n+        _ => {\n+            vec![\n+                (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+            ]\n+        }\n+    };\n+    err.multipart_suggestion(\n+        \"give this closure an explicit return type without `_` placeholders\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+}\n+\n+/// Given a closure signature, return a `String` containing a list of all its argument types.\n+fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n+    fn_sig.inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| args.tuple_fields()\n+            .map(|arg| arg.to_string())\n+            .collect::<Vec<_>>().join(\", \"))\n+        .unwrap_or_default()\n }\n \n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n@@ -106,16 +177,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty, None);\n \n-        let mut err_span = span;\n-\n-        let mut local_visitor = FindLocalByTypeVisitor {\n-            infcx: &self,\n-            target_ty: ty,\n-            hir_map: &self.tcx.hir(),\n-            found_local_pattern: None,\n-            found_arg_pattern: None,\n-            found_ty: None,\n-        };\n+        let mut local_visitor = FindLocalByTypeVisitor::new(&self, ty, &self.tcx.hir());\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -136,6 +198,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             let expr = self.tcx.hir().expect_expr(body_id.hir_id);\n             local_visitor.visit_expr(expr);\n         }\n+        let err_span = if let Some(pattern) = local_visitor.found_arg_pattern {\n+            pattern.span\n+        } else {\n+            span\n+        };\n+\n+        let is_named_and_not_impl_trait = |ty: Ty<'_>| {\n+            &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n+        };\n+\n+        let ty_msg = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let args = closure_args(&fn_sig);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+                format!(\" for the closure `fn({}) -> {}`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+                let ty = ty_to_string(ty);\n+                format!(\" for `{}`\", ty)\n+            }\n+            _ => String::new(),\n+        };\n \n         // When `name` corresponds to a type argument, show the path of the full type we're\n         // trying to infer. In the following example, `ty_msg` contains\n@@ -150,27 +237,58 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         //   |         consider giving `b` the explicit type `std::result::Result<i32, E>`, where\n         //   |         the type parameter `E` is specified\n         // ```\n-        let (ty_msg, suffix) = match &local_visitor.found_ty {\n-            Some(ty) if &ty.to_string() != \"_\" && name == \"_\" => {\n+        let mut err = struct_span_err!(\n+            self.tcx.sess,\n+            err_span,\n+            E0282,\n+            \"type annotations needed{}\",\n+            ty_msg,\n+        );\n+\n+        let suffix = match local_visitor.found_ty {\n+            Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n+                let fn_sig = substs.closure_sig(*def_id, self.tcx);\n+                let ret = fn_sig.output().skip_binder().to_string();\n+\n+                if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n+                    if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n+                        closure_return_type_suggestion(\n+                            span,\n+                            &mut err,\n+                            &decl.output,\n+                            &body,\n+                            &name,\n+                            &ret,\n+                        );\n+                        // We don't want to give the other suggestions when the problem is the\n+                        // closure return type.\n+                        return err;\n+                    }\n+                }\n+\n+                // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n+                let args = closure_args(&fn_sig);\n+                // This suggestion is incomplete, as the user will get further type inference\n+                // errors due to the `_` placeholders and the introduction of `Box`, but it does\n+                // nudge them in the right direction.\n+                format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n+            }\n+            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\"the explicit type `{}`, with the type parameters specified\", ty))\n+                format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" && ty.to_string() != name => {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n                 let ty = ty_to_string(ty);\n-                (format!(\" for `{}`\", ty),\n-                 format!(\n-                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n+                format!(\n+                    \"the explicit type `{}`, where the type parameter `{}` is specified\",\n                     ty,\n                     name,\n-                 ))\n+                )\n             }\n-            _ => (String::new(), \"a type\".to_owned()),\n+            _ => \"a type\".to_string(),\n         };\n-        let mut labels = vec![(span, InferCtxt::missing_type_msg(&name))];\n \n         if let Some(pattern) = local_visitor.found_arg_pattern {\n-            err_span = pattern.span;\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:\n@@ -187,39 +305,31 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             //          ^ consider giving this closure parameter the type `[_; 0]`\n             //            with the type parameter `_` specified\n             // ```\n-            labels.clear();\n-            labels.push((\n+            err.span_label(\n                 pattern.span,\n                 format!(\"consider giving this closure parameter {}\", suffix),\n-            ));\n+            );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_ident) = pattern.simple_ident() {\n+            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n-                    None => labels.push((\n-                        pattern.span,\n-                        format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                    )),\n-                    Some(DesugaringKind::ForLoop) => labels.push((\n-                        pattern.span,\n-                        \"the element type for this iterator is not specified\".to_owned(),\n-                    )),\n-                    _ => {}\n+                    None => {\n+                        format!(\"consider giving `{}` {}\", simple_ident, suffix)\n+                    }\n+                    Some(DesugaringKind::ForLoop) => {\n+                        \"the element type for this iterator is not specified\".to_string()\n+                    }\n+                    _ => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n-                labels.push((pattern.span, format!(\"consider giving this pattern {}\", suffix)));\n-            }\n-        };\n-\n-        let mut err = struct_span_err!(\n-            self.tcx.sess,\n-            err_span,\n-            E0282,\n-            \"type annotations needed{}\",\n-            ty_msg,\n-        );\n-\n-        for (target_span, label_message) in labels {\n-            err.span_label(target_span, label_message);\n+                format!(\"consider giving this pattern {}\", suffix)\n+            };\n+            err.span_label(pattern.span, msg);\n+        }\n+        if !err.span.span_labels().iter().any(|span_label| {\n+                span_label.label.is_some() && span_label.span == span\n+            }) && local_visitor.found_arg_pattern.is_none()\n+        { // Avoid multiple labels pointing at `span`.\n+            err.span_label(span, InferCtxt::missing_type_msg(&name));\n         }\n \n         err"}, {"sha": "1b73361dcd407e28776b0e01283989ba57133aff", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1060,7 +1060,7 @@ for LateContextAndPass<'a, 'tcx, T> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n             lint_callback!(cx, check_variant, v, g);\n             hir_visit::walk_variant(cx, v, g, item_id);\n             lint_callback!(cx, check_variant_post, v, g);\n@@ -1236,7 +1236,7 @@ impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T>\n     }\n \n     fn visit_variant(&mut self, v: &'a ast::Variant, g: &'a ast::Generics, item_id: ast::NodeId) {\n-        self.with_lint_attrs(item_id, &v.node.attrs, |cx| {\n+        self.with_lint_attrs(item_id, &v.attrs, |cx| {\n             run_early_pass!(cx, check_variant, v, g);\n             ast_visit::walk_variant(cx, v, g, item_id);\n             run_early_pass!(cx, check_variant_post, v, g);"}, {"sha": "8cb5b1e26d947dfe61f642768aa30423654b6f3b", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -846,7 +846,7 @@ impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        self.with_lint_attrs(v.node.id, &v.node.attrs, |builder| {\n+        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n             intravisit::walk_variant(builder, v, g, item_id);\n         })\n     }"}, {"sha": "1f3adf00923676f164c23c68e46e46fbe0b2e20a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -366,12 +366,12 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref enum_def, _) => {\n                 if allow_dead_code {\n-                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.node.id));\n+                    self.worklist.extend(enum_def.variants.iter().map(|variant| variant.id));\n                 }\n \n                 for variant in &enum_def.variants {\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n-                        self.struct_constructors.insert(ctor_hir_id, variant.node.id);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n+                        self.struct_constructors.insert(ctor_hir_id, variant.id);\n                     }\n                 }\n             }\n@@ -497,7 +497,7 @@ impl DeadVisitor<'tcx> {\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.hir_id, &field.attrs)\n     }\n \n-    fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n+    fn should_warn_about_variant(&mut self, variant: &hir::Variant) -> bool {\n         !self.symbol_is_live(variant.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.id,\n@@ -596,8 +596,8 @@ impl Visitor<'tcx> for DeadVisitor<'tcx> {\n                      variant: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      id: hir::HirId) {\n-        if self.should_warn_about_variant(&variant.node) {\n-            self.warn_dead_code(variant.node.id, variant.span, variant.node.ident.name,\n+        if self.should_warn_about_variant(&variant) {\n+            self.warn_dead_code(variant.id, variant.span, variant.ident.name,\n                                 \"variant\", \"constructed\");\n         } else {\n             intravisit::walk_variant(self, variant, g, id);"}, {"sha": "d02259bf3010b48bd002bbc38555424878b79195", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -290,10 +290,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Annotator<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.annotate(var.node.id, &var.node.attrs, var.span, AnnotationKind::Required,\n+        self.annotate(var.id, &var.attrs, var.span, AnnotationKind::Required,\n             |v| {\n-                if let Some(ctor_hir_id) = var.node.data.ctor_hir_id() {\n-                    v.annotate(ctor_hir_id, &var.node.attrs, var.span, AnnotationKind::Required,\n+                if let Some(ctor_hir_id) = var.data.ctor_hir_id() {\n+                    v.annotate(ctor_hir_id, &var.attrs, var.span, AnnotationKind::Required,\n                                |_| {});\n                 }\n \n@@ -372,7 +372,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MissingStabilityAnnotations<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, var: &'tcx Variant, g: &'tcx Generics, item_id: HirId) {\n-        self.check_missing_stability(var.node.id, var.span, \"variant\");\n+        self.check_missing_stability(var.id, var.span, \"variant\");\n         intravisit::walk_variant(self, var, g, item_id);\n     }\n "}, {"sha": "b55e6bc54bc5ff25b0576695a41c82ac3afed240", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -189,8 +189,11 @@ impl<'tcx, Tag> Pointer<Tag> {\n         Pointer { alloc_id: self.alloc_id, offset: self.offset, tag: () }\n     }\n \n+    /// Test if the pointer is \"inbounds\" of an allocation of the given size.\n+    /// A pointer is \"inbounds\" even if its offset is equal to the size; this is\n+    /// a \"one-past-the-end\" pointer.\n     #[inline(always)]\n-    pub fn check_in_alloc(\n+    pub fn check_inbounds_alloc(\n         self,\n         allocation_size: Size,\n         msg: CheckInAllocMsg,"}, {"sha": "42390c209d60897c5aa7291a85df8be9d59a7b54", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2068,6 +2068,9 @@ impl<'tcx> TyS<'tcx> {\n             Error => {  // ignore errors (#54954)\n                 ty::Binder::dummy(FnSig::fake())\n             }\n+            Closure(..) => bug!(\n+                \"to get the signature of a closure, use `closure_sig()` not `fn_sig()`\",\n+            ),\n             _ => bug!(\"Ty::fn_sig() called on non-fn type: {:?}\", self)\n         }\n     }"}, {"sha": "a83d490511562950a8dd3d12cc2441ab3a8e4709", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -484,8 +484,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n-                                      Some(v.node.id),\n-                                      &v.node.attrs,\n+                                      Some(v.id),\n+                                      &v.attrs,\n                                       v.span,\n                                       \"a variant\");\n     }"}, {"sha": "fc416be8eeb504a6a7a582e15f9fe1d0c28d46e6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -24,6 +24,7 @@ extern crate rustc;\n \n mod error_codes;\n mod nonstandard_style;\n+mod redundant_semicolon;\n pub mod builtin;\n mod types;\n mod unused;\n@@ -55,6 +56,7 @@ use session::Session;\n use lint::LintId;\n use lint::FutureIncompatibleInfo;\n \n+use redundant_semicolon::*;\n use nonstandard_style::*;\n use builtin::*;\n use types::*;\n@@ -98,6 +100,7 @@ macro_rules! early_lint_passes {\n             WhileTrue: WhileTrue,\n             NonAsciiIdents: NonAsciiIdents,\n             IncompleteFeatures: IncompleteFeatures,\n+            RedundantSemicolon: RedundantSemicolon,\n         ]);\n     )\n }"}, {"sha": "acd17f766323419cfe0c8efe6c514d91d62138df", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -147,7 +147,7 @@ impl EarlyLintPass for NonCamelCaseTypes {\n     }\n \n     fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_case(cx, \"variant\", &v.node.ident);\n+        self.check_case(cx, \"variant\", &v.ident);\n     }\n \n     fn check_generic_param(&mut self, cx: &EarlyContext<'_>, param: &ast::GenericParam) {"}, {"sha": "7c9df3578b59cd22a168821e94261d6eb8003bb1", "filename": "src/librustc_lint/redundant_semicolon.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Fredundant_semicolon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fredundant_semicolon.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,52 @@\n+use crate::lint::{EarlyLintPass, LintPass, EarlyContext, LintArray, LintContext};\n+use syntax::ast::{Stmt, StmtKind, ExprKind};\n+use syntax::errors::Applicability;\n+\n+declare_lint! {\n+    pub REDUNDANT_SEMICOLON,\n+    Warn,\n+    \"detects unnecessary trailing semicolons\"\n+}\n+\n+declare_lint_pass!(RedundantSemicolon => [REDUNDANT_SEMICOLON]);\n+\n+impl EarlyLintPass for RedundantSemicolon {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, stmt: &Stmt) {\n+        if let StmtKind::Semi(expr) = &stmt.node {\n+            if let ExprKind::Tup(ref v) = &expr.node {\n+                if v.is_empty() {\n+                    // Strings of excess semicolons are encoded as empty tuple expressions\n+                    // during the parsing stage, so we check for empty tuple expressions\n+                    // which span only semicolons\n+                    if let Ok(source_str) = cx.sess().source_map().span_to_snippet(stmt.span) {\n+                        if source_str.chars().all(|c| c == ';') {\n+                            let multiple = (stmt.span.hi() - stmt.span.lo()).0 > 1;\n+                            let msg = if multiple {\n+                                \"unnecessary trailing semicolons\"\n+                            } else {\n+                                \"unnecessary trailing semicolon\"\n+                            };\n+                            let mut err = cx.struct_span_lint(\n+                                REDUNDANT_SEMICOLON,\n+                                stmt.span,\n+                                &msg\n+                            );\n+                            let suggest_msg = if multiple {\n+                                \"remove these semicolons\"\n+                            } else {\n+                                \"remove this semicolon\"\n+                            };\n+                            err.span_suggestion(\n+                                stmt.span,\n+                                &suggest_msg,\n+                                String::new(),\n+                                Applicability::MaybeIncorrect\n+                            );\n+                            err.emit();\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "217e10ab24f552696be203b2c7a45789cdd341e2", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -976,7 +976,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n                     let bytes = variant_layout.size.bytes().saturating_sub(discr_size);\n \n                     debug!(\"- variant `{}` is {} bytes large\",\n-                           variant.node.ident,\n+                           variant.ident,\n                            bytes);\n                     bytes\n                 })"}, {"sha": "fb675d7d841e1bbb6938f09bc6199a0293527dbc", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1676,7 +1676,7 @@ impl Visitor<'tcx> for EncodeContext<'tcx> {\n                      id: hir::HirId) {\n         intravisit::walk_variant(self, v, g, id);\n \n-        if let Some(ref discr) = v.node.disr_expr {\n+        if let Some(ref discr) = v.disr_expr {\n             let def_id = self.tcx.hir().local_def_id(discr.hir_id);\n             self.record(def_id, EncodeContext::encode_info_for_anon_const, def_id);\n         }"}, {"sha": "6771d7661e3a4cf54e8893aed2554f9b9e349f64", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -368,7 +368,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // It is sufficient to check this for the end pointer. The addition\n                 // checks for overflow.\n                 let end_ptr = ptr.offset(size, self)?;\n-                end_ptr.check_in_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n+                end_ptr.check_inbounds_alloc(allocation_size, CheckInAllocMsg::MemoryAccessTest)?;\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n@@ -400,7 +400,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> bool {\n         let (size, _align) = self.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)\n             .expect(\"alloc info with MaybeDead cannot fail\");\n-        ptr.check_in_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n+        ptr.check_inbounds_alloc(size, CheckInAllocMsg::NullPointerTest).is_err()\n     }\n }\n "}, {"sha": "139a92c7b11908af303d47b5471a2adf909a212d", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -246,7 +246,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let ptr = match self.check_mplace_access(mplace, None)? {\n+        let ptr = match self.check_mplace_access(mplace, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(Some(ImmTy { // zero-sized type\n                 imm: Scalar::zst().into(),"}, {"sha": "16686c3800f87d95972c7a7855060e3a16200621", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 30, "deletions": 4, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -277,6 +277,10 @@ where\n {\n     /// Take a value, which represents a (thin or fat) reference, and make it a place.\n     /// Alignment is just based on the type.  This is the inverse of `MemPlace::to_ref()`.\n+    ///\n+    /// Only call this if you are sure the place is \"valid\" (aligned and inbounds), or do not\n+    /// want to ever use the place for memory access!\n+    /// Generally prefer `deref_operand`.\n     pub fn ref_to_mplace(\n         &self,\n         val: ImmTy<'tcx, M::PointerTag>,\n@@ -304,7 +308,8 @@ where\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         let val = self.read_immediate(src)?;\n         trace!(\"deref to {} on {:?}\", val.layout.ty, *val);\n-        self.ref_to_mplace(val)\n+        let place = self.ref_to_mplace(val)?;\n+        self.mplace_access_checked(place)\n     }\n \n     /// Check if the given place is good for memory access with the given\n@@ -327,6 +332,23 @@ where\n         self.memory.check_ptr_access(place.ptr, size, place.align)\n     }\n \n+    /// Return the \"access-checked\" version of this `MPlace`, where for non-ZST\n+    /// this is definitely a `Pointer`.\n+    pub fn mplace_access_checked(\n+        &self,\n+        mut place: MPlaceTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n+        let (size, align) = self.size_and_align_of_mplace(place)?\n+            .unwrap_or((place.layout.size, place.layout.align.abi));\n+        assert!(place.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n+        place.mplace.align = align; // maximally strict checking\n+        // When dereferencing a pointer, it must be non-NULL, aligned, and live.\n+        if let Some(ptr) = self.check_mplace_access(place, Some(size))? {\n+            place.mplace.ptr = ptr.into();\n+        }\n+        Ok(place)\n+    }\n+\n     /// Force `place.ptr` to a `Pointer`.\n     /// Can be helpful to avoid lots of `force_ptr` calls later, if this place is used a lot.\n     pub fn force_mplace_ptr(\n@@ -750,7 +772,9 @@ where\n         // to handle padding properly, which is only correct if we never look at this data with the\n         // wrong type.\n \n-        let ptr = match self.check_mplace_access(dest, None)? {\n+        let ptr = match self.check_mplace_access(dest, None)\n+            .expect(\"places should be checked on creation\")\n+        {\n             Some(ptr) => ptr,\n             None => return Ok(()), // zero-sized access\n         };\n@@ -853,8 +877,10 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        let src = self.check_mplace_access(src, Some(size))?;\n-        let dest = self.check_mplace_access(dest, Some(size))?;\n+        let src = self.check_mplace_access(src, Some(size))\n+            .expect(\"places should be checked on creation\");\n+        let dest = self.check_mplace_access(dest, Some(size))\n+            .expect(\"places should be checked on creation\");\n         let (src_ptr, dest_ptr) = match (src, dest) {\n             (Some(src_ptr), Some(dest_ptr)) => (src_ptr, dest_ptr),\n             (None, None) => return Ok(()), // zero-sized copy"}, {"sha": "e55827837fa1ec0515da4386be3a909e2053ec03", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -240,8 +240,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n             Ref(_, _, ref place) => {\n                 let src = self.eval_place(place)?;\n-                let val = self.force_allocation(src)?;\n-                self.write_immediate(val.to_ref(), dest)?;\n+                let place = self.force_allocation(src)?;\n+                if place.layout.size.bytes() > 0 {\n+                    // definitely not a ZST\n+                    assert!(place.ptr.is_ptr(), \"non-ZST places should be normalized to `Pointer`\");\n+                }\n+                self.write_immediate(place.to_ref(), dest)?;\n             }\n \n             NullaryOp(mir::NullOp::Box, _) => {"}, {"sha": "489806f75a5a82d56752f14368d5dff5cf76b29c", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -602,7 +602,7 @@ impl<'a> Visitor<'a> for AstValidator<'a> {\n             }\n             ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.invalid_visibility(&field.vis, None);\n                     }\n                 }"}, {"sha": "852b4898f4ab2929f97043e54206b2c7cd2222a3", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -687,11 +687,11 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n         match item.node {\n             hir::ItemKind::Enum(ref def, _) => {\n                 for variant in &def.variants {\n-                    let variant_level = self.update(variant.node.id, item_level);\n-                    if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+                    let variant_level = self.update(variant.id, item_level);\n+                    if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n                         self.update(ctor_hir_id, item_level);\n                     }\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.update(field.hir_id, variant_level);\n                     }\n                 }\n@@ -810,9 +810,9 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     self.reach(item.hir_id, item_level).generics().predicates();\n                 }\n                 for variant in &def.variants {\n-                    let variant_level = self.get(variant.node.id);\n+                    let variant_level = self.get(variant.id);\n                     if variant_level.is_some() {\n-                        for field in variant.node.data.fields() {\n+                        for field in variant.data.fields() {\n                             self.reach(field.hir_id, variant_level).ty();\n                         }\n                         // Corner case: if the variant is reachable, but its\n@@ -1647,7 +1647,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                      v: &'tcx hir::Variant,\n                      g: &'tcx hir::Generics,\n                      item_id: hir::HirId) {\n-        if self.access_levels.is_reachable(v.node.id) {\n+        if self.access_levels.is_reachable(v.id) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1898,7 +1898,7 @@ impl<'a, 'tcx> Visitor<'tcx> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx>\n                 self.check(item.hir_id, item_visibility).generics().predicates();\n \n                 for variant in &def.variants {\n-                    for field in variant.node.data.fields() {\n+                    for field in variant.data.fields() {\n                         self.check(field.hir_id, item_visibility).ty();\n                     }\n                 }"}, {"sha": "0a32b0c6e95db0c64015103af324ab4973ef0aca", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -799,17 +799,17 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                                        parent: Module<'a>,\n                                        vis: ty::Visibility,\n                                        expn_id: ExpnId) {\n-        let ident = variant.node.ident;\n+        let ident = variant.ident;\n \n         // Define a name in the type namespace.\n-        let def_id = self.r.definitions.local_def_id(variant.node.id);\n+        let def_id = self.r.definitions.local_def_id(variant.id);\n         let res = Res::Def(DefKind::Variant, def_id);\n         self.r.define(parent, ident, TypeNS, (res, vis, variant.span, expn_id));\n \n         // If the variant is marked as non_exhaustive then lower the visibility to within the\n         // crate.\n         let mut ctor_vis = vis;\n-        let has_non_exhaustive = attr::contains_name(&variant.node.attrs, sym::non_exhaustive);\n+        let has_non_exhaustive = attr::contains_name(&variant.attrs, sym::non_exhaustive);\n         if has_non_exhaustive && vis == ty::Visibility::Public {\n             ctor_vis = ty::Visibility::Restricted(DefId::local(CRATE_DEF_INDEX));\n         }\n@@ -819,9 +819,9 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n         // value namespace, they are reserved for possible future use.\n         // It's ok to use the variant's id as a ctor id since an\n         // error will be reported on any use of such resolution anyway.\n-        let ctor_node_id = variant.node.data.ctor_id().unwrap_or(variant.node.id);\n+        let ctor_node_id = variant.data.ctor_id().unwrap_or(variant.id);\n         let ctor_def_id = self.r.definitions.local_def_id(ctor_node_id);\n-        let ctor_kind = CtorKind::from_ast(&variant.node.data);\n+        let ctor_kind = CtorKind::from_ast(&variant.data);\n         let ctor_res = Res::Def(DefKind::Ctor(CtorOf::Variant, ctor_kind), ctor_def_id);\n         self.r.define(parent, ident, ValueNS, (ctor_res, ctor_vis, variant.span, expn_id));\n     }"}, {"sha": "d93c12513c5a133980ad382173e09a58c0671b8b", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -557,11 +557,11 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n         let access = access_from!(self.save_ctxt, item, hir_id);\n \n         for variant in &enum_definition.variants {\n-            let name = variant.node.ident.name.to_string();\n+            let name = variant.ident.name.to_string();\n             let qualname = format!(\"{}::{}\", enum_data.qualname, name);\n-            let name_span = variant.node.ident.span;\n+            let name_span = variant.ident.span;\n \n-            match variant.node.data {\n+            match variant.data {\n                 ast::VariantData::Struct(ref fields, ..) => {\n                     let fields_str = fields\n                         .iter()\n@@ -574,7 +574,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     let value = format!(\"{}::{} {{ {} }}\", enum_data.name, name, fields_str);\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -589,10 +589,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -612,7 +612,7 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                     }\n                     if !self.span.filter_generated(name_span) {\n                         let span = self.span_from_span(name_span);\n-                        let id = id_from_node_id(variant.node.id, &self.save_ctxt);\n+                        let id = id_from_node_id(variant.id, &self.save_ctxt);\n                         let parent = Some(id_from_node_id(item.id, &self.save_ctxt));\n \n                         self.dumper.dump_def(\n@@ -627,10 +627,10 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n                                 parent,\n                                 children: vec![],\n                                 decl_id: None,\n-                                docs: self.save_ctxt.docs_for_attrs(&variant.node.attrs),\n+                                docs: self.save_ctxt.docs_for_attrs(&variant.attrs),\n                                 sig: sig::variant_signature(variant, &self.save_ctxt),\n                                 attributes: lower_attributes(\n-                                    variant.node.attrs.clone(),\n+                                    variant.attrs.clone(),\n                                     &self.save_ctxt,\n                                 ),\n                             },\n@@ -640,8 +640,8 @@ impl<'l, 'tcx> DumpVisitor<'l, 'tcx> {\n             }\n \n \n-            for field in variant.node.data.fields() {\n-                self.process_struct_field_def(field, variant.node.id);\n+            for field in variant.data.fields() {\n+                self.process_struct_field_def(field, variant.id);\n                 self.visit_ty(&field.ty);\n             }\n         }"}, {"sha": "9da6cd800570e79427a6a6ed15356e7af552b126", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -277,7 +277,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                 filter!(self.span_utils, item.ident.span);\n                 let variants_str = def.variants\n                     .iter()\n-                    .map(|v| v.node.ident.to_string())\n+                    .map(|v| v.ident.to_string())\n                     .collect::<Vec<_>>()\n                     .join(\", \");\n                 let value = format!(\"{}::{{{}}}\", name, variants_str);\n@@ -291,7 +291,7 @@ impl<'l, 'tcx> SaveContext<'l, 'tcx> {\n                     parent: None,\n                     children: def.variants\n                         .iter()\n-                        .map(|v| id_from_node_id(v.node.id, self))\n+                        .map(|v| id_from_node_id(v.id, self))\n                         .collect(),\n                     decl_id: None,\n                     docs: self.docs_for_attrs(&item.attrs),"}, {"sha": "b34506a4f1d371747b80dc2a48bd87786aa5b6ae", "filename": "src/librustc_save_analysis/sig.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -65,7 +65,7 @@ pub fn variant_signature(variant: &ast::Variant, scx: &SaveContext<'_, '_>) -> O\n     if !scx.config.signatures {\n         return None;\n     }\n-    variant.node.make(0, None, scx).ok()\n+    variant.make(0, None, scx).ok()\n }\n \n pub fn method_signature(\n@@ -699,7 +699,7 @@ impl Sig for ast::StructField {\n }\n \n \n-impl Sig for ast::Variant_ {\n+impl Sig for ast::Variant {\n     fn make(&self, offset: usize, parent_id: Option<NodeId>, scx: &SaveContext<'_, '_>) -> Result {\n         let mut text = self.ident.to_string();\n         match self.data {"}, {"sha": "ed25601208ad1caacf505f29764cf8d84b3396c0", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -127,6 +127,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         self.suggest_compatible_variants(&mut err, expr, expected, expr_ty);\n         self.suggest_ref_or_into(&mut err, expr, expected, expr_ty);\n+        self.suggest_boxing_when_appropriate(&mut err, expr, expected, expr_ty);\n         self.suggest_missing_await(&mut err, expr, expected, expr_ty);\n \n         (expected, Some(err))\n@@ -548,7 +549,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         checked_ty: Ty<'tcx>,\n         expected_ty: Ty<'tcx>,\n     ) -> bool {\n-        if self.tcx.hir().is_const_scope(expr.hir_id) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n             // Shouldn't suggest `.into()` on `const`s.\n             // FIXME(estebank): modify once we decide to suggest `as` casts\n             return false;"}, {"sha": "92f8fb30db8ee6c15058c10c26589718a0b654aa", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 41, "deletions": 5, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2048,19 +2048,19 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n     }\n \n     for v in vs {\n-        if let Some(ref e) = v.node.disr_expr {\n+        if let Some(ref e) = v.disr_expr {\n             tcx.typeck_tables_of(tcx.hir().local_def_id(e.hir_id));\n         }\n     }\n \n     if tcx.adt_def(def_id).repr.int.is_none() && tcx.features().arbitrary_enum_discriminant {\n         let is_unit =\n-            |var: &hir::Variant| match var.node.data {\n+            |var: &hir::Variant| match var.data {\n                 hir::VariantData::Unit(..) => true,\n                 _ => false\n             };\n \n-        let has_disr = |var: &hir::Variant| var.node.disr_expr.is_some();\n+        let has_disr = |var: &hir::Variant| var.disr_expr.is_some();\n         let has_non_units = vs.iter().any(|var| !is_unit(var));\n         let disr_units = vs.iter().any(|var| is_unit(&var) && has_disr(&var));\n         let disr_non_unit = vs.iter().any(|var| !is_unit(&var) && has_disr(&var));\n@@ -2079,11 +2079,11 @@ pub fn check_enum<'tcx>(tcx: TyCtxt<'tcx>, sp: Span, vs: &'tcx [hir::Variant], i\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n-            let i_span = match variant_i.node.disr_expr {\n+            let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => tcx.hir().span(variant_i_hir_id)\n             };\n-            let span = match v.node.disr_expr {\n+            let span = match v.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n                 None => v.span\n             };\n@@ -3900,6 +3900,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 err, &fn_decl, expected, found, can_suggest);\n         }\n         self.suggest_ref_or_into(err, expression, expected, found);\n+        self.suggest_boxing_when_appropriate(err, expression, expected, found);\n         pointing_at_return_type\n     }\n \n@@ -4060,6 +4061,41 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// When encountering the expected boxed value allocated in the stack, suggest allocating it\n+    /// in the heap by calling `Box::new()`.\n+    fn suggest_boxing_when_appropriate(\n+        &self,\n+        err: &mut DiagnosticBuilder<'tcx>,\n+        expr: &hir::Expr,\n+        expected: Ty<'tcx>,\n+        found: Ty<'tcx>,\n+    ) {\n+        if self.tcx.hir().is_const_context(expr.hir_id) {\n+            // Do not suggest `Box::new` in const context.\n+            return;\n+        }\n+        if !expected.is_box() || found.is_box() {\n+            return;\n+        }\n+        let boxed_found = self.tcx.mk_box(found);\n+        if let (true, Ok(snippet)) = (\n+            self.can_coerce(boxed_found, expected),\n+            self.sess().source_map().span_to_snippet(expr.span),\n+        ) {\n+            err.span_suggestion(\n+                expr.span,\n+                \"store this in the heap by calling `Box::new`\",\n+                format!(\"Box::new({})\", snippet),\n+                Applicability::MachineApplicable,\n+            );\n+            err.note(\"for more on the distinction between the stack and the \\\n+                        heap, read https://doc.rust-lang.org/book/ch15-01-box.html, \\\n+                        https://doc.rust-lang.org/rust-by-example/std/box.html, and \\\n+                        https://doc.rust-lang.org/std/boxed/index.html\");\n+        }\n+    }\n+\n+\n     /// A common error is to forget to add a semicolon at the end of a block, e.g.,\n     ///\n     /// ```"}, {"sha": "b2c0e34d6fad7638dc19ad0c01629db0e7520cb8", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1119,7 +1119,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn enum_variants(&self, enum_def: &hir::EnumDef) -> Vec<AdtVariant<'tcx>> {\n         enum_def.variants.iter()\n-            .map(|variant| self.non_enum_variant(&variant.node.data))\n+            .map(|variant| self.non_enum_variant(&variant.data))\n             .collect()\n     }\n "}, {"sha": "5ff64224c5aa04eaf3bcc3890416b6e0ba05b2ab", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -35,7 +35,6 @@ use rustc_target::spec::abi;\n use syntax::ast;\n use syntax::ast::{Ident, MetaItemKind};\n use syntax::attr::{InlineAttr, OptimizeAttr, list_contains_name, mark_used};\n-use syntax::source_map::Spanned;\n use syntax::feature_gate;\n use syntax::symbol::{InternedString, kw, Symbol, sym};\n use syntax_pos::{Span, DUMMY_SP};\n@@ -520,7 +519,11 @@ fn convert_variant_ctor(tcx: TyCtxt<'_>, ctor_id: hir::HirId) {\n     tcx.predicates_of(def_id);\n }\n \n-fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants: &[hir::Variant]) {\n+fn convert_enum_variant_types<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    def_id: DefId,\n+    variants: &[hir::Variant]\n+) {\n     let def = tcx.adt_def(def_id);\n     let repr_type = def.repr.discr_type();\n     let initial = repr_type.initial_discriminant(tcx);\n@@ -530,7 +533,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n     for variant in variants {\n         let wrapped_discr = prev_discr.map_or(initial, |d| d.wrap_incr(tcx));\n         prev_discr = Some(\n-            if let Some(ref e) = variant.node.disr_expr {\n+            if let Some(ref e) = variant.disr_expr {\n                 let expr_did = tcx.hir().local_def_id(e.hir_id);\n                 def.eval_explicit_discr(tcx, expr_did)\n             } else if let Some(discr) = repr_type.disr_incr(tcx, prev_discr) {\n@@ -546,14 +549,14 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n                     format!(\"overflowed on value after {}\", prev_discr.unwrap()),\n                 ).note(&format!(\n                     \"explicitly set `{} = {}` if that is desired outcome\",\n-                    variant.node.ident, wrapped_discr\n+                    variant.ident, wrapped_discr\n                 ))\n                 .emit();\n                 None\n             }.unwrap_or(wrapped_discr),\n         );\n \n-        for f in variant.node.data.fields() {\n+        for f in variant.data.fields() {\n             let def_id = tcx.hir().local_def_id(f.hir_id);\n             tcx.generics_of(def_id);\n             tcx.type_of(def_id);\n@@ -562,7 +565,7 @@ fn convert_enum_variant_types<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, variants:\n \n         // Convert the ctor, if any. This also registers the variant as\n         // an item.\n-        if let Some(ctor_hir_id) = variant.node.data.ctor_hir_id() {\n+        if let Some(ctor_hir_id) = variant.data.ctor_hir_id() {\n             convert_variant_ctor(tcx, ctor_hir_id);\n         }\n     }\n@@ -641,20 +644,20 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n             let variants = def.variants\n                 .iter()\n                 .map(|v| {\n-                    let variant_did = Some(tcx.hir().local_def_id(v.node.id));\n-                    let ctor_did = v.node.data.ctor_hir_id()\n+                    let variant_did = Some(tcx.hir().local_def_id(v.id));\n+                    let ctor_did = v.data.ctor_hir_id()\n                         .map(|hir_id| tcx.hir().local_def_id(hir_id));\n \n-                    let discr = if let Some(ref e) = v.node.disr_expr {\n+                    let discr = if let Some(ref e) = v.disr_expr {\n                         distance_from_explicit = 0;\n                         ty::VariantDiscr::Explicit(tcx.hir().local_def_id(e.hir_id))\n                     } else {\n                         ty::VariantDiscr::Relative(distance_from_explicit)\n                     };\n                     distance_from_explicit += 1;\n \n-                    convert_variant(tcx, variant_did, ctor_did, v.node.ident, discr,\n-                                    &v.node.data, AdtKind::Enum, def_id)\n+                    convert_variant(tcx, variant_did, ctor_did, v.ident, discr,\n+                                    &v.data, AdtKind::Enum, def_id)\n                 })\n                 .collect();\n \n@@ -1314,10 +1317,9 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n             ForeignItemKind::Type => tcx.mk_foreign(def_id),\n         },\n \n-        Node::Ctor(&ref def) | Node::Variant(&Spanned {\n-            node: hir::VariantKind { data: ref def, .. },\n-            ..\n-        }) => match *def {\n+        Node::Ctor(&ref def) | Node::Variant(\n+            hir::Variant { data: ref def, .. }\n+        ) => match *def {\n             VariantData::Unit(..) | VariantData::Struct(..) => {\n                 tcx.type_of(tcx.hir().get_parent_did(hir_id))\n             }\n@@ -1363,12 +1365,8 @@ pub fn checked_type_of(tcx: TyCtxt<'_>, def_id: DefId, fail: bool) -> Option<Ty<\n                     tcx.types.usize\n                 }\n \n-                Node::Variant(&Spanned {\n-                    node:\n-                        VariantKind {\n-                            disr_expr: Some(ref e),\n-                            ..\n-                        },\n+                Node::Variant(Variant {\n+                    disr_expr: Some(ref e),\n                     ..\n                 }) if e.hir_id == hir_id =>\n                 {\n@@ -1809,10 +1807,9 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        Ctor(data) | Variant(Spanned {\n-            node: hir::VariantKind { data, ..  },\n-            ..\n-        }) if data.ctor_hir_id().is_some() => {\n+        Ctor(data) | Variant(\n+            hir::Variant { data, ..  }\n+        ) if data.ctor_hir_id().is_some() => {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id));\n             let inputs = data.fields()\n                 .iter()"}, {"sha": "7ed9d6606f646fed672be8e8ae60e0d6d3937f92", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -82,8 +82,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n                 self.visit_node_helper(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.visit_node_helper(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.visit_node_helper(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "e10837e52ad0407e76cb82405fea59d8963bd7ce", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -145,8 +145,8 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                 self.add_inferreds_for_item(item.hir_id);\n \n                 for variant in &enum_def.variants {\n-                    if let hir::VariantData::Tuple(..) = variant.node.data {\n-                        self.add_inferreds_for_item(variant.node.data.ctor_hir_id().unwrap());\n+                    if let hir::VariantData::Tuple(..) = variant.data {\n+                        self.add_inferreds_for_item(variant.data.ctor_hir_id().unwrap());\n                     }\n                 }\n             }"}, {"sha": "83a8d3fc109994d008510c0538b670133b0dd72c", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -951,7 +951,7 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for HirCollector<'a, 'hir> {\n                      v: &'hir hir::Variant,\n                      g: &'hir hir::Generics,\n                      item_id: hir::HirId) {\n-        self.visit_testable(v.node.ident.to_string(), &v.node.attrs, |this| {\n+        self.visit_testable(v.ident.to_string(), &v.attrs, |this| {\n             intravisit::walk_variant(this, v, g, item_id);\n         });\n     }"}, {"sha": "903ed3aae147016e8173e54a798296fa2c639ebc", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -130,10 +130,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         Enum {\n             name,\n             variants: def.variants.iter().map(|v| Variant {\n-                name: v.node.ident.name,\n-                id: v.node.id,\n-                attrs: &v.node.attrs,\n-                def: &v.node.data,\n+                name: v.ident.name,\n+                id: v.id,\n+                attrs: &v.attrs,\n+                def: &v.data,\n                 whence: v.span,\n             }).collect(),\n             vis: &it.vis,"}, {"sha": "f0f090c8e897331bca82f2c901c344c612ec18bc", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -608,6 +608,7 @@ pub struct FieldPat {\n     pub pat: P<Pat>,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n }\n \n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n@@ -925,6 +926,7 @@ pub struct Arm {\n     pub guard: Option<P<Expr>>,\n     pub body: P<Expr>,\n     pub span: Span,\n+    pub id: NodeId,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -934,6 +936,7 @@ pub struct Field {\n     pub span: Span,\n     pub is_shorthand: bool,\n     pub attrs: ThinVec<Attribute>,\n+    pub id: NodeId,\n }\n \n pub type SpannedIdent = Spanned<Ident>;\n@@ -2038,7 +2041,7 @@ pub struct EnumDef {\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n-pub struct Variant_ {\n+pub struct Variant {\n     /// Name of the variant.\n     pub ident: Ident,\n     /// Attributes of the variant.\n@@ -2049,10 +2052,10 @@ pub struct Variant_ {\n     pub data: VariantData,\n     /// Explicit discriminant, e.g., `Foo = 1`.\n     pub disr_expr: Option<AnonConst>,\n+    /// Span\n+    pub span: Span,\n }\n \n-pub type Variant = Spanned<Variant_>;\n-\n /// Part of `use` item to the right of its prefix.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub enum UseTreeKind {"}, {"sha": "70b1d3fc73b9a83356bc76961e2aa5328be5e952", "filename": "src/libsyntax/attr/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -712,7 +712,7 @@ macro_rules! derive_has_attrs {\n \n derive_has_attrs! {\n     Item, Expr, Local, ast::ForeignItem, ast::StructField, ast::ImplItem, ast::TraitItem, ast::Arm,\n-    ast::Field, ast::FieldPat, ast::Variant_, ast::Arg\n+    ast::Field, ast::FieldPat, ast::Variant, ast::Arg\n }\n \n pub fn inject(mut krate: ast::Crate, parse_sess: &ParseSess, attrs: &[String]) -> ast::Crate {"}, {"sha": "7eeea4e7bdfe191d92ea850bce252ac62cbbd69f", "filename": "src/libsyntax/config.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fconfig.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -260,7 +260,7 @@ impl<'a> StripUnconfigured<'a> {\n             ast::ItemKind::Enum(ast::EnumDef { variants }, _generics) => {\n                 variants.flat_map_in_place(|variant| self.configure(variant));\n                 for variant in variants {\n-                    self.configure_variant_data(&mut variant.node.data);\n+                    self.configure_variant_data(&mut variant.data);\n                 }\n             }\n             _ => {}"}, {"sha": "6886b4bf4211195855c409b5de572aaca0a80e89", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 16, "deletions": 37, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -405,7 +405,6 @@ impl MacResult for MacEager {\n /// after hitting errors.\n #[derive(Copy, Clone)]\n pub struct DummyResult {\n-    expr_only: bool,\n     is_error: bool,\n     span: Span,\n }\n@@ -416,21 +415,12 @@ impl DummyResult {\n     /// Use this as a return value after hitting any errors and\n     /// calling `span_err`.\n     pub fn any(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: true, span })\n+        Box::new(DummyResult { is_error: true, span })\n     }\n \n     /// Same as `any`, but must be a valid fragment, not error.\n     pub fn any_valid(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: false, is_error: false, span })\n-    }\n-\n-    /// Creates a default MacResult that can only be an expression.\n-    ///\n-    /// Use this for macros that must expand to an expression, so even\n-    /// if an error is encountered internally, the user will receive\n-    /// an error that they also used it in the wrong place.\n-    pub fn expr(span: Span) -> Box<dyn MacResult+'static> {\n-        Box::new(DummyResult { expr_only: true, is_error: true, span })\n+        Box::new(DummyResult { is_error: false, span })\n     }\n \n     /// A plain dummy expression.\n@@ -472,36 +462,19 @@ impl MacResult for DummyResult {\n     }\n \n     fn make_items(self: Box<DummyResult>) -> Option<SmallVec<[P<ast::Item>; 1]>> {\n-        // this code needs a comment... why not always just return the Some() ?\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_impl_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::ImplItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_trait_items(self: Box<DummyResult>) -> Option<SmallVec<[ast::TraitItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_foreign_items(self: Box<Self>) -> Option<SmallVec<[ast::ForeignItem; 1]>> {\n-        if self.expr_only {\n-            None\n-        } else {\n-            Some(SmallVec::new())\n-        }\n+        Some(SmallVec::new())\n     }\n \n     fn make_stmts(self: Box<DummyResult>) -> Option<SmallVec<[ast::Stmt; 1]>> {\n@@ -947,8 +920,10 @@ pub fn expr_to_spanned_string<'a>(\n     // Update `expr.span`'s ctxt now in case expr is an `include!` macro invocation.\n     expr.span = expr.span.apply_mark(cx.current_expansion.id);\n \n-    // we want to be able to handle e.g., `concat!(\"foo\", \"bar\")`\n-    cx.expander().visit_expr(&mut expr);\n+    // Perform eager expansion on the expression.\n+    // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+    let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n     Err(match expr.node {\n         ast::ExprKind::Lit(ref l) => match l.node {\n             ast::LitKind::Str(s, style) => return Ok(respan(expr.span, (s, style))),\n@@ -1013,8 +988,12 @@ pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>,\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n-        let mut expr = panictry!(p.parse_expr());\n-        cx.expander().visit_expr(&mut expr);\n+        let expr = panictry!(p.parse_expr());\n+\n+        // Perform eager expansion on the expression.\n+        // We want to be able to handle e.g., `concat!(\"foo\", \"bar\")`.\n+        let expr = cx.expander().fully_expand_fragment(AstFragment::Expr(expr)).make_expr();\n+\n         es.push(expr);\n         if p.eat(&token::Comma) {\n             continue;"}, {"sha": "f18cf86243ea3db3bb9fb223f0b72e8f2475851f", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -403,6 +403,7 @@ impl<'a> ExtCtxt<'a> {\n             span,\n             is_shorthand: false,\n             attrs: ThinVec::new(),\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n     pub fn expr_struct(\n@@ -612,6 +613,7 @@ impl<'a> ExtCtxt<'a> {\n             guard: None,\n             body: expr,\n             span,\n+            id: ast::DUMMY_NODE_ID,\n         }\n     }\n \n@@ -781,14 +783,14 @@ impl<'a> ExtCtxt<'a> {\n             ast::VariantData::Tuple(fields, ast::DUMMY_NODE_ID)\n         };\n \n-        respan(span,\n-               ast::Variant_ {\n-                   ident,\n-                   id: ast::DUMMY_NODE_ID,\n-                   attrs: Vec::new(),\n-                   data: vdata,\n-                   disr_expr: None,\n-               })\n+        ast::Variant {\n+            attrs: Vec::new(),\n+            data: vdata,\n+            disr_expr: None,\n+            id: ast::DUMMY_NODE_ID,\n+            ident,\n+            span,\n+        }\n     }\n \n     pub fn item_enum_poly(&self, span: Span, name: Ident,"}, {"sha": "402b42dfbc80d29f26986bb4bc0a0eda5311d9e5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -116,18 +116,6 @@ macro_rules! ast_fragments {\n             }\n         }\n \n-        impl<'a, 'b> MutVisitor for MacroExpander<'a, 'b> {\n-            fn filter_map_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-                self.expand_fragment(AstFragment::OptExpr(Some(expr))).make_opt_expr()\n-            }\n-            $($(fn $mut_visit_ast(&mut self, ast: &mut $AstTy) {\n-                visit_clobber(ast, |ast| self.expand_fragment(AstFragment::$Kind(ast)).$make_ast());\n-            })?)*\n-            $($(fn $flat_map_ast_elt(&mut self, ast_elt: <$AstTy as IntoIterator>::Item) -> $AstTy {\n-                self.expand_fragment(AstFragment::$Kind(smallvec![ast_elt])).$make_ast()\n-            })?)*\n-        }\n-\n         impl<'a> MacResult for crate::ext::tt::macro_rules::ParserAnyMacro<'a> {\n             $(fn $make_ast(self: Box<crate::ext::tt::macro_rules::ParserAnyMacro<'a>>)\n                            -> Option<$AstTy> {\n@@ -265,7 +253,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             tokens: None,\n         })]);\n \n-        match self.expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n+        match self.fully_expand_fragment(krate_item).make_items().pop().map(P::into_inner) {\n             Some(ast::Item { attrs, node: ast::ItemKind::Mod(module), .. }) => {\n                 krate.attrs = attrs;\n                 krate.module = module;\n@@ -285,8 +273,8 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         krate\n     }\n \n-    // Fully expand all macro invocations in this AST fragment.\n-    fn expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n+    // Recursively expand all macro invocations in this AST fragment.\n+    pub fn fully_expand_fragment(&mut self, input_fragment: AstFragment) -> AstFragment {\n         let orig_expansion_data = self.cx.current_expansion.clone();\n         self.cx.current_expansion.depth = 0;\n "}, {"sha": "8a56ae13b6f6ef22fecc9ebb316af8dd263de047", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1956,7 +1956,7 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n \n             ast::ItemKind::Enum(ast::EnumDef{ref variants, ..}, ..) => {\n                 for variant in variants {\n-                    match (&variant.node.data, &variant.node.disr_expr) {\n+                    match (&variant.data, &variant.disr_expr) {\n                         (ast::VariantData::Unit(..), _) => {},\n                         (_, Some(disr_expr)) =>\n                             gate_feature_post!("}, {"sha": "82446989997852ad508ee46945ba5baabf7e08a0", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -383,10 +383,11 @@ pub fn noop_visit_use_tree<T: MutVisitor>(use_tree: &mut UseTree, vis: &mut T) {\n }\n \n pub fn noop_visit_arm<T: MutVisitor>(\n-    Arm { attrs, pats, guard, body, span }: &mut Arm,\n+    Arm { attrs, pats, guard, body, span, id }: &mut Arm,\n     vis: &mut T,\n ) {\n     visit_attrs(attrs, vis);\n+    vis.visit_id(id);\n     visit_vec(pats, |pat| vis.visit_pat(pat));\n     visit_opt(guard, |guard| vis.visit_expr(guard));\n     vis.visit_expr(body);\n@@ -455,7 +456,7 @@ pub fn noop_visit_foreign_mod<T: MutVisitor>(foreign_mod: &mut ForeignMod, vis:\n }\n \n pub fn noop_visit_variant<T: MutVisitor>(variant: &mut Variant, vis: &mut T) {\n-    let Spanned { node: Variant_ { ident, attrs, id, data, disr_expr }, span } = variant;\n+    let Variant { ident, attrs, id, data, disr_expr, span } = variant;\n     vis.visit_ident(ident);\n     visit_attrs(attrs, vis);\n     vis.visit_id(id);\n@@ -808,9 +809,10 @@ pub fn noop_visit_struct_field<T: MutVisitor>(f: &mut StructField, visitor: &mut\n }\n \n pub fn noop_visit_field<T: MutVisitor>(f: &mut Field, vis: &mut T) {\n-    let Field { ident, expr, span, is_shorthand: _, attrs } = f;\n+    let Field { ident, expr, span, is_shorthand: _, attrs, id } = f;\n     vis.visit_ident(ident);\n     vis.visit_expr(expr);\n+    vis.visit_id(id);\n     vis.visit_span(span);\n     visit_thin_attrs(attrs, vis);\n }\n@@ -1040,8 +1042,12 @@ pub fn noop_visit_pat<T: MutVisitor>(pat: &mut P<Pat>, vis: &mut T) {\n         }\n         PatKind::Struct(path, fields, _etc) => {\n             vis.visit_path(path);\n-            for Spanned { node: FieldPat { ident, pat, is_shorthand: _, attrs }, span } in fields {\n+            for Spanned {\n+                node: FieldPat { ident, pat, is_shorthand: _, attrs, id },\n+                span\n+            } in fields {\n                 vis.visit_ident(ident);\n+                vis.visit_id(id);\n                 vis.visit_pat(pat);\n                 visit_thin_attrs(attrs, vis);\n                 vis.visit_span(span);"}, {"sha": "1fbf28fb83016059d76952556e0510db3ad4feee", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -8,7 +8,6 @@ use crate::parse::parser::{BlockMode, PathStyle, SemiColonMode, TokenType, Token\n use crate::parse::token::{self, TokenKind};\n use crate::print::pprust;\n use crate::ptr::P;\n-use crate::source_map::Spanned;\n use crate::symbol::{kw, sym};\n use crate::ThinVec;\n use crate::util::parser::AssocOp;\n@@ -592,18 +591,18 @@ impl<'a> Parser<'a> {\n \n     crate fn maybe_report_invalid_custom_discriminants(\n         sess: &ParseSess,\n-        variants: &[Spanned<ast::Variant_>],\n+        variants: &[ast::Variant],\n     ) {\n-        let has_fields = variants.iter().any(|variant| match variant.node.data {\n+        let has_fields = variants.iter().any(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => true,\n             VariantData::Unit(..) => false,\n         });\n \n-        let discriminant_spans = variants.iter().filter(|variant| match variant.node.data {\n+        let discriminant_spans = variants.iter().filter(|variant| match variant.data {\n             VariantData::Tuple(..) | VariantData::Struct(..) => false,\n             VariantData::Unit(..) => true,\n         })\n-        .filter_map(|variant| variant.node.disr_expr.as_ref().map(|c| c.value.span))\n+        .filter_map(|variant| variant.disr_expr.as_ref().map(|c| c.value.span))\n         .collect::<Vec<_>>();\n \n         if !discriminant_spans.is_empty() && has_fields {\n@@ -618,7 +617,7 @@ impl<'a> Parser<'a> {\n                 err.span_label(sp, \"disallowed custom discriminant\");\n             }\n             for variant in variants.iter() {\n-                match &variant.node.data {\n+                match &variant.data {\n                     VariantData::Struct(..) => {\n                         err.span_label(\n                             variant.span,"}, {"sha": "7b98d7a18018c1cd3a741b7d572bb8e67c24c76a", "filename": "src/libsyntax/parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fexpr.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1448,6 +1448,7 @@ impl<'a> Parser<'a> {\n             guard,\n             body: expr,\n             span: lo.to(hi),\n+            id: ast::DUMMY_NODE_ID,\n         })\n     }\n \n@@ -1603,6 +1604,7 @@ impl<'a> Parser<'a> {\n                         expr: self.mk_expr(self.token.span, ExprKind::Err, ThinVec::new()),\n                         is_shorthand: false,\n                         attrs: ThinVec::new(),\n+                        id: ast::DUMMY_NODE_ID,\n                     });\n                 }\n             }\n@@ -1688,6 +1690,7 @@ impl<'a> Parser<'a> {\n             expr,\n             is_shorthand,\n             attrs: attrs.into(),\n+            id: ast::DUMMY_NODE_ID,\n         })\n     }\n "}, {"sha": "60873ecb134684e47a6cdacf7c2b26b0457f5e0e", "filename": "src/libsyntax/parse/parser/item.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fitem.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1564,14 +1564,15 @@ impl<'a> Parser<'a> {\n                 None\n             };\n \n-            let vr = ast::Variant_ {\n+            let vr = ast::Variant {\n                 ident,\n                 id: ast::DUMMY_NODE_ID,\n                 attrs: variant_attrs,\n                 data: struct_def,\n                 disr_expr,\n+                span: vlo.to(self.prev_span),\n             };\n-            variants.push(respan(vlo.to(self.prev_span), vr));\n+            variants.push(vr);\n \n             if !self.eat(&token::Comma) {\n                 if self.token.is_ident() && !self.token.is_reserved_ident() {"}, {"sha": "40aa8d7b46f7495f9aac54da261c989b618ee9aa", "filename": "src/libsyntax/parse/parser/pat.rs", "status": "modified", "additions": 236, "deletions": 190, "changes": 426, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fpat.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -3,7 +3,7 @@ use super::{Parser, PResult, PathStyle};\n use crate::{maybe_recover_from_interpolated_ty_qpath, maybe_whole};\n use crate::ptr::P;\n use crate::ast::{self, Attribute, Pat, PatKind, FieldPat, RangeEnd, RangeSyntax, Mac_};\n-use crate::ast::{BindingMode, Ident, Mutability, Expr, ExprKind};\n+use crate::ast::{BindingMode, Ident, Mutability, Path, QSelf, Expr, ExprKind};\n use crate::parse::token::{self};\n use crate::print::pprust;\n use crate::source_map::{respan, Span, Spanned};\n@@ -108,93 +108,52 @@ impl<'a> Parser<'a> {\n         maybe_whole!(self, NtPat, |x| x);\n \n         let lo = self.token.span;\n-        let pat;\n-        match self.token.kind {\n-            token::BinOp(token::And) | token::AndAnd => {\n-                // Parse &pat / &mut pat\n-                self.expect_and()?;\n-                let mutbl = self.parse_mutability();\n-                if let token::Lifetime(name) = self.token.kind {\n-                    let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n-                    err.span_label(self.token.span, \"unexpected lifetime\");\n-                    return Err(err);\n-                }\n-                let subpat = self.parse_pat_with_range_pat(false, expected)?;\n-                pat = PatKind::Ref(subpat, mutbl);\n-            }\n-            token::OpenDelim(token::Paren) => {\n-                // Parse a tuple or parenthesis pattern.\n-                let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-\n-                // Here, `(pat,)` is a tuple pattern.\n-                // For backward compatibility, `(..)` is a tuple pattern as well.\n-                pat = if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n-                    PatKind::Paren(fields.into_iter().nth(0).unwrap())\n-                } else {\n-                    PatKind::Tuple(fields)\n-                };\n-            }\n+        let pat = match self.token.kind {\n+            token::BinOp(token::And) | token::AndAnd => self.parse_pat_deref(expected)?,\n+            token::OpenDelim(token::Paren) => self.parse_pat_tuple_or_parens()?,\n             token::OpenDelim(token::Bracket) => {\n                 // Parse `[pat, pat,...]` as a slice pattern.\n-                let (slice, _) = self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?;\n-                pat = PatKind::Slice(slice);\n+                PatKind::Slice(self.parse_delim_comma_seq(token::Bracket, |p| p.parse_pat(None))?.0)\n             }\n             token::DotDot => {\n                 self.bump();\n-                pat = if self.is_pat_range_end_start() {\n+                if self.is_pat_range_end_start() {\n                     // Parse `..42` for recovery.\n                     self.parse_pat_range_to(RangeEnd::Excluded, \"..\")?\n                 } else {\n                     // A rest pattern `..`.\n                     PatKind::Rest\n-                };\n+                }\n             }\n             token::DotDotEq => {\n                 // Parse `..=42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")?\n             }\n             token::DotDotDot => {\n                 // Parse `...42` for recovery.\n                 self.bump();\n-                pat = self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?;\n+                self.parse_pat_range_to(RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")?\n             }\n             // At this point, token != &, &&, (, [\n             _ => if self.eat_keyword(kw::Underscore) {\n                 // Parse _\n-                pat = PatKind::Wild;\n+                PatKind::Wild\n             } else if self.eat_keyword(kw::Mut) {\n-                // Parse mut ident @ pat / mut ref ident @ pat\n-                let mutref_span = self.prev_span.to(self.token.span);\n-                let binding_mode = if self.eat_keyword(kw::Ref) {\n-                    self.diagnostic()\n-                        .struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n-                        .span_suggestion(\n-                            mutref_span,\n-                            \"try switching the order\",\n-                            \"ref mut\".into(),\n-                            Applicability::MachineApplicable\n-                        ).emit();\n-                    BindingMode::ByRef(Mutability::Mutable)\n-                } else {\n-                    BindingMode::ByValue(Mutability::Mutable)\n-                };\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                self.recover_pat_ident_mut_first()?\n             } else if self.eat_keyword(kw::Ref) {\n                 // Parse ref ident @ pat / ref mut ident @ pat\n                 let mutbl = self.parse_mutability();\n-                pat = self.parse_pat_ident(BindingMode::ByRef(mutbl))?;\n+                self.parse_pat_ident(BindingMode::ByRef(mutbl))?\n             } else if self.eat_keyword(kw::Box) {\n-                // Parse box pat\n-                let subpat = self.parse_pat_with_range_pat(false, None)?;\n-                pat = PatKind::Box(subpat);\n+                // Parse `box pat`\n+                PatKind::Box(self.parse_pat_with_range_pat(false, None)?)\n             } else if self.token.is_ident() && !self.token.is_reserved_ident() &&\n                       self.parse_as_ident() {\n-                // Parse ident @ pat\n+                // Parse `ident @ pat`\n                 // This can give false positives and parse nullary enums,\n-                // they are dealt with later in resolve\n-                let binding_mode = BindingMode::ByValue(Mutability::Immutable);\n-                pat = self.parse_pat_ident(binding_mode)?;\n+                // they are dealt with later in resolve.\n+                self.parse_pat_ident(BindingMode::ByValue(Mutability::Immutable))?\n             } else if self.token.is_path_start() {\n                 // Parse pattern starting with a path\n                 let (qself, path) = if self.eat_lt() {\n@@ -206,136 +165,186 @@ impl<'a> Parser<'a> {\n                     (None, self.parse_path(PathStyle::Expr)?)\n                 };\n                 match self.token.kind {\n-                    token::Not if qself.is_none() => {\n-                        // Parse macro invocation\n-                        self.bump();\n-                        let (delim, tts) = self.expect_delimited_token_tree()?;\n-                        let mac = respan(lo.to(self.prev_span), Mac_ {\n-                            path,\n-                            tts,\n-                            delim,\n-                            prior_type_ascription: self.last_type_ascription,\n-                        });\n-                        pat = PatKind::Mac(mac);\n-                    }\n+                    token::Not if qself.is_none() => self.parse_pat_mac_invoc(lo, path)?,\n                     token::DotDotDot | token::DotDotEq | token::DotDot => {\n-                        let (end_kind, form) = match self.token.kind {\n-                            token::DotDot => (RangeEnd::Excluded, \"..\"),\n-                            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n-                            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n-                            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges \\\n-                                         (checked above)\"),\n-                        };\n-                        let op_span = self.token.span;\n-                        // Parse range\n-                        let span = lo.to(self.prev_span);\n-                        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n-                        self.bump();\n-                        let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                        pat = PatKind::Range(begin, end, respan(op_span, end_kind));\n-                    }\n-                    token::OpenDelim(token::Brace) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `{` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse struct pattern\n-                        self.bump();\n-                        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n-                            e.emit();\n-                            self.recover_stmt();\n-                            (vec![], true)\n-                        });\n-                        self.bump();\n-                        pat = PatKind::Struct(path, fields, etc);\n-                    }\n-                    token::OpenDelim(token::Paren) => {\n-                        if qself.is_some() {\n-                            let msg = \"unexpected `(` after qualified path\";\n-                            let mut err = self.fatal(msg);\n-                            err.span_label(self.token.span, msg);\n-                            return Err(err);\n-                        }\n-                        // Parse tuple struct or enum pattern\n-                        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n-                        pat = PatKind::TupleStruct(path, fields)\n+                        self.parse_pat_range_starting_with_path(lo, qself, path)?\n                     }\n-                    _ => pat = PatKind::Path(qself, path),\n+                    token::OpenDelim(token::Brace) => self.parse_pat_struct(qself, path)?,\n+                    token::OpenDelim(token::Paren) => self.parse_pat_tuple_struct(qself, path)?,\n+                    _ => PatKind::Path(qself, path),\n                 }\n             } else {\n                 // Try to parse everything else as literal with optional minus\n                 match self.parse_literal_maybe_minus() {\n-                    Ok(begin) => {\n-                        let op_span = self.token.span;\n-                        if self.check(&token::DotDot) || self.check(&token::DotDotEq) ||\n-                                self.check(&token::DotDotDot) {\n-                            let (end_kind, form) = if self.eat(&token::DotDotDot) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n-                            } else if self.eat(&token::DotDotEq) {\n-                                (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n-                            } else if self.eat(&token::DotDot) {\n-                                (RangeEnd::Excluded, \"..\")\n-                            } else {\n-                                panic!(\"impossible case: we already matched \\\n-                                        on a range-operator token\")\n-                            };\n-                            let end = self.parse_pat_range_end_opt(&begin, form)?;\n-                            pat = PatKind::Range(begin, end, respan(op_span, end_kind))\n-                        } else {\n-                            pat = PatKind::Lit(begin);\n-                        }\n-                    }\n-                    Err(mut err) => {\n-                        self.cancel(&mut err);\n-                        let expected = expected.unwrap_or(\"pattern\");\n-                        let msg = format!(\n-                            \"expected {}, found {}\",\n-                            expected,\n-                            self.this_token_descr(),\n-                        );\n-                        let mut err = self.fatal(&msg);\n-                        err.span_label(self.token.span, format!(\"expected {}\", expected));\n-                        let sp = self.sess.source_map().start_point(self.token.span);\n-                        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n-                            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n-                        }\n-                        return Err(err);\n+                    Ok(begin)\n+                        if self.check(&token::DotDot)\n+                            || self.check(&token::DotDotEq)\n+                            || self.check(&token::DotDotDot) =>\n+                    {\n+                        self.parse_pat_range_starting_with_lit(begin)?\n                     }\n+                    Ok(begin) => PatKind::Lit(begin),\n+                    Err(err) => return self.fatal_unexpected_non_pat(err, expected),\n                 }\n             }\n-        }\n+        };\n \n         let pat = self.mk_pat(lo.to(self.prev_span), pat);\n         let pat = self.maybe_recover_from_bad_qpath(pat, true)?;\n \n         if !allow_range_pat {\n-            match pat.node {\n-                PatKind::Range(\n-                    _, _, Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n-                ) => {},\n-                PatKind::Range(..) => {\n-                    let mut err = self.struct_span_err(\n-                        pat.span,\n-                        \"the range pattern here has ambiguous interpretation\",\n-                    );\n-                    err.span_suggestion(\n-                        pat.span,\n-                        \"add parentheses to clarify the precedence\",\n-                        format!(\"({})\", pprust::pat_to_string(&pat)),\n-                        // \"ambiguous interpretation\" implies that we have to be guessing\n-                        Applicability::MaybeIncorrect\n-                    );\n-                    return Err(err);\n-                }\n-                _ => {}\n-            }\n+            self.ban_pat_range_if_ambiguous(&pat)?\n         }\n \n         Ok(pat)\n     }\n \n+    /// Ban a range pattern if it has an ambiguous interpretation.\n+    fn ban_pat_range_if_ambiguous(&self, pat: &Pat) -> PResult<'a, ()> {\n+        match pat.node {\n+            PatKind::Range(\n+                .., Spanned { node: RangeEnd::Included(RangeSyntax::DotDotDot), .. }\n+            ) => return Ok(()),\n+            PatKind::Range(..) => {}\n+            _ => return Ok(()),\n+        }\n+\n+        let mut err = self.struct_span_err(\n+            pat.span,\n+            \"the range pattern here has ambiguous interpretation\",\n+        );\n+        err.span_suggestion(\n+            pat.span,\n+            \"add parentheses to clarify the precedence\",\n+            format!(\"({})\", pprust::pat_to_string(&pat)),\n+            // \"ambiguous interpretation\" implies that we have to be guessing\n+            Applicability::MaybeIncorrect\n+        );\n+        Err(err)\n+    }\n+\n+    /// Parse `&pat` / `&mut pat`.\n+    fn parse_pat_deref(&mut self, expected: Option<&'static str>) -> PResult<'a, PatKind> {\n+        self.expect_and()?;\n+        let mutbl = self.parse_mutability();\n+\n+        if let token::Lifetime(name) = self.token.kind {\n+            let mut err = self.fatal(&format!(\"unexpected lifetime `{}` in pattern\", name));\n+            err.span_label(self.token.span, \"unexpected lifetime\");\n+            return Err(err);\n+        }\n+\n+        let subpat = self.parse_pat_with_range_pat(false, expected)?;\n+        Ok(PatKind::Ref(subpat, mutbl))\n+    }\n+\n+    /// Parse a tuple or parenthesis pattern.\n+    fn parse_pat_tuple_or_parens(&mut self) -> PResult<'a, PatKind> {\n+        let (fields, trailing_comma) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+\n+        // Here, `(pat,)` is a tuple pattern.\n+        // For backward compatibility, `(..)` is a tuple pattern as well.\n+        Ok(if fields.len() == 1 && !(trailing_comma || fields[0].is_rest()) {\n+            PatKind::Paren(fields.into_iter().nth(0).unwrap())\n+        } else {\n+            PatKind::Tuple(fields)\n+        })\n+    }\n+\n+    /// Recover on `mut ref? ident @ pat` and suggest\n+    /// that the order of `mut` and `ref` is incorrect.\n+    fn recover_pat_ident_mut_first(&mut self) -> PResult<'a, PatKind> {\n+        let mutref_span = self.prev_span.to(self.token.span);\n+        let binding_mode = if self.eat_keyword(kw::Ref) {\n+            self.struct_span_err(mutref_span, \"the order of `mut` and `ref` is incorrect\")\n+                .span_suggestion(\n+                    mutref_span,\n+                    \"try switching the order\",\n+                    \"ref mut\".into(),\n+                    Applicability::MachineApplicable\n+                )\n+                .emit();\n+            BindingMode::ByRef(Mutability::Mutable)\n+        } else {\n+            BindingMode::ByValue(Mutability::Mutable)\n+        };\n+        self.parse_pat_ident(binding_mode)\n+    }\n+\n+    /// Parse macro invocation\n+    fn parse_pat_mac_invoc(&mut self, lo: Span, path: Path) -> PResult<'a, PatKind> {\n+        self.bump();\n+        let (delim, tts) = self.expect_delimited_token_tree()?;\n+        let mac = respan(lo.to(self.prev_span), Mac_ {\n+            path,\n+            tts,\n+            delim,\n+            prior_type_ascription: self.last_type_ascription,\n+        });\n+        Ok(PatKind::Mac(mac))\n+    }\n+\n+    /// Parse a range pattern `$path $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_path(\n+        &mut self,\n+        lo: Span,\n+        qself: Option<QSelf>,\n+        path: Path\n+    ) -> PResult<'a, PatKind> {\n+        let (end_kind, form) = match self.token.kind {\n+            token::DotDot => (RangeEnd::Excluded, \"..\"),\n+            token::DotDotDot => (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\"),\n+            token::DotDotEq => (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\"),\n+            _ => panic!(\"can only parse `..`/`...`/`..=` for ranges (checked above)\"),\n+        };\n+        let op_span = self.token.span;\n+        // Parse range\n+        let span = lo.to(self.prev_span);\n+        let begin = self.mk_expr(span, ExprKind::Path(qself, path), ThinVec::new());\n+        self.bump();\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    /// Parse a range pattern `$literal $form $end?` where `$form = \"..\" | \"...\" | \"..=\" ;`.\n+    /// The `$path` has already been parsed and the next token is the `$form`.\n+    fn parse_pat_range_starting_with_lit(&mut self, begin: P<Expr>) -> PResult<'a, PatKind> {\n+        let op_span = self.token.span;\n+        let (end_kind, form) = if self.eat(&token::DotDotDot) {\n+            (RangeEnd::Included(RangeSyntax::DotDotDot), \"...\")\n+        } else if self.eat(&token::DotDotEq) {\n+            (RangeEnd::Included(RangeSyntax::DotDotEq), \"..=\")\n+        } else if self.eat(&token::DotDot) {\n+            (RangeEnd::Excluded, \"..\")\n+        } else {\n+            panic!(\"impossible case: we already matched on a range-operator token\")\n+        };\n+        let end = self.parse_pat_range_end_opt(&begin, form)?;\n+        Ok(PatKind::Range(begin, end, respan(op_span, end_kind)))\n+    }\n+\n+    fn fatal_unexpected_non_pat(\n+        &mut self,\n+        mut err: DiagnosticBuilder<'a>,\n+        expected: Option<&'static str>,\n+    ) -> PResult<'a, P<Pat>> {\n+        self.cancel(&mut err);\n+\n+        let expected = expected.unwrap_or(\"pattern\");\n+        let msg = format!(\"expected {}, found {}\", expected, self.this_token_descr());\n+\n+        let mut err = self.fatal(&msg);\n+        err.span_label(self.token.span, format!(\"expected {}\", expected));\n+\n+        let sp = self.sess.source_map().start_point(self.token.span);\n+        if let Some(sp) = self.sess.ambiguous_block_expr_parse.borrow().get(&sp) {\n+            self.sess.expr_parentheses_needed(&mut err, *sp, None);\n+        }\n+\n+        Err(err)\n+    }\n+\n     // Helper function to decide whether to parse as ident binding\n     // or to try to do something more complex like range patterns.\n     fn parse_as_ident(&mut self) -> bool {\n@@ -421,33 +430,62 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses `ident` or `ident @ pat`.\n-    /// used by the copy foo and ref foo patterns to give a good\n+    /// Used by the copy foo and ref foo patterns to give a good\n     /// error message when parsing mistakes like `ref foo(a, b)`.\n-    fn parse_pat_ident(&mut self,\n-                       binding_mode: ast::BindingMode)\n-                       -> PResult<'a, PatKind> {\n+    fn parse_pat_ident(&mut self, binding_mode: BindingMode) -> PResult<'a, PatKind> {\n         let ident = self.parse_ident()?;\n         let sub = if self.eat(&token::At) {\n             Some(self.parse_pat(Some(\"binding pattern\"))?)\n         } else {\n             None\n         };\n \n-        // just to be friendly, if they write something like\n-        //   ref Some(i)\n-        // we end up here with ( as the current token.  This shortly\n-        // leads to a parse error.  Note that if there is no explicit\n+        // Just to be friendly, if they write something like `ref Some(i)`,\n+        // we end up here with `(` as the current token.\n+        // This shortly leads to a parse error. Note that if there is no explicit\n         // binding mode then we do not end up here, because the lookahead\n-        // will direct us over to parse_enum_variant()\n+        // will direct us over to `parse_enum_variant()`.\n         if self.token == token::OpenDelim(token::Paren) {\n             return Err(self.span_fatal(\n                 self.prev_span,\n-                \"expected identifier, found enum pattern\"))\n+                \"expected identifier, found enum pattern\",\n+            ))\n         }\n \n         Ok(PatKind::Ident(binding_mode, ident, sub))\n     }\n \n+    /// Parse a struct (\"record\") pattern (e.g. `Foo { ... }` or `Foo::Bar { ... }`).\n+    fn parse_pat_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `{` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+\n+        self.bump();\n+        let (fields, etc) = self.parse_pat_fields().unwrap_or_else(|mut e| {\n+            e.emit();\n+            self.recover_stmt();\n+            (vec![], true)\n+        });\n+        self.bump();\n+        Ok(PatKind::Struct(path, fields, etc))\n+    }\n+\n+    /// Parse tuple struct or tuple variant pattern (e.g. `Foo(...)` or `Foo::Bar(...)`).\n+    fn parse_pat_tuple_struct(&mut self, qself: Option<QSelf>, path: Path) -> PResult<'a, PatKind> {\n+        if qself.is_some() {\n+            let msg = \"unexpected `(` after qualified path\";\n+            let mut err = self.fatal(msg);\n+            err.span_label(self.token.span, msg);\n+            return Err(err);\n+        }\n+        let (fields, _) = self.parse_paren_comma_seq(|p| p.parse_pat(None))?;\n+        Ok(PatKind::TupleStruct(path, fields))\n+    }\n+\n     /// Parses the fields of a struct-like pattern.\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<Spanned<FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n@@ -482,17 +520,7 @@ impl<'a> Parser<'a> {\n                 etc = true;\n                 let mut etc_sp = self.token.span;\n \n-                if self.token == token::DotDotDot { // Issue #46718\n-                    // Accept `...` as if it were `..` to avoid further errors\n-                    self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n-                        .span_suggestion(\n-                            self.token.span,\n-                            \"to omit remaining fields, use one fewer `.`\",\n-                            \"..\".to_owned(),\n-                            Applicability::MachineApplicable\n-                        )\n-                        .emit();\n-                }\n+                self.recover_one_fewer_dotdot();\n                 self.bump();  // `..` || `...`\n \n                 if self.token == token::CloseDelim(token::Brace) {\n@@ -574,6 +602,23 @@ impl<'a> Parser<'a> {\n         return Ok((fields, etc));\n     }\n \n+    /// Recover on `...` as if it were `..` to avoid further errors.\n+    /// See issue #46718.\n+    fn recover_one_fewer_dotdot(&self) {\n+        if self.token != token::DotDotDot {\n+            return;\n+        }\n+\n+        self.struct_span_err(self.token.span, \"expected field pattern, found `...`\")\n+            .span_suggestion(\n+                self.token.span,\n+                \"to omit remaining fields, use one fewer `.`\",\n+                \"..\".to_owned(),\n+                Applicability::MachineApplicable\n+            )\n+            .emit();\n+    }\n+\n     fn parse_pat_field(\n         &mut self,\n         lo: Span,\n@@ -620,6 +665,7 @@ impl<'a> Parser<'a> {\n                 pat: subpat,\n                 is_shorthand,\n                 attrs: attrs.into(),\n+                id: ast::DUMMY_NODE_ID,\n            }\n         })\n     }"}, {"sha": "750d8fbbddc001e7f5421ec3a281efa9aeb77d29", "filename": "src/libsyntax/parse/parser/stmt.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser%2Fstmt.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -167,7 +167,22 @@ impl<'a> Parser<'a> {\n                     if self.token == token::Semi {\n                         unused_attrs(&attrs, self);\n                         self.bump();\n-                        return Ok(None);\n+                        let mut last_semi = lo;\n+                        while self.token == token::Semi {\n+                            last_semi = self.token.span;\n+                            self.bump();\n+                        }\n+                        // We are encoding a string of semicolons as an\n+                        // an empty tuple that spans the excess semicolons\n+                        // to preserve this info until the lint stage\n+                        return Ok(Some(Stmt {\n+                            id: ast::DUMMY_NODE_ID,\n+                            span: lo.to(last_semi),\n+                            node: StmtKind::Semi(self.mk_expr(lo.to(last_semi),\n+                                ExprKind::Tup(Vec::new()),\n+                                ThinVec::new()\n+                            )),\n+                        }));\n                     }\n \n                     if self.token == token::CloseDelim(token::Brace) {"}, {"sha": "8b97ec3da0bc99caea82a31c5a429acb4bb83be4", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1402,7 +1402,7 @@ impl<'a> State<'a> {\n         for v in variants {\n             self.space_if_not_bol();\n             self.maybe_print_comment(v.span.lo());\n-            self.print_outer_attributes(&v.node.attrs);\n+            self.print_outer_attributes(&v.attrs);\n             self.ibox(INDENT_UNIT);\n             self.print_variant(v);\n             self.s.word(\",\");\n@@ -1492,8 +1492,8 @@ impl<'a> State<'a> {\n     crate fn print_variant(&mut self, v: &ast::Variant) {\n         self.head(\"\");\n         let generics = ast::Generics::default();\n-        self.print_struct(&v.node.data, &generics, v.node.ident, v.span, false);\n-        match v.node.disr_expr {\n+        self.print_struct(&v.data, &generics, v.ident, v.span, false);\n+        match v.disr_expr {\n             Some(ref d) => {\n                 self.s.space();\n                 self.word_space(\"=\");"}, {"sha": "25214673e69355b8b6f04424fabb0a77946b8692", "filename": "src/libsyntax/print/pprust/tests.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust%2Ftests.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -54,14 +54,15 @@ fn test_variant_to_string() {\n     with_default_globals(|| {\n         let ident = ast::Ident::from_str(\"principal_skinner\");\n \n-        let var = source_map::respan(syntax_pos::DUMMY_SP, ast::Variant_ {\n+        let var = ast::Variant {\n             ident,\n             attrs: Vec::new(),\n             id: ast::DUMMY_NODE_ID,\n             // making this up as I go.... ?\n             data: ast::VariantData::Unit(ast::DUMMY_NODE_ID),\n             disr_expr: None,\n-        });\n+            span: syntax_pos::DUMMY_SP,\n+        };\n \n         let varstr = variant_to_string(&var);\n         assert_eq!(varstr, \"principal_skinner\");"}, {"sha": "41b8ef16665a4cdbf34a3baa4e1c84d44cf6e059", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -311,11 +311,11 @@ pub fn walk_variant<'a, V>(visitor: &mut V,\n                            item_id: NodeId)\n     where V: Visitor<'a>,\n {\n-    visitor.visit_ident(variant.node.ident);\n-    visitor.visit_variant_data(&variant.node.data, variant.node.ident,\n+    visitor.visit_ident(variant.ident);\n+    visitor.visit_variant_data(&variant.data, variant.ident,\n                              generics, item_id, variant.span);\n-    walk_list!(visitor, visit_anon_const, &variant.node.disr_expr);\n-    walk_list!(visitor, visit_attribute, &variant.node.attrs);\n+    walk_list!(visitor, visit_anon_const, &variant.disr_expr);\n+    walk_list!(visitor, visit_attribute, &variant.attrs);\n }\n \n pub fn walk_ty<'a, V: Visitor<'a>>(visitor: &mut V, typ: &'a Ty) {"}, {"sha": "950166f9260e2358f58a6956d2266c28de3ae30f", "filename": "src/libsyntax_ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fasm.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -47,10 +47,10 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                        -> Box<dyn base::MacResult + 'cx> {\n     let mut inline_asm = match parse_inline_asm(cx, sp, tts) {\n         Ok(Some(inline_asm)) => inline_asm,\n-        Ok(None) => return DummyResult::expr(sp),\n+        Ok(None) => return DummyResult::any(sp),\n         Err(mut err) => {\n             err.emit();\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n     };\n "}, {"sha": "e3ef39075e236c1e99bb05b4bc935b6dea3380d1", "filename": "src/libsyntax_ext/assert.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fassert.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -20,7 +20,7 @@ pub fn expand_assert<'cx>(\n         Ok(assert) => assert,\n         Err(mut err) => {\n             err.emit();\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n     };\n "}, {"sha": "0e52c1af9086f019edcbd572a18f878b4d4d2895", "filename": "src/libsyntax_ext/cfg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fcfg.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -25,7 +25,7 @@ pub fn expand_cfg(\n         }\n         Err(mut err) => {\n             err.emit();\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }"}, {"sha": "4cd17531a4500ba8dfbbfb3781d47f16d0c70905", "filename": "src/libsyntax_ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fconcat.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1,5 +1,5 @@\n use syntax::ast;\n-use syntax::ext::base;\n+use syntax::ext::base::{self, DummyResult};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n \n@@ -12,7 +12,7 @@ pub fn expand_syntax_ext(\n ) -> Box<dyn base::MacResult + 'static> {\n     let es = match base::get_exprs_from_tts(cx, sp, tts) {\n         Some(e) => e,\n-        None => return base::DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n     };\n     let mut accumulator = String::new();\n     let mut missing_literal = vec![];\n@@ -55,9 +55,9 @@ pub fn expand_syntax_ext(\n         let mut err = cx.struct_span_err(missing_literal, \"expected a literal\");\n         err.note(\"only literals (like `\\\"foo\\\"`, `42` and `3.14`) can be passed to `concat!()`\");\n         err.emit();\n-        return base::DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     } else if has_errors {\n-        return base::DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     }\n     let sp = sp.apply_mark(cx.current_expansion.id);\n     base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&accumulator)))"}, {"sha": "d80da566185cc26a29a6ede703daa9fe557acd9c", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -138,7 +138,7 @@ fn cs_clone_shallow(name: &str,\n             }\n             StaticEnum(enum_def, ..) => {\n                 for variant in &enum_def.variants {\n-                    process_variant(cx, &mut stmts, &variant.node.data);\n+                    process_variant(cx, &mut stmts, &variant.data);\n                 }\n             }\n             _ => cx.span_bug(trait_span, &format!(\"unexpected substructure in \\\n@@ -170,9 +170,9 @@ fn cs_clone(name: &str,\n             vdata = vdata_;\n         }\n         EnumMatching(.., variant, ref af) => {\n-            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.node.ident]);\n+            ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n-            vdata = &variant.node.data;\n+            vdata = &variant.data;\n         }\n         EnumNonMatchingCollapsed(..) => {\n             cx.span_bug(trait_span,"}, {"sha": "5d7c4a84389c61c773d6bed68806de3cb85a9a59", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -75,7 +75,7 @@ fn cs_total_eq_assert(cx: &mut ExtCtxt<'_>,\n         }\n         StaticEnum(enum_def, ..) => {\n             for variant in &enum_def.variants {\n-                process_variant(cx, &mut stmts, &variant.node.data);\n+                process_variant(cx, &mut stmts, &variant.data);\n             }\n         }\n         _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\")"}, {"sha": "15e93f2843a12c36eafd28c37ef2a933d29cade0", "filename": "src/libsyntax_ext/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -53,7 +53,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n     // based on the \"shape\".\n     let (ident, vdata, fields) = match substr.fields {\n         Struct(vdata, fields) => (substr.type_ident, *vdata, fields),\n-        EnumMatching(_, _, v, fields) => (v.node.ident, &v.node.data, fields),\n+        EnumMatching(_, _, v, fields) => (v.ident, &v.data, fields),\n         EnumNonMatchingCollapsed(..) |\n         StaticStruct(..) |\n         StaticEnum(..) => cx.span_bug(span, \"nonsensical .fields in `#[derive(Debug)]`\"),"}, {"sha": "52e74a7c57e8ca26bed7c06ef98c420a9b595e70", "filename": "src/libsyntax_ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -238,7 +238,7 @@ fn encodable_substructure(cx: &mut ExtCtxt<'_>,\n             }\n \n             let blk = cx.lambda_stmts_1(trait_span, stmts, blkarg);\n-            let name = cx.expr_str(trait_span, variant.node.ident.name);\n+            let name = cx.expr_str(trait_span, variant.ident.name);\n             let call = cx.expr_method_call(trait_span,\n                                            blkencoder,\n                                            cx.ident_of(\"emit_enum_variant\"),"}, {"sha": "a454593bc6575e34a05b3900a6e9d0e4f23e0697", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -758,7 +758,7 @@ impl<'a> TraitDef<'a> {\n         let mut field_tys = Vec::new();\n \n         for variant in &enum_def.variants {\n-            field_tys.extend(variant.node\n+            field_tys.extend(variant\n                 .data\n                 .fields()\n                 .iter()\n@@ -1220,7 +1220,7 @@ impl<'a> MethodDef<'a> {\n         let catch_all_substructure =\n             EnumNonMatchingCollapsed(self_arg_idents, &variants[..], &vi_idents[..]);\n \n-        let first_fieldless = variants.iter().find(|v| v.node.data.fields().is_empty());\n+        let first_fieldless = variants.iter().find(|v| v.data.fields().is_empty());\n \n         // These arms are of the form:\n         // (Variant1, Variant1, ...) => Body1\n@@ -1229,7 +1229,7 @@ impl<'a> MethodDef<'a> {\n         // where each tuple has length = self_args.len()\n         let mut match_arms: Vec<ast::Arm> = variants.iter()\n             .enumerate()\n-            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.node.data.fields().is_empty()))\n+            .filter(|&(_, v)| !(self.unify_fieldless_variants && v.data.fields().is_empty()))\n             .map(|(index, variant)| {\n                 let mk_self_pat = |cx: &mut ExtCtxt<'_>, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(cx,\n@@ -1513,8 +1513,8 @@ impl<'a> MethodDef<'a> {\n             .iter()\n             .map(|v| {\n                 let sp = v.span.with_ctxt(trait_.span.ctxt());\n-                let summary = trait_.summarise_struct(cx, &v.node.data);\n-                (v.node.ident, sp, summary)\n+                let summary = trait_.summarise_struct(cx, &v.data);\n+                (v.ident, sp, summary)\n             })\n             .collect();\n         self.call_substructure_method(cx,\n@@ -1613,6 +1613,7 @@ impl<'a> TraitDef<'a> {\n                         source_map::Spanned {\n                             span: pat.span.with_ctxt(self.span.ctxt()),\n                             node: ast::FieldPat {\n+                                id: ast::DUMMY_NODE_ID,\n                                 ident: ident.unwrap(),\n                                 pat,\n                                 is_shorthand: false,\n@@ -1643,9 +1644,9 @@ impl<'a> TraitDef<'a> {\n          mutbl: ast::Mutability)\n          -> (P<ast::Pat>, Vec<(Span, Option<Ident>, P<Expr>, &'a [ast::Attribute])>) {\n         let sp = variant.span.with_ctxt(self.span.ctxt());\n-        let variant_path = cx.path(sp, vec![enum_ident, variant.node.ident]);\n+        let variant_path = cx.path(sp, vec![enum_ident, variant.ident]);\n         let use_temporaries = false; // enums can't be repr(packed)\n-        self.create_struct_pattern(cx, variant_path, &variant.node.data, prefix, mutbl,\n+        self.create_struct_pattern(cx, variant_path, &variant.data, prefix, mutbl,\n                                    use_temporaries)\n     }\n }\n@@ -1776,7 +1777,7 @@ pub fn is_type_without_fields(item: &Annotatable) -> bool {\n     if let Annotatable::Item(ref item) = *item {\n         match item.node {\n             ast::ItemKind::Enum(ref enum_def, _) => {\n-                enum_def.variants.iter().all(|v| v.node.data.fields().is_empty())\n+                enum_def.variants.iter().all(|v| v.data.fields().is_empty())\n             }\n             ast::ItemKind::Struct(ref variant_data, _) => variant_data.fields().is_empty(),\n             _ => false,"}, {"sha": "442f27c78218564a32a9f7d1705a57909bb9675f", "filename": "src/libsyntax_ext/env.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fenv.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -16,7 +16,7 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n                               tts: &[tokenstream::TokenTree])\n                               -> Box<dyn base::MacResult + 'cx> {\n     let var = match get_single_str_from_tts(cx, sp, tts, \"option_env!\") {\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some(v) => v,\n     };\n \n@@ -50,35 +50,35 @@ pub fn expand_env<'cx>(cx: &'cx mut ExtCtxt<'_>,\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n         Some(ref exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some(exprs) => exprs.into_iter(),\n     };\n \n     let var = match expr_to_string(cx, exprs.next().unwrap(), \"expected string literal\") {\n-        None => return DummyResult::expr(sp),\n+        None => return DummyResult::any(sp),\n         Some((v, _style)) => v,\n     };\n     let msg = match exprs.next() {\n         None => Symbol::intern(&format!(\"environment variable `{}` not defined\", var)),\n         Some(second) => {\n             match expr_to_string(cx, second, \"expected string literal\") {\n-                None => return DummyResult::expr(sp),\n+                None => return DummyResult::any(sp),\n                 Some((s, _style)) => s,\n             }\n         }\n     };\n \n     if exprs.next().is_some() {\n         cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n-        return DummyResult::expr(sp);\n+        return DummyResult::any(sp);\n     }\n \n     let e = match env::var(&*var.as_str()) {\n         Err(_) => {\n             cx.span_err(sp, &msg.as_str());\n-            return DummyResult::expr(sp);\n+            return DummyResult::any(sp);\n         }\n         Ok(s) => cx.expr_str(sp, Symbol::intern(&s)),\n     };"}, {"sha": "d699b3b1a90c2fcf4eaa8c16b1e5c8ce32ea7f8b", "filename": "src/libsyntax_ext/format.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fformat.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -805,7 +805,7 @@ fn expand_format_args_impl<'cx>(\n         }\n         Err(mut err) => {\n             err.emit();\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }"}, {"sha": "70325539f301f4550698a4e58f126ab293775d90", "filename": "src/libsyntax_ext/proc_macro_harness.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fproc_macro_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fproc_macro_harness.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1,18 +1,17 @@\n use std::mem;\n \n+use smallvec::smallvec;\n use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::source_map::{ExpnInfo, ExpnKind, respan};\n use syntax::ext::base::{ExtCtxt, MacroKind};\n-use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::hygiene::ExpnId;\n use syntax::ext::proc_macro::is_proc_macro_attr;\n-use syntax::mut_visit::MutVisitor;\n use syntax::parse::ParseSess;\n use syntax::ptr::P;\n use syntax::symbol::{kw, sym};\n use syntax::visit::{self, Visitor};\n-\n use syntax_pos::{Span, DUMMY_SP};\n \n struct ProcMacroDerive {\n@@ -409,5 +408,7 @@ fn mk_decls(\n         i\n     });\n \n-    cx.monotonic_expander().flat_map_item(module).pop().unwrap()\n+    // Integrate the new module into existing module structures.\n+    let module = AstFragment::Items(smallvec![module]);\n+    cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap()\n }"}, {"sha": "cbc01b48afd03644d30b10105f9fc4e86307c274", "filename": "src/libsyntax_ext/source_util.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fsource_util.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -111,7 +111,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::To\n                           -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_str!\") {\n         Some(f) => f,\n-        None => return DummyResult::expr(sp)\n+        None => return DummyResult::any(sp)\n     };\n     let file = cx.resolve_path(file, sp);\n     match fs::read_to_string(&file) {\n@@ -126,11 +126,11 @@ pub fn expand_include_str(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::To\n         },\n         Err(ref e) if e.kind() == ErrorKind::InvalidData => {\n             cx.span_err(sp, &format!(\"{} wasn't a utf-8 file\", file.display()));\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }\n@@ -139,7 +139,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::\n                             -> Box<dyn base::MacResult+'static> {\n     let file = match get_single_str_from_tts(cx, sp, tts, \"include_bytes!\") {\n         Some(f) => f,\n-        None => return DummyResult::expr(sp)\n+        None => return DummyResult::any(sp)\n     };\n     let file = cx.resolve_path(file, sp);\n     match fs::read(&file) {\n@@ -158,7 +158,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt<'_>, sp: Span, tts: &[tokenstream::\n         },\n         Err(e) => {\n             cx.span_err(sp, &format!(\"couldn't read {}: {}\", file.display(), e));\n-            DummyResult::expr(sp)\n+            DummyResult::any(sp)\n         }\n     }\n }"}, {"sha": "0267637e5406222d245613be1a1ec6921351f187", "filename": "src/libsyntax_ext/test_harness.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Flibsyntax_ext%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Ftest_harness.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -6,7 +6,7 @@ use syntax::ast::{self, Ident};\n use syntax::attr;\n use syntax::entry::{self, EntryPointType};\n use syntax::ext::base::{ExtCtxt, Resolver};\n-use syntax::ext::expand::ExpansionConfig;\n+use syntax::ext::expand::{AstFragment, ExpansionConfig};\n use syntax::ext::hygiene::{ExpnId, MacroKind};\n use syntax::feature_gate::Features;\n use syntax::mut_visit::{*, ExpectOne};\n@@ -74,12 +74,7 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n         noop_visit_crate(c, self);\n \n         // Create a main function to run our tests\n-        let test_main = {\n-            let unresolved = mk_main(&mut self.cx);\n-            self.cx.ext_cx.monotonic_expander().flat_map_item(unresolved).pop().unwrap()\n-        };\n-\n-        c.module.items.push(test_main);\n+        c.module.items.push(mk_main(&mut self.cx));\n     }\n \n     fn flat_map_item(&mut self, i: P<ast::Item>) -> SmallVec<[P<ast::Item>; 1]> {\n@@ -216,17 +211,22 @@ fn mk_reexport_mod(cx: &mut TestCtxt<'_>,\n     let name = Ident::from_str(\"__test_reexports\").gensym();\n     let parent = if parent == ast::DUMMY_NODE_ID { ast::CRATE_NODE_ID } else { parent };\n     cx.ext_cx.current_expansion.id = cx.ext_cx.resolver.get_module_scope(parent);\n-    let it = cx.ext_cx.monotonic_expander().flat_map_item(P(ast::Item {\n+    let module = P(ast::Item {\n         ident: name,\n         attrs: Vec::new(),\n         id: ast::DUMMY_NODE_ID,\n         node: ast::ItemKind::Mod(reexport_mod),\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: DUMMY_SP,\n         tokens: None,\n-    })).pop().unwrap();\n+    });\n \n-    (it, name)\n+    // Integrate the new module into existing module structures.\n+    let module = AstFragment::Items(smallvec![module]);\n+    let module =\n+        cx.ext_cx.monotonic_expander().fully_expand_fragment(module).make_items().pop().unwrap();\n+\n+    (module, name)\n }\n \n /// Crawl over the crate, inserting test reexports and the test main function\n@@ -321,16 +321,19 @@ fn mk_main(cx: &mut TestCtxt<'_>) -> P<ast::Item> {\n         None => Ident::from_str_and_span(\"main\", sp).gensym(),\n     };\n \n-    P(ast::Item {\n+    let main = P(ast::Item {\n         ident: main_id,\n         attrs: vec![main_attr],\n         id: ast::DUMMY_NODE_ID,\n         node: main,\n         vis: dummy_spanned(ast::VisibilityKind::Public),\n         span: sp,\n         tokens: None,\n-    })\n+    });\n \n+    // Integrate the new item into existing module structures.\n+    let main = AstFragment::Items(smallvec![main]);\n+    cx.ext_cx.monotonic_expander().fully_expand_fragment(main).make_items().pop().unwrap()\n }\n \n fn path_name_i(idents: &[Ident]) -> String {"}, {"sha": "838911d9b6e8fc88ee845b805cabcdf7057f1026", "filename": "src/test/ui/async-await/issues/non-async-enclosing-span.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,12 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+async fn do_the_thing() -> u8 {\n+    8\n+}\n+// #63398: point at the enclosing scope and not the previously seen closure\n+fn main() {  //~ NOTE this is not `async`\n+    let x = move || {};\n+    let y = do_the_thing().await; //~ ERROR `await` is only allowed inside `async` functions\n+    //~^ NOTE only allowed inside `async` functions and blocks\n+}"}, {"sha": "f492c1a8045b53892c8ef0fa9c28cef2e9cd906d", "filename": "src/test/ui/async-await/issues/non-async-enclosing-span.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Fissues%2Fnon-async-enclosing-span.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,11 @@\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/non-async-enclosing-span.rs:10:13\n+   |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+LL |     let x = move || {};\n+LL |     let y = do_the_thing().await;\n+   |             ^^^^^^^^^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error: aborting due to previous error\n+"}, {"sha": "1307b5d6ddd82a0fbf424c688281201a48f80af3", "filename": "src/test/ui/block-expr-precedence.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fblock-expr-precedence.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fblock-expr-precedence.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-expr-precedence.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,8 @@\n+warning: unnecessary trailing semicolons\n+  --> $DIR/block-expr-precedence.rs:60:21\n+   |\n+LL |   if (true) { 12; };;; -num;\n+   |                     ^^ help: remove these semicolons\n+   |\n+   = note: `#[warn(redundant_semicolon)]` on by default\n+"}, {"sha": "431ff356ade197a7f21854a5b36620b1b305461a", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -11,10 +11,11 @@ const NON_NULL_PTR: NonNull<u8> = unsafe { mem::transmute(&1) };\n const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+#[deny(const_err)] // this triggers a `const_err` so validation does not even happen\n const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n-//~^ ERROR it is undefined behavior to use this value\n-    let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-    let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+    let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+    // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+    let out_of_bounds_ptr = &ptr[255]; //~ ERROR any use of this value will cause an error\n     mem::transmute(out_of_bounds_ptr)\n } };\n "}, {"sha": "7b3c97e5fbf9608cd92b40be8cd3bd410445e293", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -6,53 +6,58 @@ LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:14:1\n+error: any use of this value will cause an error\n+  --> $DIR/ub-nonnull.rs:18:29\n    |\n LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n-LL | |\n-LL | |     let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n-LL | |     let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+LL | |     let ptr: &[u8; 256] = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+LL | |     // Use address-of-element for pointer arithmetic. This could wrap around to NULL!\n+LL | |     let out_of_bounds_ptr = &ptr[255];\n+   | |                             ^^^^^^^^^ Memory access failed: pointer must be in-bounds at offset 256, but is outside bounds of allocation 6 which has size 1\n LL | |     mem::transmute(out_of_bounds_ptr)\n LL | | } };\n-   | |____^ type validation failed: encountered a potentially NULL pointer, but expected something that cannot possibly fail to be greater or equal to 1\n+   | |____-\n    |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+note: lint level defined here\n+  --> $DIR/ub-nonnull.rs:14:8\n+   |\n+LL | #[deny(const_err)] // this triggers a `const_err` so validation does not even happen\n+   |        ^^^^^^^^^\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:21:1\n+  --> $DIR/ub-nonnull.rs:22:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:23:1\n+  --> $DIR/ub-nonnull.rs:24:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:30:1\n+  --> $DIR/ub-nonnull.rs:31:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:38:1\n+  --> $DIR/ub-nonnull.rs:39:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:44:1\n+  --> $DIR/ub-nonnull.rs:45:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 20, but expected something less or equal to 10, or greater or equal to 30"}, {"sha": "f5edbe2a3af531b41ef7d0b9d44bdd5d249ac9a2", "filename": "src/test/ui/did_you_mean/issue-46836-identifier-not-instead-of-negation.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdid_you_mean%2Fissue-46836-identifier-not-instead-of-negation.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -28,7 +28,10 @@ error: expected `{`, found `;`\n LL |     if not  // lack of braces is [sic]\n    |     -- this `if` statement has a condition, but no block\n LL |         println!(\"Then when?\");\n-   |                               ^ expected `{`\n+   |                               ^\n+   |                               |\n+   |                               expected `{`\n+   |                               help: try placing this code inside a block: `{ ; }`\n \n error: unexpected `2` after identifier\n   --> $DIR/issue-46836-identifier-not-instead-of-negation.rs:26:24"}, {"sha": "0f610a5e42f65060ad380ad2161ce35d80825e49", "filename": "src/test/ui/error-codes/E0282.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0282.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/E0282.rs:2:9\n    |\n LL |     let x = \"hello\".chars().rev().collect();\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "0672014a9292928ada4105fb3ca9c24b4a04e5d9", "filename": "src/test/ui/for/for-loop-unconstrained-element-type.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffor%2Ffor-loop-unconstrained-element-type.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/for-loop-unconstrained-element-type.rs:8:14\n    |\n LL |     for i in Vec::new() { }\n-   |              ^^^^^^^^^^\n-   |              |\n-   |              cannot infer type\n-   |              the element type for this iterator is not specified\n+   |              ^^^^^^^^^^ the element type for this iterator is not specified\n \n error: aborting due to previous error\n "}, {"sha": "42bee81f524c50608aa7ae97ec78407132e70ed6", "filename": "src/test/ui/generator/niche-in-generator.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fgenerator%2Fniche-in-generator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fgenerator%2Fniche-in-generator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Fniche-in-generator.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -1,5 +1,7 @@\n // Test that niche finding works with captured generator upvars.\n \n+// run-pass\n+\n #![feature(generators)]\n \n use std::mem::size_of_val;", "previous_filename": "src/test/run-pass/generator/niche-in-generator.rs"}, {"sha": "30ed5050433a621438c6d499230d503964b85a11", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,18 @@\n+// edition:2018\n+#![feature(async_await)]\n+#![feature(impl_trait_in_bindings)]\n+//~^ WARN the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+\n+use std::io::Error;\n+\n+fn make_unit() -> Result<(), Error> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let fut = async {\n+        make_unit()?; //~ ERROR type annotations needed\n+\n+        Ok(())\n+    };\n+}"}, {"sha": "67a834a2e957aef40c0023348723d5810272c8be", "filename": "src/test/ui/inference/cannot-infer-async-enabled-impl-trait-bindings.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async-enabled-impl-trait-bindings.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,19 @@\n+warning: the feature `impl_trait_in_bindings` is incomplete and may cause the compiler to crash\n+  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:3:12\n+   |\n+LL | #![feature(impl_trait_in_bindings)]\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `#[warn(incomplete_features)]` on by default\n+\n+error[E0282]: type annotations needed for `impl std::future::Future`\n+  --> $DIR/cannot-infer-async-enabled-impl-trait-bindings.rs:14:9\n+   |\n+LL |     let fut = async {\n+   |         --- consider giving `fut` the explicit type `impl std::future::Future`, with the type parameters specified\n+LL |         make_unit()?;\n+   |         ^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "edc64276e7ce42fa8d2199f7c52fb50d6865019a", "filename": "src/test/ui/inference/cannot-infer-async.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,16 @@\n+// edition:2018\n+#![feature(async_await)]\n+\n+use std::io::Error;\n+\n+fn make_unit() -> Result<(), Error> {\n+    Ok(())\n+}\n+\n+fn main() {\n+    let fut = async {\n+        make_unit()?; //~ ERROR type annotations needed\n+\n+        Ok(())\n+    };\n+}"}, {"sha": "36608a11bb73073ca768f697092770d6f7da8d99", "filename": "src/test/ui/inference/cannot-infer-async.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-async.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,11 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot-infer-async.rs:12:9\n+   |\n+LL |     let fut = async {\n+   |         --- consider giving `fut` a type\n+LL |         make_unit()?;\n+   |         ^^^^^^^^^^^^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "8f48483c254218a66f9fcd4afe6cce7e919faf8e", "filename": "src/test/ui/inference/cannot-infer-closure.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let x = |a: (), b: ()| {\n+        Err(a)?; //~ ERROR type annotations needed for the closure\n+        Ok(b)\n+    };\n+}"}, {"sha": "5f30b5d993c1ee84cbeee95fc3d55e3d845c913e", "filename": "src/test/ui/inference/cannot-infer-closure.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Finference%2Fcannot-infer-closure.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn((), ()) -> std::result::Result<(), _>`\n+  --> $DIR/cannot-infer-closure.rs:3:9\n+   |\n+LL |         Err(a)?;\n+   |         ^^^^^^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let x = |a: (), b: ()| -> std::result::Result<(), _> {\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "9b890be3c789b44d86c580d05725db5f0a2d6718", "filename": "src/test/ui/issues/issue-18159.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-18159.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/issue-18159.rs:2:9\n    |\n LL |     let x;\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "77df9921b754ac197d295029eac40558cc31e42b", "filename": "src/test/ui/match/match-unresolved-one-arm.stderr", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-unresolved-one-arm.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -2,10 +2,7 @@ error[E0282]: type annotations needed\n   --> $DIR/match-unresolved-one-arm.rs:4:9\n    |\n LL |     let x = match () {\n-   |         ^\n-   |         |\n-   |         cannot infer type\n-   |         consider giving `x` a type\n+   |         ^ consider giving `x` a type\n \n error: aborting due to previous error\n "}, {"sha": "c3f478fe4207757f11efb0d2669a1b7b18ce48c2", "filename": "src/test/ui/parser/doc-before-semi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -3,4 +3,6 @@ fn main() {\n     //~^ ERROR found a documentation comment that doesn't document anything\n     //~| HELP maybe a comment was intended\n     ;\n+    //~^ WARNING unnecessary trailing semicolon\n+    //~| HELP remove this semicolon\n }"}, {"sha": "b9ac30b09b2f866ae433ca82709e6146a8008da9", "filename": "src/test/ui/parser/doc-before-semi.stderr", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fdoc-before-semi.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -6,6 +6,14 @@ LL |     /// hi\n    |\n    = help: doc comments must come before what they document, maybe a comment was intended with `//`?\n \n+warning: unnecessary trailing semicolon\n+  --> $DIR/doc-before-semi.rs:5:5\n+   |\n+LL |     ;\n+   |     ^ help: remove this semicolon\n+   |\n+   = note: `#[warn(redundant_semicolon)]` on by default\n+\n error: aborting due to previous error\n \n For more information about this error, try `rustc --explain E0585`."}, {"sha": "55835cb88f4e307c60789ca3506ed89ddb649d92", "filename": "src/test/ui/proc-macro/span-preservation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -9,7 +9,7 @@ extern crate test_macros;\n \n #[recollect_attr]\n fn a() {\n-    let x: usize = \"hello\";;;;; //~ ERROR mismatched types\n+    let x: usize = \"hello\"; //~ ERROR mismatched types\n }\n \n #[recollect_attr]"}, {"sha": "0290f4b2cc98259377d9c6e0228906291933ed12", "filename": "src/test/ui/proc-macro/span-preservation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fspan-preservation.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -6,7 +6,7 @@ error[E0308]: mismatched types\n error[E0308]: mismatched types\n   --> $DIR/span-preservation.rs:12:20\n    |\n-LL |     let x: usize = \"hello\";;;;;\n+LL |     let x: usize = \"hello\";\n    |                    ^^^^^^^ expected usize, found reference\n    |\n    = note: expected type `usize`"}, {"sha": "3de02cd0bd4814ab2b535a94e8dec18e6b916ac4", "filename": "src/test/ui/suggestions/suggest-box.fixed", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.fixed?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    let _x: Box<dyn Fn() -> Result<(), ()>> = Box::new(|| { //~ ERROR mismatched types\n+        Err(())?;\n+        Ok(())\n+    });\n+}"}, {"sha": "e680a61db3b177cc912c35927b3075019fe58dd2", "filename": "src/test/ui/suggestions/suggest-box.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,8 @@\n+// run-rustfix\n+\n+fn main() {\n+    let _x: Box<dyn Fn() -> Result<(), ()>> = || { //~ ERROR mismatched types\n+        Err(())?;\n+        Ok(())\n+    };\n+}"}, {"sha": "50c106d63a02b54a72053102ce0c7a3a1123ddd0", "filename": "src/test/ui/suggestions/suggest-box.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-box.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,24 @@\n+error[E0308]: mismatched types\n+  --> $DIR/suggest-box.rs:4:47\n+   |\n+LL |       let _x: Box<dyn Fn() -> Result<(), ()>> = || {\n+   |  _______________________________________________^\n+LL | |         Err(())?;\n+LL | |         Ok(())\n+LL | |     };\n+   | |_____^ expected struct `std::boxed::Box`, found closure\n+   |\n+   = note: expected type `std::boxed::Box<dyn std::ops::Fn() -> std::result::Result<(), ()>>`\n+              found type `[closure@$DIR/suggest-box.rs:4:47: 7:6]`\n+   = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html\n+help: store this in the heap by calling `Box::new`\n+   |\n+LL |     let _x: Box<dyn Fn() -> Result<(), ()>> = Box::new(|| {\n+LL |         Err(())?;\n+LL |         Ok(())\n+LL |     });\n+   |\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "910f273b9722d01474cc7f8ec6e3b8c3cae7242c", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || -> _ { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "de2d29f1270c6c26af800ac12299338c6c19afd0", "filename": "src/test/ui/suggestions/suggest-closure-return-type-1.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-1.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-1.rs:2:24\n+   |\n+LL |     let _v = || -> _ { [] };\n+   |                        ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                    ^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "6955b37ad97e423526043712f4de6b3488b9006a", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || { [] }; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "9dbd822fbb5defc4fd6553e8d8993d7462cf56b2", "filename": "src/test/ui/suggestions/suggest-closure-return-type-2.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-2.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-2.rs:2:19\n+   |\n+LL |     let _v = || { [] };\n+   |                   ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "ec6c094027e1e48fdc32f8b2b733b730b187c27f", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.rs?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    let _v = || []; //~ ERROR type annotations needed for the closure\n+}"}, {"sha": "ad0d4e41f7874b66e43f6d0d6ffe3419bc2609c6", "filename": "src/test/ui/suggestions/suggest-closure-return-type-3.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9e9a136fcec5eb78f09a14dfd072a51ae2550269/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Fsuggest-closure-return-type-3.stderr?ref=9e9a136fcec5eb78f09a14dfd072a51ae2550269", "patch": "@@ -0,0 +1,13 @@\n+error[E0282]: type annotations needed for the closure `fn() -> [_; 0]`\n+  --> $DIR/suggest-closure-return-type-3.rs:2:17\n+   |\n+LL |     let _v = || [];\n+   |                 ^^ cannot infer type\n+help: give this closure an explicit return type without `_` placeholders\n+   |\n+LL |     let _v = || -> [_; 0] { [] };\n+   |                 ^^^^^^^^^^^    ^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}]}