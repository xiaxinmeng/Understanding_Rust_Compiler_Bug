{"sha": "aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlZDQwZmJjZDhlODFjYzFlZjdhNTFiNDBiNzZiNDYzMWNiYTI5OWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-03-09T10:41:50Z"}, "committer": {"name": "unknown", "email": "graydon@.(none)", "date": "2011-03-10T00:15:55Z"}, "message": "Have the pretty-printer take a writer stream as argument\n\nIt now uses a string writer to also fill in for\nmiddle.ty.ast_ty_to_str", "tree": {"sha": "b9fe1cf0f40a6f54ab8b6522a3ed6677b127bb02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9fe1cf0f40a6f54ab8b6522a3ed6677b127bb02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "html_url": "https://github.com/rust-lang/rust/commit/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dddd7d8f447215a88aa87f438d4f495cf54be84d", "url": "https://api.github.com/repos/rust-lang/rust/commits/dddd7d8f447215a88aa87f438d4f495cf54be84d", "html_url": "https://github.com/rust-lang/rust/commit/dddd7d8f447215a88aa87f438d4f495cf54be84d"}], "stats": {"total": 180, "additions": 61, "deletions": 119}, "files": [{"sha": "6366bcafd2e57bb25b7ef416207e649c90e0cb86", "filename": "src/comp/driver/rustc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fdriver%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fdriver%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fdriver%2Frustc.rs?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -66,7 +66,7 @@ impure fn pretty_print_input(session.session sess,\n                              str input) {\n     auto p = front.parser.new_parser(sess, env, 0, input);\n     auto crate = front.parser.parse_crate_from_source_file(p);\n-    pretty.pprust.print_ast(crate.node.module);\n+    pretty.pprust.print_ast(crate.node.module, std.io.stdout_writer());\n }\n \n fn warn_wrong_compiler() {"}, {"sha": "958d0b78ef1ec81fe7c1105dbd06fed7c9e6143a", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 80, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -81,96 +81,17 @@ tag unify_result {\n \n // Stringification\n \n-fn ast_ty_to_str(&@ast.ty ty) -> str {\n-\n-    fn ast_fn_input_to_str(&rec(ast.mode mode, @ast.ty ty) input) -> str {\n-        auto s;\n-        if (mode_is_alias(input.mode)) {\n-            s = \"&\";\n-        } else {\n-            s = \"\";\n-        }\n-\n-        ret s + ast_ty_to_str(input.ty);\n-    }\n-\n-    fn ast_ty_field_to_str(&ast.ty_field f) -> str {\n-        ret ast_ty_to_str(f.ty) + \" \" + f.ident;\n-    }\n-\n-    auto s;\n-    alt (ty.node) {\n-        case (ast.ty_nil)          { s = \"()\";                            }\n-        case (ast.ty_bool)         { s = \"bool\";                          }\n-        case (ast.ty_int)          { s = \"int\";                           }\n-        case (ast.ty_uint)         { s = \"uint\";                          }\n-        case (ast.ty_machine(?tm)) { s = common.ty_mach_to_str(tm);       }\n-        case (ast.ty_char)         { s = \"char\";                          }\n-        case (ast.ty_str)          { s = \"str\";                           }\n-        case (ast.ty_box(?t))      { s = \"@\" + ast_ty_to_str(t);          }\n-        case (ast.ty_vec(?t))      { s = \"vec[\" + ast_ty_to_str(t) + \"]\"; }\n-        case (ast.ty_type)         { s = \"type\";                          }\n-\n-        case (ast.ty_tup(?elts)) {\n-            auto f = ast_ty_to_str;\n-            s = \"tup(\";\n-            s += _str.connect(_vec.map[@ast.ty,str](f, elts), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_rec(?fields)) {\n-            auto f = ast_ty_field_to_str;\n-            s = \"rec(\";\n-            s += _str.connect(_vec.map[ast.ty_field,str](f, fields), \",\");\n-            s += \")\";\n-        }\n-\n-        case (ast.ty_fn(?proto, ?inputs, ?output)) {\n-            auto f = ast_fn_input_to_str;\n-            if (proto == ast.proto_fn) {\n-                s = \"fn(\";\n-            } else {\n-                s = \"iter(\";\n-            }\n-            auto is = _vec.map[rec(ast.mode mode, @ast.ty ty),str](f, inputs);\n-            s += _str.connect(is, \", \");\n-            s += \")\";\n-\n-            if (output.node != ast.ty_nil) {\n-                s += \" -> \" + ast_ty_to_str(output);\n-            }\n-        }\n-\n-        case (ast.ty_path(?path, _)) {\n-            s = path_to_str(path);\n-        }\n-\n-        case (ast.ty_mutable(?t)) {\n-            s = \"mutable \" + ast_ty_to_str(t);\n-        }\n-\n-\n-        case (_) {\n-            fail;   // FIXME: typestate bug\n-        }\n-    }\n-\n-    ret s;\n-}\n-\n fn path_to_str(&ast.path pth) -> str {\n     auto result = _str.connect(pth.node.idents,  \".\");\n     if (_vec.len[@ast.ty](pth.node.types) > 0u) {\n-        auto f = ast_ty_to_str;\n+        auto f = pretty.pprust.ty_to_str;\n         result += \"[\";\n         result += _str.connect(_vec.map[@ast.ty,str](f, pth.node.types), \",\");\n         result += \"]\";\n     }\n     ret result;\n }\n \n-// FIXME use the pretty-printer for this once it has a concept of an\n-// abstract stream\n fn ty_to_str(&@t typ) -> str {\n \n     fn fn_input_to_str(&rec(ast.mode mode, @t ty) input) -> str {"}, {"sha": "d3145180282757509d134e4cf8c1f53750371654", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 28, "deletions": 15, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -17,17 +17,19 @@ type context = rec(contexttype tp, uint indent);\n \n type ps = @rec(mutable vec[context] context,\n                uint width,\n+               io.writer out,\n                mutable vec[token] buffered,\n                mutable uint scandepth,\n                mutable uint bufferedcol,\n                mutable uint col,\n                mutable bool start_of_line);\n \n-fn mkstate(uint width) -> ps {\n+fn mkstate(io.writer out, uint width) -> ps {\n   let vec[context] stack = vec(rec(tp=cx_v, indent=0u));\n   let vec[token] buff = vec();\n   ret @rec(mutable context=stack,\n            width=width,\n+           out=out,\n            mutable buffered=buff,\n            mutable scandepth=0u,\n            mutable bufferedcol=0u,\n@@ -46,10 +48,22 @@ impure fn pop_context(ps p) {\n }\n \n impure fn add_token(ps p, token tok) {\n-  if (p.scandepth == 0u) {do_token(p, tok);}\n+  if (p.width == 0u) {direct_token(p, tok);}\n+  else if (p.scandepth == 0u) {do_token(p, tok);}\n   else {buffer_token(p, tok);}\n }\n \n+impure fn direct_token(ps p, token tok) {\n+  alt (tok) {\n+    case (brk(?sz)) {\n+      while (sz > 0u) {p.out.write_str(\" \"); sz -= 1u;}\n+    }\n+    case (word(?w)) {p.out.write_str(w);}\n+    case (cword(?w)) {p.out.write_str(w);}\n+    case (_) {}\n+  }\n+}\n+\n impure fn buffer_token(ps p, token tok) {\n   p.buffered += vec(tok);\n   p.bufferedcol += token_size(tok);\n@@ -101,14 +115,13 @@ impure fn finish_block_scan(ps p, contexttype tp) {\n \n impure fn finish_break_scan(ps p) {\n   if (p.bufferedcol > p.width) {\n-    write_str(\"\\n\");\n-    p.col = 0u;\n+    line_break(p);\n   }\n   else {\n     auto width;\n     alt (p.buffered.(0)) {case(brk(?w)) {width = w;}}\n     auto i = 0u;\n-    while (i < width) {write_str(\" \"); i+=1u;}\n+    while (i < width) {p.out.write_str(\" \"); i+=1u;}\n     p.col += width;\n   }\n   p.scandepth = 0u;\n@@ -142,20 +155,18 @@ impure fn do_token(ps p, token tok) {\n           start_scan(p, tok);\n         }\n         case (cx_v) {\n-          write_str(\"\\n\");\n-          p.col = 0u;\n-          p.start_of_line = true;\n+          line_break(p);\n         }\n       }\n     }\n     case (word(?w)) {\n       before_print(p, false);\n-      write_str(w);\n+      p.out.write_str(w);\n       p.col += _str.byte_len(w); // TODO char_len\n     }\n     case (cword(?w)) {\n       before_print(p, true);\n-      write_str(w);\n+      p.out.write_str(w);\n       p.col += _str.byte_len(w); // TODO char_len\n     }\n     case (open(?tp, ?indent)) {\n@@ -170,21 +181,23 @@ impure fn do_token(ps p, token tok) {\n   }\n }\n \n+impure fn line_break(ps p) {\n+  p.out.write_str(\"\\n\");\n+  p.col = 0u;\n+  p.start_of_line = true;\n+}\n+\n impure fn before_print(ps p, bool closing) {\n   if (p.start_of_line) {\n     p.start_of_line = false;\n     auto ind;\n     if (closing) {ind = base_indent(p);}\n     else {ind = cur_context(p).indent;}\n     p.col = ind;\n-    while (ind > 0u) {write_str(\" \"); ind -= 1u;}\n+    while (ind > 0u) {p.out.write_str(\" \"); ind -= 1u;}\n   }\n }\n \n-fn write_str(str s) {\n-  io.writefd(1, _str.bytes(s));\n-}\n-\n fn token_size(token tok) -> uint {\n   alt (tok) {\n     case (brk(?sz)) {ret sz;}"}, {"sha": "e766cacda469887536a4fdbe9b96776166c63b6b", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -11,13 +11,19 @@ import foo = std.io;\n const uint indent_unit = 2u;\n const int as_prec = 5;\n \n-impure fn print_ast(ast._mod _mod) {\n-  auto s = pp.mkstate(80u);\n+impure fn print_ast(ast._mod _mod, std.io.writer out) {\n+  auto s = pp.mkstate(out, 80u);\n   for (@ast.view_item vitem in _mod.view_items) {print_view_item(s, vitem);}\n   line(s);\n   for (@ast.item item in _mod.items) {print_item(s, item);}\n }\n \n+fn ty_to_str(&@ast.ty ty) -> str {\n+  auto writer = std.io.string_writer();\n+  print_type(pp.mkstate(writer.get_writer(), 0u), ty);\n+  ret writer.get_str();\n+}\n+\n impure fn hbox(ps s) {\n   pp.hbox(s, indent_unit);\n }"}, {"sha": "c7d3ff6b48291eaae432438aca1f8a5e4398f2ae", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -44,6 +44,7 @@ auth middle.trans = unsafe;\n auth middle.trans.copy_args_to_allocas = impure;\n auth middle.trans.trans_block = impure;\n auth lib.llvm = unsafe;\n+auth pretty.pprust = impure;\n \n mod lib {\n     alt (target_os) {"}, {"sha": "dbe6de7a63bfd6ee0a26dcc42a6e82351c6a3172", "filename": "src/lib/io.rs", "status": "modified", "additions": 22, "deletions": 21, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Flib%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aed40fbcd8e81cc1ef7a51b40b76b4631cba299e/src%2Flib%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fio.rs?ref=aed40fbcd8e81cc1ef7a51b40b76b4631cba299e", "patch": "@@ -91,26 +91,21 @@ tag fileflag {\n     truncate;\n }\n \n-// FIXME move into fd_buf_writer\n-fn writefd(int fd, vec[u8] v) {\n-    auto len = _vec.len[u8](v);\n-    auto count = 0u;\n-    auto vbuf;\n-    while (count < len) {\n-        vbuf = _vec.buf_off[u8](v, count);\n-        auto nout = os.libc.write(fd, vbuf, len);\n-        if (nout < 0) {\n-            log \"error dumping buffer\";\n-            log sys.rustrt.last_os_error();\n-            fail;\n-        }\n-        count += nout as uint;\n-    }\n-}\n-\n state obj fd_buf_writer(int fd, bool must_close) {\n     fn write(vec[u8] v) {\n-        writefd(fd, v);\n+        auto len = _vec.len[u8](v);\n+        auto count = 0u;\n+        auto vbuf;\n+        while (count < len) {\n+            vbuf = _vec.buf_off[u8](v, count);\n+            auto nout = os.libc.write(fd, vbuf, len);\n+            if (nout < 0) {\n+                log \"error dumping buffer\";\n+                log sys.rustrt.last_os_error();\n+                fail;\n+            }\n+            count += nout as uint;\n+        }\n     }\n \n     drop {\n@@ -152,9 +147,15 @@ type writer =\n     };\n \n state obj new_writer(buf_writer out) {\n-    impure fn write_str(str s)   { out.write(_str.bytes(s)); }\n-    impure fn write_int(int n)   { out.write(_str.bytes(_int.to_str(n, 10u))); }\n-    impure fn write_uint(uint n) { out.write(_str.bytes(_uint.to_str(n, 10u))); }\n+    impure fn write_str(str s) {\n+        out.write(_str.bytes(s));\n+    }\n+    impure fn write_int(int n) {\n+        out.write(_str.bytes(_int.to_str(n, 10u)));\n+    }\n+    impure fn write_uint(uint n) {\n+        out.write(_str.bytes(_uint.to_str(n, 10u)));\n+    }\n }\n \n fn file_writer(str path, vec[fileflag] flags) -> writer {"}]}