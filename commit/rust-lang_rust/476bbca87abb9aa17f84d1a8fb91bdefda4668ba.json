{"sha": "476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NmJiY2E4N2FiYjlhYTE3Zjg0ZDFhOGZiOTFiZGVmZGE0NjY4YmE=", "commit": {"author": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-11T01:55:09Z"}, "committer": {"name": "Jesse Ruderman", "email": "jruderman@gmail.com", "date": "2011-09-11T01:55:09Z"}, "message": "Fuzzer: move tys around in addition to exprs", "tree": {"sha": "35b3a78ffddb5c7951f0f1910e257a15b01f7713", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35b3a78ffddb5c7951f0f1910e257a15b01f7713"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "html_url": "https://github.com/rust-lang/rust/commit/476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/476bbca87abb9aa17f84d1a8fb91bdefda4668ba/comments", "author": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jruderman", "id": 692547, "node_id": "MDQ6VXNlcjY5MjU0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/692547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jruderman", "html_url": "https://github.com/jruderman", "followers_url": "https://api.github.com/users/jruderman/followers", "following_url": "https://api.github.com/users/jruderman/following{/other_user}", "gists_url": "https://api.github.com/users/jruderman/gists{/gist_id}", "starred_url": "https://api.github.com/users/jruderman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jruderman/subscriptions", "organizations_url": "https://api.github.com/users/jruderman/orgs", "repos_url": "https://api.github.com/users/jruderman/repos", "events_url": "https://api.github.com/users/jruderman/events{/privacy}", "received_events_url": "https://api.github.com/users/jruderman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8df7c2b0d45e1f69ead3bca145f32ca1a399513d", "url": "https://api.github.com/repos/rust-lang/rust/commits/8df7c2b0d45e1f69ead3bca145f32ca1a399513d", "html_url": "https://github.com/rust-lang/rust/commit/8df7c2b0d45e1f69ead3bca145f32ca1a399513d"}], "stats": {"total": 115, "additions": 94, "deletions": 21}, "files": [{"sha": "899d940b390b4892d64c3bc1652427a755841e5d", "filename": "src/comp/syntax/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/476bbca87abb9aa17f84d1a8fb91bdefda4668ba/src%2Fcomp%2Fsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476bbca87abb9aa17f84d1a8fb91bdefda4668ba/src%2Fcomp%2Fsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fsyntax%2Ffold.rs?ref=476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "patch": "@@ -13,6 +13,7 @@ export noop_fold_crate;\n export noop_fold_item;\n export noop_fold_expr;\n export noop_fold_mod;\n+export noop_fold_ty;\n \n type ast_fold = @mutable a_f;\n "}, {"sha": "91aa770752a1f6cdc4c1d65250d5c9602576bdc1", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 93, "deletions": 21, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/476bbca87abb9aa17f84d1a8fb91bdefda4668ba/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/476bbca87abb9aa17f84d1a8fb91bdefda4668ba/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=476bbca87abb9aa17f84d1a8fb91bdefda4668ba", "patch": "@@ -89,51 +89,95 @@ fn safe_to_steal_expr(e: &@ast::expr) -> bool {\n     }\n }\n \n+fn safe_to_steal_ty(t: &@ast::ty) -> bool {\n+    // Same restrictions\n+    safe_to_replace_ty(t.node)\n+}\n+\n // Not type-parameterized: https://github.com/graydon/rust/issues/898\n fn stash_expr_if(c: fn(&@ast::expr)->bool, es: @mutable [ast::expr], e: &@ast::expr) {\n     if c(e) {\n         *es += [*e];\n     } else {/* now my indices are wrong :( */ }\n }\n \n-fn steal_exprs(crate: &ast::crate) -> [ast::expr] {\n-    let exprs: @mutable [ast::expr] = @mutable [];\n+fn stash_ty_if(c: fn(&@ast::ty)->bool, es: @mutable [ast::ty], e: &@ast::ty) {\n+    if c(e) {\n+        *es += [*e];\n+    } else {/* now my indices are wrong :( */ }\n+}\n+\n+type stolen_stuff = {exprs: [ast::expr], tys: [ast::ty]};\n+\n+fn steal(crate: &ast::crate) -> stolen_stuff {\n+    let exprs = @mutable [];\n+    let tys = @mutable [];\n     let v = visit::mk_simple_visitor(@{\n-        visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _)\n+        visit_expr: bind stash_expr_if(safe_to_steal_expr, exprs, _),\n+        visit_ty: bind stash_ty_if(safe_to_steal_ty, tys, _)\n         with *visit::default_simple_visitor()\n     });\n-    visit::visit_crate(crate, (), v);;\n-    *exprs\n+    visit::visit_crate(crate, (), v);\n+    {exprs: *exprs, tys: *tys}\n }\n \n // https://github.com/graydon/rust/issues/652\n-fn safe_to_replace(e: ast::expr_) -> bool {\n+fn safe_to_replace_expr(e: ast::expr_) -> bool {\n     alt e {\n       ast::expr_if(_, _, _) { false }\n       ast::expr_block(_) { false }\n       _ { true }\n     }\n }\n \n+fn safe_to_replace_ty(t: ast::ty_) -> bool {\n+    alt t {\n+      ast::ty_infer. { false } // always implicit, always top level\n+      ast::ty_bot. { false }   // in source, can only appear as the out type of a function\n+      ast::ty_mac(_) { false }\n+      _ { true }\n+    }\n+}\n+\n // Replace the |i|th expr (in fold order) of |crate| with |newexpr|.\n-fn replace_expr_in_crate(crate: &ast::crate, i: uint, newexpr: ast::expr_) ->\n+fn replace_expr_in_crate(crate: &ast::crate, i: uint, newexpr: &ast::expr) ->\n    ast::crate {\n     let j: @mutable uint = @mutable 0u;\n     fn fold_expr_rep(j_: @mutable uint, i_: uint, newexpr_: &ast::expr_,\n                      original: &ast::expr_, fld: fold::ast_fold) ->\n        ast::expr_ {\n         *j_ += 1u;\n-        if i_ + 1u == *j_ && safe_to_replace(original) {\n+        if i_ + 1u == *j_ && safe_to_replace_expr(original) {\n             newexpr_\n         } else { fold::noop_fold_expr(original, fld) }\n     }\n     let afp =\n-        {fold_expr: bind fold_expr_rep(j, i, newexpr, _, _)\n+        {fold_expr: bind fold_expr_rep(j, i, newexpr.node, _, _)\n+            with *fold::default_ast_fold()};\n+    let af = fold::make_fold(afp);\n+    let crate2: @ast::crate = @af.fold_crate(crate);\n+    fold::dummy_out(af); // work around a leak (https://github.com/graydon/rust/issues/651)\n+    *crate2\n+}\n+\n+// Replace the |i|th ty (in fold order) of |crate| with |newty|.\n+fn replace_ty_in_crate(crate: &ast::crate, i: uint, newty: &ast::ty) ->\n+   ast::crate {\n+    let j: @mutable uint = @mutable 0u;\n+    fn fold_ty_rep(j_: @mutable uint, i_: uint, newty_: &ast::ty_,\n+                     original: &ast::ty_, fld: fold::ast_fold) ->\n+       ast::ty_ {\n+        *j_ += 1u;\n+        if i_ + 1u == *j_ && safe_to_replace_ty(original) {\n+            newty_\n+        } else { fold::noop_fold_ty(original, fld) }\n+    }\n+    let afp =\n+        {fold_ty: bind fold_ty_rep(j, i, newty.node, _, _)\n             with *fold::default_ast_fold()};\n     let af = fold::make_fold(afp);\n     let crate2: @ast::crate = @af.fold_crate(crate);\n     fold::dummy_out(af); // work around a leak (https://github.com/graydon/rust/issues/651)\n-    ;\n     *crate2\n }\n \n@@ -152,14 +196,30 @@ fn as_str(f: fn(io::writer)) -> str {\n \n fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n                          filename: &str) {\n-    let exprs = steal_exprs(crate);\n-    let exprsL = vec::len(exprs);\n-    if exprsL < 100u {\n-        for each i: uint in under(uint::min(exprsL, 20u)) {\n-            log_err \"Replacing... \" + pprust::expr_to_str(@exprs[i]);\n-            for each j: uint in under(uint::min(exprsL, 5u)) {\n-                log_err \"With... \" + pprust::expr_to_str(@exprs[j]);\n-                let crate2 = @replace_expr_in_crate(crate, i, exprs[j].node);\n+    let stolen = steal(crate);\n+    check_variants_T(crate, codemap, filename, \"expr\", stolen.exprs, pprust::expr_to_str, replace_expr_in_crate);\n+    check_variants_T(crate, codemap, filename, \"ty\", stolen.tys, pprust::ty_to_str, replace_ty_in_crate);\n+}\n+\n+fn check_variants_T<T>(\n+  crate: &ast::crate,\n+  codemap: &codemap::codemap,\n+  filename: &str,\n+  thing_label: &str,\n+  things: [T],\n+  stringifier: fn(&@T) -> str,\n+  replacer: fn(&ast::crate, uint, &T) -> ast::crate\n+  ) {\n+    log_err #fmt(\"%s contains %u %s objects\", filename, vec::len(things), thing_label);\n+\n+    let L = vec::len(things);\n+\n+    if L < 100u {\n+        for each i: uint in under(uint::min(L, 20u)) {\n+            log_err \"Replacing... \" + stringifier(@things[i]);\n+            for each j: uint in under(uint::min(L, 5u)) {\n+                log_err \"With... \" + stringifier(@things[j]);\n+                let crate2 = @replacer(crate, i, things[j]);\n                 // It would be best to test the *crate* for stability, but testing the\n                 // string for stability is easier and ok for now.\n                 let str3 =\n@@ -168,8 +228,8 @@ fn check_variants_of_ast(crate: &ast::crate, codemap: &codemap::codemap,\n                                                     io::string_reader(\"\"), _,\n                                                     pprust::no_ann()));\n                 check_roundtrip_convergence(str3, 1u);\n-                //let label = #fmt(\"buggy_%s_%ud_%ud.rs\", last_part(filename), i, j);\n-                //check_whole_compiler(str3, label);\n+                //let file_label = #fmt(\"buggy_%s_%s_%u_%u.rs\", last_part(filename), thing_label, i, j);\n+                //check_whole_compiler(str3, file_label);\n             }\n         }\n     }\n@@ -214,10 +274,21 @@ fn check_whole_compiler_inner(filename: &str) -> compile_result {\n             known_bug(\"https://github.com/graydon/rust/issues/892\")\n         } else if contains(p.err, \"(S->getType()->isPointerTy() && \\\"Invalid cast\\\")\") {\n             known_bug(\"https://github.com/graydon/rust/issues/895\")\n+        } else if contains(p.err, \"Initializer type must match GlobalVariable type\") {\n+            known_bug(\"https://github.com/graydon/rust/issues/899\")\n+        } else if contains(p.err, \"(castIsValid(op, S, Ty) && \\\"Invalid cast!\\\"), function Create\") {\n+            known_bug(\"https://github.com/graydon/rust/issues/901\")\n         } else {\n             log_err \"Stderr: \" + p.err;\n             failed(\"Unfamiliar error message\")\n         }\n+    } else if p.status == 256 {\n+        if contains(p.out, \"Out of stack space, sorry\") {\n+            known_bug(\"Recursive types - https://github.com/graydon/rust/issues/742\")\n+        } else {\n+            log_err \"Stdout: \" + p.out;\n+            failed(\"Unfamiliar sudden exit\")\n+        }\n     } else if p.status == 6 {\n         if contains(p.out, \"get_id_ident: can't find item in ext_map\") {\n             known_bug(\"https://github.com/graydon/rust/issues/876\")\n@@ -235,7 +306,7 @@ fn check_whole_compiler_inner(filename: &str) -> compile_result {\n         passed(\"Accepted the input program\")\n     } else {\n         log_err p.status;\n-        log_err p.out;\n+        log_err \"!Stdout: \" + p.out;\n         failed(\"Unfamiliar status code\")\n     }\n }\n@@ -257,6 +328,7 @@ fn content_is_dangerous_to_modify(code: &str) -> bool {\n     let dangerous_patterns =\n         [\"#macro\", // not safe to steal things inside of it, because they have a special syntax\n          \"#\",      // strange representation of the arguments to #fmt, for example\n+         \"tag\",    // typeck hang: https://github.com/graydon/rust/issues/900\n          \" be \"];  // don't want to replace its child with a non-call: \"Non-call expression in tail call\"\n \n     for p: str in dangerous_patterns { if contains(code, p) { ret true; } }"}]}