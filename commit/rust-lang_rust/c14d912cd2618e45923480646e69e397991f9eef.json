{"sha": "c14d912cd2618e45923480646e69e397991f9eef", "node_id": "C_kwDOAAsO6NoAKGMxNGQ5MTJjZDI2MThlNDU5MjM0ODA2NDZlNjllMzk3OTkxZjllZWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2023-05-10T04:12:13Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-05-10T04:12:13Z"}, "message": "Rollup merge of #110673 - compiler-errors:alias-bounds-2, r=lcnr\n\nMake alias bounds sound in the new solver (take 2)\n\nMake alias bounds sound in the new solver (in a way that does not require coinduction) by only considering them for projection types whose corresponding trait refs come from a param-env candidate.\n\nThat is, given `<T as Trait>::Assoc: Bound`, we only *really* need to consider the alias bound if `T: Trait` is satisfied via a param-env candidate. If it's instead satisfied, e.g., via an user provided impl candidate or a , then that impl should have a concrete type to which we could otherwise normalize `<T as Trait>::Assoc`, and that concrete type is then responsible to prove the `Bound` on it.\n\nSimilar consideration is given to opaque types, since we only need to consider alias bounds if we're *not* in reveal-all mode, since similarly we'd be able to reveal the opaque types and prove any bounds that way.\n\nThis does not remove that hacky \"eager projection replacement\" logic from object bounds, which are somewhat like alias bounds. But removing this eager normalization behavior (added in #108333) would require full coinduction to be enabled. Compare to #110628, which does remove this object-bound custom logic but requires coinduction to be sound.\n\nr? `@lcnr`", "tree": {"sha": "e546520e179bfa7e185e201055afc583b2413bc9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e546520e179bfa7e185e201055afc583b2413bc9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c14d912cd2618e45923480646e69e397991f9eef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkWxmdCRBK7hj4Ov3rIwAAV6IIAJGVU1NfguHRg1+BouzerWXU\nAHbaex7NFkxXSRyLHsnWzop1ukbqlezmADhp9wPwd9JASSvbC3Y1+6kTMLY8YyaL\nmJi283Xl5u18yLIcSvk8VNSfIq+/HlZQyCxaDMjgdNI8UjMmBQfoATzyxvZzW3ge\nLDm0/UrHtTVI0jkMJwKFjhpAcZbINXlF4kWcTRL4cF/gTkvUpqYqrsufcEGCHFAU\n5H8dfohUkZ7uIvgZXrJQtThK33g6fmXszKbeq5ebNoG9IMRjOaOS6JXvgFzeis+Q\ntvjCO76OkLWMP7wArG1glU/Cc14FctS6HmmhVzHBaFDp/wi053nufSqUI3TmP30=\n=FSX2\n-----END PGP SIGNATURE-----\n", "payload": "tree e546520e179bfa7e185e201055afc583b2413bc9\nparent 65dfca8488d635552eb246eb8e15df646e987cff\nparent 3a863e534bcba819a4ff8d8362df442001a3dd8a\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1683691933 +0200\ncommitter GitHub <noreply@github.com> 1683691933 +0200\n\nRollup merge of #110673 - compiler-errors:alias-bounds-2, r=lcnr\n\nMake alias bounds sound in the new solver (take 2)\n\nMake alias bounds sound in the new solver (in a way that does not require coinduction) by only considering them for projection types whose corresponding trait refs come from a param-env candidate.\n\nThat is, given `<T as Trait>::Assoc: Bound`, we only *really* need to consider the alias bound if `T: Trait` is satisfied via a param-env candidate. If it's instead satisfied, e.g., via an user provided impl candidate or a , then that impl should have a concrete type to which we could otherwise normalize `<T as Trait>::Assoc`, and that concrete type is then responsible to prove the `Bound` on it.\n\nSimilar consideration is given to opaque types, since we only need to consider alias bounds if we're *not* in reveal-all mode, since similarly we'd be able to reveal the opaque types and prove any bounds that way.\n\nThis does not remove that hacky \"eager projection replacement\" logic from object bounds, which are somewhat like alias bounds. But removing this eager normalization behavior (added in #108333) would require full coinduction to be enabled. Compare to #110628, which does remove this object-bound custom logic but requires coinduction to be sound.\n\nr? `@lcnr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c14d912cd2618e45923480646e69e397991f9eef", "html_url": "https://github.com/rust-lang/rust/commit/c14d912cd2618e45923480646e69e397991f9eef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c14d912cd2618e45923480646e69e397991f9eef/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65dfca8488d635552eb246eb8e15df646e987cff", "url": "https://api.github.com/repos/rust-lang/rust/commits/65dfca8488d635552eb246eb8e15df646e987cff", "html_url": "https://github.com/rust-lang/rust/commit/65dfca8488d635552eb246eb8e15df646e987cff"}, {"sha": "3a863e534bcba819a4ff8d8362df442001a3dd8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a863e534bcba819a4ff8d8362df442001a3dd8a", "html_url": "https://github.com/rust-lang/rust/commit/3a863e534bcba819a4ff8d8362df442001a3dd8a"}], "stats": {"total": 324, "additions": 231, "deletions": 93}, "files": [{"sha": "25cc82f01d5535822fc09611e7add79ab26c4a08", "filename": "compiler/rustc_trait_selection/src/solve/assembly/mod.rs", "status": "modified", "additions": 154, "deletions": 4, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly%2Fmod.rs?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -8,6 +8,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def_id::DefId;\n use rustc_infer::traits::query::NoSolution;\n use rustc_infer::traits::util::elaborate;\n+use rustc_infer::traits::Reveal;\n use rustc_middle::traits::solve::{CanonicalResponse, Certainty, Goal, MaybeCause, QueryResult};\n use rustc_middle::ty::fast_reject::TreatProjections;\n use rustc_middle::ty::TypeFoldable;\n@@ -87,7 +88,9 @@ pub(super) enum CandidateSource {\n }\n \n /// Methods used to assemble candidates for either trait or projection goals.\n-pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n+pub(super) trait GoalKind<'tcx>:\n+    TypeFoldable<TyCtxt<'tcx>> + Copy + Eq + std::fmt::Display\n+{\n     fn self_ty(self) -> Ty<'tcx>;\n \n     fn trait_ref(self, tcx: TyCtxt<'tcx>) -> ty::TraitRef<'tcx>;\n@@ -96,6 +99,17 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n \n     fn trait_def_id(self, tcx: TyCtxt<'tcx>) -> DefId;\n \n+    // Try equating an assumption predicate against a goal's predicate. If it\n+    // holds, then execute the `then` callback, which should do any additional\n+    // work, then produce a response (typically by executing\n+    // [`EvalCtxt::evaluate_added_goals_and_make_canonical_response`]).\n+    fn probe_and_match_goal_against_assumption(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n+    ) -> QueryResult<'tcx>;\n+\n     // Consider a clause, which consists of a \"assumption\" and some \"requirements\",\n     // to satisfy a goal. If the requirements hold, then attempt to satisfy our\n     // goal by equating it with the assumption.\n@@ -104,7 +118,26 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n         requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.add_goals(requirements);\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n+\n+    /// Consider a bound originating from the item bounds of an alias. For this we\n+    /// require that the well-formed requirements of the self type of the goal\n+    /// are \"satisfied from the param-env\".\n+    /// See [`EvalCtxt::validate_alias_bound_self_from_param_env`].\n+    fn consider_alias_bound_candidate(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+        assumption: ty::Predicate<'tcx>,\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            ecx.validate_alias_bound_self_from_param_env(goal)\n+        })\n+    }\n \n     // Consider a clause specifically for a `dyn Trait` self type. This requires\n     // additionally checking all of the supertraits and object bounds to hold,\n@@ -113,7 +146,25 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<TyCtxt<'tcx>> + Copy + Eq {\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx>;\n+    ) -> QueryResult<'tcx> {\n+        Self::probe_and_match_goal_against_assumption(ecx, goal, assumption, |ecx| {\n+            let tcx = ecx.tcx();\n+            let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n+                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n+                };\n+            ecx.add_goals(\n+                structural_traits::predicates_for_object_candidate(\n+                    &ecx,\n+                    goal.param_env,\n+                    goal.predicate.trait_ref(tcx),\n+                    bounds,\n+                )\n+                .into_iter()\n+                .map(|pred| goal.with(tcx, pred)),\n+            );\n+            ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+        })\n+    }\n \n     fn consider_impl_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n@@ -463,7 +514,7 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n \n         for assumption in self.tcx().item_bounds(alias_ty.def_id).subst(self.tcx(), alias_ty.substs)\n         {\n-            match G::consider_implied_clause(self, goal, assumption, []) {\n+            match G::consider_alias_bound_candidate(self, goal, assumption) {\n                 Ok(result) => {\n                     candidates.push(Candidate { source: CandidateSource::AliasBound, result })\n                 }\n@@ -472,6 +523,105 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n         }\n     }\n \n+    /// Check that we are allowed to use an alias bound originating from the self\n+    /// type of this goal. This means something different depending on the self type's\n+    /// alias kind.\n+    ///\n+    /// * Projection: Given a goal with a self type such as `<Ty as Trait>::Assoc`,\n+    /// we require that the bound `Ty: Trait` can be proven using either a nested alias\n+    /// bound candidate, or a param-env candidate.\n+    ///\n+    /// * Opaque: The param-env must be in `Reveal::UserFacing` mode. Otherwise,\n+    /// the goal should be proven by using the hidden type instead.\n+    #[instrument(level = \"debug\", skip(self), ret)]\n+    pub(super) fn validate_alias_bound_self_from_param_env<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+    ) -> QueryResult<'tcx> {\n+        match *goal.predicate.self_ty().kind() {\n+            ty::Alias(ty::Projection, projection_ty) => {\n+                let mut param_env_candidates = vec![];\n+                let self_trait_ref = projection_ty.trait_ref(self.tcx());\n+\n+                if self_trait_ref.self_ty().is_ty_var() {\n+                    return self\n+                        .evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS);\n+                }\n+\n+                let trait_goal: Goal<'_, ty::TraitPredicate<'tcx>> = goal.with(\n+                    self.tcx(),\n+                    ty::TraitPredicate {\n+                        trait_ref: self_trait_ref,\n+                        constness: ty::BoundConstness::NotConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    },\n+                );\n+\n+                self.assemble_param_env_candidates(trait_goal, &mut param_env_candidates);\n+                // FIXME: We probably need some sort of recursion depth check here.\n+                // Can't come up with an example yet, though, and the worst case\n+                // we can have is a compiler stack overflow...\n+                self.assemble_alias_bound_candidates(trait_goal, &mut param_env_candidates);\n+\n+                // FIXME: We must also consider alias-bound candidates for a peculiar\n+                // class of built-in candidates that I'll call \"defaulted\" built-ins.\n+                //\n+                // For example, we always know that `T: Pointee` is implemented, but\n+                // we do not always know what `<T as Pointee>::Metadata` actually is,\n+                // similar to if we had a user-defined impl with a `default type ...`.\n+                // For these traits, since we're not able to always normalize their\n+                // associated types to a concrete type, we must consider their alias bounds\n+                // instead, so we can prove bounds such as `<T as Pointee>::Metadata: Copy`.\n+                self.assemble_alias_bound_candidates_for_builtin_impl_default_items(\n+                    trait_goal,\n+                    &mut param_env_candidates,\n+                );\n+\n+                self.merge_candidates(param_env_candidates)\n+            }\n+            ty::Alias(ty::Opaque, _opaque_ty) => match goal.param_env.reveal() {\n+                Reveal::UserFacing => {\n+                    self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                }\n+                Reveal::All => return Err(NoSolution),\n+            },\n+            _ => bug!(\"only expected to be called on alias tys\"),\n+        }\n+    }\n+\n+    /// Assemble a subset of builtin impl candidates for a class of candidates called\n+    /// \"defaulted\" built-in traits.\n+    ///\n+    /// For example, we always know that `T: Pointee` is implemented, but we do not\n+    /// always know what `<T as Pointee>::Metadata` actually is! See the comment in\n+    /// [`EvalCtxt::validate_alias_bound_self_from_param_env`] for more detail.\n+    #[instrument(level = \"debug\", skip_all)]\n+    fn assemble_alias_bound_candidates_for_builtin_impl_default_items<G: GoalKind<'tcx>>(\n+        &mut self,\n+        goal: Goal<'tcx, G>,\n+        candidates: &mut Vec<Candidate<'tcx>>,\n+    ) {\n+        let lang_items = self.tcx().lang_items();\n+        let trait_def_id = goal.predicate.trait_def_id(self.tcx());\n+\n+        // You probably shouldn't add anything to this list unless you\n+        // know what you're doing.\n+        let result = if lang_items.pointee_trait() == Some(trait_def_id) {\n+            G::consider_builtin_pointee_candidate(self, goal)\n+        } else if lang_items.discriminant_kind_trait() == Some(trait_def_id) {\n+            G::consider_builtin_discriminant_kind_candidate(self, goal)\n+        } else {\n+            Err(NoSolution)\n+        };\n+\n+        match result {\n+            Ok(result) => {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result })\n+            }\n+            Err(NoSolution) => (),\n+        }\n+    }\n+\n     #[instrument(level = \"debug\", skip_all)]\n     fn assemble_object_bound_candidates<G: GoalKind<'tcx>>(\n         &mut self,"}, {"sha": "20ce2d9416e73eeeb3c30676a74dfc1735d05bcb", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 3, "deletions": 45, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -56,11 +56,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n         self.trait_def_id(tcx)\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n             && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n@@ -75,49 +75,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n                 )?;\n                 ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n                     .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_projection_pred) = assumption.to_opt_poly_projection_pred()\n-            && poly_projection_pred.projection_def_id() == goal.predicate.def_id()\n-        {\n-            ecx.probe(|ecx| {\n-                let tcx = ecx.tcx();\n-\n-                let assumption_projection_pred =\n-                    ecx.instantiate_binder_with_infer(poly_projection_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.projection_ty,\n-                    assumption_projection_pred.projection_ty,\n-                )?;\n-\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.projection_ty.trait_ref(tcx),\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.eq(goal.param_env, goal.predicate.term, assumption_projection_pred.term)\n-                    .expect(\"expected goal term to be fully unconstrained\");\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "dcfa33ae842e9b5f02d14dd9265055cb802bc02b", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 3, "deletions": 44, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -78,11 +78,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         })\n     }\n \n-    fn consider_implied_clause(\n+    fn probe_and_match_goal_against_assumption(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n         assumption: ty::Predicate<'tcx>,\n-        requirements: impl IntoIterator<Item = Goal<'tcx, ty::Predicate<'tcx>>>,\n+        then: impl FnOnce(&mut EvalCtxt<'_, 'tcx>) -> QueryResult<'tcx>,\n     ) -> QueryResult<'tcx> {\n         if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n             && poly_trait_pred.def_id() == goal.predicate.def_id()\n@@ -97,48 +97,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                     goal.predicate.trait_ref,\n                     assumption_trait_pred.trait_ref,\n                 )?;\n-                ecx.add_goals(requirements);\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            })\n-        } else {\n-            Err(NoSolution)\n-        }\n-    }\n-\n-    fn consider_object_bound_candidate(\n-        ecx: &mut EvalCtxt<'_, 'tcx>,\n-        goal: Goal<'tcx, Self>,\n-        assumption: ty::Predicate<'tcx>,\n-    ) -> QueryResult<'tcx> {\n-        if let Some(poly_trait_pred) = assumption.to_opt_poly_trait_pred()\n-            && poly_trait_pred.def_id() == goal.predicate.def_id()\n-            && poly_trait_pred.polarity() == goal.predicate.polarity\n-        {\n-            // FIXME: Constness and polarity\n-            ecx.probe(|ecx| {\n-                let assumption_trait_pred =\n-                    ecx.instantiate_binder_with_infer(poly_trait_pred);\n-                ecx.eq(\n-                    goal.param_env,\n-                    goal.predicate.trait_ref,\n-                    assumption_trait_pred.trait_ref,\n-                )?;\n-\n-                let tcx = ecx.tcx();\n-                let ty::Dynamic(bounds, _, _) = *goal.predicate.self_ty().kind() else {\n-                    bug!(\"expected object type in `consider_object_bound_candidate`\");\n-                };\n-                ecx.add_goals(\n-                    structural_traits::predicates_for_object_candidate(\n-                        &ecx,\n-                        goal.param_env,\n-                        goal.predicate.trait_ref,\n-                        bounds,\n-                    )\n-                    .into_iter()\n-                    .map(|pred| goal.with(tcx, pred)),\n-                );\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                then(ecx)\n             })\n         } else {\n             Err(NoSolution)"}, {"sha": "00294c708f1fa059701f02808d1fad4f3e018378", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.rs?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -0,0 +1,27 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+// Makes sure that alias bounds are not unsound!\n+\n+#![feature(trivial_bounds)]\n+\n+trait Foo {\n+    type Item: Copy\n+    where\n+        <Self as Foo>::Item: Copy;\n+\n+    fn copy_me(x: &Self::Item) -> Self::Item {\n+        *x\n+    }\n+}\n+\n+impl Foo for () {\n+    type Item = String where String: Copy;\n+}\n+\n+fn main() {\n+    let x = String::from(\"hello, world\");\n+    drop(<() as Foo>::copy_me(&x));\n+    //~^ ERROR `<() as Foo>::Item: Copy` is not satisfied\n+    //~| ERROR `<() as Foo>::Item` is not well-formed\n+    println!(\"{x}\");\n+}"}, {"sha": "9a43d2a6639ce86bf4ded8d1ca86277a8fa41b01", "filename": "tests/ui/traits/new-solver/alias-bound-unsound.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-bound-unsound.stderr?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -0,0 +1,24 @@\n+error[E0277]: the trait bound `<() as Foo>::Item: Copy` is not satisfied\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Copy` is not implemented for `<() as Foo>::Item`\n+   |\n+note: required by a bound in `Foo::Item`\n+  --> $DIR/alias-bound-unsound.rs:10:30\n+   |\n+LL |     type Item: Copy\n+   |          ---- required by a bound in this associated type\n+LL |     where\n+LL |         <Self as Foo>::Item: Copy;\n+   |                              ^^^^ required by this bound in `Foo::Item`\n+\n+error: the type `<() as Foo>::Item` is not well-formed\n+  --> $DIR/alias-bound-unsound.rs:23:10\n+   |\n+LL |     drop(<() as Foo>::copy_me(&x));\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "c365902dbe5e833a07f1e5f98f247d1774b708aa", "filename": "tests/ui/traits/new-solver/nested-alias-bound.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c14d912cd2618e45923480646e69e397991f9eef/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fnested-alias-bound.rs?ref=c14d912cd2618e45923480646e69e397991f9eef", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait A {\n+    type A: B;\n+}\n+\n+trait B {\n+    type B: C;\n+}\n+\n+trait C {}\n+\n+fn needs_c<T: C>() {}\n+\n+fn test<T: A>() {\n+    needs_c::<<T::A as B>::B>();\n+}\n+\n+fn main() {}"}]}