{"sha": "630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzMGQ1YTQ4OTU1MmU2NzFiZjlkYzdjMGU3MmM3N2IwYTFhZDM1M2M=", "commit": {"author": {"name": "kenta7777", "email": "k.hasegw7@gmail.com", "date": "2019-03-26T04:06:15Z"}, "committer": {"name": "kenta7777", "email": "k.hasegw7@gmail.com", "date": "2019-03-26T04:06:15Z"}, "message": "renames EvalContext to InterpretCx.", "tree": {"sha": "dde176974e6c03fae59e40e32799a603273a88e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dde176974e6c03fae59e40e32799a603273a88e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "html_url": "https://github.com/rust-lang/rust/commit/630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/comments", "author": {"login": "kenta7777", "id": 16369171, "node_id": "MDQ6VXNlcjE2MzY5MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/16369171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kenta7777", "html_url": "https://github.com/kenta7777", "followers_url": "https://api.github.com/users/kenta7777/followers", "following_url": "https://api.github.com/users/kenta7777/following{/other_user}", "gists_url": "https://api.github.com/users/kenta7777/gists{/gist_id}", "starred_url": "https://api.github.com/users/kenta7777/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kenta7777/subscriptions", "organizations_url": "https://api.github.com/users/kenta7777/orgs", "repos_url": "https://api.github.com/users/kenta7777/repos", "events_url": "https://api.github.com/users/kenta7777/events{/privacy}", "received_events_url": "https://api.github.com/users/kenta7777/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kenta7777", "id": 16369171, "node_id": "MDQ6VXNlcjE2MzY5MTcx", "avatar_url": "https://avatars.githubusercontent.com/u/16369171?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kenta7777", "html_url": "https://github.com/kenta7777", "followers_url": "https://api.github.com/users/kenta7777/followers", "following_url": "https://api.github.com/users/kenta7777/following{/other_user}", "gists_url": "https://api.github.com/users/kenta7777/gists{/gist_id}", "starred_url": "https://api.github.com/users/kenta7777/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kenta7777/subscriptions", "organizations_url": "https://api.github.com/users/kenta7777/orgs", "repos_url": "https://api.github.com/users/kenta7777/repos", "events_url": "https://api.github.com/users/kenta7777/events{/privacy}", "received_events_url": "https://api.github.com/users/kenta7777/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4c27fb19ba15a2e45485e601a79914c6280196b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4c27fb19ba15a2e45485e601a79914c6280196b0", "html_url": "https://github.com/rust-lang/rust/commit/4c27fb19ba15a2e45485e601a79914c6280196b0"}], "stats": {"total": 140, "additions": 70, "deletions": 70}, "files": [{"sha": "211573ab49a1cfa2a3e4ac296cca671f409dc40d", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -22,7 +22,7 @@ use syntax::source_map::{Span, DUMMY_SP};\n use crate::interpret::{self,\n     PlaceTy, MPlaceTy, MemPlace, OpTy, ImmTy, Immediate, Scalar, Pointer,\n     RawConst, ConstValue,\n-    EvalResult, EvalError, EvalErrorKind, GlobalId, EvalContext, StackPopCleanup,\n+    EvalResult, EvalError, EvalErrorKind, GlobalId, InterpretCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n     snapshot, RefTracking,\n };\n@@ -47,7 +47,7 @@ pub(crate) fn mk_eval_cx<'a, 'mir, 'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n ) -> CompileTimeEvalContext<'a, 'mir, 'tcx> {\n     debug!(\"mk_eval_cx: {:?}\", param_env);\n-    EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n+    InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new())\n }\n \n pub(crate) fn eval_promoted<'a, 'mir, 'tcx>(\n@@ -116,7 +116,7 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n     // and try improving it down the road when more information is available\n     let span = tcx.def_span(cid.instance.def_id());\n     let span = mir.map(|mir| mir.span).unwrap_or(span);\n-    let mut ecx = EvalContext::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n+    let mut ecx = InterpretCx::new(tcx.at(span), param_env, CompileTimeInterpreter::new());\n     let r = eval_body_using_ecx(&mut ecx, cid, mir, param_env);\n     (r, ecx)\n }\n@@ -292,7 +292,7 @@ impl<K: Hash + Eq, V> interpret::AllocMap<K, V> for FxHashMap<K, V> {\n }\n \n type CompileTimeEvalContext<'a, 'mir, 'tcx> =\n-    EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n+    InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>;\n \n impl interpret::MayLeak for ! {\n     #[inline(always)]\n@@ -317,12 +317,12 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     const STATIC_KIND: Option<!> = None; // no copying of statics allowed\n \n     #[inline(always)]\n-    fn enforce_validity(_ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool {\n+    fn enforce_validity(_ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool {\n         false // for now, we don't enforce validity\n     }\n \n     fn find_fn(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: Option<PlaceTy<'tcx>>,\n@@ -362,7 +362,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn call_intrinsic(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx>],\n         dest: PlaceTy<'tcx>,\n@@ -378,7 +378,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn ptr_op(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         _bin_op: mir::BinOp,\n         _left: ImmTy<'tcx>,\n         _right: ImmTy<'tcx>,\n@@ -406,15 +406,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n     }\n \n     fn box_alloc(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _dest: PlaceTy<'tcx>,\n     ) -> EvalResult<'tcx> {\n         Err(\n             ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n \n-    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx> {\n         {\n             let steps = &mut ecx.machine.steps_since_detector_enabled;\n \n@@ -440,7 +440,7 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     #[inline(always)]\n     fn tag_new_allocation(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         _kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer {\n@@ -449,15 +449,15 @@ impl<'a, 'mir, 'tcx> interpret::Machine<'a, 'mir, 'tcx>\n \n     #[inline(always)]\n     fn stack_push(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n     ) -> EvalResult<'tcx> {\n         Ok(())\n     }\n \n     /// Called immediately before a stack frame gets popped.\n     #[inline(always)]\n     fn stack_pop(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _extra: (),\n     ) -> EvalResult<'tcx> {\n         Ok(())\n@@ -504,7 +504,7 @@ pub fn const_variant_index<'a, 'tcx>(\n }\n \n pub fn error_to_const_error<'a, 'mir, 'tcx>(\n-    ecx: &EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    ecx: &InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     mut error: EvalError<'tcx>\n ) -> ConstEvalErr<'tcx> {\n     error.print_backtrace();"}, {"sha": "003c2182d0b45c4829bc592cf19a0c7a41ff0e42", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -9,9 +9,9 @@ use rustc::mir::interpret::{\n use rustc::mir::CastKind;\n use rustc_apfloat::Float;\n \n-use super::{EvalContext, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n+use super::{InterpretCx, Machine, PlaceTy, OpTy, ImmTy, Immediate};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n         match ty.sty {\n             ty::RawPtr(ty::TypeAndMut { ty, .. }) |"}, {"sha": "8b7e28c3de077f5b2b054ec087c967aac7b7a148", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -26,7 +26,7 @@ use super::{\n     Memory, Machine\n };\n \n-pub struct EvalContext<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n+pub struct InterpretCx<'a, 'mir, 'tcx: 'a + 'mir, M: Machine<'a, 'mir, 'tcx>> {\n     /// Stores the `Machine` instance.\n     pub machine: M,\n \n@@ -141,15 +141,15 @@ impl<'tcx, Tag> LocalState<'tcx, Tag> {\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> HasDataLayout\n-    for EvalContext<'a, 'mir, 'tcx, M>\n+    for InterpretCx<'a, 'mir, 'tcx, M>\n {\n     #[inline]\n     fn data_layout(&self) -> &layout::TargetDataLayout {\n         &self.tcx.data_layout\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for InterpretCx<'a, 'mir, 'tcx, M>\n     where M: Machine<'a, 'mir, 'tcx>\n {\n     #[inline]\n@@ -159,7 +159,7 @@ impl<'a, 'mir, 'tcx, M> layout::HasTyCtxt<'tcx> for EvalContext<'a, 'mir, 'tcx,\n }\n \n impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n-    for EvalContext<'a, 'mir, 'tcx, M>\n+    for InterpretCx<'a, 'mir, 'tcx, M>\n {\n     type Ty = Ty<'tcx>;\n     type TyLayout = EvalResult<'tcx, TyLayout<'tcx>>;\n@@ -171,13 +171,13 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> LayoutOf\n     }\n }\n \n-impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx: 'mir, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     pub fn new(\n         tcx: TyCtxtAt<'a, 'tcx, 'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n     ) -> Self {\n-        EvalContext {\n+        InterpretCx {\n             machine,\n             tcx,\n             param_env,"}, {"sha": "99dd654df21e317ad6c82f26ee0016870469fe06", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, PlaceTy, OpTy, EvalContext,\n+    Machine, PlaceTy, OpTy, InterpretCx,\n };\n \n \n@@ -36,7 +36,7 @@ fn numeric_intrinsic<'tcx, Tag>(\n     Ok(Scalar::from_uint(bits_out, size))\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Returns `true` if emulation happened.\n     pub fn emulate_intrinsic(\n         &mut self,"}, {"sha": "09d403ab243d60f88fe8eb21167f97b4366bc42b", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, query::TyCtxtAt};\n \n use super::{\n     Allocation, AllocId, EvalResult, Scalar, AllocationExtra,\n-    EvalContext, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n+    InterpretCx, PlaceTy, MPlaceTy, OpTy, ImmTy, Pointer, MemoryKind,\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -95,11 +95,11 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     const STATIC_KIND: Option<Self::MemoryKinds>;\n \n     /// Whether to enforce the validity invariant\n-    fn enforce_validity(ecx: &EvalContext<'a, 'mir, 'tcx, Self>) -> bool;\n+    fn enforce_validity(ecx: &InterpretCx<'a, 'mir, 'tcx, Self>) -> bool;\n \n     /// Called before a basic block terminator is executed.\n     /// You can use this to detect endlessly running programs.\n-    fn before_terminator(ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n+    fn before_terminator(ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>) -> EvalResult<'tcx>;\n \n     /// Entry point to all function calls.\n     ///\n@@ -112,7 +112,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Passing `dest`and `ret` in the same `Option` proved very annoying when only one of them\n     /// was used.\n     fn find_fn(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n@@ -122,7 +122,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Self::PointerTag>],\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n@@ -156,21 +156,21 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     ///\n     /// Returns a (value, overflowed) pair if the operation succeeded\n     fn ptr_op(\n-        ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Self::PointerTag>,\n         right: ImmTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx, (Scalar<Self::PointerTag>, bool)>;\n \n     /// Heap allocations via the `box` keyword.\n     fn box_alloc(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx>;\n \n     /// Adds the tag for a newly allocated pointer.\n     fn tag_new_allocation(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         ptr: Pointer,\n         kind: MemoryKind<Self::MemoryKinds>,\n     ) -> Pointer<Self::PointerTag>;\n@@ -180,7 +180,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// `mutability` can be `None` in case a raw ptr is being dereferenced.\n     #[inline]\n     fn tag_dereference(\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, Self>,\n         place: MPlaceTy<'tcx, Self::PointerTag>,\n         _mutability: Option<hir::Mutability>,\n     ) -> EvalResult<'tcx, Scalar<Self::PointerTag>> {\n@@ -190,7 +190,7 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n     /// Executes a retagging operation\n     #[inline]\n     fn retag(\n-        _ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        _ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         _kind: mir::RetagKind,\n         _place: PlaceTy<'tcx, Self::PointerTag>,\n     ) -> EvalResult<'tcx> {\n@@ -199,12 +199,12 @@ pub trait Machine<'a, 'mir, 'tcx>: Sized {\n \n     /// Called immediately before a new stack frame got pushed\n     fn stack_push(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n     ) -> EvalResult<'tcx, Self::FrameExtra>;\n \n     /// Called immediately after a stack frame gets popped\n     fn stack_pop(\n-        ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n+        ecx: &mut InterpretCx<'a, 'mir, 'tcx, Self>,\n         extra: Self::FrameExtra,\n     ) -> EvalResult<'tcx>;\n }"}, {"sha": "ea358389ddb761f41f213ccd47cba9b8d5bbfb2c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -18,7 +18,7 @@ mod visitor;\n pub use rustc::mir::interpret::*; // have all the `interpret` symbols in one place: here\n \n pub use self::eval_context::{\n-    EvalContext, Frame, StackPopCleanup, LocalState, LocalValue,\n+    InterpretCx, Frame, StackPopCleanup, LocalState, LocalValue,\n };\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};"}, {"sha": "15b6d5c914d20c92f487adfbc51b8ddf4e570a71", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -13,7 +13,7 @@ use rustc::mir::interpret::{\n     sign_extend, truncate,\n };\n use super::{\n-    EvalContext, Machine,\n+    InterpretCx, Machine,\n     MemPlace, MPlaceTy, PlaceTy, Place, MemoryKind,\n };\n pub use rustc::mir::interpret::ScalarMaybeUndef;\n@@ -267,7 +267,7 @@ pub(super) fn from_known_layout<'tcx>(\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Try reading an immediate in memory; this is interesting particularly for ScalarPair.\n     /// Returns `None` if the layout does not permit loading this as a value.\n     fn try_read_immediate_from_mplace("}, {"sha": "ca93007788e0342ef9a8bb54931f90aa99b510a6", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -5,10 +5,10 @@ use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{EvalResult, Scalar};\n \n-use super::{EvalContext, PlaceTy, Immediate, Machine, ImmTy};\n+use super::{InterpretCx, PlaceTy, Immediate, Machine, ImmTy};\n \n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Applies the binary operation `op` to the two operands and writes a tuple of the result\n     /// and a boolean signifying the potential overflow to the destination.\n     pub fn binop_with_overflow(\n@@ -37,7 +37,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     fn binary_char_op(\n         &self,\n         bin_op: mir::BinOp,"}, {"sha": "70c3e9f5a58bc9068eb3f527041a61a40c691305", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -14,7 +14,7 @@ use rustc::ty::TypeFoldable;\n \n use super::{\n     GlobalId, AllocId, Allocation, Scalar, EvalResult, Pointer, PointerArithmetic,\n-    EvalContext, Machine, AllocMap, AllocationExtra,\n+    InterpretCx, Machine, AllocMap, AllocationExtra,\n     RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind\n };\n \n@@ -305,7 +305,7 @@ impl<'tcx, Tag: ::std::fmt::Debug> PlaceTy<'tcx, Tag> {\n }\n \n // separating the pointer tag for `impl Trait`, see https://github.com/rust-lang/rust/issues/54385\n-impl<'a, 'mir, 'tcx, Tag, M> EvalContext<'a, 'mir, 'tcx, M>\n+impl<'a, 'mir, 'tcx, Tag, M> InterpretCx<'a, 'mir, 'tcx, M>\n where\n     // FIXME: Working around https://github.com/rust-lang/rust/issues/54385\n     Tag: ::std::fmt::Debug+Default+Copy+Eq+Hash+'static,\n@@ -606,7 +606,7 @@ where\n                 // global table but not in its local memory: It calls back into tcx through\n                 // a query, triggering the CTFE machinery to actually turn this lazy reference\n                 // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-                // this EvalContext uses another Machine (e.g., in miri).  This is what we\n+                // this InterpretCx uses another Machine (e.g., in miri).  This is what we\n                 // want!  This way, computing statics works concistently between codegen\n                 // and miri: They use the same query to eventually obtain a `ty::Const`\n                 // and use that for further computation."}, {"sha": "29a8547035e4add17aa0967b75b14ef88966103f", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -1,12 +1,12 @@\n-//! This module contains the `EvalContext` methods for executing a single step of the interpreter.\n+//! This module contains the `InterpretCx` methods for executing a single step of the interpreter.\n //!\n //! The main entry point is the `step` method.\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n use rustc::mir::interpret::{EvalResult, Scalar, PointerArithmetic};\n \n-use super::{EvalContext, Machine};\n+use super::{InterpretCx, Machine};\n \n /// Classify whether an operator is \"left-homogeneous\", i.e., the LHS has the\n /// same type as the result.\n@@ -35,7 +35,7 @@ fn binop_right_homogeneous(op: mir::BinOp) -> bool {\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     pub fn run(&mut self) -> EvalResult<'tcx> {\n         while self.step()? {}\n         Ok(())"}, {"sha": "01965f53c157d2bbac7ba046317df528b3c18e3e", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -7,10 +7,10 @@ use rustc_target::spec::abi::Abi;\n \n use rustc::mir::interpret::{EvalResult, PointerArithmetic, EvalErrorKind, Scalar};\n use super::{\n-    EvalContext, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpretCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n };\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     #[inline]\n     pub fn goto_block(&mut self, target: Option<mir::BasicBlock>) -> EvalResult<'tcx> {\n         if let Some(target) = target {"}, {"sha": "cce6c95a31240f780feefccdc6e27f0fd87f3c9e", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -3,9 +3,9 @@ use rustc::ty::{self, Ty};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, EvalResult, PointerArithmetic};\n \n-use super::{EvalContext, Machine, MemoryKind};\n+use super::{InterpretCx, Machine, MemoryKind};\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n     /// objects.\n     ///"}, {"sha": "3323ec387bfd59b38633cc5dbb8ad17f9807b99a", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    OpTy, Machine, EvalContext, ValueVisitor, MPlaceTy,\n+    OpTy, Machine, InterpretCx, ValueVisitor, MPlaceTy,\n };\n \n macro_rules! validation_failure {\n@@ -153,7 +153,7 @@ struct ValidityVisitor<'rt, 'a: 'rt, 'mir: 'rt, 'tcx: 'a+'rt+'mir, M: Machine<'a\n     path: Vec<PathElem>,\n     ref_tracking: Option<&'rt mut RefTracking<MPlaceTy<'tcx, M::PointerTag>>>,\n     const_mode: bool,\n-    ecx: &'rt EvalContext<'a, 'mir, 'tcx, M>,\n+    ecx: &'rt InterpretCx<'a, 'mir, 'tcx, M>,\n }\n \n impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> ValidityVisitor<'rt, 'a, 'mir, 'tcx, M> {\n@@ -224,7 +224,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     type V = OpTy<'tcx, M::PointerTag>;\n \n     #[inline(always)]\n-    fn ecx(&self) -> &EvalContext<'a, 'mir, 'tcx, M> {\n+    fn ecx(&self) -> &InterpretCx<'a, 'mir, 'tcx, M> {\n         &self.ecx\n     }\n \n@@ -587,7 +587,7 @@ impl<'rt, 'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>\n     }\n }\n \n-impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n+impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> InterpretCx<'a, 'mir, 'tcx, M> {\n     /// This function checks the data at `op`. `op` is assumed to cover valid memory if it\n     /// is an indirect operand.\n     /// It will error if the bits at the destination do not match the ones described by the layout."}, {"sha": "90d4fff42183782bc610b1c7bde23a7ee61d287d", "filename": "src/librustc_mir/interpret/visitor.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvisitor.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -8,7 +8,7 @@ use rustc::mir::interpret::{\n };\n \n use super::{\n-    Machine, EvalContext, MPlaceTy, OpTy,\n+    Machine, InterpretCx, MPlaceTy, OpTy,\n };\n \n // A thing that we can project into, and that has a layout.\n@@ -22,7 +22,7 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Makes this into an `OpTy`.\n     fn to_op(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>>;\n \n     /// Creates this from an `MPlaceTy`.\n@@ -31,14 +31,14 @@ pub trait Value<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>>: Copy\n     /// Projects to the given enum variant.\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self>;\n \n     /// Projects to the n-th field.\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self>;\n }\n@@ -56,7 +56,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self)\n     }\n@@ -69,7 +69,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_downcast(self, variant)\n@@ -78,7 +78,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.operand_field(self, field)\n@@ -95,7 +95,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn to_op(\n         self,\n-        _ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        _ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         Ok(self.into())\n     }\n@@ -108,7 +108,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_downcast(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         variant: VariantIdx,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.mplace_downcast(self, variant)\n@@ -117,7 +117,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> Value<'a, 'mir, 'tcx, M>\n     #[inline(always)]\n     fn project_field(\n         self,\n-        ecx: &EvalContext<'a, 'mir, 'tcx, M>,\n+        ecx: &InterpretCx<'a, 'mir, 'tcx, M>,\n         field: u64,\n     ) -> EvalResult<'tcx, Self> {\n         ecx.mplace_field(self, field)\n@@ -130,9 +130,9 @@ macro_rules! make_value_visitor {\n         pub trait $visitor_trait_name<'a, 'mir, 'tcx: 'mir+'a, M: Machine<'a, 'mir, 'tcx>>: Sized {\n             type V: Value<'a, 'mir, 'tcx, M>;\n \n-            /// The visitor must have an `EvalContext` in it.\n+            /// The visitor must have an `InterpretCx` in it.\n             fn ecx(&$($mutability)? self)\n-                -> &$($mutability)? EvalContext<'a, 'mir, 'tcx, M>;\n+                -> &$($mutability)? InterpretCx<'a, 'mir, 'tcx, M>;\n \n             // Recursive actions, ready to be overloaded.\n             /// Visits the given value, dispatching as appropriate to more specialized visitors."}, {"sha": "dd84aa5d5530a4f335b6c0aa567a751c43b52a29", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/630d5a489552e671bf9dc7c0e72c77b0a1ad353c/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=630d5a489552e671bf9dc7c0e72c77b0a1ad353c", "patch": "@@ -18,7 +18,7 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n-use crate::interpret::{EvalContext, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n+use crate::interpret::{InterpretCx, ScalarMaybeUndef, Immediate, OpTy, ImmTy, MemoryKind};\n use crate::const_eval::{\n     CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_eval_cx,\n };\n@@ -70,7 +70,7 @@ type Const<'tcx> = (OpTy<'tcx>, Span);\n \n /// Finds optimization opportunities on the MIR.\n struct ConstPropagator<'a, 'mir, 'tcx:'a+'mir> {\n-    ecx: EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    ecx: InterpretCx<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n     mir: &'mir Mir<'tcx>,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     source: MirSource<'tcx>,"}]}