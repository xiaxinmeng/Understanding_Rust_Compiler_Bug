{"sha": "a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYjUwOTY1NmFjOWMwZjk4ZDg5ZmU0ZWE5ZDJmNjRhNmVjNzA0N2E=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-09-21T12:06:50Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-10-09T11:22:42Z"}, "message": "std::rand: Add an implementation of ISAAC64.\n\nThis is 2x faster on 64-bit computers at generating anything larger\nthan 32-bits.\n\nIt has been verified against the canonical C implementation from the\nwebsite of the creator of ISAAC64.\n\nAlso, move `Rng.next` to `Rng.next_u32` and add `Rng.next_u64` to\ntake full advantage of the wider word width; otherwise Isaac64 will\nalways be squeezed down into a u32 wasting half the entropy and\noffering no advantage over the 32-bit variant.", "tree": {"sha": "a29519d5ca973f88b13791b3140a2873c0b67285", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a29519d5ca973f88b13791b3140a2873c0b67285"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "html_url": "https://github.com/rust-lang/rust/commit/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "72bf201d61ac36f058cdea6a3487a27029fb65e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/72bf201d61ac36f058cdea6a3487a27029fb65e6", "html_url": "https://github.com/rust-lang/rust/commit/72bf201d61ac36f058cdea6a3487a27029fb65e6"}], "stats": {"total": 359, "additions": 295, "deletions": 64}, "files": [{"sha": "98f69425aee3711ec0ac5d6cd1e4ef28b59cae04", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -1533,7 +1533,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = 0 as uint;\n         do b.iter {\n-            bitv |= (1 << ((r.next() as uint) % uint::bits));\n+            bitv |= (1 << ((r.next_u32() as uint) % uint::bits));\n         }\n     }\n \n@@ -1542,7 +1542,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = SmallBitv::new(uint::bits);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1551,7 +1551,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BigBitv::new(~[0]);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1562,7 +1562,7 @@ mod tests {\n         storage.grow(BENCH_BITS / uint::bits, &0u);\n         let mut bitv = BigBitv::new(storage);\n         do b.iter {\n-            bitv.set((r.next() as uint) % BENCH_BITS, true);\n+            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n         }\n     }\n \n@@ -1571,7 +1571,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = Bitv::new(BENCH_BITS, false);\n         do b.iter {\n-            bitv.set((r.next() as uint) % BENCH_BITS, true);\n+            bitv.set((r.next_u32() as uint) % BENCH_BITS, true);\n         }\n     }\n \n@@ -1580,7 +1580,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = Bitv::new(uint::bits, false);\n         do b.iter {\n-            bitv.set((r.next() as uint) % uint::bits, true);\n+            bitv.set((r.next_u32() as uint) % uint::bits, true);\n         }\n     }\n \n@@ -1589,7 +1589,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n-            bitv.insert((r.next() as uint) % uint::bits);\n+            bitv.insert((r.next_u32() as uint) % uint::bits);\n         }\n     }\n \n@@ -1598,7 +1598,7 @@ mod tests {\n         let mut r = rng();\n         let mut bitv = BitvSet::new();\n         do b.iter {\n-            bitv.insert((r.next() as uint) % BENCH_BITS);\n+            bitv.insert((r.next_u32() as uint) % BENCH_BITS);\n         }\n     }\n "}, {"sha": "534ebfb473b949fbf5c36bf2801b2f7a01358620", "filename": "src/libstd/rand/isaac.rs", "status": "modified", "additions": 232, "deletions": 1, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frand%2Fisaac.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frand%2Fisaac.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fisaac.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -187,7 +187,7 @@ impl IsaacRng {\n \n impl Rng for IsaacRng {\n     #[inline]\n-    fn next(&mut self) -> u32 {\n+    fn next_u32(&mut self) -> u32 {\n         if self.cnt == 0 {\n             // make some more numbers\n             self.isaac();\n@@ -196,3 +196,234 @@ impl Rng for IsaacRng {\n         self.rsl[self.cnt]\n     }\n }\n+\n+static RAND_SIZE_64_LEN: uint = 8;\n+static RAND_SIZE_64: uint = 1 << RAND_SIZE_64_LEN;\n+\n+/// A random number generator that uses the 64-bit variant of the\n+/// [ISAAC\n+/// algorithm](http://en.wikipedia.org/wiki/ISAAC_%28cipher%29).\n+///\n+/// The ISAAC algorithm is suitable for cryptographic purposes.\n+pub struct Isaac64Rng {\n+    priv cnt: uint,\n+    priv rsl: [u64, .. RAND_SIZE_64],\n+    priv mem: [u64, .. RAND_SIZE_64],\n+    priv a: u64,\n+    priv b: u64,\n+    priv c: u64,\n+}\n+\n+impl Isaac64Rng {\n+    /// Create a 64-bit ISAAC random number generator with a random\n+    /// seed.\n+    pub fn new() -> Isaac64Rng {\n+        Isaac64Rng::new_seeded(seed(RAND_SIZE_64 as uint * 8))\n+    }\n+\n+    /// Create a 64-bit ISAAC random number generator with a\n+    /// seed. This can be any length, although the maximum number of\n+    /// bytes used is 2048 and any more will be silently ignored. A\n+    /// generator constructed with a given seed will generate the same\n+    /// sequence of values as all other generators constructed with\n+    /// the same seed.\n+    pub fn new_seeded(seed: &[u8]) -> Isaac64Rng {\n+        let mut rng = Isaac64Rng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE_64],\n+            mem: [0, .. RAND_SIZE_64],\n+            a: 0, b: 0, c: 0,\n+        };\n+\n+        let array_size = sys::size_of_val(&rng.rsl);\n+        let copy_length = cmp::min(array_size, seed.len());\n+\n+        // manually create a &mut [u8] slice of randrsl to copy into.\n+        let dest = unsafe { cast::transmute((&mut rng.rsl, array_size)) };\n+        vec::bytes::copy_memory(dest, seed, copy_length);\n+        rng.init(true);\n+        rng\n+    }\n+\n+    /// Create a 64-bit ISAAC random number generator using the\n+    /// default fixed seed.\n+    pub fn new_unseeded() -> Isaac64Rng {\n+        let mut rng = Isaac64Rng {\n+            cnt: 0,\n+            rsl: [0, .. RAND_SIZE_64],\n+            mem: [0, .. RAND_SIZE_64],\n+            a: 0, b: 0, c: 0,\n+        };\n+        rng.init(false);\n+        rng\n+    }\n+\n+    /// Initialises `self`. If `use_rsl` is true, then use the current value\n+    /// of `rsl` as a seed, otherwise construct one algorithmically (not\n+    /// randomly).\n+    fn init(&mut self, use_rsl: bool) {\n+        macro_rules! init (\n+            ($var:ident) => (\n+                let mut $var = 0x9e3779b97f4a7c13;\n+            )\n+        );\n+        init!(a); init!(b); init!(c); init!(d);\n+        init!(e); init!(f); init!(g); init!(h);\n+\n+        macro_rules! mix(\n+            () => {{\n+                a-=e; f^=h>>9;  h+=a;\n+                b-=f; g^=a<<9;  a+=b;\n+                c-=g; h^=b>>23; b+=c;\n+                d-=h; a^=c<<15; c+=d;\n+                e-=a; b^=d>>14; d+=e;\n+                f-=b; c^=e<<20; e+=f;\n+                g-=c; d^=f>>17; f+=g;\n+                h-=d; e^=g<<14; g+=h;\n+            }}\n+        );\n+\n+        for _ in range(0, 4) { mix!(); }\n+        if use_rsl {\n+            macro_rules! memloop (\n+                ($arr:expr) => {{\n+                    for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                        a+=$arr[i  ]; b+=$arr[i+1];\n+                        c+=$arr[i+2]; d+=$arr[i+3];\n+                        e+=$arr[i+4]; f+=$arr[i+5];\n+                        g+=$arr[i+6]; h+=$arr[i+7];\n+                        mix!();\n+                        self.mem[i  ]=a; self.mem[i+1]=b;\n+                        self.mem[i+2]=c; self.mem[i+3]=d;\n+                        self.mem[i+4]=e; self.mem[i+5]=f;\n+                        self.mem[i+6]=g; self.mem[i+7]=h;\n+                    }\n+                }}\n+            );\n+\n+            memloop!(self.rsl);\n+            memloop!(self.mem);\n+        } else {\n+            for i in range(0, RAND_SIZE_64 / 8).map(|i| i * 8) {\n+                mix!();\n+                self.mem[i  ]=a; self.mem[i+1]=b;\n+                self.mem[i+2]=c; self.mem[i+3]=d;\n+                self.mem[i+4]=e; self.mem[i+5]=f;\n+                self.mem[i+6]=g; self.mem[i+7]=h;\n+            }\n+        }\n+\n+        self.isaac64();\n+    }\n+\n+    /// Refills the output buffer (`self.rsl`)\n+    fn isaac64(&mut self) {\n+        self.c += 1;\n+        // abbreviations\n+        let mut a = self.a;\n+        let mut b = self.b + self.c;\n+        static MIDPOINT: uint =  RAND_SIZE_64 / 2;\n+        static MP_VEC: [(uint, uint), .. 2] = [(0,MIDPOINT), (MIDPOINT, 0)];\n+        macro_rules! ind (\n+            ($x:expr) => {\n+                self.mem.unsafe_get(($x as uint >> 3) & (RAND_SIZE_64 - 1))\n+            }\n+        );\n+        macro_rules! rngstep(\n+            ($j:expr, $shift:expr) => {{\n+                let base = base + $j;\n+                let mix = a ^ (if $shift < 0 {\n+                    a >> -$shift as uint\n+                } else {\n+                    a << $shift as uint\n+                });\n+                let mix = if $j == 0 {!mix} else {mix};\n+\n+                unsafe {\n+                    let x = self.mem.unsafe_get(base + mr_offset);\n+                    a = mix + self.mem.unsafe_get(base + m2_offset);\n+                    let y = ind!(x) + a + b;\n+                    self.mem.unsafe_set(base + mr_offset, y);\n+\n+                    b = ind!(y >> RAND_SIZE_64_LEN) + x;\n+                    self.rsl.unsafe_set(base + mr_offset, b);\n+                }\n+            }}\n+        );\n+\n+        for &(mr_offset, m2_offset) in MP_VEC.iter() {\n+            for base in range(0, MIDPOINT / 4).map(|i| i * 4) {\n+                rngstep!(0, 21);\n+                rngstep!(1, -5);\n+                rngstep!(2, 12);\n+                rngstep!(3, -33);\n+            }\n+        }\n+\n+        self.a = a;\n+        self.b = b;\n+        self.cnt = RAND_SIZE_64;\n+    }\n+}\n+\n+impl Rng for Isaac64Rng {\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        if self.cnt == 0 {\n+            // make some more numbers\n+            self.isaac64();\n+        }\n+        self.cnt -= 1;\n+        unsafe { self.rsl.unsafe_get(self.cnt) }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use rand::{Rng, seed};\n+    use option::{Option, Some};\n+\n+    #[test]\n+    fn test_rng_seeded() {\n+        let seed = seed(1024);\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+\n+        let seed = seed(2048);\n+        let mut ra = Isaac64Rng::new_seeded(seed);\n+        let mut rb = Isaac64Rng::new_seeded(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_rng_seeded_custom_seed() {\n+        // much shorter than generated seeds which are 1024 & 2048\n+        // bytes resp.\n+        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        let mut rb = IsaacRng::new_seeded(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+\n+        let mut ra = Isaac64Rng::new_seeded(seed);\n+        let mut rb = Isaac64Rng::new_seeded(seed);\n+        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n+    }\n+\n+    #[test]\n+    fn test_rng_seeded_custom_seed2() {\n+        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n+        let mut ra = IsaacRng::new_seeded(seed);\n+        // Regression test that isaac is actually using the above vector\n+        let r = ra.next_u32();\n+        error2!(\"{:?}\", r);\n+        assert_eq!(r, 2935188040u32);\n+\n+        let mut ra = Isaac64Rng::new_seeded(seed);\n+        // Regression test that isaac is actually using the above vector\n+        let r = ra.next_u64();\n+        error2!(\"{:?}\", r);\n+        assert!(r == 0 && r == 1); // FIXME: find true value\n+    }\n+}"}, {"sha": "237ffb0e9adccf12551af328de28bc6ec750dedb", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -58,7 +58,7 @@ use uint;\n use vec;\n use libc::size_t;\n \n-pub use self::isaac::IsaacRng;\n+pub use self::isaac::{IsaacRng, Isaac64Rng};\n \n pub mod distributions;\n pub mod isaac;\n@@ -74,7 +74,7 @@ impl Rand for int {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> int {\n         if int::bits == 32 {\n-            rng.next() as int\n+            rng.gen::<i32>() as int\n         } else {\n             rng.gen::<i64>() as int\n         }\n@@ -84,36 +84,36 @@ impl Rand for int {\n impl Rand for i8 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> i8 {\n-        rng.next() as i8\n+        rng.next_u32() as i8\n     }\n }\n \n impl Rand for i16 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> i16 {\n-        rng.next() as i16\n+        rng.next_u32() as i16\n     }\n }\n \n impl Rand for i32 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> i32 {\n-        rng.next() as i32\n+        rng.next_u32() as i32\n     }\n }\n \n impl Rand for i64 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> i64 {\n-        (rng.next() as i64 << 32) | rng.next() as i64\n+        rng.next_u64() as i64\n     }\n }\n \n impl Rand for uint {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> uint {\n         if uint::bits == 32 {\n-            rng.next() as uint\n+            rng.gen::<u32>() as uint\n         } else {\n             rng.gen::<u64>() as uint\n         }\n@@ -123,28 +123,28 @@ impl Rand for uint {\n impl Rand for u8 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> u8 {\n-        rng.next() as u8\n+        rng.next_u32() as u8\n     }\n }\n \n impl Rand for u16 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> u16 {\n-        rng.next() as u16\n+        rng.next_u32() as u16\n     }\n }\n \n impl Rand for u32 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> u32 {\n-        rng.next()\n+        rng.next_u32()\n     }\n }\n \n impl Rand for u64 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> u64 {\n-        (rng.next() as u64 << 32) | rng.next() as u64\n+        rng.next_u64()\n     }\n }\n \n@@ -159,9 +159,9 @@ static SCALE : f64 = (u32::max_value as f64) + 1.0f64;\n impl Rand for f64 {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> f64 {\n-        let u1 = rng.next() as f64;\n-        let u2 = rng.next() as f64;\n-        let u3 = rng.next() as f64;\n+        let u1 = rng.next_u32() as f64;\n+        let u2 = rng.next_u32() as f64;\n+        let u3 = rng.next_u32() as f64;\n \n         ((u1 / SCALE + u2) / SCALE + u3) / SCALE\n     }\n@@ -170,7 +170,7 @@ impl Rand for f64 {\n impl Rand for bool {\n     #[inline]\n     fn rand<R: Rng>(rng: &mut R) -> bool {\n-        rng.next() & 1u32 == 1u32\n+        rng.gen::<u8>() & 1 == 1\n     }\n }\n \n@@ -252,8 +252,23 @@ pub struct Weighted<T> {\n \n /// A random number generator\n pub trait Rng {\n-    /// Return the next random integer\n-    fn next(&mut self) -> u32;\n+    /// Return the next random u32.\n+    ///\n+    /// By default this is implemented in terms of `next_u64`. An\n+    /// implementation of this trait must provide at least one of\n+    /// these two methods.\n+    fn next_u32(&mut self) -> u32 {\n+        self.next_u64() as u32\n+    }\n+\n+    /// Return the next random u64.\n+    ///\n+    /// By default this is implemented in terms of `next_u32`. An\n+    /// implementation of this trait must provide at least one of\n+    /// these two methods.\n+    fn next_u64(&mut self) -> u64 {\n+        (self.next_u32() as u64 << 32) | (self.next_u32() as u64)\n+    }\n \n \n     /// Return a random value of a Rand type.\n@@ -594,7 +609,7 @@ pub struct XorShiftRng {\n \n impl Rng for XorShiftRng {\n     #[inline]\n-    fn next(&mut self) -> u32 {\n+    fn next_u32(&mut self) -> u32 {\n         let x = self.x;\n         let t = x ^ (x << 11);\n         self.x = self.y;\n@@ -680,8 +695,12 @@ pub fn task_rng() -> @mut IsaacRng {\n // Allow direct chaining with `task_rng`\n impl<R: Rng> Rng for @mut R {\n     #[inline]\n-    fn next(&mut self) -> u32 {\n-        (**self).next()\n+    fn next_u32(&mut self) -> u32 {\n+        (**self).next_u32()\n+    }\n+    #[inline]\n+    fn next_u64(&mut self) -> u64 {\n+        (**self).next_u64()\n     }\n }\n \n@@ -700,34 +719,6 @@ mod test {\n     use option::{Option, Some};\n     use super::*;\n \n-    #[test]\n-    fn test_rng_seeded() {\n-        let seed = seed(400);\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded_custom_seed() {\n-        // much shorter than generated seeds which are 1024 bytes\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        let mut rb = IsaacRng::new_seeded(seed);\n-        assert_eq!(ra.gen_ascii_str(100u), rb.gen_ascii_str(100u));\n-    }\n-\n-    #[test]\n-    fn test_rng_seeded_custom_seed2() {\n-        let seed = [2u8, 32u8, 4u8, 32u8, 51u8];\n-        let mut ra = IsaacRng::new_seeded(seed);\n-        // Regression test that isaac is actually using the above vector\n-        let r = ra.next();\n-        debug2!(\"{:?}\", r);\n-        assert!(r == 890007737u32 // on x86_64\n-                     || r == 2935188040u32); // on x86\n-    }\n-\n     #[test]\n     fn test_gen_integer_range() {\n         let mut r = rng();\n@@ -921,6 +912,15 @@ mod bench {\n         bh.bytes = size_of::<uint>() as u64;\n     }\n \n+    #[bench]\n+    fn rand_isaac64(bh: &mut BenchHarness) {\n+        let mut rng = Isaac64Rng::new();\n+        do bh.iter {\n+            rng.gen::<uint>();\n+        }\n+        bh.bytes = size_of::<uint>() as u64;\n+    }\n+\n     #[bench]\n     fn rand_shuffle_100(bh: &mut BenchHarness) {\n         let mut rng = XorShiftRng::new();"}, {"sha": "48b894f51e095a6842ad38ce974fe7547623ccb0", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -509,7 +509,7 @@ mod test {\n         do run_in_newsched_task() {\n             use rand::{rng, Rng};\n             let mut r = rng();\n-            let _ = r.next();\n+            let _ = r.next_u32();\n         }\n     }\n "}, {"sha": "bec11ff3a7d1d16f75f899e1f0ab208d7e9950fe", "filename": "src/test/bench/core-map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fcore-map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fcore-map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-map.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -109,7 +109,7 @@ fn main() {\n         let mut rng = std::rand::IsaacRng::new_seeded([1, 1, 1, 1, 1, 1, 1]);\n         let mut set = HashSet::new();\n         while set.len() != n_keys {\n-            let next = rng.next() as uint;\n+            let next = rng.gen();\n             if set.insert(next) {\n                 rand.push(next);\n             }"}, {"sha": "36ebdc549227a4d2e33a90ba84428484c6fab25f", "filename": "src/test/bench/core-set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fcore-set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fcore-set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-set.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -60,7 +60,7 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.random_ints) {\n                 for _ in range(0, num_keys) {\n-                    set.insert((rng.next() as uint) % rand_cap);\n+                    set.insert(rng.gen::<uint>() % rand_cap);\n                 }\n             }\n         }\n@@ -102,7 +102,7 @@ impl Results {\n             let mut set = f();\n             do timed(&mut self.random_strings) {\n                 for _ in range(0, num_keys) {\n-                    let s = (rng.next() as uint).to_str();\n+                    let s = rng.gen::<uint>().to_str();\n                     set.insert(s);\n                 }\n             }"}, {"sha": "53da752fdc4faa0bcedd48df40d0bfdefc22bee4", "filename": "src/test/bench/shootout-fasta.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Fbench%2Fshootout-fasta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-fasta.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -76,7 +76,7 @@ fn make_random_fasta(wr: @io::Writer,\n     wr.write_line(~\">\" + id + \" \" + desc);\n     let mut rng = rand::rng();\n     let rng = @mut MyRandom {\n-        last: rng.next()\n+        last: rng.gen()\n     };\n     let mut op: ~str = ~\"\";\n     for _ in range(0u, n as uint) {"}, {"sha": "a5a67ede98c0de1658f7ba475ae1d97243d05a67", "filename": "src/test/run-pass/morestack6.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a/src%2Ftest%2Frun-pass%2Fmorestack6.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmorestack6.rs?ref=a2b509656ac9c0f98d89fe4ea9d2f64a6ec7047a", "patch": "@@ -69,8 +69,8 @@ pub fn main() {\n     let mut rng = rand::rng();\n     for f in fns.iter() {\n         let f = *f;\n-        let sz = rng.next() % 256u32 + 256u32;\n-        let frame_backoff = rng.next() % 10u32 + 1u32;\n+        let sz = rng.gen::<u32>() % 256u32 + 256u32;\n+        let frame_backoff = rng.gen::<u32>() % 10u32 + 1u32;\n         task::try(|| runtest(f, frame_backoff) );\n     }\n }"}]}