{"sha": "efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmZDBlYTViMjBhNzJhMDk2N2Y4MGVhM2E2M2Y2ZGM0ZDE0MzRjZTA=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-18T13:03:16Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-04-19T13:08:45Z"}, "message": "Parse data-layout specifications.", "tree": {"sha": "18d1dadcfde43f39a2b108b0416d93d99a8a1077", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18d1dadcfde43f39a2b108b0416d93d99a8a1077"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "html_url": "https://github.com/rust-lang/rust/commit/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0776399eac62f8cf5cb02761014e8ed6c51204aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/0776399eac62f8cf5cb02761014e8ed6c51204aa", "html_url": "https://github.com/rust-lang/rust/commit/0776399eac62f8cf5cb02761014e8ed6c51204aa"}], "stats": {"total": 255, "additions": 255, "deletions": 0}, "files": [{"sha": "a6d05cf0b24a9a451d4f07f630f91aa8abc57812", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "patch": "@@ -31,6 +31,7 @@ use hir::FreevarMap;\n use ty::{BareFnTy, InferTy, ParamTy, ProjectionTy, TraitTy};\n use ty::{TyVar, TyVid, IntVar, IntVid, FloatVar, FloatVid};\n use ty::TypeVariants::*;\n+use ty::layout::TargetDataLayout;\n use ty::maps;\n use util::common::MemoizationMap;\n use util::nodemap::{NodeMap, NodeSet, DefIdMap, DefIdSet};\n@@ -419,6 +420,9 @@ pub struct TyCtxt<'tcx> {\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: token::InternedString,\n+\n+    /// Data layout specification for the current target.\n+    pub data_layout: TargetDataLayout,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -531,6 +535,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                                  f: F) -> R\n                                  where F: FnOnce(&TyCtxt<'tcx>) -> R\n     {\n+        let data_layout = TargetDataLayout::parse(s);\n         let interner = RefCell::new(FnvHashMap());\n         let common_types = CommonTypes::new(&arenas.type_, &interner);\n         let dep_graph = map.dep_graph.clone();\n@@ -589,6 +594,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             cast_kinds: RefCell::new(NodeMap()),\n             fragment_infos: RefCell::new(DefIdMap()),\n             crate_name: token::intern_and_get_ident(crate_name),\n+            data_layout: data_layout,\n        }, f)\n     }\n }"}, {"sha": "8c1078fbbe2396abcb1086a04252d3c642dfb682", "filename": "src/librustc/ty/layout.rs", "status": "added", "additions": 248, "deletions": 0, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "patch": "@@ -0,0 +1,248 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use session::Session;\n+\n+use std::cmp;\n+\n+/// Parsed [Data layout](http://llvm.org/docs/LangRef.html#data-layout)\n+/// for a target, which contains everything needed to compute layouts.\n+pub struct TargetDataLayout {\n+    pub endian: Endian,\n+    pub i1_align: Align,\n+    pub i8_align: Align,\n+    pub i16_align: Align,\n+    pub i32_align: Align,\n+    pub i64_align: Align,\n+    pub f32_align: Align,\n+    pub f64_align: Align,\n+    pub pointer_size: Size,\n+    pub pointer_align: Align,\n+    pub aggregate_align: Align,\n+\n+    /// Alignments for vector types, sorted by size.\n+    pub vector_align: Vec<(Size, Align)>\n+}\n+\n+impl Default for TargetDataLayout {\n+    fn default() -> TargetDataLayout {\n+        TargetDataLayout {\n+            endian: Endian::Big,\n+            i1_align: Align::from_bits(8, 8).unwrap(),\n+            i8_align: Align::from_bits(8, 8).unwrap(),\n+            i16_align: Align::from_bits(16, 16).unwrap(),\n+            i32_align: Align::from_bits(32, 32).unwrap(),\n+            i64_align: Align::from_bits(32, 64).unwrap(),\n+            f32_align: Align::from_bits(32, 32).unwrap(),\n+            f64_align: Align::from_bits(64, 64).unwrap(),\n+            pointer_size: Size::from_bits(64),\n+            pointer_align: Align::from_bits(64, 64).unwrap(),\n+            aggregate_align: Align::from_bits(0, 64).unwrap(),\n+            vector_align: vec![(Size::from_bits(128),\n+                                Align::from_bits(128, 128).unwrap())]\n+        }\n+    }\n+}\n+\n+impl TargetDataLayout {\n+    pub fn parse(sess: &Session) -> TargetDataLayout {\n+        // Parse a bit count from a string.\n+        let parse_bits = |s: &str, kind: &str, cause: &str| {\n+            s.parse::<u64>().unwrap_or_else(|err| {\n+                sess.err(&format!(\"invalid {} `{}` for `{}` in \\\"data-layout\\\": {}\",\n+                                  kind, s, cause, err));\n+                0\n+            })\n+        };\n+\n+        // Parse a size string.\n+        let size = |s: &str, cause: &str| {\n+            Size::from_bits(parse_bits(s, \"size\", cause))\n+        };\n+\n+        // Parse an alignment string.\n+        let align = |s: &[&str], cause: &str| {\n+            if s.is_empty() {\n+                sess.err(&format!(\"missing alignment for `{}` in \\\"data-layout\\\"\", cause));\n+            }\n+            let abi = parse_bits(s[0], \"alignment\", cause);\n+            let pref = s.get(1).map_or(abi, |pref| parse_bits(pref, \"alignment\", cause));\n+            Align::from_bits(abi, pref).unwrap_or_else(|err| {\n+                sess.err(&format!(\"invalid alignment for `{}` in \\\"data-layout\\\": {}\",\n+                                  cause, err));\n+                Align::from_bits(8, 8).unwrap()\n+            })\n+        };\n+\n+        let mut dl = TargetDataLayout::default();\n+        for spec in sess.target.target.data_layout.split(\"-\") {\n+            match &spec.split(\":\").collect::<Vec<_>>()[..] {\n+                [\"e\"] => dl.endian = Endian::Little,\n+                [\"E\"] => dl.endian = Endian::Big,\n+                [\"a\", a..] => dl.aggregate_align = align(a, \"a\"),\n+                [\"f32\", a..] => dl.f32_align = align(a, \"f32\"),\n+                [\"f64\", a..] => dl.f64_align = align(a, \"f64\"),\n+                [p @ \"p\", s, a..] | [p @ \"p0\", s, a..] => {\n+                    dl.pointer_size = size(s, p);\n+                    dl.pointer_align = align(a, p);\n+                }\n+                [s, a..] if s.starts_with(\"i\") => {\n+                    let ty_align = match s[1..].parse::<u64>() {\n+                        Ok(1) => &mut dl.i8_align,\n+                        Ok(8) => &mut dl.i8_align,\n+                        Ok(16) => &mut dl.i16_align,\n+                        Ok(32) => &mut dl.i32_align,\n+                        Ok(64) => &mut dl.i64_align,\n+                        Ok(_) => continue,\n+                        Err(_) => {\n+                            size(&s[1..], \"i\"); // For the user error.\n+                            continue;\n+                        }\n+                    };\n+                    *ty_align = align(a, s);\n+                }\n+                [s, a..] if s.starts_with(\"v\") => {\n+                    let v_size = size(&s[1..], \"v\");\n+                    let a = align(a, s);\n+                    if let Some(v) = dl.vector_align.iter_mut().find(|v| v.0 == v_size) {\n+                        v.1 = a;\n+                        continue;\n+                    }\n+                    // No existing entry, add a new one.\n+                    dl.vector_align.push((v_size, a));\n+                }\n+                _ => {} // Ignore everything else.\n+            }\n+        }\n+\n+        // Sort vector alignments by size.\n+        dl.vector_align.sort_by_key(|&(s, _)| s);\n+\n+        // Perform consistency checks against the Target information.\n+        let endian_str = match dl.endian {\n+            Endian::Little => \"little\",\n+            Endian::Big => \"big\"\n+        };\n+        if endian_str != sess.target.target.target_endian {\n+            sess.err(&format!(\"inconsistent target specification: \\\"data-layout\\\" claims \\\n+                               architecture is {}-endian, while \\\"target-endian\\\" is `{}`\",\n+                              endian_str, sess.target.target.target_endian));\n+        }\n+\n+        if dl.pointer_size.bits().to_string() != sess.target.target.target_pointer_width {\n+            sess.err(&format!(\"inconsistent target specification: \\\"data-layout\\\" claims \\\n+                               pointers are {}-bit, while \\\"target-pointer-width\\\" is `{}`\",\n+                              dl.pointer_size.bits(), sess.target.target.target_pointer_width));\n+        }\n+\n+        dl\n+    }\n+}\n+\n+/// Endianness of the target, which must match cfg(target-endian).\n+#[derive(Copy, Clone)]\n+pub enum Endian {\n+    Little,\n+    Big\n+}\n+\n+/// Size of a type in bytes.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]\n+pub struct Size {\n+    raw: u64\n+}\n+\n+impl Size {\n+    pub fn from_bits(bits: u64) -> Size {\n+        Size::from_bytes((bits + 7) / 8)\n+    }\n+\n+    pub fn from_bytes(bytes: u64) -> Size {\n+        if bytes >= (1 << 61) {\n+            bug!(\"Size::from_bytes: {} bytes in bits doesn't fit in u64\", bytes)\n+        }\n+        Size {\n+            raw: bytes\n+        }\n+    }\n+\n+    pub fn bytes(self) -> u64 {\n+        self.raw\n+    }\n+\n+    pub fn bits(self) -> u64 {\n+        self.bytes() * 8\n+    }\n+}\n+\n+/// Alignment of a type in bytes, both ABI-mandated and preferred.\n+/// Since alignments are always powers of 2, we can pack both in one byte,\n+/// giving each a nibble (4 bits) for a maximum alignment of 2^15 = 32768.\n+#[derive(Copy, Clone)]\n+pub struct Align {\n+    raw: u8\n+}\n+\n+impl Align {\n+    pub fn from_bits(abi: u64, pref: u64) -> Result<Align, String> {\n+        Align::from_bytes((abi + 7) / 8, (pref + 7) / 8)\n+    }\n+\n+    pub fn from_bytes(abi: u64, pref: u64) -> Result<Align, String> {\n+        let pack = |align: u64| {\n+            // Treat an alignment of 0 bytes like 1-byte alignment.\n+            if align == 0 {\n+                return Ok(0);\n+            }\n+\n+            let mut bytes = align;\n+            let mut pow: u8 = 0;\n+            while (bytes & 1) == 0 {\n+                pow += 1;\n+                bytes >>= 1;\n+            }\n+            if bytes != 1 {\n+                Err(format!(\"`{}` is not a power of 2\", align))\n+            } else if pow > 0x0f {\n+                Err(format!(\"`{}` is too large\", align))\n+            } else {\n+                Ok(pow)\n+            }\n+        };\n+\n+        Ok(Align {\n+            raw: pack(abi)? | (pack(pref)? << 4)\n+        })\n+    }\n+\n+    pub fn abi(self) -> u64 {\n+        1 << (self.raw & 0xf)\n+    }\n+\n+    pub fn pref(self) -> u64 {\n+        1 << (self.raw >> 4)\n+    }\n+\n+    pub fn min(self, other: Align) -> Align {\n+        let abi = cmp::min(self.raw & 0x0f, other.raw & 0x0f);\n+        let pref = cmp::min(self.raw & 0xf0, other.raw & 0xf0);\n+        Align {\n+            raw: abi | pref\n+        }\n+    }\n+\n+    pub fn max(self, other: Align) -> Align {\n+        let abi = cmp::max(self.raw & 0x0f, other.raw & 0x0f);\n+        let pref = cmp::max(self.raw & 0xf0, other.raw & 0xf0);\n+        Align {\n+            raw: abi | pref\n+        }\n+    }\n+}"}, {"sha": "ec117f998cdc7a636b37cd413929286f1aeb1621", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=efd0ea5b20a72a0967f80ea3a63f6dc4d1434ce0", "patch": "@@ -84,6 +84,7 @@ pub mod error;\n pub mod fast_reject;\n pub mod fold;\n pub mod item_path;\n+pub mod layout;\n pub mod _match;\n pub mod maps;\n pub mod outlives;"}]}