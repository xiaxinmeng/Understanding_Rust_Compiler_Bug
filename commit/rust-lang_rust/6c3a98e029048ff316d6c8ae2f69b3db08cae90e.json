{"sha": "6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZjM2E5OGUwMjkwNDhmZjMxNmQ2YzhhZTJmNjliM2RiMDhjYWU5MGU=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-14T19:14:25Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-08-14T19:14:25Z"}, "message": "review comments", "tree": {"sha": "1c59c7bdd18f9faa8e0d87373280b74924c3a2ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1c59c7bdd18f9faa8e0d87373280b74924c3a2ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "html_url": "https://github.com/rust-lang/rust/commit/6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6c3a98e029048ff316d6c8ae2f69b3db08cae90e/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "806476c840a19ee2da4113ec3e68f9681018325e", "url": "https://api.github.com/repos/rust-lang/rust/commits/806476c840a19ee2da4113ec3e68f9681018325e", "html_url": "https://github.com/rust-lang/rust/commit/806476c840a19ee2da4113ec3e68f9681018325e"}], "stats": {"total": 137, "additions": 73, "deletions": 64}, "files": [{"sha": "3267505708b8100dfcee4e45cf7fc2423828e423", "filename": "src/librustc/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/6c3a98e029048ff316d6c8ae2f69b3db08cae90e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6c3a98e029048ff316d6c8ae2f69b3db08cae90e/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=6c3a98e029048ff316d6c8ae2f69b3db08cae90e", "patch": "@@ -24,8 +24,8 @@ impl<'a, 'tcx> FindLocalByTypeVisitor<'a, 'tcx> {\n         infcx: &'a InferCtxt<'a, 'tcx>,\n         target_ty: Ty<'tcx>,\n         hir_map: &'a hir::map::Map<'tcx>,\n-    ) -> FindLocalByTypeVisitor<'a, 'tcx> {\n-        FindLocalByTypeVisitor {\n+    ) -> Self {\n+        Self {\n             infcx,\n             target_ty,\n             hir_map,\n@@ -101,6 +101,50 @@ impl<'a, 'tcx> Visitor<'tcx> for FindLocalByTypeVisitor<'a, 'tcx> {\n     }\n }\n \n+/// Suggest giving an appropriate return type to a closure expression.\n+fn closure_return_type_suggestion(\n+    span: Span,\n+    err: &mut DiagnosticBuilder<'_>,\n+    output: &FunctionRetTy,\n+    body: &Body,\n+    name: &str,\n+    ret: &str,\n+) {\n+    let (arrow, post) = match output {\n+        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n+        _ => (\"\", \"\"),\n+    };\n+    let suggestion = match body.value.node {\n+        ExprKind::Block(..) => {\n+            vec![(output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n+        }\n+        _ => {\n+            vec![\n+                (output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n+                (body.value.span.shrink_to_hi(), \" }\".to_string()),\n+            ]\n+        }\n+    };\n+    err.multipart_suggestion(\n+        \"give this closure an explicit return type without `_` placeholders\",\n+        suggestion,\n+        Applicability::HasPlaceholders,\n+    );\n+    err.span_label(span, InferCtxt::missing_type_msg(&name));\n+}\n+\n+/// Given a closure signature, return a `String` containing a list of all its argument types.\n+fn closure_args(fn_sig: &ty::PolyFnSig<'_>) -> String {\n+    fn_sig.inputs()\n+        .skip_binder()\n+        .iter()\n+        .next()\n+        .map(|args| args.tuple_fields()\n+            .map(|arg| arg.to_string())\n+            .collect::<Vec<_>>().join(\", \"))\n+        .unwrap_or_default()\n+}\n+\n impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn extract_type_name(\n         &self,\n@@ -160,24 +204,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             span\n         };\n \n+        let is_named_and_not_impl_trait = |ty: Ty<'_>| {\n+            &ty.to_string() != \"_\" &&\n+                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n+                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n+        };\n+\n         let ty_msg = match local_visitor.found_ty {\n             Some(ty::TyS { sty: ty::Closure(def_id, substs), .. }) => {\n                 let fn_sig = substs.closure_sig(*def_id, self.tcx);\n-                let args = fn_sig.inputs()\n-                    .skip_binder()\n-                    .iter()\n-                    .next()\n-                    .map(|args| args.tuple_fields()\n-                        .map(|arg| arg.to_string())\n-                        .collect::<Vec<_>>().join(\", \"))\n-                    .unwrap_or_default();\n+                let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" &&\n-                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n-                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n-            {\n+            Some(ty) if is_named_and_not_impl_trait(ty) => {\n                 let ty = ty_to_string(ty);\n                 format!(\" for `{}`\", ty)\n             }\n@@ -211,59 +251,33 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 let ret = fn_sig.output().skip_binder().to_string();\n \n                 if let Some(ExprKind::Closure(_, decl, body_id, ..)) = local_visitor.found_closure {\n-                    let (arrow, post) = match decl.output {\n-                        FunctionRetTy::DefaultReturn(_) => (\"-> \", \" \"),\n-                        _ => (\"\", \"\"),\n-                    };\n                     if let Some(body) = self.tcx.hir().krate().bodies.get(body_id) {\n-                        let suggestion = match body.value.node {\n-                            ExprKind::Block(..) => {\n-                                vec![(decl.output.span(), format!(\"{}{}{}\", arrow, ret, post))]\n-                            }\n-                            _ => {\n-                                vec![\n-                                    (decl.output.span(), format!(\"{}{}{}{{ \", arrow, ret, post)),\n-                                    (body.value.span.shrink_to_hi(), \" }\".to_string()),\n-                                ]\n-                            }\n-                        };\n-                        err.multipart_suggestion(\n-                            \"give this closure an explicit return type without `_` placeholders\",\n-                            suggestion,\n-                            Applicability::HasPlaceholders,\n+                        closure_return_type_suggestion(\n+                            span,\n+                            &mut err,\n+                            &decl.output,\n+                            &body,\n+                            &name,\n+                            &ret,\n                         );\n-                        err.span_label(span, InferCtxt::missing_type_msg(&name));\n+                        // We don't want to give the other suggestions when the problem is the\n+                        // closure return type.\n                         return err;\n                     }\n                 }\n \n                 // This shouldn't be reachable, but just in case we leave a reasonable fallback.\n-                let args = fn_sig.inputs()\n-                    .skip_binder()\n-                    .iter()\n-                    .next()\n-                    .map(|args| args.tuple_fields()\n-                        .map(|arg| arg.to_string())\n-                        .collect::<Vec<_>>().join(\", \"))\n-                    .unwrap_or_default();\n+                let args = closure_args(&fn_sig);\n                 // This suggestion is incomplete, as the user will get further type inference\n                 // errors due to the `_` placeholders and the introduction of `Box`, but it does\n                 // nudge them in the right direction.\n                 format!(\"a boxed closure type like `Box<dyn Fn({}) -> {}>`\", args, ret)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" &&\n-                name == \"_\" &&\n-                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n-                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n-            {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && name == \"_\" => {\n                 let ty = ty_to_string(ty);\n                 format!(\"the explicit type `{}`, with the type parameters specified\", ty)\n             }\n-            Some(ty) if &ty.to_string() != \"_\" &&\n-                ty.to_string() != name &&\n-                // FIXME: Remove this check after `impl_trait_in_bindings` is stabilized. #63527\n-                (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings) =>\n-            {\n+            Some(ty) if is_named_and_not_impl_trait(ty) && ty.to_string() != name => {\n                 let ty = ty_to_string(ty);\n                 format!(\n                     \"the explicit type `{}`, where the type parameter `{}` is specified\",\n@@ -296,25 +310,20 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 format!(\"consider giving this closure parameter {}\", suffix),\n             );\n         } else if let Some(pattern) = local_visitor.found_local_pattern {\n-            if let Some(simple_ident) = pattern.simple_ident() {\n+            let msg = if let Some(simple_ident) = pattern.simple_ident() {\n                 match pattern.span.desugaring_kind() {\n                     None => {\n-                        err.span_label(\n-                            pattern.span,\n-                            format!(\"consider giving `{}` {}\", simple_ident, suffix),\n-                        );\n+                        format!(\"consider giving `{}` {}\", simple_ident, suffix)\n                     }\n                     Some(DesugaringKind::ForLoop) => {\n-                        err.span_label(\n-                            pattern.span,\n-                            \"the element type for this iterator is not specified\".to_string(),\n-                        );\n+                        \"the element type for this iterator is not specified\".to_string()\n                     }\n-                    _ => {}\n+                    _ => format!(\"this needs {}\", suffix),\n                 }\n             } else {\n-                err.span_label(pattern.span, format!(\"consider giving this pattern {}\", suffix));\n-            }\n+                format!(\"consider giving this pattern {}\", suffix)\n+            };\n+            err.span_label(pattern.span, msg);\n         }\n         if !err.span.span_labels().iter().any(|span_label| {\n                 span_label.label.is_some() && span_label.span == span"}]}