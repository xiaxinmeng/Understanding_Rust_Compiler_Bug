{"sha": "3d5753fda1ee8f729da1061e931e13b043f479a5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkNTc1M2ZkYTFlZThmNzI5ZGExMDYxZTkzMWUxM2IwNDNmNDc5YTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-16T09:41:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-16T09:41:54Z"}, "message": "Auto merge of #52422 - michaelwoerister:revert-52266, r=oli-obk\n\nRevert #52266\n\nReverts #52266 until the performance issues with that PR are ironed out.", "tree": {"sha": "520829f521d866f7cc80b23ad5c8066e6234866c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/520829f521d866f7cc80b23ad5c8066e6234866c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d5753fda1ee8f729da1061e931e13b043f479a5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5753fda1ee8f729da1061e931e13b043f479a5", "html_url": "https://github.com/rust-lang/rust/commit/3d5753fda1ee8f729da1061e931e13b043f479a5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d5753fda1ee8f729da1061e931e13b043f479a5/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fa76a45024412c268237b840294ae3056035ff4", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fa76a45024412c268237b840294ae3056035ff4", "html_url": "https://github.com/rust-lang/rust/commit/1fa76a45024412c268237b840294ae3056035ff4"}, {"sha": "d992090a702dff976a6d05a9b53b0d7b82199d14", "url": "https://api.github.com/repos/rust-lang/rust/commits/d992090a702dff976a6d05a9b53b0d7b82199d14", "html_url": "https://github.com/rust-lang/rust/commit/d992090a702dff976a6d05a9b53b0d7b82199d14"}], "stats": {"total": 628, "additions": 171, "deletions": 457}, "files": [{"sha": "79566fbbc11a46c1cba41446fceeb5f2493cb61c", "filename": "src/librustc/mir/mono.rs", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmono.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -8,16 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::def_id::{DefId, CrateNum};\n+use hir::def_id::DefId;\n use syntax::ast::NodeId;\n-use syntax::symbol::{Symbol, InternedString};\n+use syntax::symbol::InternedString;\n use ty::{Instance, TyCtxt};\n use util::nodemap::FxHashMap;\n use rustc_data_structures::base_n;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasherResult,\n                                            StableHasher};\n use ich::{Fingerprint, StableHashingContext, NodeIdHashingMode};\n-use std::fmt;\n use std::hash::Hash;\n \n #[derive(PartialEq, Eq, Clone, Copy, Debug, Hash)]\n@@ -174,80 +173,6 @@ impl<'tcx> CodegenUnit<'tcx> {\n             self.size_estimate = Some(size_estimate + delta);\n         }\n     }\n-\n-    /// CGU names should fulfill the following requirements:\n-    /// - They should be able to act as a file name on any kind of file system\n-    /// - They should not collide with other CGU names, even for different versions\n-    ///   of the same crate.\n-    ///\n-    /// Consequently, we don't use special characters except for '.' and '-' and we\n-    /// prefix each name with the crate-name and crate-disambiguator.\n-    ///\n-    /// This function will build CGU names of the form:\n-    ///\n-    /// ```\n-    /// <crate-name>.<crate-disambiguator>(-<component>)*[.<special-suffix>]\n-    /// ```\n-    ///\n-    /// The '.' before `<special-suffix>` makes sure that names with a special\n-    /// suffix can never collide with a name built out of regular Rust\n-    /// identifiers (e.g. module paths).\n-    pub fn build_cgu_name<I, C, S>(tcx: TyCtxt,\n-                                   cnum: CrateNum,\n-                                   components: I,\n-                                   special_suffix: Option<S>)\n-                                   -> InternedString\n-        where I: IntoIterator<Item=C>,\n-              C: fmt::Display,\n-              S: fmt::Display,\n-    {\n-        let cgu_name = CodegenUnit::build_cgu_name_no_mangle(tcx,\n-                                                             cnum,\n-                                                             components,\n-                                                             special_suffix);\n-\n-        if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n-            cgu_name\n-        } else {\n-            let cgu_name = &cgu_name.as_str()[..];\n-            Symbol::intern(&CodegenUnit::mangle_name(cgu_name)).as_interned_str()\n-        }\n-    }\n-\n-    /// Same as `CodegenUnit::build_cgu_name()` but will never mangle the\n-    /// resulting name.\n-    pub fn build_cgu_name_no_mangle<I, C, S>(tcx: TyCtxt,\n-                                             cnum: CrateNum,\n-                                             components: I,\n-                                             special_suffix: Option<S>)\n-                                             -> InternedString\n-        where I: IntoIterator<Item=C>,\n-              C: fmt::Display,\n-              S: fmt::Display,\n-    {\n-        use std::fmt::Write;\n-\n-        let mut cgu_name = String::with_capacity(64);\n-\n-        // Start out with the crate name and disambiguator\n-        write!(cgu_name,\n-               \"{}.{}\",\n-               tcx.crate_name(cnum),\n-               tcx.crate_disambiguator(cnum)).unwrap();\n-\n-        // Add the components\n-        for component in components {\n-            write!(cgu_name, \"-{}\", component).unwrap();\n-        }\n-\n-        if let Some(special_suffix) = special_suffix {\n-            // We add a dot in here so it cannot clash with anything in a regular\n-            // Rust identifier\n-            write!(cgu_name, \".{}\", special_suffix).unwrap();\n-        }\n-\n-        Symbol::intern(&cgu_name[..]).as_interned_str()\n-    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for CodegenUnit<'tcx> {"}, {"sha": "ad1df0a1348c53917b67d85dfc373942e97aaa3c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -26,7 +26,6 @@ use util::nodemap::{FxHashMap, FxHashSet};\n use util::common::{duration_to_secs_str, ErrorReported};\n use util::common::ProfileQueriesMsg;\n \n-use rustc_data_structures::base_n;\n use rustc_data_structures::sync::{self, Lrc, Lock, LockCell, OneThread, Once, RwLock};\n \n use syntax::ast::NodeId;\n@@ -1186,14 +1185,6 @@ impl CrateDisambiguator {\n     }\n }\n \n-impl fmt::Display for CrateDisambiguator {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> Result<(), fmt::Error> {\n-        let (a, b) = self.0.as_value();\n-        let as_u128 = a as u128 | ((b as u128) << 64);\n-        f.write_str(&base_n::encode(as_u128, base_n::CASE_INSENSITIVE))\n-    }\n-}\n-\n impl From<Fingerprint> for CrateDisambiguator {\n     fn from(fingerprint: Fingerprint) -> CrateDisambiguator {\n         CrateDisambiguator(fingerprint)"}, {"sha": "a7f0910a6fcccff6e1fe9eb48b1ea26d213499b9", "filename": "src/librustc_codegen_llvm/back/link.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flink.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -45,6 +45,13 @@ use std::process::{Output, Stdio};\n use std::str;\n use syntax::attr;\n \n+/// The LLVM module name containing crate-metadata. This includes a `.` on\n+/// purpose, so it cannot clash with the name of a user-defined module.\n+pub const METADATA_MODULE_NAME: &'static str = \"crate.metadata\";\n+\n+// same as for metadata above, but for allocator shim\n+pub const ALLOCATOR_MODULE_NAME: &'static str = \"crate.allocator\";\n+\n pub use rustc_codegen_utils::link::{find_crate_name, filename_for_input, default_output_for_target,\n                                   invalid_output_for_target, build_link_meta, out_filename,\n                                   check_file_is_writeable};"}, {"sha": "a33f8b569d0a8585e3cee4a92ffbf70e90b19699", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 9, "deletions": 142, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -20,23 +20,16 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n-use rustc_data_structures::fx::FxHashMap;\n use time_graph::Timeline;\n use {ModuleCodegen, ModuleLlvm, ModuleKind, ModuleSource};\n \n use libc;\n \n-use std::ffi::{CString, CStr};\n-use std::fs::File;\n-use std::io;\n-use std::mem;\n-use std::path::Path;\n+use std::ffi::CString;\n use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n-pub const THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME: &str = \"thin-lto-imports.bin\";\n-\n pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n     match crate_type {\n         config::CrateTypeExecutable |\n@@ -200,7 +193,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n         }\n         Lto::Thin |\n         Lto::ThinLocal => {\n-            thin_lto(cgcx, &diag_handler, modules, upstream_modules, &arr, timeline)\n+            thin_lto(&diag_handler, modules, upstream_modules, &arr, timeline)\n         }\n         Lto::No => unreachable!(),\n     }\n@@ -238,7 +231,7 @@ fn fat_lto(cgcx: &CodegenContext,\n         .expect(\"must be codegen'ing at least one module\");\n     let module = modules.remove(costliest_module);\n     let llmod = module.llvm().expect(\"can't lto pre-codegened modules\").llmod;\n-    info!(\"using {:?} as a base module\", module.name);\n+    info!(\"using {:?} as a base module\", module.llmod_id);\n \n     // For all other modules we codegened we'll need to link them into our own\n     // bitcode. All modules were codegened in their own LLVM context, however,\n@@ -248,7 +241,7 @@ fn fat_lto(cgcx: &CodegenContext,\n     for module in modules {\n         let llvm = module.llvm().expect(\"can't lto pre-codegened modules\");\n         let buffer = ModuleBuffer::new(llvm.llmod);\n-        let llmod_id = CString::new(&module.name[..]).unwrap();\n+        let llmod_id = CString::new(&module.llmod_id[..]).unwrap();\n         serialized_modules.push((SerializedModule::Local(buffer), llmod_id));\n     }\n \n@@ -353,8 +346,7 @@ impl Drop for Linker {\n /// calculating the *index* for ThinLTO. This index will then be shared amongst\n /// all of the `LtoModuleCodegen` units returned below and destroyed once\n /// they all go out of scope.\n-fn thin_lto(cgcx: &CodegenContext,\n-            diag_handler: &Handler,\n+fn thin_lto(diag_handler: &Handler,\n             modules: Vec<ModuleCodegen>,\n             serialized_modules: Vec<(SerializedModule, CString)>,\n             symbol_white_list: &[*const libc::c_char],\n@@ -376,9 +368,9 @@ fn thin_lto(cgcx: &CodegenContext,\n         //        the most expensive portion of this small bit of global\n         //        analysis!\n         for (i, module) in modules.iter().enumerate() {\n-            info!(\"local module: {} - {}\", i, module.name);\n+            info!(\"local module: {} - {}\", i, module.llmod_id);\n             let llvm = module.llvm().expect(\"can't lto precodegened module\");\n-            let name = CString::new(module.name.clone()).unwrap();\n+            let name = CString::new(module.llmod_id.clone()).unwrap();\n             let buffer = ThinBuffer::new(llvm.llmod);\n             thin_modules.push(llvm::ThinLTOModule {\n                 identifier: name.as_ptr(),\n@@ -387,7 +379,7 @@ fn thin_lto(cgcx: &CodegenContext,\n             });\n             thin_buffers.push(buffer);\n             module_names.push(name);\n-            timeline.record(&module.name);\n+            timeline.record(&module.llmod_id);\n         }\n \n         // FIXME: All upstream crates are deserialized internally in the\n@@ -432,18 +424,6 @@ fn thin_lto(cgcx: &CodegenContext,\n             let msg = format!(\"failed to prepare thin LTO context\");\n             return Err(write::llvm_err(&diag_handler, msg))\n         }\n-\n-        // Save the ThinLTO import information for incremental compilation.\n-        if let Some(ref incr_comp_session_dir) = cgcx.incr_comp_session_dir {\n-            let path = incr_comp_session_dir.join(THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME);\n-            let imports = ThinLTOImports::from_thin_lto_data(data);\n-            if let Err(err) = imports.save_to_file(&path) {\n-                let msg = format!(\"Error while writing ThinLTO import data: {}\",\n-                                  err);\n-                return Err(write::llvm_err(&diag_handler, msg));\n-            }\n-        }\n-\n         let data = ThinData(data);\n         info!(\"thin LTO data created\");\n         timeline.record(\"data\");\n@@ -676,6 +656,7 @@ impl ThinModule {\n                 llcx,\n                 tm,\n             }),\n+            llmod_id: self.name().to_string(),\n             name: self.name().to_string(),\n             kind: ModuleKind::Regular,\n         };\n@@ -795,117 +776,3 @@ impl ThinModule {\n         Ok(module)\n     }\n }\n-\n-\n-#[derive(Debug)]\n-pub struct ThinLTOImports {\n-    // key = llvm name of importing module, value = list of modules it imports from\n-    imports: FxHashMap<String, Vec<String>>,\n-}\n-\n-impl ThinLTOImports {\n-\n-    pub fn new() -> ThinLTOImports {\n-        ThinLTOImports {\n-            imports: FxHashMap(),\n-        }\n-    }\n-\n-    /// Load the ThinLTO import map from ThinLTOData.\n-    unsafe fn from_thin_lto_data(data: *const llvm::ThinLTOData) -> ThinLTOImports {\n-\n-        fn module_name_to_str(c_str: &CStr) -> &str {\n-            match c_str.to_str() {\n-                Ok(s) => s,\n-                Err(e) => {\n-                    bug!(\"Encountered non-utf8 LLVM module name `{}`: {}\",\n-                        c_str.to_string_lossy(),\n-                        e)\n-                }\n-            }\n-        }\n-\n-        unsafe extern \"C\" fn imported_module_callback(payload: *mut libc::c_void,\n-                                                      importing_module_name: *const libc::c_char,\n-                                                      imported_module_name: *const libc::c_char) {\n-            let map = &mut* (payload as *mut ThinLTOImports);\n-\n-            let importing_module_name = CStr::from_ptr(importing_module_name);\n-            let importing_module_name = module_name_to_str(&importing_module_name);\n-            let imported_module_name = CStr::from_ptr(imported_module_name);\n-            let imported_module_name = module_name_to_str(&imported_module_name);\n-\n-            if !map.imports.contains_key(importing_module_name) {\n-                map.imports.insert(importing_module_name.to_owned(), vec![]);\n-            }\n-\n-            map.imports\n-               .get_mut(importing_module_name)\n-               .unwrap()\n-               .push(imported_module_name.to_owned());\n-        }\n-\n-        let mut map = ThinLTOImports {\n-            imports: FxHashMap(),\n-        };\n-\n-        llvm::LLVMRustGetThinLTOModuleImports(data,\n-                                              imported_module_callback,\n-                                              &mut map as *mut _ as *mut libc::c_void);\n-        map\n-    }\n-\n-    pub fn save_to_file(&self, path: &Path) -> io::Result<()> {\n-        use std::io::Write;\n-\n-        let file = File::create(path)?;\n-        let mut writer = io::BufWriter::new(file);\n-\n-        for (importing_module_name, imported_modules) in &self.imports {\n-            writeln!(writer, \"{}\", importing_module_name)?;\n-\n-            for imported_module in imported_modules {\n-                writeln!(writer, \"  {}\", imported_module)?;\n-            }\n-\n-            writeln!(writer)?;\n-        }\n-\n-        Ok(())\n-    }\n-\n-    pub fn load_from_file(path: &Path) -> io::Result<ThinLTOImports> {\n-        use std::io::BufRead;\n-\n-        let mut imports = FxHashMap();\n-        let mut current_module = None;\n-        let mut current_imports = vec![];\n-\n-        let file = File::open(path)?;\n-\n-        for line in io::BufReader::new(file).lines() {\n-            let line = line?;\n-\n-            if line.is_empty() {\n-                let importing_module = current_module\n-                    .take()\n-                    .expect(\"Importing module not set\");\n-\n-                imports.insert(importing_module,\n-                               mem::replace(&mut current_imports, vec![]));\n-            } else if line.starts_with(\" \") {\n-                // This is an imported module\n-                assert_ne!(current_module, None);\n-                current_imports.push(line.trim().to_string());\n-            } else {\n-                // This is the beginning of a new module\n-                assert_eq!(current_module, None);\n-                current_module = Some(line.trim().to_string());\n-            }\n-        }\n-\n-        Ok(ThinLTOImports {\n-            imports\n-        })\n-    }\n-}"}, {"sha": "d36142af56c6540ad15af51d052e1bace989f8c9", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -694,7 +694,7 @@ unsafe fn codegen(cgcx: &CodegenContext,\n \n         if config.emit_bc_compressed {\n             let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n-            let data = bytecode::encode(&module.name, data);\n+            let data = bytecode::encode(&module.llmod_id, data);\n             if let Err(e) = fs::write(&dst, data) {\n                 diag_handler.err(&format!(\"failed to write bytecode: {}\", e));\n             }\n@@ -1306,6 +1306,7 @@ fn execute_work_item(cgcx: &CodegenContext,\n         assert_eq!(bytecode_compressed.is_some(), config.emit_bc_compressed);\n \n         Ok(WorkItemResult::Compiled(CompiledModule {\n+            llmod_id: module.llmod_id.clone(),\n             name: module_name,\n             kind: ModuleKind::Regular,\n             pre_existing: true,"}, {"sha": "ea26e271c9bb3edad6c6221b951f28b6b36c3f26", "filename": "src/librustc_codegen_llvm/base.rs", "status": "modified", "additions": 49, "deletions": 53, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbase.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -29,7 +29,7 @@ use super::ModuleCodegen;\n use super::ModuleKind;\n \n use abi;\n-use back::{link, lto};\n+use back::link;\n use back::write::{self, OngoingCodegen, create_target_machine};\n use llvm::{ContextRef, ModuleRef, ValueRef, Vector, get_param};\n use llvm;\n@@ -739,18 +739,15 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let link_meta = link::build_link_meta(crate_hash);\n \n     // Codegen the metadata.\n-    let metadata_cgu_name = CodegenUnit::build_cgu_name(tcx,\n-                                                        LOCAL_CRATE,\n-                                                        &[\"crate\"],\n-                                                        Some(\"metadata\")).as_str()\n-                                                                         .to_string();\n+    let llmod_id = \"metadata\";\n     let (metadata_llcx, metadata_llmod, metadata) =\n         time(tcx.sess, \"write metadata\", || {\n-            write_metadata(tcx, &metadata_cgu_name, &link_meta)\n+            write_metadata(tcx, llmod_id, &link_meta)\n         });\n \n     let metadata_module = ModuleCodegen {\n-        name: metadata_cgu_name,\n+        name: link::METADATA_MODULE_NAME.to_string(),\n+        llmod_id: llmod_id.to_string(),\n         source: ModuleSource::Codegened(ModuleLlvm {\n             llcx: metadata_llcx,\n             llmod: metadata_llmod,\n@@ -813,30 +810,26 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     // Codegen an allocator shim, if any\n     let allocator_module = if let Some(kind) = *tcx.sess.allocator_kind.get() {\n-        let llmod_id = CodegenUnit::build_cgu_name(tcx,\n-                                                   LOCAL_CRATE,\n-                                                   &[\"crate\"],\n-                                                   Some(\"allocator\")).as_str()\n-                                                                     .to_string();\n-        let (llcx, llmod) = unsafe {\n-            context::create_context_and_module(tcx.sess, &llmod_id)\n-        };\n-        let modules = ModuleLlvm {\n-            llmod,\n-            llcx,\n-            tm: create_target_machine(tcx.sess, false),\n-        };\n-        time(tcx.sess, \"write allocator module\", || {\n-            unsafe {\n+        unsafe {\n+            let llmod_id = \"allocator\";\n+            let (llcx, llmod) =\n+                context::create_context_and_module(tcx.sess, llmod_id);\n+            let modules = ModuleLlvm {\n+                llmod,\n+                llcx,\n+                tm: create_target_machine(tcx.sess, false),\n+            };\n+            time(tcx.sess, \"write allocator module\", || {\n                 allocator::codegen(tcx, &modules, kind)\n-            }\n-        });\n+            });\n \n-        Some(ModuleCodegen {\n-            name: llmod_id,\n-            source: ModuleSource::Codegened(modules),\n-            kind: ModuleKind::Allocator,\n-        })\n+            Some(ModuleCodegen {\n+                name: link::ALLOCATOR_MODULE_NAME.to_string(),\n+                llmod_id: llmod_id.to_string(),\n+                source: ModuleSource::Codegened(modules),\n+                kind: ModuleKind::Allocator,\n+            })\n+        }\n     } else {\n         None\n     };\n@@ -879,10 +872,21 @@ pub fn codegen_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 // succeed it means that none of the dependencies has changed\n                 // and we can safely re-use.\n                 if let Some(dep_node_index) = tcx.dep_graph.try_mark_green(tcx, dep_node) {\n+                    // Append \".rs\" to LLVM module identifier.\n+                    //\n+                    // LLVM code generator emits a \".file filename\" directive\n+                    // for ELF backends. Value of the \"filename\" is set as the\n+                    // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+                    // crashes if the module identifier is same as other symbols\n+                    // such as a function name in the module.\n+                    // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+                    let llmod_id = format!(\"{}.rs\", cgu.name());\n+\n                     let module = ModuleCodegen {\n                         name: cgu.name().to_string(),\n                         source: ModuleSource::Preexisting(buf),\n                         kind: ModuleKind::Regular,\n+                        llmod_id,\n                     };\n                     tcx.dep_graph.mark_loaded_from_cache(dep_node_index, true);\n                     write::submit_codegened_module_to_llvm(tcx, module, 0);\n@@ -1191,8 +1195,21 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     {\n         let cgu_name = cgu.name().to_string();\n \n+        // Append \".rs\" to LLVM module identifier.\n+        //\n+        // LLVM code generator emits a \".file filename\" directive\n+        // for ELF backends. Value of the \"filename\" is set as the\n+        // LLVM module identifier.  Due to a LLVM MC bug[1], LLVM\n+        // crashes if the module identifier is same as other symbols\n+        // such as a function name in the module.\n+        // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n+        let llmod_id = format!(\"{}-{}.rs\",\n+                               cgu.name(),\n+                               tcx.crate_disambiguator(LOCAL_CRATE)\n+                                   .to_fingerprint().to_hex());\n+\n         // Instantiate monomorphizations without filling out definitions yet...\n-        let cx = CodegenCx::new(tcx, cgu);\n+        let cx = CodegenCx::new(tcx, cgu, &llmod_id);\n         let module = {\n             let mono_items = cx.codegen_unit\n                                  .items_in_deterministic_order(cx.tcx);\n@@ -1250,6 +1267,7 @@ fn compile_codegen_unit<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 name: cgu_name,\n                 source: ModuleSource::Codegened(llvm_module),\n                 kind: ModuleKind::Regular,\n+                llmod_id,\n             }\n         };\n \n@@ -1352,27 +1370,6 @@ mod temp_stable_hash_impls {\n     }\n }\n \n-#[allow(unused)]\n-fn load_thin_lto_imports(sess: &Session) -> lto::ThinLTOImports {\n-    let path = rustc_incremental::in_incr_comp_dir_sess(\n-        sess,\n-        lto::THIN_LTO_IMPORTS_INCR_COMP_FILE_NAME\n-    );\n-\n-    if !path.exists() {\n-        return lto::ThinLTOImports::new();\n-    }\n-\n-    match lto::ThinLTOImports::load_from_file(&path) {\n-        Ok(imports) => imports,\n-        Err(e) => {\n-            let msg = format!(\"Error while trying to load ThinLTO import data \\\n-                               for incremental compilation: {}\", e);\n-            sess.fatal(&msg)\n-        }\n-    }\n-}\n-\n pub fn define_custom_section(cx: &CodegenCx, def_id: DefId) {\n     use rustc::mir::interpret::GlobalId;\n \n@@ -1411,4 +1408,3 @@ pub fn define_custom_section(cx: &CodegenCx, def_id: DefId) {\n         );\n     }\n }\n-"}, {"sha": "b774d7c5def217a9a17f5bc501bc8ef60cdb7d07", "filename": "src/librustc_codegen_llvm/context.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcontext.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -214,7 +214,8 @@ pub unsafe fn create_context_and_module(sess: &Session, mod_name: &str) -> (Cont\n \n impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n     pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               codegen_unit: Arc<CodegenUnit<'tcx>>)\n+               codegen_unit: Arc<CodegenUnit<'tcx>>,\n+               llmod_id: &str)\n                -> CodegenCx<'a, 'tcx> {\n         // An interesting part of Windows which MSVC forces our hand on (and\n         // apparently MinGW didn't) is the usage of `dllimport` and `dllexport`\n@@ -267,7 +268,7 @@ impl<'a, 'tcx> CodegenCx<'a, 'tcx> {\n \n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&tcx.sess,\n-                                                          &codegen_unit.name().as_str());\n+                                                          &llmod_id[..]);\n \n             let dbg_cx = if tcx.sess.opts.debuginfo != NoDebugInfo {\n                 let dctx = debuginfo::CrateDebugContext::new(llmod);"}, {"sha": "8aa7902021f240891e2b8686c43b7e2f0931a136", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -90,7 +90,7 @@ mod back {\n     mod command;\n     pub mod linker;\n     pub mod link;\n-    pub mod lto;\n+    mod lto;\n     pub mod symbol_export;\n     pub mod write;\n     mod rpath;\n@@ -258,8 +258,8 @@ struct ModuleCodegen {\n     /// unique amongst **all** crates.  Therefore, it should contain\n     /// something unique to this crate (e.g., a module path) as well\n     /// as the crate name and disambiguator.\n-    /// We currently generate these names via CodegenUnit::build_cgu_name().\n     name: String,\n+    llmod_id: String,\n     source: ModuleSource,\n     kind: ModuleKind,\n }\n@@ -306,6 +306,7 @@ impl ModuleCodegen {\n         };\n \n         CompiledModule {\n+            llmod_id: self.llmod_id,\n             name: self.name.clone(),\n             kind: self.kind,\n             pre_existing,\n@@ -319,6 +320,7 @@ impl ModuleCodegen {\n #[derive(Debug)]\n struct CompiledModule {\n     name: String,\n+    llmod_id: String,\n     kind: ModuleKind,\n     pre_existing: bool,\n     object: Option<PathBuf>,"}, {"sha": "df8e0f056afc9141651b63ea8fd0601aaded3d6c", "filename": "src/librustc_incremental/assert_module_sources.rs", "status": "modified", "additions": 8, "deletions": 45, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Fassert_module_sources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fassert_module_sources.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -27,11 +27,11 @@\n //! the HIR doesn't change as a result of the annotations, which might\n //! perturb the reuse results.\n \n-use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::dep_graph::{DepNode, DepConstructor};\n use rustc::mir::mono::CodegenUnit;\n use rustc::ty::TyCtxt;\n use syntax::ast;\n+use syntax_pos::symbol::Symbol;\n use rustc::ich::{ATTR_PARTITION_REUSED, ATTR_PARTITION_CODEGENED};\n \n const MODULE: &'static str = \"module\";\n@@ -72,71 +72,34 @@ impl<'a, 'tcx> AssertModuleSource<'a, 'tcx> {\n             return;\n         }\n \n-        let user_path = self.field(attr, MODULE).as_str().to_string();\n-        let crate_name = self.tcx.crate_name(LOCAL_CRATE).as_str().to_string();\n-\n-        if !user_path.starts_with(&crate_name) {\n-            let msg = format!(\"Found malformed codegen unit name `{}`. \\\n-                Codegen units names must always start with the name of the \\\n-                crate (`{}` in this case).\", user_path, crate_name);\n-            self.tcx.sess.span_fatal(attr.span, &msg);\n-        }\n-\n-        // Split of the \"special suffix\" if there is one.\n-        let (user_path, cgu_special_suffix) = if let Some(index) = user_path.rfind(\".\") {\n-            (&user_path[..index], Some(&user_path[index + 1 ..]))\n-        } else {\n-            (&user_path[..], None)\n-        };\n-\n-        let mut cgu_path_components = user_path.split(\"-\").collect::<Vec<_>>();\n-\n-        // Remove the crate name\n-        assert_eq!(cgu_path_components.remove(0), crate_name);\n-\n-        let cgu_name = CodegenUnit::build_cgu_name(self.tcx,\n-                                                   LOCAL_CRATE,\n-                                                   cgu_path_components,\n-                                                   cgu_special_suffix);\n-\n-        debug!(\"mapping '{}' to cgu name '{}'\", self.field(attr, MODULE), cgu_name);\n+        let mname = self.field(attr, MODULE);\n+        let mangled_cgu_name = CodegenUnit::mangle_name(&mname.as_str());\n+        let mangled_cgu_name = Symbol::intern(&mangled_cgu_name).as_interned_str();\n \n         let dep_node = DepNode::new(self.tcx,\n-                                    DepConstructor::CompileCodegenUnit(cgu_name));\n+                                    DepConstructor::CompileCodegenUnit(mangled_cgu_name));\n \n         if let Some(loaded_from_cache) = self.tcx.dep_graph.was_loaded_from_cache(&dep_node) {\n             match (disposition, loaded_from_cache) {\n                 (Disposition::Reused, false) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n                         &format!(\"expected module named `{}` to be Reused but is Codegened\",\n-                                 user_path));\n+                                 mname));\n                 }\n                 (Disposition::Codegened, true) => {\n                     self.tcx.sess.span_err(\n                         attr.span,\n                         &format!(\"expected module named `{}` to be Codegened but is Reused\",\n-                                 user_path));\n+                                 mname));\n                 }\n                 (Disposition::Reused, true) |\n                 (Disposition::Codegened, false) => {\n                     // These are what we would expect.\n                 }\n             }\n         } else {\n-            let available_cgus = self.tcx\n-                .collect_and_partition_mono_items(LOCAL_CRATE)\n-                .1\n-                .iter()\n-                .map(|cgu| format!(\"{}\", cgu.name()))\n-                .collect::<Vec<String>>()\n-                .join(\", \");\n-\n-            self.tcx.sess.span_err(attr.span,\n-                &format!(\"no module named `{}` (mangled: {}).\\nAvailable modules: {}\",\n-                    user_path,\n-                    cgu_name,\n-                    available_cgus));\n+            self.tcx.sess.span_err(attr.span, &format!(\"no module named `{}`\", mname));\n         }\n     }\n "}, {"sha": "2ef88041d338f67c5ce4894213f1d3efef14b83b", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -44,7 +44,6 @@ pub use persist::copy_cgu_workproducts_to_incr_comp_cache_dir;\n pub use persist::save_dep_graph;\n pub use persist::save_work_product_index;\n pub use persist::in_incr_comp_dir;\n-pub use persist::in_incr_comp_dir_sess;\n pub use persist::prepare_session_directory;\n pub use persist::finalize_session_directory;\n pub use persist::delete_workproduct_files;"}, {"sha": "e1f00db56d5cbc0572214a3a15d94941e7a8b09e", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -23,7 +23,6 @@ mod file_format;\n pub use self::fs::finalize_session_directory;\n pub use self::fs::garbage_collect_session_directories;\n pub use self::fs::in_incr_comp_dir;\n-pub use self::fs::in_incr_comp_dir_sess;\n pub use self::fs::prepare_session_directory;\n pub use self::load::dep_graph_tcx_init;\n pub use self::load::load_dep_graph;"}, {"sha": "b4483557dd33fe53816ae93598df910fa67b169f", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -351,10 +351,6 @@ pub enum ThinLTOData {}\n /// LLVMRustThinLTOBuffer\n pub enum ThinLTOBuffer {}\n \n-// LLVMRustModuleNameCallback\n-pub type ThinLTOModuleNameCallback =\n-    unsafe extern \"C\" fn(*mut c_void, *const c_char, *const c_char);\n-\n /// LLVMRustThinLTOModule\n #[repr(C)]\n pub struct ThinLTOModule {\n@@ -1783,11 +1779,6 @@ extern \"C\" {\n         Data: *const ThinLTOData,\n         Module: ModuleRef,\n     ) -> bool;\n-    pub fn LLVMRustGetThinLTOModuleImports(\n-        Data: *const ThinLTOData,\n-        ModuleNameCallback: ThinLTOModuleNameCallback,\n-        CallbackPayload: *mut c_void,\n-    );\n     pub fn LLVMRustFreeThinLTOData(Data: *mut ThinLTOData);\n     pub fn LLVMRustParseBitcodeForThinLTO(\n         Context: ContextRef,"}, {"sha": "5f15870d6fbc306c4e7d2c5725cc4f9180ab9eea", "filename": "src/librustc_mir/monomorphize/partitioning.rs", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fpartitioning.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -104,7 +104,7 @@\n \n use monomorphize::collector::InliningMap;\n use rustc::dep_graph::WorkProductId;\n-use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::mir::mono::{Linkage, Visibility};\n use rustc::middle::exported_symbols::SymbolExportLevel;\n@@ -114,7 +114,7 @@ use rustc::util::nodemap::{FxHashMap, FxHashSet};\n use std::collections::hash_map::Entry;\n use std::cmp;\n use syntax::ast::NodeId;\n-use syntax::symbol::InternedString;\n+use syntax::symbol::{Symbol, InternedString};\n use rustc::mir::mono::MonoItem;\n use monomorphize::item::{MonoItemExt, InstantiationMode};\n \n@@ -204,9 +204,16 @@ impl<'tcx> CodegenUnitExt<'tcx> for CodegenUnit<'tcx> {\n \n // Anything we can't find a proper codegen unit for goes into this.\n fn fallback_cgu_name(tcx: TyCtxt) -> InternedString {\n-    CodegenUnit::build_cgu_name(tcx, LOCAL_CRATE, &[\"fallback\"], Some(\"cgu\"))\n+    const FALLBACK_CODEGEN_UNIT: &'static str = \"__rustc_fallback_codegen_unit\";\n+\n+    if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+        Symbol::intern(FALLBACK_CODEGEN_UNIT).as_interned_str()\n+    } else {\n+        Symbol::intern(&CodegenUnit::mangle_name(FALLBACK_CODEGEN_UNIT)).as_interned_str()\n+    }\n }\n \n+\n pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                               mono_items: I,\n                               strategy: PartitioningStrategy,\n@@ -217,7 +224,8 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // In the first step, we place all regular monomorphizations into their\n     // respective 'home' codegen unit. Regular monomorphizations are all\n     // functions and statics defined in the local crate.\n-    let mut initial_partitioning = place_root_mono_items(tcx, mono_items);\n+    let mut initial_partitioning = place_root_mono_items(tcx,\n+                                                                mono_items);\n \n     initial_partitioning.codegen_units.iter_mut().for_each(|cgu| cgu.estimate_size(&tcx));\n \n@@ -226,7 +234,7 @@ pub fn partition<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     // If the partitioning should produce a fixed count of codegen units, merge\n     // until that count is reached.\n     if let PartitioningStrategy::FixedUnitCount(count) = strategy {\n-        merge_codegen_units(tcx, &mut initial_partitioning, count);\n+        merge_codegen_units(&mut initial_partitioning, count, &tcx.crate_name.as_str());\n \n         debug_dump(tcx, \"POST MERGING:\", initial_partitioning.codegen_units.iter());\n     }\n@@ -320,7 +328,7 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         };\n \n         let codegen_unit = codegen_units.entry(codegen_unit_name.clone())\n-                                        .or_insert_with(make_codegen_unit);\n+                                            .or_insert_with(make_codegen_unit);\n \n         let mut can_be_internalized = true;\n         let default_visibility = |id: DefId, is_generic: bool| {\n@@ -483,9 +491,9 @@ fn place_root_mono_items<'a, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n-                             initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n-                             target_cgu_count: usize) {\n+fn merge_codegen_units<'tcx>(initial_partitioning: &mut PreInliningPartitioning<'tcx>,\n+                             target_cgu_count: usize,\n+                             crate_name: &str) {\n     assert!(target_cgu_count >= 1);\n     let codegen_units = &mut initial_partitioning.codegen_units;\n \n@@ -514,7 +522,7 @@ fn merge_codegen_units<'tcx>(tcx: TyCtxt<'_, 'tcx, 'tcx>,\n     }\n \n     for (index, cgu) in codegen_units.iter_mut().enumerate() {\n-        cgu.set_name(numbered_codegen_unit_name(tcx, index));\n+        cgu.set_name(numbered_codegen_unit_name(crate_name, index));\n     }\n }\n \n@@ -719,26 +727,42 @@ fn compute_codegen_unit_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                        def_id: DefId,\n                                        volatile: bool)\n                                        -> InternedString {\n+    // Unfortunately we cannot just use the `ty::item_path` infrastructure here\n+    // because we need paths to modules and the DefIds of those are not\n+    // available anymore for external items.\n+    let mut cgu_name = String::with_capacity(64);\n+\n     let def_path = tcx.def_path(def_id);\n+    cgu_name.push_str(&tcx.crate_name(def_path.krate).as_str());\n+\n+    for part in tcx.def_path(def_id)\n+                   .data\n+                   .iter()\n+                   .take_while(|part| {\n+                        match part.data {\n+                            DefPathData::Module(..) => true,\n+                            _ => false,\n+                        }\n+                    }) {\n+        cgu_name.push_str(\"-\");\n+        cgu_name.push_str(&part.data.as_interned_str().as_str());\n+    }\n \n-    let components = def_path.data.iter().take_while(|part| {\n-        match part.data {\n-            DefPathData::Module(..) => true,\n-            _ => false,\n-        }\n-    }).map(|part| part.data.as_interned_str());\n+    if volatile {\n+        cgu_name.push_str(\".volatile\");\n+    }\n \n-    let volatile_suffix = if volatile {\n-        Some(\"volatile\")\n+    let cgu_name = if tcx.sess.opts.debugging_opts.human_readable_cgu_names {\n+        cgu_name\n     } else {\n-        None\n+        CodegenUnit::mangle_name(&cgu_name)\n     };\n \n-    CodegenUnit::build_cgu_name(tcx, def_path.krate, components, volatile_suffix)\n+    Symbol::intern(&cgu_name[..]).as_interned_str()\n }\n \n-fn numbered_codegen_unit_name(tcx: TyCtxt, index: usize) -> InternedString {\n-    CodegenUnit::build_cgu_name_no_mangle(tcx, LOCAL_CRATE, &[\"cgu\"], Some(index))\n+fn numbered_codegen_unit_name(crate_name: &str, index: usize) -> InternedString {\n+    Symbol::intern(&format!(\"{}{}\", crate_name, index)).as_interned_str()\n }\n \n fn debug_dump<'a, 'b, 'tcx, I>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "a00ff3b345d116e4c0127fde7c4d3f07f15ea6ab", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -1099,30 +1099,6 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n   return true;\n }\n \n-extern \"C\" typedef void (*LLVMRustModuleNameCallback)(void*, // payload\n-                                                      const char*, // importing module name\n-                                                      const char*); // imported module name\n-\n-// Calls `module_name_callback` for each module import done by ThinLTO.\n-// The callback is provided with regular null-terminated C strings.\n-extern \"C\" void\n-LLVMRustGetThinLTOModuleImports(const LLVMRustThinLTOData *data,\n-                                LLVMRustModuleNameCallback module_name_callback,\n-                                void* callback_payload) {\n-  for (const auto& importing_module : data->ImportLists) {\n-    const std::string importing_module_id = importing_module.getKey().str();\n-\n-    const auto& imports = importing_module.getValue();\n-\n-    for (const auto& imported_module : imports) {\n-      const std::string imported_module_id = imported_module.getKey().str();\n-      module_name_callback(callback_payload,\n-                           importing_module_id.c_str(),\n-                           imported_module_id.c_str());\n-    }\n-  }\n-}\n-\n // This struct and various functions are sort of a hack right now, but the\n // problem is that we've got in-memory LLVM modules after we generate and\n // optimize all codegen-units for one compilation in rustc. To be compatible\n@@ -1304,11 +1280,6 @@ LLVMRustPrepareThinLTOImport(const LLVMRustThinLTOData *Data, LLVMModuleRef M) {\n   report_fatal_error(\"ThinLTO not available\");\n }\n \n-extern \"C\" LLVMRustThinLTOModuleImports\n-LLVMRustGetLLVMRustThinLTOModuleImports(const LLVMRustThinLTOData *Data) {\n-  report_fatal_error(\"ThinLTO not available\");\n-}\n-\n extern \"C\" void\n LLVMRustFreeThinLTOData(LLVMRustThinLTOData *Data) {\n   report_fatal_error(\"ThinLTO not available\");"}, {"sha": "49e4b8d43c19c9131c4560e63710f9dbcf9266a6", "filename": "src/test/codegen-units/item-collection/drop_in_place_intrinsic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fdrop_in_place_intrinsic.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -14,7 +14,7 @@\n \n #![feature(start)]\n \n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<drop_in_place_intrinsic::StructWithDtor[0]> @@ drop_in_place_intrinsic0[Internal]\n struct StructWithDtor(u32);\n \n impl Drop for StructWithDtor {\n@@ -26,7 +26,7 @@ impl Drop for StructWithDtor {\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]; 2]> @@ drop_in_place_intrinsic0[Internal]\n     let x = [StructWithDtor(0), StructWithDtor(1)];\n \n     drop_slice_in_place(&x);\n@@ -40,7 +40,7 @@ fn drop_slice_in_place(x: &[StructWithDtor]) {\n         // This is the interesting thing in this test case: Normally we would\n         // not have drop-glue for the unsized [StructWithDtor]. This has to be\n         // generated though when the drop_in_place() intrinsic is used.\n-        //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic-cgu.0[Internal]\n+        //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<[drop_in_place_intrinsic::StructWithDtor[0]]> @@ drop_in_place_intrinsic0[Internal]\n         ::std::ptr::drop_in_place(x as *const _ as *mut [StructWithDtor]);\n     }\n }"}, {"sha": "aad32d1eb7c0646493e6513d5042aaad6d2bb87a", "filename": "src/test/codegen-units/item-collection/generic-drop-glue.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fgeneric-drop-glue.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -47,7 +47,7 @@ enum EnumNoDrop<T1, T2> {\n struct NonGenericNoDrop(i32);\n \n struct NonGenericWithDrop(i32);\n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::NonGenericWithDrop[0]> @@ generic_drop_glue0[Internal]\n \n impl Drop for NonGenericWithDrop {\n     //~ MONO_ITEM fn generic_drop_glue::{{impl}}[2]::drop[0]\n@@ -57,11 +57,11 @@ impl Drop for NonGenericWithDrop {\n //~ MONO_ITEM fn generic_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<i8, char>> @@ generic_drop_glue0[Internal]\n     //~ MONO_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<i8, char>\n     let _ = StructWithDrop { x: 0i8, y: 'a' }.x;\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructWithDrop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>> @@ generic_drop_glue0[Internal]\n     //~ MONO_ITEM fn generic_drop_glue::{{impl}}[0]::drop[0]<&str, generic_drop_glue::NonGenericNoDrop[0]>\n     let _ = StructWithDrop { x: \"&str\", y: NonGenericNoDrop(0) }.y;\n \n@@ -70,17 +70,17 @@ fn start(_: isize, _: *const *const u8) -> isize {\n \n     // This is supposed to generate drop-glue because it contains a field that\n     // needs to be dropped.\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::StructNoDrop[0]<generic_drop_glue::NonGenericWithDrop[0], f64>> @@ generic_drop_glue0[Internal]\n     let _ = StructNoDrop { x: NonGenericWithDrop(0), y: 0f64 }.y;\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<i32, i64>> @@ generic_drop_glue0[Internal]\n     //~ MONO_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<i32, i64>\n     let _ = match EnumWithDrop::A::<i32, i64>(0) {\n         EnumWithDrop::A(x) => x,\n         EnumWithDrop::B(x) => x as i32\n     };\n \n-    //~MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue-cgu.0[Internal]\n+    //~MONO_ITEM fn core::ptr[0]::drop_in_place[0]<generic_drop_glue::EnumWithDrop[0]<f64, f32>> @@ generic_drop_glue0[Internal]\n     //~ MONO_ITEM fn generic_drop_glue::{{impl}}[1]::drop[0]<f64, f32>\n     let _ = match EnumWithDrop::B::<f64, f32>(1.0) {\n         EnumWithDrop::A(x) => x,"}, {"sha": "5c6201da252bee22bc49265a4787b26c1dfa355d", "filename": "src/test/codegen-units/item-collection/instantiation-through-vtable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Finstantiation-through-vtable.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -34,13 +34,13 @@ impl<T> Trait for Struct<T> {\n fn start(_: isize, _: *const *const u8) -> isize {\n     let s1 = Struct { _a: 0u32 };\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u32>> @@ instantiation_through_vtable0[Internal]\n     //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u32>\n     //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u32>\n     let _ = &s1 as &Trait;\n \n     let s1 = Struct { _a: 0u64 };\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<instantiation_through_vtable::Struct[0]<u64>> @@ instantiation_through_vtable0[Internal]\n     //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::foo[0]<u64>\n     //~ MONO_ITEM fn instantiation_through_vtable::{{impl}}[0]::bar[0]<u64>\n     let _ = &s1 as &Trait;"}, {"sha": "6ca24aa5b4b89da9fd84b79b49582373b128ed13", "filename": "src/test/codegen-units/item-collection/non-generic-drop-glue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Fnon-generic-drop-glue.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -15,7 +15,7 @@\n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::StructWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n struct StructWithDrop {\n     x: i32\n }\n@@ -29,7 +29,7 @@ struct StructNoDrop {\n     x: i32\n }\n \n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<non_generic_drop_glue::EnumWithDrop[0]> @@ non_generic_drop_glue0[Internal]\n enum EnumWithDrop {\n     A(i32)\n }"}, {"sha": "d20213c109bdb3d18664fef978b95b6fcc52d32e", "filename": "src/test/codegen-units/item-collection/transitive-drop-glue.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftransitive-drop-glue.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -15,11 +15,11 @@\n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Root[0]> @@ transitive_drop_glue0[Internal]\n struct Root(Intermediate);\n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Intermediate[0]> @@ transitive_drop_glue0[Internal]\n struct Intermediate(Leaf);\n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::Leaf[0]> @@ transitive_drop_glue0[Internal]\n struct Leaf;\n \n impl Drop for Leaf {\n@@ -40,15 +40,15 @@ impl<T> Drop for LeafGen<T> {\n fn start(_: isize, _: *const *const u8) -> isize {\n     let _ = Root(Intermediate(Leaf));\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue-cgu.0[Internal]\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue-cgu.0[Internal]\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<u32>> @@ transitive_drop_glue0[Internal]\n     //~ MONO_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<u32>\n     let _ = RootGen(IntermediateGen(LeafGen(0u32)));\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue-cgu.0[Internal]\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue-cgu.0[Internal]\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::RootGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::IntermediateGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<transitive_drop_glue::LeafGen[0]<i16>> @@ transitive_drop_glue0[Internal]\n     //~ MONO_ITEM fn transitive_drop_glue::{{impl}}[1]::drop[0]<i16>\n     let _ = RootGen(IntermediateGen(LeafGen(0i16)));\n "}, {"sha": "9e4cc6ea6f08ebd51b72a3fd9494b3b9307929bc", "filename": "src/test/codegen-units/item-collection/tuple-drop-glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Ftuple-drop-glue.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -15,7 +15,7 @@\n #![deny(dead_code)]\n #![feature(start)]\n \n-//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue-cgu.0[Internal]\n+//~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<tuple_drop_glue::Dropped[0]> @@ tuple_drop_glue0[Internal]\n struct Dropped;\n \n impl Drop for Dropped {\n@@ -26,11 +26,11 @@ impl Drop for Dropped {\n //~ MONO_ITEM fn tuple_drop_glue::start[0]\n #[start]\n fn start(_: isize, _: *const *const u8) -> isize {\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(u32, tuple_drop_glue::Dropped[0])> @@ tuple_drop_glue0[Internal]\n     let x = (0u32, Dropped);\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue-cgu.0[Internal]\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(i16, (tuple_drop_glue::Dropped[0], bool))> @@ tuple_drop_glue0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<(tuple_drop_glue::Dropped[0], bool)> @@ tuple_drop_glue0[Internal]\n     let x = (0i16, (Dropped, true));\n \n     0"}, {"sha": "adc0eb6c709152f206b64fe3709ac5fba7b74360", "filename": "src/test/codegen-units/item-collection/unsizing.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen-units%2Fitem-collection%2Funsizing.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -59,13 +59,13 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Wrapper<U>> for Wrapper<T>\n fn start(_: isize, _: *const *const u8) -> isize {\n     // simple case\n     let bool_sized = &true;\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<bool> @@ unsizing0[Internal]\n     //~ MONO_ITEM fn unsizing::{{impl}}[0]::foo[0]\n     let _bool_unsized = bool_sized as &Trait;\n \n     let char_sized = &'a';\n \n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<char> @@ unsizing0[Internal]\n     //~ MONO_ITEM fn unsizing::{{impl}}[1]::foo[0]\n     let _char_unsized = char_sized as &Trait;\n \n@@ -75,13 +75,13 @@ fn start(_: isize, _: *const *const u8) -> isize {\n         _b: 2,\n         _c: 3.0f64\n     };\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<f64> @@ unsizing0[Internal]\n     //~ MONO_ITEM fn unsizing::{{impl}}[2]::foo[0]\n     let _struct_unsized = struct_sized as &Struct<Trait>;\n \n     // custom coercion\n     let wrapper_sized = Wrapper(&0u32);\n-    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing-cgu.0[Internal]\n+    //~ MONO_ITEM fn core::ptr[0]::drop_in_place[0]<u32> @@ unsizing0[Internal]\n     //~ MONO_ITEM fn unsizing::{{impl}}[3]::foo[0]\n     let _wrapper_sized = wrapper_sized as Wrapper<Trait>;\n "}, {"sha": "a562eab1768f3d163358aed9d1a44d6d8849bdca", "filename": "src/test/incremental/issue-39828/auxiliary/generic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fissue-39828%2Fauxiliary%2Fgeneric.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -11,7 +11,7 @@\n // revisions:rpass1 rpass2\n // compile-flags: -Z query-dep-graph\n \n-#![rustc_partition_reused(module=\"generic-fallback.cgu\", cfg=\"rpass2\")]\n+#![rustc_partition_reused(module=\"__rustc_fallback_codegen_unit\", cfg=\"rpass2\")]\n #![feature(rustc_attrs)]\n \n #![crate_type=\"rlib\"]"}, {"sha": "efe1b7072ffb8f75a3d5460a67e100c6854af46a", "filename": "src/test/run-make-fulldeps/cross-lang-lto/Makefile", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcross-lang-lto%2FMakefile?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -17,22 +17,22 @@ all: staticlib staticlib-fat-lto staticlib-thin-lto rlib exe cdylib rdylib\n staticlib: lib.rs\n \t$(BUILD_LIB) --crate-type=staticlib -o $(TMPDIR)/liblib.a\n \t$(call EXTRACT_OBJS, liblib.a)\n-\tfor file in $(TMPDIR)/liblib.*.rcgu.o; do $(ASSERT_IS_BITCODE_OBJ) $$file; done\n+\t$(ASSERT_IS_BITCODE_OBJ) $(TMPDIR)/liblib.lib0.rcgu.o\n \n staticlib-fat-lto: lib.rs\n \t$(BUILD_LIB) --crate-type=staticlib -o $(TMPDIR)/liblib-fat-lto.a -Clto=fat\n \t$(call EXTRACT_OBJS, liblib-fat-lto.a)\n-\tfor file in $(TMPDIR)/liblib-fat-lto.*.rcgu.o; do $(ASSERT_IS_BITCODE_OBJ) $$file; done\n+\t$(ASSERT_IS_BITCODE_OBJ) $(TMPDIR)/liblib-fat-lto.lib0.rcgu.o\n \n staticlib-thin-lto: lib.rs\n \t$(BUILD_LIB) --crate-type=staticlib -o $(TMPDIR)/liblib-thin-lto.a -Clto=thin\n \t$(call EXTRACT_OBJS, liblib-thin-lto.a)\n-\tfor file in $(TMPDIR)/liblib-thin-lto.*.rcgu.o; do $(ASSERT_IS_BITCODE_OBJ) $$file; done\n+\t$(ASSERT_IS_BITCODE_OBJ) $(TMPDIR)/liblib-thin-lto.lib0.rcgu.o\n \n rlib: lib.rs\n \t$(BUILD_LIB) --crate-type=rlib -o $(TMPDIR)/liblib.rlib\n \t$(call EXTRACT_OBJS, liblib.rlib)\n-\tfor file in $(TMPDIR)/liblib.*.rcgu.o; do $(ASSERT_IS_BITCODE_OBJ) $$file; done\n+\t$(ASSERT_IS_BITCODE_OBJ) $(TMPDIR)/liblib.lib0.rcgu.o\n \n cdylib: lib.rs\n \t$(BUILD_LIB) --crate-type=cdylib --emit=obj -o $(TMPDIR)/cdylib.o"}, {"sha": "6de4f97df0c16bf6df2b83c8fec542a2e8198910", "filename": "src/test/run-make-fulldeps/extra-filename-with-temp-outputs/Makefile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Frun-make-fulldeps%2Fextra-filename-with-temp-outputs%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftest%2Frun-make-fulldeps%2Fextra-filename-with-temp-outputs%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fextra-filename-with-temp-outputs%2FMakefile?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -2,5 +2,5 @@\n \n all:\n \t$(RUSTC) -C extra-filename=bar foo.rs -C save-temps\n-\trm $(TMPDIR)/foobar.foo*0.rcgu.o\n+\trm $(TMPDIR)/foobar.foo0.rcgu.o\n \trm $(TMPDIR)/$(call BIN,foobar)"}, {"sha": "59ddc16715d3b6e52ad8264e894a84e2f5bdeb08", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 5, "deletions": 28, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d5753fda1ee8f729da1061e931e13b043f479a5/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=3d5753fda1ee8f729da1061e931e13b043f479a5", "patch": "@@ -2209,12 +2209,12 @@ impl<'test> TestCx<'test> {\n             .stdout\n             .lines()\n             .filter(|line| line.starts_with(PREFIX))\n-            .map(|line| str_to_mono_item(line, true))\n+            .map(str_to_mono_item)\n             .collect();\n \n         let expected: Vec<MonoItem> = errors::load_errors(&self.testpaths.file, None)\n             .iter()\n-            .map(|e| str_to_mono_item(&e.msg[..], false))\n+            .map(|e| str_to_mono_item(&e.msg[..]))\n             .collect();\n \n         let mut missing = Vec::new();\n@@ -2299,14 +2299,14 @@ impl<'test> TestCx<'test> {\n         }\n \n         // [MONO_ITEM] name [@@ (cgu)+]\n-        fn str_to_mono_item(s: &str, cgu_has_crate_disambiguator: bool) -> MonoItem {\n+        fn str_to_mono_item(s: &str) -> MonoItem {\n             let s = if s.starts_with(PREFIX) {\n                 (&s[PREFIX.len()..]).trim()\n             } else {\n                 s.trim()\n             };\n \n-            let full_string = format!(\"{}{}\", PREFIX, s);\n+            let full_string = format!(\"{}{}\", PREFIX, s.trim().to_owned());\n \n             let parts: Vec<&str> = s\n                 .split(CGU_MARKER)\n@@ -2323,13 +2323,7 @@ impl<'test> TestCx<'test> {\n                     .split(' ')\n                     .map(str::trim)\n                     .filter(|s| !s.is_empty())\n-                    .map(|s| {\n-                        if cgu_has_crate_disambiguator {\n-                            remove_crate_disambiguator_from_cgu(s)\n-                        } else {\n-                            s.to_string()\n-                        }\n-                    })\n+                    .map(str::to_owned)\n                     .collect()\n             } else {\n                 HashSet::new()\n@@ -2354,23 +2348,6 @@ impl<'test> TestCx<'test> {\n \n             string\n         }\n-\n-        fn remove_crate_disambiguator_from_cgu(cgu: &str) -> String {\n-            // The first '.' is the start of the crate disambiguator\n-            let disambiguator_start = cgu.find('.')\n-                .expect(\"Could not find start of crate disambiguator in CGU spec\");\n-\n-            // The first non-alphanumeric character is the end of the disambiguator\n-            let disambiguator_end = cgu[disambiguator_start + 1 ..]\n-                .find(|c| !char::is_alphanumeric(c))\n-                .expect(\"Could not find end of crate disambiguator in CGU spec\")\n-                + disambiguator_start + 1;\n-\n-            let mut result = cgu[0 .. disambiguator_start].to_string();\n-            result.push_str(&cgu[disambiguator_end ..]);\n-\n-            result\n-        }\n     }\n \n     fn init_incremental_test(&self) {"}]}