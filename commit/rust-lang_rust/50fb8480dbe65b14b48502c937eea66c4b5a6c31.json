{"sha": "50fb8480dbe65b14b48502c937eea66c4b5a6c31", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwZmI4NDgwZGJlNjViMTRiNDg1MDJjOTM3ZWVhNjZjNGI1YTZjMzE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-31T18:19:36Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-31T18:19:36Z"}, "message": "Rollup merge of #67730 - Centril:typeck-pat-cleanup, r=estebank\n\nCleanup pattern type checking, fix diagnostics bugs (+ improvements)\n\nr? @estebank", "tree": {"sha": "d05faa6e61945514bcf1b774018015ab56479808", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d05faa6e61945514bcf1b774018015ab56479808"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50fb8480dbe65b14b48502c937eea66c4b5a6c31", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeC5E4CRBK7hj4Ov3rIwAAdHIIAA7cfjdmNCZfsVz1J3nFWYul\nHEZpJry0y8zWFTaE6QScTb1hTmyJx+pchQRaAtefCznBoqghN4vYg1ZudfPJ7trW\n1uHqveicH6thgKKO7afvvLg/LuLdkZe6B/5+nzKHKIvxWtj/+wNenfca4toBrQmW\noubIk69oHLoTuD73AMDNTqcQPh7EwsMwNl2CVGBXk1PrhreYOzI369/+iIkNeN0a\nX4Qn6lIoRRNUtNsOCuuxWt+GVq7bnx6esOCc69QVdM1xUOttBx36n7n4t0qBWMVH\nZkvo191pKei3Sq3zZEBlJivPQRtXoT/0E6PfcXoQhatX/aybWrd6xziYKThnb9I=\n=gqTW\n-----END PGP SIGNATURE-----\n", "payload": "tree d05faa6e61945514bcf1b774018015ab56479808\nparent bc5963d2eb1f64b32dd82014cbc8c6082e463322\nparent 63dc0e41dbf6d939741238a7c71bf5a63ae3ce55\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1577816376 +0100\ncommitter GitHub <noreply@github.com> 1577816376 +0100\n\nRollup merge of #67730 - Centril:typeck-pat-cleanup, r=estebank\n\nCleanup pattern type checking, fix diagnostics bugs (+ improvements)\n\nr? @estebank\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50fb8480dbe65b14b48502c937eea66c4b5a6c31", "html_url": "https://github.com/rust-lang/rust/commit/50fb8480dbe65b14b48502c937eea66c4b5a6c31", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50fb8480dbe65b14b48502c937eea66c4b5a6c31/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc5963d2eb1f64b32dd82014cbc8c6082e463322", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc5963d2eb1f64b32dd82014cbc8c6082e463322", "html_url": "https://github.com/rust-lang/rust/commit/bc5963d2eb1f64b32dd82014cbc8c6082e463322"}, {"sha": "63dc0e41dbf6d939741238a7c71bf5a63ae3ce55", "url": "https://api.github.com/repos/rust-lang/rust/commits/63dc0e41dbf6d939741238a7c71bf5a63ae3ce55", "html_url": "https://github.com/rust-lang/rust/commit/63dc0e41dbf6d939741238a7c71bf5a63ae3ce55"}], "stats": {"total": 662, "additions": 418, "deletions": 244}, "files": [{"sha": "b3a79c0883358895c38b36484d36d500bad2a7d0", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -581,10 +581,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         exp_found: Option<ty::error::ExpectedFound<Ty<'tcx>>>,\n     ) {\n         match cause.code {\n-            ObligationCauseCode::MatchExpressionArmPattern { span, ty } => {\n+            ObligationCauseCode::Pattern { origin_expr: true, span: Some(span), root_ty } => {\n+                let ty = self.resolve_vars_if_possible(&root_ty);\n                 if ty.is_suggestable() {\n                     // don't show type `_`\n-                    err.span_label(span, format!(\"this match expression has type `{}`\", ty));\n+                    err.span_label(span, format!(\"this expression has type `{}`\", ty));\n                 }\n                 if let Some(ty::error::ExpectedFound { found, .. }) = exp_found {\n                     if ty.is_box() && ty.boxed_ty() == found {\n@@ -599,11 +600,14 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     }\n                 }\n             }\n+            ObligationCauseCode::Pattern { origin_expr: false, span: Some(span), .. } => {\n+                err.span_label(span, \"expected due to this\");\n+            }\n             ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n-                discrim_hir_id,\n+                scrut_hir_id,\n                 ..\n             }) => match source {\n                 hir::MatchSource::IfLetDesugar { .. } => {\n@@ -612,16 +616,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 }\n                 hir::MatchSource::TryDesugar => {\n                     if let Some(ty::error::ExpectedFound { expected, .. }) = exp_found {\n-                        let discrim_expr = self.tcx.hir().expect_expr(discrim_hir_id);\n-                        let discrim_ty = if let hir::ExprKind::Call(_, args) = &discrim_expr.kind {\n+                        let scrut_expr = self.tcx.hir().expect_expr(scrut_hir_id);\n+                        let scrut_ty = if let hir::ExprKind::Call(_, args) = &scrut_expr.kind {\n                             let arg_expr = args.first().expect(\"try desugaring call w/out arg\");\n                             self.in_progress_tables\n                                 .and_then(|tables| tables.borrow().expr_ty_opt(arg_expr))\n                         } else {\n-                            bug!(\"try desugaring w/out call expr as discriminant\");\n+                            bug!(\"try desugaring w/out call expr as scrutinee\");\n                         };\n \n-                        match discrim_ty {\n+                        match scrut_ty {\n                             Some(ty) if expected == ty => {\n                                 let source_map = self.tcx.sess.source_map();\n                                 err.span_suggestion("}, {"sha": "5819e7aa5c25dc8391c59d4aca708632ba8ce89c", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2580,7 +2580,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         match *cause_code {\n             ObligationCauseCode::ExprAssignable\n             | ObligationCauseCode::MatchExpressionArm { .. }\n-            | ObligationCauseCode::MatchExpressionArmPattern { .. }\n+            | ObligationCauseCode::Pattern { .. }\n             | ObligationCauseCode::IfExpression { .. }\n             | ObligationCauseCode::IfExpressionWithNoElse\n             | ObligationCauseCode::MainFunctionType"}, {"sha": "fe373e02e10f368cbdfb96a3df20b391f60e6b30", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -249,10 +249,14 @@ pub enum ObligationCauseCode<'tcx> {\n     /// Computing common supertype in the arms of a match expression\n     MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n \n-    /// Computing common supertype in the pattern guard for the arms of a match expression\n-    MatchExpressionArmPattern {\n-        span: Span,\n-        ty: Ty<'tcx>,\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n     },\n \n     /// Constants in patterns must have `Structural` type.\n@@ -311,7 +315,7 @@ pub struct MatchExpressionArmCause<'tcx> {\n     pub source: hir::MatchSource,\n     pub prior_arms: Vec<Span>,\n     pub last_ty: Ty<'tcx>,\n-    pub discrim_hir_id: hir::HirId,\n+    pub scrut_hir_id: hir::HirId,\n }\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]"}, {"sha": "c439f20d640024d4784c1ec58b6ba85470ea643a", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -511,18 +511,18 @@ impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n                 source,\n                 ref prior_arms,\n                 last_ty,\n-                discrim_hir_id,\n+                scrut_hir_id,\n             }) => tcx.lift(&last_ty).map(|last_ty| {\n                 super::MatchExpressionArm(box super::MatchExpressionArmCause {\n                     arm_span,\n                     source,\n                     prior_arms: prior_arms.clone(),\n                     last_ty,\n-                    discrim_hir_id,\n+                    scrut_hir_id,\n                 })\n             }),\n-            super::MatchExpressionArmPattern { span, ty } => {\n-                tcx.lift(&ty).map(|ty| super::MatchExpressionArmPattern { span, ty })\n+            super::Pattern { span, root_ty, origin_expr } => {\n+                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n             }\n             super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n                 Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))"}, {"sha": "841dd226b40583166b06679d04abb21459c68a21", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -11,7 +11,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub fn check_match(\n         &self,\n         expr: &'tcx hir::Expr<'tcx>,\n-        discrim: &'tcx hir::Expr<'tcx>,\n+        scrut: &'tcx hir::Expr<'tcx>,\n         arms: &'tcx [hir::Arm<'tcx>],\n         expected: Expectation<'tcx>,\n         match_src: hir::MatchSource,\n@@ -27,7 +27,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         };\n \n         // Type check the descriminant and get its type.\n-        let discrim_ty = if force_scrutinee_bool {\n+        let scrut_ty = if force_scrutinee_bool {\n             // Here we want to ensure:\n             //\n             // 1. That default match bindings are *not* accepted in the condition of an\n@@ -36,9 +36,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // 2. By expecting `bool` for `expr` we get nice diagnostics for e.g. `if x = y { .. }`.\n             //\n             // FIXME(60707): Consider removing hack with principled solution.\n-            self.check_expr_has_type_or_error(discrim, self.tcx.types.bool, |_| {})\n+            self.check_expr_has_type_or_error(scrut, self.tcx.types.bool, |_| {})\n         } else {\n-            self.demand_discriminant_type(arms, discrim)\n+            self.demand_scrutinee_type(arms, scrut)\n         };\n \n         // If there are no arms, that is a diverging match; a special case.\n@@ -51,7 +51,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Otherwise, we have to union together the types that the\n         // arms produce and so forth.\n-        let discrim_diverges = self.diverges.get();\n+        let scrut_diverges = self.diverges.get();\n         self.diverges.set(Diverges::Maybe);\n \n         // rust-lang/rust#55810: Typecheck patterns first (via eager\n@@ -61,7 +61,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .map(|arm| {\n                 let mut all_pats_diverge = Diverges::WarnedAlways;\n                 self.diverges.set(Diverges::Maybe);\n-                self.check_pat_top(&arm.pat, discrim_ty, Some(discrim.span));\n+                self.check_pat_top(&arm.pat, scrut_ty, Some(scrut.span), true);\n                 all_pats_diverge &= self.diverges.get();\n \n                 // As discussed with @eddyb, this is for disabling unreachable_code\n@@ -157,7 +157,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             source: match_src,\n                             prior_arms: other_arms.clone(),\n                             last_ty: prior_arm_ty.unwrap(),\n-                            discrim_hir_id: discrim.hir_id,\n+                            scrut_hir_id: scrut.hir_id,\n                         }),\n                     ),\n                 };\n@@ -186,8 +186,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n         }\n \n-        // We won't diverge unless the discriminant or all arms diverge.\n-        self.diverges.set(discrim_diverges | all_arms_diverge);\n+        // We won't diverge unless the scrutinee or all arms diverge.\n+        self.diverges.set(scrut_diverges | all_arms_diverge);\n \n         coercion.complete(self)\n     }\n@@ -388,14 +388,14 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         )\n     }\n \n-    fn demand_discriminant_type(\n+    fn demand_scrutinee_type(\n         &self,\n         arms: &'tcx [hir::Arm<'tcx>],\n-        discrim: &'tcx hir::Expr<'tcx>,\n+        scrut: &'tcx hir::Expr<'tcx>,\n     ) -> Ty<'tcx> {\n         // Not entirely obvious: if matches may create ref bindings, we want to\n-        // use the *precise* type of the discriminant, *not* some supertype, as\n-        // the \"discriminant type\" (issue #23116).\n+        // use the *precise* type of the scrutinee, *not* some supertype, as\n+        // the \"scrutinee type\" (issue #23116).\n         //\n         // arielb1 [writes here in this comment thread][c] that there\n         // is certainly *some* potential danger, e.g., for an example\n@@ -454,17 +454,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             });\n \n         if let Some(m) = contains_ref_bindings {\n-            self.check_expr_with_needs(discrim, Needs::maybe_mut_place(m))\n+            self.check_expr_with_needs(scrut, Needs::maybe_mut_place(m))\n         } else {\n             // ...but otherwise we want to use any supertype of the\n-            // discriminant. This is sort of a workaround, see note (*) in\n+            // scrutinee. This is sort of a workaround, see note (*) in\n             // `check_pat` for some details.\n-            let discrim_ty = self.next_ty_var(TypeVariableOrigin {\n+            let scrut_ty = self.next_ty_var(TypeVariableOrigin {\n                 kind: TypeVariableOriginKind::TypeInference,\n-                span: discrim.span,\n+                span: scrut.span,\n             });\n-            self.check_expr_has_type_or_error(discrim, discrim_ty, |_| {});\n-            discrim_ty\n+            self.check_expr_has_type_or_error(scrut, scrut_ty, |_| {});\n+            scrut_ty\n         }\n     }\n }"}, {"sha": "48403687aabdc23c9351f30b607ba86d5df291f2", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 30, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -1,6 +1,6 @@\n use crate::check::FnCtxt;\n use rustc::infer::InferOk;\n-use rustc::traits::{self, ObligationCause, ObligationCauseCode};\n+use rustc::traits::{self, ObligationCause};\n \n use errors::{Applicability, DiagnosticBuilder};\n use rustc::hir::{self, is_range_literal, print, Node};\n@@ -79,35 +79,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    pub fn demand_eqtype_pat_diag(\n-        &self,\n-        cause_span: Span,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n-    ) -> Option<DiagnosticBuilder<'tcx>> {\n-        let cause = if let Some(span) = match_expr_span {\n-            self.cause(\n-                cause_span,\n-                ObligationCauseCode::MatchExpressionArmPattern { span, ty: expected },\n-            )\n-        } else {\n-            self.misc(cause_span)\n-        };\n-        self.demand_eqtype_with_origin(&cause, expected, actual)\n-    }\n-\n-    pub fn demand_eqtype_pat(\n-        &self,\n-        cause_span: Span,\n-        expected: Ty<'tcx>,\n-        actual: Ty<'tcx>,\n-        match_expr_span: Option<Span>,\n-    ) {\n-        self.demand_eqtype_pat_diag(cause_span, expected, actual, match_expr_span)\n-            .map(|mut err| err.emit());\n-    }\n-\n     pub fn demand_coerce(\n         &self,\n         expr: &hir::Expr<'_>,"}, {"sha": "042c2fbd13a62e094a1e9f2a89d8c2c796f20f91", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 59, "deletions": 44, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -1268,13 +1268,17 @@ fn check_fn<'a, 'tcx>(\n     let mut fcx = FnCtxt::new(inherited, param_env, body.value.hir_id);\n     *fcx.ps.borrow_mut() = UnsafetyState::function(fn_sig.unsafety, fn_id);\n \n+    let tcx = fcx.tcx;\n+    let sess = tcx.sess;\n+    let hir = tcx.hir();\n+\n     let declared_ret_ty = fn_sig.output();\n     fcx.require_type_is_sized(declared_ret_ty, decl.output.span(), traits::SizedReturnType);\n     let revealed_ret_ty =\n         fcx.instantiate_opaque_types_from_value(fn_id, &declared_ret_ty, decl.output.span());\n     debug!(\"check_fn: declared_ret_ty: {}, revealed_ret_ty: {}\", declared_ret_ty, revealed_ret_ty);\n     fcx.ret_coercion = Some(RefCell::new(CoerceMany::new(revealed_ret_ty)));\n-    fn_sig = fcx.tcx.mk_fn_sig(\n+    fn_sig = tcx.mk_fn_sig(\n         fn_sig.inputs().iter().cloned(),\n         revealed_ret_ty,\n         fn_sig.c_variadic,\n@@ -1284,7 +1288,7 @@ fn check_fn<'a, 'tcx>(\n \n     let span = body.value.span;\n \n-    fn_maybe_err(fcx.tcx, span, fn_sig.abi);\n+    fn_maybe_err(tcx, span, fn_sig.abi);\n \n     if body.generator_kind.is_some() && can_be_generator.is_some() {\n         let yield_ty = fcx\n@@ -1293,37 +1297,39 @@ fn check_fn<'a, 'tcx>(\n         fcx.yield_ty = Some(yield_ty);\n     }\n \n-    let outer_def_id = fcx.tcx.closure_base_def_id(fcx.tcx.hir().local_def_id(fn_id));\n-    let outer_hir_id = fcx.tcx.hir().as_local_hir_id(outer_def_id).unwrap();\n+    let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id));\n+    let outer_hir_id = hir.as_local_hir_id(outer_def_id).unwrap();\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n     // (as it's created inside the body itself, not passed in from outside).\n     let maybe_va_list = if fn_sig.c_variadic {\n-        let va_list_did = fcx.tcx.require_lang_item(\n+        let va_list_did = tcx.require_lang_item(\n             lang_items::VaListTypeLangItem,\n             Some(body.params.last().unwrap().span),\n         );\n-        let region = fcx.tcx.mk_region(ty::ReScope(region::Scope {\n+        let region = tcx.mk_region(ty::ReScope(region::Scope {\n             id: body.value.hir_id.local_id,\n             data: region::ScopeData::CallSite,\n         }));\n \n-        Some(fcx.tcx.type_of(va_list_did).subst(fcx.tcx, &[region.into()]))\n+        Some(tcx.type_of(va_list_did).subst(tcx, &[region.into()]))\n     } else {\n         None\n     };\n \n     // Add formal parameters.\n-    for (param_ty, param) in fn_sig.inputs().iter().copied().chain(maybe_va_list).zip(body.params) {\n+    let inputs_hir = hir.fn_decl_by_hir_id(fn_id).map(|decl| &decl.inputs);\n+    let inputs_fn = fn_sig.inputs().iter().copied();\n+    for (idx, (param_ty, param)) in inputs_fn.chain(maybe_va_list).zip(body.params).enumerate() {\n         // Check the pattern.\n-        fcx.check_pat_top(&param.pat, param_ty, None);\n+        fcx.check_pat_top(&param.pat, param_ty, try { inputs_hir?.get(idx)?.span }, false);\n \n         // Check that argument is Sized.\n         // The check for a non-trivial pattern is a hack to avoid duplicate warnings\n         // for simple cases like `fn foo(x: Trait)`,\n         // where we would error once on the parameter as a whole, and once on the binding `x`.\n-        if param.pat.simple_ident().is_none() && !fcx.tcx.features().unsized_locals {\n+        if param.pat.simple_ident().is_none() && !tcx.features().unsized_locals {\n             fcx.require_type_is_sized(param_ty, decl.output.span(), traits::SizedArgumentType);\n         }\n \n@@ -1384,11 +1390,11 @@ fn check_fn<'a, 'tcx>(\n     fcx.demand_suptype(span, revealed_ret_ty, actual_return_ty);\n \n     // Check that the main return type implements the termination trait.\n-    if let Some(term_id) = fcx.tcx.lang_items().termination() {\n-        if let Some((def_id, EntryFnType::Main)) = fcx.tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = fcx.tcx.hir().as_local_hir_id(def_id).unwrap();\n+    if let Some(term_id) = tcx.lang_items().termination() {\n+        if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n+            let main_id = hir.as_local_hir_id(def_id).unwrap();\n             if main_id == fn_id {\n-                let substs = fcx.tcx.mk_substs_trait(declared_ret_ty, &[]);\n+                let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n                 let return_ty_span = decl.output.span();\n                 let cause = traits::ObligationCause::new(\n@@ -1407,15 +1413,15 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     // Check that a function marked as `#[panic_handler]` has signature `fn(&PanicInfo) -> !`\n-    if let Some(panic_impl_did) = fcx.tcx.lang_items().panic_impl() {\n-        if panic_impl_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(panic_info_did) = fcx.tcx.lang_items().panic_info() {\n+    if let Some(panic_impl_did) = tcx.lang_items().panic_impl() {\n+        if panic_impl_did == hir.local_def_id(fn_id) {\n+            if let Some(panic_info_did) = tcx.lang_items().panic_info() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_panic_info = match inputs[0].kind {\n                         ty::Ref(region, ty, mutbl) => match ty.kind {\n@@ -1430,52 +1436,50 @@ fn check_fn<'a, 'tcx>(\n                     };\n \n                     if !arg_is_panic_info {\n-                        fcx.tcx\n-                            .sess\n-                            .span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `&PanicInfo`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(span, \"should have no type parameters\");\n+                                sess.span_err(span, \"should have no type parameters\");\n                             }\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `panic_info`\");\n+                sess.err(\"language item required, but not found: `panic_info`\");\n             }\n         }\n     }\n \n     // Check that a function marked as `#[alloc_error_handler]` has signature `fn(Layout) -> !`\n-    if let Some(alloc_error_handler_did) = fcx.tcx.lang_items().oom() {\n-        if alloc_error_handler_did == fcx.tcx.hir().local_def_id(fn_id) {\n-            if let Some(alloc_layout_did) = fcx.tcx.lang_items().alloc_layout() {\n+    if let Some(alloc_error_handler_did) = tcx.lang_items().oom() {\n+        if alloc_error_handler_did == hir.local_def_id(fn_id) {\n+            if let Some(alloc_layout_did) = tcx.lang_items().alloc_layout() {\n                 if declared_ret_ty.kind != ty::Never {\n-                    fcx.tcx.sess.span_err(decl.output.span(), \"return type should be `!`\");\n+                    sess.span_err(decl.output.span(), \"return type should be `!`\");\n                 }\n \n                 let inputs = fn_sig.inputs();\n-                let span = fcx.tcx.hir().span(fn_id);\n+                let span = hir.span(fn_id);\n                 if inputs.len() == 1 {\n                     let arg_is_alloc_layout = match inputs[0].kind {\n                         ty::Adt(ref adt, _) => adt.did == alloc_layout_did,\n                         _ => false,\n                     };\n \n                     if !arg_is_alloc_layout {\n-                        fcx.tcx.sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n+                        sess.span_err(decl.inputs[0].span, \"argument should be `Layout`\");\n                     }\n \n-                    if let Node::Item(item) = fcx.tcx.hir().get(fn_id) {\n+                    if let Node::Item(item) = hir.get(fn_id) {\n                         if let ItemKind::Fn(_, ref generics, _) = item.kind {\n                             if !generics.params.is_empty() {\n-                                fcx.tcx.sess.span_err(\n+                                sess.span_err(\n                                     span,\n                                     \"`#[alloc_error_handler]` function should have no type \\\n                                      parameters\",\n@@ -1484,11 +1488,11 @@ fn check_fn<'a, 'tcx>(\n                         }\n                     }\n                 } else {\n-                    let span = fcx.tcx.sess.source_map().def_span(span);\n-                    fcx.tcx.sess.span_err(span, \"function should have one argument\");\n+                    let span = sess.source_map().def_span(span);\n+                    sess.span_err(span, \"function should have one argument\");\n                 }\n             } else {\n-                fcx.tcx.sess.err(\"language item required, but not found: `alloc_layout`\");\n+                sess.err(\"language item required, but not found: `alloc_layout`\");\n             }\n         }\n     }\n@@ -4304,18 +4308,29 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Type check a `let` statement.\n     pub fn check_decl_local(&self, local: &'tcx hir::Local<'tcx>) {\n-        let t = self.local_ty(local.span, local.hir_id).decl_ty;\n-        self.write_ty(local.hir_id, t);\n+        // Determine and write the type which we'll check the pattern against.\n+        let ty = self.local_ty(local.span, local.hir_id).decl_ty;\n+        self.write_ty(local.hir_id, ty);\n \n+        // Type check the initializer.\n         if let Some(ref init) = local.init {\n             let init_ty = self.check_decl_initializer(local, &init);\n-            self.overwrite_local_ty_if_err(local, t, init_ty);\n+            self.overwrite_local_ty_if_err(local, ty, init_ty);\n         }\n \n-        self.check_pat_top(&local.pat, t, None);\n+        // Does the expected pattern type originate from an expression and what is the span?\n+        let (origin_expr, ty_span) = match (local.ty, local.init) {\n+            (Some(ty), _) => (false, Some(ty.span)), // Bias towards the explicit user type.\n+            (_, Some(init)) => (true, Some(init.span)), // No explicit type; so use the scrutinee.\n+            _ => (false, None), // We have `let $pat;`, so the expected type is unconstrained.\n+        };\n+\n+        // Type check the pattern. Override if necessary to avoid knock-on errors.\n+        self.check_pat_top(&local.pat, ty, ty_span, origin_expr);\n         let pat_ty = self.node_ty(local.pat.hir_id);\n-        self.overwrite_local_ty_if_err(local, t, pat_ty);\n+        self.overwrite_local_ty_if_err(local, ty, pat_ty);\n     }\n \n     fn overwrite_local_ty_if_err(\n@@ -4325,7 +4340,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ty: Ty<'tcx>,\n     ) {\n         if ty.references_error() {\n-            // Override the types everywhere with `types.err` to avoid knock down errors.\n+            // Override the types everywhere with `types.err` to avoid knock on errors.\n             self.write_ty(local.hir_id, ty);\n             self.write_ty(local.pat.hir_id, ty);\n             let local_ty = LocalTy { decl_ty, revealed_ty: ty };"}, {"sha": "759118933960367a89a1159a027a9e331fd9b95c", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 124, "deletions": 81, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -6,6 +6,7 @@ use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n use rustc::hir::{self, HirId, Pat, PatKind};\n use rustc::infer;\n use rustc::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n+use rustc::traits::Pattern;\n use rustc::ty::subst::GenericArg;\n use rustc::ty::{self, BindingMode, Ty, TypeFoldable};\n use syntax::ast;\n@@ -29,39 +30,97 @@ pointers. If you encounter this error you should try to avoid dereferencing the\n You can read more about trait objects in the Trait Objects section of the Reference: \\\n https://doc.rust-lang.org/reference/types.html#trait-objects\";\n \n-impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n-    pub fn check_pat_top(\n-        &self,\n-        pat: &'tcx Pat<'tcx>,\n-        expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n-    ) {\n-        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n-        self.check_pat(pat, expected, def_bm, discrim_span);\n-    }\n-\n-    /// `discrim_span` argument having a `Span` indicates that this pattern is part of a match\n-    /// expression arm guard, and it points to the match discriminant to add context in type errors.\n-    /// In the following example, `discrim_span` corresponds to the `a + b` expression:\n+/// Information about the expected type at the top level of type checking a pattern.\n+///\n+/// **NOTE:** This is only for use by diagnostics. Do NOT use for type checking logic!\n+#[derive(Copy, Clone)]\n+struct TopInfo<'tcx> {\n+    /// The `expected` type at the top level of type checking a pattern.\n+    expected: Ty<'tcx>,\n+    /// Was the origin of the `span` from a scrutinee expression?\n+    ///\n+    /// Otherwise there is no scrutinee and it could be e.g. from the type of a formal parameter.\n+    origin_expr: bool,\n+    /// The span giving rise to the `expected` type, if one could be provided.\n+    ///\n+    /// If `origin_expr` is `true`, then this is the span of the scrutinee as in:\n+    ///\n+    /// - `match scrutinee { ... }`\n+    /// - `let _ = scrutinee;`\n+    ///\n+    /// This is used to point to add context in type errors.\n+    /// In the following example, `span` corresponds to the `a + b` expression:\n     ///\n     /// ```text\n     /// error[E0308]: mismatched types\n-    ///  --> src/main.rs:5:9\n+    ///  --> src/main.rs:L:C\n     ///   |\n-    /// 4 |    let temp: usize = match a + b {\n+    /// L |    let temp: usize = match a + b {\n     ///   |                            ----- this expression has type `usize`\n-    /// 5 |         Ok(num) => num,\n+    /// L |         Ok(num) => num,\n     ///   |         ^^^^^^^ expected `usize`, found enum `std::result::Result`\n     ///   |\n     ///   = note: expected type `usize`\n     ///              found type `std::result::Result<_, _>`\n     /// ```\n+    span: Option<Span>,\n+}\n+\n+impl<'tcx> FnCtxt<'_, 'tcx> {\n+    fn demand_eqtype_pat_diag(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        let code = Pattern { span: ti.span, root_ty: ti.expected, origin_expr: ti.origin_expr };\n+        let cause = self.cause(cause_span, code);\n+        self.demand_eqtype_with_origin(&cause, expected, actual)\n+    }\n+\n+    fn demand_eqtype_pat(\n+        &self,\n+        cause_span: Span,\n+        expected: Ty<'tcx>,\n+        actual: Ty<'tcx>,\n+        ti: TopInfo<'tcx>,\n+    ) {\n+        self.demand_eqtype_pat_diag(cause_span, expected, actual, ti).map(|mut err| err.emit());\n+    }\n+}\n+\n+impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    /// Type check the given top level pattern against the `expected` type.\n+    ///\n+    /// If a `Some(span)` is provided and `origin_expr` holds,\n+    /// then the `span` represents the scrutinee's span.\n+    /// The scrutinee is found in e.g. `match scrutinee { ... }` and `let pat = scrutinee;`.\n+    ///\n+    /// Otherwise, `Some(span)` represents the span of a type expression\n+    /// which originated the `expected` type.\n+    pub fn check_pat_top(\n+        &self,\n+        pat: &'tcx Pat<'tcx>,\n+        expected: Ty<'tcx>,\n+        span: Option<Span>,\n+        origin_expr: bool,\n+    ) {\n+        let def_bm = BindingMode::BindByValue(hir::Mutability::Not);\n+        self.check_pat(pat, expected, def_bm, TopInfo { expected, origin_expr, span });\n+    }\n+\n+    /// Type check the given `pat` against the `expected` type\n+    /// with the provided `def_bm` (default binding mode).\n+    ///\n+    /// Outside of this module, `check_pat_top` should always be used.\n+    /// Conversely, inside this module, `check_pat_top` should never be used.\n     fn check_pat(\n         &self,\n         pat: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) {\n         debug!(\"check_pat(pat={:?},expected={:?},def_bm={:?})\", pat, expected, def_bm);\n \n@@ -72,60 +131,42 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let is_nrp = self.is_non_ref_pat(pat, path_resolution.map(|(res, ..)| res));\n         let (expected, def_bm) = self.calc_default_binding_mode(pat, expected, def_bm, is_nrp);\n \n-        let ty = match &pat.kind {\n+        let ty = match pat.kind {\n             PatKind::Wild => expected,\n-            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, discrim_span),\n+            PatKind::Lit(lt) => self.check_pat_lit(pat.span, lt, expected, ti),\n             PatKind::Range(begin, end, _) => {\n-                match self.check_pat_range(pat.span, begin, end, expected, discrim_span) {\n+                match self.check_pat_range(pat.span, begin, end, expected, ti) {\n                     None => return,\n                     Some(ty) => ty,\n                 }\n             }\n             PatKind::Binding(ba, var_id, _, sub) => {\n-                let sub = sub.as_deref();\n-                self.check_pat_ident(pat, *ba, *var_id, sub, expected, def_bm, discrim_span)\n+                self.check_pat_ident(pat, ba, var_id, sub, expected, def_bm, ti)\n             }\n-            PatKind::TupleStruct(qpath, subpats, ddpos) => self.check_pat_tuple_struct(\n-                pat,\n-                qpath,\n-                subpats,\n-                *ddpos,\n-                expected,\n-                def_bm,\n-                discrim_span,\n-            ),\n-            PatKind::Path(qpath) => {\n+            PatKind::TupleStruct(ref qpath, subpats, ddpos) => {\n+                self.check_pat_tuple_struct(pat, qpath, subpats, ddpos, expected, def_bm, ti)\n+            }\n+            PatKind::Path(ref qpath) => {\n                 self.check_pat_path(pat, path_resolution.unwrap(), qpath, expected)\n             }\n-            PatKind::Struct(qpath, fields, etc) => {\n-                self.check_pat_struct(pat, qpath, fields, *etc, expected, def_bm, discrim_span)\n+            PatKind::Struct(ref qpath, fields, etc) => {\n+                self.check_pat_struct(pat, qpath, fields, etc, expected, def_bm, ti)\n             }\n             PatKind::Or(pats) => {\n-                for pat in *pats {\n-                    self.check_pat(pat, expected, def_bm, discrim_span);\n+                for pat in pats {\n+                    self.check_pat(pat, expected, def_bm, ti);\n                 }\n                 expected\n             }\n             PatKind::Tuple(elements, ddpos) => {\n-                self.check_pat_tuple(pat.span, *elements, *ddpos, expected, def_bm, discrim_span)\n-            }\n-            PatKind::Box(inner) => {\n-                self.check_pat_box(pat.span, inner, expected, def_bm, discrim_span)\n+                self.check_pat_tuple(pat.span, elements, ddpos, expected, def_bm, ti)\n             }\n+            PatKind::Box(inner) => self.check_pat_box(pat.span, inner, expected, def_bm, ti),\n             PatKind::Ref(inner, mutbl) => {\n-                self.check_pat_ref(pat, inner, *mutbl, expected, def_bm, discrim_span)\n+                self.check_pat_ref(pat, inner, mutbl, expected, def_bm, ti)\n             }\n             PatKind::Slice(before, slice, after) => {\n-                let slice = slice.as_deref();\n-                self.check_pat_slice(\n-                    pat.span,\n-                    *before,\n-                    slice,\n-                    *after,\n-                    expected,\n-                    def_bm,\n-                    discrim_span,\n-                )\n+                self.check_pat_slice(pat.span, before, slice, after, expected, def_bm, ti)\n             }\n         };\n \n@@ -302,7 +343,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         span: Span,\n         lt: &hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // We've already computed the type above (when checking for a non-ref pat),\n         // so avoid computing it again.\n@@ -336,7 +377,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // then that's equivalent to there existing a LUB.\n         if let Some(mut err) = self.demand_suptype_diag(span, expected, pat_ty) {\n             err.emit_unless(\n-                discrim_span\n+                ti.span\n                     .filter(|&s| {\n                         // In the case of `if`- and `while`-expressions we've already checked\n                         // that `scrutinee: bool`. We know that the pattern is `true`,\n@@ -356,7 +397,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         lhs: &'tcx hir::Expr<'tcx>,\n         rhs: &'tcx hir::Expr<'tcx>,\n         expected: Ty<'tcx>,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Option<Ty<'tcx>> {\n         let lhs_ty = self.check_expr(lhs);\n         let rhs_ty = self.check_expr(rhs);\n@@ -377,7 +418,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Subtyping doesn't matter here, as the value is some kind of scalar.\n         let demand_eqtype = |x_span, y_span, x_ty, y_ty| {\n-            self.demand_eqtype_pat_diag(x_span, expected, x_ty, discrim_span).map(|mut err| {\n+            self.demand_eqtype_pat_diag(x_span, expected, x_ty, ti).map(|mut err| {\n                 self.endpoint_has_type(&mut err, y_span, y_ty);\n                 err.emit();\n             });\n@@ -451,7 +492,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         sub: Option<&'tcx Pat<'tcx>>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Determine the binding mode...\n         let bm = match ba {\n@@ -481,17 +522,17 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 expected\n             }\n         };\n-        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, eq_ty, local_ty, ti);\n \n         // If there are multiple arms, make sure they all agree on\n         // what the type of the binding `x` ought to be.\n         if var_id != pat.hir_id {\n             let vt = self.local_ty(pat.span, var_id).decl_ty;\n-            self.demand_eqtype_pat(pat.span, vt, local_ty, discrim_span);\n+            self.demand_eqtype_pat(pat.span, vt, local_ty, ti);\n         }\n \n         if let Some(p) = sub {\n-            self.check_pat(&p, expected, def_bm, discrim_span);\n+            self.check_pat(&p, expected, def_bm, ti);\n         }\n \n         local_ty\n@@ -570,24 +611,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         etc: bool,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         // Resolve the path and check the definition for errors.\n         let (variant, pat_ty) = if let Some(variant_ty) = self.check_struct_path(qpath, pat.hir_id)\n         {\n             variant_ty\n         } else {\n             for field in fields {\n-                self.check_pat(&field.pat, self.tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(&field.pat, self.tcx.types.err, def_bm, ti);\n             }\n             return self.tcx.types.err;\n         };\n \n         // Type-check the path.\n-        self.demand_eqtype_pat(pat.span, expected, pat_ty, discrim_span);\n+        self.demand_eqtype_pat(pat.span, expected, pat_ty, ti);\n \n         // Type-check subpatterns.\n-        if self.check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm)\n+        if self\n+            .check_struct_pat_fields(pat_ty, pat.hir_id, pat.span, variant, fields, etc, def_bm, ti)\n         {\n             pat_ty\n         } else {\n@@ -638,12 +680,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        match_arm_pat_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let on_error = || {\n             for pat in subpats {\n-                self.check_pat(&pat, tcx.types.err, def_bm, match_arm_pat_span);\n+                self.check_pat(&pat, tcx.types.err, def_bm, ti);\n             }\n         };\n         let report_unexpected_res = |res: Res| {\n@@ -704,7 +746,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let pat_ty = pat_ty.no_bound_vars().expect(\"expected fn type\");\n \n         // Type-check the tuple struct pattern against the expected type.\n-        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, match_arm_pat_span);\n+        let diag = self.demand_eqtype_pat_diag(pat.span, expected, pat_ty, ti);\n         let had_err = diag.is_some();\n         diag.map(|mut err| err.emit());\n \n@@ -718,7 +760,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             };\n             for (i, subpat) in subpats.iter().enumerate_and_adjust(variant.fields.len(), ddpos) {\n                 let field_ty = self.field_ty(subpat.span, &variant.fields[i], substs);\n-                self.check_pat(&subpat, field_ty, def_bm, match_arm_pat_span);\n+                self.check_pat(&subpat, field_ty, def_bm, ti);\n \n                 self.tcx.check_stability(variant.fields[i].did, Some(pat.hir_id), subpat.span);\n             }\n@@ -822,7 +864,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         ddpos: Option<usize>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let mut expected_len = elements.len();\n@@ -849,12 +891,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // further errors being emitted when using the bindings. #50333\n             let element_tys_iter = (0..max_len).map(|_| tcx.types.err);\n             for (_, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &tcx.types.err, def_bm, discrim_span);\n+                self.check_pat(elem, &tcx.types.err, def_bm, ti);\n             }\n             tcx.mk_tup(element_tys_iter)\n         } else {\n             for (i, elem) in elements.iter().enumerate_and_adjust(max_len, ddpos) {\n-                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, discrim_span);\n+                self.check_pat(elem, &element_tys[i].expect_ty(), def_bm, ti);\n             }\n             pat_ty\n         }\n@@ -869,6 +911,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fields: &'tcx [hir::FieldPat<'tcx>],\n         etc: bool,\n         def_bm: BindingMode,\n+        ti: TopInfo<'tcx>,\n     ) -> bool {\n         let tcx = self.tcx;\n \n@@ -918,7 +961,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 }\n             };\n \n-            self.check_pat(&field.pat, field_ty, def_bm, None);\n+            self.check_pat(&field.pat, field_ty, def_bm, ti);\n         }\n \n         let mut unmentioned_fields = variant\n@@ -1095,7 +1138,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         inner: &'tcx Pat<'tcx>,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let (box_ty, inner_ty) = if self.check_dereferenceable(span, expected, &inner) {\n@@ -1106,12 +1149,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 span: inner.span,\n             });\n             let box_ty = tcx.mk_box(inner_ty);\n-            self.demand_eqtype_pat(span, expected, box_ty, discrim_span);\n+            self.demand_eqtype_pat(span, expected, box_ty, ti);\n             (box_ty, inner_ty)\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         box_ty\n     }\n \n@@ -1122,7 +1165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         mutbl: hir::Mutability,\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let tcx = self.tcx;\n         let expected = self.shallow_resolve(expected);\n@@ -1157,7 +1200,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         } else {\n             (tcx.types.err, tcx.types.err)\n         };\n-        self.check_pat(&inner, inner_ty, def_bm, discrim_span);\n+        self.check_pat(&inner, inner_ty, def_bm, ti);\n         rptr_ty\n     }\n \n@@ -1186,7 +1229,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         after: &'tcx [&'tcx Pat<'tcx>],\n         expected: Ty<'tcx>,\n         def_bm: BindingMode,\n-        discrim_span: Option<Span>,\n+        ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n         let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n@@ -1211,15 +1254,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n         // Type check all the patterns before `slice`.\n         for elt in before {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, slice_ty, def_bm, discrim_span);\n+            self.check_pat(&slice, slice_ty, def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n-            self.check_pat(&elt, inner_ty, def_bm, discrim_span);\n+            self.check_pat(&elt, inner_ty, def_bm, ti);\n         }\n         expected\n     }"}, {"sha": "f06fe1e4bf2113ccbd6ec5e23caa3ead106e8136", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -65,6 +65,7 @@ This API is completely unstable and subject to change.\n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n #![feature(slice_patterns)]\n+#![feature(try_blocks)]\n #![feature(never_type)]\n #![recursion_limit = \"256\"]\n "}, {"sha": "416f055251b04076e82cd19c78a8ae76978dbdab", "filename": "src/test/ui/block-result/issue-13624.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fblock-result%2Fissue-13624.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -10,7 +10,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13624.rs:20:9\n    |\n LL |       match enum_struct_variant {\n-   |             ------------------- this match expression has type `()`\n+   |             ------------------- this expression has type `()`\n LL |         a::Enum::EnumStructVariant { x, y, z } => {\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found enum `a::Enum`\n "}, {"sha": "c78166f411d2855d8c3fb287720631bc7b7fe71c", "filename": "src/test/ui/destructure-trait-ref.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdestructure-trait-ref.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -44,7 +44,9 @@ error[E0308]: mismatched types\n   --> $DIR/destructure-trait-ref.rs:42:13\n    |\n LL |     let box box x = box 1isize as Box<dyn T>;\n-   |             ^^^^^ expected trait `T`, found struct `std::boxed::Box`\n+   |             ^^^^^   ------------------------ this expression has type `std::boxed::Box<dyn T>`\n+   |             |\n+   |             expected trait `T`, found struct `std::boxed::Box`\n    |\n    = note: expected trait object `dyn T`\n                     found struct `std::boxed::Box<_>`"}, {"sha": "39c0676373794b45135c49e01d9b0412963e7ba6", "filename": "src/test/ui/error-codes/E0308-4.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0308-4.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/E0308-4.rs:4:15\n    |\n LL |     match x {\n-   |           - this match expression has type `u8`\n+   |           - this expression has type `u8`\n LL |         0u8..=3i8 => (),\n    |         ---   ^^^ expected `u8`, found `i8`\n    |         |"}, {"sha": "76ae7241ff2771959a918eccf81ac291061ea71b", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99.., _] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "5c96f8041feb26cf84ac88905d3518225d3e173e", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision2.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -14,7 +14,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision2.rs:5:13\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [_, 99..] => {},\n    |             ^^ expected struct `std::ops::Range`, found integer\n    |"}, {"sha": "17e10324db18187df60dbbd0010c941f59070a18", "filename": "src/test/ui/exclusive-range/exclusive_range_pattern_syntax_collision3.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fexclusive-range%2Fexclusive_range_pattern_syntax_collision3.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -8,7 +8,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:12\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |            ^ expected struct `std::ops::Range`, found integer\n    |\n@@ -19,7 +19,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:15\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               ^^  --- this is of type `{integer}`\n    |               |\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n   --> $DIR/exclusive_range_pattern_syntax_collision3.rs:5:19\n    |\n LL |     match [5..4, 99..105, 43..44] {\n-   |           ----------------------- this match expression has type `std::ops::Range<{integer}>`\n+   |           ----------------------- this expression has type `[std::ops::Range<{integer}>; 3]`\n LL |         [..9, 99..100, _] => {},\n    |               --  ^^^ expected struct `std::ops::Range`, found integer\n    |               |"}, {"sha": "57533ba5e370b86d35ce9fa6eab0c1fd31af61ef", "filename": "src/test/ui/issues/issue-11844.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-11844.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-11844.rs:6:9\n    |\n LL |     match a {\n-   |           - this match expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n+   |           - this expression has type `std::option::Option<std::boxed::Box<{integer}>>`\n LL |         Ok(a) =>\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "60c4cceac51bef60570b9aaa89475b0e573c7a04", "filename": "src/test/ui/issues/issue-12552.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-12552.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-12552.rs:6:5\n    |\n LL |   match t {\n-   |         - this match expression has type `std::result::Result<_, {integer}>`\n+   |         - this expression has type `std::result::Result<_, {integer}>`\n LL |     Some(k) => match k {\n    |     ^^^^^^^ expected enum `std::result::Result`, found enum `std::option::Option`\n    |"}, {"sha": "52d9e2a91b971e9d849faa03e71562b45f925bef", "filename": "src/test/ui/issues/issue-13466.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13466.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:8:9\n    |\n LL |     let _x: usize = match Some(1) {\n-   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+   |                           ------- this expression has type `std::option::Option<{integer}>`\n LL |         Ok(u) => u,\n    |         ^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-13466.rs:14:9\n    |\n LL |     let _x: usize = match Some(1) {\n-   |                           ------- this match expression has type `std::option::Option<{integer}>`\n+   |                           ------- this expression has type `std::option::Option<{integer}>`\n ...\n LL |         Err(e) => panic!(e)\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`"}, {"sha": "cf155f428c6a0606769b9918a0f194719319ee2b", "filename": "src/test/ui/issues/issue-14541.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-14541.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-14541.rs:5:9\n    |\n LL |     let Vec3 { y: _, z: _ } = v;\n-   |         ^^^^^^^^^^^^^^^^^^^ expected struct `Vec2`, found struct `Vec3`\n+   |         ^^^^^^^^^^^^^^^^^^^   - this expression has type `Vec2`\n+   |         |\n+   |         expected struct `Vec2`, found struct `Vec3`\n \n error: aborting due to previous error\n "}, {"sha": "b3f0907b81d2595406b87aa7f099a2e02c35be0a", "filename": "src/test/ui/issues/issue-15896.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-15896.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-15896.rs:11:11\n    |\n LL |     let u = match e {\n-   |                   - this match expression has type `main::R`\n+   |                   - this expression has type `main::E`\n LL |         E::B(\n LL |           Tau{t: x},\n    |           ^^^^^^^^^ expected enum `main::R`, found struct `main::Tau`"}, {"sha": "6878600b0298338535d7e1dd7216e62e5be0a670", "filename": "src/test/ui/issues/issue-16338.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16338.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-16338.rs:7:9\n    |\n LL |     let Slice { data: data, len: len } = \"foo\";\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `str`, found struct `Slice`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^   ----- this expression has type `&str`\n+   |         |\n+   |         expected `str`, found struct `Slice`\n    |\n    = note: expected type `str`\n             found struct `Slice<_>`"}, {"sha": "f8ea0907099a5d0a39f4228f6978271258ff5dfb", "filename": "src/test/ui/issues/issue-16401.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16401.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-16401.rs:8:9\n    |\n LL |     match () {\n-   |           -- this match expression has type `()`\n+   |           -- this expression has type `()`\n LL |         Slice { data: data, len: len } => (),\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `Slice`\n    |"}, {"sha": "713e4b5ccd57575720f08173d3ef8b782f0b85f9", "filename": "src/test/ui/issues/issue-3680.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-3680.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-3680.rs:3:9\n    |\n LL |     match None {\n-   |           ---- this match expression has type `std::option::Option<_>`\n+   |           ---- this expression has type `std::option::Option<_>`\n LL |         Err(_) => ()\n    |         ^^^^^^ expected enum `std::option::Option`, found enum `std::result::Result`\n    |"}, {"sha": "361369e68bc0869238375f4c2747ea4e9cca7499", "filename": "src/test/ui/issues/issue-37026.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37026.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -8,7 +8,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-37026.rs:7:9\n    |\n LL |     let empty_struct::XEmpty6(..) = ();\n-   |         ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `()`, found struct `empty_struct::XEmpty6`\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^   -- this expression has type `()`\n+   |         |\n+   |         expected `()`, found struct `empty_struct::XEmpty6`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "c47e8689436ee1e7ee3dea504ef8e95c0e2ea35c", "filename": "src/test/ui/issues/issue-5100.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5100.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -29,7 +29,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-5100.rs:33:9\n    |\n LL |     match (true, false) {\n-   |           ------------- this match expression has type `(bool, bool)`\n+   |           ------------- this expression has type `(bool, bool)`\n LL |         box (true, false) => ()\n    |         ^^^^^^^^^^^^^^^^^ expected tuple, found struct `std::boxed::Box`\n    |"}, {"sha": "314d1fddbd76a5ff9598bc3505d44d46e69cba3e", "filename": "src/test/ui/issues/issue-5358-1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-5358-1.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-5358-1.rs:6:9\n    |\n LL |     match S(Either::Left(5)) {\n-   |           ------------------ this match expression has type `S`\n+   |           ------------------ this expression has type `S`\n LL |         Either::Right(_) => {}\n    |         ^^^^^^^^^^^^^^^^ expected struct `S`, found enum `Either`\n    |"}, {"sha": "a4f1ac94825d59f38388fc00de6ee1fdef528e94", "filename": "src/test/ui/issues/issue-57741-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57741-1.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-57741-1.rs:14:9\n    |\n LL |     let y = match x {\n-   |                   - this match expression has type `std::boxed::Box<u32>`\n+   |                   - this expression has type `std::boxed::Box<u32>`\n LL |         S::A { a } | S::B { b: a } => a,\n    |         ^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n    |\n@@ -13,7 +13,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-57741-1.rs:14:22\n    |\n LL |     let y = match x {\n-   |                   - this match expression has type `std::boxed::Box<u32>`\n+   |                   - this expression has type `std::boxed::Box<u32>`\n LL |         S::A { a } | S::B { b: a } => a,\n    |                      ^^^^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n    |"}, {"sha": "6f9e5b08a833f1990dc0ae107d28132f5e33e648", "filename": "src/test/ui/issues/issue-57741.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-57741.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<T>`\n+   |                   this expression has type `std::boxed::Box<T>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         T::A(a) | T::B(a) => a,\n    |         ^^^^^^^ expected struct `std::boxed::Box`, found enum `T`\n@@ -18,7 +18,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<T>`\n+   |                   this expression has type `std::boxed::Box<T>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         T::A(a) | T::B(a) => a,\n    |                   ^^^^^^^ expected struct `std::boxed::Box`, found enum `T`\n@@ -32,7 +32,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<S>`\n+   |                   this expression has type `std::boxed::Box<S>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         S::A { a } | S::B { b: a } => a,\n    |         ^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`\n@@ -46,7 +46,7 @@ error[E0308]: mismatched types\n LL |     let y = match x {\n    |                   -\n    |                   |\n-   |                   this match expression has type `std::boxed::Box<S>`\n+   |                   this expression has type `std::boxed::Box<S>`\n    |                   help: consider dereferencing the boxed value: `*x`\n LL |         S::A { a } | S::B { b: a } => a,\n    |                      ^^^^^^^^^^^^^ expected struct `std::boxed::Box`, found enum `S`"}, {"sha": "6e8ea6bf618f2fdb1a86ba90a83c755a3135326f", "filename": "src/test/ui/issues/issue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-67037-pat-tup-scrut-ty-diff-less-fields.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,9 @@ error[E0308]: mismatched types\n   --> $DIR/issue-67037-pat-tup-scrut-ty-diff-less-fields.rs:19:9\n    |\n LL |     let P() = U {};\n-   |         ^^^ expected struct `U`, found struct `P`\n+   |         ^^^   ---- this expression has type `U`\n+   |         |\n+   |         expected struct `U`, found struct `P`\n    |\n    = note: expected struct `U`\n               found struct `P<_>`"}, {"sha": "590dd40c65364238fb48e0d2ad48099a7d846c47", "filename": "src/test/ui/issues/issue-7092.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-7092.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/issue-7092.rs:6:9\n    |\n LL |     match x {\n-   |           - this match expression has type `Whatever`\n+   |           - this expression has type `Whatever`\n LL |         Some(field) =>\n    |         ^^^^^^^^^^^ expected enum `Whatever`, found enum `std::option::Option`\n    |"}, {"sha": "a475bd5e5819c7a4e9d844e2fb9c659882203e43", "filename": "src/test/ui/match/match-struct.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-struct.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/match-struct.rs:6:9\n    |\n LL |     match (S { a: 1 }) {\n-   |           ------------ this match expression has type `S`\n+   |           ------------ this expression has type `S`\n LL |         E::C(_) => (),\n    |         ^^^^^^^ expected struct `S`, found enum `E`\n "}, {"sha": "31f77bdff8b1f00d63f4e312acfcec3a9ab1eb7b", "filename": "src/test/ui/match/match-tag-unary.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatch%2Fmatch-tag-unary.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -4,7 +4,7 @@ error[E0308]: mismatched types\n LL | fn main() { let x: A = A::A(0); match x { B::B(y) => { } } }\n    |                                       -   ^^^^^^^ expected enum `A`, found enum `B`\n    |                                       |\n-   |                                       this match expression has type `A`\n+   |                                       this expression has type `A`\n \n error: aborting due to previous error\n "}, {"sha": "2306fb352738f80ef17a57d06ce6e1f8522f1e4c", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -9,6 +9,8 @@ LL |         (0, ref y) | (y, 0) => {}\n error[E0308]: mismatched types\n   --> $DIR/E0409.rs:5:23\n    |\n+LL |     match x {\n+   |           - this expression has type `({integer}, {integer})`\n LL |         (0, ref y) | (y, 0) => {}\n    |                       ^ expected `&{integer}`, found integer\n "}, {"sha": "948c91370d0d41496df712a5588f239ab8457917", "filename": "src/test/ui/or-patterns/already-bound-name.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Falready-bound-name.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -94,7 +94,9 @@ error[E0308]: mismatched types\n   --> $DIR/already-bound-name.rs:33:31\n    |\n LL |     let B(A(a, _) | B(a)) | A(a, A(a, _) | B(a)) = B(B(1));\n-   |                               ^ expected integer, found enum `E`\n+   |                               ^                    ------- this expression has type `E<E<{integer}>>`\n+   |                               |\n+   |                               expected integer, found enum `E`\n    |\n    = note: expected type `{integer}`\n               found type `E<{integer}>`"}, {"sha": "7c1638ff94d0f636bf3a3191bcb642c551eaa67e", "filename": "src/test/ui/or-patterns/inconsistent-modes.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Finconsistent-modes.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -60,7 +60,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:13:25\n    |\n LL |     let Ok(ref a) | Err(ref mut a): Result<&u8, &mut u8> = Ok(&0);\n-   |                         ^^^^^^^^^ types differ in mutability\n+   |                         ^^^^^^^^^   -------------------- expected due to this\n+   |                         |\n+   |                         types differ in mutability\n    |\n    = note: expected type `&&u8`\n               found type `&mut &mut u8`\n@@ -69,7 +71,9 @@ error[E0308]: mismatched types\n   --> $DIR/inconsistent-modes.rs:16:31\n    |\n LL |     let Ok((ref a, b)) | Err((ref mut a, ref b)) = Ok((0, &0));\n-   |                               ^^^^^^^^^ types differ in mutability\n+   |                               ^^^^^^^^^            ----------- this expression has type `std::result::Result<({integer}, &{integer}), (_, _)>`\n+   |                               |\n+   |                               types differ in mutability\n    |\n    = note: expected type `&{integer}`\n               found type `&mut _`"}, {"sha": "bc288e06250751d914801818d0240c36253341cb", "filename": "src/test/ui/or-patterns/or-pattern-mismatch.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2For-pattern-mismatch.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/or-pattern-mismatch.rs:3:68\n    |\n LL | fn main() { match Blah::A(1, 1, 2) { Blah::A(_, x, y) | Blah::B(x, y) => { } } }\n-   |                                                                    ^ expected `usize`, found `isize`\n+   |                   ---------------- this expression has type `Blah` ^ expected `usize`, found `isize`\n \n error: aborting due to previous error\n "}, {"sha": "8ff4f948a05ec5132610e1f5d5d82dca9797906c", "filename": "src/test/ui/parser/pat-tuple-5.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fpat-tuple-5.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -17,7 +17,7 @@ error[E0308]: mismatched types\n   --> $DIR/pat-tuple-5.rs:5:10\n    |\n LL |     match (0, 1) {\n-   |           ------ this match expression has type `({integer}, {integer})`\n+   |           ------ this expression has type `({integer}, {integer})`\n LL |         (PAT ..) => {}\n    |          ^^^ expected tuple, found `u8`\n    |"}, {"sha": "3fed64c191a8a2de52c518513935c66e64aa1cd6", "filename": "src/test/ui/parser/recover-range-pats.stderr", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Frecover-range-pats.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -425,8 +425,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:23:16\n    |\n LL |     if let X.. .0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -457,8 +458,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:36:16\n    |\n LL |     if let X..=.0 = 0 {}\n-   |            -   ^^ expected integer, found floating-point number\n-   |            |\n+   |            -   ^^   - this expression has type `u8`\n+   |            |   |\n+   |            |   expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns\n@@ -489,8 +491,9 @@ error[E0308]: mismatched types\n   --> $DIR/recover-range-pats.rs:52:17\n    |\n LL |     if let X... .0 = 0 {}\n-   |            -    ^^ expected integer, found floating-point number\n-   |            |\n+   |            -    ^^   - this expression has type `u8`\n+   |            |    |\n+   |            |    expected integer, found floating-point number\n    |            this is of type `u8`\n \n error[E0029]: only char and numeric types are allowed in range patterns"}, {"sha": "1d18214de7f08ac263ba45ad14965c389b0f7b7e", "filename": "src/test/ui/pattern/pat-struct-field-expr-has-type.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,9 @@\n+struct S {\n+    f: u8,\n+}\n+\n+fn main() {\n+    match (S { f: 42 }) {\n+        S { f: Ok(_) } => {} //~ ERROR mismatched types\n+    }\n+}"}, {"sha": "d57a8a0dbc1813ef299b788abad195e00215ac4c", "filename": "src/test/ui/pattern/pat-struct-field-expr-has-type.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-struct-field-expr-has-type.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-struct-field-expr-has-type.rs:7:16\n+   |\n+LL |     match (S { f: 42 }) {\n+   |           ------------- this expression has type `S`\n+LL |         S { f: Ok(_) } => {}\n+   |                ^^^^^ expected `u8`, found enum `std::result::Result`\n+   |\n+   = note: expected type `u8`\n+              found enum `std::result::Result<_, _>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "54336b3492321f5459ae1fd797c44a563dbc2d13", "filename": "src/test/ui/pattern/pat-type-err-formal-param.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,8 @@\n+// Test the `.span_label(..)` to the type when there's a\n+// type error in a pattern due to a the formal parameter.\n+\n+fn main() {}\n+\n+struct Tuple(u8);\n+\n+fn foo(Tuple(_): String) {} //~ ERROR mismatched types"}, {"sha": "2d7eb62faef2bb272697ec7adf116950f06baf93", "filename": "src/test/ui/pattern/pat-type-err-formal-param.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-formal-param.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,11 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-formal-param.rs:8:8\n+   |\n+LL | fn foo(Tuple(_): String) {}\n+   |        ^^^^^^^^  ------ expected due to this\n+   |        |\n+   |        expected struct `std::string::String`, found struct `Tuple`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "6e9850b655cb9f67183e68062a65699525443aeb", "filename": "src/test/ui/pattern/pat-type-err-let-stmt.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.rs?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,16 @@\n+// Test the `.span_label` to the type / scrutinee\n+// when there's a type error in checking a pattern.\n+\n+fn main() {\n+    // We want to point at the `Option<u8>`.\n+    let Ok(0): Option<u8> = 42u8;\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+\n+    // We want to point at the `Option<u8>`.\n+    let Ok(0): Option<u8>;\n+    //~^ ERROR mismatched types\n+\n+    // We want to point at the scrutinee.\n+    let Ok(0) = 42u8; //~ ERROR mismatched types\n+}"}, {"sha": "d75fa3f247c451cc47bc7a81a8303e8edd597be5", "filename": "src/test/ui/pattern/pat-type-err-let-stmt.stderr", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpat-type-err-let-stmt.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -0,0 +1,49 @@\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:6:29\n+   |\n+LL |     let Ok(0): Option<u8> = 42u8;\n+   |                ----------   ^^^^\n+   |                |            |\n+   |                |            expected enum `std::option::Option`, found `u8`\n+   |                |            help: try using a variant of the expected enum: `Some(42u8)`\n+   |                expected due to this\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found type `u8`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:6:9\n+   |\n+LL |     let Ok(0): Option<u8> = 42u8;\n+   |         ^^^^^  ---------- expected due to this\n+   |         |\n+   |         expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found enum `std::result::Result<_, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:11:9\n+   |\n+LL |     let Ok(0): Option<u8>;\n+   |         ^^^^^  ---------- expected due to this\n+   |         |\n+   |         expected enum `std::option::Option`, found enum `std::result::Result`\n+   |\n+   = note: expected enum `std::option::Option<u8>`\n+              found enum `std::result::Result<_, _>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/pat-type-err-let-stmt.rs:15:9\n+   |\n+LL |     let Ok(0) = 42u8;\n+   |         ^^^^^   ---- this expression has type `u8`\n+   |         |\n+   |         expected `u8`, found enum `std::result::Result`\n+   |\n+   = note: expected type `u8`\n+              found enum `std::result::Result<_, _>`\n+\n+error: aborting due to 4 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "60f76796c03969717613163d2a4b186361bdedf7", "filename": "src/test/ui/pattern/pattern-error-continue.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-error-continue.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -28,7 +28,7 @@ error[E0308]: mismatched types\n   --> $DIR/pattern-error-continue.rs:22:9\n    |\n LL |     match 'c' {\n-   |           --- this match expression has type `char`\n+   |           --- this expression has type `char`\n LL |         S { .. } => (),\n    |         ^^^^^^^^ expected `char`, found struct `S`\n "}, {"sha": "15425da69bcc48595ddf2221f181ae5aa6c4d812", "filename": "src/test/ui/pattern/pattern-tyvar.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fpattern%2Fpattern-tyvar.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -2,7 +2,7 @@ error[E0308]: mismatched types\n   --> $DIR/pattern-tyvar.rs:5:18\n    |\n LL |     match t {\n-   |           - this match expression has type `std::option::Option<std::vec::Vec<isize>>`\n+   |           - this expression has type `Bar`\n LL |       Bar::T1(_, Some::<isize>(x)) => {\n    |                  ^^^^^^^^^^^^^^^^ expected struct `std::vec::Vec`, found `isize`\n    |"}, {"sha": "61d1001ce9154f154e0665d3b26b9c3a653a7ecd", "filename": "src/test/ui/resolve/resolve-inconsistent-binding-mode.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-binding-mode.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -23,18 +23,24 @@ LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:7:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:16:32\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref i) | Opts::B(i) => {}\n    |                                ^ expected `&isize`, found `isize`\n \n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-binding-mode.rs:25:36\n    |\n+LL |     match x {\n+   |           - this expression has type `Opts`\n LL |       Opts::A(ref mut i) | Opts::B(ref i) => {}\n    |                                    ^^^^^ types differ in mutability\n    |"}, {"sha": "5c87f7c684f3b0695c6c4b63f76e80a8cc2ae398", "filename": "src/test/ui/resolve/resolve-inconsistent-names.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fresolve-inconsistent-names.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -86,6 +86,8 @@ LL |         (CONST1, _) | (_, Const2) => ()\n error[E0308]: mismatched types\n   --> $DIR/resolve-inconsistent-names.rs:19:19\n    |\n+LL |     match x {\n+   |           - this expression has type `(E, E)`\n LL |         (A, B) | (ref B, c) | (c, A) => ()\n    |                   ^^^^^ expected enum `E`, found `&E`\n "}, {"sha": "7170adca60dc345b4c6516512a59d687ed7e3340", "filename": "src/test/ui/rfc-2497-if-let-chains/disallowed-positions.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2497-if-let-chains%2Fdisallowed-positions.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -630,7 +630,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:67:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true && false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -650,7 +650,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:71:12\n    |\n LL |     if let Range { start: _, end: _ } = true..true || false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -697,7 +697,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:86:12\n    |\n LL |     if let Range { start: true, end } = t..&&false {}\n-   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |            |\n    |            expected `bool`, found struct `std::ops::Range`\n    |\n@@ -818,7 +818,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:131:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true && false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -838,7 +838,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:135:15\n    |\n LL |     while let Range { start: _, end: _ } = true..true || false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -885,7 +885,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:150:15\n    |\n LL |     while let Range { start: true, end } = t..&&false {}\n-   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this match expression has type `bool`\n+   |               ^^^^^^^^^^^^^^^^^^^^^^^^^^   - this expression has type `&&bool`\n    |               |\n    |               expected `bool`, found struct `std::ops::Range`\n    |\n@@ -961,7 +961,7 @@ error[E0308]: mismatched types\n   --> $DIR/disallowed-positions.rs:198:10\n    |\n LL |     (let Range { start: _, end: _ } = true..true || false);\n-   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this match expression has type `bool`\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^   ---- this expression has type `bool`\n    |          |\n    |          expected `bool`, found struct `std::ops::Range`\n    |"}, {"sha": "8cfa118a2dac2a3964028fe3e4aaba814d357429", "filename": "src/test/ui/structs/structure-constructor-type-mismatch.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/50fb8480dbe65b14b48502c937eea66c4b5a6c31/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstructure-constructor-type-mismatch.stderr?ref=50fb8480dbe65b14b48502c937eea66c4b5a6c31", "patch": "@@ -86,7 +86,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:54:9\n    |\n LL |     match (Point { x: 1, y: 2 }) {\n-   |           ---------------------- this match expression has type `Point<{integer}>`\n+   |           ---------------------- this expression has type `Point<{integer}>`\n LL |         PointF::<u32> { .. } => {}\n    |         ^^^^^^^^^^^^^^^^^^^^ expected integer, found `f32`\n    |\n@@ -97,7 +97,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:59:9\n    |\n LL |     match (Point { x: 1, y: 2 }) {\n-   |           ---------------------- this match expression has type `Point<{integer}>`\n+   |           ---------------------- this expression has type `Point<{integer}>`\n LL |         PointF { .. } => {}\n    |         ^^^^^^^^^^^^^ expected integer, found `f32`\n    |\n@@ -108,7 +108,7 @@ error[E0308]: mismatched types\n   --> $DIR/structure-constructor-type-mismatch.rs:67:9\n    |\n LL |     match (Pair { x: 1, y: 2 }) {\n-   |           --------------------- this match expression has type `Pair<{integer}, {integer}>`\n+   |           --------------------- this expression has type `Pair<{integer}, {integer}>`\n LL |         PairF::<u32> { .. } => {}\n    |         ^^^^^^^^^^^^^^^^^^^ expected integer, found `f32`\n    |"}]}