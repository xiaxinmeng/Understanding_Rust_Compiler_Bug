{"sha": "ef02c3c038812897cd96789fa35770e4215d27e8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmMDJjM2MwMzg4MTI4OTdjZDk2Nzg5ZmEzNTc3MGU0MjE1ZDI3ZTg=", "commit": {"author": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-03-29T12:34:05Z"}, "committer": {"name": "Sergey Parilin", "email": "Sergey.Parilin@fxdd.com", "date": "2019-03-29T12:34:05Z"}, "message": "some PR issues fixed", "tree": {"sha": "8989066dd039688b565f54d997713920285edccd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8989066dd039688b565f54d997713920285edccd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef02c3c038812897cd96789fa35770e4215d27e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef02c3c038812897cd96789fa35770e4215d27e8", "html_url": "https://github.com/rust-lang/rust/commit/ef02c3c038812897cd96789fa35770e4215d27e8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef02c3c038812897cd96789fa35770e4215d27e8/comments", "author": null, "committer": null, "parents": [{"sha": "58224bc65910ae94cff81b2cdcd74a435498f5f2", "url": "https://api.github.com/repos/rust-lang/rust/commits/58224bc65910ae94cff81b2cdcd74a435498f5f2", "html_url": "https://github.com/rust-lang/rust/commit/58224bc65910ae94cff81b2cdcd74a435498f5f2"}], "stats": {"total": 150, "additions": 68, "deletions": 82}, "files": [{"sha": "0107f7de957d51a395d80bea9358daa9b74d8e45", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 68, "deletions": 82, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/ef02c3c038812897cd96789fa35770e4215d27e8/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef02c3c038812897cd96789fa35770e4215d27e8/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=ef02c3c038812897cd96789fa35770e4215d27e8", "patch": "@@ -1,22 +1,50 @@\n-extern crate lazy_static;\n-\n use std::cell::RefCell;\n-use std::time;\n-use std::fmt;\n+use std::time::{Duration, Instant};\n use std::mem;\n-use std::io::{stderr, StderrLock, Write};\n+use std::io::{stderr, Write};\n use std::iter::repeat;\n use std::collections::{HashSet};\n use std::default::Default;\n use std::iter::FromIterator;\n use std::sync::RwLock;\n-\n use lazy_static::lazy_static;\n \n-type Message = (usize, u64, String);\n+pub fn set_filter(f: Filter) {\n+    let set = HashSet::from_iter(f.allowed.iter().cloned());\n+    let mut old = FILTER.write().unwrap();\n+    let filter_data = FilterData { depth: f.depth, allowed: set, version: old.version + 1 };\n+    *old = filter_data;\n+}\n+\n+pub fn profile(desc: &str) -> Profiler {\n+    PROFILE_STACK.with(|stack| {\n+        let mut stack = stack.borrow_mut();\n+        if stack.starts.len() == 0 {\n+            match FILTER.try_read() {\n+                Ok(f) => {\n+                    if f.version > stack.filter_data.version {\n+                        stack.filter_data = f.clone();\n+                    }\n+                }\n+                Err(_) => (),\n+            };\n+        }\n+        let desc_str = desc.to_string();\n+        if desc_str.is_empty() {\n+            Profiler { desc: None }\n+        } else if stack.starts.len() < stack.filter_data.depth\n+            && stack.filter_data.allowed.contains(&desc_str)\n+        {\n+            stack.starts.push(Instant::now());\n+            Profiler { desc: Some(desc_str) }\n+        } else {\n+            Profiler { desc: None }\n+        }\n+    })\n+}\n \n pub struct Profiler {\n-    desc: String,\n+    desc: Option<String>,\n }\n \n pub struct Filter {\n@@ -25,112 +53,70 @@ pub struct Filter {\n }\n \n struct ProfileStack {\n-    starts: Vec<time::Instant>,\n+    starts: Vec<Instant>,\n     messages: Vec<Message>,\n     filter_data: FilterData,\n }\n \n+struct Message {\n+    level: usize,\n+    duration: Duration,\n+    message: String,\n+}\n+\n impl ProfileStack {\n     fn new() -> ProfileStack {\n         ProfileStack { starts: Vec::new(), messages: Vec::new(), filter_data: Default::default() }\n     }\n }\n \n-#[derive(Default)]\n+#[derive(Default, Clone)]\n struct FilterData {\n     depth: usize,\n     version: usize,\n     allowed: HashSet<String>,\n }\n \n-impl Clone for FilterData {\n-    fn clone(&self) -> FilterData {\n-        let set = HashSet::from_iter(self.allowed.iter().cloned());\n-        FilterData { depth: self.depth, allowed: set, version: self.version }\n-    }\n-}\n-\n lazy_static! {\n     static ref FILTER: RwLock<FilterData> = RwLock::new(Default::default());\n }\n \n thread_local!(static PROFILE_STACK: RefCell<ProfileStack> = RefCell::new(ProfileStack::new()));\n \n-pub fn set_filter(f: Filter) {\n-    let mut old = FILTER.write().unwrap();\n-    let set = HashSet::from_iter(f.allowed.iter().cloned());\n-    let filter_data = FilterData { depth: f.depth, allowed: set, version: old.version + 1 };\n-    *old = filter_data;\n-}\n-\n-pub fn profile<T: fmt::Display>(desc: T) -> Profiler {\n-    PROFILE_STACK.with(|stack| {\n-        let mut stack = stack.borrow_mut();\n-        if stack.starts.len() == 0 {\n-            match FILTER.try_read() {\n-                Ok(f) => {\n-                    if f.version > stack.filter_data.version {\n-                        stack.filter_data = f.clone();\n-                    }\n-                }\n-                Err(_) => (),\n-            };\n-        }\n-        let desc_str = desc.to_string();\n-        if desc_str.is_empty() {\n-            Profiler { desc: desc_str }\n-        } else if stack.starts.len() < stack.filter_data.depth\n-            && stack.filter_data.allowed.contains(&desc_str)\n-        {\n-            stack.starts.push(time::Instant::now());\n-            Profiler { desc: desc_str }\n-        } else {\n-            Profiler { desc: String::new() }\n-        }\n-    })\n-}\n-\n impl Drop for Profiler {\n     fn drop(&mut self) {\n-        if self.desc.is_empty() {\n-            return;\n-        }\n-        PROFILE_STACK.with(|stack| {\n-            let mut stack = stack.borrow_mut();\n-            let start = stack.starts.pop().unwrap();\n-            let duration = start.elapsed();\n-            let duration_ms = duration.as_secs() * 1000 + u64::from(duration.subsec_millis());\n-            let stack_len = stack.starts.len();\n-            let msg = (stack_len, duration_ms, mem::replace(&mut self.desc, String::new()));\n-            stack.messages.push(msg);\n-            if stack_len == 0 {\n-                let stdout = stderr();\n-                print(0, &stack.messages, 1, &mut stdout.lock());\n-                stack.messages.clear();\n+        match self {\n+            Profiler { desc: Some(desc) } => {\n+                PROFILE_STACK.with(|stack| {\n+                    let mut stack = stack.borrow_mut();\n+                    let start = stack.starts.pop().unwrap();\n+                    let duration = start.elapsed();\n+                    let level = stack.starts.len();\n+                    let message = mem::replace(desc, String::new());\n+                    stack.messages.push(Message { level, duration, message });\n+                    if level == 0 {\n+                        let stdout = stderr();\n+                        print(0, &stack.messages, &mut stdout.lock());\n+                        stack.messages.clear();\n+                    }\n+                });\n             }\n-        });\n+            Profiler { desc: None } => (),\n+        }\n     }\n }\n \n-fn print(lvl: usize, msgs: &[Message], enabled: usize, stdout: &mut StderrLock<'_>) {\n-    if lvl > enabled {\n-        return;\n-    }\n+fn print(lvl: usize, msgs: &[Message], out: &mut impl Write) {\n     let mut last = 0;\n-    for (i, &(l, time, ref msg)) in msgs.iter().enumerate() {\n+    let indent = repeat(\"    \").take(lvl + 1).collect::<String>();\n+    for (i, &Message { level: l, duration: dur, message: ref msg }) in msgs.iter().enumerate() {\n         if l != lvl {\n             continue;\n         }\n-        writeln!(\n-            stdout,\n-            \"{} {:6}ms - {}\",\n-            repeat(\"    \").take(lvl + 1).collect::<String>(),\n-            time,\n-            msg\n-        )\n-        .expect(\"printing profiling info to stdout\");\n-\n-        print(lvl + 1, &msgs[last..i], enabled, stdout);\n+        writeln!(out, \"{} {:6}ms - {}\", indent, dur.as_millis(), msg)\n+            .expect(\"printing profiling info to stdout\");\n+\n+        print(lvl + 1, &msgs[last..i], out);\n         last = i;\n     }\n }"}]}