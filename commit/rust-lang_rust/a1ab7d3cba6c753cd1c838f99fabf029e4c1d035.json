{"sha": "a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYWI3ZDNjYmE2Yzc1M2NkMWM4MzhmOTlmYWJmMDI5ZTRjMWQwMzU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-18T17:47:39Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:25Z"}, "message": "libstd: Add serialization2 versions of prettyprint and ebml", "tree": {"sha": "773d18a76e45a910ad24e92f69075c77d4b7ef71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/773d18a76e45a910ad24e92f69075c77d4b7ef71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "html_url": "https://github.com/rust-lang/rust/commit/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "html_url": "https://github.com/rust-lang/rust/commit/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd"}], "stats": {"total": 773, "additions": 772, "deletions": 1}, "files": [{"sha": "8b37dea62108e32028091548d66874b46ddabc60", "filename": "src/libstd/ebml2.rs", "status": "added", "additions": 623, "deletions": 0, "changes": 623, "blob_url": "https://github.com/rust-lang/rust/blob/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Febml2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Febml2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Febml2.rs?ref=a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "patch": "@@ -0,0 +1,623 @@\n+use serialization2;\n+\n+// Simple Extensible Binary Markup Language (ebml) reader and writer on a\n+// cursor model. See the specification here:\n+//     http://www.matroska.org/technical/specs/rfc/index.html\n+export Doc;\n+export doc_at;\n+export maybe_get_doc;\n+export get_doc;\n+export docs;\n+export tagged_docs;\n+export doc_data;\n+export doc_as_str;\n+export doc_as_u8;\n+export doc_as_u16;\n+export doc_as_u32;\n+export doc_as_u64;\n+export doc_as_i8;\n+export doc_as_i16;\n+export doc_as_i32;\n+export doc_as_i64;\n+export Serializer;\n+export Deserializer;\n+export with_doc_data;\n+export get_doc;\n+export extensions;\n+\n+struct EbmlTag {\n+    id: uint,\n+    size: uint,\n+}\n+\n+struct EbmlState {\n+    ebml_tag: EbmlTag,\n+    tag_pos: uint,\n+    data_pos: uint,\n+}\n+\n+// FIXME (#2739): When we have module renaming, make \"reader\" and \"writer\"\n+// separate modules within this file.\n+\n+// ebml reading\n+struct Doc {\n+    data: @~[u8],\n+    start: uint,\n+    end: uint,\n+}\n+\n+struct TaggedDoc {\n+    tag: uint,\n+    doc: Doc,\n+}\n+\n+impl Doc: ops::Index<uint,Doc> {\n+    pure fn index(+tag: uint) -> Doc {\n+        unsafe {\n+            get_doc(self, tag)\n+        }\n+    }\n+}\n+\n+fn vuint_at(data: &[u8], start: uint) -> {val: uint, next: uint} {\n+    let a = data[start];\n+    if a & 0x80u8 != 0u8 {\n+        return {val: (a & 0x7fu8) as uint, next: start + 1u};\n+    }\n+    if a & 0x40u8 != 0u8 {\n+        return {val: ((a & 0x3fu8) as uint) << 8u |\n+                 (data[start + 1u] as uint),\n+             next: start + 2u};\n+    } else if a & 0x20u8 != 0u8 {\n+        return {val: ((a & 0x1fu8) as uint) << 16u |\n+                 (data[start + 1u] as uint) << 8u |\n+                 (data[start + 2u] as uint),\n+             next: start + 3u};\n+    } else if a & 0x10u8 != 0u8 {\n+        return {val: ((a & 0x0fu8) as uint) << 24u |\n+                 (data[start + 1u] as uint) << 16u |\n+                 (data[start + 2u] as uint) << 8u |\n+                 (data[start + 3u] as uint),\n+             next: start + 4u};\n+    } else { error!(\"vint too big\"); fail; }\n+}\n+\n+fn Doc(data: @~[u8]) -> Doc {\n+    Doc { data: data, start: 0u, end: vec::len::<u8>(*data) }\n+}\n+\n+fn doc_at(data: @~[u8], start: uint) -> TaggedDoc {\n+    let elt_tag = vuint_at(*data, start);\n+    let elt_size = vuint_at(*data, elt_tag.next);\n+    let end = elt_size.next + elt_size.val;\n+    TaggedDoc {\n+        tag: elt_tag.val,\n+        doc: Doc { data: data, start: elt_size.next, end: end }\n+    }\n+}\n+\n+fn maybe_get_doc(d: Doc, tg: uint) -> Option<Doc> {\n+    let mut pos = d.start;\n+    while pos < d.end {\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if elt_tag.val == tg {\n+            return Some(Doc { data: d.data, start: elt_size.next, end: pos });\n+        }\n+    }\n+    None\n+}\n+\n+fn get_doc(d: Doc, tg: uint) -> Doc {\n+    match maybe_get_doc(d, tg) {\n+      Some(d) => d,\n+      None => {\n+        error!(\"failed to find block with tag %u\", tg);\n+        fail;\n+      }\n+    }\n+}\n+\n+fn docs(d: Doc, it: fn(uint, Doc) -> bool) {\n+    let mut pos = d.start;\n+    while pos < d.end {\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+        if !it(elt_tag.val, doc) {\n+            break;\n+        }\n+    }\n+}\n+\n+fn tagged_docs(d: Doc, tg: uint, it: fn(Doc) -> bool) {\n+    let mut pos = d.start;\n+    while pos < d.end {\n+        let elt_tag = vuint_at(*d.data, pos);\n+        let elt_size = vuint_at(*d.data, elt_tag.next);\n+        pos = elt_size.next + elt_size.val;\n+        if elt_tag.val == tg {\n+            let doc = Doc { data: d.data, start: elt_size.next, end: pos };\n+            if !it(doc) {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+fn doc_data(d: Doc) -> ~[u8] { vec::slice::<u8>(*d.data, d.start, d.end) }\n+\n+fn with_doc_data<T>(d: Doc, f: fn(x: &[u8]) -> T) -> T {\n+    f(vec::view(*d.data, d.start, d.end))\n+}\n+\n+fn doc_as_str(d: Doc) -> ~str { str::from_bytes(doc_data(d)) }\n+\n+fn doc_as_u8(d: Doc) -> u8 {\n+    assert d.end == d.start + 1u;\n+    (*d.data)[d.start]\n+}\n+\n+fn doc_as_u16(d: Doc) -> u16 {\n+    assert d.end == d.start + 2u;\n+    io::u64_from_be_bytes(*d.data, d.start, 2u) as u16\n+}\n+\n+fn doc_as_u32(d: Doc) -> u32 {\n+    assert d.end == d.start + 4u;\n+    io::u64_from_be_bytes(*d.data, d.start, 4u) as u32\n+}\n+\n+fn doc_as_u64(d: Doc) -> u64 {\n+    assert d.end == d.start + 8u;\n+    io::u64_from_be_bytes(*d.data, d.start, 8u)\n+}\n+\n+fn doc_as_i8(d: Doc) -> i8 { doc_as_u8(d) as i8 }\n+fn doc_as_i16(d: Doc) -> i16 { doc_as_u16(d) as i16 }\n+fn doc_as_i32(d: Doc) -> i32 { doc_as_u32(d) as i32 }\n+fn doc_as_i64(d: Doc) -> i64 { doc_as_u64(d) as i64 }\n+\n+// ebml writing\n+struct Serializer {\n+    writer: io::Writer,\n+    priv mut size_positions: ~[uint],\n+}\n+\n+fn write_sized_vuint(w: io::Writer, n: uint, size: uint) {\n+    match size {\n+      1u => w.write(&[0x80u8 | (n as u8)]),\n+      2u => w.write(&[0x40u8 | ((n >> 8_u) as u8), n as u8]),\n+      3u => w.write(&[0x20u8 | ((n >> 16_u) as u8), (n >> 8_u) as u8,\n+                      n as u8]),\n+      4u => w.write(&[0x10u8 | ((n >> 24_u) as u8), (n >> 16_u) as u8,\n+                      (n >> 8_u) as u8, n as u8]),\n+      _ => fail fmt!(\"vint to write too big: %?\", n)\n+    };\n+}\n+\n+fn write_vuint(w: io::Writer, n: uint) {\n+    if n < 0x7f_u { write_sized_vuint(w, n, 1u); return; }\n+    if n < 0x4000_u { write_sized_vuint(w, n, 2u); return; }\n+    if n < 0x200000_u { write_sized_vuint(w, n, 3u); return; }\n+    if n < 0x10000000_u { write_sized_vuint(w, n, 4u); return; }\n+    fail fmt!(\"vint to write too big: %?\", n);\n+}\n+\n+fn Serializer(w: io::Writer) -> Serializer {\n+    let size_positions: ~[uint] = ~[];\n+    Serializer { writer: w, mut size_positions: size_positions }\n+}\n+\n+// FIXME (#2741): Provide a function to write the standard ebml header.\n+impl Serializer {\n+    fn start_tag(tag_id: uint) {\n+        debug!(\"Start tag %u\", tag_id);\n+\n+        // Write the enum ID:\n+        write_vuint(self.writer, tag_id);\n+\n+        // Write a placeholder four-byte size.\n+        vec::push(self.size_positions, self.writer.tell());\n+        let zeroes: &[u8] = &[0u8, 0u8, 0u8, 0u8];\n+        self.writer.write(zeroes);\n+    }\n+\n+    fn end_tag() {\n+        let last_size_pos = vec::pop::<uint>(self.size_positions);\n+        let cur_pos = self.writer.tell();\n+        self.writer.seek(last_size_pos as int, io::SeekSet);\n+        let size = (cur_pos - last_size_pos - 4u);\n+        write_sized_vuint(self.writer, size, 4u);\n+        self.writer.seek(cur_pos as int, io::SeekSet);\n+\n+        debug!(\"End tag (size = %u)\", size);\n+    }\n+\n+    fn wr_tag(tag_id: uint, blk: fn()) {\n+        self.start_tag(tag_id);\n+        blk();\n+        self.end_tag();\n+    }\n+\n+    fn wr_tagged_bytes(tag_id: uint, b: &[u8]) {\n+        write_vuint(self.writer, tag_id);\n+        write_vuint(self.writer, vec::len(b));\n+        self.writer.write(b);\n+    }\n+\n+    fn wr_tagged_u64(tag_id: uint, v: u64) {\n+        do io::u64_to_be_bytes(v, 8u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_u32(tag_id: uint, v: u32) {\n+        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_u16(tag_id: uint, v: u16) {\n+        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_u8(tag_id: uint, v: u8) {\n+        self.wr_tagged_bytes(tag_id, &[v]);\n+    }\n+\n+    fn wr_tagged_i64(tag_id: uint, v: i64) {\n+        do io::u64_to_be_bytes(v as u64, 8u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_i32(tag_id: uint, v: i32) {\n+        do io::u64_to_be_bytes(v as u64, 4u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_i16(tag_id: uint, v: i16) {\n+        do io::u64_to_be_bytes(v as u64, 2u) |v| {\n+            self.wr_tagged_bytes(tag_id, v);\n+        }\n+    }\n+\n+    fn wr_tagged_i8(tag_id: uint, v: i8) {\n+        self.wr_tagged_bytes(tag_id, &[v as u8]);\n+    }\n+\n+    fn wr_tagged_str(tag_id: uint, v: &str) {\n+        str::byte_slice(v, |b| self.wr_tagged_bytes(tag_id, b));\n+    }\n+\n+    fn wr_bytes(b: &[u8]) {\n+        debug!(\"Write %u bytes\", vec::len(b));\n+        self.writer.write(b);\n+    }\n+\n+    fn wr_str(s: ~str) {\n+        debug!(\"Write str: %?\", s);\n+        self.writer.write(str::to_bytes(s));\n+    }\n+}\n+\n+// FIXME (#2743): optionally perform \"relaxations\" on end_tag to more\n+// efficiently encode sizes; this is a fixed point iteration\n+\n+// Set to true to generate more debugging in EBML serialization.\n+// Totally lame approach.\n+const debug: bool = false;\n+\n+enum EbmlSerializerTag {\n+    EsUint, EsU64, EsU32, EsU16, EsU8,\n+    EsInt, EsI64, EsI32, EsI16, EsI8,\n+    EsBool,\n+    EsStr,\n+    EsF64, EsF32, EsFloat,\n+    EsEnum, EsEnumVid, EsEnumBody,\n+    EsVec, EsVecLen, EsVecElt,\n+\n+    EsOpaque,\n+\n+    EsLabel // Used only when debugging\n+}\n+\n+priv impl Serializer {\n+    // used internally to emit things like the vector length and so on\n+    fn _emit_tagged_uint(t: EbmlSerializerTag, v: uint) {\n+        assert v <= 0xFFFF_FFFF_u;\n+        self.wr_tagged_u32(t as uint, v as u32);\n+    }\n+\n+    fn _emit_label(label: &str) {\n+        // There are various strings that we have access to, such as\n+        // the name of a record field, which do not actually appear in\n+        // the serialized EBML (normally).  This is just for\n+        // efficiency.  When debugging, though, we can emit such\n+        // labels and then they will be checked by deserializer to\n+        // try and check failures more quickly.\n+        if debug { self.wr_tagged_str(EsLabel as uint, label) }\n+    }\n+}\n+\n+impl Serializer {\n+    fn emit_opaque(&self, f: fn()) {\n+        do self.wr_tag(EsOpaque as uint) {\n+            f()\n+        }\n+    }\n+}\n+\n+impl Serializer: serialization2::Serializer {\n+    fn emit_nil(&self) {}\n+\n+    fn emit_uint(&self, v: uint) {\n+        self.wr_tagged_u64(EsUint as uint, v as u64);\n+    }\n+    fn emit_u64(&self, v: u64) { self.wr_tagged_u64(EsU64 as uint, v); }\n+    fn emit_u32(&self, v: u32) { self.wr_tagged_u32(EsU32 as uint, v); }\n+    fn emit_u16(&self, v: u16) { self.wr_tagged_u16(EsU16 as uint, v); }\n+    fn emit_u8(&self, v: u8)   { self.wr_tagged_u8 (EsU8  as uint, v); }\n+\n+    fn emit_int(&self, v: int) {\n+        self.wr_tagged_i64(EsInt as uint, v as i64);\n+    }\n+    fn emit_i64(&self, v: i64) { self.wr_tagged_i64(EsI64 as uint, v); }\n+    fn emit_i32(&self, v: i32) { self.wr_tagged_i32(EsI32 as uint, v); }\n+    fn emit_i16(&self, v: i16) { self.wr_tagged_i16(EsI16 as uint, v); }\n+    fn emit_i8(&self, v: i8)   { self.wr_tagged_i8 (EsI8  as uint, v); }\n+\n+    fn emit_bool(&self, v: bool) {\n+        self.wr_tagged_u8(EsBool as uint, v as u8)\n+    }\n+\n+    // FIXME (#2742): implement these\n+    fn emit_f64(&self, _v: f64) { fail ~\"Unimplemented: serializing an f64\"; }\n+    fn emit_f32(&self, _v: f32) { fail ~\"Unimplemented: serializing an f32\"; }\n+    fn emit_float(&self, _v: float) {\n+        fail ~\"Unimplemented: serializing a float\";\n+    }\n+\n+    fn emit_str(&self, v: &str) { self.wr_tagged_str(EsStr as uint, v) }\n+\n+    fn emit_enum(&self, name: &str, f: fn()) {\n+        self._emit_label(name);\n+        self.wr_tag(EsEnum as uint, f)\n+    }\n+    fn emit_enum_variant(&self, _v_name: &str, v_id: uint, _cnt: uint,\n+                         f: fn()) {\n+        self._emit_tagged_uint(EsEnumVid, v_id);\n+        self.wr_tag(EsEnumBody as uint, f)\n+    }\n+    fn emit_enum_variant_arg(&self, _idx: uint, f: fn()) { f() }\n+\n+    fn emit_vec(&self, len: uint, f: fn()) {\n+        do self.wr_tag(EsVec as uint) {\n+            self._emit_tagged_uint(EsVecLen, len);\n+            f()\n+        }\n+    }\n+\n+    fn emit_vec_elt(&self, _idx: uint, f: fn()) {\n+        self.wr_tag(EsVecElt as uint, f)\n+    }\n+\n+    fn emit_box(&self, f: fn()) { f() }\n+    fn emit_uniq(&self, f: fn()) { f() }\n+    fn emit_rec(&self, f: fn()) { f() }\n+    fn emit_rec_field(&self, f_name: &str, _f_idx: uint, f: fn()) {\n+        self._emit_label(f_name);\n+        f()\n+    }\n+    fn emit_tup(&self, _sz: uint, f: fn()) { f() }\n+    fn emit_tup_elt(&self, _idx: uint, f: fn()) { f() }\n+}\n+\n+struct Deserializer {\n+    priv mut parent: Doc,\n+    priv mut pos: uint,\n+}\n+\n+fn Deserializer(d: Doc) -> Deserializer {\n+    Deserializer { mut parent: d, mut pos: d.start }\n+}\n+\n+priv impl Deserializer {\n+    fn _check_label(lbl: ~str) {\n+        if self.pos < self.parent.end {\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                doc_at(self.parent.data, self.pos);\n+\n+            if r_tag == (EsLabel as uint) {\n+                self.pos = r_doc.end;\n+                let str = doc_as_str(r_doc);\n+                if lbl != str {\n+                    fail fmt!(\"Expected label %s but found %s\", lbl, str);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn next_doc(exp_tag: EbmlSerializerTag) -> Doc {\n+        debug!(\". next_doc(exp_tag=%?)\", exp_tag);\n+        if self.pos >= self.parent.end {\n+            fail ~\"no more documents in current node!\";\n+        }\n+        let TaggedDoc { tag: r_tag, doc: r_doc } =\n+            doc_at(self.parent.data, self.pos);\n+        debug!(\"self.parent=%?-%? self.pos=%? r_tag=%? r_doc=%?-%?\",\n+               copy self.parent.start, copy self.parent.end,\n+               copy self.pos, r_tag, r_doc.start, r_doc.end);\n+        if r_tag != (exp_tag as uint) {\n+            fail fmt!(\"expected EMBL doc with tag %? but found tag %?\",\n+                      exp_tag, r_tag);\n+        }\n+        if r_doc.end > self.parent.end {\n+            fail fmt!(\"invalid EBML, child extends to 0x%x, parent to 0x%x\",\n+                      r_doc.end, self.parent.end);\n+        }\n+        self.pos = r_doc.end;\n+        r_doc\n+    }\n+\n+    fn push_doc<T>(d: Doc, f: fn() -> T) -> T{\n+        let old_parent = self.parent;\n+        let old_pos = self.pos;\n+        self.parent = d;\n+        self.pos = d.start;\n+        let r = f();\n+        self.parent = old_parent;\n+        self.pos = old_pos;\n+        move r\n+    }\n+\n+    fn _next_uint(exp_tag: EbmlSerializerTag) -> uint {\n+        let r = doc_as_u32(self.next_doc(exp_tag));\n+        debug!(\"_next_uint exp_tag=%? result=%?\", exp_tag, r);\n+        r as uint\n+    }\n+}\n+\n+impl Deserializer {\n+    fn read_opaque<R>(&self, op: fn(Doc) -> R) -> R {\n+        do self.push_doc(self.next_doc(EsOpaque)) {\n+            op(copy self.parent)\n+        }\n+    }\n+}\n+\n+impl Deserializer: serialization2::Deserializer {\n+    fn read_nil(&self) -> () { () }\n+\n+    fn read_u64(&self) -> u64 { doc_as_u64(self.next_doc(EsU64)) }\n+    fn read_u32(&self) -> u32 { doc_as_u32(self.next_doc(EsU32)) }\n+    fn read_u16(&self) -> u16 { doc_as_u16(self.next_doc(EsU16)) }\n+    fn read_u8 (&self) -> u8  { doc_as_u8 (self.next_doc(EsU8 )) }\n+    fn read_uint(&self) -> uint {\n+        let v = doc_as_u64(self.next_doc(EsUint));\n+        if v > (core::uint::max_value as u64) {\n+            fail fmt!(\"uint %? too large for this architecture\", v);\n+        }\n+        v as uint\n+    }\n+\n+    fn read_i64(&self) -> i64 { doc_as_u64(self.next_doc(EsI64)) as i64 }\n+    fn read_i32(&self) -> i32 { doc_as_u32(self.next_doc(EsI32)) as i32 }\n+    fn read_i16(&self) -> i16 { doc_as_u16(self.next_doc(EsI16)) as i16 }\n+    fn read_i8 (&self) -> i8  { doc_as_u8 (self.next_doc(EsI8 )) as i8  }\n+    fn read_int(&self) -> int {\n+        let v = doc_as_u64(self.next_doc(EsInt)) as i64;\n+        if v > (int::max_value as i64) || v < (int::min_value as i64) {\n+            fail fmt!(\"int %? out of range for this architecture\", v);\n+        }\n+        v as int\n+    }\n+\n+    fn read_bool(&self) -> bool { doc_as_u8(self.next_doc(EsBool)) as bool }\n+\n+    fn read_f64(&self) -> f64 { fail ~\"read_f64()\"; }\n+    fn read_f32(&self) -> f32 { fail ~\"read_f32()\"; }\n+    fn read_float(&self) -> float { fail ~\"read_float()\"; }\n+\n+    fn read_str(&self) -> ~str { doc_as_str(self.next_doc(EsStr)) }\n+\n+    // Compound types:\n+    fn read_enum<T>(&self, name: ~str, f: fn() -> T) -> T {\n+        debug!(\"read_enum(%s)\", name);\n+        self._check_label(name);\n+        self.push_doc(self.next_doc(EsEnum), f)\n+    }\n+\n+    fn read_enum_variant<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_enum_variant()\");\n+        let idx = self._next_uint(EsEnumVid);\n+        debug!(\"  idx=%u\", idx);\n+        do self.push_doc(self.next_doc(EsEnumBody)) {\n+            f(idx)\n+        }\n+    }\n+\n+    fn read_enum_variant_arg<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_enum_variant_arg(idx=%u)\", idx);\n+        f()\n+    }\n+\n+    fn read_vec<T>(&self, f: fn(uint) -> T) -> T {\n+        debug!(\"read_vec()\");\n+        do self.push_doc(self.next_doc(EsVec)) {\n+            let len = self._next_uint(EsVecLen);\n+            debug!(\"  len=%u\", len);\n+            f(len)\n+        }\n+    }\n+\n+    fn read_vec_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_vec_elt(idx=%u)\", idx);\n+        self.push_doc(self.next_doc(EsVecElt), f)\n+    }\n+\n+    fn read_box<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_box()\");\n+        f()\n+    }\n+\n+    fn read_uniq<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_uniq()\");\n+        f()\n+    }\n+\n+    fn read_rec<T>(&self, f: fn() -> T) -> T {\n+        debug!(\"read_rec()\");\n+        f()\n+    }\n+\n+    fn read_rec_field<T>(&self, f_name: ~str, f_idx: uint,\n+                         f: fn() -> T) -> T {\n+        debug!(\"read_rec_field(%s, idx=%u)\", f_name, f_idx);\n+        self._check_label(f_name);\n+        f()\n+    }\n+\n+    fn read_tup<T>(&self, sz: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup(sz=%u)\", sz);\n+        f()\n+    }\n+\n+    fn read_tup_elt<T>(&self, idx: uint, f: fn() -> T) -> T {\n+        debug!(\"read_tup_elt(idx=%u)\", idx);\n+        f()\n+    }\n+}\n+\n+\n+// ___________________________________________________________________________\n+// Testing\n+\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn test_option_int() {\n+        fn test_v(v: Option<int>) {\n+            debug!(\"v == %?\", v);\n+            let bytes = do io::with_bytes_writer |wr| {\n+                let ebml_w = Serializer(wr);\n+                v.serialize(&ebml_w)\n+            };\n+            let ebml_doc = Doc(@bytes);\n+            let deser = Deserializer(ebml_doc);\n+            let v1 = serialization2::deserialize(&deser);\n+            debug!(\"v1 == %?\", v1);\n+            assert v == v1;\n+        }\n+\n+        test_v(Some(22));\n+        test_v(None);\n+        test_v(Some(3));\n+    }\n+}"}, {"sha": "c0e76662bcb0114c3b0b3b85c5c2e4eac85eb3d0", "filename": "src/libstd/prettyprint2.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Fprettyprint2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Fprettyprint2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprettyprint2.rs?ref=a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "patch": "@@ -0,0 +1,142 @@\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+use io::Writer;\n+use io::WriterUtil;\n+use serialization2;\n+\n+struct Serializer {\n+    wr: io::Writer,\n+}\n+\n+fn Serializer(wr: io::Writer) -> Serializer {\n+    Serializer { wr: wr }\n+}\n+\n+impl Serializer: serialization2::Serializer {\n+    fn emit_nil(&self) {\n+        self.wr.write_str(~\"()\")\n+    }\n+\n+    fn emit_uint(&self, v: uint) {\n+        self.wr.write_str(fmt!(\"%?u\", v));\n+    }\n+\n+    fn emit_u64(&self, v: u64) {\n+        self.wr.write_str(fmt!(\"%?_u64\", v));\n+    }\n+\n+    fn emit_u32(&self, v: u32) {\n+        self.wr.write_str(fmt!(\"%?_u32\", v));\n+    }\n+\n+    fn emit_u16(&self, v: u16) {\n+        self.wr.write_str(fmt!(\"%?_u16\", v));\n+    }\n+\n+    fn emit_u8(&self, v: u8) {\n+        self.wr.write_str(fmt!(\"%?_u8\", v));\n+    }\n+\n+    fn emit_int(&self, v: int) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n+    }\n+\n+    fn emit_i64(&self, v: i64) {\n+        self.wr.write_str(fmt!(\"%?_i64\", v));\n+    }\n+\n+    fn emit_i32(&self, v: i32) {\n+        self.wr.write_str(fmt!(\"%?_i32\", v));\n+    }\n+\n+    fn emit_i16(&self, v: i16) {\n+        self.wr.write_str(fmt!(\"%?_i16\", v));\n+    }\n+\n+    fn emit_i8(&self, v: i8) {\n+        self.wr.write_str(fmt!(\"%?_i8\", v));\n+    }\n+\n+    fn emit_bool(&self, v: bool) {\n+        self.wr.write_str(fmt!(\"%b\", v));\n+    }\n+\n+    fn emit_float(&self, v: float) {\n+        self.wr.write_str(fmt!(\"%?_f\", v));\n+    }\n+\n+    fn emit_f64(&self, v: f64) {\n+        self.wr.write_str(fmt!(\"%?_f64\", v));\n+    }\n+\n+    fn emit_f32(&self, v: f32) {\n+        self.wr.write_str(fmt!(\"%?_f32\", v));\n+    }\n+\n+    fn emit_str(&self, v: &str) {\n+        self.wr.write_str(fmt!(\"%?\", v));\n+    }\n+\n+    fn emit_enum(&self, _name: &str, f: fn()) {\n+        f();\n+    }\n+\n+    fn emit_enum_variant(&self, v_name: &str, _v_id: uint, sz: uint,\n+                         f: fn()) {\n+        self.wr.write_str(v_name);\n+        if sz > 0u { self.wr.write_str(~\"(\"); }\n+        f();\n+        if sz > 0u { self.wr.write_str(~\")\"); }\n+    }\n+\n+    fn emit_enum_variant_arg(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        f();\n+    }\n+\n+    fn emit_vec(&self, _len: uint, f: fn()) {\n+        self.wr.write_str(~\"[\");\n+        f();\n+        self.wr.write_str(~\"]\");\n+    }\n+\n+    fn emit_vec_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        f();\n+    }\n+\n+    fn emit_box(&self, f: fn()) {\n+        self.wr.write_str(~\"@\");\n+        f();\n+    }\n+\n+    fn emit_uniq(&self, f: fn()) {\n+        self.wr.write_str(~\"~\");\n+        f();\n+    }\n+\n+    fn emit_rec(&self, f: fn()) {\n+        self.wr.write_str(~\"{\");\n+        f();\n+        self.wr.write_str(~\"}\");\n+    }\n+\n+    fn emit_rec_field(&self, f_name: &str, f_idx: uint, f: fn()) {\n+        if f_idx > 0u { self.wr.write_str(~\", \"); }\n+        self.wr.write_str(f_name);\n+        self.wr.write_str(~\": \");\n+        f();\n+    }\n+\n+    fn emit_tup(&self, _sz: uint, f: fn()) {\n+        self.wr.write_str(~\"(\");\n+        f();\n+        self.wr.write_str(~\")\");\n+    }\n+\n+    fn emit_tup_elt(&self, idx: uint, f: fn()) {\n+        if idx > 0u { self.wr.write_str(~\", \"); }\n+        f();\n+    }\n+}"}, {"sha": "c3b7c1793ec3202c543514877da7a9bfab8f029b", "filename": "src/libstd/std.rc", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a1ab7d3cba6c753cd1c838f99fabf029e4c1d035/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=a1ab7d3cba6c753cd1c838f99fabf029e4c1d035", "patch": "@@ -34,7 +34,9 @@ export sync, arc, comm;\n export bitv, deque, fun_treemap, list, map;\n export smallintmap, sort, treemap;\n export rope, arena, par;\n-export ebml, dbg, getopts, json, rand, sha1, term, time, prettyprint;\n+export ebml, ebml2;\n+export dbg, getopts, json, rand, sha1, term, time;\n+export prettyprint, prettyprint2;\n export test, tempfile, serialization, serialization2;\n export cmp;\n export base64;\n@@ -107,6 +109,8 @@ mod treemap;\n #[legacy_exports]\n mod ebml;\n #[legacy_exports]\n+mod ebml2;\n+#[legacy_exports]\n mod dbg;\n #[legacy_exports]\n mod getopts;\n@@ -125,6 +129,8 @@ mod time;\n #[legacy_exports]\n mod prettyprint;\n #[legacy_exports]\n+mod prettyprint2;\n+#[legacy_exports]\n mod arena;\n #[legacy_exports]\n mod par;"}]}