{"sha": "5fd37862d95a7fd898342e49ae5273edc8886b83", "node_id": "C_kwDOAAsO6NoAKDVmZDM3ODYyZDk1YTdmZDg5ODM0MmU0OWFlNTI3M2VkYzg4ODZiODM", "commit": {"author": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2021-10-13T13:58:41Z"}, "committer": {"name": "Esteban Kuber", "email": "esteban@kuber.com.ar", "date": "2022-03-24T02:08:49Z"}, "message": "Properly track `ImplObligation`s\n\nInstead of probing for all possible impls that could have caused an\n`ImplObligation`, keep track of its `DefId` and obligation spans for\naccurate error reporting.\n\nFollow up to #89580. Addresses #89418.\n\nRemove some unnecessary clones.\n\nTweak output for auto trait impl obligations.", "tree": {"sha": "fe52310640ff222ce511fc596d06c447b68863ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fe52310640ff222ce511fc596d06c447b68863ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5fd37862d95a7fd898342e49ae5273edc8886b83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5fd37862d95a7fd898342e49ae5273edc8886b83", "html_url": "https://github.com/rust-lang/rust/commit/5fd37862d95a7fd898342e49ae5273edc8886b83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5fd37862d95a7fd898342e49ae5273edc8886b83/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "547369d3d881a9eb1de0d3e368f9a59aa7c648b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/547369d3d881a9eb1de0d3e368f9a59aa7c648b0", "html_url": "https://github.com/rust-lang/rust/commit/547369d3d881a9eb1de0d3e368f9a59aa7c648b0"}], "stats": {"total": 634, "additions": 421, "deletions": 213}, "files": [{"sha": "61e3334862bc0d2b53b824b9f5e40ddc543f6f37", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/mismatched_static_lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fmismatched_static_lifetime.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -31,7 +31,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         // about the original obligation only.\n         let code = match cause.code() {\n             ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => &*parent_code,\n-            _ => cause.code(),\n+            code => code,\n         };\n         let ObligationCauseCode::MatchImpl(parent, impl_def_id) = code else {\n             return None;"}, {"sha": "3ed7836074b258b8d038d4f13c1d33b3266c84c2", "filename": "compiler/rustc_middle/src/traits/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fmod.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -257,7 +257,7 @@ pub enum ObligationCauseCode<'tcx> {\n \n     BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n \n-    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+    ImplDerivedObligation(Box<ImplDerivedObligationCause<'tcx>>),\n \n     DerivedObligation(DerivedObligationCause<'tcx>),\n \n@@ -396,16 +396,29 @@ pub enum WellFormedLoc {\n     },\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Hash, Lift)]\n+pub struct ImplDerivedObligationCause<'tcx> {\n+    pub derived: DerivedObligationCause<'tcx>,\n+    pub impl_def_id: DefId,\n+    pub span: Span,\n+}\n+\n impl ObligationCauseCode<'_> {\n     // Return the base obligation, ignoring derived obligations.\n     pub fn peel_derives(&self) -> &Self {\n         let mut base_cause = self;\n-        while let BuiltinDerivedObligation(DerivedObligationCause { parent_code, .. })\n-        | ImplDerivedObligation(DerivedObligationCause { parent_code, .. })\n-        | DerivedObligation(DerivedObligationCause { parent_code, .. })\n-        | FunctionArgumentObligation { parent_code, .. } = base_cause\n-        {\n-            base_cause = &parent_code;\n+        loop {\n+            match base_cause {\n+                BuiltinDerivedObligation(DerivedObligationCause { parent_code, .. })\n+                | DerivedObligation(DerivedObligationCause { parent_code, .. })\n+                | FunctionArgumentObligation { parent_code, .. } => {\n+                    base_cause = &parent_code;\n+                }\n+                ImplDerivedObligation(obligation_cause) => {\n+                    base_cause = &*obligation_cause.derived.parent_code;\n+                }\n+                _ => break,\n+            }\n         }\n         base_cause\n     }"}, {"sha": "d65b390af3460d5a664773f94bc4d2acdb546826", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 82, "deletions": 39, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -507,8 +507,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         let body_id = obligation.cause.body_id;\n         let span = obligation.cause.span;\n         let real_trait_pred = match &*code {\n-            ObligationCauseCode::ImplDerivedObligation(cause)\n-            | ObligationCauseCode::DerivedObligation(cause)\n+            ObligationCauseCode::ImplDerivedObligation(cause) => cause.derived.parent_trait_pred,\n+            ObligationCauseCode::DerivedObligation(cause)\n             | ObligationCauseCode::BuiltinDerivedObligation(cause) => cause.parent_trait_pred,\n             _ => trait_pred,\n         };\n@@ -790,8 +790,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return false;\n         };\n \n-        if let ObligationCauseCode::ImplDerivedObligation(obligation) = code {\n-            try_borrowing(obligation.parent_trait_pred, &[])\n+        if let ObligationCauseCode::ImplDerivedObligation(cause) = &*code {\n+            try_borrowing(cause.derived.parent_trait_pred, &[])\n         } else if let ObligationCauseCode::BindingObligation(_, _)\n         | ObligationCauseCode::ItemObligation(_) = code\n         {\n@@ -1433,13 +1433,43 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 ObligationCauseCode::FunctionArgumentObligation { parent_code, .. } => {\n                     next_code = Some(parent_code.as_ref());\n                 }\n+                ObligationCauseCode::ImplDerivedObligation(cause) => {\n+                    let ty = cause.derived.parent_trait_pred.skip_binder().self_ty();\n+                    debug!(\n+                        \"maybe_note_obligation_cause_for_async_await: ImplDerived \\\n+                         parent_trait_ref={:?} self_ty.kind={:?}\",\n+                        cause.derived.parent_trait_pred,\n+                        ty.kind()\n+                    );\n+\n+                    match *ty.kind() {\n+                        ty::Generator(did, ..) => {\n+                            generator = generator.or(Some(did));\n+                            outer_generator = Some(did);\n+                        }\n+                        ty::GeneratorWitness(..) => {}\n+                        ty::Tuple(_) if !seen_upvar_tys_infer_tuple => {\n+                            // By introducing a tuple of upvar types into the chain of obligations\n+                            // of a generator, the first non-generator item is now the tuple itself,\n+                            // we shall ignore this.\n+\n+                            seen_upvar_tys_infer_tuple = true;\n+                        }\n+                        _ if generator.is_none() => {\n+                            trait_ref = Some(cause.derived.parent_trait_pred.skip_binder());\n+                            target_ty = Some(ty);\n+                        }\n+                        _ => {}\n+                    }\n+\n+                    next_code = Some(cause.derived.parent_code.as_ref());\n+                }\n                 ObligationCauseCode::DerivedObligation(derived_obligation)\n-                | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation)\n-                | ObligationCauseCode::ImplDerivedObligation(derived_obligation) => {\n+                | ObligationCauseCode::BuiltinDerivedObligation(derived_obligation) => {\n                     let ty = derived_obligation.parent_trait_pred.skip_binder().self_ty();\n                     debug!(\n                         \"maybe_note_obligation_cause_for_async_await: \\\n-                            parent_trait_ref={:?} self_ty.kind={:?}\",\n+                         parent_trait_ref={:?} self_ty.kind={:?}\",\n                         derived_obligation.parent_trait_pred,\n                         ty.kind()\n                     );\n@@ -2166,59 +2196,72 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n             }\n             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                let mut parent_trait_pred = self.resolve_vars_if_possible(data.parent_trait_pred);\n+                let mut parent_trait_pred =\n+                    self.resolve_vars_if_possible(data.derived.parent_trait_pred);\n                 parent_trait_pred.remap_constness_diag(param_env);\n                 let parent_def_id = parent_trait_pred.def_id();\n                 let msg = format!(\n                     \"required because of the requirements on the impl of `{}` for `{}`\",\n                     parent_trait_pred.print_modifiers_and_trait_path(),\n                     parent_trait_pred.skip_binder().self_ty()\n                 );\n-                let mut candidates = vec![];\n-                self.tcx.for_each_relevant_impl(\n-                    parent_def_id,\n-                    parent_trait_pred.self_ty().skip_binder(),\n-                    |impl_def_id| match self.tcx.hir().get_if_local(impl_def_id) {\n-                        Some(Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Impl(hir::Impl { .. }),\n-                            ..\n-                        })) => {\n-                            candidates.push(impl_def_id);\n-                        }\n-                        _ => {}\n-                    },\n-                );\n-                match &candidates[..] {\n-                    [def_id] => match self.tcx.hir().get_if_local(*def_id) {\n-                        Some(Node::Item(hir::Item {\n-                            kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n-                            ..\n-                        })) => {\n-                            let mut spans = Vec::with_capacity(2);\n-                            if let Some(trait_ref) = of_trait {\n-                                spans.push(trait_ref.path.span);\n-                            }\n-                            spans.push(self_ty.span);\n-                            err.span_note(spans, &msg)\n+                let mut is_auto_trait = false;\n+                match self.tcx.hir().get_if_local(data.impl_def_id) {\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Trait(is_auto, ..),\n+                        ident,\n+                        ..\n+                    })) => {\n+                        // FIXME: we should do something else so that it works even on crate foreign\n+                        // auto traits.\n+                        is_auto_trait = matches!(is_auto, hir::IsAuto::Yes);\n+                        err.span_note(ident.span, &msg)\n+                    }\n+                    Some(Node::Item(hir::Item {\n+                        kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                        ..\n+                    })) => {\n+                        let mut spans = Vec::with_capacity(2);\n+                        if let Some(trait_ref) = of_trait {\n+                            spans.push(trait_ref.path.span);\n                         }\n-                        _ => err.note(&msg),\n-                    },\n+                        spans.push(self_ty.span);\n+                        err.span_note(spans, &msg)\n+                    }\n                     _ => err.note(&msg),\n                 };\n \n                 let mut parent_predicate = parent_trait_pred.to_predicate(tcx);\n-                let mut data = data;\n+                let mut data = &data.derived;\n                 let mut count = 0;\n                 seen_requirements.insert(parent_def_id);\n+                if is_auto_trait {\n+                    // We don't want to point at the ADT saying \"required because it appears within\n+                    // the type `X`\", like we would otherwise do in test `supertrait-auto-trait.rs`.\n+                    while let ObligationCauseCode::BuiltinDerivedObligation(derived) =\n+                        &*data.parent_code\n+                    {\n+                        let child_trait_ref =\n+                            self.resolve_vars_if_possible(derived.parent_trait_pred);\n+                        let child_def_id = child_trait_ref.def_id();\n+                        if seen_requirements.insert(child_def_id) {\n+                            break;\n+                        }\n+                        data = derived;\n+                        parent_predicate = child_trait_ref.to_predicate(tcx);\n+                        parent_trait_pred = child_trait_ref;\n+                    }\n+                }\n                 while let ObligationCauseCode::ImplDerivedObligation(child) = &*data.parent_code {\n                     // Skip redundant recursive obligation notes. See `ui/issue-20413.rs`.\n-                    let child_trait_pred = self.resolve_vars_if_possible(child.parent_trait_pred);\n+                    let child_trait_pred =\n+                        self.resolve_vars_if_possible(child.derived.parent_trait_pred);\n                     let child_def_id = child_trait_pred.def_id();\n                     if seen_requirements.insert(child_def_id) {\n                         break;\n                     }\n                     count += 1;\n-                    data = child;\n+                    data = &child.derived;\n                     parent_predicate = child_trait_pred.to_predicate(tcx);\n                     parent_trait_pred = child_trait_pred;\n                 }"}, {"sha": "9c871eea1cdda63a615edd288583df9e8dbbea5f", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 44, "deletions": 31, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -18,24 +18,17 @@ use rustc_span::def_id::DefId;\n \n use crate::traits::project::{normalize_with_depth, normalize_with_depth_to};\n use crate::traits::select::TraitObligationExt;\n-use crate::traits::util;\n-use crate::traits::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n-use crate::traits::ImplSource;\n-use crate::traits::Normalized;\n-use crate::traits::OutputTypeParameterMismatch;\n-use crate::traits::Selection;\n-use crate::traits::TraitNotObjectSafe;\n-use crate::traits::VtblSegment;\n-use crate::traits::{BuiltinDerivedObligation, ImplDerivedObligation};\n+use crate::traits::util::{self, closure_trait_ref_and_return_type, predicate_for_trait_def};\n use crate::traits::{\n-    ImplSourceAutoImplData, ImplSourceBuiltinData, ImplSourceClosureData,\n-    ImplSourceConstDestructData, ImplSourceDiscriminantKindData, ImplSourceFnPointerData,\n-    ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData, ImplSourceTraitAliasData,\n-    ImplSourceTraitUpcastingData, ImplSourceUserDefinedData,\n+    BuiltinDerivedObligation, DerivedObligationCause, ImplDerivedObligation,\n+    ImplDerivedObligationCause, ImplSource, ImplSourceAutoImplData, ImplSourceBuiltinData,\n+    ImplSourceClosureData, ImplSourceConstDestructData, ImplSourceDiscriminantKindData,\n+    ImplSourceFnPointerData, ImplSourceGeneratorData, ImplSourceObjectData, ImplSourcePointeeData,\n+    ImplSourceTraitAliasData, ImplSourceTraitUpcastingData, ImplSourceUserDefinedData, Normalized,\n+    ObjectCastObligation, Obligation, ObligationCause, OutputTypeParameterMismatch,\n+    PredicateObligation, Selection, SelectionError, TraitNotObjectSafe, TraitObligation,\n+    Unimplemented, VtblSegment,\n };\n-use crate::traits::{ObjectCastObligation, PredicateObligation, TraitObligation};\n-use crate::traits::{Obligation, ObligationCause};\n-use crate::traits::{SelectionError, Unimplemented};\n \n use super::BuiltinImplConditions;\n use super::SelectionCandidate::{self, *};\n@@ -321,28 +314,29 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?nested, \"vtable_auto_impl\");\n         ensure_sufficient_stack(|| {\n             let cause = obligation.derived_cause(BuiltinDerivedObligation);\n-            let mut obligations = self.collect_predicates_for_types(\n-                obligation.param_env,\n-                cause,\n-                obligation.recursion_depth + 1,\n-                trait_def_id,\n-                nested,\n-            );\n \n             let trait_obligations: Vec<PredicateObligation<'_>> =\n                 self.infcx.commit_unconditionally(|_| {\n                     let poly_trait_ref = obligation.predicate.to_poly_trait_ref();\n                     let trait_ref = self.infcx.replace_bound_vars_with_placeholders(poly_trait_ref);\n-                    let cause = obligation.derived_cause(ImplDerivedObligation);\n                     self.impl_or_trait_obligations(\n-                        cause,\n+                        &cause,\n                         obligation.recursion_depth + 1,\n                         obligation.param_env,\n                         trait_def_id,\n                         &trait_ref.substs,\n+                        obligation.predicate,\n                     )\n                 });\n \n+            let mut obligations = self.collect_predicates_for_types(\n+                obligation.param_env,\n+                cause,\n+                obligation.recursion_depth + 1,\n+                trait_def_id,\n+                nested,\n+            );\n+\n             // Adds the predicates from the trait.  Note that this contains a `Self: Trait`\n             // predicate as usual.  It won't have any effect since auto traits are coinductive.\n             obligations.extend(trait_obligations);\n@@ -365,14 +359,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         self.infcx.commit_unconditionally(|_| {\n             let substs = self.rematch_impl(impl_def_id, obligation);\n             debug!(?substs, \"impl substs\");\n-            let cause = obligation.derived_cause(ImplDerivedObligation);\n             ensure_sufficient_stack(|| {\n                 self.vtable_impl(\n                     impl_def_id,\n                     substs,\n-                    cause,\n+                    &obligation.cause,\n                     obligation.recursion_depth + 1,\n                     obligation.param_env,\n+                    obligation.predicate,\n                 )\n             })\n         })\n@@ -382,9 +376,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         &mut self,\n         impl_def_id: DefId,\n         substs: Normalized<'tcx, SubstsRef<'tcx>>,\n-        cause: ObligationCause<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n+        parent_trait_pred: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n     ) -> ImplSourceUserDefinedData<'tcx, PredicateObligation<'tcx>> {\n         debug!(?impl_def_id, ?substs, ?recursion_depth, \"vtable_impl\");\n \n@@ -394,6 +389,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             param_env,\n             impl_def_id,\n             &substs.value,\n+            parent_trait_pred,\n         );\n \n         debug!(?impl_obligations, \"vtable_impl\");\n@@ -566,11 +562,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             let substs = trait_ref.substs;\n \n             let trait_obligations = self.impl_or_trait_obligations(\n-                obligation.cause.clone(),\n+                &obligation.cause,\n                 obligation.recursion_depth,\n                 obligation.param_env,\n                 trait_def_id,\n                 &substs,\n+                obligation.predicate,\n             );\n \n             debug!(?trait_def_id, ?trait_obligations, \"trait alias obligations\");\n@@ -1073,14 +1070,30 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 });\n                 let substs = self.rematch_impl(impl_def_id, &new_obligation);\n                 debug!(?substs, \"impl substs\");\n-                let cause = obligation.derived_cause(ImplDerivedObligation);\n+\n+                let derived = DerivedObligationCause {\n+                    parent_trait_pred: obligation.predicate,\n+                    parent_code: obligation.cause.clone_code(),\n+                };\n+                let derived_code = ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                    derived,\n+                    impl_def_id,\n+                    span: obligation.cause.span,\n+                }));\n+\n+                let cause = ObligationCause::new(\n+                    obligation.cause.span,\n+                    obligation.cause.body_id,\n+                    derived_code,\n+                );\n                 ensure_sufficient_stack(|| {\n                     self.vtable_impl(\n                         impl_def_id,\n                         substs,\n-                        cause,\n+                        &cause,\n                         new_obligation.recursion_depth + 1,\n                         new_obligation.param_env,\n+                        obligation.predicate,\n                     )\n                 })\n             });"}, {"sha": "c15afa33d2b982d10f117b6b1c4aab4675a103cc", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -13,15 +13,11 @@ use super::project::ProjectionTyObligation;\n use super::util;\n use super::util::{closure_trait_ref_and_return_type, predicate_for_trait_def};\n use super::wf;\n-use super::DerivedObligationCause;\n-use super::Normalized;\n-use super::Obligation;\n-use super::ObligationCauseCode;\n-use super::Selection;\n-use super::SelectionResult;\n-use super::TraitQueryMode;\n-use super::{ErrorReporting, Overflow, SelectionError};\n-use super::{ObligationCause, PredicateObligation, TraitObligation};\n+use super::{\n+    DerivedObligationCause, ErrorReporting, ImplDerivedObligation, ImplDerivedObligationCause,\n+    Normalized, Obligation, ObligationCause, ObligationCauseCode, Overflow, PredicateObligation,\n+    Selection, SelectionError, SelectionResult, TraitObligation, TraitQueryMode,\n+};\n \n use crate::infer::{InferCtxt, InferOk, TypeFreshener};\n use crate::traits::error_reporting::InferCtxtExt;\n@@ -2333,11 +2329,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[tracing::instrument(level = \"debug\", skip(self, cause, param_env))]\n     fn impl_or_trait_obligations(\n         &mut self,\n-        cause: ObligationCause<'tcx>,\n+        cause: &ObligationCause<'tcx>,\n         recursion_depth: usize,\n         param_env: ty::ParamEnv<'tcx>,\n         def_id: DefId,           // of impl or trait\n         substs: SubstsRef<'tcx>, // for impl or trait\n+        parent_trait_pred: ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,\n     ) -> Vec<PredicateObligation<'tcx>> {\n         let tcx = self.tcx();\n \n@@ -2359,8 +2356,17 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?predicates);\n         assert_eq!(predicates.parent, None);\n         let mut obligations = Vec::with_capacity(predicates.predicates.len());\n-        for (predicate, _) in predicates.predicates {\n-            debug!(?predicate);\n+        let parent_code = cause.clone_code();\n+        for (predicate, span) in predicates.predicates {\n+            let span = *span;\n+            let derived =\n+                DerivedObligationCause { parent_trait_pred, parent_code: parent_code.clone() };\n+            let code = ImplDerivedObligation(Box::new(ImplDerivedObligationCause {\n+                derived,\n+                impl_def_id: def_id,\n+                span,\n+            }));\n+            let cause = ObligationCause::new(cause.span, cause.body_id, code);\n             let predicate = normalize_with_depth_to(\n                 self,\n                 param_env,\n@@ -2369,12 +2375,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 predicate.subst(tcx, substs),\n                 &mut obligations,\n             );\n-            obligations.push(Obligation {\n-                cause: cause.clone(),\n-                recursion_depth,\n-                param_env,\n-                predicate,\n-            });\n+            obligations.push(Obligation { cause, recursion_depth, param_env, predicate });\n         }\n \n         obligations"}, {"sha": "a22c9210a9c22020bfdf31f88f0242cd3ac3c407", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -227,8 +227,14 @@ fn compare_predicate_entailment<'tcx>(\n                 traits::normalize(&mut selcx, param_env, normalize_cause, predicate);\n \n             inh.register_predicates(obligations);\n-            let mut cause = cause.clone();\n-            cause.span = span;\n+            let cause = ObligationCause::new(\n+                span,\n+                impl_m_hir_id,\n+                ObligationCauseCode::CompareImplMethodObligation {\n+                    impl_item_def_id: impl_m.def_id,\n+                    trait_item_def_id: trait_m.def_id,\n+                },\n+            );\n             inh.register_predicate(traits::Obligation::new(cause, param_env, predicate));\n         }\n "}, {"sha": "b7b45929e1463c46604a6937fd6501a3eb597b69", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -1087,8 +1087,10 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let mut result_code = code.clone();\n                 loop {\n                     let parent = match &*code {\n+                        ObligationCauseCode::ImplDerivedObligation(c) => {\n+                            c.derived.parent_code.clone()\n+                        }\n                         ObligationCauseCode::BuiltinDerivedObligation(c)\n-                        | ObligationCauseCode::ImplDerivedObligation(c)\n                         | ObligationCauseCode::DerivedObligation(c) => c.parent_code.clone(),\n                         _ => break,\n                     };\n@@ -1098,10 +1100,12 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             let self_: ty::subst::GenericArg<'_> = match &*unpeel_to_top(error.obligation.cause.clone_code()) {\n                 ObligationCauseCode::BuiltinDerivedObligation(code) |\n-                ObligationCauseCode::ImplDerivedObligation(code) |\n                 ObligationCauseCode::DerivedObligation(code) => {\n                     code.parent_trait_pred.self_ty().skip_binder().into()\n                 }\n+                ObligationCauseCode::ImplDerivedObligation(code) => {\n+                    code.derived.parent_trait_pred.self_ty().skip_binder().into()\n+                }\n                 _ if let ty::PredicateKind::Trait(predicate) =\n                     error.obligation.predicate.kind().skip_binder() => {\n                         predicate.self_ty().into()"}, {"sha": "704866c2cc2accf2aa3b6a5244dc3e7cad54ee7a", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -1521,6 +1521,8 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n             let selcx = &mut traits::SelectionContext::new(self);\n             let cause = traits::ObligationCause::misc(self.span, self.body_id);\n \n+            let mut parent_pred = None;\n+\n             // If so, impls may carry other conditions (e.g., where\n             // clauses) that must be considered. Make sure that those\n             // match as well (or at least may match, sometimes we\n@@ -1584,6 +1586,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                     }\n                     let predicate =\n                         ty::Binder::dummy(trait_ref).without_const().to_predicate(self.tcx);\n+                    parent_pred = Some(predicate);\n                     let obligation = traits::Obligation::new(cause, self.param_env, predicate);\n                     if !self.predicate_may_hold(&obligation) {\n                         result = ProbeResult::NoMatch;\n@@ -1639,7 +1642,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 let o = self.resolve_vars_if_possible(o);\n                 if !self.predicate_may_hold(&o) {\n                     result = ProbeResult::NoMatch;\n-                    possibly_unsatisfied_predicates.push((o.predicate, None, Some(o.cause)));\n+                    possibly_unsatisfied_predicates.push((o.predicate, parent_pred, Some(o.cause)));\n                 }\n             }\n "}, {"sha": "9c3f2da56442fdce283adf63cd05e3139bf2d150", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 152, "deletions": 65, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -16,9 +16,8 @@ use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::print::with_crate_prefix;\n use rustc_middle::ty::ToPolyTraitRef;\n use rustc_middle::ty::{self, DefIdTree, ToPredicate, Ty, TyCtxt, TypeFoldable};\n-use rustc_span::lev_distance;\n use rustc_span::symbol::{kw, sym, Ident};\n-use rustc_span::{source_map, FileName, MultiSpan, Span};\n+use rustc_span::{lev_distance, source_map, ExpnKind, FileName, MacroKind, MultiSpan, Span};\n use rustc_trait_selection::traits::error_reporting::on_unimplemented::InferCtxtExt as _;\n use rustc_trait_selection::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc_trait_selection::traits::{\n@@ -723,102 +722,190 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // Find all the requirements that come from a local `impl` block.\n                     let mut skip_list: FxHashSet<_> = Default::default();\n                     let mut spanned_predicates: FxHashMap<MultiSpan, _> = Default::default();\n-                    for (data, p, parent_p) in unsatisfied_predicates\n+                    for (data, p, parent_p, impl_def_id, cause_span) in unsatisfied_predicates\n                         .iter()\n                         .filter_map(|(p, parent, c)| c.as_ref().map(|c| (p, parent, c)))\n                         .filter_map(|(p, parent, c)| match c.code() {\n                             ObligationCauseCode::ImplDerivedObligation(ref data) => {\n-                                Some((data, p, parent))\n+                                Some((&data.derived, p, parent, data.impl_def_id, data.span))\n                             }\n                             _ => None,\n                         })\n                     {\n                         let parent_trait_ref = data.parent_trait_pred;\n-                        let parent_def_id = parent_trait_ref.def_id();\n                         let path = parent_trait_ref.print_modifiers_and_trait_path();\n                         let tr_self_ty = parent_trait_ref.skip_binder().self_ty();\n-                        let mut candidates = vec![];\n-                        self.tcx.for_each_relevant_impl(\n-                            parent_def_id,\n-                            parent_trait_ref.self_ty().skip_binder(),\n-                            |impl_def_id| match self.tcx.hir().get_if_local(impl_def_id) {\n-                                Some(Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Impl(hir::Impl { .. }),\n-                                    ..\n-                                })) => {\n-                                    candidates.push(impl_def_id);\n+                        let unsatisfied_msg = \"unsatisfied trait bound introduced here\".to_string();\n+                        let derive_msg =\n+                            \"unsatisfied trait bound introduced in this `derive` macro\";\n+                        match self.tcx.hir().get_if_local(impl_def_id) {\n+                            // Unmet obligation comes from a `derive` macro, point at it once to\n+                            // avoid multiple span labels pointing at the same place.\n+                            Some(Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Trait(..),\n+                                ident,\n+                                ..\n+                            })) if matches!(\n+                                ident.span.ctxt().outer_expn_data().kind,\n+                                ExpnKind::Macro(MacroKind::Derive, _)\n+                            ) =>\n+                            {\n+                                let span = ident.span.ctxt().outer_expn_data().call_site;\n+                                let mut spans: MultiSpan = span.into();\n+                                spans.push_span_label(span, derive_msg.to_string());\n+                                let entry = spanned_predicates.entry(spans);\n+                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                            }\n+\n+                            Some(Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                                ..\n+                            })) if matches!(\n+                                self_ty.span.ctxt().outer_expn_data().kind,\n+                                ExpnKind::Macro(MacroKind::Derive, _)\n+                            ) || matches!(\n+                                of_trait.as_ref().map(|t| t\n+                                    .path\n+                                    .span\n+                                    .ctxt()\n+                                    .outer_expn_data()\n+                                    .kind),\n+                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n+                            ) =>\n+                            {\n+                                let span = self_ty.span.ctxt().outer_expn_data().call_site;\n+                                let mut spans: MultiSpan = span.into();\n+                                spans.push_span_label(span, derive_msg.to_string());\n+                                let entry = spanned_predicates.entry(spans.into());\n+                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                            }\n+\n+                            // Unmet obligation coming from a `trait`.\n+                            Some(Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Trait(..),\n+                                ident,\n+                                span: item_span,\n+                                ..\n+                            })) if !matches!(\n+                                ident.span.ctxt().outer_expn_data().kind,\n+                                ExpnKind::Macro(MacroKind::Derive, _)\n+                            ) =>\n+                            {\n+                                if let Some(pred) = parent_p {\n+                                    // Done to add the \"doesn't satisfy\" `span_label`.\n+                                    let _ = format_pred(*pred);\n                                 }\n-                                _ => {}\n-                            },\n-                        );\n-                        if let [def_id] = &candidates[..] {\n-                            match self.tcx.hir().get_if_local(*def_id) {\n-                                Some(Node::Item(hir::Item {\n-                                    kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n-                                    ..\n-                                })) => {\n-                                    if let Some(pred) = parent_p {\n-                                        // Done to add the \"doesn't satisfy\" `span_label`.\n-                                        let _ = format_pred(*pred);\n-                                    }\n-                                    skip_list.insert(p);\n+                                skip_list.insert(p);\n+                                let mut spans = if cause_span != *item_span {\n+                                    let mut spans: MultiSpan = cause_span.into();\n+                                    spans.push_span_label(cause_span, unsatisfied_msg);\n+                                    spans\n+                                } else {\n+                                    ident.span.into()\n+                                };\n+                                spans.push_span_label(ident.span, \"in this trait\".to_string());\n+                                let entry = spanned_predicates.entry(spans.into());\n+                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n+                            }\n+\n+                            // Unmet obligation coming from an `impl`.\n+                            Some(Node::Item(hir::Item {\n+                                kind: hir::ItemKind::Impl(hir::Impl { of_trait, self_ty, .. }),\n+                                span: item_span,\n+                                ..\n+                            })) if !matches!(\n+                                self_ty.span.ctxt().outer_expn_data().kind,\n+                                ExpnKind::Macro(MacroKind::Derive, _)\n+                            ) && !matches!(\n+                                of_trait.as_ref().map(|t| t\n+                                    .path\n+                                    .span\n+                                    .ctxt()\n+                                    .outer_expn_data()\n+                                    .kind),\n+                                Some(ExpnKind::Macro(MacroKind::Derive, _))\n+                            ) =>\n+                            {\n+                                if let Some(pred) = parent_p {\n+                                    // Done to add the \"doesn't satisfy\" `span_label`.\n+                                    let _ = format_pred(*pred);\n+                                }\n+                                skip_list.insert(p);\n+                                let mut spans = if cause_span != *item_span {\n+                                    let mut spans: MultiSpan = cause_span.into();\n+                                    spans.push_span_label(cause_span, unsatisfied_msg);\n+                                    spans\n+                                } else {\n                                     let mut spans = Vec::with_capacity(2);\n                                     if let Some(trait_ref) = of_trait {\n                                         spans.push(trait_ref.path.span);\n                                     }\n                                     spans.push(self_ty.span);\n-                                    let entry = spanned_predicates.entry(spans.into());\n-                                    entry\n-                                        .or_insert_with(|| (path, tr_self_ty, Vec::new()))\n-                                        .2\n-                                        .push(p);\n+                                    spans.into()\n+                                };\n+                                if let Some(trait_ref) = of_trait {\n+                                    spans.push_span_label(trait_ref.path.span, String::new());\n                                 }\n-                                _ => {}\n+                                spans.push_span_label(self_ty.span, String::new());\n+\n+                                let entry = spanned_predicates.entry(spans.into());\n+                                entry.or_insert_with(|| (path, tr_self_ty, Vec::new())).2.push(p);\n                             }\n+                            _ => {}\n                         }\n                     }\n-                    for (span, (path, self_ty, preds)) in spanned_predicates {\n-                        err.span_note(\n-                            span,\n-                            &format!(\n-                                \"the following trait bounds were not satisfied because of the \\\n-                                 requirements of the implementation of `{}` for `{}`:\\n{}\",\n-                                path,\n-                                self_ty,\n-                                preds\n-                                    .into_iter()\n-                                    // .map(|pred| format!(\"{:?}\", pred))\n-                                    .filter_map(|pred| format_pred(*pred))\n-                                    .map(|(p, _)| format!(\"`{}`\", p))\n-                                    .collect::<Vec<_>>()\n-                                    .join(\"\\n\"),\n-                            ),\n-                        );\n+                    let mut spanned_predicates: Vec<_> = spanned_predicates.into_iter().collect();\n+                    spanned_predicates.sort_by_key(|(span, (_, _, _))| span.primary_span());\n+                    for (span, (_path, _self_ty, preds)) in spanned_predicates {\n+                        let mut preds: Vec<_> = preds\n+                            .into_iter()\n+                            .filter_map(|pred| format_pred(*pred))\n+                            .map(|(p, _)| format!(\"`{}`\", p))\n+                            .collect();\n+                        preds.sort();\n+                        preds.dedup();\n+                        let msg = if let [pred] = &preds[..] {\n+                            format!(\"trait bound {} was not satisfied\", pred)\n+                        } else {\n+                            format!(\n+                                \"the following trait bounds were not satisfied:\\n{}\",\n+                                preds.join(\"\\n\"),\n+                            )\n+                        };\n+                        err.span_note(span, &msg);\n+                        unsatisfied_bounds = true;\n                     }\n \n                     // The requirements that didn't have an `impl` span to show.\n                     let mut bound_list = unsatisfied_predicates\n                         .iter()\n-                        .filter(|(pred, _, _parent_pred)| !skip_list.contains(&pred))\n                         .filter_map(|(pred, parent_pred, _cause)| {\n                             format_pred(*pred).map(|(p, self_ty)| {\n                                 collect_type_param_suggestions(self_ty, *pred, &p);\n-                                match parent_pred {\n-                                    None => format!(\"`{}`\", &p),\n-                                    Some(parent_pred) => match format_pred(*parent_pred) {\n+                                (\n+                                    match parent_pred {\n                                         None => format!(\"`{}`\", &p),\n-                                        Some((parent_p, _)) => {\n-                                            collect_type_param_suggestions(\n-                                                self_ty,\n-                                                *parent_pred,\n-                                                &p,\n-                                            );\n-                                            format!(\"`{}`\\nwhich is required by `{}`\", p, parent_p)\n-                                        }\n+                                        Some(parent_pred) => match format_pred(*parent_pred) {\n+                                            None => format!(\"`{}`\", &p),\n+                                            Some((parent_p, _)) => {\n+                                                collect_type_param_suggestions(\n+                                                    self_ty,\n+                                                    *parent_pred,\n+                                                    &p,\n+                                                );\n+                                                format!(\n+                                                    \"`{}`\\nwhich is required by `{}`\",\n+                                                    p, parent_p\n+                                                )\n+                                            }\n+                                        },\n                                     },\n-                                }\n+                                    *pred,\n+                                )\n                             })\n                         })\n+                        .filter(|(_, pred)| !skip_list.contains(&pred))\n+                        .map(|(t, _)| t)\n                         .enumerate()\n                         .collect::<Vec<(usize, String)>>();\n "}, {"sha": "d0c4726bb0a8c41193c3b3d7b20c8a055fec3852", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -58,6 +58,7 @@ This API is completely unstable and subject to change.\n #![allow(rustc::potential_query_instability)]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(bool_to_option)]\n+#![feature(box_patterns)]\n #![feature(control_flow_enum)]\n #![feature(crate_visibility_modifier)]\n #![feature(hash_drain_filter)]"}, {"sha": "72dd9c153ab0df9b6673ee332986835d8c02fbf0", "filename": "src/test/ui/derives/derive-assoc-type-not-impl.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderives%2Fderive-assoc-type-not-impl.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -13,16 +13,17 @@ LL | struct NotClone;\n LL |     Bar::<NotClone> { x: 1 }.clone();\n    |                              ^^^^^ method cannot be called on `Bar<NotClone>` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `Clone` for `_`:\n-      `NotClone: Clone`\n+note: trait bound `NotClone: Clone` was not satisfied\n   --> $DIR/derive-assoc-type-not-impl.rs:6:10\n    |\n LL | #[derive(Clone)]\n-   |          ^^^^^\n+   |          ^^^^^ unsatisfied trait bound introduced in this `derive` macro\n+   = note: the following trait bounds were not satisfied:\n+           `NotClone: Clone`\n+           which is required by `Bar<NotClone>: Clone`\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-   = note: this error originates in the derive macro `Clone` (in Nightly builds, run with -Z macro-backtrace for more info)\n help: consider annotating `NotClone` with `#[derive(Clone)]`\n    |\n LL | #[derive(Clone)]"}, {"sha": "655abd18da1cb08192cfc6eb963d9ec1dd71e65e", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.rs?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -12,7 +12,10 @@ trait M {\n }\n \n impl<T: X<Y<i32> = i32>> M for T {}\n-//~^ NOTE the following trait bounds were not satisfied\n+//~^ NOTE trait bound `<S as X>::Y<i32> = i32` was not satisfied\n+//~| NOTE unsatisfied trait bound introduced here\n+//~| NOTE\n+//~| NOTE\n \n struct S;\n //~^ NOTE method `f` not found for this"}, {"sha": "9eeebd80afecb010e8829462946be1bed2a5848f", "filename": "src/test/ui/generic-associated-types/method-unsatified-assoc-type-predicate.stderr", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgeneric-associated-types%2Fmethod-unsatified-assoc-type-predicate.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -1,5 +1,5 @@\n error[E0599]: the method `f` exists for struct `S`, but its trait bounds were not satisfied\n-  --> $DIR/method-unsatified-assoc-type-predicate.rs:27:7\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:30:7\n    |\n LL | struct S;\n    | ---------\n@@ -11,12 +11,13 @@ LL | struct S;\n LL |     a.f();\n    |       ^ method cannot be called on `S` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `M` for `_`:\n-      `<S as X>::Y<i32> = i32`\n-  --> $DIR/method-unsatified-assoc-type-predicate.rs:14:26\n+note: trait bound `<S as X>::Y<i32> = i32` was not satisfied\n+  --> $DIR/method-unsatified-assoc-type-predicate.rs:14:11\n    |\n LL | impl<T: X<Y<i32> = i32>> M for T {}\n-   |                          ^     ^\n+   |           ^^^^^^^^^^^^   -     -\n+   |           |\n+   |           unsatisfied trait bound introduced here\n \n error: aborting due to previous error\n "}, {"sha": "7ffe2f4cd7e1ce2c354f7349fdfa3b118cb1e8ca", "filename": "src/test/ui/hrtb/issue-30786.migrate.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.migrate.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -10,14 +10,14 @@ LL | pub struct Map<S, F> {\n LL |     let filter = map.filterx(|x: &_| true);\n    |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+note: the following trait bounds were not satisfied:\n       `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n       `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n-  --> $DIR/issue-30786.rs:105:9\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+  --> $DIR/issue-30786.rs:105:50\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n-   |         ^^^^^^^^^     ^\n+   |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -31,14 +31,14 @@ LL | pub struct Filter<S, F> {\n LL |     let count = filter.countx();\n    |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+note: the following trait bounds were not satisfied:\n       `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n       `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n-  --> $DIR/issue-30786.rs:105:9\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+  --> $DIR/issue-30786.rs:105:50\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n-   |         ^^^^^^^^^     ^\n+   |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "7ffe2f4cd7e1ce2c354f7349fdfa3b118cb1e8ca", "filename": "src/test/ui/hrtb/issue-30786.nll.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fissue-30786.nll.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -10,14 +10,14 @@ LL | pub struct Map<S, F> {\n LL |     let filter = map.filterx(|x: &_| true);\n    |                      ^^^^^^^ method cannot be called on `Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+note: the following trait bounds were not satisfied:\n       `&'a mut &Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n       `&'a mut &mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n-  --> $DIR/issue-30786.rs:105:9\n+      `&'a mut Map<Repeat, [closure@$DIR/issue-30786.rs:126:27: 126:36]>: Stream`\n+  --> $DIR/issue-30786.rs:105:50\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n-   |         ^^^^^^^^^     ^\n+   |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n error[E0599]: the method `countx` exists for struct `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>`, but its trait bounds were not satisfied\n   --> $DIR/issue-30786.rs:140:24\n@@ -31,14 +31,14 @@ LL | pub struct Filter<S, F> {\n LL |     let count = filter.countx();\n    |                        ^^^^^^ method cannot be called on `Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `StreamExt` for `_`:\n-      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+note: the following trait bounds were not satisfied:\n       `&'a mut &Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n       `&'a mut &mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n-  --> $DIR/issue-30786.rs:105:9\n+      `&'a mut Filter<Map<Repeat, for<'r> fn(&'r u64) -> &'r u64 {identity::<u64>}>, [closure@$DIR/issue-30786.rs:139:30: 139:42]>: Stream`\n+  --> $DIR/issue-30786.rs:105:50\n    |\n LL | impl<T> StreamExt for T where for<'a> &'a mut T: Stream {}\n-   |         ^^^^^^^^^     ^\n+   |         ---------     -                          ^^^^^^ unsatisfied trait bound introduced here\n \n error: aborting due to 2 previous errors\n "}, {"sha": "f3c6b39e62ed0fc9b406edb56f2a7c21d394b230", "filename": "src/test/ui/missing-trait-bounds/missing-trait-bounds-for-method-call.stderr", "status": "modified", "additions": 21, "deletions": 8, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fmissing-trait-bounds%2Fmissing-trait-bounds-for-method-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fmissing-trait-bounds%2Fmissing-trait-bounds-for-method-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing-trait-bounds%2Fmissing-trait-bounds-for-method-call.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -7,11 +7,20 @@ LL | struct Foo<T> {\n LL |         self.foo();\n    |              ^^^ method cannot be called on `&Foo<T>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `T: Default`\n-           which is required by `Foo<T>: Bar`\n-           `T: Bar`\n-           which is required by `Foo<T>: Bar`\n+note: trait bound `T: Default` was not satisfied\n+  --> $DIR/missing-trait-bounds-for-method-call.rs:10:9\n+   |\n+LL | impl<T: Default + Bar> Bar for Foo<T> {}\n+   |         ^^^^^^^        ---     ------\n+   |         |\n+   |         unsatisfied trait bound introduced here\n+note: trait bound `T: Bar` was not satisfied\n+  --> $DIR/missing-trait-bounds-for-method-call.rs:10:19\n+   |\n+LL | impl<T: Default + Bar> Bar for Foo<T> {}\n+   |                   ^^^  ---     ------\n+   |                   |\n+   |                   unsatisfied trait bound introduced here\n help: consider restricting the type parameters to satisfy the trait bounds\n    |\n LL | struct Foo<T> where T: Bar, T: Default {\n@@ -26,9 +35,13 @@ LL | struct Fin<T> where T: Bar {\n LL |         self.foo();\n    |              ^^^ method cannot be called on `&Fin<T>` due to unsatisfied trait bounds\n    |\n-   = note: the following trait bounds were not satisfied:\n-           `T: Default`\n-           which is required by `Fin<T>: Bar`\n+note: trait bound `T: Default` was not satisfied\n+  --> $DIR/missing-trait-bounds-for-method-call.rs:23:9\n+   |\n+LL | impl<T: Default + Bar> Bar for Fin<T> {}\n+   |         ^^^^^^^        ---     ------\n+   |         |\n+   |         unsatisfied trait bound introduced here\n help: consider restricting the type parameter to satisfy the trait bound\n    |\n LL | struct Fin<T> where T: Bar, T: Default {"}, {"sha": "9dbaffd4c15650d11339d1de3e3a6cbe99a811f1", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.precise.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.precise.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -54,6 +54,12 @@ LL |         const _: () = check($exp);\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Destruct`\n    |\n+note: required because of the requirements on the impl of `~const Destruct` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+  --> $DIR/const-drop-fail.rs:28:25\n+   |\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `~const Destruct` for `ConstDropImplWithBounds<NonTrivialDrop>`\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:34:19"}, {"sha": "9dbaffd4c15650d11339d1de3e3a6cbe99a811f1", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-drop-fail.stock.stderr", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-drop-fail.stock.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -54,6 +54,12 @@ LL |         const _: () = check($exp);\n LL |     ConstDropImplWithBounds::<NonTrivialDrop>(PhantomData),\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected an implementor of trait `~const Destruct`\n    |\n+note: required because of the requirements on the impl of `~const Destruct` for `ConstDropImplWithBounds<NonTrivialDrop>`\n+  --> $DIR/const-drop-fail.rs:28:25\n+   |\n+LL | impl<T: ~const A> const Drop for ConstDropImplWithBounds<T> {\n+   |                         ^^^^     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: 1 redundant requirement hidden\n    = note: required because of the requirements on the impl of `~const Destruct` for `ConstDropImplWithBounds<NonTrivialDrop>`\n note: required by a bound in `check`\n   --> $DIR/const-drop-fail.rs:34:19"}, {"sha": "9894ecc64b518fdf12b9a8c38e532d3a1cd17af8", "filename": "src/test/ui/specialization/defaultimpl/specialization-trait-not-implemented.stderr", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefaultimpl%2Fspecialization-trait-not-implemented.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -20,8 +20,7 @@ LL | struct MyStruct;\n LL |     println!(\"{}\", MyStruct.foo_one());\n    |                             ^^^^^^^ method cannot be called on `MyStruct` due to unsatisfied trait bounds\n    |\n-note: the following trait bounds were not satisfied because of the requirements of the implementation of `Foo` for `_`:\n-      `MyStruct: Foo`\n+note: trait bound `MyStruct: Foo` was not satisfied\n   --> $DIR/specialization-trait-not-implemented.rs:14:17\n    |\n LL | default impl<T> Foo for T {"}, {"sha": "d0d00c97e83052d2eead2dc3939d24be35b58f61", "filename": "src/test/ui/traits/alias/cross-crate.stderr", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Ftraits%2Falias%2Fcross-crate.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Ftraits%2Falias%2Fcross-crate.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Falias%2Fcross-crate.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -5,6 +5,7 @@ LL |     use_alias::<Rc<u32>>();\n    |                 ^^^^^^^ `Rc<u32>` cannot be sent between threads safely\n    |\n    = help: the trait `Send` is not implemented for `Rc<u32>`\n+   = note: required because of the requirements on the impl of `SendSync` for `Rc<u32>`\n note: required by a bound in `use_alias`\n   --> $DIR/cross-crate.rs:10:17\n    |\n@@ -18,6 +19,7 @@ LL |     use_alias::<Rc<u32>>();\n    |                 ^^^^^^^ `Rc<u32>` cannot be shared between threads safely\n    |\n    = help: the trait `Sync` is not implemented for `Rc<u32>`\n+   = note: required because of the requirements on the impl of `SendSync` for `Rc<u32>`\n note: required by a bound in `use_alias`\n   --> $DIR/cross-crate.rs:10:17\n    |"}, {"sha": "9ceeea4872fbbf6b63a55ce490fa4485d40a26b5", "filename": "src/test/ui/traits/inductive-overflow/supertrait-auto-trait.stderr", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Finductive-overflow%2Fsupertrait-auto-trait.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -14,7 +14,11 @@ LL |     let (a, b) = copy(NoClone);\n    |                  |\n    |                  required by a bound introduced by this call\n    |\n-   = note: required because of the requirements on the impl of `Magic` for `NoClone`\n+note: required because of the requirements on the impl of `Magic` for `NoClone`\n+  --> $DIR/supertrait-auto-trait.rs:8:12\n+   |\n+LL | auto trait Magic: Copy {}\n+   |            ^^^^^\n note: required by a bound in `copy`\n   --> $DIR/supertrait-auto-trait.rs:10:12\n    |"}, {"sha": "de0bc7830b73a6bf51b4965f5f893a7be8569433", "filename": "src/test/ui/union/union-derive-clone.mirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.mirunsafeck.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -13,6 +13,11 @@ LL | struct CloneNoCopy;\n LL |     let w = u.clone();\n    |               ^^^^^ method cannot be called on `U5<CloneNoCopy>` due to unsatisfied trait bounds\n    |\n+note: trait bound `CloneNoCopy: Copy` was not satisfied\n+  --> $DIR/union-derive-clone.rs:28:10\n+   |\n+LL | #[derive(Clone, Copy)]\n+   |          ^^^^^ unsatisfied trait bound introduced in this `derive` macro\n    = note: the following trait bounds were not satisfied:\n            `CloneNoCopy: Copy`\n            which is required by `U5<CloneNoCopy>: Clone`"}, {"sha": "de0bc7830b73a6bf51b4965f5f893a7be8569433", "filename": "src/test/ui/union/union-derive-clone.thirunsafeck.stderr", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-derive-clone.thirunsafeck.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -13,6 +13,11 @@ LL | struct CloneNoCopy;\n LL |     let w = u.clone();\n    |               ^^^^^ method cannot be called on `U5<CloneNoCopy>` due to unsatisfied trait bounds\n    |\n+note: trait bound `CloneNoCopy: Copy` was not satisfied\n+  --> $DIR/union-derive-clone.rs:28:10\n+   |\n+LL | #[derive(Clone, Copy)]\n+   |          ^^^^^ unsatisfied trait bound introduced in this `derive` macro\n    = note: the following trait bounds were not satisfied:\n            `CloneNoCopy: Copy`\n            which is required by `U5<CloneNoCopy>: Clone`"}, {"sha": "0d9b9627562f94018a855643b81164448bacba4b", "filename": "src/test/ui/wf/hir-wf-check-erase-regions.stderr", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/5fd37862d95a7fd898342e49ae5273edc8886b83/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwf%2Fhir-wf-check-erase-regions.stderr?ref=5fd37862d95a7fd898342e49ae5273edc8886b83", "patch": "@@ -5,11 +5,7 @@ LL |     type IntoIter = std::iter::Flatten<std::slice::Iter<'a, T>>;\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n-note: required because of the requirements on the impl of `IntoIterator` for `&T`\n-  --> $DIR/hir-wf-check-erase-regions.rs:6:29\n-   |\n-LL | impl<'a, T, const N: usize> IntoIterator for &'a Table<T, N> {\n-   |                             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n    |\n@@ -23,11 +19,7 @@ LL |     fn into_iter(self) -> Self::IntoIter {\n    |                           ^^^^^^^^^^^^^^ `&T` is not an iterator\n    |\n    = help: the trait `Iterator` is not implemented for `&T`\n-note: required because of the requirements on the impl of `IntoIterator` for `&T`\n-  --> $DIR/hir-wf-check-erase-regions.rs:6:29\n-   |\n-LL | impl<'a, T, const N: usize> IntoIterator for &'a Table<T, N> {\n-   |                             ^^^^^^^^^^^^     ^^^^^^^^^^^^^^^\n+   = note: required because of the requirements on the impl of `IntoIterator` for `&T`\n note: required by a bound in `Flatten`\n   --> $SRC_DIR/core/src/iter/adapters/flatten.rs:LL:COL\n    |"}]}