{"sha": "68b17986c7c272d9be8df9a7abb9b162329b9d65", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4YjE3OTg2YzdjMjcyZDliZThkZjlhN2FiYjliMTYyMzI5YjlkNjU=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-21T17:54:04Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-10-22T15:57:00Z"}, "message": "Implement DNF-based `#[cfg]` introspection", "tree": {"sha": "82bd50239ada5dc6b9952f353c1e6acde07fe337", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/82bd50239ada5dc6b9952f353c1e6acde07fe337"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/68b17986c7c272d9be8df9a7abb9b162329b9d65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/68b17986c7c272d9be8df9a7abb9b162329b9d65", "html_url": "https://github.com/rust-lang/rust/commit/68b17986c7c272d9be8df9a7abb9b162329b9d65", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/68b17986c7c272d9be8df9a7abb9b162329b9d65/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "url": "https://api.github.com/repos/rust-lang/rust/commits/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0", "html_url": "https://github.com/rust-lang/rust/commit/2bc4c1ff31b6ef0ca1848a7ce12f981b93dcded0"}], "stats": {"total": 624, "additions": 622, "deletions": 2}, "files": [{"sha": "d435ec2ea057e0a4b4db4b9760320a80a8126e0d", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68b17986c7c272d9be8df9a7abb9b162329b9d65/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/68b17986c7c272d9be8df9a7abb9b162329b9d65/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=68b17986c7c272d9be8df9a7abb9b162329b9d65", "patch": "@@ -162,6 +162,7 @@ checksum = \"ed67cbde08356238e75fc4656be4749481eeffb09e19f320a25237d5221c985d\"\n name = \"cfg\"\n version = \"0.0.0\"\n dependencies = [\n+ \"expect-test\",\n  \"mbe\",\n  \"rustc-hash\",\n  \"syntax\","}, {"sha": "c68e391c1bd514183e73ad4a2fcacabb89d63740", "filename": "crates/cfg/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2FCargo.toml?ref=68b17986c7c272d9be8df9a7abb9b162329b9d65", "patch": "@@ -17,3 +17,4 @@ tt = { path = \"../tt\", version = \"0.0.0\" }\n [dev-dependencies]\n mbe = { path = \"../mbe\" }\n syntax = { path = \"../syntax\" }\n+expect-test = \"1.0\""}, {"sha": "3f12a3fa80c8778d5aca74fd74584bfcca41901c", "filename": "crates/cfg/src/cfg_expr.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fcfg_expr.rs?ref=68b17986c7c272d9be8df9a7abb9b162329b9d65", "patch": "@@ -2,12 +2,12 @@\n //!\n //! See: https://doc.rust-lang.org/reference/conditional-compilation.html#conditional-compilation\n \n-use std::slice::Iter as SliceIter;\n+use std::{fmt, slice::Iter as SliceIter};\n \n use tt::SmolStr;\n \n /// A simple configuration value passed in from the outside.\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+#[derive(Debug, Clone, PartialEq, Eq, Hash, Ord, PartialOrd)]\n pub enum CfgAtom {\n     /// eg. `#[cfg(test)]`\n     Flag(SmolStr),\n@@ -18,6 +18,37 @@ pub enum CfgAtom {\n     KeyValue { key: SmolStr, value: SmolStr },\n }\n \n+impl CfgAtom {\n+    /// Returns `true` when the atom comes from the target specification.\n+    ///\n+    /// If this returns `true`, then changing this atom requires changing the compilation target. If\n+    /// it returns `false`, the atom might come from a build script or the build system.\n+    pub fn is_target_defined(&self) -> bool {\n+        match self {\n+            CfgAtom::Flag(flag) => matches!(&**flag, \"unix\" | \"windows\"),\n+            CfgAtom::KeyValue { key, value: _ } => matches!(\n+                &**key,\n+                \"target_arch\"\n+                    | \"target_os\"\n+                    | \"target_env\"\n+                    | \"target_family\"\n+                    | \"target_endian\"\n+                    | \"target_pointer_width\"\n+                    | \"target_vendor\" // NOTE: `target_feature` is left out since it can be configured via `-Ctarget-feature`\n+            ),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for CfgAtom {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            CfgAtom::Flag(name) => write!(f, \"{}\", name),\n+            CfgAtom::KeyValue { key, value } => write!(f, \"{} = \\\"{}\\\"\", key, value),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n     Invalid,"}, {"sha": "35f946e6fd3836bc0186f63b8d933000cefb7acf", "filename": "crates/cfg/src/dnf.rs", "status": "added", "additions": 477, "deletions": 0, "changes": 477, "blob_url": "https://github.com/rust-lang/rust/blob/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Fdnf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Fdnf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Fdnf.rs?ref=68b17986c7c272d9be8df9a7abb9b162329b9d65", "patch": "@@ -0,0 +1,477 @@\n+//! Disjunctive Normal Form construction.\n+//!\n+//! Algorithm from <https://www.cs.drexel.edu/~jjohnson/2015-16/fall/CS270/Lectures/3/dnf.pdf>,\n+//! which would have been much easier to read if it used pattern matching. It's also missing the\n+//! entire \"distribute ANDs over ORs\" part, which is not trivial. Oh well.\n+//!\n+//! This is currently both messy and inefficient. Feel free to improve, there are unit tests.\n+\n+use std::fmt;\n+\n+use rustc_hash::FxHashSet;\n+\n+use crate::{CfgAtom, CfgDiff, CfgExpr, CfgOptions, InactiveReason};\n+\n+/// A `#[cfg]` directive in Disjunctive Normal Form (DNF).\n+pub struct DnfExpr {\n+    conjunctions: Vec<Conjunction>,\n+}\n+\n+impl DnfExpr {\n+    pub fn new(expr: CfgExpr) -> Self {\n+        let builder = Builder { expr: DnfExpr { conjunctions: Vec::new() } };\n+\n+        builder.lower(expr.clone())\n+    }\n+\n+    /// Computes a list of present or absent atoms in `opts` that cause this expression to evaluate\n+    /// to `false`.\n+    ///\n+    /// Note that flipping a subset of these atoms might be sufficient to make the whole expression\n+    /// evaluate to `true`. For that, see `compute_enable_hints`.\n+    ///\n+    /// Returns `None` when `self` is already true, or contains errors.\n+    pub fn why_inactive(&self, opts: &CfgOptions) -> Option<InactiveReason> {\n+        let mut res = InactiveReason { enabled: Vec::new(), disabled: Vec::new() };\n+\n+        for conj in &self.conjunctions {\n+            let mut conj_is_true = true;\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate == enabled {\n+                    // Literal is false, but needs to be true for this conjunction.\n+                    conj_is_true = false;\n+\n+                    if enabled {\n+                        res.enabled.push(atom.clone());\n+                    } else {\n+                        res.disabled.push(atom.clone());\n+                    }\n+                }\n+            }\n+\n+            if conj_is_true {\n+                // This expression is not actually inactive.\n+                return None;\n+            }\n+        }\n+\n+        res.enabled.sort_unstable();\n+        res.enabled.dedup();\n+        res.disabled.sort_unstable();\n+        res.disabled.dedup();\n+        Some(res)\n+    }\n+\n+    /// Returns `CfgDiff` objects that would enable this directive if applied to `opts`.\n+    pub fn compute_enable_hints<'a>(\n+        &'a self,\n+        opts: &'a CfgOptions,\n+    ) -> impl Iterator<Item = CfgDiff> + 'a {\n+        // A cfg is enabled if any of `self.conjunctions` evaluate to `true`.\n+\n+        self.conjunctions.iter().filter_map(move |conj| {\n+            let mut enable = FxHashSet::default();\n+            let mut disable = FxHashSet::default();\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = opts.enabled.contains(atom);\n+                if lit.negate && enabled {\n+                    disable.insert(atom.clone());\n+                }\n+                if !lit.negate && !enabled {\n+                    enable.insert(atom.clone());\n+                }\n+            }\n+\n+            // Check that this actually makes `conj` true.\n+            for lit in &conj.literals {\n+                let atom = lit.var.as_ref()?;\n+                let enabled = enable.contains(atom)\n+                    || (opts.enabled.contains(atom) && !disable.contains(atom));\n+                if enabled == lit.negate {\n+                    return None;\n+                }\n+            }\n+\n+            if enable.is_empty() && disable.is_empty() {\n+                return None;\n+            }\n+\n+            let mut diff = CfgDiff {\n+                enable: enable.into_iter().collect(),\n+                disable: disable.into_iter().collect(),\n+            };\n+\n+            // Undo the FxHashMap randomization for consistent output.\n+            diff.enable.sort_unstable();\n+            diff.disable.sort_unstable();\n+\n+            Some(diff)\n+        })\n+    }\n+}\n+\n+impl fmt::Display for DnfExpr {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.conjunctions.len() != 1 {\n+            write!(f, \"any(\")?;\n+        }\n+        for (i, conj) in self.conjunctions.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            write!(f, \"{}\", conj)?;\n+        }\n+        if self.conjunctions.len() != 1 {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+struct Conjunction {\n+    literals: Vec<Literal>,\n+}\n+\n+impl Conjunction {\n+    fn new(parts: Vec<CfgExpr>) -> Self {\n+        let mut literals = Vec::new();\n+        for part in parts {\n+            match part {\n+                CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                    literals.push(Literal::new(part));\n+                }\n+                CfgExpr::All(conj) => {\n+                    // Flatten.\n+                    literals.extend(Conjunction::new(conj).literals);\n+                }\n+                CfgExpr::Any(_) => unreachable!(\"disjunction in conjunction\"),\n+            }\n+        }\n+\n+        Self { literals }\n+    }\n+}\n+\n+impl fmt::Display for Conjunction {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.literals.len() != 1 {\n+            write!(f, \"all(\")?;\n+        }\n+        for (i, lit) in self.literals.iter().enumerate() {\n+            if i != 0 {\n+                f.write_str(\", \")?;\n+            }\n+\n+            write!(f, \"{}\", lit)?;\n+        }\n+        if self.literals.len() != 1 {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+struct Literal {\n+    negate: bool,\n+    var: Option<CfgAtom>, // None = Invalid\n+}\n+\n+impl Literal {\n+    fn new(expr: CfgExpr) -> Self {\n+        match expr {\n+            CfgExpr::Invalid => Self { negate: false, var: None },\n+            CfgExpr::Atom(atom) => Self { negate: false, var: Some(atom) },\n+            CfgExpr::Not(expr) => match *expr {\n+                CfgExpr::Invalid => Self { negate: true, var: None },\n+                CfgExpr::Atom(atom) => Self { negate: true, var: Some(atom) },\n+                _ => unreachable!(\"non-atom {:?}\", expr),\n+            },\n+            CfgExpr::Any(_) | CfgExpr::All(_) => unreachable!(\"non-literal {:?}\", expr),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Literal {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if self.negate {\n+            write!(f, \"not(\")?;\n+        }\n+\n+        match &self.var {\n+            Some(var) => write!(f, \"{}\", var)?,\n+            None => f.write_str(\"<invalid>\")?,\n+        }\n+\n+        if self.negate {\n+            write!(f, \")\")?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+struct Builder {\n+    expr: DnfExpr,\n+}\n+\n+impl Builder {\n+    fn lower(mut self, expr: CfgExpr) -> DnfExpr {\n+        let expr = make_nnf(expr);\n+        let expr = make_dnf(expr);\n+\n+        match expr {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => {\n+                self.expr.conjunctions.push(Conjunction::new(vec![expr]));\n+            }\n+            CfgExpr::All(conj) => {\n+                self.expr.conjunctions.push(Conjunction::new(conj));\n+            }\n+            CfgExpr::Any(mut disj) => {\n+                disj.reverse();\n+                while let Some(conj) = disj.pop() {\n+                    match conj {\n+                        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::All(_) | CfgExpr::Not(_) => {\n+                            self.expr.conjunctions.push(Conjunction::new(vec![conj]));\n+                        }\n+                        CfgExpr::Any(inner_disj) => {\n+                            // Flatten.\n+                            disj.extend(inner_disj.into_iter().rev());\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        self.expr\n+    }\n+}\n+\n+fn make_dnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) | CfgExpr::Not(_) => expr,\n+        CfgExpr::Any(e) => CfgExpr::Any(e.into_iter().map(|expr| make_dnf(expr)).collect()),\n+        CfgExpr::All(e) => {\n+            let e = e.into_iter().map(|expr| make_nnf(expr)).collect::<Vec<_>>();\n+\n+            CfgExpr::Any(distribute_conj(&e))\n+        }\n+    }\n+}\n+\n+/// Turns a conjunction of expressions into a disjunction of expressions.\n+fn distribute_conj(conj: &[CfgExpr]) -> Vec<CfgExpr> {\n+    fn go(out: &mut Vec<CfgExpr>, with: &mut Vec<CfgExpr>, rest: &[CfgExpr]) {\n+        match rest {\n+            [head, tail @ ..] => match head {\n+                CfgExpr::Any(disj) => {\n+                    for part in disj {\n+                        with.push(part.clone());\n+                        go(out, with, tail);\n+                        with.pop();\n+                    }\n+                }\n+                _ => {\n+                    with.push(head.clone());\n+                    go(out, with, tail);\n+                    with.pop();\n+                }\n+            },\n+            _ => {\n+                // Turn accumulated parts into a new conjunction.\n+                out.push(CfgExpr::All(with.clone()));\n+            }\n+        }\n+    }\n+\n+    let mut out = Vec::new();\n+    let mut with = Vec::new();\n+\n+    go(&mut out, &mut with, conj);\n+\n+    out\n+}\n+\n+fn make_nnf(expr: CfgExpr) -> CfgExpr {\n+    match expr {\n+        CfgExpr::Invalid | CfgExpr::Atom(_) => expr,\n+        CfgExpr::Any(expr) => CfgExpr::Any(expr.into_iter().map(|expr| make_nnf(expr)).collect()),\n+        CfgExpr::All(expr) => CfgExpr::All(expr.into_iter().map(|expr| make_nnf(expr)).collect()),\n+        CfgExpr::Not(operand) => match *operand {\n+            CfgExpr::Invalid | CfgExpr::Atom(_) => CfgExpr::Not(operand.clone()), // Original negated expr\n+            CfgExpr::Not(expr) => {\n+                // Remove double negation.\n+                make_nnf(*expr)\n+            }\n+            // Convert negated conjunction/disjunction using DeMorgan's Law.\n+            CfgExpr::Any(inner) => CfgExpr::All(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+            CfgExpr::All(inner) => CfgExpr::Any(\n+                inner.into_iter().map(|expr| make_nnf(CfgExpr::Not(Box::new(expr)))).collect(),\n+            ),\n+        },\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use expect_test::{expect, Expect};\n+    use mbe::ast_to_token_tree;\n+    use syntax::{ast, AstNode};\n+\n+    use super::*;\n+\n+    fn check_dnf(input: &str, expect: Expect) {\n+        let (tt, _) = {\n+            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            ast_to_token_tree(&tt).unwrap()\n+        };\n+        let cfg = CfgExpr::parse(&tt);\n+        let actual = format!(\"#![cfg({})]\", DnfExpr::new(cfg));\n+        expect.assert_eq(&actual);\n+    }\n+\n+    fn check_why_inactive(input: &str, opts: &CfgOptions, expect: Expect) {\n+        let (tt, _) = {\n+            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            ast_to_token_tree(&tt).unwrap()\n+        };\n+        let cfg = CfgExpr::parse(&tt);\n+        let dnf = DnfExpr::new(cfg);\n+        let why_inactive = dnf.why_inactive(opts).unwrap().to_string();\n+        expect.assert_eq(&why_inactive);\n+    }\n+\n+    #[track_caller]\n+    fn check_enable_hints(input: &str, opts: &CfgOptions, expected_hints: &[&str]) {\n+        let (tt, _) = {\n+            let source_file = ast::SourceFile::parse(input).ok().unwrap();\n+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            ast_to_token_tree(&tt).unwrap()\n+        };\n+        let cfg = CfgExpr::parse(&tt);\n+        let dnf = DnfExpr::new(cfg);\n+        let hints = dnf.compute_enable_hints(opts).map(|diff| diff.to_string()).collect::<Vec<_>>();\n+        assert_eq!(hints, expected_hints);\n+    }\n+\n+    #[test]\n+    fn smoke() {\n+        check_dnf(\"#![cfg(test)]\", expect![[r#\"#![cfg(test)]\"#]]);\n+        check_dnf(\"#![cfg(not(test))]\", expect![[r#\"#![cfg(not(test))]\"#]]);\n+        check_dnf(\"#![cfg(not(not(test)))]\", expect![[r#\"#![cfg(test)]\"#]]);\n+\n+        check_dnf(\"#![cfg(all(a, b))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+        check_dnf(\"#![cfg(any(a, b))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+\n+        check_dnf(\"#![cfg(not(a))]\", expect![[r#\"#![cfg(not(a))]\"#]]);\n+    }\n+\n+    #[test]\n+    fn distribute() {\n+        check_dnf(\"#![cfg(all(any(a, b), c))]\", expect![[r#\"#![cfg(any(all(a, c), all(b, c)))]\"#]]);\n+        check_dnf(\"#![cfg(all(c, any(a, b)))]\", expect![[r#\"#![cfg(any(all(c, a), all(c, b)))]\"#]]);\n+        check_dnf(\n+            \"#![cfg(all(any(a, b), any(c, d)))]\",\n+            expect![[r#\"#![cfg(any(all(a, c), all(a, d), all(b, c), all(b, d)))]\"#]],\n+        );\n+\n+        check_dnf(\n+            \"#![cfg(all(any(a, b, c), any(d, e, f), g))]\",\n+            expect![[\n+                r#\"#![cfg(any(all(a, d, g), all(a, e, g), all(a, f, g), all(b, d, g), all(b, e, g), all(b, f, g), all(c, d, g), all(c, e, g), all(c, f, g)))]\"#\n+            ]],\n+        );\n+    }\n+\n+    #[test]\n+    fn demorgan() {\n+        check_dnf(\"#![cfg(not(all(a, b)))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+        check_dnf(\"#![cfg(not(any(a, b)))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+\n+        check_dnf(\"#![cfg(not(all(not(a), b)))]\", expect![[r#\"#![cfg(any(a, not(b)))]\"#]]);\n+        check_dnf(\"#![cfg(not(any(a, not(b))))]\", expect![[r#\"#![cfg(all(not(a), b))]\"#]]);\n+    }\n+\n+    #[test]\n+    fn nested() {\n+        check_dnf(\n+            \"#![cfg(all(any(a), not(all(any(b)))))]\",\n+            expect![[r#\"#![cfg(all(a, not(b)))]\"#]],\n+        );\n+\n+        check_dnf(\"#![cfg(any(any(a, b)))]\", expect![[r#\"#![cfg(any(a, b))]\"#]]);\n+        check_dnf(\"#![cfg(not(any(any(a, b))))]\", expect![[r#\"#![cfg(all(not(a), not(b)))]\"#]]);\n+        check_dnf(\"#![cfg(all(all(a, b)))]\", expect![[r#\"#![cfg(all(a, b))]\"#]]);\n+        check_dnf(\"#![cfg(not(all(all(a, b))))]\", expect![[r#\"#![cfg(any(not(a), not(b)))]\"#]]);\n+    }\n+\n+    #[test]\n+    fn hints() {\n+        let mut opts = CfgOptions::default();\n+\n+        check_enable_hints(\"#![cfg(test)]\", &opts, &[\"enable test\"]);\n+        check_enable_hints(\"#![cfg(not(test))]\", &opts, &[]);\n+\n+        check_enable_hints(\"#![cfg(any(a, b))]\", &opts, &[\"enable a\", \"enable b\"]);\n+        check_enable_hints(\"#![cfg(any(b, a))]\", &opts, &[\"enable b\", \"enable a\"]);\n+\n+        check_enable_hints(\"#![cfg(all(a, b))]\", &opts, &[\"enable a and b\"]);\n+\n+        opts.insert_atom(\"test\".into());\n+\n+        check_enable_hints(\"#![cfg(test)]\", &opts, &[]);\n+        check_enable_hints(\"#![cfg(not(test))]\", &opts, &[\"disable test\"]);\n+    }\n+\n+    /// Tests that we don't suggest hints for cfgs that express an inconsistent formula.\n+    #[test]\n+    fn hints_impossible() {\n+        let mut opts = CfgOptions::default();\n+\n+        check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+\n+        opts.insert_atom(\"test\".into());\n+\n+        check_enable_hints(\"#![cfg(all(test, not(test)))]\", &opts, &[]);\n+    }\n+\n+    #[test]\n+    fn why_inactive() {\n+        let mut opts = CfgOptions::default();\n+        opts.insert_atom(\"test\".into());\n+        opts.insert_atom(\"test2\".into());\n+\n+        check_why_inactive(\"#![cfg(a)]\", &opts, expect![[\"a is disabled\"]]);\n+        check_why_inactive(\"#![cfg(not(test))]\", &opts, expect![[\"test is enabled\"]]);\n+\n+        check_why_inactive(\n+            \"#![cfg(all(not(test), not(test2)))]\",\n+            &opts,\n+            expect![[\"test and test2 are enabled\"]],\n+        );\n+        check_why_inactive(\n+            \"#![cfg(all(not(test), a))]\",\n+            &opts,\n+            expect![[\"test is enabled and a is disabled\"]],\n+        );\n+        check_why_inactive(\n+            \"#![cfg(all(not(test), test2, a))]\",\n+            &opts,\n+            expect![[\"test is enabled and a is disabled\"]],\n+        );\n+        check_why_inactive(\n+            \"#![cfg(all(not(test), not(test2), a))]\",\n+            &opts,\n+            expect![[\"test and test2 are enabled and a is disabled\"]],\n+        );\n+    }\n+}"}, {"sha": "0b0734213feb838c69ac6f3994e7336e40469a3c", "filename": "crates/cfg/src/lib.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/68b17986c7c272d9be8df9a7abb9b162329b9d65/crates%2Fcfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcfg%2Fsrc%2Flib.rs?ref=68b17986c7c272d9be8df9a7abb9b162329b9d65", "patch": "@@ -1,11 +1,15 @@\n //! cfg defines conditional compiling options, `cfg` attibute parser and evaluator\n \n mod cfg_expr;\n+mod dnf;\n+\n+use std::fmt;\n \n use rustc_hash::FxHashSet;\n use tt::SmolStr;\n \n pub use cfg_expr::{CfgAtom, CfgExpr};\n+pub use dnf::DnfExpr;\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes.\n /// We have two kind of options in different namespaces: atomic options like `unix`, and\n@@ -40,4 +44,110 @@ impl CfgOptions {\n             self.enabled.insert(atom.clone());\n         }\n     }\n+\n+    pub fn apply_diff(&mut self, diff: CfgDiff) {\n+        for atom in diff.enable {\n+            self.enabled.insert(atom);\n+        }\n+\n+        for atom in diff.disable {\n+            self.enabled.remove(&atom);\n+        }\n+    }\n+}\n+\n+pub struct CfgDiff {\n+    // Invariants: No duplicates, no atom that's both in `enable` and `disable`.\n+    enable: Vec<CfgAtom>,\n+    disable: Vec<CfgAtom>,\n+}\n+\n+impl CfgDiff {\n+    /// Returns the total number of atoms changed by this diff.\n+    pub fn len(&self) -> usize {\n+        self.enable.len() + self.disable.len()\n+    }\n+}\n+\n+impl fmt::Display for CfgDiff {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enable.is_empty() {\n+            f.write_str(\"enable \")?;\n+            for (i, atom) in self.enable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+\n+            if !self.disable.is_empty() {\n+                f.write_str(\"; \")?;\n+            }\n+        }\n+\n+        if !self.disable.is_empty() {\n+            f.write_str(\"disable \")?;\n+            for (i, atom) in self.disable.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enable.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+pub struct InactiveReason {\n+    enabled: Vec<CfgAtom>,\n+    disabled: Vec<CfgAtom>,\n+}\n+\n+impl fmt::Display for InactiveReason {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if !self.enabled.is_empty() {\n+            for (i, atom) in self.enabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+            let is_are = if self.enabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} enabled\", is_are)?;\n+\n+            if !self.disabled.is_empty() {\n+                f.write_str(\" and \")?;\n+            }\n+        }\n+\n+        if !self.disabled.is_empty() {\n+            for (i, atom) in self.disabled.iter().enumerate() {\n+                let sep = match i {\n+                    0 => \"\",\n+                    _ if i == self.enabled.len() - 1 => \" and \",\n+                    _ => \", \",\n+                };\n+                f.write_str(sep)?;\n+\n+                write!(f, \"{}\", atom)?;\n+            }\n+            let is_are = if self.disabled.len() == 1 { \"is\" } else { \"are\" };\n+            write!(f, \" {} disabled\", is_are)?;\n+        }\n+\n+        Ok(())\n+    }\n }"}]}