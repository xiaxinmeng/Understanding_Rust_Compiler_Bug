{"sha": "41a21f053ced3df8fe9acc66cb30fb6005339b3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxYTIxZjA1M2NlZDNkZjhmZTlhY2M2NmNiMzBmYjYwMDUzMzliM2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-14T01:43:52Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-07-15T00:37:20Z"}, "message": "remove typestate from code, tests, and docs", "tree": {"sha": "12cf2e5e9ba0405e31a0a6abd509b6a5d3f477c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/12cf2e5e9ba0405e31a0a6abd509b6a5d3f477c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41a21f053ced3df8fe9acc66cb30fb6005339b3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41a21f053ced3df8fe9acc66cb30fb6005339b3e", "html_url": "https://github.com/rust-lang/rust/commit/41a21f053ced3df8fe9acc66cb30fb6005339b3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41a21f053ced3df8fe9acc66cb30fb6005339b3e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "html_url": "https://github.com/rust-lang/rust/commit/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad"}], "stats": {"total": 2392, "additions": 144, "deletions": 2248}, "files": [{"sha": "b7d5925def0dc4f1fe2aabf1094d86d1019b3557", "filename": "doc/rust.md", "status": "modified", "additions": 1, "deletions": 330, "changes": 331, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -211,7 +211,7 @@ The keywords in [source files](#source-files) are the following strings:\n ~~~~~~~~ {.keyword}\n alt again assert\n break\n-check claim class const copy\n+check class const copy\n drop\n else enum export extern\n fail false fn for\n@@ -1926,10 +1926,6 @@ an optional reference slot to serve as the function's output, bound to the\n `lval` on the right hand side of the call. If the function eventually returns,\n then the expression completes.\n \n-A call expression statically requires that the precondition declared in the\n-callee's signature is satisfied by the expression prestate. In this way,\n-typestates propagate through function boundaries.\n-\n An example of a call expression:\n \n ~~~~\n@@ -2354,117 +2350,6 @@ library. It is best to use the macro forms of logging (*#error*,\n when it is changed.\n \n \n-### Check expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-check_expr : \"check\" call_expr ;\n-~~~~~~~~\n-\n-A `check` expression connects dynamic assertions made at run-time to the\n-static [typestate system](#typestate-system). A `check` expression takes a\n-constraint to check at run-time. If the constraint holds at run-time, control\n-passes through the `check` and on to the next expression in the enclosing\n-block. If the condition fails to hold at run-time, the `check` expression\n-behaves as a `fail` expression.\n-\n-The typestate algorithm is built around `check` expressions, and in particular\n-the fact that control *will not pass* a check expression with a condition that\n-fails to hold. The typestate algorithm can therefore assume that the (static)\n-postcondition of a `check` expression includes the checked constraint\n-itself. From there, the typestate algorithm can perform dataflow calculations\n-on subsequent expressions, propagating [conditions](#conditions) forward and\n-statically comparing implied states and their specifications.\n-\n-~~~~~~~~\n-# fn print(i: int) { }\n-\n-pure fn even(x: int) -> bool {\n-    ret x & 1 == 0;\n-}\n-\n-fn print_even(x: int) : even(x) {\n-    print(x);\n-}\n-\n-fn test() {\n-    let y: int = 8;\n-\n-    // Cannot call print_even(y) here.\n-\n-    check even(y);\n-\n-    // Can call print_even(y) here, since even(y) now holds.\n-    print_even(y);\n-}\n-~~~~~~~~\n-\n-### Prove expressions\n-\n-**Note: Prove expressions are not yet supported by the compiler.**\n-\n-~~~~~~~~{.ebnf .gram}\n-prove_expr : \"prove\" call_expr ;\n-~~~~~~~~\n-\n-A `prove` expression has no run-time effect. Its purpose is to statically\n-check (and document) that its argument constraint holds at its expression\n-entry point. If its argument typestate does not hold, under the typestate\n-algorithm, the program containing it will fail to compile.\n-\n-### Claim expressions\n-\n-~~~~~~~~{.ebnf .gram}\n-claim_expr : \"claim\" call_expr ;\n-~~~~~~~~\n-\n-A `claim` expression is an unsafe variant on a `check` expression that is not\n-actually checked at runtime. Thus, using a `claim` implies a proof obligation\n-to ensure---without compiler assistance---that an assertion always holds.\n-\n-Setting a runtime flag can turn all `claim` expressions into `check`\n-expressions in a compiled Rust program, but the default is to not check the\n-assertion contained in a `claim`. The idea behind `claim` is that performance\n-profiling might identify a few bottlenecks in the code where actually checking\n-a given callee's predicate is too expensive; `claim` allows the code to\n-typecheck without removing the predicate check at every other call site.\n-\n-\n-\n-### If-Check expressions\n-\n-An `if check` expression combines a `if` expression and a `check`\n-expression in an indivisible unit that can be used to build more complex\n-conditional control-flow than the `check` expression affords.\n-\n-In fact, `if check` is a \"more primitive\" expression than `check`;\n-instances of the latter can be rewritten as instances of the former. The\n-following two examples are equivalent:\n-\n-Example using `check`:\n-\n-~~~~\n-# pure fn even(x: int) -> bool { true }\n-# fn print_even(x: int) { }\n-# let x = 0;\n-\n-check even(x);\n-print_even(x);\n-~~~~\n-\n-Equivalent example using `if check`:\n-\n-~~~~\n-# pure fn even(x: int) -> bool { true }\n-# fn print_even(x: int) { }\n-# let x = 0;\n-\n-if check even(x) {\n-    print_even(x);\n-} else {\n-    fail;\n-}\n-~~~~\n-\n ### Assert expressions\n \n ~~~~~~~~{.ebnf .gram}\n@@ -2813,220 +2698,6 @@ Sending operations are not part of the Rust language, but are\n implemented in the library. Generic functions that send values bound\n the kind of these values to sendable.\n \n-\n-\n-## Typestate system\n-\n-\n-Rust programs have a static semantics that determine the types of values\n-produced by each expression, as well as the *predicates* that hold over\n-slots in the environment at each point in time during execution.\n-\n-The latter semantics -- the dataflow analysis of predicates holding over slots\n--- is called the *typestate* system.\n-\n-### Points\n-\n-Control flows from statement to statement in a block, and through the\n-evaluation of each expression, from one sub-expression to another. This\n-sequential control flow is specified as a set of _points_, each of which\n-has a set of points before and after it in the implied control flow.\n-\n-For example, this code:\n-\n-~~~~~~~~\n-# let mut s;\n-\n-s = ~\"hello, world\";\n-io::println(s);\n-~~~~~~~~\n-\n-Consists of 2 statements, 3 expressions and 12 points:\n-\n-\n-* the point before the first statement\n-* the point before evaluating the static initializer `\"hello, world\"`\n-* the point after evaluating the static initializer `\"hello, world\"`\n-* the point after the first statement\n-* the point before the second statement\n-* the point before evaluating the function value `println`\n-* the point after evaluating the function value `println`\n-* the point before evaluating the arguments to `println`\n-* the point before evaluating the symbol `s`\n-* the point after evaluating the symbol `s`\n-* the point after evaluating the arguments to `println`\n-* the point after the second statement\n-\n-\n-Whereas this code:\n-\n-\n-~~~~~~~~\n-# fn x() -> ~str { ~\"\" }\n-# fn y() -> ~str { ~\"\" }\n-\n-io::println(x() + y());\n-~~~~~~~~\n-\n-Consists of 1 statement, 7 expressions and 14 points:\n-\n-\n-* the point before the statement\n-* the point before evaluating the function value `println`\n-* the point after evaluating the function value `println`\n-* the point before evaluating the arguments to `println`\n-* the point before evaluating the arguments to `+`\n-* the point before evaluating the function value `x`\n-* the point after evaluating the function value `x`\n-* the point before evaluating the arguments to `x`\n-* the point after evaluating the arguments to `x`\n-* the point before evaluating the function value `y`\n-* the point after evaluating the function value `y`\n-* the point before evaluating the arguments to `y`\n-* the point after evaluating the arguments to `y`\n-* the point after evaluating the arguments to `+`\n-* the point after evaluating the arguments to `println`\n-\n-\n-The typestate system reasons over points, rather than statements or\n-expressions. This may seem counter-intuitive, but points are the more\n-primitive concept. Another way of thinking about a point is as a set of\n-*instants in time* at which the state of a task is fixed. By contrast, a\n-statement or expression represents a *duration in time*, during which the\n-state of the task changes. The typestate system is concerned with constraining\n-the possible states of a task's memory at *instants*; it is meaningless to\n-speak of the state of a task's memory \"at\" a statement or expression, as each\n-statement or expression is likely to change the contents of memory.\n-\n-\n-### Control flow graph\n-\n-Each *point* can be considered a vertex in a directed *graph*. Each\n-kind of expression or statement implies a number of points *and edges* in\n-this graph. The edges connect the points within each statement or expression,\n-as well as between those points and those of nearby statements and expressions\n-in the program. The edges between points represent *possible* indivisible\n-control transfers that might occur during execution.\n-\n-This implicit graph is called the _control-flow graph_, or _CFG_.\n-\n-\n-### Constraints\n-\n-A [_predicate_](#predicate-functions) is a pure boolean function declared with\n-the keywords `pure fn`.\n-\n-A _constraint_ is a predicate applied to specific slots.\n-\n-For example, consider the following code:\n-\n-~~~~~~~~\n-pure fn is_less_than(a: int, b: int) -> bool {\n-     ret a < b;\n-}\n-\n-fn test() {\n-   let x: int = 10;\n-   let y: int = 20;\n-   check is_less_than(x,y);\n-}\n-~~~~~~~~\n-\n-This example defines the predicate `is_less_than`, and applies it to the slots\n-`x` and `y`. The constraint being checked on the third line of the function is\n-`is_less_than(x,y)`.\n-\n-Predicates can only apply to slots holding immutable values. The slots a\n-predicate applies to can themselves be mutable, but the types of values held\n-in those slots must be immutable.\n-\n-### Conditions\n-\n-A _condition_ is a set of zero or more constraints.\n-\n-Each *point* has an associated *condition*:\n-\n-* The _precondition_ of a statement or expression is the condition required at\n-in the point before it.\n-* The _postcondition_ of a statement or expression is the condition enforced\n-in the point after it.\n-\n-Any constraint present in the precondition and *absent* in the postcondition\n-is considered to be *dropped* by the statement or expression.\n-\n-\n-### Calculated typestates\n-\n-The typestate checking system *calculates* an additional condition for each\n-point called its _typestate_. For a given statement or expression, we call the\n-two typestates associated with its two points the prestate and a poststate.\n-\n-* The _prestate_ of a statement or expression is the typestate of the\n-point before it.\n-* The _poststate_ of a statement or expression is the typestate of the\n-point after it.\n-\n-A _typestate_ is a condition that has _been determined by the typestate\n-algorithm_ to hold at a point. This is a subtle but important point to\n-understand: preconditions and postconditions are *inputs* to the typestate\n-algorithm; prestates and poststates are *outputs* from the typestate\n-algorithm.\n-\n-The typestate algorithm analyses the preconditions and postconditions of every\n-statement and expression in a block, and computes a condition for each\n-typestate. Specifically:\n-\n-\n-* Initially, every typestate is empty.\n-* Each statement or expression's poststate is given the union of the its\n-prestate, precondition, and postcondition.\n-* Each statement or expression's poststate has the difference between its\n-precondition and postcondition removed.\n-* Each statement or expression's prestate is given the intersection of the\n-poststates of every predecessor point in the CFG.\n-* The previous three steps are repeated until no typestates in the\n-block change.\n-\n-The typestate algorithm is a very conventional dataflow calculation, and can\n-be performed using bit-set operations, with one bit per predicate and one\n-bit-set per condition.\n-\n-After the typestates of a block are computed, the typestate algorithm checks\n-that every constraint in the precondition of a statement is satisfied by its\n-prestate. If any preconditions are not satisfied, the mismatch is considered a\n-static (compile-time) error.\n-\n-\n-### Typestate checks\n-\n-The key mechanism that connects run-time semantics and compile-time analysis\n-of typestates is the use of [`check` expressions](#check-expressions). A\n-`check` expression guarantees that *if* control were to proceed past it, the\n-predicate associated with the `check` would have succeeded, so the constraint\n-being checked *statically* holds in subsequent points.^[A `check` expression\n-is similar to an `assert` call in a C program, with the significant difference\n-that the Rust compiler *tracks* the constraint that each `check` expression\n-enforces. Naturally, `check` expressions cannot be omitted from a \"production\n-build\" of a Rust program the same way `asserts` are frequently disabled in\n-deployed C programs.}\n-\n-It is important to understand that the typestate system has *no insight* into\n-the meaning of a particular predicate. Predicates and constraints are not\n-evaluated in any way at compile time. Predicates are treated as specific (but\n-unknown) functions applied to specific (also unknown) slots. All the typestate\n-system does is track which of those predicates -- whatever they calculate --\n-*must have been checked already* in order for program control to reach a\n-particular point in the CFG. The fundamental building block, therefore, is the\n-`check` statement, which tells the typestate system \"if control passes this\n-point, the checked predicate holds\".\n-\n-From this building block, constraints can be propagated to function signatures\n-and constrained types, and the responsibility to `check` a constraint\n-pushed further and further away from the site at which the program requires it\n-to hold in order to execute properly.\n-\n-\n-\n # Memory and concurrency models\n \n Rust has a memory model centered around concurrently-executing _tasks_. Thus"}, {"sha": "0ac7cf008744363d9766e8dd042539c6342c7224", "filename": "src/cargo/cargo.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcargo%2Fcargo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcargo%2Fcargo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcargo%2Fcargo.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -763,7 +763,6 @@ fn rustc_sysroot() -> ~str {\n     alt os::self_exe_path() {\n         some(path) {\n             let path = ~[path, ~\"..\", ~\"bin\", ~\"rustc\"];\n-            check vec::is_not_empty(path);\n             let rustc = path::normalize(path::connect_many(path));\n             #debug(\"  rustc: %s\", rustc);\n             rustc"}, {"sha": "3ba358bfb93438a32382388cc9a003b1bfcbd52d", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -39,7 +39,7 @@ fn parse_config(args: ~[~str]) -> config {\n           getopts::optflag(~\"verbose\"),\n           getopts::optopt(~\"logfile\")];\n \n-    check (vec::is_not_empty(args));\n+    assert (vec::is_not_empty(args));\n     let args_ = vec::tail(args);\n     let match =\n         alt getopts::getopts(args_, opts) {"}, {"sha": "6e43c1756a7a2ae3941f7c14cf175b649a4d3d3e", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -121,7 +121,6 @@ fn run_pretty_test(config: config, props: test_props, testfile: ~str) {\n     if option::is_some(props.pp_exact) {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        check (str::is_not_empty(cr));\n         actual = str::replace(actual, cr, ~\"\");\n         expected = str::replace(expected, cr, ~\"\");\n     }"}, {"sha": "a75f920cfd81deb49bf9582e0c764a50b8d8ab12", "filename": "src/fuzzer/fuzzer.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ffuzzer%2Ffuzzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ffuzzer%2Ffuzzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffuzzer%2Ffuzzer.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -69,7 +69,6 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           // position, the pretty-printer can't preserve this even by\n           // parenthesizing!!  See email to marijn.\n           ast::expr_if(_, _, _) { false }\n-          ast::expr_if_check(_, _, _) { false }\n           ast::expr_block(_) { false }\n           ast::expr_alt(_, _, _) { false }\n           ast::expr_while(_, _) { false }\n@@ -87,10 +86,6 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n           // https://github.com/mozilla/rust/issues/953\n           ast::expr_fail(option::some(_)) { false }\n \n-          // https://github.com/mozilla/rust/issues/927\n-          //ast::expr_assert(_) { false }\n-          ast::expr_check(_, _) { false }\n-\n           // https://github.com/mozilla/rust/issues/928\n           //ast::expr_cast(_, _) { false }\n \n@@ -105,13 +100,8 @@ pure fn safe_to_use_expr(e: ast::expr, tm: test_mode) -> bool {\n }\n \n fn safe_to_steal_ty(t: @ast::ty, tm: test_mode) -> bool {\n-    alt t.node {\n-        // https://github.com/mozilla/rust/issues/971\n-        ast::ty_constr(_, _) { false }\n-\n-        // Other restrictions happen to be the same.\n-        _ { safe_to_replace_ty(t.node, tm) }\n-    }\n+    // Restrictions happen to be the same.\n+    safe_to_replace_ty(t.node, tm)\n }\n \n // Not type-parameterized: https://github.com/mozilla/rust/issues/898 (FIXED)"}, {"sha": "8331284bf10eb28a0814b0b41f5474a259035d58", "filename": "src/libcore/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibcore%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibcore%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpath.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -217,7 +217,7 @@ fn normalize(p: path) -> path {\n     let s = strip_dots(s);\n     let s = rollup_doubledots(s);\n \n-    let s = if check vec::is_not_empty(s) {\n+    let s = if vec::is_not_empty(s) {\n         connect_many(s)\n     } else {\n         ~\"\""}, {"sha": "0abf3ce299b62da3f9d132c8bda190f96dd85cbb", "filename": "src/libcore/result.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -289,9 +289,9 @@ fn map_opt<T,U:copy,V:copy>(\n  * to accommodate an error like the vectors being of different lengths.\n  */\n fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n-                               op: fn(S,T) -> result<V,U>)\n-    : vec::same_length(ss, ts) -> result<~[V],U> {\n+                               op: fn(S,T) -> result<V,U>) -> result<~[V],U> {\n \n+    assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n     let mut vs = ~[];\n     vec::reserve(vs, n);\n@@ -312,10 +312,9 @@ fn map_vec2<S,T,U:copy,V:copy>(ss: ~[S], ts: ~[T],\n  * on its own as no result vector is built.\n  */\n fn iter_vec2<S,T,U:copy>(ss: ~[S], ts: ~[T],\n-                         op: fn(S,T) -> result<(),U>)\n-    : vec::same_length(ss, ts)\n-    -> result<(),U> {\n+                         op: fn(S,T) -> result<(),U>) -> result<(),U> {\n \n+    assert vec::same_length(ss, ts);\n     let n = vec::len(ts);\n     let mut i = 0u;\n     while i < n {"}, {"sha": "db70ad12b6e65dab81f0e62f077c8e9160106a3a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 77, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -284,9 +284,6 @@ type field = spanned<field_>;\n #[auto_serialize]\n enum blk_check_mode { default_blk, unchecked_blk, unsafe_blk, }\n \n-#[auto_serialize]\n-enum expr_check_mode { claimed_expr, checked_expr, }\n-\n #[auto_serialize]\n type expr = {id: node_id, callee_id: node_id, node: expr_, span: span};\n // Extra node ID is only used for index, assign_op, unary, binary\n@@ -322,10 +319,6 @@ enum expr_ {\n     expr_do_body(@expr),\n     expr_block(blk),\n \n-    /*\n-     * FIXME (#34): many of these @exprs should be constrained with\n-     * is_lval once we have constrained types working.\n-     */\n     expr_copy(@expr),\n     expr_move(@expr, @expr),\n     expr_assign(@expr, @expr),\n@@ -348,9 +341,6 @@ enum expr_ {\n     /* just an assert, no significance to typestate */\n     expr_assert(@expr),\n \n-    /* preds that typestate is aware of */\n-    expr_check(expr_check_mode, @expr),\n-    expr_if_check(@expr, blk, option<@expr>),\n     expr_mac(mac),\n }\n \n@@ -365,15 +355,6 @@ type capture_item = @{\n #[auto_serialize]\n type capture_clause = @~[capture_item];\n \n-/*\n-// Says whether this is a block the user marked as\n-// \"unchecked\"\n-enum blk_sort {\n-    blk_unchecked, // declared as \"exception to effect-checking rules\"\n-    blk_checked, // all typing rules apply\n-}\n-*/\n-\n #[auto_serialize]\n #[doc=\"For macro invocations; parsing is delegated to the macro\"]\n enum token_tree {\n@@ -384,8 +365,6 @@ enum token_tree {\n     tt_interpolate(span, ident)\n }\n \n-\n-\n #[auto_serialize]\n type matcher = spanned<matcher_>;\n \n@@ -502,7 +481,6 @@ enum ty_ {\n     ty_fn(proto, fn_decl),\n     ty_tup(~[@ty]),\n     ty_path(@path, node_id),\n-    ty_constr(@ty, ~[@ty_constr]),\n     ty_fixed_length(@ty, option<uint>),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n@@ -511,59 +489,6 @@ enum ty_ {\n     ty_infer,\n }\n \n-\n-/*\n-A constraint arg that's a function argument is referred to by its position\n-rather than name.  This is so we could have higher-order functions that have\n-constraints (potentially -- right now there's no way to write that), and also\n-so that the typestate pass doesn't have to map a function name onto its decl.\n-So, the constr_arg type is parameterized: it's instantiated with uint for\n-declarations, and ident for uses.\n-*/\n-#[auto_serialize]\n-enum constr_arg_general_<T> { carg_base, carg_ident(T), carg_lit(@lit), }\n-\n-#[auto_serialize]\n-type fn_constr_arg = constr_arg_general_<uint>;\n-\n-#[auto_serialize]\n-type sp_constr_arg<T> = spanned<constr_arg_general_<T>>;\n-\n-#[auto_serialize]\n-type ty_constr_arg = sp_constr_arg<@path>;\n-\n-#[auto_serialize]\n-type constr_arg = spanned<fn_constr_arg>;\n-\n-// Constrained types' args are parameterized by paths, since\n-// we refer to paths directly and not by indices.\n-// The implicit root of such path, in the constraint-list for a\n-// constrained type, is * (referring to the base record)\n-\n-#[auto_serialize]\n-type constr_general_<ARG, ID> =\n-    {path: @path, args: ~[@sp_constr_arg<ARG>], id: ID};\n-\n-// In the front end, constraints have a node ID attached.\n-// Typeck turns this to a def_id, using the output of resolve.\n-#[auto_serialize]\n-type constr_general<ARG> = spanned<constr_general_<ARG, node_id>>;\n-\n-#[auto_serialize]\n-type constr_ = constr_general_<uint, node_id>;\n-\n-#[auto_serialize]\n-type constr = spanned<constr_general_<uint, node_id>>;\n-\n-#[auto_serialize]\n-type ty_constr_ = constr_general_<@path, node_id>;\n-\n-#[auto_serialize]\n-type ty_constr = spanned<ty_constr_>;\n-\n-/* The parser generates ast::constrs; resolve generates\n- a mapping from each function to a list of ty::constr_defs,\n- corresponding to these. */\n #[auto_serialize]\n type arg = {mode: mode, ty: @ty, ident: ident, id: node_id};\n \n@@ -572,8 +497,7 @@ type fn_decl =\n     {inputs: ~[arg],\n      output: @ty,\n      purity: purity,\n-     cf: ret_style,\n-     constraints: ~[@constr]};\n+     cf: ret_style};\n \n #[auto_serialize]\n enum purity {"}, {"sha": "49478779fbadf59ebb9b889250ab958e9493373b", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 2, "deletions": 14, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -213,14 +213,6 @@ pure fn is_call_expr(e: @expr) -> bool {\n     alt e.node { expr_call(_, _, _) { true } _ { false } }\n }\n \n-fn is_constraint_arg(e: @expr) -> bool {\n-    alt e.node {\n-      expr_lit(_) { ret true; }\n-      expr_path(_) { ret true; }\n-      _ { ret false; }\n-    }\n-}\n-\n fn eq_ty(&&a: @ty, &&b: @ty) -> bool { ret box::ptr_eq(a, b); }\n \n fn hash_ty(&&t: @ty) -> uint {\n@@ -381,8 +373,8 @@ fn dtor_dec() -> fn_decl {\n     let nil_t = @{id: 0, node: ty_nil, span: dummy_sp()};\n     // dtor has one argument, of type ()\n     {inputs: ~[{mode: ast::expl(ast::by_ref),\n-               ty: nil_t, ident: @~\"_\", id: 0}],\n-     output: nil_t, purity: impure_fn, cf: return_val, constraints: ~[]}\n+                ty: nil_t, ident: @~\"_\", id: 0}],\n+     output: nil_t, purity: impure_fn, cf: return_val}\n }\n \n // ______________________________________________________________________\n@@ -467,10 +459,6 @@ fn id_visitor(vfn: fn@(node_id)) -> visit::vt<()> {\n             vec::iter(ps, |p| vfn(p.id))\n         },\n \n-        visit_constr: fn@(_p: @path, _sp: span, id: node_id) {\n-            vfn(id);\n-        },\n-\n         visit_fn: fn@(fk: visit::fn_kind, d: ast::fn_decl,\n                       _b: ast::blk, _sp: span, id: ast::node_id) {\n             vfn(id);"}, {"sha": "a7a6080fb0b70e4512794fd79029c624090d4ee2", "filename": "src/libsyntax/ext/auto_serialize.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fext%2Fauto_serialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fauto_serialize.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -162,8 +162,7 @@ impl helpers for ext_ctxt {\n           node: ast::ty_fn(ast::proto_any, {inputs: args,\n                                             output: output,\n                                             purity: ast::impure_fn,\n-                                            cf: ast::return_val,\n-                                            constraints: ~[]}),\n+                                            cf: ast::return_val}),\n           span: span}\n     }\n \n@@ -466,10 +465,6 @@ fn ser_ty(cx: ext_ctxt, tps: ser_tps_map,\n         }\n       }\n \n-      ast::ty_constr(ty, _) {\n-        ser_ty(cx, tps, ty, s, v)\n-      }\n-\n       ast::ty_mac(_) {\n         cx.span_err(ty.span, ~\"cannot serialize macro types\");\n         ~[]\n@@ -573,8 +568,7 @@ fn mk_ser_fn(cx: ext_ctxt, span: span, name: ast::ident,\n       node: ast::item_fn({inputs: ser_inputs,\n                           output: ser_output,\n                           purity: ast::impure_fn,\n-                          cf: ast::return_val,\n-                          constraints: ~[]},\n+                          cf: ast::return_val},\n                          ser_tps,\n                          ser_blk),\n       vis: ast::public,\n@@ -697,10 +691,6 @@ fn deser_ty(cx: ext_ctxt, tps: deser_tps_map,\n         }\n       }\n \n-      ast::ty_constr(ty, constrs) {\n-        deser_ty(cx, tps, ty, d)\n-      }\n-\n       ast::ty_mac(_) {\n         #ast{ fail }\n       }\n@@ -783,8 +773,7 @@ fn mk_deser_fn(cx: ext_ctxt, span: span,\n       node: ast::item_fn({inputs: deser_inputs,\n                           output: v_ty,\n                           purity: ast::impure_fn,\n-                          cf: ast::return_val,\n-                          constraints: ~[]},\n+                          cf: ast::return_val},\n                          deser_tps,\n                          deser_blk),\n       vis: ast::public,"}, {"sha": "2a2fbe2628a88ea3d82b0cf38a0723f40d061a1f", "filename": "src/libsyntax/ext/pipes/ast_builder.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fast_builder.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -89,10 +89,7 @@ impl ast_builder for ext_ctxt {\n         {inputs: inputs,\n          output: output,\n          purity: ast::impure_fn,\n-         cf: ast::return_val,\n-         // FIXME #2886: we'll probably want a variant that does constrained\n-         // types.\n-         constraints: ~[]}\n+         cf: ast::return_val}\n     }\n \n     fn item(name: ident,"}, {"sha": "965caacf07a8cd5ae168bd2d711ae357bc7c3fca", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 42, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -33,8 +33,6 @@ iface ast_fold {\n     fn fold_decl(&&@decl) -> @decl;\n     fn fold_expr(&&@expr) -> @expr;\n     fn fold_ty(&&@ty) -> @ty;\n-    fn fold_constr(&&@constr) -> @constr;\n-    fn fold_ty_constr(&&@ty_constr) -> @ty_constr;\n     fn fold_mod(_mod) -> _mod;\n     fn fold_foreign_mod(foreign_mod) -> foreign_mod;\n     fn fold_variant(variant) -> variant;\n@@ -66,9 +64,6 @@ type ast_fold_precursor = @{\n     fold_decl: fn@(decl_, span, ast_fold) -> (decl_, span),\n     fold_expr: fn@(expr_, span, ast_fold) -> (expr_, span),\n     fold_ty: fn@(ty_, span, ast_fold) -> (ty_, span),\n-    fold_constr: fn@(ast::constr_, span, ast_fold) -> (constr_, span),\n-    fold_ty_constr: fn@(ast::ty_constr_, span, ast_fold)\n-        -> (ty_constr_, span),\n     fold_mod: fn@(_mod, ast_fold) -> _mod,\n     fold_foreign_mod: fn@(foreign_mod, ast_fold) -> foreign_mod,\n     fold_variant: fn@(variant_, span, ast_fold) -> (variant_, span),\n@@ -135,8 +130,7 @@ fn fold_fn_decl(decl: ast::fn_decl, fld: ast_fold) -> ast::fn_decl {\n     ret {inputs: vec::map(decl.inputs, |x| fold_arg_(x, fld) ),\n          output: fld.fold_ty(decl.output),\n          purity: decl.purity,\n-         cf: decl.cf,\n-         constraints: vec::map(decl.constraints, |x| fld.fold_constr(x))}\n+         cf: decl.cf}\n }\n \n fn fold_ty_param_bound(tpb: ty_param_bound, fld: ast_fold) -> ty_param_bound {\n@@ -200,10 +194,7 @@ fn noop_fold_foreign_item(&&ni: @foreign_item, fld: ast_fold)\n                   foreign_item_fn({inputs: vec::map(fdec.inputs, fold_arg),\n                                   output: fld.fold_ty(fdec.output),\n                                   purity: fdec.purity,\n-                                  cf: fdec.cf,\n-                                  constraints:\n-                                      vec::map(fdec.constraints,\n-                                               |x| fld.fold_constr(x))},\n+                                  cf: fdec.cf},\n                                  fold_ty_params(typms, fld))\n                 }\n               },\n@@ -474,11 +465,6 @@ fn noop_fold_expr(e: expr_, fld: ast_fold) -> expr_ {\n           expr_log(i, lv, e) { expr_log(i, fld.fold_expr(lv),\n                                         fld.fold_expr(e)) }\n           expr_assert(e) { expr_assert(fld.fold_expr(e)) }\n-          expr_check(m, e) { expr_check(m, fld.fold_expr(e)) }\n-          expr_if_check(cond, tr, fl) {\n-            expr_if_check(fld.fold_expr(cond), fld.fold_block(tr),\n-                          option::map(fl, |x| fld.fold_expr(x)))\n-          }\n           expr_mac(mac) { expr_mac(fold_mac(mac)) }\n         }\n }\n@@ -504,24 +490,11 @@ fn noop_fold_ty(t: ty_, fld: ast_fold) -> ty_ {\n       ty_fn(proto, decl) {ty_fn(proto, fold_fn_decl(decl, fld))}\n       ty_tup(tys) {ty_tup(vec::map(tys, |ty| fld.fold_ty(ty)))}\n       ty_path(path, id) {ty_path(fld.fold_path(path), fld.new_id(id))}\n-      ty_constr(ty, constrs) {ty_constr(fld.fold_ty(ty),\n-                                vec::map(constrs, |x| fld.fold_ty_constr(x)))}\n       ty_fixed_length(t, vs) {ty_fixed_length(fld.fold_ty(t), vs)}\n       ty_mac(mac) {ty_mac(fold_mac(mac))}\n     }\n }\n \n-fn noop_fold_constr(c: constr_, fld: ast_fold) -> constr_ {\n-    {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n-     id: fld.new_id(c.id)}\n-}\n-\n-fn noop_fold_ty_constr(c: ty_constr_, fld: ast_fold) -> ty_constr_ {\n-    let rslt: ty_constr_ =\n-        {path: fld.fold_path(c.path), args: /* FIXME (#2543) */ copy c.args,\n-         id: fld.new_id(c.id)};\n-    rslt\n-}\n // ...nor do modules\n fn noop_fold_mod(m: _mod, fld: ast_fold) -> _mod {\n     ret {view_items: vec::map(m.view_items, |x| fld.fold_view_item(x)),\n@@ -606,8 +579,6 @@ fn default_ast_fold() -> ast_fold_precursor {\n           fold_decl: wrap(noop_fold_decl),\n           fold_expr: wrap(noop_fold_expr),\n           fold_ty: wrap(noop_fold_ty),\n-          fold_constr: wrap(noop_fold_constr),\n-          fold_ty_constr: wrap(noop_fold_ty_constr),\n           fold_mod: noop_fold_mod,\n           fold_foreign_mod: noop_fold_foreign_mod,\n           fold_variant: wrap(noop_fold_variant),\n@@ -697,17 +668,6 @@ impl of ast_fold for ast_fold_precursor {\n         let (n, s) = self.fold_ty(x.node, x.span, self as ast_fold);\n         ret @{id: self.new_id(x.id), node: n, span: self.new_span(s)};\n     }\n-    fn fold_constr(&&x: @ast::constr) ->\n-       @ast::constr {\n-        let (n, s) = self.fold_constr(x.node, x.span, self as ast_fold);\n-        ret @{node: n, span: self.new_span(s)};\n-    }\n-    fn fold_ty_constr(&&x: @ast::ty_constr) ->\n-       @ast::ty_constr {\n-        let (n, s) : (ty_constr_, span) =\n-            self.fold_ty_constr(x.node, x.span, self as ast_fold);\n-        ret @{node: n, span: self.new_span(s)};\n-    }\n     fn fold_mod(x: _mod) -> _mod {\n         ret self.fold_mod(x, self as ast_fold);\n     }"}, {"sha": "20fb7772d08f3bdac86ea33d6d5ae082e1dc9b34", "filename": "src/libsyntax/parse/classify.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fclassify.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -6,8 +6,7 @@ import ast_util::operator_prec;\n \n fn expr_requires_semi_to_be_stmt(e: @ast::expr) -> bool {\n     alt e.node {\n-      ast::expr_if(_, _, _) | ast::expr_if_check(_, _, _)\n-      | ast::expr_alt(_, _, _) | ast::expr_block(_)\n+      ast::expr_if(_, _, _) | ast::expr_alt(_, _, _) | ast::expr_block(_)\n       | ast::expr_while(_, _) | ast::expr_loop(_)\n       | ast::expr_call(_, _, true) {\n         false\n@@ -44,7 +43,6 @@ fn need_parens(expr: @ast::expr, outer_prec: uint) -> bool {\n       ast::expr_assign_op(_, _, _) { true }\n       ast::expr_ret(_) { true }\n       ast::expr_assert(_) { true }\n-      ast::expr_check(_, _) { true }\n       ast::expr_log(_, _, _) { true }\n       _ { !parse::classify::expr_requires_semi_to_be_stmt(expr) }\n     }\n@@ -64,8 +62,9 @@ fn ends_in_lit_int(ex: @ast::expr) -> bool {\n       ast::expr_move(_, sub) | ast::expr_copy(sub) |\n       ast::expr_assign(_, sub) |\n       ast::expr_assign_op(_, _, sub) | ast::expr_swap(_, sub) |\n-      ast::expr_log(_, _, sub) | ast::expr_assert(sub) |\n-      ast::expr_check(_, sub) { ends_in_lit_int(sub) }\n+      ast::expr_log(_, _, sub) | ast::expr_assert(sub) {\n+        ends_in_lit_int(sub)\n+      }\n       ast::expr_fail(osub) | ast::expr_ret(osub) {\n         alt osub {\n           some(ex) { ends_in_lit_int(ex) }"}, {"sha": "fa0361e797b52239ee3a00fd99de9a51a40f88be", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 12, "deletions": 141, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -20,14 +20,14 @@ import ast::{_mod, add, alt_check, alt_exhaustive, arg, arm, attribute,\n              by_mutbl_ref, by_ref, by_val, capture_clause, capture_item,\n              carg_base, carg_ident, cdir_dir_mod, cdir_src_mod,\n              cdir_view_item, checked_expr, claimed_expr, class_immutable,\n-             class_member, class_method, class_mutable, constr, constr_arg,\n-             constr_general, crate, crate_cfg, crate_directive, decl,\n+             class_member, class_method, class_mutable,\n+             crate, crate_cfg, crate_directive, decl,\n              decl_item, decl_local, default_blk, deref, div, expl, expr,\n              expr_, expr_addr_of, expr_alt, expr_again, expr_assert,\n              expr_assign, expr_assign_op, expr_binary, expr_block, expr_break,\n-             expr_call, expr_cast, expr_check, expr_copy, expr_do_body,\n+             expr_call, expr_cast, expr_copy, expr_do_body,\n              expr_fail, expr_field, expr_fn, expr_fn_block, expr_if,\n-             expr_if_check, expr_index, expr_lit, expr_log, expr_loop,\n+             expr_index, expr_lit, expr_log, expr_loop,\n              expr_loop_body, expr_mac, expr_move, expr_new, expr_path,\n              expr_rec, expr_ret, expr_swap, expr_tup, expr_unary, expr_vec,\n              expr_vstore, expr_while, extern_fn, field, fn_decl, foreign_item,\n@@ -265,15 +265,9 @@ class parser {\n             {mode: mode, ty: p.parse_ty(false), ident: name,\n              id: p.get_id()}\n         };\n-        // FIXME (#34): constrs is empty because right now, higher-order\n-        // functions can't have constrained types. Not sure whether\n-        // that would be desirable anyway. See bug for the story on\n-        // constrained types.\n-        let constrs: ~[@constr] = ~[];\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret {inputs: inputs, output: ret_ty,\n-             purity: purity, cf: ret_style,\n-             constraints: constrs};\n+             purity: purity, cf: ret_style};\n     }\n \n     fn parse_trait_methods() -> ~[trait_method] {\n@@ -341,79 +335,6 @@ class parser {\n         ret spanned(lo, ty.span.hi, {ident: id, mt: {ty: ty, mutbl: mutbl}});\n     }\n \n-    // if i is the jth ident in args, return j\n-    // otherwise, fail\n-    fn ident_index(args: ~[arg], i: ident) -> uint {\n-        let mut j = 0u;\n-        for args.each |a| { if a.ident == i { ret j; } j += 1u; }\n-        self.fatal(~\"unbound variable `\" + *i + ~\"` in constraint arg\");\n-    }\n-\n-    fn parse_type_constr_arg() -> @ty_constr_arg {\n-        let sp = self.span;\n-        let mut carg = carg_base;\n-        self.expect(token::BINOP(token::STAR));\n-        if self.token == token::DOT {\n-            // \"*...\" notation for record fields\n-            self.bump();\n-            let pth = self.parse_path_without_tps();\n-            carg = carg_ident(pth);\n-        }\n-        // No literals yet, I guess?\n-        ret @{node: carg, span: sp};\n-    }\n-\n-    fn parse_constr_arg(args: ~[arg]) -> @constr_arg {\n-        let sp = self.span;\n-        let mut carg = carg_base;\n-        if self.token == token::BINOP(token::STAR) {\n-            self.bump();\n-        } else {\n-            let i: ident = self.parse_value_ident();\n-            carg = carg_ident(self.ident_index(args, i));\n-        }\n-        ret @{node: carg, span: sp};\n-    }\n-\n-    fn parse_ty_constr(fn_args: ~[arg]) -> @constr {\n-        let lo = self.span.lo;\n-        let path = self.parse_path_without_tps();\n-        let args = self.parse_unspanned_seq(\n-            token::LPAREN, token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_constr_arg(fn_args));\n-        ret @spanned(lo, self.span.hi,\n-                     {path: path, args: args, id: self.get_id()});\n-    }\n-\n-    fn parse_constr_in_type() -> @ty_constr {\n-        let lo = self.span.lo;\n-        let path = self.parse_path_without_tps();\n-        let args: ~[@ty_constr_arg] = self.parse_unspanned_seq(\n-            token::LPAREN, token::RPAREN,\n-            seq_sep_trailing_disallowed(token::COMMA),\n-            |p| p.parse_type_constr_arg());\n-        let hi = self.span.lo;\n-        let tc: ty_constr_ = {path: path, args: args, id: self.get_id()};\n-        ret @spanned(lo, hi, tc);\n-    }\n-\n-\n-    fn parse_constrs<T: copy>(pser: fn(parser) -> @constr_general<T>) ->\n-        ~[@constr_general<T>] {\n-        let mut constrs: ~[@constr_general<T>] = ~[];\n-        loop {\n-            let constr = pser(self);\n-            vec::push(constrs, constr);\n-            if self.token == token::COMMA { self.bump(); }\n-            else { ret constrs; }\n-        };\n-    }\n-\n-    fn parse_type_constraints() -> ~[@ty_constr] {\n-        ret self.parse_constrs(|p| p.parse_constr_in_type());\n-    }\n-\n     fn parse_ret_ty() -> (ret_style, @ty) {\n         ret if self.eat(token::RARROW) {\n             let lo = self.span.lo;\n@@ -519,16 +440,7 @@ class parser {\n             if vec::len(elems) == 0u {\n                 self.unexpected_last(token::RBRACE);\n             }\n-            let hi = self.span.hi;\n-\n-            let t = ty_rec(elems);\n-            if self.token == token::COLON {\n-                self.bump();\n-                ty_constr(@{id: self.get_id(),\n-                            node: t,\n-                            span: mk_sp(lo, hi)},\n-                          self.parse_type_constraints())\n-            } else { t }\n+            ty_rec(elems)\n         } else if self.token == token::LBRACKET {\n             self.expect(token::LBRACKET);\n             let t = ty_vec(self.parse_mt());\n@@ -970,21 +882,6 @@ class parser {\n             let e = self.parse_expr();\n             ex = expr_assert(e);\n             hi = e.span.hi;\n-        } else if self.eat_keyword(~\"check\") {\n-            /* Should be a predicate (pure boolean function) applied to\n-            arguments that are all either slot variables or literals.\n-            but the typechecker enforces that. */\n-            let e = self.parse_expr();\n-            hi = e.span.hi;\n-            ex = expr_check(checked_expr, e);\n-        } else if self.eat_keyword(~\"claim\") {\n-            /* Same rules as check, except that if check-claims\n-            is enabled (a command-line flag), then the parser turns\n-            claims into check */\n-\n-            let e = self.parse_expr();\n-            hi = e.span.hi;\n-            ex = expr_check(claimed_expr, e);\n         } else if self.eat_keyword(~\"ret\") {\n             if can_begin_expr(self.token) {\n                 let e = self.parse_expr();\n@@ -1457,12 +1354,7 @@ class parser {\n         ret lhs;\n     }\n \n-    fn parse_if_expr_1() ->\n-        {cond: @expr,\n-         then: blk,\n-         els: option<@expr>,\n-         lo: uint,\n-         hi: uint} {\n+    fn parse_if_expr() -> @expr {\n         let lo = self.last_span.lo;\n         let cond = self.parse_expr();\n         let thn = self.parse_block();\n@@ -1473,18 +1365,8 @@ class parser {\n             els = some(elexpr);\n             hi = elexpr.span.hi;\n         }\n-        ret {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n-    }\n-\n-    fn parse_if_expr() -> @expr {\n-        if self.eat_keyword(~\"check\") {\n-            let q = self.parse_if_expr_1();\n-            ret self.mk_expr(q.lo, q.hi,\n-                             expr_if_check(q.cond, q.then, q.els));\n-        } else {\n-            let q = self.parse_if_expr_1();\n-            ret self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n-        }\n+        let q = {cond: cond, then: thn, els: els, lo: lo, hi: hi};\n+        ret self.mk_expr(q.lo, q.hi, expr_if(q.cond, q.then, q.els));\n     }\n \n     fn parse_fn_expr(proto: proto) -> @expr {\n@@ -1520,8 +1402,7 @@ class parser {\n                                 span: self.span\n                             },\n                             purity: impure_fn,\n-                            cf: return_val,\n-                            constraints: ~[]\n+                            cf: return_val\n                         }\n                     },\n                     @~[])\n@@ -2083,20 +1964,11 @@ class parser {\n         let inputs = either::lefts(args_or_capture_items);\n         let capture_clause = @either::rights(args_or_capture_items);\n \n-        // Use the args list to translate each bound variable\n-        // mentioned in a constraint to an arg index.\n-        // Seems weird to do this in the parser, but I'm not sure how else to.\n-        let mut constrs = ~[];\n-        if self.token == token::COLON {\n-            self.bump();\n-            constrs = self.parse_constrs(|p| p.parse_ty_constr(inputs));\n-        }\n         let (ret_style, ret_ty) = self.parse_ret_ty();\n         ret ({inputs: inputs,\n               output: ret_ty,\n               purity: purity,\n-              cf: ret_style,\n-              constraints: constrs}, capture_clause);\n+              cf: ret_style}, capture_clause);\n     }\n \n     fn parse_fn_block_decl() -> (fn_decl, capture_clause) {\n@@ -2118,8 +1990,7 @@ class parser {\n         ret ({inputs: either::lefts(inputs_captures),\n               output: output,\n               purity: impure_fn,\n-              cf: return_val,\n-              constraints: ~[]},\n+              cf: return_val},\n              @either::rights(inputs_captures));\n     }\n "}, {"sha": "eb8c5b65fa5108aaeea61018b94912b473e7b3ec", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -306,7 +306,7 @@ fn restricted_keyword_table() -> hashmap<~str, ()> {\n     let keys = ~[\n         ~\"alt\", ~\"again\", ~\"assert\",\n         ~\"break\",\n-        ~\"check\", ~\"claim\", ~\"class\", ~\"const\", ~\"copy\",\n+        ~\"check\", ~\"class\", ~\"const\", ~\"copy\",\n         ~\"do\", ~\"drop\",\n         ~\"else\", ~\"enum\", ~\"export\", ~\"extern\",\n         ~\"fail\", ~\"false\", ~\"fn\", ~\"for\","}, {"sha": "1b9b0ce7f96236bed6c89f796870254977d1dea1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 2, "deletions": 85, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -128,8 +128,7 @@ fn test_fun_to_str() {\n                   node: ast::ty_nil,\n                   span: ast_util::dummy_sp()},\n         purity: ast::impure_fn,\n-        cf: ast::return_val,\n-        constraints: ~[]\n+        cf: ast::return_val\n     };\n     assert fun_to_str(decl, \"a\", ~[]) == \"fn a()\";\n }\n@@ -373,11 +372,6 @@ fn print_type_ex(s: ps, &&ty: @ast::ty, print_colons: bool) {\n         print_ty_fn(s, some(proto), d, none, none);\n       }\n       ast::ty_path(path, _) { print_path(s, path, print_colons); }\n-      ast::ty_constr(t, cs) {\n-        print_type(s, t);\n-        space(s.s);\n-        word(s.s, constrs_str(cs, ty_constr_to_str));\n-      }\n       ast::ty_fixed_length(t, v) {\n         print_type(s, t);\n         word(s.s, ~\"/\");\n@@ -977,9 +971,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n       ast::expr_if(test, blk, elseopt) {\n         print_if(s, test, blk, elseopt, false);\n       }\n-      ast::expr_if_check(test, blk, elseopt) {\n-        print_if(s, test, blk, elseopt, true);\n-      }\n       ast::expr_while(test, blk) {\n         head(s, ~\"while\");\n         print_maybe_parens_discrim(s, test);\n@@ -1131,15 +1122,6 @@ fn print_expr(s: ps, &&expr: @ast::expr) {\n           }\n         }\n       }\n-      ast::expr_check(m, expr) {\n-        alt m {\n-          ast::claimed_expr { word_nbsp(s, ~\"claim\"); }\n-          ast::checked_expr { word_nbsp(s, ~\"check\"); }\n-        }\n-        popen(s);\n-        print_expr(s, expr);\n-        pclose(s);\n-      }\n       ast::expr_assert(expr) {\n         word_nbsp(s, ~\"assert\");\n         print_expr(s, expr);\n@@ -1166,7 +1148,7 @@ fn print_expr_parens_if_not_bot(s: ps, ex: @ast::expr) {\n       ast::expr_assign_op(_, _, _) | ast::expr_swap(_, _) |\n       ast::expr_log(_, _, _) | ast::expr_assert(_) |\n       ast::expr_call(_, _, true) |\n-      ast::expr_check(_, _) | ast::expr_vstore(_, _) { true }\n+      ast::expr_vstore(_, _) { true }\n       _ { false }\n     };\n     if parens { popen(s); }\n@@ -1348,9 +1330,6 @@ fn print_fn_args_and_ret(s: ps, decl: ast::fn_decl,\n     popen(s);\n     print_fn_args(s, decl, cap_items);\n     pclose(s);\n-    word(s.s, constrs_str(decl.constraints, |c| {\n-        ast_fn_constr_to_str(decl, c)\n-    }));\n \n     maybe_print_comment(s, decl.output.span.lo);\n     if decl.output.node != ast::ty_nil {\n@@ -1552,7 +1531,6 @@ fn print_ty_fn(s: ps, opt_proto: option<ast::proto>,\n         else { print_type(s, decl.output); }\n         end(s);\n     }\n-    word(s.s, constrs_str(decl.constraints, ast_ty_fn_constr_to_str));\n     end(s);\n }\n \n@@ -1736,67 +1714,6 @@ fn next_comment(s: ps) -> option<comments::cmnt> {\n     }\n }\n \n-fn constr_args_to_str<T>(f: fn@(T) -> ~str,\n-                         args: ~[@ast::sp_constr_arg<T>]) ->\n-   ~str {\n-    let mut comma = false;\n-    let mut s = ~\"(\";\n-    for args.each |a| {\n-        if comma { s += ~\", \"; } else { comma = true; }\n-        s += constr_arg_to_str::<T>(f, a.node);\n-    }\n-    s += ~\")\";\n-    ret s;\n-}\n-\n-fn constr_arg_to_str<T>(f: fn@(T) -> ~str, c: ast::constr_arg_general_<T>) ->\n-   ~str {\n-    alt c {\n-      ast::carg_base { ret ~\"*\"; }\n-      ast::carg_ident(i) { ret f(i); }\n-      ast::carg_lit(l) { ret lit_to_str(l); }\n-    }\n-}\n-\n-// needed b/c constr_args_to_str needs\n-// something that takes an alias\n-// (argh)\n-fn uint_to_str(&&i: uint) -> ~str { ret uint::str(i); }\n-\n-fn ast_ty_fn_constr_to_str(&&c: @ast::constr) -> ~str {\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str(uint_to_str, c.node.args);\n-}\n-\n-fn ast_fn_constr_to_str(decl: ast::fn_decl, &&c: @ast::constr) -> ~str {\n-    let arg_to_str = |a| fn_arg_idx_to_str(decl, a);\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str(arg_to_str, c.node.args);\n-}\n-\n-fn ty_constr_to_str(&&c: @ast::ty_constr) -> ~str {\n-    fn ty_constr_path_to_str(&&p: @ast::path) -> ~str {\n-        ~\"*.\" + path_to_str(p)\n-    }\n-\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str::<@ast::path>(ty_constr_path_to_str,\n-                                             c.node.args);\n-}\n-\n-fn constrs_str<T>(constrs: ~[T], elt: fn(T) -> ~str) -> ~str {\n-    let mut s = ~\"\", colon = true;\n-    for constrs.each |c| {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n-        s += elt(c);\n-    }\n-    ret s;\n-}\n-\n-fn fn_arg_idx_to_str(decl: ast::fn_decl, &&idx: uint) -> ~str {\n-    *decl.inputs[idx].ident\n-}\n-\n fn opt_proto_to_str(opt_p: option<ast::proto>) -> ~str {\n     alt opt_p {\n       none { ~\"fn\" }"}, {"sha": "3e61f3706f9335ece30c71d2c04da141fc85ce85", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -44,8 +44,6 @@ fn tps_of_fn(fk: fn_kind) -> ~[ty_param] {\n }\n \n type visitor<E> =\n-    // takes the components so that one function can be\n-    // generic over constr and ty_constr\n     @{visit_mod: fn@(_mod, span, node_id, E, vt<E>),\n       visit_view_item: fn@(@view_item, E, vt<E>),\n       visit_foreign_item: fn@(@foreign_item, E, vt<E>),\n@@ -59,7 +57,6 @@ type visitor<E> =\n       visit_expr: fn@(@expr, E, vt<E>),\n       visit_ty: fn@(@ty, E, vt<E>),\n       visit_ty_params: fn@(~[ty_param], E, vt<E>),\n-      visit_constr: fn@(@path, span, node_id, E, vt<E>),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id, E, vt<E>),\n       visit_ty_method: fn@(ty_method, E, vt<E>),\n       visit_trait_method: fn@(trait_method, E, vt<E>),\n@@ -79,7 +76,6 @@ fn default_visitor<E>() -> visitor<E> {\n           visit_expr: |a,b,c|visit_expr::<E>(a, b, c),\n           visit_ty: |a,b,c|skip_ty::<E>(a, b, c),\n           visit_ty_params: |a,b,c|visit_ty_params::<E>(a, b, c),\n-          visit_constr: |a,b,c,d,e|visit_constr::<E>(a, b, c, d, e),\n           visit_fn: |a,b,c,d,e,f,g|visit_fn::<E>(a, b, c, d, e, f, g),\n           visit_ty_method: |a,b,c|visit_ty_method::<E>(a, b, c),\n           visit_trait_method: |a,b,c|visit_trait_method::<E>(a, b, c),\n@@ -194,21 +190,12 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n       ty_tup(ts) { for ts.each |tt| { v.visit_ty(tt, e, v); } }\n       ty_fn(_, decl) {\n         for decl.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n-        for decl.constraints.each |c| {\n-            v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n-        }\n         v.visit_ty(decl.output, e, v);\n       }\n       ty_path(p, _) { visit_path(p, e, v); }\n       ty_fixed_length(t, _) {\n         v.visit_ty(t, e, v);\n       }\n-      ty_constr(t, cs) {\n-        v.visit_ty(t, e, v);\n-        for cs.each |tc| {\n-            v.visit_constr(tc.node.path, tc.span, tc.node.id, e, v);\n-        }\n-      }\n       ty_nil |\n       ty_bot |\n       ty_mac(_) |\n@@ -217,11 +204,6 @@ fn visit_ty<E>(t: @ty, e: E, v: vt<E>) {\n     }\n }\n \n-fn visit_constr<E>(_operator: @path, _sp: span, _id: node_id, _e: E,\n-                   _v: vt<E>) {\n-    // default\n-}\n-\n fn visit_path<E>(p: @path, e: E, v: vt<E>) {\n     for p.types.each |tp| { v.visit_ty(tp, e, v); }\n }\n@@ -272,9 +254,6 @@ fn visit_ty_params<E>(tps: ~[ty_param], e: E, v: vt<E>) {\n \n fn visit_fn_decl<E>(fd: fn_decl, e: E, v: vt<E>) {\n     for fd.inputs.each |a| { v.visit_ty(a.ty, e, v); }\n-    for fd.constraints.each |c| {\n-        v.visit_constr(c.node.path, c.span, c.node.id, e, v);\n-    }\n     v.visit_ty(fd.output, e, v);\n }\n \n@@ -394,21 +373,14 @@ fn visit_expr<E>(ex: @expr, e: E, v: vt<E>) {\n       expr_binary(_, a, b) { v.visit_expr(a, e, v); v.visit_expr(b, e, v); }\n       expr_addr_of(_, x) | expr_unary(_, x) |\n       expr_loop_body(x) | expr_do_body(x) |\n-      expr_check(_, x) | expr_assert(x) {\n-        v.visit_expr(x, e, v);\n-      }\n+      expr_assert(x) { v.visit_expr(x, e, v); }\n       expr_lit(_) { }\n       expr_cast(x, t) { v.visit_expr(x, e, v); v.visit_ty(t, e, v); }\n       expr_if(x, b, eo) {\n         v.visit_expr(x, e, v);\n         v.visit_block(b, e, v);\n         visit_expr_opt(eo, e, v);\n       }\n-      expr_if_check(x, b, eo) {\n-        v.visit_expr(x, e, v);\n-        v.visit_block(b, e, v);\n-        visit_expr_opt(eo, e, v);\n-      }\n       expr_while(x, b) { v.visit_expr(x, e, v); v.visit_block(b, e, v); }\n       expr_loop(b) { v.visit_block(b, e, v); }\n       expr_alt(x, arms, _) {\n@@ -460,8 +432,6 @@ fn visit_arm<E>(a: arm, e: E, v: vt<E>) {\n // calls the given functions on the nodes.\n \n type simple_visitor =\n-    // takes the components so that one function can be\n-    // generic over constr and ty_constr\n     @{visit_mod: fn@(_mod, span, node_id),\n       visit_view_item: fn@(@view_item),\n       visit_foreign_item: fn@(@foreign_item),\n@@ -475,7 +445,6 @@ type simple_visitor =\n       visit_expr: fn@(@expr),\n       visit_ty: fn@(@ty),\n       visit_ty_params: fn@(~[ty_param]),\n-      visit_constr: fn@(@path, span, node_id),\n       visit_fn: fn@(fn_kind, fn_decl, blk, span, node_id),\n       visit_ty_method: fn@(ty_method),\n       visit_trait_method: fn@(trait_method),\n@@ -497,7 +466,6 @@ fn default_simple_visitor() -> simple_visitor {\n           visit_expr: fn@(_e: @expr) { },\n           visit_ty: simple_ignore_ty,\n           visit_ty_params: fn@(_ps: ~[ty_param]) {},\n-          visit_constr: fn@(_p: @path, _sp: span, _id: node_id) { },\n           visit_fn: fn@(_fk: fn_kind, _d: fn_decl, _b: blk, _sp: span,\n                         _id: node_id) { },\n           visit_ty_method: fn@(_m: ty_method) { },\n@@ -572,11 +540,6 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n         f(ps);\n         visit_ty_params(ps, e, v);\n     }\n-    fn v_constr(f: fn@(@path, span, node_id), pt: @path, sp: span,\n-                id: node_id, &&e: (), v: vt<()>) {\n-        f(pt, sp, id);\n-        visit_constr(pt, sp, id, e, v);\n-    }\n     fn v_fn(f: fn@(fn_kind, fn_decl, blk, span, node_id),\n             fk: fn_kind, decl: fn_decl, body: blk, sp: span,\n             id: node_id, &&e: (), v: vt<()>) {\n@@ -610,8 +573,6 @@ fn mk_simple_visitor(v: simple_visitor) -> vt<()> {\n                 visit_ty: visit_ty,\n                 visit_ty_params: |a,b,c|\n                     v_ty_params(v.visit_ty_params, a, b, c),\n-                visit_constr: |a,b,c,d,e|\n-                    v_constr(v.visit_constr, a, b, c, d, e),\n                 visit_fn: |a,b,c,d,e,f,g|\n                     v_fn(v.visit_fn, a, b, c, d, e, f, g),\n                 visit_ty_method: |a,b,c|"}, {"sha": "9f6b703281ddbf1481052a3fce56e1dc99587a3f", "filename": "src/rustc/back/rpath.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fback%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fback%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fback%2Frpath.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -97,15 +97,16 @@ fn get_rpaths_relative_to_output(os: session::os,\n                                  output: path::path,\n                                  libs: ~[path::path]) -> ~[~str] {\n     vec::map(libs, |a| {\n-        check not_win32(os);\n         get_rpath_relative_to_output(os, cwd, output, a)\n     })\n }\n \n fn get_rpath_relative_to_output(os: session::os,\n                                 cwd: path::path,\n                                 output: path::path,\n-                                &&lib: path::path) : not_win32(os) -> ~str {\n+                                &&lib: path::path) -> ~str {\n+    assert not_win32(os);\n+\n     // Mac doesn't appear to support $ORIGIN\n     let prefix = alt os {\n         session::os_linux { ~\"$ORIGIN\" + path::path_sep() }\n@@ -147,7 +148,7 @@ fn get_relative_to(abs1: path::path, abs2: path::path) -> path::path {\n     // FIXME (#2880): use view here.\n     vec::push_all(path, vec::slice(split2, start_idx, len2 - 1u));\n \n-    if check vec::is_not_empty(path) {\n+    if vec::is_not_empty(path) {\n         ret path::connect_many(path);\n     } else {\n         ret ~\".\";\n@@ -314,18 +315,16 @@ mod test {\n     #[test]\n     #[cfg(target_os = \"linux\")]\n     fn test_rpath_relative() {\n-        let o = session::os_linux;\n-        check not_win32(o);\n-        let res = get_rpath_relative_to_output(o,\n+      let o = session::os_linux;\n+      let res = get_rpath_relative_to_output(o,\n             ~\"/usr\", ~\"bin/rustc\", ~\"lib/libstd.so\");\n-        assert res == ~\"$ORIGIN/../lib\";\n+      assert res == ~\"$ORIGIN/../lib\";\n     }\n \n     #[test]\n     #[cfg(target_os = \"freebsd\")]\n     fn test_rpath_relative() {\n         let o = session::os_freebsd;\n-        check not_win32(o);\n         let res = get_rpath_relative_to_output(o,\n             ~\"/usr\", ~\"bin/rustc\", ~\"lib/libstd.so\");\n         assert res == ~\"$ORIGIN/../lib\";\n@@ -336,7 +335,6 @@ mod test {\n     fn test_rpath_relative() {\n         // this is why refinements would be nice\n         let o = session::os_macos;\n-        check not_win32(o);\n         let res = get_rpath_relative_to_output(o, ~\"/usr\", ~\"bin/rustc\",\n                                                ~\"lib/libstd.so\");\n         assert res == ~\"@executable_path/../lib\";"}, {"sha": "a81b491f23f81a5abfd265266334369e6c1c4449", "filename": "src/rustc/driver/driver.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fdriver%2Fdriver.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -207,9 +207,6 @@ fn compile_upto(sess: session, cfg: ast::crate_cfg,\n     let last_use_map = time(time_passes, ~\"liveness checking\", ||\n         middle::liveness::check_crate(ty_cx, method_map, crate));\n \n-    time(time_passes, ~\"typestate checking\", ||\n-         middle::tstate::ck::check_crate(ty_cx, crate));\n-\n     let (root_map, mutbl_map) = time(time_passes, ~\"borrow checking\", ||\n         middle::borrowck::check_crate(ty_cx, method_map,\n                                       last_use_map, crate));"}, {"sha": "2e9b380314ae949a8074f6c31a3e08c2c2b48f04", "filename": "src/rustc/front/test.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Ftest.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -221,8 +221,7 @@ fn mk_tests(cx: test_ctxt) -> @ast::item {\n         {inputs: ~[],\n          output: ret_ty,\n          purity: ast::impure_fn,\n-         cf: ast::return_val,\n-         constraints: ~[]};\n+         cf: ast::return_val};\n \n     // The vector of test_descs for this crate\n     let test_descs = mk_test_desc_vec(cx);\n@@ -382,8 +381,7 @@ fn mk_test_wrapper(cx: test_ctxt,\n         inputs: ~[],\n         output: @{id: cx.sess.next_node_id(), node: ast::ty_nil, span: span},\n         purity: ast::impure_fn,\n-        cf: ast::return_val,\n-        constraints: ~[]\n+        cf: ast::return_val\n     };\n \n     let wrapper_body: ast::blk = nospan({\n@@ -436,8 +434,7 @@ fn mk_main(cx: test_ctxt) -> @ast::item {\n         {inputs: ~[args_arg],\n          output: @ret_ty,\n          purity: ast::impure_fn,\n-         cf: ast::return_val,\n-         constraints: ~[]};\n+         cf: ast::return_val};\n \n     let test_main_call_expr = mk_test_main_call(cx);\n "}, {"sha": "28056838a7a20edcb23df1a6b34587426cf005ce", "filename": "src/rustc/metadata/tydecode.rs", "status": "modified", "additions": 1, "deletions": 87, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftydecode.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -63,31 +63,6 @@ fn parse_ret_ty(st: @pstate, conv: conv_did) -> (ast::ret_style, ty::t) {\n     }\n }\n \n-fn parse_constrs_gen<T: copy>(st: @pstate, conv: conv_did,\n-                                       pser: fn(@pstate)\n-  -> ast::constr_arg_general_<T>) -> ~[@ty::constr_general<T>] {\n-    let mut rslt: ~[@ty::constr_general<T>] = ~[];\n-    alt peek(st) {\n-      ':' {\n-        loop {\n-          next(st);\n-          vec::push(rslt, parse_constr(st, conv, pser));\n-          if peek(st) != ';' { break; }\n-        }\n-      }\n-      _ {}\n-    }\n-    rslt\n-}\n-\n-fn parse_constrs(st: @pstate, conv: conv_did) -> ~[@ty::constr] {\n-    parse_constrs_gen(st, conv, parse_constr_arg)\n-}\n-\n-fn parse_ty_constrs(st: @pstate, conv: conv_did) -> ~[@ty::type_constr] {\n-    parse_constrs_gen(st, conv, parse_ty_constr_arg)\n-}\n-\n fn parse_path(st: @pstate) -> @ast::path {\n     let mut idents: ~[ast::ident] = ~[];\n     fn is_last(c: char) -> bool { ret c == '(' || c == ':'; }\n@@ -106,59 +81,6 @@ fn parse_path(st: @pstate) -> @ast::path {\n     };\n }\n \n-fn parse_constr_arg(st: @pstate) -> ast::fn_constr_arg {\n-    alt peek(st) {\n-      '*' { st.pos += 1u; ret ast::carg_base; }\n-      c {\n-\n-        /* how will we disambiguate between\n-           an arg index and a lit argument? */\n-        if c >= '0' && c <= '9' {\n-            next(st);\n-            // FIXME #877\n-            ret ast::carg_ident((c as uint) - 48u);\n-        } else {\n-            #error(\"Lit args are unimplemented\");\n-            fail; // FIXME #877\n-        }\n-        /*\n-          else {\n-          auto lit = parse_lit(st, conv, ',');\n-          vec::push(args, respan(st.span, ast::carg_lit(lit)));\n-          }\n-        */\n-      }\n-    }\n-}\n-\n-fn parse_ty_constr_arg(st: @pstate) -> ast::constr_arg_general_<@path> {\n-    alt peek(st) {\n-      '*' { st.pos += 1u; ret ast::carg_base; }\n-      c { ret ast::carg_ident(parse_path(st)); }\n-    }\n-}\n-\n-fn parse_constr<T: copy>(st: @pstate, conv: conv_did,\n-                         pser: fn(@pstate) -> ast::constr_arg_general_<T>)\n-    -> @ty::constr_general<T> {\n-    // FIXME: use real spans and not a bogus one (#2407)\n-    let sp = ast_util::dummy_sp();\n-    let mut args: ~[@sp_constr_arg<T>] = ~[];\n-    let pth = parse_path(st);\n-    let mut ignore: char = next(st);\n-    assert (ignore == '(');\n-    let def = parse_def(st, conv);\n-    let mut an_arg: constr_arg_general_<T>;\n-    loop {\n-        an_arg = pser(st);\n-        vec::push(args, @respan(sp, an_arg));\n-        ignore = next(st);\n-        if ignore != ';' { break; }\n-    }\n-    assert (ignore == ')');\n-    ret @respan(sp, {path: pth, args: args, id: def});\n-}\n-\n fn parse_ty_rust_fn(st: @pstate, conv: conv_did) -> ty::t {\n     ret ty::mk_fn(st.tcx, parse_ty_fn(st, conv));\n }\n@@ -363,13 +285,6 @@ fn parse_ty(st: @pstate, conv: conv_did) -> ty::t {\n           }\n         }\n       }\n-      'A' {\n-        assert (next(st) == '[');\n-        let tt = parse_ty(st, conv);\n-        let tcs = parse_ty_constrs(st, conv);\n-        assert (next(st) == ']');\n-        ret ty::mk_constr(st.tcx, tt, tcs);\n-      }\n       '\"' {\n         let def = parse_def(st, conv);\n         let inner = parse_ty(st, conv);\n@@ -457,10 +372,9 @@ fn parse_ty_fn(st: @pstate, conv: conv_did) -> ty::fn_ty {\n         vec::push(inputs, {mode: ast::expl(mode), ty: parse_ty(st, conv)});\n     }\n     st.pos += 1u; // eat the ']'\n-    let cs = parse_constrs(st, conv);\n     let (ret_style, ret_ty) = parse_ret_ty(st, conv);\n     ret {purity: purity, proto: proto, inputs: inputs, output: ret_ty,\n-         ret_style: ret_style, constraints: cs};\n+         ret_style: ret_style};\n }\n \n "}, {"sha": "9a6ddaf7c597efeb833932a3ee2daefc99e67b1a", "filename": "src/rustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Ftyencode.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -285,12 +285,6 @@ fn enc_sty(w: io::writer, cx: @ctxt, st: ty::sty) {\n       ty::ty_opaque_closure_ptr(ty::ck_block) { w.write_str(&\"C&\"); }\n       ty::ty_opaque_closure_ptr(ty::ck_box) { w.write_str(&\"C@\"); }\n       ty::ty_opaque_closure_ptr(ty::ck_uniq) { w.write_str(&\"C~\"); }\n-      ty::ty_constr(ty, cs) {\n-        w.write_str(&\"A[\");\n-        enc_ty(w, cx, ty);\n-        for cs.each |tc| { enc_ty_constr(w, cx, tc); }\n-        w.write_char(']');\n-      }\n       ty::ty_opaque_box { w.write_char('B'); }\n       ty::ty_class(def, substs) {\n           #debug(\"~~~~ %s\", ~\"a[\");\n@@ -344,55 +338,12 @@ fn enc_ty_fn(w: io::writer, cx: @ctxt, ft: ty::fn_ty) {\n         enc_ty(w, cx, arg.ty);\n     }\n     w.write_char(']');\n-    let mut colon = true;\n-    for ft.constraints.each |c| {\n-        if colon {\n-            w.write_char(':');\n-            colon = false;\n-        } else { w.write_char(';'); }\n-        enc_constr(w, cx, c);\n-    }\n     alt ft.ret_style {\n       noreturn { w.write_char('!'); }\n       _ { enc_ty(w, cx, ft.output); }\n     }\n }\n \n-fn enc_constr_gen<T>(w: io::writer, cx: @ctxt,\n-                  c: @ty::constr_general<T>,\n-                  write_arg: fn(@sp_constr_arg<T>)) {\n-    w.write_str(path_to_str(c.node.path));\n-    w.write_char('(');\n-    w.write_str(cx.ds(c.node.id));\n-    w.write_char('|');\n-    let mut semi = false;\n-    for c.node.args.each |a| {\n-        if semi { w.write_char(';'); } else { semi = true; }\n-        write_arg(a);\n-    }\n-    w.write_char(')');\n-}\n-\n-fn enc_constr(w: io::writer, cx: @ctxt, c: @ty::constr) {\n-    enc_constr_gen(w, cx, c, |a| {\n-      alt a.node {\n-        carg_base     { w.write_char('*'); }\n-        carg_ident(i) { w.write_uint(i); }\n-        carg_lit(l)   { w.write_str(lit_to_str(l)); }\n-      }\n-    });\n-}\n-\n-fn enc_ty_constr(w: io::writer, cx: @ctxt, c: @ty::type_constr) {\n-    enc_constr_gen(w, cx, c, |a| {\n-      alt a.node {\n-        carg_base     { w.write_char('*'); }\n-        carg_ident(p) { w.write_str(path_to_str(p)); }\n-        carg_lit(l)  { w.write_str(lit_to_str(l)); }\n-      }\n-    });\n-}\n-\n fn enc_bounds(w: io::writer, cx: @ctxt, bs: @~[ty::param_bound]) {\n     for vec::each(*bs) |bound| {\n         alt bound {"}, {"sha": "e7976cac2e6448e61eda050637a8201c512ac663", "filename": "src/rustc/middle/borrowck/categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fborrowck%2Fcategorization.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -167,11 +167,11 @@ impl public_methods for borrowck_ctxt {\n           ast::expr_addr_of(*) | ast::expr_call(*) |\n           ast::expr_swap(*) | ast::expr_move(*) | ast::expr_assign(*) |\n           ast::expr_assign_op(*) | ast::expr_fn(*) | ast::expr_fn_block(*) |\n-          ast::expr_assert(*) | ast::expr_check(*) | ast::expr_ret(*) |\n+          ast::expr_assert(*) | ast::expr_ret(*) |\n           ast::expr_loop_body(*) | ast::expr_do_body(*) | ast::expr_unary(*) |\n           ast::expr_copy(*) | ast::expr_cast(*) | ast::expr_fail(*) |\n           ast::expr_vstore(*) | ast::expr_vec(*) | ast::expr_tup(*) |\n-          ast::expr_if_check(*) | ast::expr_if(*) | ast::expr_log(*) |\n+          ast::expr_if(*) | ast::expr_log(*) |\n           ast::expr_new(*) | ast::expr_binary(*) | ast::expr_while(*) |\n           ast::expr_block(*) | ast::expr_loop(*) | ast::expr_alt(*) |\n           ast::expr_lit(*) | ast::expr_break | ast::expr_mac(*) |"}, {"sha": "02d24772c25d3e90b062f17e1d9a57d5ff8c3f65", "filename": "src/rustc/middle/liveness.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fliveness.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -453,8 +453,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       }\n \n       // live nodes required for interesting control flow:\n-      expr_if_check(*) | expr_if(*) | expr_alt(*) |\n-      expr_while(*) | expr_loop(*) {\n+      expr_if(*) | expr_alt(*) | expr_while(*) | expr_loop(*) {\n         (*self).add_live_node_for_node(expr.id, lnk_expr(expr.span));\n         visit::visit_expr(expr, self, vt);\n       }\n@@ -467,7 +466,7 @@ fn visit_expr(expr: @expr, &&self: @ir_maps, vt: vt<@ir_maps>) {\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n       expr_vec(*) | expr_rec(*) | expr_call(*) | expr_tup(*) |\n       expr_new(*) | expr_log(*) | expr_binary(*) |\n-      expr_assert(*) | expr_check(*) | expr_addr_of(*) | expr_copy(*) |\n+      expr_assert(*) | expr_addr_of(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) | expr_cast(*) |\n       expr_unary(*) | expr_fail(*) |\n       expr_break | expr_again | expr_lit(_) | expr_ret(*) |\n@@ -936,7 +935,6 @@ class liveness {\n             }\n           }\n \n-          expr_if_check(cond, then, els) |\n           expr_if(cond, then, els) {\n             //\n             //     (cond)\n@@ -1098,7 +1096,6 @@ class liveness {\n           }\n \n           expr_assert(e) |\n-          expr_check(_, e) |\n           expr_addr_of(_, e) |\n           expr_copy(e) |\n           expr_loop_body(e) |\n@@ -1449,12 +1446,12 @@ fn check_expr(expr: @expr, &&self: @liveness, vt: vt<@liveness>) {\n       }\n \n       // no correctness conditions related to liveness\n-      expr_if_check(*) | expr_if(*) | expr_alt(*) |\n+      expr_if(*) | expr_alt(*) |\n       expr_while(*) | expr_loop(*) |\n       expr_index(*) | expr_field(*) | expr_vstore(*) |\n       expr_vec(*) | expr_rec(*) | expr_tup(*) |\n       expr_new(*) | expr_log(*) | expr_binary(*) |\n-      expr_assert(*) | expr_check(*) | expr_copy(*) |\n+      expr_assert(*) | expr_copy(*) |\n       expr_loop_body(*) | expr_do_body(*) |\n       expr_cast(*) | expr_unary(*) | expr_fail(*) |\n       expr_ret(*) | expr_break | expr_again | expr_lit(_) |"}, {"sha": "a4c85bee55ea23f4a00c117e8d47b85709f7db36", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -428,7 +428,6 @@ fn resolve_names(e: @env, c: @ast::crate) {\n           visit_expr: |a,b,c| walk_expr(e, a, b ,c),\n           visit_ty: |a,b,c| walk_ty(e, a, b, c),\n           visit_ty_params: |a,b,c| walk_tps(e, a, b, c),\n-          visit_constr: |a,b,c,d,f| walk_constr(e, a, b, c, d, f),\n           visit_fn: |a,b,c,d,f,g,h| {\n               visit_fn_with_scope(e, a, b, c, d, f, g, h)\n           }\n@@ -662,7 +661,6 @@ fn visit_fn_with_scope(e: @env, fk: visit::fn_kind, decl: ast::fn_decl,\n \n     // here's where we need to set up the mapping\n     // for f's constrs in the table.\n-    for decl.constraints.each |c| { resolve_constr(e, c, sc, v); }\n     let scope = alt fk {\n       visit::fk_item_fn(_, tps) | visit::fk_method(_, tps, _)\n       | visit::fk_ctor(_, tps, _, _) | visit::fk_dtor(tps, _, _) {\n@@ -767,19 +765,6 @@ fn follow_import(e: env, &&sc: scopes, path: ~[ident], sp: span) ->\n     } else { ret none; }\n }\n \n-fn resolve_constr(e: @env, c: @ast::constr, &&sc: scopes, _v: vt<scopes>) {\n-    alt lookup_path_strict(*e, sc, c.span, c.node.path, ns_val) {\n-       some(d@ast::def_fn(_,ast::pure_fn)) {\n-         e.def_map.insert(c.node.id, d);\n-       }\n-       _ {\n-           let s = path_to_str(c.node.path);\n-           e.sess.span_err(c.span, #fmt(\"%s is not declared pure. Try \\\n-             `pure fn %s` instead of `fn %s`.\", s, s, s));\n-       }\n-    }\n-}\n-\n // Import resolution\n fn resolve_import(e: env, n_id: node_id, name: ast::ident,\n                   ids: ~[ast::ident], sp: codemap::span, &&sc: scopes) {"}, {"sha": "9e742f38bacf9b2256374ee2e01cf691648b9c0a", "filename": "src/rustc/middle/resolve3.rs", "status": "modified", "additions": 1, "deletions": 35, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fresolve3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve3.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -20,7 +20,7 @@ import syntax::ast::{item_ty, local, local_crate, method, node_id, pat};\n import syntax::ast::{pat_enum, pat_ident, path, prim_ty, stmt_decl, ty,\n                      pat_box, pat_uniq, pat_lit, pat_range, pat_rec,\n                      pat_tup, pat_wild};\n-import syntax::ast::{ty_bool, ty_char, ty_constr, ty_f, ty_f32, ty_f64};\n+import syntax::ast::{ty_bool, ty_char, ty_f, ty_f32, ty_f64};\n import syntax::ast::{ty_float, ty_i, ty_i16, ty_i32, ty_i64, ty_i8, ty_int};\n import syntax::ast::{ty_param, ty_path, ty_str, ty_u, ty_u16, ty_u32, ty_u64};\n import syntax::ast::{ty_u8, ty_uint, variant, view_item, view_item_export};\n@@ -3163,21 +3163,6 @@ class Resolver {\n                     }\n \n                     self.resolve_type(declaration.output, visitor);\n-\n-                    // Resolve constraints.\n-                    for declaration.constraints.each |constraint| {\n-                        alt self.resolve_path(constraint.node.path, ValueNS,\n-                                              false, visitor) {\n-                            none {\n-                                self.session.span_err(constraint.span,\n-                                    #fmt(\"unresolved name: %s\",\n-                                    *constraint.node.path.idents.last()));\n-                            }\n-                            some(def) {\n-                                self.record_def(constraint.node.id, def);\n-                            }\n-                        }\n-                    }\n                 }\n             }\n \n@@ -3560,25 +3545,6 @@ class Resolver {\n                 }\n             }\n \n-            ty_constr(base_type, constraints) {\n-                self.resolve_type(base_type, visitor);\n-\n-                for constraints.each |constraint| {\n-                    alt self.resolve_path(constraint.node.path, ValueNS,\n-                                          false, visitor) {\n-                        none {\n-                            self.session.span_err(constraint.span,\n-                                                  ~\"(resolving function) \\\n-                                                   use of undeclared \\\n-                                                   constraint\");\n-                        }\n-                        some(def) {\n-                            self.record_def(constraint.node.id, def);\n-                        }\n-                    }\n-                }\n-            }\n-\n             _ {\n                 // Just resolve embedded types.\n                 visit_ty(ty, (), visitor);"}, {"sha": "212ba14a516b281ebe3bf605f6ca8b7f0fda382d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 18, "deletions": 31, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -2002,19 +2002,23 @@ fn trans_external_path(ccx: @crate_ctxt, did: ast::def_id, t: ty::t)\n fn normalize_for_monomorphization(tcx: ty::ctxt, ty: ty::t) -> option<ty::t> {\n     // FIXME[mono] could do this recursively. is that worthwhile? (#2529)\n     alt ty::get(ty).struct {\n-      ty::ty_box(mt) { some(ty::mk_opaque_box(tcx)) }\n-      ty::ty_fn(fty) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n-                                            proto: fty.proto,\n-                                            inputs: ~[],\n-                                            output: ty::mk_nil(tcx),\n-                                            ret_style: ast::return_val,\n-                                            constraints: ~[]})) }\n-      ty::ty_trait(_, _) { some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n-                                                proto: ast::proto_box,\n-                                                inputs: ~[],\n-                                                output: ty::mk_nil(tcx),\n-                                                ret_style: ast::return_val,\n-                                                constraints: ~[]})) }\n+      ty::ty_box(mt) {\n+        some(ty::mk_opaque_box(tcx))\n+      }\n+      ty::ty_fn(fty) {\n+        some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                             proto: fty.proto,\n+                             inputs: ~[],\n+                             output: ty::mk_nil(tcx),\n+                             ret_style: ast::return_val}))\n+      }\n+      ty::ty_trait(_, _) {\n+        some(ty::mk_fn(tcx, {purity: ast::impure_fn,\n+                             proto: ast::proto_box,\n+                             inputs: ~[],\n+                             output: ty::mk_nil(tcx),\n+                             ret_style: ast::return_val}))\n+      }\n       ty::ty_ptr(_) { some(ty::mk_uint(tcx)) }\n       _ { none }\n     }\n@@ -3525,7 +3529,7 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n     fn unrooted(bcx: block, e: @ast::expr, dest: dest) -> block {\n         let tcx = bcx.tcx();\n         alt e.node {\n-          ast::expr_if(cond, thn, els) | ast::expr_if_check(cond, thn, els) {\n+          ast::expr_if(cond, thn, els) {\n             ret trans_if(bcx, cond, thn, els, dest);\n           }\n           ast::expr_alt(expr, arms, mode) {\n@@ -3631,23 +3635,6 @@ fn trans_expr(bcx: block, e: @ast::expr, dest: dest) -> block {\n             assert dest == ignore;\n             ret trans_check_expr(bcx, e, a, ~\"Assertion\");\n           }\n-          ast::expr_check(ast::checked_expr, a) {\n-            assert dest == ignore;\n-            ret trans_check_expr(bcx, e, a, ~\"Predicate\");\n-          }\n-          ast::expr_check(ast::claimed_expr, a) {\n-            assert dest == ignore;\n-            /* Claims are turned on and off by a global variable\n-            that the RTS sets. This case generates code to\n-            check the value of that variable, doing nothing\n-            if it's set to false and acting like a check\n-            otherwise. */\n-            let c = get_extern_const(bcx.ccx().externs, bcx.ccx().llmod,\n-                                     ~\"check_claims\", T_bool());\n-            ret do with_cond(bcx, Load(bcx, c)) |bcx| {\n-                trans_check_expr(bcx, e, a, ~\"Claim\")\n-            };\n-          }\n           ast::expr_while(cond, body) {\n             assert dest == ignore;\n             ret trans_while(bcx, cond, body);"}, {"sha": "fca21eb3a8eef7f36f213531d0c8288b34a3b654", "filename": "src/rustc/middle/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -976,8 +976,7 @@ fn trans_intrinsic(ccx: @crate_ctxt, decl: ValueRef, item: @ast::foreign_item,\n                     ty::mk_mach_uint(bcx.tcx(), ast::ty_u8))\n             }],\n             output: ty::mk_nil(bcx.tcx()),\n-            ret_style: ast::return_val,\n-            constraints: ~[]\n+            ret_style: ast::return_val\n         });\n         bcx = trans_call_inner(bcx, none, fty, ty::mk_nil(bcx.tcx()),\n                                |bcx| lval_no_env("}, {"sha": "6ce5f2f387d7f44676210dd9c42e1f6fc0ce09ef", "filename": "src/rustc/middle/trans/reflect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -276,7 +276,6 @@ impl methods for reflector {\n           ty::ty_self { self.leaf(~\"self\") }\n           ty::ty_type { self.leaf(~\"type\") }\n           ty::ty_opaque_box { self.leaf(~\"opaque_box\") }\n-          ty::ty_constr(t, _) { self.visit(~\"constr\", ~[self.c_tydesc(t)]) }\n           ty::ty_opaque_closure_ptr(ck) {\n             let ckval = alt ck {\n               ty::ck_block { 0u }"}, {"sha": "71a15b7f05ee6ed661ef41b1b5e32311cc1d764b", "filename": "src/rustc/middle/trans/shape.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fshape.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -357,7 +357,6 @@ fn shape_of(ccx: @crate_ctxt, t: ty::t) -> ~[u8] {\n       ty::ty_fn({proto: ast::proto_any, _}) { ~[shape_stack_fn] }\n       ty::ty_fn({proto: ast::proto_bare, _}) { ~[shape_bare_fn] }\n       ty::ty_opaque_closure_ptr(_) { ~[shape_opaque_closure_ptr] }\n-      ty::ty_constr(inner_t, _) { shape_of(ccx, inner_t) }\n       ty::ty_var(_) | ty::ty_var_integral(_) | ty::ty_self {\n         ccx.sess.bug(~\"shape_of: unexpected type struct found\");\n       }"}, {"sha": "ab3384dad2511f33d65a04a838d054defe92ebf2", "filename": "src/rustc/middle/trans/type_of.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -148,7 +148,6 @@ fn type_of(cx: @crate_ctxt, t: ty::t) -> TypeRef {\n             T_struct(tys)\n           }\n           ty::ty_opaque_closure_ptr(_) { T_opaque_box_ptr(cx) }\n-          ty::ty_constr(subt,_) { type_of(cx, subt) }\n           ty::ty_class(*) {\n             // Only create the named struct, but don't fill it in. We fill it\n             // in *after* placing it into the type cache. This prevents"}, {"sha": "95dfffff07e60ba8e5705dd6bd70c9c677b29e91", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -243,8 +243,8 @@ fn mark_for_expr(cx: ctx, e: @expr) {\n       }\n       expr_alt(_, _, _) | expr_block(_) | expr_if(_, _, _) |\n       expr_while(_, _) | expr_fail(_) | expr_break | expr_again |\n-      expr_unary(_, _) | expr_lit(_) | expr_assert(_) | expr_check(_, _) |\n-      expr_if_check(_, _, _) | expr_mac(_) | expr_addr_of(_, _) |\n+      expr_unary(_, _) | expr_lit(_) | expr_assert(_) |\n+      expr_mac(_) | expr_addr_of(_, _) |\n       expr_ret(_) | expr_loop(_) |\n       expr_loop_body(_) | expr_do_body(_) {}\n     }"}, {"sha": "83151d8627a24c230a0bb650ef8503eeafccaedc", "filename": "src/rustc/middle/tstate/bitvectors.rs", "status": "removed", "additions": 0, "deletions": 186, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,186 +0,0 @@\n-import syntax::ast::*;\n-import syntax::visit;\n-import option::*;\n-import aux::*;\n-import tstate::ann::{pre_and_post, precond, postcond, prestate, poststate,\n-                     relax_prestate, relax_precond, relax_poststate,\n-                     pps_len, true_precond,\n-                     difference, union, clone,\n-                     set_in_postcond, set_in_poststate, set_in_poststate_,\n-                     clear_in_poststate, clear_in_prestate,\n-                     clear_in_poststate_};\n-import tritv::*;\n-import driver::session::session;\n-import std::map::hashmap;\n-\n-fn bit_num(fcx: fn_ctxt, c: tsconstr) -> uint {\n-    let d = c.def_id;\n-    assert (fcx.enclosing.constrs.contains_key(d));\n-    let rslt = fcx.enclosing.constrs.get(d);\n-    match_args(fcx, rslt.descs, c.args)\n-}\n-\n-fn promises(fcx: fn_ctxt, p: poststate, c: tsconstr) -> bool {\n-    ret promises_(bit_num(fcx, c), p);\n-}\n-\n-fn promises_(n: uint, p: poststate) -> bool {\n-    ret tritv_get(p, n) == ttrue;\n-}\n-\n-// v \"happens after\" u\n-fn seq_trit(u: trit, v: trit) -> trit {\n-    alt v { ttrue { ttrue } tfalse { tfalse } dont_care { u } }\n-}\n-\n-// idea: q \"happens after\" p -- so if something is\n-// 1 in q and 0 in p, it's 1 in the result; however,\n-// if it's 0 in q and 1 in p, it's 0 in the result\n-fn seq_tritv(p: postcond, q: postcond) {\n-    let mut i = 0u;\n-    assert (p.nbits == q.nbits);\n-    while i < p.nbits {\n-        tritv_set(i, p, seq_trit(tritv_get(p, i), tritv_get(q, i)));\n-        i += 1u;\n-    }\n-}\n-\n-fn seq_postconds(fcx: fn_ctxt, ps: ~[postcond]) -> postcond {\n-    let sz = vec::len(ps);\n-    if sz >= 1u {\n-        let prev = tritv_clone(ps[0]);\n-        vec::iter_between(ps, 1u, sz, |p| seq_tritv(prev, p) );\n-        ret prev;\n-    } else { ret ann::empty_poststate(num_constraints(fcx.enclosing)); }\n-}\n-\n-// Given a list of pres and posts for exprs e0 ... en,\n-// return the precondition for evaluating each expr in order.\n-// So, if e0's post is {x} and e1's pre is {x, y, z}, the entire\n-// precondition shouldn't include x.\n-fn seq_preconds(fcx: fn_ctxt, pps: ~[pre_and_post]) -> precond {\n-    let sz: uint = vec::len(pps);\n-    let num_vars: uint = num_constraints(fcx.enclosing);\n-\n-    fn seq_preconds_go(fcx: fn_ctxt, pps: ~[pre_and_post],\n-                       idx: uint, first: pre_and_post)\n-       -> precond {\n-        let mut idx = idx;\n-        let mut first = first;\n-        loop {\n-            let sz: uint = vec::len(pps) - idx;\n-            if sz >= 1u {\n-                let second = pps[0];\n-                assert (pps_len(second) == num_constraints(fcx.enclosing));\n-                let second_pre = clone(second.precondition);\n-                difference(second_pre, first.postcondition);\n-                let next_first = clone(first.precondition);\n-                union(next_first, second_pre);\n-                let next_first_post = clone(first.postcondition);\n-                seq_tritv(next_first_post, second.postcondition);\n-                idx += 1u;\n-                first = {precondition: next_first,\n-                         postcondition: next_first_post};\n-            } else { ret first.precondition; }\n-        }\n-    }\n-\n-    if sz >= 1u {\n-        let first = pps[0];\n-        assert (pps_len(first) == num_vars);\n-        ret seq_preconds_go(fcx, pps, 1u, first);\n-    } else { ret true_precond(num_vars); }\n-}\n-\n-fn intersect_states(p: prestate, q: prestate) -> prestate {\n-    let rslt = tritv_clone(p);\n-    tritv_intersect(rslt, q);\n-    ret rslt;\n-}\n-\n-fn gen(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n-    ret set_in_postcond(bit_num(fcx, c),\n-                        node_id_to_ts_ann(fcx.ccx, id).conditions);\n-}\n-\n-fn declare_var(fcx: fn_ctxt, c: tsconstr, pre: prestate) -> prestate {\n-    let rslt = clone(pre);\n-    relax_prestate(bit_num(fcx, c), rslt);\n-    // idea is this is scoped\n-    relax_poststate(bit_num(fcx, c), rslt);\n-    ret rslt;\n-}\n-\n-fn relax_precond_expr(e: @expr, cx: relax_ctxt, vt: visit::vt<relax_ctxt>) {\n-    relax_precond(cx.i as uint, expr_precond(cx.fcx.ccx, e));\n-    visit::visit_expr(e, cx, vt);\n-}\n-\n-fn relax_precond_stmt(s: @stmt, cx: relax_ctxt, vt: visit::vt<relax_ctxt>) {\n-    relax_precond(cx.i as uint, stmt_precond(cx.fcx.ccx, *s));\n-    visit::visit_stmt(s, cx, vt);\n-}\n-\n-type relax_ctxt = {fcx: fn_ctxt, i: node_id};\n-\n-fn relax_precond_block_inner(b: blk, cx: relax_ctxt,\n-                             vt: visit::vt<relax_ctxt>) {\n-    relax_precond(cx.i as uint, block_precond(cx.fcx.ccx, b));\n-    visit::visit_block(b, cx, vt);\n-}\n-\n-fn relax_precond_block(fcx: fn_ctxt, i: node_id, b: blk) {\n-    let cx = {fcx: fcx, i: i};\n-    let visitor = visit::default_visitor::<relax_ctxt>();\n-    let visitor =\n-        @{visit_block: relax_precond_block_inner,\n-          visit_expr: relax_precond_expr,\n-          visit_stmt: relax_precond_stmt,\n-          visit_item:\n-              fn@(_i: @item, _cx: relax_ctxt, _vt: visit::vt<relax_ctxt>) { },\n-          visit_fn: do_nothing\n-             with *visitor};\n-    let v1 = visit::mk_vt(visitor);\n-    v1.visit_block(b, cx, v1);\n-}\n-\n-fn gen_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n-    #debug(\"gen_poststate\");\n-    ret set_in_poststate(bit_num(fcx, c),\n-                         node_id_to_ts_ann(fcx.ccx, id).states);\n-}\n-\n-fn kill_prestate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n-    ret clear_in_prestate(bit_num(fcx, c),\n-                          node_id_to_ts_ann(fcx.ccx, id).states);\n-}\n-\n-fn kill_all_prestate(fcx: fn_ctxt, id: node_id) {\n-    tritv::tritv_kill(node_id_to_ts_ann(fcx.ccx, id).states.prestate);\n-}\n-\n-\n-fn kill_poststate(fcx: fn_ctxt, id: node_id, c: tsconstr) -> bool {\n-    #debug(\"kill_poststate\");\n-    ret clear_in_poststate(bit_num(fcx, c),\n-                           node_id_to_ts_ann(fcx.ccx, id).states);\n-}\n-\n-fn kill_poststate_(fcx: fn_ctxt, c: tsconstr, post: poststate) -> bool {\n-    #debug(\"kill_poststate_\");\n-    ret clear_in_poststate_(bit_num(fcx, c), post);\n-}\n-\n-fn set_in_prestate_constr(fcx: fn_ctxt, c: tsconstr, t: prestate) -> bool {\n-    ret set_in_poststate_(bit_num(fcx, c), t);\n-}\n-\n-//\n-// Local Variables:\n-// mode: rust\n-// fill-column: 78;\n-// indent-tabs-mode: nil\n-// c-basic-offset: 4\n-// buffer-file-coding-system: utf-8-unix\n-// End:\n-//"}, {"sha": "0e724321b3ef98e76eee1e39781d802e5cf86a16", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 23, "deletions": 146, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -15,7 +15,7 @@ import middle::lint::{get_warning_level, vecs_not_implicitly_copyable,\n                       ignore};\n import syntax::ast::*;\n import syntax::print::pprust::*;\n-import util::ppaux::{ty_to_str, tys_to_str, ty_constr_to_str};\n+import util::ppaux::{ty_to_str, tys_to_str};\n \n export tv_vid, tvi_vid, region_vid, vid;\n export br_hashmap;\n@@ -24,12 +24,8 @@ export node_id_to_type;\n export node_id_to_type_params;\n export arg;\n export args_eq;\n-export ast_constr_to_constr;\n export block_ty;\n export class_items_as_fields, class_items_as_mutable_fields;\n-export constr;\n-export constr_general;\n-export constr_table;\n export ctxt;\n export deref, deref_sty;\n export index, index_sty;\n@@ -76,10 +72,8 @@ export ty_param_bounds_and_ty;\n export ty_bool, mk_bool, type_is_bool;\n export ty_bot, mk_bot, type_is_bot;\n export ty_box, mk_box, mk_imm_box, type_is_box, type_is_boxed;\n-export ty_constr, mk_constr;\n export ty_opaque_closure_ptr, mk_opaque_closure_ptr;\n export ty_opaque_box, mk_opaque_box;\n-export ty_constr_arg;\n export ty_float, mk_float, mk_mach_float, type_is_fp;\n export ty_fn, fn_ty, mk_fn;\n export ty_fn_proto, ty_fn_ret, ty_fn_ret_style, tys_in_fn_ty;\n@@ -113,7 +107,6 @@ export tbox_has_flag;\n export ty_var_id;\n export ty_to_def_id;\n export ty_fn_args;\n-export type_constr;\n export kind, kind_implicitly_copyable, kind_sendable, kind_copyable;\n export kind_noncopyable, kind_const;\n export kind_can_be_copied, kind_can_be_sent, kind_can_be_implicitly_copied;\n@@ -168,7 +161,7 @@ export terr_no_integral_type, terr_ty_param_size, terr_self_substs;\n export terr_in_field, terr_record_fields, terr_vstores_differ, terr_arg_count;\n export terr_sorts, terr_vec, terr_str, terr_record_size, terr_tuple_size;\n export terr_regions_differ, terr_mutability, terr_purity_mismatch;\n-export terr_constr_mismatch, terr_constr_len, terr_proto_mismatch;\n+export terr_proto_mismatch;\n export terr_ret_style_mismatch;\n \n // Data types\n@@ -187,8 +180,6 @@ type method = {ident: ast::ident,\n                purity: ast::purity,\n                vis: ast::visibility};\n \n-type constr_table = hashmap<ast::node_id, ~[constr]>;\n-\n type mt = {ty: t, mutbl: ast::mutability};\n \n enum vstore {\n@@ -316,8 +307,7 @@ type fn_ty = {purity: ast::purity,\n               proto: ast::proto,\n               inputs: ~[arg],\n               output: t,\n-              ret_style: ret_style,\n-              constraints: ~[@constr]};\n+              ret_style: ret_style};\n \n // See discussion at head of region.rs\n enum region {\n@@ -379,7 +369,6 @@ enum sty {\n                               // integral types only\n     ty_param(uint, def_id), // type parameter\n     ty_self, // special, implicit `self` type parameter\n-    ty_constr(t, ~[@type_constr]),\n \n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n@@ -388,12 +377,6 @@ enum sty {\n     ty_unboxed_vec(mt),\n }\n \n-// In the middle end, constraints have a def_id attached, referring\n-// to the definition of the operator in the constraint.\n-type constr_general<ARG> = spanned<constr_general_<ARG, def_id>>;\n-type type_constr = constr_general<@path>;\n-type constr = constr_general<uint>;\n-\n enum terr_vstore_kind {\n     terr_vec, terr_str\n }\n@@ -416,8 +399,6 @@ enum type_err {\n     terr_record_fields(ast::ident, ast::ident),\n     terr_arg_count,\n     terr_mode_mismatch(mode, mode),\n-    terr_constr_len(uint, uint),\n-    terr_constr_mismatch(@type_constr, @type_constr),\n     terr_regions_differ(region, region),\n     terr_vstores_differ(terr_vstore_kind, vstore, vstore),\n     terr_in_field(@type_err, ast::ident),\n@@ -607,9 +588,6 @@ fn mk_t_with_id(cx: ctxt, st: sty, o_def_id: option<ast::def_id>) -> t {\n         for f.inputs.each |a| { flags |= get(a.ty).flags; }\n         flags |= get(f.output).flags;\n       }\n-      ty_constr(tt, _) {\n-        flags |= get(tt).flags;\n-      }\n     }\n     let t = @{struct: st, id: cx.next_id, flags: flags, o_def_id: o_def_id};\n     cx.interner.insert(key, t);\n@@ -700,10 +678,6 @@ fn mk_mut_unboxed_vec(cx: ctxt, ty: t) -> t {\n \n fn mk_rec(cx: ctxt, fs: ~[field]) -> t { mk_t(cx, ty_rec(fs)) }\n \n-fn mk_constr(cx: ctxt, t: t, cs: ~[@type_constr]) -> t {\n-    mk_t(cx, ty_constr(t, cs))\n-}\n-\n fn mk_tup(cx: ctxt, ts: ~[t]) -> t { mk_t(cx, ty_tup(ts)) }\n \n fn mk_fn(cx: ctxt, fty: fn_ty) -> t { mk_t(cx, ty_fn(fty)) }\n@@ -790,7 +764,6 @@ fn maybe_walk_ty(ty: t, f: fn(t) -> bool) {\n         for ft.inputs.each |a| { maybe_walk_ty(a.ty, f); }\n         maybe_walk_ty(ft.output, f);\n       }\n-      ty_constr(sub, _) { maybe_walk_ty(sub, f); }\n       ty_uniq(tm) { maybe_walk_ty(tm.ty, f); }\n     }\n }\n@@ -851,9 +824,6 @@ fn fold_sty(sty: sty, fldop: fn(t) -> t) -> sty {\n       ty_rptr(r, tm) {\n         ty_rptr(r, {ty: fldop(tm.ty), mutbl: tm.mutbl})\n       }\n-      ty_constr(subty, cs) {\n-        ty_constr(fldop(subty), cs)\n-      }\n       ty_class(did, substs) {\n         ty_class(did, fold_substs(substs, fldop))\n       }\n@@ -1589,7 +1559,6 @@ fn type_kind(cx: ctxt, ty: t) -> kind {\n       ty_param(_, did) {\n         param_bounds_to_kind(cx.ty_param_bounds.get(did.node))\n       }\n-      ty_constr(t, _) { type_kind(cx, t) }\n       // FIXME (#2663): is self ever const?\n       ty_self { kind_noncopyable() }\n       ty_var(_) | ty_var_integral(_) {\n@@ -1651,11 +1620,6 @@ fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n           ty_unboxed_vec(_) {\n             false\n           }\n-\n-          ty_constr(t, _) {\n-            type_requires(cx, seen, r_ty, t)\n-          }\n-\n           ty_box(mt) |\n           ty_uniq(mt) |\n           ty_rptr(_, mt) {\n@@ -1836,7 +1800,6 @@ fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_evec(mt, vstore_fixed(_)) | ty_unboxed_vec(mt) {\n         result = type_is_pod(cx, mt.ty);\n       }\n-      ty_constr(subt, _) { result = type_is_pod(cx, subt); }\n       ty_param(_, _) { result = false; }\n       ty_opaque_closure_ptr(_) { result = true; }\n       ty_class(did, substs) {\n@@ -1967,18 +1930,6 @@ fn hash_type_structure(st: sty) -> uint {\n         for subtys.each |s| { h = (h << 2u) + type_id(s) }\n         h\n     }\n-    fn hash_type_constr(id: uint, c: @type_constr) -> uint {\n-        let mut h = id;\n-        h = (h << 2u) + hash_def(h, c.node.id);\n-        for c.node.args.each |a| {\n-            alt a.node {\n-              carg_base { h += h << 2u; }\n-              carg_lit(_) { fail ~\"lit args not implemented yet\"; }\n-              carg_ident(p) { h += h << 2u; }\n-            }\n-        }\n-        h\n-    }\n     fn hash_region(r: region) -> uint {\n         alt r { // no idea if this is any good\n           re_bound(br) { (hash_bound_region(br)) << 2u | 0u }\n@@ -2036,11 +1987,6 @@ fn hash_type_structure(st: sty) -> uint {\n       ty_type { 32u }\n       ty_bot { 34u }\n       ty_ptr(mt) { hash_subty(35u, mt.ty) }\n-      ty_constr(t, cs) {\n-        let mut h = hash_subty(36u, t);\n-        for cs.each |c| { h = (h << 2u) + hash_type_constr(h, c); }\n-        h\n-      }\n       ty_uniq(mt) { hash_subty(37u, mt.ty) }\n       ty_trait(did, substs) {\n         let mut h = hash_def(40u, did);\n@@ -2061,49 +2007,6 @@ fn hash_type_structure(st: sty) -> uint {\n     }\n }\n \n-fn arg_eq<T>(eq: fn(T, T) -> bool,\n-             a: @sp_constr_arg<T>,\n-             b: @sp_constr_arg<T>)\n-   -> bool {\n-    alt a.node {\n-      ast::carg_base {\n-        alt b.node { ast::carg_base { ret true; } _ { ret false; } }\n-      }\n-      ast::carg_ident(s) {\n-        alt b.node { ast::carg_ident(t) { ret eq(s, t); } _ { ret false; } }\n-      }\n-      ast::carg_lit(l) {\n-        alt b.node {\n-          ast::carg_lit(m) { ret const_eval::lit_eq(l, m); } _ { ret false; }\n-        }\n-      }\n-    }\n-}\n-\n-fn args_eq<T>(eq: fn(T, T) -> bool,\n-              a: ~[@sp_constr_arg<T>],\n-              b: ~[@sp_constr_arg<T>]) -> bool {\n-    let mut i: uint = 0u;\n-    for a.each |arg| {\n-        if !arg_eq(eq, arg, b[i]) { ret false; }\n-        i += 1u;\n-    }\n-    ret true;\n-}\n-\n-fn constr_eq(c: @constr, d: @constr) -> bool {\n-    fn eq_int(&&x: uint, &&y: uint) -> bool { ret x == y; }\n-    ret path_to_str(c.node.path) == path_to_str(d.node.path) &&\n-            args_eq(eq_int, c.node.args, d.node.args);\n-}\n-\n-fn constrs_eq(cs: ~[@constr], ds: ~[@constr]) -> bool {\n-    if vec::len(cs) != vec::len(ds) { ret false; }\n-    let mut i = 0u;\n-    for cs.each |c| { if !constr_eq(c, ds[i]) { ret false; } i += 1u; }\n-    ret true;\n-}\n-\n fn node_id_to_type(cx: ctxt, id: ast::node_id) -> t {\n     alt smallintmap::find(*cx.node_types, id as uint) {\n        some(t) { t }\n@@ -2385,7 +2288,6 @@ fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_var_integral(_) { ~\"integral variable\" }\n       ty_param(_, _) { ~\"type parameter\" }\n       ty_self { ~\"self\" }\n-      ty_constr(t, _) { ty_sort_str(cx, t) }\n     }\n }\n \n@@ -2443,16 +2345,6 @@ fn type_err_to_str(cx: ctxt, err: type_err) -> ~str {\n         ret ~\"expected argument mode \" + mode_to_str(e_mode) +\n             ~\" but found \" + mode_to_str(a_mode);\n       }\n-      terr_constr_len(e_len, a_len) {\n-        ret ~\"expected a type with \" + uint::str(e_len) +\n-            ~\" constraints, but found one with \" + uint::str(a_len) +\n-            ~\" constraints\";\n-      }\n-      terr_constr_mismatch(e_constr, a_constr) {\n-        ret ~\"expected a type with constraint \" + ty_constr_to_str(e_constr) +\n-            ~\" but found one with constraint \" +\n-            ty_constr_to_str(a_constr);\n-      }\n       terr_regions_differ(subregion, superregion) {\n         ret #fmt(\"references with lifetime %s do not necessarily \\\n                   outlive references with lifetime %s\",\n@@ -2784,30 +2676,33 @@ pure fn is_public(f: field_ty) -> bool {\n   }\n }\n \n-// Look up the list of method names and IDs for a given class\n-// Fails if the id is not bound to a class.\n-fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n-    : is_local(did) -> ~[{name: ident, id: node_id, vis: visibility}] {\n-    alt cx.items.find(did.node) {\n-       some(ast_map::node_item(@{node: item_class(_,_,items,_,_), _}, _)) {\n-         let (_,ms) = split_class_items(items);\n-         vec::map(ms, |m| {name: m.ident, id: m.id,\n-                            vis: m.vis})\n-       }\n-       _ {\n-           cx.sess.bug(~\"lookup_class_method_ids: id not bound to a class\");\n-       }\n-    }\n-}\n-\n /* Given a class def_id and a method name, return the method's\n  def_id. Needed so we can do static dispatch for methods\n  Doesn't care about the method's privacy. (It's assumed that\n  the caller already checked that.)\n */\n fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n                                sp: span) -> def_id {\n-    if check is_local(did) {\n+\n+    // Look up the list of method names and IDs for a given class\n+    // Fails if the id is not bound to a class.\n+    fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n+        -> ~[{name: ident, id: node_id, vis: visibility}] {\n+\n+        assert is_local(did);\n+        alt cx.items.find(did.node) {\n+          some(ast_map::node_item(@{node: item_class(_,_,items,_,_), _}, _)) {\n+            let (_,ms) = split_class_items(items);\n+            vec::map(ms, |m| {name: m.ident, id: m.id,\n+                              vis: m.vis})\n+          }\n+          _ {\n+            cx.sess.bug(~\"lookup_class_method_ids: id not bound to a class\");\n+          }\n+        }\n+    }\n+\n+    if is_local(did) {\n        let ms = lookup_class_method_ids(cx, did);\n         for ms.each |m| {\n          if m.name == name {\n@@ -2939,24 +2834,6 @@ fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n     ret tbl[tycat(ty)][opcat(op)];\n }\n \n-fn ast_constr_to_constr<T>(tcx: ctxt, c: @ast::constr_general<T>) ->\n-   @constr_general<T> {\n-    alt tcx.def_map.find(c.node.id) {\n-      some(ast::def_fn(pred_id, ast::pure_fn)) {\n-        ret @ast_util::respan(c.span,\n-                              {path: c.node.path,\n-                               args: c.node.args,\n-                               id: pred_id});\n-      }\n-      _ {\n-        tcx.sess.span_fatal(c.span,\n-                            ~\"predicate \" + path_to_str(c.node.path) +\n-                            ~\" is unbound or bound to a non-function or an \\\n-            impure function\");\n-      }\n-    }\n-}\n-\n fn ty_params_to_tys(tcx: ty::ctxt, tps: ~[ast::ty_param]) -> ~[t] {\n     vec::from_fn(tps.len(), |i| {\n                 ty::mk_param(tcx, i, ast_util::local_def(tps[i].id))"}, {"sha": "51f87c697a5046d188083255332baa9f6cefa2e8", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -240,7 +240,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n     let main_t = ty::node_id_to_type(tcx, main_id);\n     alt ty::get(main_t).struct {\n       ty::ty_fn({purity: ast::impure_fn, proto: ast::proto_bare,\n-                 inputs, output, ret_style: ast::return_val, constraints}) {\n+                 inputs, output, ret_style: ast::return_val}) {\n         alt tcx.items.find(main_id) {\n          some(ast_map::node_item(it,_)) {\n              alt it.node {\n@@ -254,8 +254,7 @@ fn check_main_fn_ty(ccx: @crate_ctxt,\n          }\n          _ {}\n         }\n-        let mut ok = vec::len(constraints) == 0u;\n-        ok &= ty::type_is_nil(output);\n+        let mut ok = ty::type_is_nil(output);\n         let num_args = vec::len(inputs);\n         ok &= num_args == 0u || num_args == 1u &&\n               arg_is_argv_ty(tcx, inputs[0]);"}, {"sha": "1b1bf7732cbfbd348ce6731caf2731cb06e95168", "filename": "src/rustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -332,13 +332,6 @@ fn ast_ty_to_ty<AC: ast_conv, RS: region_scope copy>(\n             ast_ty.span,\n             ~\"implied fixed length for bound\");\n       }\n-      ast::ty_constr(t, cs) {\n-        let mut out_cs = ~[];\n-        for cs.each |constr| {\n-            vec::push(out_cs, ty::ast_constr_to_constr(tcx, constr));\n-        }\n-        ty::mk_constr(tcx, ast_ty_to_ty(self, rscope, t), out_cs)\n-      }\n       ast::ty_infer {\n         // ty_infer should only appear as the type of arguments or return\n         // values in a fn_expr, or as the type of local variables.  Both of\n@@ -429,12 +422,8 @@ fn ty_of_fn_decl<AC: ast_conv, RS: region_scope copy>(\n           _ {ast_ty_to_ty(self, rb, decl.output)}\n         };\n \n-        let out_constrs = vec::map(decl.constraints, |constr| {\n-            ty::ast_constr_to_constr(self.tcx(), constr)\n-        });\n-\n         {purity: decl.purity, proto: proto, inputs: input_tys,\n-         output: output_ty, ret_style: decl.cf, constraints: out_constrs}\n+         output: output_ty, ret_style: decl.cf}\n     }\n }\n "}, {"sha": "4f5ea3fe4f8eea81fae3e1c44585ac39719856e1", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 3, "deletions": 129, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -225,7 +225,6 @@ fn check_fn(ccx: @crate_ctxt,\n     };\n \n     gather_locals(fcx, decl, body, arg_tys);\n-    check_constraints(fcx, decl.constraints, decl.inputs);\n     check_block(fcx, body);\n \n     // We unify the tail expr's type with the\n@@ -1342,15 +1341,6 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         check_expr(fcx, e, none);\n         fcx.write_nil(id);\n       }\n-      ast::expr_check(_, e) {\n-        bot = check_pred_expr(fcx, e);\n-        fcx.write_nil(id);\n-      }\n-      ast::expr_if_check(cond, thn, elsopt) {\n-        bot =\n-            check_pred_expr(fcx, cond) |\n-                check_then_else(fcx, thn, elsopt, id, expr.span);\n-      }\n       ast::expr_assert(e) {\n         bot = check_expr_with(fcx, e, ty::mk_bool(tcx));\n         fcx.write_nil(id);\n@@ -1643,8 +1633,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                 proto: ast::proto_any,\n                                 inputs: ~[{mode: m, ty: ty_nilp}],\n                                 output: ty_nilp,\n-                                ret_style: ast::return_val,\n-                                constraints: ~[]})\n+                                ret_style: ast::return_val})\n             };\n \n             demand::suptype(fcx, expr.span,\n@@ -1893,119 +1882,6 @@ fn check_enum_variants(ccx: @crate_ctxt,\n     check_instantiable(ccx.tcx, sp, id);\n }\n \n-// A generic function for checking the pred in a check\n-// or if-check\n-fn check_pred_expr(fcx: @fn_ctxt, e: @ast::expr) -> bool {\n-    let bot = check_expr_with(fcx, e, ty::mk_bool(fcx.ccx.tcx));\n-\n-    /* e must be a call expr where all arguments are either\n-    literals or slots */\n-    alt e.node {\n-      ast::expr_call(operator, operands, _) {\n-        if !ty::is_pred_ty(fcx.expr_ty(operator)) {\n-            fcx.ccx.tcx.sess.span_err\n-                (operator.span,\n-                 ~\"operator in constraint has non-boolean return type\");\n-        }\n-\n-        alt operator.node {\n-          ast::expr_path(oper_name) {\n-            alt fcx.ccx.tcx.def_map.find(operator.id) {\n-              some(ast::def_fn(_, ast::pure_fn)) {\n-                // do nothing\n-              }\n-              _ {\n-                fcx.ccx.tcx.sess.span_err(operator.span,\n-                                            ~\"impure function as operator \\\n-                                             in constraint\");\n-              }\n-            }\n-            for operands.each |operand| {\n-                if !ast_util::is_constraint_arg(operand) {\n-                    let s =\n-                        ~\"constraint args must be slot variables or literals\";\n-                    fcx.ccx.tcx.sess.span_err(e.span, s);\n-                }\n-            }\n-          }\n-          _ {\n-            let s = ~\"in a constraint, expected the \\\n-                     constraint name to be an explicit name\";\n-            fcx.ccx.tcx.sess.span_err(e.span, s);\n-          }\n-        }\n-      }\n-      _ { fcx.ccx.tcx.sess.span_err(e.span, ~\"check on non-predicate\"); }\n-    }\n-    ret bot;\n-}\n-\n-fn check_constraints(fcx: @fn_ctxt, cs: ~[@ast::constr],\n-                     args: ~[ast::arg]) {\n-    let num_args = vec::len(args);\n-    for cs.each |c| {\n-        let mut c_args = ~[];\n-        for c.node.args.each |a| {\n-            vec::push(c_args,\n-                 // \"base\" should not occur in a fn type thing, as of\n-                 // yet, b/c we don't allow constraints on the return type\n-\n-                 // Works b/c no higher-order polymorphism\n-                 /*\n-                 This is kludgy, and we probably shouldn't be assigning\n-                 node IDs here, but we're creating exprs that are\n-                 ephemeral, just for the purposes of typechecking. So\n-                 that's my justification.\n-                 */\n-                 @alt a.node {\n-                    ast::carg_base {\n-                      fcx.ccx.tcx.sess.span_bug(a.span,\n-                                                ~\"check_constraints:\\\n-                    unexpected carg_base\");\n-                    }\n-                    ast::carg_lit(l) {\n-                      let tmp_node_id = fcx.ccx.tcx.sess.next_node_id();\n-                      {id: tmp_node_id,\n-                       callee_id: fcx.ccx.tcx.sess.next_node_id(),\n-                       node: ast::expr_lit(l), span: a.span}\n-                    }\n-                    ast::carg_ident(i) {\n-                      if i < num_args {\n-                          let p = @{span: a.span, global: false,\n-                                    idents: ~[args[i].ident],\n-                                    rp: none, types: ~[]};\n-                          let arg_occ_node_id =\n-                              fcx.ccx.tcx.sess.next_node_id();\n-                          fcx.ccx.tcx.def_map.insert\n-                              (arg_occ_node_id,\n-                               ast::def_arg(args[i].id, args[i].mode));\n-                          {id: arg_occ_node_id,\n-                           callee_id: fcx.ccx.tcx.sess.next_node_id(),\n-                           node: ast::expr_path(p),\n-                           span: a.span}\n-                      } else {\n-                          fcx.ccx.tcx.sess.span_bug(\n-                              a.span, ~\"check_constraints:\\\n-                                       carg_ident index out of bounds\");\n-                      }\n-                    }\n-                  });\n-        }\n-        let p_op: ast::expr_ = ast::expr_path(c.node.path);\n-        let oper: @ast::expr = @{id: c.node.id,\n-             callee_id: fcx.ccx.tcx.sess.next_node_id(),\n-             node: p_op, span: c.span};\n-        // Another ephemeral expr\n-        let call_expr_id = fcx.ccx.tcx.sess.next_node_id();\n-        let call_expr =\n-            @{id: call_expr_id,\n-              callee_id: fcx.ccx.tcx.sess.next_node_id(),\n-              node: ast::expr_call(oper, c_args, false),\n-              span: c.span};\n-        check_pred_expr(fcx, call_expr);\n-    }\n-}\n-\n // Determines whether the given node ID is a use of the def of\n // the self ID for the current method, if there is one\n // self IDs in an outer scope count. so that means that you can\n@@ -2305,8 +2181,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n                     ty::mk_mach_uint(ccx.tcx, ast::ty_u8))\n             }],\n             output: ty::mk_nil(ccx.tcx),\n-            ret_style: ast::return_val,\n-            constraints: ~[]\n+            ret_style: ast::return_val\n         });\n         (0u, ~[arg(ast::by_ref, fty)], ty::mk_nil(tcx))\n       }\n@@ -2319,8 +2194,7 @@ fn check_intrinsic_type(ccx: @crate_ctxt, it: @ast::foreign_item) {\n     let fty = ty::mk_fn(tcx, {purity: ast::impure_fn,\n                               proto: ast::proto_bare,\n                               inputs: inputs, output: output,\n-                              ret_style: ast::return_val,\n-                              constraints: ~[]});\n+                              ret_style: ast::return_val});\n     let i_ty = ty::lookup_item_type(ccx.tcx, local_def(it.id));\n     let i_n_tps = (*i_ty.bounds).len();\n     if i_n_tps != n_tps {"}, {"sha": "2b32c8e356470fe564f71fe20ff2cae35ed2f6a5", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -1,5 +1,6 @@\n import middle::typeck::infer::methods; // next_ty_var,\n                                        // resolve_type_vars_if_possible\n+import syntax::print::pprust;\n \n fn check_alt(fcx: @fn_ctxt,\n              expr: @ast::expr,\n@@ -124,6 +125,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n     let fcx = pcx.fcx;\n     let tcx = pcx.fcx.ccx.tcx;\n+\n     alt pat.node {\n       ast::pat_wild {\n         fcx.write_ty(pat.id, expected);"}, {"sha": "228bf4088367e9db71ff82d861eac8c2e0a6ac99", "filename": "src/rustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -8,7 +8,7 @@ import middle::ty::{get, t, ty_box, ty_uniq, ty_ptr, ty_rptr, ty_enum};\n import middle::ty::{ty_class, ty_nil, ty_bot, ty_bool, ty_int, ty_uint};\n import middle::ty::{ty_float, ty_estr, ty_evec, ty_rec};\n import middle::ty::{ty_fn, ty_trait, ty_tup, ty_var, ty_var_integral};\n-import middle::ty::{ty_param, ty_self, ty_constr, ty_type, ty_opaque_box};\n+import middle::ty::{ty_param, ty_self, ty_type, ty_opaque_box};\n import middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec, new_ty_hash};\n import middle::ty::{subst};\n import middle::typeck::infer::{infer_ctxt, mk_subty, new_infer_ctxt};\n@@ -173,7 +173,7 @@ class CoherenceChecker {\n             ty_nil | ty_bot | ty_bool | ty_int(*) | ty_uint(*) | ty_float(*) |\n             ty_estr(*) | ty_evec(*) | ty_rec(*) |\n             ty_fn(*) | ty_tup(*) | ty_var(*) | ty_var_integral(*) |\n-            ty_param(*) | ty_self | ty_constr(*) | ty_type | ty_opaque_box |\n+            ty_param(*) | ty_self | ty_type | ty_opaque_box |\n             ty_opaque_closure_ptr(*) | ty_unboxed_vec(*) {\n                 none\n             }"}, {"sha": "68253a51ba6f121408cd0e3c4f6755a2bcdf7416", "filename": "src/rustc/middle/typeck/collect.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -126,8 +126,7 @@ fn get_enum_variant_types(ccx: @crate_ctxt,\n                             proto: ast::proto_box,\n                             inputs: args,\n                             output: enum_ty,\n-                            ret_style: ast::return_val,\n-                            constraints: ~[]})\n+                            ret_style: ast::return_val})\n         };\n         let tpt = {bounds: ty_param_bounds(ccx, ty_params),\n                    rp: rp,\n@@ -363,8 +362,7 @@ fn convert(ccx: @crate_ctxt, it: @ast::item) {\n                   proto: ast::proto_any,\n                   inputs: t_args,\n                   output: t_res,\n-                  ret_style: ast::return_val,\n-                  constraints: ~[]}); // FIXME (#2813): allow ctors to have\n+                  ret_style: ast::return_val});\n         // constraints, or remove constraints from the language\n         write_ty_to_tcx(tcx, ctor.node.id, t_ctor);\n         tcx.tcache.insert(local_def(ctor.node.id),\n@@ -618,8 +616,7 @@ fn ty_of_foreign_fn_decl(ccx: @crate_ctxt,\n                                    proto: ast::proto_bare,\n                                    inputs: input_tys,\n                                    output: output_ty,\n-                                   ret_style: ast::return_val,\n-                                   constraints: ~[]});\n+                                   ret_style: ast::return_val});\n     let tpt = {bounds: bounds, rp: false, ty: t_fn};\n     ccx.tcx.tcache.insert(def_id, tpt);\n     ret tpt;"}, {"sha": "9b725072549bd0599f795dff0d40e3b938839f00", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 5, "deletions": 69, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -974,49 +974,6 @@ impl unify_methods for infer_ctxt {\n         uok()\n     }\n \n-    fn constrs(\n-        expected: @ty::type_constr,\n-        actual_constr: @ty::type_constr) -> ures {\n-\n-        let err_res =\n-            err(ty::terr_constr_mismatch(expected, actual_constr));\n-\n-        if expected.node.id != actual_constr.node.id { ret err_res; }\n-        let expected_arg_len = vec::len(expected.node.args);\n-        let actual_arg_len = vec::len(actual_constr.node.args);\n-        if expected_arg_len != actual_arg_len { ret err_res; }\n-        let mut i = 0u;\n-        for expected.node.args.each |a| {\n-            let actual = actual_constr.node.args[i];\n-            alt a.node {\n-              ast::carg_base {\n-                alt actual.node {\n-                  ast::carg_base { }\n-                  _ { ret err_res; }\n-                }\n-              }\n-              ast::carg_lit(l) {\n-                alt actual.node {\n-                  ast::carg_lit(m) {\n-                    if l != m { ret err_res; }\n-                  }\n-                  _ { ret err_res; }\n-                }\n-              }\n-              ast::carg_ident(p) {\n-                alt actual.node {\n-                  ast::carg_ident(q) {\n-                    if p.idents != q.idents { ret err_res; }\n-                  }\n-                  _ { ret err_res; }\n-                }\n-              }\n-            }\n-            i += 1u;\n-        }\n-        ret uok();\n-    }\n-\n     fn bnds<T:copy to_str st>(\n         a: bound<T>, b: bound<T>) -> ures {\n \n@@ -1035,18 +992,6 @@ impl unify_methods for infer_ctxt {\n         }\n     }\n \n-    fn constrvecs(\n-        as: ~[@ty::type_constr], bs: ~[@ty::type_constr]) -> ures {\n-\n-        if check vec::same_length(as, bs) {\n-            do iter_vec2(as, bs) |a,b| {\n-                self.constrs(a, b)\n-            }\n-        } else {\n-            err(ty::terr_constr_len(bs.len(), as.len()))\n-        }\n-    }\n-\n     fn sub_tys(a: ty::t, b: ty::t) -> ures {\n         sub(self).tys(a, b).chain(|_t| ok(()) )\n     }\n@@ -1584,7 +1529,7 @@ fn super_tps<C:combine>(\n     // future we could allow type parameters to declare a\n     // variance.\n \n-    if check vec::same_length(as, bs) {\n+    if vec::same_length(as, bs) {\n         iter_vec2(as, bs, |a, b| {\n             self.infcx().eq_tys(a, b)\n         }).then(|| ok(as) )\n@@ -1674,7 +1619,7 @@ fn super_fns<C:combine>(\n     fn argvecs<C:combine>(self: C, a_args: ~[ty::arg],\n                           b_args: ~[ty::arg]) -> cres<~[ty::arg]> {\n \n-        if check vec::same_length(a_args, b_args) {\n+        if vec::same_length(a_args, b_args) {\n             map_vec2(a_args, b_args, |a, b| self.args(a, b) )\n         } else {\n             err(ty::terr_arg_count)\n@@ -1693,8 +1638,7 @@ fn super_fns<C:combine>(\n                             proto: p,\n                             inputs: inputs,\n                             output: output,\n-                            ret_style: rs,\n-                            constraints: a_f.constraints})\n+                            ret_style: rs})\n                     // }\n                     }\n                 }\n@@ -1824,7 +1768,7 @@ fn super_tys<C:combine>(\n       }\n \n       (ty::ty_rec(as), ty::ty_rec(bs)) {\n-        if check vec::same_length(as, bs) {\n+        if vec::same_length(as, bs) {\n             map_vec2(as, bs, |a,b| {\n                 self.flds(a, b)\n             }).chain(|flds| ok(ty::mk_rec(tcx, flds)) )\n@@ -1834,7 +1778,7 @@ fn super_tys<C:combine>(\n       }\n \n       (ty::ty_tup(as), ty::ty_tup(bs)) {\n-        if check vec::same_length(as, bs) {\n+        if vec::same_length(as, bs) {\n             map_vec2(as, bs, |a, b| self.tys(a, b) )\n                 .chain(|ts| ok(ty::mk_tup(tcx, ts)) )\n         } else {\n@@ -1848,14 +1792,6 @@ fn super_tys<C:combine>(\n         }\n       }\n \n-      (ty::ty_constr(a_t, a_constrs), ty::ty_constr(b_t, b_constrs)) {\n-        do self.tys(a_t, b_t).chain |t| {\n-            do self.infcx().constrvecs(a_constrs, b_constrs).then {\n-                ok(ty::mk_constr(tcx, t, a_constrs))\n-            }\n-        }\n-      }\n-\n       _ { err(ty::terr_sorts(b, a)) }\n     }\n }"}, {"sha": "bf82cf59426ae32393895b3d22679606d3733e4d", "filename": "src/rustc/rustc.rc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Frustc.rc?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -89,19 +89,6 @@ mod middle {\n     mod region;\n     mod const_eval;\n     mod astencode;\n-\n-    mod tstate {\n-        mod ck;\n-        mod annotate;\n-        #[path = \"auxiliary.rs\"]\n-        mod aux;\n-        mod bitvectors;\n-        mod collect_locals;\n-        mod pre_post_conditions;\n-        mod states;\n-        mod ann;\n-        mod tritv;\n-    }\n }\n \n mod front {"}, {"sha": "04152eb69d37ca5de3553fd2fdfc74ede0b08e34", "filename": "src/rustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 30, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Futil%2Fppaux.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -1,9 +1,9 @@\n import std::map::hashmap;\n import middle::ty;\n import middle::ty::{arg, bound_region, br_anon, br_named, canon_mode};\n-import middle::ty::{ck_block, ck_box, ck_uniq, constr, ctxt, field, method};\n+import middle::ty::{ck_block, ck_box, ck_uniq, ctxt, field, method};\n import middle::ty::{mt, re_bound, re_free, re_scope, re_var, region, t};\n-import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_constr, ty_enum};\n+import middle::ty::{ty_bool, ty_bot, ty_box, ty_class, ty_enum};\n import middle::ty::{ty_estr, ty_evec, ty_float, ty_fn, ty_trait, ty_int};\n import middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n import middle::ty::{ty_ptr, ty_rec, ty_rptr, ty_self, ty_tup};\n@@ -12,7 +12,7 @@ import middle::ty::{ty_unboxed_vec, vid};\n import metadata::encoder;\n import syntax::codemap;\n import syntax::print::pprust;\n-import syntax::print::pprust::{path_to_str, constr_args_to_str, proto_to_str,\n+import syntax::print::pprust::{path_to_str, proto_to_str,\n                                mode_to_str, purity_to_str};\n import syntax::{ast, ast_util};\n import syntax::ast_map;\n@@ -134,8 +134,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n     }\n     fn fn_to_str(cx: ctxt, purity: ast::purity, proto: ast::proto,\n                  ident: option<ast::ident>,\n-                 inputs: ~[arg], output: t, cf: ast::ret_style,\n-                 constrs: ~[@constr]) -> ~str {\n+                 inputs: ~[arg], output: t, cf: ast::ret_style) -> ~str {\n         let mut s;\n \n         s = alt purity {\n@@ -156,13 +155,12 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n               ast::return_val { s += ty_to_str(cx, output); }\n             }\n         }\n-        s += constrs_str(constrs);\n         ret s;\n     }\n     fn method_to_str(cx: ctxt, m: method) -> ~str {\n         ret fn_to_str(\n             cx, m.fty.purity, m.fty.proto, some(m.ident), m.fty.inputs,\n-            m.fty.output, m.fty.ret_style, m.fty.constraints) + ~\";\";\n+            m.fty.output, m.fty.ret_style) + ~\";\";\n     }\n     fn field_to_str(cx: ctxt, f: field) -> ~str {\n         ret *f.ident + ~\": \" + mt_to_str(cx, f.mt);\n@@ -211,7 +209,7 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_fn(f) {\n         fn_to_str(cx, f.purity, f.proto, none, f.inputs,\n-                  f.output, f.ret_style, f.constraints)\n+                  f.output, f.ret_style)\n       }\n       ty_var(v) { v.to_str() }\n       ty_var_integral(v) { v.to_str() }\n@@ -234,7 +232,6 @@ fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n       }\n       ty_estr(vs) { vstore_ty_to_str(cx, ~\"str\", vs) }\n       ty_opaque_box { ~\"@?\" }\n-      ty_constr(t, _) { ~\"@?\" }\n       ty_opaque_closure_ptr(ck_block) { ~\"closure&\" }\n       ty_opaque_closure_ptr(ck_box) { ~\"closure@\" }\n       ty_opaque_closure_ptr(ck_uniq) { ~\"closure~\" }\n@@ -267,27 +264,6 @@ fn ty_to_short_str(cx: ctxt, typ: t) -> ~str {\n     ret s;\n }\n \n-fn constr_to_str(c: @constr) -> ~str {\n-    ret path_to_str(c.node.path) +\n-            pprust::constr_args_to_str(pprust::uint_to_str, c.node.args);\n-}\n-\n-fn constrs_str(constrs: ~[@constr]) -> ~str {\n-    let mut s = ~\"\";\n-    let mut colon = true;\n-    for constrs.each |c| {\n-        if colon { s += ~\" : \"; colon = false; } else { s += ~\", \"; }\n-        s += constr_to_str(c);\n-    }\n-    ret s;\n-}\n-\n-fn ty_constr_to_str<Q>(c: @ast::spanned<ast::constr_general_<@ast::path, Q>>)\n-   -> ~str {\n-    ret path_to_str(c.node.path) +\n-            constr_args_to_str::<@ast::path>(path_to_str, c.node.args);\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "26b785b6614f825f7441cc47d91f412c540d67cf", "filename": "src/rustdoc/unindent_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustdoc%2Funindent_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Frustdoc%2Funindent_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustdoc%2Funindent_pass.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -60,7 +60,7 @@ fn unindent(s: ~str) -> ~str {\n         }\n     };\n \n-    if check vec::is_not_empty(lines) {\n+    if vec::is_not_empty(lines) {\n         let unindented = ~[str::trim(vec::head(lines))]\n             + do par::anymap(vec::tail(lines)) |line| {\n             if str::is_whitespace(line) {"}, {"sha": "2843ef93ea6c0121cdd9fc5c6aa76108e1270466", "filename": "src/test/compile-fail/fn-constraint.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffn-constraint.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,10 +0,0 @@\n-// error-pattern:precondition constraint (for example, uint::le(a, b)\n-use std;\n-import str::*;\n-\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 4u;\n-    let b: uint = 1u;\n-    log(error, foo(a, b));\n-}"}, {"sha": "4545277e18d6921309bc02d15a9a644644354518", "filename": "src/test/compile-fail/if-check-precond-fail.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fif-check-precond-fail.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,12 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint\n-pure fn even(x: uint) -> bool {\n-    if x < 2u {\n-        ret false;\n-    } else if x == 2u { ret true; } else { ret even(x - 2u); }\n-}\n-\n-fn print_even(x: uint) : even(x) { log(debug, x); }\n-\n-fn foo(x: uint) { if check even(x) { fail; } else { print_even(x); } }\n-\n-fn main() { foo(3u); }"}, {"sha": "aef5080e3ae196cc20ea0e8195118402969b1c3f", "filename": "src/test/compile-fail/impure-pred.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpure-pred.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,14 +0,0 @@\n-// -*- rust -*-\n-\n-fn g() { }\n-\n-pure fn f(_q: int) -> bool {\n-    g(); //~ ERROR access to impure function prohibited in pure context\n-    ret true;\n-}\n-\n-fn main() {\n-    let x = 0;\n-\n-    check (f(x));\n-}"}, {"sha": "28c531b3b81b764c0b22298e6371ed564ff572b5", "filename": "src/test/compile-fail/liveness-unused.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fliveness-unused.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -35,10 +35,12 @@ fn f4() {\n }\n \n // leave this in here just to trigger compile-fail:\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n+class r {\n+    let x: ();\n+    new() { self.x = (); }\n+    drop {}\n+}\n fn main() {\n-    let i: int = 4;\n-    log(debug, false && { check is_even(i); true });\n-    even(i); //~ ERROR unsatisfied precondition\n+    let x = r();\n+    fn@() { copy x; }; //~ ERROR copying a noncopyable value\n }"}, {"sha": "a55fe477ba796c4efbb588f968de27f84da57583", "filename": "src/test/compile-fail/loop-pred-constraints.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Floop-pred-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Floop-pred-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Floop-pred-constraints.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-// https://github.com/mozilla/rust/issues/2374\n-// error-pattern:unsatisfied precondition constraint (for example, even(y\n-\n-\n-fn print_even(y: int) : even(y) { log(debug, y); }\n-\n-pure fn even(y: int) -> bool { true }\n-\n-fn main() {\n-    let mut y = 42;\n-    check (even(y));\n-    loop {\n-        print_even(y);\n-        loop { y += 1; break; }\n-    }\n-}"}, {"sha": "f1c02bd406f7fda6ea4649c8afefaabd8648f94d", "filename": "src/test/compile-fail/no-constraint-prop.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fno-constraint-prop.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,18 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, uint::le\n-\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let mut a: uint = 1u;\n-    let mut b: uint = 4u;\n-    let mut c: uint = 5u;\n-    // make sure that the constraint le(b, a) exists...\n-    check (uint::le(b, a));\n-    // ...invalidate it...\n-    b += 1u;\n-    check (uint::le(c, a));\n-    // ...and check that it doesn't get set in the poststate of\n-    // the next statement, since it's not true in the\n-    // prestate.\n-    let d <- a;\n-    log(debug, foo(b, d));\n-}"}, {"sha": "2ac5ac128fcb736957ef2918d68ea920b0a41759", "filename": "src/test/compile-fail/nonsense-constraints.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnonsense-constraints.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,13 +0,0 @@\n-// Tests that the typechecker checks constraints\n-// error-pattern:mismatched types: expected `uint` but found `u8`\n-use std;\n-import uint;\n-\n-fn enum_chars(start: u8, end: u8) : uint::le(start, end) -> ~[char] {\n-    let i = start;\n-    let r = ~[];\n-    while i <= end { r += ~[i as char]; i += 1u as u8; }\n-    ret r;\n-}\n-\n-fn main() { log(debug, enum_chars('a' as u8, 'z' as u8)); }"}, {"sha": "3bac354fb246a8b174553038a1db0e5f26a26205", "filename": "src/test/compile-fail/not-a-pred-2.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-2.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,14 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern: non-predicate\n-\n-fn main() {\n-    check (1 ==\n-               2); // should fail to typecheck, as (a == b)\n-                   // is not a manifest call\n-\n-\n-\n-\n-\n-}"}, {"sha": "24016a70b2d5dd2ee3ca48283b770205347bd23d", "filename": "src/test/compile-fail/not-a-pred-check.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-a-pred-check.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,10 +0,0 @@\n-// -*- rust -*-\n-// error-pattern:impure function as operator\n-\n-fn f(q: int) -> bool { ret true; }\n-\n-fn main() {\n-    let x = 0;\n-\n-    check (f(x));\n-}"}, {"sha": "6fb5273e1e76d330cf39b2f551682ac2ae1697e8", "filename": "src/test/compile-fail/not-pred-args.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fnot-pred-args.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,11 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern:constraint args must be\n-\n-pure fn f(q: int) -> bool { ret true; }\n-\n-fn main() {\n-    // should fail to typecheck, as pred args must be slot variables\n-    // or literals\n-    check (f(42 * 17));\n-}"}, {"sha": "19a7105098636e2cb6fcc310c0c8b436b40253d3", "filename": "src/test/compile-fail/pred-assign.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-assign.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern:unsatisfied precondition constraint (for example, lt(a, b)\n-\n-fn f(a: int, b: int) : lt(a, b) { }\n-\n-pure fn lt(a: int, b: int) -> bool { ret a < b; }\n-\n-fn main() {\n-    let mut a: int = 10;\n-    let mut b: int = 23;\n-    let mut c: int = 77;\n-    check (lt(a, b));\n-    a = 24;\n-    f(a, b);\n-}"}, {"sha": "3d887e8d6ef669d8f1db5492a20971708d28ee79", "filename": "src/test/compile-fail/pred-on-wrong-slots.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-on-wrong-slots.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,17 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern: lt(a, c)\n-\n-fn f(a: int, b: int) : lt(a, b) { }\n-\n-pure fn lt(a: int, b: int) -> bool { ret a < b; }\n-\n-fn main() {\n-    let a: int = 10;\n-    let b: int = 23;\n-    let c: int = 77;\n-    check (lt(a, b));\n-    check (lt(b, c));\n-    f(a, b);\n-    f(a, c);\n-}"}, {"sha": "b62f5a942f7ca367dd73f6ecb39f6b6535198253", "filename": "src/test/compile-fail/pred-swap.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fpred-swap.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-// -*- rust -*-\n-\n-// error-pattern:unsatisfied precondition constraint (for example, lt(a, b)\n-\n-fn f(a: int, b: int) : lt(a, b) { }\n-\n-pure fn lt(a: int, b: int) -> bool { ret a < b; }\n-\n-fn main() {\n-    let mut a: int = 10;\n-    let mut b: int = 23;\n-    let mut c: int = 77;\n-    check (lt(a, b));\n-    b <-> a;\n-    f(a, b);\n-}"}, {"sha": "820ebd655f51db3eb01a242524bd9c5b7d13237d", "filename": "src/test/compile-fail/slot-as-pred.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslot-as-pred.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,12 +0,0 @@\n-// -*- rust -*-\n-// error-pattern: unresolved name: lt\n-\n-fn f(a: int, b: int) : lt(a, b) { }\n-\n-fn main() {\n-    let lt: int;\n-    let a: int = 10;\n-    let b: int = 23;\n-    check (lt(a, b));\n-    f(a, b);\n-}"}, {"sha": "d6e01f20ff472e46f169379763ba9ed9ce9f963a", "filename": "src/test/compile-fail/tstate-and-init.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-and-init.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-fn main() {\n-    let i: int = 4;\n-    log(debug, false && { check is_even(i); true });\n-    even(i); //~ ERROR unsatisfied precondition\n-}"}, {"sha": "91a31fed6cf46f05ef6c6448ad1fbb586091014c", "filename": "src/test/compile-fail/tstate-block-uninit.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-block-uninit.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,11 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn force(f: fn()) { f(); }\n-\n-fn main() {\n-    let x: int = 4;\n-    force(fn&() {\n-        even(x); //~ ERROR unsatisfied precondition\n-    });\n-}"}, {"sha": "7d75009098fccc8d3e1f68d2169993455de0f1fd", "filename": "src/test/compile-fail/tstate-break-uninit-2.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit-2.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn foo() -> int {\n-    let x: int = 4;\n-\n-    while 1 != 2 {\n-        break;\n-        check is_even(x); //~ WARNING unreachable statement\n-    }\n-\n-    even(x); //~ ERROR unsatisfied precondition\n-    ret 17;\n-}\n-\n-fn main() { log(debug, foo()); }"}, {"sha": "b0d51deb5df0770a9145505f7323f420a41afc97", "filename": "src/test/compile-fail/tstate-break-uninit.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-break-uninit.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn foo() -> int {\n-    let x: int = 4;\n-\n-    loop {\n-        break;\n-        check is_even(x); //~ WARNING unreachable statement\n-    }\n-\n-    even(x); //~ ERROR unsatisfied precondition\n-    ret 17;\n-}\n-\n-fn main() { log(debug, foo()); }"}, {"sha": "e72e57f901b523e9b9b80d65e98a2049650549af", "filename": "src/test/compile-fail/tstate-ctor-unsat.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-ctor-unsat.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,25 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-class cat {\n-  priv {\n-    let mut meows : uint;\n-  }\n-\n-  let how_hungry : int;\n-\n-  fn eat() {\n-    self.how_hungry -= 5;\n-  }\n-\n-  new(in_x : uint, in_y : int) {\n-    let foo = 3;\n-    self.meows = in_x + (in_y as uint);\n-    self.how_hungry = even(foo); //~ ERROR unsatisfied precondition\n-  }\n-}\n-\n-fn main() {\n-  let nyan : cat = cat(52u, 99);\n-  nyan.eat();\n-}"}, {"sha": "c5335ce1f8567e317a61e09197fe52a0694d6505", "filename": "src/test/compile-fail/tstate-fru.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-fru.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,14 +0,0 @@\n-// -*- rust -*-\n-\n-type point = {x: int, y: int};\n-\n-pure fn test(_p: point) -> bool { true }\n-fn tested(p: point) : test(p) -> point { p }\n-\n-fn main() {\n-    let origin: point;\n-    origin = {x: 0, y: 0};\n-    let right: point = {x: 10 with tested(origin)};\n-        //~^ ERROR precondition\n-    copy right;\n-}"}, {"sha": "e9873110a44c610e3a9fea7bf7466a8002ac9157", "filename": "src/test/compile-fail/tstate-if-no-else.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-if-no-else.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,10 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn foo(x: int) { log(debug, x); }\n-\n-fn main() {\n-\tlet x: int = 10;\n-        if 1 > 2 { check is_even(x); }\n-        even(x); //~ ERROR unsatisfied precondition\n-}"}, {"sha": "c813d84d4657a7160bb59117bef1f0e0335fc19b", "filename": "src/test/compile-fail/tstate-if-with-else.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-if-with-else.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,14 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn foo(x: int) { log(debug, x); }\n-\n-fn main() {\n-    let x: int = 10;\n-    if 1 > 2 {\n-        #debug(\"whoops\");\n-    } else {\n-        check is_even(x);\n-    }\n-    even(x); //~ ERROR unsatisfied precondition\n-}"}, {"sha": "731a7d0b6d8857f4a35fe8c42543da45c434fa77", "filename": "src/test/compile-fail/tstate-loop-constraints.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-loop-constraints.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,19 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn main() {\n-\n-    let mut x: int = 42;\n-    loop {\n-        loop {\n-            loop {\n-                check is_even(x);\n-                even(x); // OK\n-                loop {\n-                    even(x); //~ ERROR unsatisfied precondition\n-                    x = 11; \n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "f24dd9d888e73bb21f07587777459bd96b4b5a29", "filename": "src/test/compile-fail/tstate-or-init.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-or-init.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-fn main() {\n-    let i: int = 4;\n-    log(debug, false || { check is_even(i); true });\n-    even(i); //~ ERROR unsatisfied precondition\n-}"}, {"sha": "0ac68559f8b867031c6fa5ab297cffbba9b15f2f", "filename": "src/test/compile-fail/tstate-return.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-return.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn f() -> int {\n-\tlet x: int = 4;\n-\tret even(x); //~ ERROR unsatisfied precondition\n-}\n-\n-fn main() { f(); }"}, {"sha": "6722736dea0f06e512dd7cd5f4eeef227dbd5ffc", "filename": "src/test/compile-fail/tstate-unsat-after-item.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-after-item.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn main() {\n-    let x = 4;\n-    fn baz(_x: int) { }\n-    baz(even(x)); //~ ERROR unsatisfied precondition\n-}\n-"}, {"sha": "3caee2475a86af9c5f2d60650f066112cd133eee", "filename": "src/test/compile-fail/tstate-unsat-in-called-fn-expr.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-called-fn-expr.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-fn foo(v: ~[int]) : vec::is_empty(v) { #debug(\"%d\", v[0]); }\n-\n-fn main() {\n-    let f = fn@() {\n-        let v = ~[1];\n-        foo(v); //~ ERROR unsatisfied precondition constraint\n-    }();\n-    log(error, f);\n-}"}, {"sha": "ffc1e87bcc5cc0504aac6bea17447bd47e759cbd", "filename": "src/test/compile-fail/tstate-unsat-in-fn-expr.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat-in-fn-expr.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-fn foo(v: ~[int]) : vec::is_empty(v) { #debug(\"%d\", v[0]); }\n-\n-fn main() {\n-    let f = fn@() {\n-        let v = ~[1];\n-        foo(v); //~ ERROR unsatisfied precondition constraint\n-    };\n-    log(error, f());\n-}"}, {"sha": "210feb28b920f077d507c0855e90fc3c38faa01a", "filename": "src/test/compile-fail/tstate-unsat.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-unsat.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn main() {\n-    let x: int = 4;\n-    even(x); //~ ERROR unsatisfied precondition\n-}"}, {"sha": "49905d503485456ef435fa4c6137f654194dbbc5", "filename": "src/test/compile-fail/tstate-while-break.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-break.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,15 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn test(cond: bool) {\n-    let v = 4;\n-    while cond {\n-        check is_even(v);\n-        break;\n-    }\n-    even(v); //~ ERROR unsatisfied precondition\n-}\n-\n-fn main() {\n-    test(true);\n-}"}, {"sha": "afc77fa42c63d141ea9746c6c01a15ac264c7cbb", "filename": "src/test/compile-fail/tstate-while-cond.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-cond.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn main() {\n-    let x: int = 4;\n-    while even(x) != 0 { } //~ ERROR unsatisfied precondition\n-}"}, {"sha": "5fff9aa9cb50c6d7fb36c62c7ef319c1a36aa82c", "filename": "src/test/compile-fail/tstate-while-loop-unsat-constriants.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while-loop-unsat-constriants.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,16 +0,0 @@\n-// error-pattern:unsatisfied precondition constraint (for example, even(y\n-\n-fn print_even(y: int) : even(y) { log(debug, y); }\n-\n-pure fn even(y: int) -> bool { true }\n-\n-fn main() {\n-\n-    let mut y: int = 42;\n-    let mut x: int = 1;\n-    check (even(y));\n-    loop {\n-        print_even(y);\n-        while true { while true { while true { y += x; } } }\n-    }\n-}"}, {"sha": "f99c966aaf46f9ffb16b534b0cf550d451e671b3", "filename": "src/test/compile-fail/tstate-while.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftstate-while.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,10 +0,0 @@\n-pure fn is_even(i: int) -> bool { (i%2) == 0 }\n-fn even(i: int) : is_even(i) -> int { i }\n-\n-fn f() {\n-    let mut x: int = 10;\n-    while 1 == 1 { x = 10; }\n-    even(x); //~ ERROR unsatisfied precondition\n-}\n-\n-fn main() { f(); }"}, {"sha": "e209a3de489859ca5cf5b1cbd87b4df52fe5af43", "filename": "src/test/run-fail/fn-constraint-claim.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint-claim.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-// error-pattern:quux\n-use std;\n-import uint::*;\n-\n-fn nop(a: uint, b: uint) : le(a, b) { fail ~\"quux\"; }\n-\n-fn main() { let a: uint = 5u; let b: uint = 4u; claim (le(a, b)); nop(a, b); }"}, {"sha": "f24d96e13cc96c696fa405d16e0130bc928ae418", "filename": "src/test/run-fail/fn-constraint.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Ffn-constraint.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-// error-pattern:Predicate uint::le(a, b) failed\n-\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 4u;\n-    let b: uint = 1u;\n-    check (uint::le(a, b));\n-    log(error, foo(a, b));\n-}"}, {"sha": "0ca92ab18c4abdbba0dc05a98a6c0d7e3c23d0e4", "filename": "src/test/run-fail/if-check-fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-fail%2Fif-check-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fif-check-fail.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -6,7 +6,7 @@ pure fn even(x: uint) -> bool {\n }\n \n fn foo(x: uint) {\n-    if check even(x) {\n+    if even(x) {\n         log(debug, x);\n     } else {\n         fail ~\"Number is odd\";"}, {"sha": "494bee968f1a4c87a6c5110d733eb36d63da8e35", "filename": "src/test/run-fail/pred.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fpred.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-// -*- rust -*-\n-// error-pattern:Predicate lt(b, a) failed\n-fn f(a: int, b: int) { }\n-\n-pure fn lt(a: int, b: int) -> bool { ret a < b; }\n-\n-fn main() { let a: int = 10; let b: int = 23; check (lt(b, a)); f(b, a); }"}, {"sha": "e01cc969cea61764e512790b6228153def93abb1", "filename": "src/test/run-fail/unwind-check.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Funwind-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-fail%2Funwind-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Funwind-check.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,8 +0,0 @@\n-// error-pattern:fail\n-\n-pure fn p(a: @int) -> bool { false }\n-\n-fn main() {\n-    let a = @0;\n-    check p(a);\n-}\n\\ No newline at end of file"}, {"sha": "5f29e83f8f824125c8ad59c2cedfd76609b76603", "filename": "src/test/run-fail/zip-different-lengths.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fzip-different-lengths.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -1,6 +1,6 @@\n // In this case, the code should compile but\n-// the check should fail at runtime\n-// error-pattern:Predicate same_length\n+// the assert should fail at runtime\n+// error-pattern:Assertion same_length(chars, ints) failed\n use std;\n import uint;\n import u8;\n@@ -25,12 +25,12 @@ fn enum_uints(start: uint, end: uint) -> ~[uint] {\n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 9u;\n     // Silly, but necessary\n-    check (u8::le(a, j));\n-    check (uint::le(k, l));\n+    assert (u8::le(a, j));\n+    assert (uint::le(k, l));\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    check (same_length(chars, ints));\n+    assert (same_length(chars, ints));\n     let ps = zip(chars, ints);\n     fail ~\"the impossible happened\";\n }"}, {"sha": "8172cae6b47e070db09a3b0092b4df396b1294b2", "filename": "src/test/run-pass/bug-862.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fbug-862.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fbug-862.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fbug-862.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn p(j: int) -> bool { true }\n-\n-fn f(i: int, j: int) : p(j) -> int { j }\n-\n-fn g(i: int, j: int) : p(j) -> int { f(i, j) }\n-\n-fn main() { let x = 1; check (p(x)); log(debug, g(x, x)); }"}, {"sha": "936947701adcaa5996b85a8bdf938d5ecad2c077", "filename": "src/test/run-pass/check-pattern-bound.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcheck-pattern-bound.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,9 +0,0 @@\n-use std;\n-\n-pure fn p(x: int) -> bool { true }\n-\n-fn f(x: int) : p(x) { }\n-\n-fn main() {\n-    alt some(5) { some(y) { check (p(y)); f(y); } _ { fail ~\"yuck\"; } }\n-}"}, {"sha": "5f427d185ebf3dfd396e63ff946cbdc44440a2b9", "filename": "src/test/run-pass/claim-nonterm.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclaim-nonterm.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-// tests that the pred in a claim isn't actually eval'd\n-use std;\n-import uint::*;\n-\n-pure fn fails(a: uint) -> bool { fail; }\n-\n-fn main() { let b: uint = 4u; claim (fails(b)); }"}, {"sha": "c29bcbdfee28ede719db07fe7ba432df2f24080a", "filename": "src/test/run-pass/constrained-type.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstrained-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstrained-type.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,11 +0,0 @@\n-// -*- rust -*-\n-\n-enum list { cons(int, @list), nil, }\n-\n-type bubu = {x: int, y: int};\n-\n-pure fn less_than(x: int, y: int) -> bool { ret x < y; }\n-\n-type ordered_range = {low: int, high: int}  : less_than(*.low, *.high);\n-\n-fn main() { }"}, {"sha": "a2550197d0eb30da2b22457615ceb7644c95f2f1", "filename": "src/test/run-pass/constraint-prop-expr-move.rs", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-expr-move.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,10 +0,0 @@\n-\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 1u;\n-    let b: uint = 4u;\n-    let mut c: uint = 17u;\n-    check (uint::le(a, b));\n-    c <- a;\n-    log(debug, foo(c, b));\n-}"}, {"sha": "a07b60799e887250af896beb8d4a824c70860b89", "filename": "src/test/run-pass/constraint-prop-move.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-move.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,8 +0,0 @@\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 1u;\n-    let b: uint = 4u;\n-    check (uint::le(a, b));\n-    let c <- a;\n-    log(debug, foo(c, b));\n-}"}, {"sha": "76d6a733e98c026546301a60919bf18215554fd3", "filename": "src/test/run-pass/constraint-prop-swap.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop-swap.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,8 +0,0 @@\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let mut a: uint = 4u;\n-    let mut b: uint = 1u;\n-    check (uint::le(b, a));\n-    b <-> a;\n-    log(debug, foo(a, b));\n-}"}, {"sha": "6d5808be3d1750c2fd89812f31e50d86c83bc995", "filename": "src/test/run-pass/constraint-prop.rs", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconstraint-prop.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,8 +0,0 @@\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 1u;\n-    let b: uint = 4u;\n-    check uint::le(a, b);\n-    let c = b;\n-    log(debug, foo(a, c));\n-}"}, {"sha": "476a6b74a3d83853ccc362912c2d5bad13108eb4", "filename": "src/test/run-pass/fn-constraint.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Ffn-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffn-constraint.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-fn main() unsafe {\n-    fn foo(_a: uint, _b: uint) : uint::le(_a, _b) {}\n-    let a: uint = 1u;\n-    let b: uint = 4u;\n-    check (uint::le(a, b));\n-    log(debug, foo(a, b));\n-}"}, {"sha": "f3d35f52a3aa450dc9963aa6eed041e86cceece9", "filename": "src/test/run-pass/if-check-precond.rs", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fif-check-precond.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check-precond.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,11 +0,0 @@\n-pure fn even(x: uint) -> bool {\n-    if x < 2u {\n-        ret false;\n-    } else if x == 2u { ret true; } else { ret even(x - 2u); }\n-}\n-\n-fn print_even(x: uint) : even(x) { log(debug, x); }\n-\n-fn foo(x: uint) { if check even(x) { print_even(x); } else { fail; } }\n-\n-fn main() { foo(2u); }"}, {"sha": "78208ec61499f4b70b927e6b4dba5ff1d0f60d1e", "filename": "src/test/run-pass/if-check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fif-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fif-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fif-check.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -5,7 +5,7 @@ pure fn even(x: uint) -> bool {\n }\n \n fn foo(x: uint) {\n-    if check even(x) {\n+    if even(x) {\n         log(debug, x);\n     } else {\n         fail;"}, {"sha": "53d94d3150654e6c157af52874c82331267a970f", "filename": "src/test/run-pass/issue-933.rs", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fissue-933.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fissue-933.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-933.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,2 +0,0 @@\n-pure fn c() -> bool { check c(); true }\n-fn main() {}"}, {"sha": "17fa82980a99f6e3cee8f403a779c4c962d116ac", "filename": "src/test/run-pass/issue-970.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fissue-970.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fissue-970.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-970.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,6 +0,0 @@\n-enum maybe_ordered_pair {\n-    yes({low: int, high: int} : less_than(*.low, *.high)),\n-    no\n-}\n-pure fn less_than(x: int, y: int) -> bool { ret x < y; }\n-fn main() { }"}, {"sha": "da3f19062dd69da708b74e6d23d4a6cfa518d858", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -10,19 +10,13 @@ pure fn pure_length<T: copy>(ls: @list<T>) -> uint { pure_length_go(ls, 0u) }\n \n pure fn nonempty_list<T: copy>(ls: @list<T>) -> bool { pure_length(ls) > 0u }\n \n-// Of course, the compiler can't take advantage of the\n-// knowledge that ls is a cons node. Future work.\n-// Also, this is pretty contrived since nonempty_list\n-// could be a \"enum refinement\", if we implement those.\n-fn safe_head<T: copy>(ls: @list<T>) : nonempty_list(ls) -> T {\n-    check is_not_empty(ls);\n+fn safe_head<T: copy>(ls: @list<T>) -> T {\n+    assert is_not_empty(ls);\n     ret head(ls);\n }\n \n fn main() {\n     let mylist = @cons(@1u, @nil);\n-    // Again, a way to eliminate such \"obvious\" checks seems\n-    // desirable. (Tags could have postconditions.)\n-    check (nonempty_list(mylist));\n+    assert (nonempty_list(mylist));\n     assert (*safe_head(mylist) == 1u);\n }"}, {"sha": "588288cea2f4f44dea8a68bc9e0714ed33038b96", "filename": "src/test/run-pass/pred-check.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fpred-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fpred-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpred-check.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,4 +0,0 @@\n-// -*- rust -*-\n-pure fn f(q: int) -> bool { ret true; }\n-\n-fn main() { let x = 0; check (f(x)); }"}, {"sha": "212e77cbdc1c3708aa8b7daccb96cbd2dfe73800", "filename": "src/test/run-pass/pred.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fpred.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Fpred.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpred.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,14 +0,0 @@\n-// -*- rust -*-\n-fn f(a: int, b: int) { }\n-\n-pure fn lt(a: int, b: int) -> bool { ret a < b; }\n-\n-fn main() {\n-    let a: int = 10;\n-    let b: int = 23;\n-    let c: int = 77;\n-    check (lt(a, b));\n-    check (lt(a, c));\n-    f(a, b);\n-    f(a, c);\n-}"}, {"sha": "632aec5c4d14e0d942ca08c71b8cd55d91753e64", "filename": "src/test/run-pass/typestate-transitive.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftypestate-transitive.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,7 +0,0 @@\n-pure fn p(i: int) -> bool { true }\n-\n-fn f(i: int) : p(i) -> int { i }\n-\n-fn g(i: int) : p(i) -> int { f(i) }\n-\n-fn main() { }"}, {"sha": "c897c676329f2f46d4bcfd58b39d75a0716859a2", "filename": "src/test/run-pass/unchecked-predicates.rs", "status": "removed", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1fbb9d035ddd0c9ae56a91167fda2f100c3987ad/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funchecked-predicates.rs?ref=1fbb9d035ddd0c9ae56a91167fda2f100c3987ad", "patch": "@@ -1,39 +0,0 @@\n-// Uses foldl to exhibit the unchecked block syntax.\n-use std;\n-\n-import std::list::*;\n-\n-// Can't easily be written as a \"pure fn\" because there's\n-// no syntax for specifying that f is pure.\n-fn pure_foldl<T: copy, U: copy>(ls: @list<T>, u: U, f: fn(T, U) -> U) -> U {\n-    alt *ls {\n-        nil { u }\n-        cons(hd, tl) { f(hd, pure_foldl(tl, f(hd, u), f)) }\n-    }\n-}\n-\n-// Shows how to use an \"unchecked\" block to call a general\n-// fn from a pure fn\n-pure fn pure_length<T: copy>(ls: @list<T>) -> uint {\n-    fn count<T>(_t: T, &&u: uint) -> uint { u + 1u }\n-    unchecked{ pure_foldl(ls, 0u, count) }\n-}\n-\n-pure fn nonempty_list<T: copy>(ls: @list<T>) -> bool { pure_length(ls) > 0u }\n-\n-// Of course, the compiler can't take advantage of the\n-// knowledge that ls is a cons node. Future work.\n-// Also, this is pretty contrived since nonempty_list\n-// could be a \"enum refinement\", if we implement those.\n-fn safe_head<T: copy>(ls: @list<T>) : nonempty_list(ls) -> T {\n-    check is_not_empty(ls);\n-    ret head(ls)\n-}\n-\n-fn main() {\n-    let mylist = @cons(@1u, @nil);\n-    // Again, a way to eliminate such \"obvious\" checks seems\n-    // desirable. (Tags could have postconditions.)\n-    check (nonempty_list(mylist));\n-    assert (*safe_head(mylist) == 1u);\n-}"}, {"sha": "104bea41e5665802d69689ffb9600549611b4bb8", "filename": "src/test/run-pass/weird-exprs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fweird-exprs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fweird-exprs.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -51,8 +51,8 @@ fn hammertime() -> int {\n \n fn canttouchthis() -> uint {\n     pure fn p() -> bool { true }\n-    let _a = (assert (true)) == (check (p()));\n-    let _c = (check (p())) == ();\n+    let _a = (assert (true)) == (assert (p()));\n+    let _c = (assert (p())) == ();\n     let _b: bool = (log(debug, 0) == (ret 0u));\n }\n "}, {"sha": "3ae9f1c1eba19a76b235da304b68b89e6047762a", "filename": "src/test/run-pass/zip-same-length.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41a21f053ced3df8fe9acc66cb30fb6005339b3e/src%2Ftest%2Frun-pass%2Fzip-same-length.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fzip-same-length.rs?ref=41a21f053ced3df8fe9acc66cb30fb6005339b3e", "patch": "@@ -23,16 +23,11 @@ fn enum_uints(start: uint, end: uint) -> ~[uint] {\n \n fn main() {\n     let a = 'a' as u8, j = 'j' as u8, k = 1u, l = 10u;\n-    // Silly, but necessary\n-    check (u8::le(a, j));\n-    check (uint::le(k, l));\n     let chars = enum_chars(a, j);\n     let ints = enum_uints(k, l);\n \n-    check (same_length(chars, ints));\n     let ps = zip(chars, ints);\n \n-    check (is_not_empty(ps));\n     assert (head(ps) == ('a', 1u));\n     assert (last(ps) == (j as char, 10u));\n }"}]}