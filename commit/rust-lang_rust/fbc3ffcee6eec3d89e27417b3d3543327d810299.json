{"sha": "fbc3ffcee6eec3d89e27417b3d3543327d810299", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYzNmZmNlZTZlZWMzZDg5ZTI3NDE3YjNkMzU0MzMyN2Q4MTAyOTk=", "commit": {"author": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-01-18T12:17:34Z"}, "committer": {"name": "Mikhail Modin", "email": "mikhailm1@gmail.com", "date": "2020-01-27T21:34:19Z"}, "message": "Improves reference search by StructLiteral", "tree": {"sha": "87cc91dda122f4417ff08e893931c8eb4234da1e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87cc91dda122f4417ff08e893931c8eb4234da1e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fbc3ffcee6eec3d89e27417b3d3543327d810299", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fbc3ffcee6eec3d89e27417b3d3543327d810299", "html_url": "https://github.com/rust-lang/rust/commit/fbc3ffcee6eec3d89e27417b3d3543327d810299", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fbc3ffcee6eec3d89e27417b3d3543327d810299/comments", "author": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mikhail-m1", "id": 5663581, "node_id": "MDQ6VXNlcjU2NjM1ODE=", "avatar_url": "https://avatars.githubusercontent.com/u/5663581?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mikhail-m1", "html_url": "https://github.com/mikhail-m1", "followers_url": "https://api.github.com/users/mikhail-m1/followers", "following_url": "https://api.github.com/users/mikhail-m1/following{/other_user}", "gists_url": "https://api.github.com/users/mikhail-m1/gists{/gist_id}", "starred_url": "https://api.github.com/users/mikhail-m1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mikhail-m1/subscriptions", "organizations_url": "https://api.github.com/users/mikhail-m1/orgs", "repos_url": "https://api.github.com/users/mikhail-m1/repos", "events_url": "https://api.github.com/users/mikhail-m1/events{/privacy}", "received_events_url": "https://api.github.com/users/mikhail-m1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1916a78c6a31219a8aaa73f2b443282441671539", "url": "https://api.github.com/repos/rust-lang/rust/commits/1916a78c6a31219a8aaa73f2b443282441671539", "html_url": "https://github.com/rust-lang/rust/commit/1916a78c6a31219a8aaa73f2b443282441671539"}], "stats": {"total": 138, "additions": 111, "deletions": 27}, "files": [{"sha": "ebded715d616c69f4d639c0ab15d0edadd7e1f7e", "filename": "crates/ra_ide/src/references.rs", "status": "modified", "additions": 111, "deletions": 27, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/fbc3ffcee6eec3d89e27417b3d3543327d810299/crates%2Fra_ide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fbc3ffcee6eec3d89e27417b3d3543327d810299/crates%2Fra_ide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Freferences.rs?ref=fbc3ffcee6eec3d89e27417b3d3543327d810299", "patch": "@@ -112,25 +112,20 @@ impl IntoIterator for ReferenceSearchResult {\n \n pub(crate) fn find_all_refs(\n     db: &RootDatabase,\n-    mut position: FilePosition,\n+    position: FilePosition,\n     search_scope: Option<SearchScope>,\n ) -> Option<RangeInfo<ReferenceSearchResult>> {\n     let parse = db.parse(position.file_id);\n     let syntax = parse.tree().syntax().clone();\n \n-    let token = syntax.token_at_offset(position.offset);\n-    let mut search_kind = ReferenceKind::Other;\n+    let (opt_name, search_kind) =\n+        if let Some(name) = get_struct_def_name_for_struc_litetal_search(&syntax, position) {\n+            (Some(name), ReferenceKind::StructLiteral)\n+        } else {\n+            (find_node_at_offset::<ast::Name>(&syntax, position.offset), ReferenceKind::Other)\n+        };\n \n-    if let TokenAtOffset::Between(ref left, ref right) = token {\n-        if (right.kind() == SyntaxKind::L_CURLY || right.kind() == SyntaxKind::L_PAREN)\n-            && left.kind() != SyntaxKind::IDENT\n-        {\n-            position = FilePosition { offset: left.text_range().start(), ..position };\n-            search_kind = ReferenceKind::StructLiteral;\n-        }\n-    }\n-\n-    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position)?;\n+    let RangeInfo { range, info: (name, def) } = find_name(db, &syntax, position, opt_name)?;\n \n     let declaration = match def.kind {\n         NameKind::Macro(mac) => mac.to_nav(db),\n@@ -170,9 +165,10 @@ fn find_name(\n     db: &RootDatabase,\n     syntax: &SyntaxNode,\n     position: FilePosition,\n+    opt_name: Option<ast::Name>,\n ) -> Option<RangeInfo<(String, NameDefinition)>> {\n     let mut sb = SourceBinder::new(db);\n-    if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, position.offset) {\n+    if let Some(name) = opt_name {\n         let def = classify_name(&mut sb, InFile::new(position.file_id.into(), &name))?;\n         let range = name.syntax().text_range();\n         return Some(RangeInfo::new(range, (name.text().to_string(), def)));\n@@ -218,15 +214,8 @@ fn process_definition(\n                 if let Some(d) = classify_name_ref(&mut sb, InFile::new(file_id.into(), &name_ref))\n                 {\n                     if d == def {\n-                        let kind = if name_ref\n-                            .syntax()\n-                            .ancestors()\n-                            .find_map(ast::RecordLit::cast)\n-                            .and_then(|l| l.path())\n-                            .and_then(|p| p.segment())\n-                            .and_then(|p| p.name_ref())\n-                            .map(|n| n == name_ref)\n-                            .unwrap_or(false)\n+                        let kind = if is_record_lit_name_ref(&name_ref)\n+                            || is_call_expr_name_ref(&name_ref)\n                         {\n                             ReferenceKind::StructLiteral\n                         } else {\n@@ -301,6 +290,49 @@ fn reference_access(kind: &NameKind, name_ref: &ast::NameRef) -> Option<Referenc\n     mode.or(Some(ReferenceAccess::Read))\n }\n \n+fn is_record_lit_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::RecordLit::cast)\n+        .and_then(|l| l.path())\n+        .and_then(|p| p.segment())\n+        .map(|p| p.name_ref().as_ref() == Some(name_ref))\n+        .unwrap_or(false)\n+}\n+\n+fn get_struct_def_name_for_struc_litetal_search(\n+    syntax: &SyntaxNode,\n+    position: FilePosition,\n+) -> Option<ast::Name> {\n+    if let TokenAtOffset::Between(ref left, ref right) = syntax.token_at_offset(position.offset) {\n+        if right.kind() != SyntaxKind::L_CURLY && right.kind() != SyntaxKind::L_PAREN {\n+            return None;\n+        }\n+        if let Some(name) = find_node_at_offset::<ast::Name>(&syntax, left.text_range().start()) {\n+            return name.syntax().ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+        if find_node_at_offset::<ast::TypeParamList>(&syntax, left.text_range().start()).is_some() {\n+            return left.ancestors().find_map(ast::StructDef::cast).and_then(|l| l.name());\n+        }\n+    }\n+    None\n+}\n+\n+fn is_call_expr_name_ref(name_ref: &ast::NameRef) -> bool {\n+    name_ref\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::CallExpr::cast)\n+        .and_then(|c| match c.expr()? {\n+            ast::Expr::PathExpr(p) => {\n+                Some(p.path()?.segment()?.name_ref().as_ref() == Some(name_ref))\n+            }\n+            _ => None,\n+        })\n+        .unwrap_or(false)\n+}\n+\n #[cfg(test)]\n mod tests {\n     use crate::{\n@@ -309,7 +341,7 @@ mod tests {\n     };\n \n     #[test]\n-    fn test_struct_literal() {\n+    fn test_struct_literal_after_space() {\n         let code = r#\"\n     struct Foo <|>{\n         a: i32,\n@@ -330,6 +362,58 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_struct_literal_befor_space() {\n+        let code = r#\"\n+    struct Foo<|> {}\n+        fn main() {\n+        let f: Foo;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 18) [12; 15) Other\",\n+            &[\"FileId(1) [54; 57) Other\", \"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_with_generic_type() {\n+        let code = r#\"\n+    struct Foo<T> <|>{}\n+        fn main() {\n+        let f: Foo::<i32>;\n+        f = Foo {};\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [81; 84) StructLiteral\"],\n+        );\n+    }\n+\n+    #[test]\n+    fn test_struct_literal_for_tuple() {\n+        let code = r#\"\n+    struct Foo<|>(i32);\n+\n+    fn main() {\n+        let f: Foo;\n+        f = Foo(1);\n+    }\"#;\n+\n+        let refs = get_all_refs(code);\n+        check_result(\n+            refs,\n+            \"Foo STRUCT_DEF FileId(1) [5; 21) [12; 15) Other\",\n+            &[\"FileId(1) [71; 74) StructLiteral\"],\n+        );\n+    }\n+\n     #[test]\n     fn test_find_all_refs_for_local() {\n         let code = r#\"\n@@ -564,15 +648,15 @@ mod tests {\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(2) [16; 20) Other\", \"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(2) [16; 20) StructLiteral\", \"FileId(3) [16; 20) StructLiteral\"],\n         );\n \n         let refs =\n             analysis.find_all_refs(pos, Some(SearchScope::single_file(bar))).unwrap().unwrap();\n         check_result(\n             refs,\n             \"quux FN_DEF FileId(1) [18; 34) [25; 29) Other\",\n-            &[\"FileId(3) [16; 20) Other\"],\n+            &[\"FileId(3) [16; 20) StructLiteral\"],\n         );\n     }\n \n@@ -591,7 +675,7 @@ mod tests {\n         check_result(\n             refs,\n             \"m1 MACRO_CALL FileId(1) [9; 63) [46; 48) Other\",\n-            &[\"FileId(1) [96; 98) Other\", \"FileId(1) [114; 116) Other\"],\n+            &[\"FileId(1) [96; 98) StructLiteral\", \"FileId(1) [114; 116) StructLiteral\"],\n         );\n     }\n "}]}