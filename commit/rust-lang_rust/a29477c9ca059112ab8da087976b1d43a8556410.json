{"sha": "a29477c9ca059112ab8da087976b1d43a8556410", "node_id": "C_kwDOAAsO6NoAKGEyOTQ3N2M5Y2EwNTkxMTJhYjhkYTA4Nzk3NmIxZDQzYTg1NTY0MTA", "commit": {"author": {"name": "Petr Sumbera", "email": "petr.sumbera@oracle.com", "date": "2022-02-21T12:49:36Z"}, "committer": {"name": "Petr Sumbera", "email": "petr.sumbera@oracle.com", "date": "2022-02-21T12:49:36Z"}, "message": "more complete sparc64 ABI fix for aggregates with floating point members\n\nPrevious fix didn't handle nested structures at all.", "tree": {"sha": "ae3a8639b2a6040e8f3a81a604d6c47b3792d047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae3a8639b2a6040e8f3a81a604d6c47b3792d047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a29477c9ca059112ab8da087976b1d43a8556410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a29477c9ca059112ab8da087976b1d43a8556410", "html_url": "https://github.com/rust-lang/rust/commit/a29477c9ca059112ab8da087976b1d43a8556410", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a29477c9ca059112ab8da087976b1d43a8556410/comments", "author": {"login": "psumbera", "id": 4249116, "node_id": "MDQ6VXNlcjQyNDkxMTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4249116?v=4", "gravatar_id": "", "url": "https://api.github.com/users/psumbera", "html_url": "https://github.com/psumbera", "followers_url": "https://api.github.com/users/psumbera/followers", "following_url": "https://api.github.com/users/psumbera/following{/other_user}", "gists_url": "https://api.github.com/users/psumbera/gists{/gist_id}", "starred_url": "https://api.github.com/users/psumbera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/psumbera/subscriptions", "organizations_url": "https://api.github.com/users/psumbera/orgs", "repos_url": "https://api.github.com/users/psumbera/repos", "events_url": "https://api.github.com/users/psumbera/events{/privacy}", "received_events_url": "https://api.github.com/users/psumbera/received_events", "type": "User", "site_admin": false}, "committer": {"login": "psumbera", "id": 4249116, "node_id": "MDQ6VXNlcjQyNDkxMTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4249116?v=4", "gravatar_id": "", "url": "https://api.github.com/users/psumbera", "html_url": "https://github.com/psumbera", "followers_url": "https://api.github.com/users/psumbera/followers", "following_url": "https://api.github.com/users/psumbera/following{/other_user}", "gists_url": "https://api.github.com/users/psumbera/gists{/gist_id}", "starred_url": "https://api.github.com/users/psumbera/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/psumbera/subscriptions", "organizations_url": "https://api.github.com/users/psumbera/orgs", "repos_url": "https://api.github.com/users/psumbera/repos", "events_url": "https://api.github.com/users/psumbera/events{/privacy}", "received_events_url": "https://api.github.com/users/psumbera/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd", "url": "https://api.github.com/repos/rust-lang/rust/commits/026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd", "html_url": "https://github.com/rust-lang/rust/commit/026d8ce7f5f66ba6fbb8aaf4babb533e95ee3efd"}], "stats": {"total": 284, "additions": 183, "deletions": 101}, "files": [{"sha": "822db6d05bbdb84ccbc375b6403eafc27ea00960", "filename": "compiler/rustc_target/src/abi/call/sparc64.rs", "status": "modified", "additions": 183, "deletions": 101, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/a29477c9ca059112ab8da087976b1d43a8556410/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a29477c9ca059112ab8da087976b1d43a8556410/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fsparc64.rs?ref=a29477c9ca059112ab8da087976b1d43a8556410", "patch": "@@ -1,137 +1,219 @@\n // FIXME: This needs an audit for correctness and completeness.\n \n use crate::abi::call::{\n-    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, Reg, RegKind, Uniform,\n+    ArgAbi, ArgAttribute, ArgAttributes, ArgExtension, CastTarget, FnAbi, Reg, Uniform,\n };\n-use crate::abi::{self, HasDataLayout, Size, TyAbiInterface};\n+use crate::abi::{self, HasDataLayout, Scalar, Size, TyAbiInterface, TyAndLayout};\n+\n+#[derive(Clone, Debug)]\n+pub struct Sdata {\n+    pub prefix: [Option<Reg>; 8],\n+    pub prefix_index: usize,\n+    pub last_offset: Size,\n+    pub has_float: bool,\n+    pub arg_attribute: ArgAttribute,\n+}\n \n-fn is_homogeneous_aggregate<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>) -> Option<Uniform>\n+fn arg_scalar<C>(cx: &C, scalar: &Scalar, offset: Size, mut data: Sdata) -> Sdata\n where\n-    Ty: TyAbiInterface<'a, C> + Copy,\n     C: HasDataLayout,\n {\n-    arg.layout.homogeneous_aggregate(cx).ok().and_then(|ha| ha.unit()).and_then(|unit| {\n-        // Ensure we have at most eight uniquely addressable members.\n-        if arg.layout.size > unit.size.checked_mul(8, cx).unwrap() {\n-            return None;\n+    let dl = cx.data_layout();\n+\n+    if scalar.value != abi::F32 && scalar.value != abi::F64 {\n+        return data;\n+    }\n+\n+    data.has_float = true;\n+\n+    if !data.last_offset.is_aligned(dl.f64_align.abi) && data.last_offset < offset {\n+        if data.prefix_index == data.prefix.len() {\n+            return data;\n         }\n+        data.prefix[data.prefix_index] = Some(Reg::i32());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i32().size;\n+    }\n \n-        let valid_unit = match unit.kind {\n-            RegKind::Integer => false,\n-            RegKind::Float => false,\n-            RegKind::Vector => arg.layout.size.bits() == 128,\n-        };\n+    for _ in 0..((offset - data.last_offset).bits() / 64)\n+        .min((data.prefix.len() - data.prefix_index) as u64)\n+    {\n+        data.prefix[data.prefix_index] = Some(Reg::i64());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i64().size;\n+    }\n \n-        valid_unit.then_some(Uniform { unit, total: arg.layout.size })\n-    })\n+    if data.last_offset < offset {\n+        if data.prefix_index == data.prefix.len() {\n+            return data;\n+        }\n+        data.prefix[data.prefix_index] = Some(Reg::i32());\n+        data.prefix_index += 1;\n+        data.last_offset = data.last_offset + Reg::i32().size;\n+    }\n+\n+    if data.prefix_index == data.prefix.len() {\n+        return data;\n+    }\n+\n+    if scalar.value == abi::F32 {\n+        data.arg_attribute = ArgAttribute::InReg;\n+        data.prefix[data.prefix_index] = Some(Reg::f32());\n+        data.last_offset = offset + Reg::f32().size;\n+    } else {\n+        data.prefix[data.prefix_index] = Some(Reg::f64());\n+        data.last_offset = offset + Reg::f64().size;\n+    }\n+    data.prefix_index += 1;\n+    return data;\n }\n \n-fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, in_registers_max: Size)\n+fn arg_scalar_pair<C>(\n+    cx: &C,\n+    scalar1: &Scalar,\n+    scalar2: &Scalar,\n+    mut offset: Size,\n+    mut data: Sdata,\n+) -> Sdata\n where\n-    Ty: TyAbiInterface<'a, C> + Copy,\n     C: HasDataLayout,\n {\n-    if !arg.layout.is_aggregate() {\n-        arg.extend_integer_width_to(64);\n-        return;\n+    data = arg_scalar(cx, &scalar1, offset, data);\n+    if scalar1.value == abi::F32 {\n+        offset += Reg::f32().size;\n+    } else if scalar2.value == abi::F64 {\n+        offset += Reg::f64().size;\n+    } else if let abi::Int(i, _signed) = scalar1.value {\n+        offset += i.size();\n+    } else if scalar1.value == abi::Pointer {\n+        offset = offset + Reg::i64().size;\n     }\n \n-    // This doesn't intentionally handle structures with floats which needs\n-    // special care below.\n-    if let Some(uniform) = is_homogeneous_aggregate(cx, arg) {\n-        arg.cast_to(uniform);\n-        return;\n+    if (offset.raw % 4) != 0 && (scalar2.value == abi::F32 || scalar2.value == abi::F64) {\n+        offset.raw += 4 - (offset.raw % 4);\n+    }\n+    data = arg_scalar(cx, &scalar2, offset, data);\n+    return data;\n+}\n+\n+fn parse_structure<'a, Ty, C>(\n+    cx: &C,\n+    layout: TyAndLayout<'a, Ty>,\n+    mut data: Sdata,\n+    mut offset: Size,\n+) -> Sdata\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if let abi::FieldsShape::Union(_) = layout.fields {\n+        return data;\n     }\n \n-    if let abi::FieldsShape::Arbitrary { .. } = arg.layout.fields {\n-        let dl = cx.data_layout();\n-        let size = arg.layout.size;\n-        let mut prefix = [None; 8];\n-        let mut prefix_index = 0;\n-        let mut last_offset = Size::ZERO;\n-        let mut has_float = false;\n-        let mut arg_attribute = ArgAttribute::default();\n-\n-        for i in 0..arg.layout.fields.count() {\n-            let field = arg.layout.field(cx, i);\n-            let offset = arg.layout.fields.offset(i);\n-\n-            if let abi::Abi::Scalar(scalar) = &field.abi {\n-                if scalar.value == abi::F32 || scalar.value == abi::F64 {\n-                    has_float = true;\n-\n-                    if !last_offset.is_aligned(dl.f64_align.abi) && last_offset < offset {\n-                        if prefix_index == prefix.len() {\n-                            break;\n-                        }\n-                        prefix[prefix_index] = Some(Reg::i32());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i32().size;\n-                    }\n-\n-                    for _ in 0..((offset - last_offset).bits() / 64)\n-                        .min((prefix.len() - prefix_index) as u64)\n-                    {\n-                        prefix[prefix_index] = Some(Reg::i64());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i64().size;\n-                    }\n-\n-                    if last_offset < offset {\n-                        if prefix_index == prefix.len() {\n-                            break;\n-                        }\n-                        prefix[prefix_index] = Some(Reg::i32());\n-                        prefix_index += 1;\n-                        last_offset = last_offset + Reg::i32().size;\n-                    }\n-\n-                    if prefix_index == prefix.len() {\n-                        break;\n-                    }\n-\n-                    if scalar.value == abi::F32 {\n-                        arg_attribute = ArgAttribute::InReg;\n-                        prefix[prefix_index] = Some(Reg::f32());\n-                        last_offset = offset + Reg::f32().size;\n-                    } else {\n-                        prefix[prefix_index] = Some(Reg::f64());\n-                        last_offset = offset + Reg::f64().size;\n-                    }\n-                    prefix_index += 1;\n+    match layout.abi {\n+        abi::Abi::Scalar(scalar) => {\n+            data = arg_scalar(cx, &scalar, offset, data);\n+        }\n+        abi::Abi::Aggregate { .. } => {\n+            for i in 0..layout.fields.count().clone() {\n+                if offset < layout.fields.offset(i) {\n+                    offset = layout.fields.offset(i);\n                 }\n+                data = parse_structure(cx, layout.field(cx, i).clone(), data.clone(), offset);\n             }\n         }\n-\n-        if has_float && arg.layout.size <= in_registers_max {\n-            let mut rest_size = size - last_offset;\n-\n-            if (rest_size.raw % 8) != 0 && prefix_index < prefix.len() {\n-                prefix[prefix_index] = Some(Reg::i32());\n-                rest_size = rest_size - Reg::i32().size;\n+        _ => {\n+            if let abi::Abi::ScalarPair(scalar1, scalar2) = &layout.abi {\n+                data = arg_scalar_pair(cx, scalar1, scalar2, offset, data);\n             }\n-\n-            arg.cast_to(CastTarget {\n-                prefix,\n-                rest: Uniform { unit: Reg::i64(), total: rest_size },\n-                attrs: ArgAttributes {\n-                    regular: arg_attribute,\n-                    arg_ext: ArgExtension::None,\n-                    pointee_size: Size::ZERO,\n-                    pointee_align: None,\n-                },\n-            });\n-            return;\n         }\n     }\n \n+    return data;\n+}\n+\n+fn classify_arg<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, in_registers_max: Size)\n+where\n+    Ty: TyAbiInterface<'a, C> + Copy,\n+    C: HasDataLayout,\n+{\n+    if !arg.layout.is_aggregate() {\n+        arg.extend_integer_width_to(64);\n+        return;\n+    }\n+\n     let total = arg.layout.size;\n     if total > in_registers_max {\n         arg.make_indirect();\n         return;\n     }\n \n-    arg.cast_to(Uniform { unit: Reg::i64(), total });\n+    match arg.layout.fields {\n+        abi::FieldsShape::Primitive => unreachable!(),\n+        abi::FieldsShape::Array { .. } => {\n+            // Arrays are passed indirectly\n+            arg.make_indirect();\n+            return;\n+        }\n+        abi::FieldsShape::Union(_) => {\n+            // Unions and are always treated as a series of 64-bit integer chunks\n+        }\n+        abi::FieldsShape::Arbitrary { .. } => {\n+            // Stuctures with floating point numbers need special care.\n+\n+            let mut data = parse_structure(\n+                cx,\n+                arg.layout.clone(),\n+                Sdata {\n+                    prefix: [None; 8],\n+                    prefix_index: 0,\n+                    last_offset: Size::ZERO,\n+                    has_float: false,\n+                    arg_attribute: ArgAttribute::default(),\n+                },\n+                Size { raw: 0 },\n+            );\n+\n+            if data.has_float {\n+                // Structure { float, int, int } doesn't like to be handled like\n+                // { float, long int }. Other way around it doesn't mind.\n+                if data.last_offset < arg.layout.size\n+                    && (data.last_offset.raw % 8) != 0\n+                    && data.prefix_index < data.prefix.len()\n+                {\n+                    data.prefix[data.prefix_index] = Some(Reg::i32());\n+                    data.prefix_index += 1;\n+                    data.last_offset += Reg::i32().size;\n+                }\n+\n+                let mut rest_size = arg.layout.size - data.last_offset;\n+                if (rest_size.raw % 8) != 0 && data.prefix_index < data.prefix.len() {\n+                    data.prefix[data.prefix_index] = Some(Reg::i32());\n+                    rest_size = rest_size - Reg::i32().size;\n+                }\n+\n+                arg.cast_to(CastTarget {\n+                    prefix: data.prefix,\n+                    rest: Uniform {\n+                        unit: Reg::i64(),\n+                        total: rest_size,\n+                    },\n+                    attrs: ArgAttributes {\n+                        regular: data.arg_attribute,\n+                        arg_ext: ArgExtension::None,\n+                        pointee_size: Size::ZERO,\n+                        pointee_align: None,\n+                    },\n+                });\n+                return;\n+            }\n+        }\n+    }\n+\n+    arg.cast_to(Uniform {\n+        unit: Reg::i64(),\n+        total,\n+    });\n }\n \n pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)"}]}