{"sha": "2951527528b39dbf47c02b3d329129d677ddcdfd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5NTE1Mjc1MjhiMzlkYmY0N2MwMmIzZDMyOTEyOWQ2NzdkZGNkZmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-12T02:45:28Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-05-14T16:24:43Z"}, "message": "compiletest: Remove #[allow(vecs_implicitly_copyable)]", "tree": {"sha": "5742363dc45c5defcf2e389fdab691cd8ebb851e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5742363dc45c5defcf2e389fdab691cd8ebb851e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2951527528b39dbf47c02b3d329129d677ddcdfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2951527528b39dbf47c02b3d329129d677ddcdfd", "html_url": "https://github.com/rust-lang/rust/commit/2951527528b39dbf47c02b3d329129d677ddcdfd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2951527528b39dbf47c02b3d329129d677ddcdfd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f104d4213ae31f4e61b210ef34b223c81c8c3af", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f104d4213ae31f4e61b210ef34b223c81c8c3af", "html_url": "https://github.com/rust-lang/rust/commit/9f104d4213ae31f4e61b210ef34b223c81c8c3af"}], "stats": {"total": 437, "additions": 220, "deletions": 217}, "files": [{"sha": "dedf465b56d8bd7ea9a46a15efd71a9ced22d289", "filename": "src/compiletest/compiletest.rc", "status": "modified", "additions": 38, "deletions": 27, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fcompiletest.rc", "raw_url": "https://github.com/rust-lang/rust/raw/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fcompiletest.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rc?ref=2951527528b39dbf47c02b3d329129d677ddcdfd", "patch": "@@ -10,9 +10,7 @@\n \n #[crate_type = \"bin\"];\n \n-#[allow(vecs_implicitly_copyable)];\n #[allow(non_camel_case_types)];\n-#[allow(deprecated_pattern)];\n \n extern mod std(vers = \"0.7-pre\");\n \n@@ -43,8 +41,8 @@ pub mod errors;\n pub fn main() {\n     let args = os::args();\n     let config = parse_config(args);\n-    log_config(config);\n-    run_tests(config);\n+    log_config(&config);\n+    run_tests(&config);\n }\n \n pub fn parse_config(args: ~[~str]) -> config {\n@@ -89,30 +87,31 @@ pub fn parse_config(args: ~[~str]) -> config {\n         run_ignored: getopts::opt_present(matches, ~\"ignored\"),\n         filter:\n              if vec::len(matches.free) > 0u {\n-                 option::Some(matches.free[0])\n+                 option::Some(copy matches.free[0])\n              } else { option::None },\n         logfile: getopts::opt_maybe_str(matches, ~\"logfile\").map(|s| Path(*s)),\n         runtool: getopts::opt_maybe_str(matches, ~\"runtool\"),\n         rustcflags: getopts::opt_maybe_str(matches, ~\"rustcflags\"),\n         jit: getopts::opt_present(matches, ~\"jit\"),\n         newrt: getopts::opt_present(matches, ~\"newrt\"),\n-        target: opt_str(getopts::opt_maybe_str(matches, ~\"target\")),\n-        adb_path: opt_str(getopts::opt_maybe_str(matches, ~\"adb-path\")),\n-        adb_test_dir: opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")),\n+        target: opt_str2(getopts::opt_maybe_str(matches, ~\"target\")).to_str(),\n+        adb_path: opt_str2(getopts::opt_maybe_str(matches, ~\"adb-path\")).to_str(),\n+        adb_test_dir:\n+            opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")).to_str(),\n         adb_device_status:\n-            if (opt_str(getopts::opt_maybe_str(matches, ~\"target\")) ==\n+            if (opt_str2(getopts::opt_maybe_str(matches, ~\"target\")) ==\n                 ~\"arm-linux-androideabi\") {\n-                if (opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                if (opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n                     ~\"(none)\" &&\n-                    opt_str(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n+                    opt_str2(getopts::opt_maybe_str(matches, ~\"adb-test-dir\")) !=\n                     ~\"\") { true }\n                 else { false }\n             } else { false },\n         verbose: getopts::opt_present(matches, ~\"verbose\")\n     }\n }\n \n-pub fn log_config(config: config) {\n+pub fn log_config(config: &config) {\n     let c = config;\n     logv(c, fmt!(\"configuration:\"));\n     logv(c, fmt!(\"compile_lib_path: %s\", config.compile_lib_path));\n@@ -123,9 +122,9 @@ pub fn log_config(config: config) {\n     logv(c, fmt!(\"stage_id: %s\", config.stage_id));\n     logv(c, fmt!(\"mode: %s\", mode_str(config.mode)));\n     logv(c, fmt!(\"run_ignored: %b\", config.run_ignored));\n-    logv(c, fmt!(\"filter: %s\", opt_str(config.filter)));\n-    logv(c, fmt!(\"runtool: %s\", opt_str(config.runtool)));\n-    logv(c, fmt!(\"rustcflags: %s\", opt_str(config.rustcflags)));\n+    logv(c, fmt!(\"filter: %s\", opt_str(&config.filter)));\n+    logv(c, fmt!(\"runtool: %s\", opt_str(&config.runtool)));\n+    logv(c, fmt!(\"rustcflags: %s\", opt_str(&config.rustcflags)));\n     logv(c, fmt!(\"jit: %b\", config.jit));\n     logv(c, fmt!(\"newrt: %b\", config.newrt));\n     logv(c, fmt!(\"target: %s\", config.target));\n@@ -136,8 +135,18 @@ pub fn log_config(config: config) {\n     logv(c, fmt!(\"\\n\"));\n }\n \n-pub fn opt_str(maybestr: Option<~str>) -> ~str {\n-    match maybestr { option::Some(s) => s, option::None => ~\"(none)\" }\n+pub fn opt_str<'a>(maybestr: &'a Option<~str>) -> &'a str {\n+    match *maybestr {\n+        option::None => \"(none)\",\n+        option::Some(ref s) => {\n+            let s: &'a str = *s;\n+            s\n+        }\n+    }\n+}\n+\n+pub fn opt_str2(maybestr: Option<~str>) -> ~str {\n+    match maybestr { None => ~\"(none)\", Some(s) => { s } }\n }\n \n pub fn str_opt(maybestr: ~str) -> Option<~str> {\n@@ -165,16 +174,16 @@ pub fn mode_str(mode: mode) -> ~str {\n     }\n }\n \n-pub fn run_tests(config: config) {\n+pub fn run_tests(config: &config) {\n     let opts = test_opts(config);\n     let tests = make_tests(config);\n     let res = test::run_tests_console(&opts, tests);\n     if !res { fail!(\"Some tests failed\"); }\n }\n \n-pub fn test_opts(config: config) -> test::TestOpts {\n+pub fn test_opts(config: &config) -> test::TestOpts {\n     test::TestOpts {\n-        filter: config.filter,\n+        filter: copy config.filter,\n         run_ignored: config.run_ignored,\n         logfile: copy config.logfile,\n         run_tests: true,\n@@ -184,7 +193,7 @@ pub fn test_opts(config: config) -> test::TestOpts {\n     }\n }\n \n-pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n+pub fn make_tests(config: &config) -> ~[test::TestDescAndFn] {\n     debug!(\"making tests from %s\",\n            config.src_base.to_str());\n     let mut tests = ~[];\n@@ -198,7 +207,7 @@ pub fn make_tests(config: config) -> ~[test::TestDescAndFn] {\n     tests\n }\n \n-pub fn is_test(config: config, testfile: &Path) -> bool {\n+pub fn is_test(config: &config, testfile: &Path) -> bool {\n     // Pretty-printer does not work with .rc files yet\n     let valid_extensions =\n         match config.mode {\n@@ -221,7 +230,7 @@ pub fn is_test(config: config, testfile: &Path) -> bool {\n     return valid;\n }\n \n-pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n+pub fn make_test(config: &config, testfile: &Path) -> test::TestDescAndFn {\n     test::TestDescAndFn {\n         desc: test::TestDesc {\n             name: make_test_name(config, testfile),\n@@ -232,13 +241,15 @@ pub fn make_test(config: config, testfile: &Path) -> test::TestDescAndFn {\n     }\n }\n \n-pub fn make_test_name(config: config, testfile: &Path) -> test::TestName {\n+pub fn make_test_name(config: &config, testfile: &Path) -> test::TestName {\n     test::DynTestName(fmt!(\"[%s] %s\",\n                            mode_str(config.mode),\n                            testfile.to_str()))\n }\n \n-pub fn make_test_closure(config: config, testfile: &Path) -> test::TestFn {\n-    let testfile = testfile.to_str();\n-    test::DynTestFn(|| runtest::run(config, testfile))\n+pub fn make_test_closure(config: &config, testfile: &Path) -> test::TestFn {\n+    use core::cell::Cell;\n+    let config = Cell(copy *config);\n+    let testfile = Cell(testfile.to_str());\n+    test::DynTestFn(|| { runtest::run(config.take(), testfile.take()) })\n }"}, {"sha": "b1f4c9f515bb0fc6280aa361e363d8f4feee7f74", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=2951527528b39dbf47c02b3d329129d677ddcdfd", "patch": "@@ -52,12 +52,14 @@ pub fn load_props(testfile: &Path) -> TestProps {\n             pp_exact = parse_pp_exact(ln, testfile);\n         }\n \n-        for parse_aux_build(ln).each |ab| {\n-            aux_builds.push(*ab);\n+        match parse_aux_build(ln) {\n+            Some(ab) => { aux_builds.push(ab); }\n+            None => {}\n         }\n \n-        for parse_exec_env(ln).each |ee| {\n-            exec_env.push(*ee);\n+        match parse_exec_env(ln) {\n+            Some(ee) => { exec_env.push(ee); }\n+            None => {}\n         }\n \n         match parse_debugger_cmd(ln) {\n@@ -81,7 +83,7 @@ pub fn load_props(testfile: &Path) -> TestProps {\n     };\n }\n \n-pub fn is_test_ignored(config: config, testfile: &Path) -> bool {\n+pub fn is_test_ignored(config: &config, testfile: &Path) -> bool {\n     for iter_header(testfile) |ln| {\n         if parse_name_directive(ln, ~\"xfail-test\") { return true; }\n         if parse_name_directive(ln, xfail_target()) { return true; }\n@@ -111,44 +113,47 @@ fn iter_header(testfile: &Path, it: &fn(~str) -> bool) -> bool {\n     return true;\n }\n \n-fn parse_error_pattern(line: ~str) -> Option<~str> {\n+fn parse_error_pattern(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"error-pattern\")\n }\n \n-fn parse_aux_build(line: ~str) -> Option<~str> {\n+fn parse_aux_build(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"aux-build\")\n }\n \n-fn parse_compile_flags(line: ~str) -> Option<~str> {\n+fn parse_compile_flags(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"compile-flags\")\n }\n \n-fn parse_debugger_cmd(line: ~str) -> Option<~str> {\n+fn parse_debugger_cmd(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"debugger\")\n }\n \n-fn parse_check_line(line: ~str) -> Option<~str> {\n+fn parse_check_line(line: &str) -> Option<~str> {\n     parse_name_value_directive(line, ~\"check\")\n }\n \n-fn parse_exec_env(line: ~str) -> Option<(~str, ~str)> {\n+fn parse_exec_env(line: &str) -> Option<(~str, ~str)> {\n     do parse_name_value_directive(line, ~\"exec-env\").map |nv| {\n         // nv is either FOO or FOO=BAR\n         let mut strs = ~[];\n         for str::each_splitn_char(*nv, '=', 1u) |s| { strs.push(s.to_owned()); }\n         match strs.len() {\n-          1u => (strs[0], ~\"\"),\n-          2u => (strs[0], strs[1]),\n+          1u => (strs.pop(), ~\"\"),\n+          2u => {\n+              let end = strs.pop();\n+              (strs.pop(), end)\n+          }\n           n => fail!(\"Expected 1 or 2 strings, not %u\", n)\n         }\n     }\n }\n \n-fn parse_pp_exact(line: ~str, testfile: &Path) -> Option<Path> {\n+fn parse_pp_exact(line: &str, testfile: &Path) -> Option<Path> {\n     match parse_name_value_directive(line, ~\"pp-exact\") {\n       Some(s) => Some(Path(s)),\n       None => {\n-        if parse_name_directive(line, ~\"pp-exact\") {\n+        if parse_name_directive(line, \"pp-exact\") {\n             Some(testfile.file_path())\n         } else {\n             None\n@@ -157,11 +162,11 @@ fn parse_pp_exact(line: ~str, testfile: &Path) -> Option<Path> {\n     }\n }\n \n-fn parse_name_directive(line: ~str, directive: ~str) -> bool {\n+fn parse_name_directive(line: &str, directive: &str) -> bool {\n     str::contains(line, directive)\n }\n \n-fn parse_name_value_directive(line: ~str,\n+fn parse_name_value_directive(line: &str,\n                               directive: ~str) -> Option<~str> {\n     let keycolon = directive + ~\":\";\n     match str::find_str(line, keycolon) {"}, {"sha": "71efa5596a8ad0d1c0dacdc823acd444fb08c57a", "filename": "src/compiletest/procsrv.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fprocsrv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fprocsrv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fprocsrv.rs?ref=2951527528b39dbf47c02b3d329129d677ddcdfd", "patch": "@@ -14,7 +14,7 @@ use core::run::spawn_process;\n use core::run;\n \n #[cfg(target_os = \"win32\")]\n-fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n+fn target_env(lib_path: &str, prog: &str) -> ~[(~str,~str)] {\n \n     let mut env = os::env();\n \n@@ -27,7 +27,7 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n         if k == ~\"PATH\" { (~\"PATH\", v + ~\";\" + lib_path + ~\";\" + aux_path) }\n         else { (k,v) }\n     };\n-    if str::ends_with(prog, ~\"rustc.exe\") {\n+    if str::ends_with(prog, \"rustc.exe\") {\n         env.push((~\"RUST_THREADS\", ~\"1\"));\n     }\n     return env;\n@@ -36,16 +36,16 @@ fn target_env(lib_path: ~str, prog: ~str) -> ~[(~str,~str)] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn target_env(_lib_path: ~str, _prog: ~str) -> ~[(~str,~str)] {\n+fn target_env(_lib_path: &str, _prog: &str) -> ~[(~str,~str)] {\n     ~[]\n }\n \n-struct Result {status: int, out: ~str, err: ~str}\n+pub struct Result {status: int, out: ~str, err: ~str}\n \n // FIXME (#2659): This code is duplicated in core::run::program_output\n-pub fn run(lib_path: ~str,\n-           prog: ~str,\n-           args: ~[~str],\n+pub fn run(lib_path: &str,\n+           prog: &str,\n+           args: &[~str],\n            env: ~[(~str, ~str)],\n            input: Option<~str>) -> Result {\n     let pipe_in = os::pipe();"}, {"sha": "73e1e3ee763842ebb5b979b683fcc2c92f2dab81", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 150, "deletions": 163, "changes": 313, "blob_url": "https://github.com/rust-lang/rust/blob/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=2951527528b39dbf47c02b3d329129d677ddcdfd", "patch": "@@ -30,40 +30,40 @@ pub fn run(config: config, testfile: ~str) {\n     let props = load_props(&testfile);\n     debug!(\"loaded props\");\n     match config.mode {\n-      mode_compile_fail => run_cfail_test(config, props, &testfile),\n-      mode_run_fail => run_rfail_test(config, props, &testfile),\n-      mode_run_pass => run_rpass_test(config, props, &testfile),\n-      mode_pretty => run_pretty_test(config, props, &testfile),\n-      mode_debug_info => run_debuginfo_test(config, props, &testfile)\n+      mode_compile_fail => run_cfail_test(&config, &props, &testfile),\n+      mode_run_fail => run_rfail_test(&config, &props, &testfile),\n+      mode_run_pass => run_rpass_test(&config, &props, &testfile),\n+      mode_pretty => run_pretty_test(&config, &props, &testfile),\n+      mode_debug_info => run_debuginfo_test(&config, &props, &testfile)\n     }\n }\n \n-fn run_cfail_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_cfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = compile_test(config, props, testfile);\n \n     if ProcRes.status == 0 {\n-        fatal_ProcRes(~\"compile-fail test compiled successfully!\", ProcRes);\n+        fatal_ProcRes(~\"compile-fail test compiled successfully!\", &ProcRes);\n     }\n \n-    check_correct_failure_status(ProcRes);\n+    check_correct_failure_status(&ProcRes);\n \n     let expected_errors = errors::load_errors(testfile);\n     if !expected_errors.is_empty() {\n         if !props.error_patterns.is_empty() {\n             fatal(~\"both error pattern and expected errors specified\");\n         }\n-        check_expected_errors(expected_errors, testfile, ProcRes);\n+        check_expected_errors(expected_errors, testfile, &ProcRes);\n     } else {\n-        check_error_patterns(props, testfile, ProcRes);\n+        check_error_patterns(props, testfile, &ProcRes);\n     }\n }\n \n-fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_rfail_test(config: &config, props: &TestProps, testfile: &Path) {\n     let ProcRes = if !config.jit {\n         let ProcRes = compile_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n         exec_compiled_test(config, props, testfile)\n@@ -74,26 +74,26 @@ fn run_rfail_test(config: config, props: TestProps, testfile: &Path) {\n     // The value our Makefile configures valgrind to return on failure\n     static valgrind_err: int = 100;\n     if ProcRes.status == valgrind_err {\n-        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", ProcRes);\n+        fatal_ProcRes(~\"run-fail test isn't valgrind-clean!\", &ProcRes);\n     }\n \n     match config.target {\n \n         ~\"arm-linux-androideabi\" => {\n             if (config.adb_device_status) {\n-                check_correct_failure_status(ProcRes);\n-                check_error_patterns(props, testfile, ProcRes);\n+                check_correct_failure_status(&ProcRes);\n+                check_error_patterns(props, testfile, &ProcRes);\n             }\n         }\n \n         _=> {\n-            check_correct_failure_status(ProcRes);\n-            check_error_patterns(props, testfile, ProcRes);\n+            check_correct_failure_status(&ProcRes);\n+            check_error_patterns(props, testfile, &ProcRes);\n         }\n     }\n }\n \n-fn check_correct_failure_status(ProcRes: ProcRes) {\n+fn check_correct_failure_status(ProcRes: &ProcRes) {\n     // The value the rust runtime returns on failure\n     static rust_err: int = 101;\n     if ProcRes.status != rust_err {\n@@ -104,27 +104,27 @@ fn check_correct_failure_status(ProcRes: ProcRes) {\n     }\n }\n \n-fn run_rpass_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_rpass_test(config: &config, props: &TestProps, testfile: &Path) {\n     if !config.jit {\n         let mut ProcRes = compile_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+            fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n         }\n \n         ProcRes = exec_compiled_test(config, props, testfile);\n \n         if ProcRes.status != 0 {\n-            fatal_ProcRes(~\"test run failed!\", ProcRes);\n+            fatal_ProcRes(~\"test run failed!\", &ProcRes);\n         }\n     } else {\n         let ProcRes = jit_test(config, props, testfile);\n \n-        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", ProcRes); }\n+        if ProcRes.status != 0 { fatal_ProcRes(~\"jit failed!\", &ProcRes); }\n     }\n }\n \n-fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_pretty_test(config: &config, props: &TestProps, testfile: &Path) {\n     if props.pp_exact.is_some() {\n         logv(config, ~\"testing for exact pretty-printing\");\n     } else { logv(config, ~\"testing for converging pretty-printing\"); }\n@@ -137,32 +137,33 @@ fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n     let mut round = 0;\n     while round < rounds {\n         logv(config, fmt!(\"pretty-printing round %d\", round));\n-        let ProcRes = print_source(config, testfile, srcs[round]);\n+        let ProcRes = print_source(config, testfile, copy srcs[round]);\n \n         if ProcRes.status != 0 {\n             fatal_ProcRes(fmt!(\"pretty-printing failed in round %d\", round),\n-                          ProcRes);\n+                          &ProcRes);\n         }\n \n-        srcs.push(ProcRes.stdout);\n+        let ProcRes{ stdout, _ } = ProcRes;\n+        srcs.push(stdout);\n         round += 1;\n     }\n \n     let mut expected =\n         match props.pp_exact {\n-          Some(file) => {\n-            let filepath = testfile.dir_path().push_rel(&file);\n+          Some(ref file) => {\n+            let filepath = testfile.dir_path().push_rel(file);\n             io::read_whole_file_str(&filepath).get()\n           }\n-          None => { srcs[vec::len(srcs) - 2u] }\n+          None => { copy srcs[srcs.len() - 2u] }\n         };\n-    let mut actual = srcs[vec::len(srcs) - 1u];\n+    let mut actual = copy srcs[srcs.len() - 1u];\n \n     if props.pp_exact.is_some() {\n         // Now we have to care about line endings\n         let cr = ~\"\\r\";\n-        actual = str::replace(actual, cr, ~\"\");\n-        expected = str::replace(expected, cr, ~\"\");\n+        actual = str::replace(actual, cr, \"\");\n+        expected = str::replace(expected, cr, \"\");\n     }\n \n     compare_source(expected, actual);\n@@ -171,23 +172,22 @@ fn run_pretty_test(config: config, props: TestProps, testfile: &Path) {\n     let ProcRes = typecheck_source(config, props, testfile, actual);\n \n     if ProcRes.status != 0 {\n-        fatal_ProcRes(~\"pretty-printed source does not typecheck\", ProcRes);\n+        fatal_ProcRes(~\"pretty-printed source does not typecheck\", &ProcRes);\n     }\n \n     return;\n \n-    fn print_source(config: config, testfile: &Path, src: ~str) -> ProcRes {\n+    fn print_source(config: &config, testfile: &Path, src: ~str) -> ProcRes {\n         compose_and_run(config, testfile, make_pp_args(config, testfile),\n                         ~[], config.compile_lib_path, Some(src))\n     }\n \n-    fn make_pp_args(config: config, _testfile: &Path) -> ProcArgs {\n-        let prog = config.rustc_path;\n+    fn make_pp_args(config: &config, _testfile: &Path) -> ProcArgs {\n         let args = ~[~\"-\", ~\"--pretty\", ~\"normal\"];\n-        return ProcArgs {prog: prog.to_str(), args: args};\n+        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n \n-    fn compare_source(expected: ~str, actual: ~str) {\n+    fn compare_source(expected: &str, actual: &str) {\n         if expected != actual {\n             error(~\"pretty-printed source does not match expected source\");\n             let msg =\n@@ -207,46 +207,45 @@ actual:\\n\\\n         }\n     }\n \n-    fn typecheck_source(config: config, props: TestProps,\n+    fn typecheck_source(config: &config, props: &TestProps,\n                         testfile: &Path, src: ~str) -> ProcRes {\n-        compose_and_run_compiler(\n-            config, props, testfile,\n-            make_typecheck_args(config, props, testfile),\n-            Some(src))\n+        let args = make_typecheck_args(config, props, testfile);\n+        compose_and_run_compiler(config, props, testfile, args, Some(src))\n     }\n \n-    fn make_typecheck_args(config: config, props: TestProps, testfile: &Path) -> ProcArgs {\n-        let prog = config.rustc_path;\n+    fn make_typecheck_args(config: &config, props: &TestProps, testfile: &Path) -> ProcArgs {\n         let mut args = ~[~\"-\",\n                          ~\"--no-trans\", ~\"--lib\",\n                          ~\"-L\", config.build_base.to_str(),\n                          ~\"-L\",\n                          aux_output_dir_name(config, testfile).to_str()];\n-        args += split_maybe_args(config.rustcflags);\n-        args += split_maybe_args(props.compile_flags);\n-        return ProcArgs {prog: prog.to_str(), args: args};\n+        args += split_maybe_args(&config.rustcflags);\n+        args += split_maybe_args(&props.compile_flags);\n+        return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n     }\n }\n \n-fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n+fn run_debuginfo_test(config: &config, props: &TestProps, testfile: &Path) {\n     // do not optimize debuginfo tests\n-    let config = match config.rustcflags {\n-        Some(flags) => config {\n-            rustcflags: Some(str::replace(flags, ~\"-O\", ~\"\")),\n-            .. config\n+    let mut config = match config.rustcflags {\n+        Some(ref flags) => config {\n+            rustcflags: Some(str::replace(*flags, ~\"-O\", ~\"\")),\n+            .. copy *config\n         },\n-        None => config\n+        None => copy *config\n     };\n+    let config = &mut config;\n+    let cmds = str::connect(props.debugger_cmds, \"\\n\");\n+    let check_lines = copy props.check_lines;\n \n     // compile test file (it shoud have 'compile-flags:-g' in the header)\n     let mut ProcRes = compile_test(config, props, testfile);\n     if ProcRes.status != 0 {\n-        fatal_ProcRes(~\"compilation failed!\", ProcRes);\n+        fatal_ProcRes(~\"compilation failed!\", &ProcRes);\n     }\n \n     // write debugger script\n-    let script_str = str::append(str::connect(props.debugger_cmds, \"\\n\"),\n-                                 ~\"\\nquit\\n\");\n+    let script_str = str::append(cmds, \"\\nquit\\n\");\n     debug!(\"script_str = %s\", script_str);\n     dump_output_file(config, testfile, script_str, ~\"debugger.script\");\n \n@@ -265,13 +264,13 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         fatal(~\"gdb failed to execute\");\n     }\n \n-    let num_check_lines = vec::len(props.check_lines);\n+    let num_check_lines = vec::len(check_lines);\n     if num_check_lines > 0 {\n         // check if each line in props.check_lines appears in the\n         // output (in order)\n         let mut i = 0u;\n         for str::each_line(ProcRes.stdout) |line| {\n-            if props.check_lines[i].trim() == line.trim() {\n+            if check_lines[i].trim() == line.trim() {\n                 i += 1u;\n             }\n             if i == num_check_lines {\n@@ -281,14 +280,14 @@ fn run_debuginfo_test(config: config, props: TestProps, testfile: &Path) {\n         }\n         if i != num_check_lines {\n             fatal_ProcRes(fmt!(\"line not found in debugger output: %s\"\n-                               props.check_lines[i]), ProcRes);\n+                               check_lines[i]), &ProcRes);\n         }\n     }\n }\n \n-fn check_error_patterns(props: TestProps,\n+fn check_error_patterns(props: &TestProps,\n                         testfile: &Path,\n-                        ProcRes: ProcRes) {\n+                        ProcRes: &ProcRes) {\n     if vec::is_empty(props.error_patterns) {\n         fatal(~\"no error pattern specified in \" + testfile.to_str());\n     }\n@@ -298,18 +297,18 @@ fn check_error_patterns(props: TestProps,\n     }\n \n     let mut next_err_idx = 0u;\n-    let mut next_err_pat = props.error_patterns[next_err_idx];\n+    let mut next_err_pat = &props.error_patterns[next_err_idx];\n     let mut done = false;\n     for str::each_line(ProcRes.stderr) |line| {\n-        if str::contains(line, next_err_pat) {\n-            debug!(\"found error pattern %s\", next_err_pat);\n+        if str::contains(line, *next_err_pat) {\n+            debug!(\"found error pattern %s\", *next_err_pat);\n             next_err_idx += 1u;\n             if next_err_idx == vec::len(props.error_patterns) {\n                 debug!(\"found all error patterns\");\n                 done = true;\n                 break;\n             }\n-            next_err_pat = props.error_patterns[next_err_idx];\n+            next_err_pat = &props.error_patterns[next_err_idx];\n         }\n     }\n     if done { return; }\n@@ -330,7 +329,7 @@ fn check_error_patterns(props: TestProps,\n \n fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n                          testfile: &Path,\n-                         ProcRes: ProcRes) {\n+                         ProcRes: &ProcRes) {\n \n     // true if we found the error in question\n     let mut found_flags = vec::from_elem(\n@@ -380,14 +379,14 @@ fn check_expected_errors(expected_errors: ~[errors::ExpectedError],\n \n     for uint::range(0u, vec::len(found_flags)) |i| {\n         if !found_flags[i] {\n-            let ee = expected_errors[i];\n+            let ee = &expected_errors[i];\n             fatal_ProcRes(fmt!(\"expected %s on line %u not found: %s\",\n                                ee.kind, ee.line, ee.msg), ProcRes);\n         }\n     }\n }\n \n-fn is_compiler_error_or_warning(line: ~str) -> bool {\n+fn is_compiler_error_or_warning(line: &str) -> bool {\n     let mut i = 0u;\n     return\n         scan_until_char(line, ':', &mut i) &&\n@@ -401,11 +400,11 @@ fn is_compiler_error_or_warning(line: ~str) -> bool {\n         scan_char(line, ':', &mut i) &&\n         scan_integer(line, &mut i) &&\n         scan_char(line, ' ', &mut i) &&\n-        (scan_string(line, ~\"error\", &mut i) ||\n-         scan_string(line, ~\"warning\", &mut i));\n+        (scan_string(line, \"error\", &mut i) ||\n+         scan_string(line, \"warning\", &mut i));\n }\n \n-fn scan_until_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n+fn scan_until_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -417,7 +416,7 @@ fn scan_until_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n+fn scan_char(haystack: &str, needle: char, idx: &mut uint) -> bool {\n     if *idx >= haystack.len() {\n         return false;\n     }\n@@ -429,7 +428,7 @@ fn scan_char(haystack: ~str, needle: char, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_integer(haystack: ~str, idx: &mut uint) -> bool {\n+fn scan_integer(haystack: &str, idx: &mut uint) -> bool {\n     let mut i = *idx;\n     while i < haystack.len() {\n         let range = str::char_range_at(haystack, i);\n@@ -445,7 +444,7 @@ fn scan_integer(haystack: ~str, idx: &mut uint) -> bool {\n     return true;\n }\n \n-fn scan_string(haystack: ~str, needle: ~str, idx: &mut uint) -> bool {\n+fn scan_string(haystack: &str, needle: &str, idx: &mut uint) -> bool {\n     let mut haystack_i = *idx;\n     let mut needle_i = 0u;\n     while needle_i < needle.len() {\n@@ -466,34 +465,29 @@ struct ProcArgs {prog: ~str, args: ~[~str]}\n \n struct ProcRes {status: int, stdout: ~str, stderr: ~str, cmdline: ~str}\n \n-fn compile_test(config: config, props: TestProps,\n+fn compile_test(config: &config, props: &TestProps,\n                 testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [])\n }\n \n-fn jit_test(config: config, props: TestProps, testfile: &Path) -> ProcRes {\n+fn jit_test(config: &config, props: &TestProps, testfile: &Path) -> ProcRes {\n     compile_test_(config, props, testfile, [~\"--jit\"])\n }\n \n-fn compile_test_(config: config, props: TestProps,\n+fn compile_test_(config: &config, props: &TestProps,\n                  testfile: &Path, extra_args: &[~str]) -> ProcRes {\n     let link_args = ~[~\"-L\", aux_output_dir_name(config, testfile).to_str()];\n-    compose_and_run_compiler(\n-        config, props, testfile,\n-        make_compile_args(config, props, link_args + extra_args,\n-                          make_exe_name, testfile),\n-        None)\n+    let args = make_compile_args(config, props, link_args + extra_args,\n+                                 make_exe_name, testfile);\n+    compose_and_run_compiler(config, props, testfile, args, None)\n }\n \n-fn exec_compiled_test(config: config, props: TestProps,\n+fn exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     // If testing the new runtime then set the RUST_NEWRT env var\n-    let env = if config.newrt {\n-        props.exec_env + ~[(~\"RUST_NEWRT\", ~\"1\")]\n-    } else {\n-        props.exec_env\n-    };\n+    let env = copy props.exec_env;\n+    let env = if config.newrt { env + &[(~\"RUST_NEWRT\", ~\"1\")] } else { env };\n \n     match config.target {\n \n@@ -515,8 +509,8 @@ fn exec_compiled_test(config: config, props: TestProps,\n }\n \n fn compose_and_run_compiler(\n-    config: config,\n-    props: TestProps,\n+    config: &config,\n+    props: &TestProps,\n     testfile: &Path,\n     args: ProcArgs,\n     input: Option<~str>) -> ProcRes {\n@@ -539,7 +533,7 @@ fn compose_and_run_compiler(\n             fatal_ProcRes(\n                 fmt!(\"auxiliary build of %s failed to compile: \",\n                      abs_ab.to_str()),\n-                auxres);\n+                &auxres);\n         }\n \n         match config.target {\n@@ -565,74 +559,66 @@ fn ensure_dir(path: &Path) {\n     }\n }\n \n-fn compose_and_run(config: config, testfile: &Path,\n-                   ProcArgs: ProcArgs,\n+fn compose_and_run(config: &config, testfile: &Path,\n+                   ProcArgs{ args, prog }: ProcArgs,\n                    procenv: ~[(~str, ~str)],\n-                   lib_path: ~str,\n+                   lib_path: &str,\n                    input: Option<~str>) -> ProcRes {\n     return program_output(config, testfile, lib_path,\n-                       ProcArgs.prog, ProcArgs.args, procenv, input);\n+                          prog, args, procenv, input);\n }\n \n-fn make_compile_args(config: config, props: TestProps, extras: ~[~str],\n-                     xform: &fn(config, (&Path)) -> Path,\n+fn make_compile_args(config: &config, props: &TestProps, extras: ~[~str],\n+                     xform: &fn(&config, (&Path)) -> Path,\n                      testfile: &Path) -> ProcArgs {\n-    let prog = config.rustc_path;\n     let mut args = ~[testfile.to_str(),\n                      ~\"-o\", xform(config, testfile).to_str(),\n                      ~\"-L\", config.build_base.to_str()]\n         + extras;\n-    args += split_maybe_args(config.rustcflags);\n-    args += split_maybe_args(props.compile_flags);\n-    return ProcArgs {prog: prog.to_str(), args: args};\n+    args += split_maybe_args(&config.rustcflags);\n+    args += split_maybe_args(&props.compile_flags);\n+    return ProcArgs {prog: config.rustc_path.to_str(), args: args};\n }\n \n-fn make_lib_name(config: config, auxfile: &Path, testfile: &Path) -> Path {\n+fn make_lib_name(config: &config, auxfile: &Path, testfile: &Path) -> Path {\n     // what we return here is not particularly important, as it\n     // happens; rustc ignores everything except for the directory.\n     let auxname = output_testname(auxfile);\n     aux_output_dir_name(config, testfile).push_rel(&auxname)\n }\n \n-fn make_exe_name(config: config, testfile: &Path) -> Path {\n+fn make_exe_name(config: &config, testfile: &Path) -> Path {\n     Path(output_base_name(config, testfile).to_str() +\n             str::to_owned(os::EXE_SUFFIX))\n }\n \n-fn make_run_args(config: config, _props: TestProps, testfile: &Path) ->\n+fn make_run_args(config: &config, _props: &TestProps, testfile: &Path) ->\n    ProcArgs {\n-    let toolargs = {\n-            // If we've got another tool to run under (valgrind),\n-            // then split apart its command\n-            let runtool =\n-                match config.runtool {\n-                  Some(s) => Some(s),\n-                  None => None\n-                };\n-            split_maybe_args(runtool)\n-        };\n+    // If we've got another tool to run under (valgrind),\n+    // then split apart its command\n+    let toolargs = split_maybe_args(&config.runtool);\n \n-    let args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n-    return ProcArgs {prog: args[0],\n-                     args: vec::slice(args, 1, args.len()).to_vec()};\n+    let mut args = toolargs + ~[make_exe_name(config, testfile).to_str()];\n+    let prog = args.shift();\n+    return ProcArgs {prog: prog, args: args};\n }\n \n-fn split_maybe_args(argstr: Option<~str>) -> ~[~str] {\n+fn split_maybe_args(argstr: &Option<~str>) -> ~[~str] {\n     fn rm_whitespace(v: ~[~str]) -> ~[~str] {\n         v.filtered(|s| !str::is_whitespace(*s))\n     }\n \n-    match argstr {\n-        Some(s) => {\n+    match *argstr {\n+        Some(ref s) => {\n             let mut ss = ~[];\n-            for str::each_split_char(s, ' ') |s| { ss.push(s.to_owned()) }\n+            for str::each_split_char(*s, ' ') |s| { ss.push(s.to_owned()) }\n             rm_whitespace(ss)\n         }\n         None => ~[]\n     }\n }\n \n-fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n+fn program_output(config: &config, testfile: &Path, lib_path: &str, prog: ~str,\n                   args: ~[~str], env: ~[(~str, ~str)],\n                   input: Option<~str>) -> ProcRes {\n     let cmdline =\n@@ -641,67 +627,68 @@ fn program_output(config: config, testfile: &Path, lib_path: ~str, prog: ~str,\n             logv(config, fmt!(\"executing %s\", cmdline));\n             cmdline\n         };\n-    let res = procsrv::run(lib_path, prog, args, env, input);\n-    dump_output(config, testfile, res.out, res.err);\n-    return ProcRes {status: res.status,\n-         stdout: res.out,\n-         stderr: res.err,\n+    let procsrv::Result{ out, err, status } =\n+            procsrv::run(lib_path, prog, args, env, input);\n+    dump_output(config, testfile, out, err);\n+    return ProcRes {status: status,\n+         stdout: out,\n+         stderr: err,\n          cmdline: cmdline};\n }\n \n // Linux and mac don't require adjusting the library search path\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"macos\")]\n #[cfg(target_os = \"freebsd\")]\n-fn make_cmdline(_libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n+fn make_cmdline(_libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s\", prog, str::connect(args, ~\" \"))\n }\n \n #[cfg(target_os = \"win32\")]\n-fn make_cmdline(libpath: ~str, prog: ~str, args: ~[~str]) -> ~str {\n+fn make_cmdline(libpath: &str, prog: &str, args: &[~str]) -> ~str {\n     fmt!(\"%s %s %s\", lib_path_cmd_prefix(libpath), prog,\n          str::connect(args, ~\" \"))\n }\n \n // Build the LD_LIBRARY_PATH variable as it would be seen on the command line\n // for diagnostic purposes\n-fn lib_path_cmd_prefix(path: ~str) -> ~str {\n+fn lib_path_cmd_prefix(path: &str) -> ~str {\n     fmt!(\"%s=\\\"%s\\\"\", util::lib_path_env_var(), util::make_new_path(path))\n }\n \n-fn dump_output(config: config, testfile: &Path, out: ~str, err: ~str) {\n-    dump_output_file(config, testfile, out, ~\"out\");\n-    dump_output_file(config, testfile, err, ~\"err\");\n+fn dump_output(config: &config, testfile: &Path, out: &str, err: &str) {\n+    dump_output_file(config, testfile, out, \"out\");\n+    dump_output_file(config, testfile, err, \"err\");\n     maybe_dump_to_stdout(config, out, err);\n }\n \n-fn dump_output_file(config: config, testfile: &Path,\n-                    out: ~str, extension: ~str) {\n+fn dump_output_file(config: &config, testfile: &Path,\n+                    out: &str, extension: &str) {\n     let outfile = make_out_name(config, testfile, extension);\n     let writer =\n         io::file_writer(&outfile, ~[io::Create, io::Truncate]).get();\n     writer.write_str(out);\n }\n \n-fn make_out_name(config: config, testfile: &Path, extension: ~str) -> Path {\n+fn make_out_name(config: &config, testfile: &Path, extension: &str) -> Path {\n     output_base_name(config, testfile).with_filetype(extension)\n }\n \n-fn aux_output_dir_name(config: config, testfile: &Path) -> Path {\n+fn aux_output_dir_name(config: &config, testfile: &Path) -> Path {\n     output_base_name(config, testfile).with_filetype(\"libaux\")\n }\n \n fn output_testname(testfile: &Path) -> Path {\n     Path(testfile.filestem().get())\n }\n \n-fn output_base_name(config: config, testfile: &Path) -> Path {\n+fn output_base_name(config: &config, testfile: &Path) -> Path {\n     config.build_base\n         .push_rel(&output_testname(testfile))\n         .with_filetype(config.stage_id)\n }\n \n-fn maybe_dump_to_stdout(config: config, out: ~str, err: ~str) {\n+fn maybe_dump_to_stdout(config: &config, out: &str, err: &str) {\n     if config.verbose {\n         let sep1 = fmt!(\"------%s------------------------------\", ~\"stdout\");\n         let sep2 = fmt!(\"------%s------------------------------\", ~\"stderr\");\n@@ -718,7 +705,7 @@ fn error(err: ~str) { io::stdout().write_line(fmt!(\"\\nerror: %s\", err)); }\n \n fn fatal(err: ~str) -> ! { error(err); fail!(); }\n \n-fn fatal_ProcRes(err: ~str, ProcRes: ProcRes) -> ! {\n+fn fatal_ProcRes(err: ~str, ProcRes: &ProcRes) -> ! {\n     let msg =\n         fmt!(\"\\n\\\n error: %s\\n\\\n@@ -737,21 +724,20 @@ stderr:\\n\\\n     fail!();\n }\n \n-fn _arm_exec_compiled_test(config: config, props: TestProps,\n+fn _arm_exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(~\"\", args.prog, args.args);\n+    let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     // get bare program string\n     let mut tvec = ~[];\n-    let tstr = args.prog;\n-    for str::each_split_char(tstr, '/') |ts| { tvec.push(ts.to_owned()) }\n+    for str::each_split_char(args.prog, '/') |ts| { tvec.push(ts.to_owned()) }\n     let prog_short = tvec.pop();\n \n     // copy to target\n-    let copy_result = procsrv::run(~\"\", config.adb_path,\n-        ~[~\"push\", args.prog, config.adb_test_dir],\n+    let copy_result = procsrv::run(\"\", config.adb_path,\n+        [~\"push\", copy args.prog, copy config.adb_test_dir],\n         ~[(~\"\",~\"\")], Some(~\"\"));\n \n     if config.verbose {\n@@ -767,7 +753,6 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     // to stdout and stderr separately but to stdout only\n     let mut newargs_out = ~[];\n     let mut newargs_err = ~[];\n-    let subargs = args.args;\n     newargs_out.push(~\"shell\");\n     newargs_err.push(~\"shell\");\n \n@@ -780,7 +765,7 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     newcmd_err.push_str(fmt!(\"LD_LIBRARY_PATH=%s %s/%s\",\n         config.adb_test_dir, config.adb_test_dir, prog_short));\n \n-    for vec::each(subargs) |tv| {\n+    for args.args.each |tv| {\n         newcmd_out.push_str(\" \");\n         newcmd_err.push_str(\" \");\n         newcmd_out.push_str(tv.to_owned());\n@@ -793,26 +778,28 @@ fn _arm_exec_compiled_test(config: config, props: TestProps,\n     newargs_out.push(newcmd_out);\n     newargs_err.push(newcmd_err);\n \n-    let exe_result_out = procsrv::run(~\"\", config.adb_path,\n-        newargs_out, ~[(~\"\",~\"\")], Some(~\"\"));\n-    let exe_result_err = procsrv::run(~\"\", config.adb_path,\n-        newargs_err, ~[(~\"\",~\"\")], Some(~\"\"));\n+    let procsrv::Result{ out: out_out, err: _out_err, status: out_status } =\n+            procsrv::run(~\"\", config.adb_path, newargs_out, ~[(~\"\",~\"\")],\n+                         Some(~\"\"));\n+    let procsrv::Result{ out: err_out, err: _err_err, status: _err_status } =\n+            procsrv::run(~\"\", config.adb_path, newargs_err, ~[(~\"\",~\"\")],\n+                         Some(~\"\"));\n \n-    dump_output(config, testfile, exe_result_out.out, exe_result_err.out);\n+    dump_output(config, testfile, out_out, err_out);\n \n-    match exe_result_err.out {\n-        ~\"\" => ProcRes {status: exe_result_out.status, stdout: exe_result_out.out,\n-            stderr: exe_result_err.out, cmdline: cmdline },\n-        _   => ProcRes {status: 101, stdout: exe_result_out.out,\n-            stderr: exe_result_err.out, cmdline: cmdline }\n+    match err_out {\n+        ~\"\" => ProcRes {status: out_status, stdout: out_out,\n+            stderr: err_out, cmdline: cmdline },\n+        _   => ProcRes {status: 101, stdout: out_out,\n+            stderr: err_out, cmdline: cmdline }\n     }\n }\n \n-fn _dummy_exec_compiled_test(config: config, props: TestProps,\n+fn _dummy_exec_compiled_test(config: &config, props: &TestProps,\n                       testfile: &Path) -> ProcRes {\n \n     let args = make_run_args(config, props, testfile);\n-    let cmdline = make_cmdline(~\"\", args.prog, args.args);\n+    let cmdline = make_cmdline(\"\", args.prog, args.args);\n \n     match config.mode {\n         mode_run_fail => ProcRes {status: 101, stdout: ~\"\",\n@@ -822,15 +809,15 @@ fn _dummy_exec_compiled_test(config: config, props: TestProps,\n     }\n }\n \n-fn _arm_push_aux_shared_library(config: config, testfile: &Path) {\n+fn _arm_push_aux_shared_library(config: &config, testfile: &Path) {\n     let tstr = aux_output_dir_name(config, testfile).to_str();\n \n     for os::list_dir_path(&Path(tstr)).each |file| {\n \n         if (file.filetype() == Some(~\".so\")) {\n \n             let copy_result = procsrv::run(~\"\", config.adb_path,\n-                ~[~\"push\", file.to_str(), config.adb_test_dir],\n+                ~[~\"push\", file.to_str(), copy config.adb_test_dir],\n                 ~[(~\"\",~\"\")], Some(~\"\"));\n \n             if config.verbose {"}, {"sha": "05e5d902a47c9834399df5c994401a62f134e61b", "filename": "src/compiletest/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2951527528b39dbf47c02b3d329129d677ddcdfd/src%2Fcompiletest%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Futil.rs?ref=2951527528b39dbf47c02b3d329129d677ddcdfd", "patch": "@@ -12,15 +12,15 @@ use common::config;\n \n use core::os::getenv;\n \n-pub fn make_new_path(path: ~str) -> ~str {\n+pub fn make_new_path(path: &str) -> ~str {\n \n     // Windows just uses PATH as the library search path, so we have to\n     // maintain the current value while adding our own\n     match getenv(lib_path_env_var()) {\n       Some(curr) => {\n         fmt!(\"%s%s%s\", path, path_div(), curr)\n       }\n-      None => path\n+      None => path.to_str()\n     }\n }\n \n@@ -42,7 +42,7 @@ pub fn path_div() -> ~str { ~\":\" }\n #[cfg(target_os = \"win32\")]\n pub fn path_div() -> ~str { ~\";\" }\n \n-pub fn logv(config: config, s: ~str) {\n+pub fn logv(config: &config, s: ~str) {\n     debug!(\"%s\", s);\n     if config.verbose { io::println(s); }\n }"}]}