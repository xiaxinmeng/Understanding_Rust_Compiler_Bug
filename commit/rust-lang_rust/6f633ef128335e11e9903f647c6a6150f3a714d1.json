{"sha": "6f633ef128335e11e9903f647c6a6150f3a714d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmNjMzZWYxMjgzMzVlMTFlOTkwM2Y2NDdjNmE2MTUwZjNhNzE0ZDE=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "arielb1@mail.tau.ac.il", "date": "2016-02-11T16:30:34Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-02-19T23:54:58Z"}, "message": "tuple arguments to overloaded calls\n\nalso fix translation of \"rust-call\" functions, although that could use\nmore optimizations", "tree": {"sha": "2d9c96d8a6757bbfefaf451901fab5e4f6c543a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d9c96d8a6757bbfefaf451901fab5e4f6c543a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f633ef128335e11e9903f647c6a6150f3a714d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f633ef128335e11e9903f647c6a6150f3a714d1", "html_url": "https://github.com/rust-lang/rust/commit/6f633ef128335e11e9903f647c6a6150f3a714d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f633ef128335e11e9903f647c6a6150f3a714d1/comments", "author": null, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7cbbc374c8549620221ad6c4e6e3c300efa5b1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b7cbbc374c8549620221ad6c4e6e3c300efa5b1c", "html_url": "https://github.com/rust-lang/rust/commit/b7cbbc374c8549620221ad6c4e6e3c300efa5b1c"}], "stats": {"total": 222, "additions": 179, "deletions": 43}, "files": [{"sha": "769dbe0ab5162472ba5e162b7689512708e39084", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=6f633ef128335e11e9903f647c6a6150f3a714d1", "patch": "@@ -54,14 +54,35 @@ impl<'tcx> Mirror<'tcx> for &'tcx hir::Expr {\n                     // Find the actual method implementation being called and\n                     // build the appropriate UFCS call expression with the\n                     // callee-object as self parameter.\n+\n+                    // rewrite f(u, v) into FnOnce::call_once(f, (u, v))\n+\n                     let method = method_callee(cx, self, ty::MethodCall::expr(self.id));\n-                    let mut argrefs = vec![fun.to_ref()];\n-                    argrefs.extend(args.iter().map(|a| a.to_ref()));\n+\n+                    let sig = match method.ty.sty {\n+                        ty::TyBareFn(_, fn_ty) => &fn_ty.sig,\n+                        _ => cx.tcx.sess.span_bug(self.span, \"type of method is not an fn\")\n+                    };\n+\n+                    let sig = cx.tcx.no_late_bound_regions(sig).unwrap_or_else(|| {\n+                        cx.tcx.sess.span_bug(self.span, \"method call has late-bound regions\")\n+                    });\n+\n+                    assert_eq!(sig.inputs.len(), 2);\n+\n+                    let tupled_args = Expr {\n+                        ty: sig.inputs[1],\n+                        temp_lifetime: cx.tcx.region_maps.temporary_scope(self.id),\n+                        span: self.span,\n+                        kind: ExprKind::Tuple {\n+                            fields: args.iter().map(ToRef::to_ref).collect()\n+                        }\n+                    };\n \n                     ExprKind::Call {\n                         ty: method.ty,\n                         fun: method.to_ref(),\n-                        args: argrefs,\n+                        args: vec![fun.to_ref(), tupled_args.to_ref()]\n                     }\n                 } else {\n                     let adt_data = if let hir::ExprPath(..) = fun.node {"}, {"sha": "609f1dee98aadb2e3eb9593a56b08597e2a686d2", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 51, "deletions": 10, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=6f633ef128335e11e9903f647c6a6150f3a714d1", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use llvm::{BasicBlockRef, ValueRef, OperandBundleDef};\n-use rustc::middle::ty;\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr as mir;\n use syntax::abi::Abi;\n use trans::adt;\n@@ -26,8 +26,55 @@ use trans::type_::Type;\n \n use super::MirContext;\n use super::operand::OperandValue::{FatPtr, Immediate, Ref};\n+use super::operand::OperandRef;\n+\n+#[derive(PartialEq, Eq)]\n+enum AbiStyle {\n+    Foreign,\n+    RustCall,\n+    Rust\n+}\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    fn abi_style(&self, fn_ty: Ty<'tcx>) -> AbiStyle {\n+        if let ty::TyBareFn(_, ref f) = fn_ty.sty {\n+            // We do not translate intrinsics here (they shouldn\u2019t be functions)\n+            assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n+\n+            match f.abi {\n+                Abi::Rust => AbiStyle::Rust,\n+                Abi::RustCall => AbiStyle::RustCall,\n+                _ => AbiStyle::Foreign\n+            }\n+        } else {\n+            unreachable!()\n+        }\n+    }\n+\n+    fn arg_operands(&mut self,\n+                    bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                    abi_style: AbiStyle,\n+                    args: &[mir::Operand<'tcx>])\n+                    -> Vec<OperandRef<'tcx>>\n+    {\n+        match abi_style {\n+            AbiStyle::Foreign | AbiStyle::Rust => {\n+                args.iter().map(|arg| self.trans_operand(bcx, arg)).collect()\n+            }\n+            AbiStyle::RustCall => match args.split_last() {\n+                None => vec![],\n+                Some((tup, self_ty)) => {\n+                    // we can reorder safely because of MIR\n+                    let untupled_args = self.trans_operand_untupled(bcx, tup);\n+                    self_ty\n+                        .iter().map(|arg| self.trans_operand(bcx, arg))\n+                        .chain(untupled_args.into_iter())\n+                        .collect()\n+                }\n+            }\n+        }\n+    }\n+\n     pub fn trans_block(&mut self, bb: mir::BasicBlock) {\n         debug!(\"trans_block({:?})\", bb);\n \n@@ -159,13 +206,8 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let mut arg_tys = Vec::new();\n \n                 // Foreign-ABI functions are translated differently\n-                let is_foreign = if let ty::TyBareFn(_, ref f) = callee.ty.sty {\n-                    // We do not translate intrinsics here (they shouldn\u2019t be functions)\n-                    assert!(f.abi != Abi::RustIntrinsic && f.abi != Abi::PlatformIntrinsic);\n-                    f.abi != Abi::Rust && f.abi != Abi::RustCall\n-                } else {\n-                    false\n-                };\n+                let abi_style = self.abi_style(callee.ty);\n+                let is_foreign = abi_style == AbiStyle::Foreign;\n \n                 // Prepare the return value destination\n                 let (ret_dest_ty, must_copy_dest) = if let Some((ref d, _)) = *destination {\n@@ -182,8 +224,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 };\n \n                 // Process the rest of the args.\n-                for arg in args {\n-                    let operand = self.trans_operand(&bcx, arg);\n+                for operand in self.arg_operands(&bcx, abi_style, args) {\n                     match operand.val {\n                         Ref(llval) | Immediate(llval) => llargs.push(llval),\n                         FatPtr(b, e) => {"}, {"sha": "2183348c8b5eabafc421597c6a547c6e5a2b4a02", "filename": "src/librustc_trans/trans/mir/operand.rs", "status": "modified", "additions": 73, "deletions": 25, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Foperand.rs?ref=6f633ef128335e11e9903f647c6a6150f3a714d1", "patch": "@@ -9,13 +9,16 @@\n // except according to those terms.\n \n use llvm::ValueRef;\n-use rustc::middle::ty::{Ty, TypeFoldable};\n+use rustc::middle::ty::{self, Ty};\n use rustc::mir::repr as mir;\n+use trans::adt;\n use trans::base;\n use trans::common::{self, Block, BlockAndBuilder};\n use trans::datum;\n+use trans::Disr;\n \n use super::{MirContext, TempRef};\n+use super::lvalue::LvalueRef;\n \n /// The representation of a Rust value. The enum variant is in fact\n /// uniquely determined by the value's type, but is kept as a\n@@ -90,6 +93,32 @@ impl<'tcx> OperandRef<'tcx> {\n }\n \n impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n+    pub fn trans_load(&mut self,\n+                      bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                      llval: ValueRef,\n+                      ty: Ty<'tcx>)\n+                      -> OperandRef<'tcx>\n+    {\n+        debug!(\"trans_load: {} @ {:?}\", bcx.val_to_string(llval), ty);\n+\n+        let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n+            datum::ByValue => {\n+                bcx.with_block(|bcx| {\n+                    OperandValue::Immediate(base::load_ty(bcx, llval, ty))\n+                })\n+            }\n+            datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n+                let (lldata, llextra) = bcx.with_block(|bcx| {\n+                    base::load_fat_ptr(bcx, llval, ty)\n+                });\n+                OperandValue::FatPtr(lldata, llextra)\n+            }\n+            datum::ByRef => OperandValue::Ref(llval)\n+        };\n+\n+        OperandRef { val: val, ty: ty }\n+    }\n+\n     pub fn trans_operand(&mut self,\n                          bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                          operand: &mir::Operand<'tcx>)\n@@ -120,30 +149,7 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 // out from their home\n                 let tr_lvalue = self.trans_lvalue(bcx, lvalue);\n                 let ty = tr_lvalue.ty.to_ty(bcx.tcx());\n-                debug!(\"trans_operand: tr_lvalue={} @ {:?}\",\n-                       bcx.val_to_string(tr_lvalue.llval),\n-                       ty);\n-                let val = match datum::appropriate_rvalue_mode(bcx.ccx(), ty) {\n-                    datum::ByValue => {\n-                        bcx.with_block(|bcx| {\n-                            OperandValue::Immediate(base::load_ty(bcx, tr_lvalue.llval, ty))\n-                        })\n-                    }\n-                    datum::ByRef if common::type_is_fat_ptr(bcx.tcx(), ty) => {\n-                        let (lldata, llextra) = bcx.with_block(|bcx| {\n-                            base::load_fat_ptr(bcx, tr_lvalue.llval, ty)\n-                        });\n-                        OperandValue::FatPtr(lldata, llextra)\n-                    }\n-                    datum::ByRef => OperandValue::Ref(tr_lvalue.llval)\n-                };\n-\n-                assert!(!ty.has_erasable_regions());\n-\n-                OperandRef {\n-                    val: val,\n-                    ty: ty\n-                }\n+                self.trans_load(bcx, tr_lvalue.llval, ty)\n             }\n \n             mir::Operand::Constant(ref constant) => {\n@@ -197,4 +203,46 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             }\n         }\n     }\n+\n+    pub fn trans_operand_untupled(&mut self,\n+                                  bcx: &BlockAndBuilder<'bcx, 'tcx>,\n+                                  operand: &mir::Operand<'tcx>)\n+                                  -> Vec<OperandRef<'tcx>>\n+    {\n+        // FIXME: consider having some optimization to avoid tupling/untupling\n+        // (and storing/loading in the case of immediates)\n+\n+        // avoid trans_operand for pointless copying\n+        let lv = match *operand {\n+            mir::Operand::Consume(ref lvalue) => self.trans_lvalue(bcx, lvalue),\n+            mir::Operand::Constant(ref constant) => {\n+                // FIXME: consider being less pessimized\n+                if constant.ty.is_nil() {\n+                    return vec![];\n+                }\n+\n+                let ty = bcx.monomorphize(&constant.ty);\n+                let lv = LvalueRef::alloca(bcx, ty, \"__untuple_alloca\");\n+                let constant = self.trans_constant(bcx, constant);\n+                self.store_operand(bcx, lv.llval, constant);\n+                lv\n+           }\n+        };\n+\n+        let lv_ty = lv.ty.to_ty(bcx.tcx());\n+        let result_types = match lv_ty.sty {\n+            ty::TyTuple(ref tys) => tys,\n+            _ => bcx.tcx().sess.span_bug(\n+                self.mir.span,\n+                &format!(\"bad final argument to \\\"rust-call\\\" fn {:?}\", lv_ty))\n+        };\n+\n+        let base_repr = adt::represent_type(bcx.ccx(), lv_ty);\n+        let base = adt::MaybeSizedValue::sized(lv.llval);\n+        result_types.iter().enumerate().map(|(n, &ty)| {\n+            self.trans_load(bcx, bcx.with_block(|bcx| {\n+                adt::trans_field_ptr(bcx, &base_repr, base, Disr(0), n)\n+            }), ty)\n+        }).collect()\n+    }\n }"}, {"sha": "b8b7ecbf03cd6e834817eee2bd01d4366ebf1dd4", "filename": "src/test/run-pass/mir_trans_calls.rs", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f633ef128335e11e9903f647c6a6150f3a714d1/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_trans_calls.rs?ref=6f633ef128335e11e9903f647c6a6150f3a714d1", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![feature(rustc_attrs)]\n+#![feature(rustc_attrs, unboxed_closures, fn_traits)]\n \n #[rustc_mir]\n fn test1(a: isize, b: (i32, i32), c: &[i32]) -> (isize, (i32, i32), &[i32]) {\n@@ -117,6 +117,27 @@ fn test_fn_impl(f: &&Fn(i32, i32) -> i32, x: i32, y: i32) -> i32 {\n     f(x, y)\n }\n \n+#[rustc_mir]\n+fn test_fn_direct_call<F>(f: &F, x: i32, y: i32) -> i32\n+    where F: Fn(i32, i32) -> i32\n+{\n+    f.call((x, y))\n+}\n+\n+#[rustc_mir]\n+fn test_fn_const_call<F>(f: &F) -> i32\n+    where F: Fn(i32, i32) -> i32\n+{\n+    f.call((100, -1))\n+}\n+\n+#[rustc_mir]\n+fn test_fn_nil_call<F>(f: &F) -> i32\n+    where F: Fn() -> i32\n+{\n+    f()\n+}\n+\n fn main() {\n     assert_eq!(test1(1, (2, 3), &[4, 5, 6]), (1, (2, 3), &[4, 5, 6][..]));\n     assert_eq!(test2(98), 98);\n@@ -128,9 +149,14 @@ fn main() {\n     assert_eq!(test8(), 2);\n     assert_eq!(test9(), 41 + 42 * 43);\n \n-    let closure = |x: i32, y: i32| { x + y };\n-    assert_eq!(test_closure(&closure, 100, 1), 101);\n+    let r = 3;\n+    let closure = |x: i32, y: i32| { r*(x + (y*2)) };\n+    assert_eq!(test_fn_const_call(&closure), 294);\n+    assert_eq!(test_closure(&closure, 100, 1), 306);\n     let function_object = &closure as &Fn(i32, i32) -> i32;\n-    assert_eq!(test_fn_object(function_object, 100, 2), 102);\n-    assert_eq!(test_fn_impl(&function_object, 100, 3), 103);\n+    assert_eq!(test_fn_object(function_object, 100, 2), 312);\n+    assert_eq!(test_fn_impl(&function_object, 100, 3), 318);\n+    assert_eq!(test_fn_direct_call(&closure, 100, 4), 324);\n+\n+    assert_eq!(test_fn_nil_call(&(|| 42)), 42);\n }"}]}