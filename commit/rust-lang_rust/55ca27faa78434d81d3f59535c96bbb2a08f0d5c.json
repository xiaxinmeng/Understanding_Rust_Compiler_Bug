{"sha": "55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU1Y2EyN2ZhYTc4NDM0ZDgxZDNmNTk1MzVjOTZiYmIyYTA4ZjBkNWM=", "commit": {"author": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-02-06T21:38:16Z"}, "committer": {"name": "The8472", "email": "git@infinite-source.de", "date": "2021-02-07T08:12:21Z"}, "message": "use rwlock for accessing ENV", "tree": {"sha": "6d1c3b5d95255346ad63ef4cd2c8c405eb26a85d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6d1c3b5d95255346ad63ef4cd2c8c405eb26a85d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "html_url": "https://github.com/rust-lang/rust/commit/55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/comments", "author": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "committer": {"login": "the8472", "id": 1065730, "node_id": "MDQ6VXNlcjEwNjU3MzA=", "avatar_url": "https://avatars.githubusercontent.com/u/1065730?v=4", "gravatar_id": "", "url": "https://api.github.com/users/the8472", "html_url": "https://github.com/the8472", "followers_url": "https://api.github.com/users/the8472/followers", "following_url": "https://api.github.com/users/the8472/following{/other_user}", "gists_url": "https://api.github.com/users/the8472/gists{/gist_id}", "starred_url": "https://api.github.com/users/the8472/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/the8472/subscriptions", "organizations_url": "https://api.github.com/users/the8472/orgs", "repos_url": "https://api.github.com/users/the8472/repos", "events_url": "https://api.github.com/users/the8472/events{/privacy}", "received_events_url": "https://api.github.com/users/the8472/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfba499271ba53190a1d3647ff8f7202ec9ed6f5", "html_url": "https://github.com/rust-lang/rust/commit/cfba499271ba53190a1d3647ff8f7202ec9ed6f5"}], "stats": {"total": 66, "additions": 55, "deletions": 11}, "files": [{"sha": "33921180cb17c4970a9a04abe0e1933364967864", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "patch": "@@ -22,6 +22,7 @@ use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n+use crate::sys_common::rwlock::{RWLock, RWLockGuard};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -493,17 +494,16 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     &mut environ\n }\n \n-pub unsafe fn env_lock() -> StaticMutexGuard {\n-    // It is UB to attempt to acquire this mutex reentrantly!\n-    static ENV_LOCK: StaticMutex = StaticMutex::new();\n-    ENV_LOCK.lock()\n+pub unsafe fn env_rwlock(readonly: bool) -> RWLockGuard {\n+    static ENV_LOCK: RWLock = RWLock::new();\n+    if readonly { ENV_LOCK.read_with_guard() } else { ENV_LOCK.write_with_guard() }\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_rwlock(true);\n         let mut environ = *environ();\n         let mut result = Vec::new();\n         if !environ.is_null() {\n@@ -540,7 +540,7 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_rwlock(true);\n         let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n         let ret = if s.is_null() {\n             None\n@@ -556,7 +556,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_rwlock(false);\n         cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n     }\n }\n@@ -565,7 +565,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        let _guard = env_lock();\n+        let _guard = env_rwlock(false);\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n     }\n }"}, {"sha": "0e4e66389fb3b1e353d7b9717f1830e049e4beef", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "patch": "@@ -47,7 +47,7 @@ impl Command {\n         // a lock any more because the parent won't do anything and the child is\n         // in its own process.\n         let result = unsafe {\n-            let _env_lock = sys::os::env_lock();\n+            let _env_lock = sys::os::env_rwlock(true);\n             cvt(libc::fork())?\n         };\n \n@@ -124,7 +124,7 @@ impl Command {\n                     // Similar to when forking, we want to ensure that access to\n                     // the environment is synchronized, so make sure to grab the\n                     // environment lock before we try to exec.\n-                    let _lock = sys::os::env_lock();\n+                    let _lock = sys::os::env_rwlock(true);\n \n                     let Err(e) = self.do_exec(theirs, envp.as_ref());\n                     e\n@@ -404,7 +404,7 @@ impl Command {\n             cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource\n-            let _env_lock = sys::os::env_lock();\n+            let _env_lock = sys::os::env_rwlock(true);\n             let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::os::environ() as *const _);\n             cvt_nz(libc::posix_spawnp(\n                 &mut p.pid,"}, {"sha": "1f2765ffbcca615a760db76ea4c185a60f7343ff", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55ca27faa78434d81d3f59535c96bbb2a08f0d5c/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=55ca27faa78434d81d3f59535c96bbb2a08f0d5c", "patch": "@@ -1,5 +1,23 @@\n use crate::sys::rwlock as imp;\n \n+enum GuardType {\n+    Read,\n+    Write,\n+}\n+\n+pub struct RWLockGuard(&'static RWLock, GuardType);\n+\n+impl Drop for RWLockGuard {\n+    fn drop(&mut self) {\n+        unsafe {\n+            match &self.1 {\n+                GuardType::Read => self.0.read_unlock(),\n+                GuardType::Write => self.0.write_unlock(),\n+            }\n+        }\n+    }\n+}\n+\n /// An OS-based reader-writer lock.\n ///\n /// This structure is entirely unsafe and serves as the lowest layer of a\n@@ -26,6 +44,19 @@ impl RWLock {\n         self.0.read()\n     }\n \n+    /// Acquires shared access to the underlying lock, blocking the current\n+    /// thread to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous method call.\n+    #[inline]\n+    pub unsafe fn read_with_guard(&'static self) -> RWLockGuard {\n+        self.read();\n+        RWLockGuard(&self, GuardType::Read)\n+    }\n+\n     /// Attempts to acquire shared access to this lock, returning whether it\n     /// succeeded or not.\n     ///\n@@ -48,6 +79,19 @@ impl RWLock {\n         self.0.write()\n     }\n \n+    /// Acquires write access to the underlying lock, blocking the current thread\n+    /// to do so.\n+    ///\n+    /// The lock is automatically unlocked when the returned guard is dropped.\n+    ///\n+    /// Behavior is undefined if the rwlock has been moved between this and any\n+    /// previous method call.\n+    #[inline]\n+    pub unsafe fn write_with_guard(&'static self) -> RWLockGuard {\n+        self.write();\n+        RWLockGuard(&self, GuardType::Write)\n+    }\n+\n     /// Attempts to acquire exclusive access to this lock, returning whether it\n     /// succeeded or not.\n     ///"}]}