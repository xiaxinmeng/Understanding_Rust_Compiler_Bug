{"sha": "b324cbf2821c7851829522a43ea07ca3229d0492", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIzMjRjYmYyODIxYzc4NTE4Mjk1MjJhNDNlYTA3Y2EzMjI5ZDA0OTI=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-06T07:29:17Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-07-06T07:29:17Z"}, "message": "Merge remote-tracking branch 'origin/master' into rustup", "tree": {"sha": "e8f3b8abe81ad327700a8b59d597f0517e3bca27", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8f3b8abe81ad327700a8b59d597f0517e3bca27"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b324cbf2821c7851829522a43ea07ca3229d0492", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b324cbf2821c7851829522a43ea07ca3229d0492", "html_url": "https://github.com/rust-lang/rust/commit/b324cbf2821c7851829522a43ea07ca3229d0492", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b324cbf2821c7851829522a43ea07ca3229d0492/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e82693fa23caea857ba83fa0963154627b5fe12c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e82693fa23caea857ba83fa0963154627b5fe12c", "html_url": "https://github.com/rust-lang/rust/commit/e82693fa23caea857ba83fa0963154627b5fe12c"}, {"sha": "ad837079e1f18d00090d7ac1c58fda7b3c49a822", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad837079e1f18d00090d7ac1c58fda7b3c49a822", "html_url": "https://github.com/rust-lang/rust/commit/ad837079e1f18d00090d7ac1c58fda7b3c49a822"}], "stats": {"total": 589, "additions": 367, "deletions": 222}, "files": [{"sha": "6313b56c57848efce05faa7aa7e901ccfc2886ea", "filename": ".gitattributes", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/.gitattributes", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/.gitattributes", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitattributes?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -0,0 +1 @@\n+* text=auto eol=lf"}, {"sha": "69c66db52147ed4f6d56f8610537501c4c9c97cb", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -279,6 +279,8 @@ Several `-Z` flags are relevant for Miri:\n * `-Zalways-encode-mir` makes rustc dump MIR even for completely monomorphic\n   functions.  This is needed so that Miri can execute such functions, so Miri\n   sets this flag per default.\n+* `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n+  enables this per default because it is needed for validation.\n \n Moreover, Miri recognizes some environment variables:\n \n@@ -327,6 +329,7 @@ Miri has already found a number of bugs in the Rust standard library and beyond,\n Definite bugs found:\n \n * [`Debug for vec_deque::Iter` accessing uninitialized memory](https://github.com/rust-lang/rust/issues/53566)\n+* [`Vec::into_iter` doing an unaligned ZST read](https://github.com/rust-lang/rust/pull/53804)\n * [`From<&[T]> for Rc` creating a not sufficiently aligned reference](https://github.com/rust-lang/rust/issues/54908)\n * [`BTreeMap` creating a shared reference pointing to a too small allocation](https://github.com/rust-lang/rust/issues/54957)\n * [`Vec::append` creating a dangling reference](https://github.com/rust-lang/rust/pull/61082)"}, {"sha": "cbd8e335771e35cb73fdfb2d643b913ccb9e980b", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1 +1 @@\n-7e08576e4276a97b523c25bfd196d419c39c7b87\n+24a9bcbb7cb0d8bdc11b8252a9c13f7562c7e4ca"}, {"sha": "6132c502531fa5c919b49083d8d39fe03f19b254", "filename": "src/eval.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -10,7 +10,7 @@ use rustc::hir::def_id::DefId;\n use rustc::mir;\n \n use crate::{\n-    InterpResult, InterpError, InterpretCx, StackPopCleanup, struct_error,\n+    InterpResult, InterpError, InterpCx, StackPopCleanup, struct_error,\n     Scalar, Tag, Pointer,\n     MemoryExtra, MiriMemoryKind, Evaluator, TlsEvalContextExt,\n };\n@@ -30,14 +30,23 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     tcx: TyCtxt<'tcx>,\n     main_id: DefId,\n     config: MiriConfig,\n-) -> InterpResult<'tcx, InterpretCx<'mir, 'tcx, Evaluator<'tcx>>> {\n-    let mut ecx = InterpretCx::new(\n+) -> InterpResult<'tcx, InterpCx<'mir, 'tcx, Evaluator<'tcx>>> {\n+\n+    // FIXME(https://github.com/rust-lang/miri/pull/803): no validation on Windows.\n+    let target_os = tcx.sess.target.target.target_os.to_lowercase();\n+    let validate = if target_os == \"windows\" {\n+        false\n+    } else {\n+        config.validate\n+    };\n+\n+    let mut ecx = InterpCx::new(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n-        Evaluator::new(config.validate),\n-        MemoryExtra::with_rng(config.seed.map(StdRng::seed_from_u64)),\n+        Evaluator::new(),\n+        MemoryExtra::new(config.seed.map(StdRng::seed_from_u64), validate),\n     );\n-    \n+\n     let main_instance = ty::Instance::mono(ecx.tcx.tcx, main_id);\n     let main_mir = ecx.load_mir(main_instance.def)?;\n "}, {"sha": "3503af43690f996fc3e02ba57dfe51840bac2153", "filename": "src/helpers.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -43,6 +43,28 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             })\n     }\n \n+    /// Write a 0 of the appropriate size to `dest`.\n+    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+        self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n+    }\n+\n+    /// Test if this immediate equals 0.\n+    fn is_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, bool> {\n+        let this = self.eval_context_ref();\n+        let null = Scalar::from_int(0, this.memory().pointer_size());\n+        this.ptr_eq(val, null)\n+    }\n+\n+    /// Turn a Scalar into an Option<NonNullScalar>\n+    fn test_null(&self, val: Scalar<Tag>) -> InterpResult<'tcx, Option<Scalar<Tag>>> {\n+        let this = self.eval_context_ref();\n+        Ok(if this.is_null(val)? {\n+            None\n+        } else {\n+            Some(val)\n+        })\n+    }\n+\n     /// Visits the memory covered by `place`, sensitive to freezing: the 3rd parameter\n     /// will be true if this is frozen, false if this is in an `UnsafeCell`.\n     fn visit_freeze_sensitive(\n@@ -58,6 +80,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             .map(|(size, _)| size)\n             .unwrap_or_else(|| place.layout.size)\n         );\n+        assert!(size.bytes() > 0);\n         // Store how far we proceeded into the place so far. Everything to the left of\n         // this offset has already been handled, in the sense that the frozen parts\n         // have had `action` called on them."}, {"sha": "5797895c54f809b888ad9615bd2f4269794cec7e", "filename": "src/intptrcast.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -4,7 +4,8 @@ use std::cmp::max;\n \n use rand::Rng;\n \n-use rustc_mir::interpret::{AllocId, Pointer, InterpResult, Memory, AllocCheck};\n+use rustc::ty::layout::HasDataLayout;\n+use rustc_mir::interpret::{AllocId, Pointer, InterpResult, Memory, AllocCheck, PointerArithmetic};\n use rustc_target::abi::Size;\n \n use crate::{Evaluator, Tag, STACK_ADDR};\n@@ -75,7 +76,9 @@ impl<'mir, 'tcx> GlobalState {\n         let mut global_state = memory.extra.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n-        let (size, align) = memory.get_size_and_align(ptr.alloc_id, AllocCheck::Live)?;\n+        // There is nothing wrong with a raw pointer being cast to an integer only after\n+        // it became dangling.  Hence `MaybeDead`.\n+        let (size, align) = memory.get_size_and_align(ptr.alloc_id, AllocCheck::MaybeDead)?;\n \n         let base_addr = match global_state.base_addr.entry(ptr.alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n@@ -107,7 +110,9 @@ impl<'mir, 'tcx> GlobalState {\n         };\n \n         debug_assert_eq!(base_addr % align.bytes(), 0); // sanity check\n-        Ok(base_addr + ptr.offset.bytes())\n+        // Add offset with the right kind of pointer-overflowing arithmetic.\n+        let dl = memory.data_layout();\n+        Ok(dl.overflowing_offset(base_addr, ptr.offset.bytes()).0)\n     }\n \n     /// Shifts `addr` to make it aligned with `align` by rounding `addr` to the smallest multiple"}, {"sha": "31e707077769c6f2b92525fa51e069ab60fa8d35", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -15,7 +15,6 @@ extern crate rustc_target;\n mod shims;\n mod operator;\n mod helpers;\n-mod tls;\n mod range_map;\n mod mono_hash_map;\n mod stacked_borrows;\n@@ -28,10 +27,11 @@ pub use rustc_mir::interpret::*;\n // Resolve ambiguity.\n pub use rustc_mir::interpret::{self, AllocMap, PlaceTy};\n \n+pub use crate::shims::{EvalContextExt as ShimsEvalContextExt};\n pub use crate::shims::foreign_items::EvalContextExt as ForeignItemsEvalContextExt;\n pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n+pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n-pub use crate::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};\n pub use crate::mono_hash_map::MonoHashMap;"}, {"sha": "0875331131bd34dd9ccdf0c42851b88dd0fbf36f", "filename": "src/machine.rs", "status": "modified", "additions": 66, "deletions": 38, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -28,6 +28,8 @@ pub enum MiriMemoryKind {\n     Rust,\n     /// `malloc` memory.\n     C,\n+    /// Windows `HeapAlloc` memory.\n+    WinHeap,\n     /// Part of env var emulation.\n     Env,\n     /// Statics.\n@@ -44,25 +46,31 @@ impl Into<MemoryKind<MiriMemoryKind>> for MiriMemoryKind {\n /// Extra per-allocation data\n #[derive(Debug, Clone)]\n pub struct AllocExtra {\n-    pub stacked_borrows: stacked_borrows::AllocExtra,\n+    /// Stacked Borrows state is only added if validation is enabled.\n+    pub stacked_borrows: Option<stacked_borrows::AllocExtra>,\n }\n \n /// Extra global memory data\n #[derive(Clone, Debug)]\n pub struct MemoryExtra {\n     pub stacked_borrows: stacked_borrows::MemoryExtra,\n     pub intptrcast: intptrcast::MemoryExtra,\n+\n     /// The random number generator to use if Miri is running in non-deterministic mode and to\n     /// enable intptrcast\n-    pub(crate) rng: Option<RefCell<StdRng>>\n+    pub(crate) rng: Option<RefCell<StdRng>>,\n+\n+    /// Whether to enforce the validity invariant.\n+    pub(crate) validate: bool,\n }\n \n impl MemoryExtra {\n-    pub fn with_rng(rng: Option<StdRng>) -> Self {\n+    pub fn new(rng: Option<StdRng>, validate: bool) -> Self {\n         MemoryExtra {\n             stacked_borrows: Default::default(),\n             intptrcast: Default::default(),\n             rng: rng.map(RefCell::new),\n+            validate,\n         }\n     }\n }\n@@ -85,27 +93,23 @@ pub struct Evaluator<'tcx> {\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n-\n-    /// Whether to enforce the validity invariant.\n-    pub(crate) validate: bool,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n-    pub(crate) fn new(validate: bool) -> Self {\n+    pub(crate) fn new() -> Self {\n         Evaluator {\n             env_vars: HashMap::default(),\n             argc: None,\n             argv: None,\n             cmd_line: None,\n             last_error: 0,\n             tls: TlsData::default(),\n-            validate,\n         }\n     }\n }\n \n-/// A rustc InterpretCx for Miri.\n-pub type MiriEvalContext<'mir, 'tcx> = InterpretCx<'mir, 'tcx, Evaluator<'tcx>>;\n+/// A rustc InterpCx for Miri.\n+pub type MiriEvalContext<'mir, 'tcx> = InterpCx<'mir, 'tcx, Evaluator<'tcx>>;\n \n /// A little trait that's useful to be inherited by extension traits.\n pub trait MiriEvalContextExt<'mir, 'tcx> {\n@@ -137,14 +141,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     const STATIC_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Static);\n \n     #[inline(always)]\n-    fn enforce_validity(ecx: &InterpretCx<'mir, 'tcx, Self>) -> bool {\n-        ecx.machine.validate\n+    fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n+        ecx.memory().extra.validate\n     }\n \n     /// Returns `Ok()` when the function was handled; fail otherwise.\n     #[inline(always)]\n     fn find_fn(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n@@ -155,7 +159,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn call_intrinsic(\n-        ecx: &mut rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: PlaceTy<'tcx, Tag>,\n@@ -165,7 +169,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn ptr_op(\n-        ecx: &rustc_mir::interpret::InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &rustc_mir::interpret::InterpCx<'mir, 'tcx, Self>,\n         bin_op: mir::BinOp,\n         left: ImmTy<'tcx, Tag>,\n         right: ImmTy<'tcx, Tag>,\n@@ -174,7 +178,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     fn box_alloc(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         dest: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"box_alloc for {:?}\", dest.layout.ty);\n@@ -240,7 +244,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     }\n \n     #[inline(always)]\n-    fn before_terminator(_ecx: &mut InterpretCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n+    fn before_terminator(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx>\n     {\n         // We are not interested in detecting loops.\n         Ok(())\n@@ -254,12 +258,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     ) -> (Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>, Self::PointerTag) {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         let alloc = alloc.into_owned();\n-        let (stacks, base_tag) = Stacks::new_allocation(\n-            id,\n-            Size::from_bytes(alloc.bytes.len() as u64),\n-            Rc::clone(&memory.extra.stacked_borrows),\n-            kind,\n-        );\n+        let (stacks, base_tag) = if !memory.extra.validate {\n+            (None, Tag::Untagged)\n+        } else {\n+            let (stacks, base_tag) = Stacks::new_allocation(\n+                id,\n+                Size::from_bytes(alloc.bytes.len() as u64),\n+                Rc::clone(&memory.extra.stacked_borrows),\n+                kind,\n+            );\n+            (Some(stacks), base_tag)\n+        };\n         if kind != MiriMemoryKind::Static.into() {\n             assert!(alloc.relocations.is_empty(), \"Only statics can come initialized with inner pointers\");\n             // Now we can rely on the inner pointers being static, too.\n@@ -271,7 +280,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n                 alloc.relocations.iter()\n                     // The allocations in the relocations (pointers stored *inside* this allocation)\n                     // all get the base pointer tag.\n-                    .map(|&(offset, ((), alloc))| (offset, (memory_extra.static_base_ptr(alloc), alloc)))\n+                    .map(|&(offset, ((), alloc))| {\n+                        let tag = if !memory.extra.validate {\n+                            Tag::Untagged\n+                        } else {\n+                            memory_extra.static_base_ptr(alloc)\n+                        };\n+                        (offset, (tag, alloc))\n+                    })\n                     .collect()\n             ),\n             undef_mask: alloc.undef_mask,\n@@ -289,21 +305,21 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         id: AllocId,\n         memory: &Memory<'mir, 'tcx, Self>,\n     ) -> Self::PointerTag {\n-        memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        if !memory.extra.validate {\n+            Tag::Untagged\n+        } else {\n+            memory.extra.stacked_borrows.borrow_mut().static_base_ptr(id)\n+        }\n     }\n \n     #[inline(always)]\n     fn retag(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n         place: PlaceTy<'tcx, Tag>,\n     ) -> InterpResult<'tcx> {\n-        if !ecx.tcx.sess.opts.debugging_opts.mir_emit_retag || !Self::enforce_validity(ecx) {\n-            // No tracking, or no retagging. The latter is possible because a dependency of ours\n-            // might be called with different flags than we are, so there are `Retag`\n-            // statements but we do not want to execute them.\n-            // Also, honor the whitelist in `enforce_validity` because otherwise we might retag\n-            // uninitialized data.\n+        if !Self::enforce_validity(ecx) {\n+            // No tracking.\n              Ok(())\n         } else {\n             ecx.retag(kind, place)\n@@ -312,14 +328,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n \n     #[inline(always)]\n     fn stack_push(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n     ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().new_call())\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n-        ecx: &mut InterpretCx<'mir, 'tcx, Self>,\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         extra: stacked_borrows::CallId,\n     ) -> InterpResult<'tcx> {\n         Ok(ecx.memory().extra.stacked_borrows.borrow_mut().end_call(extra))\n@@ -357,7 +373,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_read(ptr, size)\n+        if let Some(ref stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_read(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -366,7 +386,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_written(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_written(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n \n     #[inline(always)]\n@@ -375,7 +399,11 @@ impl AllocationExtra<Tag> for AllocExtra {\n         ptr: Pointer<Tag>,\n         size: Size,\n     ) -> InterpResult<'tcx> {\n-        alloc.extra.stacked_borrows.memory_deallocated(ptr, size)\n+        if let Some(ref mut stacked_borrows) = alloc.extra.stacked_borrows {\n+            stacked_borrows.memory_deallocated(ptr, size)\n+        } else {\n+            Ok(())\n+        }\n     }\n }\n \n@@ -384,7 +412,7 @@ impl MayLeak for MiriMemoryKind {\n     fn may_leak(self) -> bool {\n         use self::MiriMemoryKind::*;\n         match self {\n-            Rust | C => false,\n+            Rust | C | WinHeap => false,\n             Env | Static => true,\n         }\n     }"}, {"sha": "df60acc661ed4a51899f34bbf1274a43cf1c9656", "filename": "src/operator.rs", "status": "modified", "additions": 38, "deletions": 22, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -56,10 +56,12 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);\n \n-        // If intptrcast is enabled and the operation is not an offset\n-        // we can force the cast from pointers to integer addresses and\n-        // then dispatch to rustc binary operation method\n-        if self.memory().extra.rng.is_some() && bin_op != Offset {\n+        // If intptrcast is enabled, treat everything of integer *type* at integer *value*.\n+        if self.memory().extra.rng.is_some() && left.layout.ty.is_integral() {\n+            // This is actually an integer operation, so dispatch back to the core engine.\n+            // TODO: Once intptrcast is the default, librustc_mir should never even call us\n+            // for integer types.\n+            assert!(right.layout.ty.is_integral());\n             let l_bits = self.force_bits(left.imm.to_scalar()?, left.layout.size)?;\n             let r_bits = self.force_bits(right.imm.to_scalar()?, right.layout.size)?;\n             \n@@ -186,6 +188,13 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n         right: Scalar<Tag>,\n     ) -> InterpResult<'tcx, bool> {\n         let size = self.pointer_size();\n+        if self.memory().extra.rng.is_some() {\n+            // Just compare the integers.\n+            // TODO: Do we really want to *always* do that, even when comparing two live in-bounds pointers?\n+            let left = self.force_bits(left, size)?;\n+            let right = self.force_bits(right, size)?;\n+            return Ok(left == right);\n+        }\n         Ok(match (left, right) {\n             (Scalar::Raw { .. }, Scalar::Raw { .. }) =>\n                 left.to_bits(size)? == right.to_bits(size)?,\n@@ -206,7 +215,7 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                     // on read hardware this can easily happen. Thus for comparisons we require\n                     // both pointers to be live.\n                     if self.pointer_inbounds(left).is_ok() && self.pointer_inbounds(right).is_ok() {\n-                        // Two in-bounds pointers in different allocations are different.\n+                        // Two in-bounds (and hence live) pointers in different allocations are different.\n                         false\n                     } else {\n                         return err!(InvalidPointerMath);\n@@ -303,7 +312,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n                 map_to_primval(left.overflowing_offset(Size::from_bytes(right as u64), self)),\n \n             BitAnd if !signed => {\n-                let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n+                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n+                    .expect(\"alloc info with MaybeDead cannot fail\")\n+                    .1.bytes();\n                 let base_mask = {\n                     // FIXME: use `interpret::truncate`, once that takes a `Size` instead of a `Layout`.\n                     let shift = 128 - self.memory().pointer_size().bits();\n@@ -337,7 +348,9 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             Rem if !signed => {\n                 // Doing modulo a divisor of the alignment is allowed.\n                 // (Intuition: modulo a divisor leaks less information.)\n-                let ptr_base_align = self.memory().get(left.alloc_id)?.align.bytes();\n+                let ptr_base_align = self.memory().get_size_and_align(left.alloc_id, AllocCheck::MaybeDead)\n+                    .expect(\"alloc info with MaybeDead cannot fail\")\n+                    .1.bytes();\n                 let right = right as u64;\n                 let ptr_size = self.memory().pointer_size();\n                 if right == 1 {\n@@ -384,21 +397,24 @@ impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n             .checked_mul(pointee_size)\n             .ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n         // Now let's see what kind of pointer this is.\n-        if let Scalar::Ptr(ptr) = ptr {\n-            // Both old and new pointer must be in-bounds of a *live* allocation.\n-            // (Of the same allocation, but that part is trivial with our representation.)\n-            self.pointer_inbounds(ptr)?;\n-            let ptr = ptr.signed_offset(offset, self)?;\n-            self.pointer_inbounds(ptr)?;\n-            Ok(Scalar::Ptr(ptr))\n-        } else {\n-            // An integer pointer. They can only be offset by 0, and we pretend there\n-            // is a little zero-sized allocation here.\n-            if offset == 0 {\n-                Ok(ptr)\n-            } else {\n-                err!(InvalidPointerMath)\n+        let ptr = if offset == 0 {\n+            match ptr {\n+                Scalar::Ptr(ptr) => ptr,\n+                Scalar::Raw { .. } => {\n+                    // Offset 0 on an integer. We accept that, pretending there is\n+                    // a little zero-sized allocation here.\n+                    return Ok(ptr);\n+                }\n             }\n-        }\n+        } else {\n+            // Offset > 0. We *require* a pointer.\n+            self.force_ptr(ptr)?\n+        };\n+        // Both old and new pointer must be in-bounds of a *live* allocation.\n+        // (Of the same allocation, but that part is trivial with our representation.)\n+        self.pointer_inbounds(ptr)?;\n+        let ptr = ptr.signed_offset(offset, self)?;\n+        self.pointer_inbounds(ptr)?;\n+        Ok(Scalar::Ptr(ptr))\n     }\n }"}, {"sha": "2fe2ecc19581aacdc1e29ae6d9b91b80e31af73d", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 83, "deletions": 105, "changes": 188, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,4 +1,3 @@\n-use rustc::ty;\n use rustc::ty::layout::{Align, LayoutOf, Size};\n use rustc::hir::def_id::DefId;\n use rustc::mir;\n@@ -11,70 +10,48 @@ use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn find_fn(\n-        &mut self,\n-        instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: Option<PlaceTy<'tcx, Tag>>,\n-        ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        let this = self.eval_context_mut();\n-        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n-\n-        // First, run the common hooks also supported by CTFE.\n-        if this.hook_fn(instance, args, dest)? {\n-            this.goto_block(ret)?;\n-            return Ok(None);\n-        }\n-        // There are some more lang items we want to hook that CTFE does not hook (yet).\n-        if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n-            // FIXME: return a real value in case the target allocation has an\n-            // alignment bigger than the one requested.\n-            let n = u128::max_value();\n-            let dest = dest.unwrap();\n-            let n = this.truncate(n, dest.layout);\n-            this.write_scalar(Scalar::from_uint(n, dest.layout.size), dest)?;\n-            this.goto_block(ret)?;\n-            return Ok(None);\n-        }\n-\n-        // Try to see if we can do something about foreign items.\n-        if this.tcx.is_foreign_item(instance.def_id()) {\n-            // An external function that we cannot find MIR for, but we can still run enough\n-            // of them to make miri viable.\n-            this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n-            // `goto_block` already handled.\n-            return Ok(None);\n-        }\n-\n-        // Otherwise, load the MIR.\n-        Ok(Some(this.load_mir(instance.def)?))\n-    }\n-\n-    /// Returns the minimum alignment for the target architecture.\n-    fn min_align(&self) -> Align {\n+    /// Returns the minimum alignment for the target architecture for allocations of the given size.\n+    fn min_align(&self, size: u64, kind: MiriMemoryKind) -> Align {\n         let this = self.eval_context_ref();\n         // List taken from `libstd/sys_common/alloc.rs`.\n         let min_align = match this.tcx.tcx.sess.target.target.arch.as_str() {\n             \"x86\" | \"arm\" | \"mips\" | \"powerpc\" | \"powerpc64\" | \"asmjs\" | \"wasm32\" => 8,\n             \"x86_64\" | \"aarch64\" | \"mips64\" | \"s390x\" | \"sparc64\" => 16,\n             arch => bug!(\"Unsupported target architecture: {}\", arch),\n         };\n-        Align::from_bytes(min_align).unwrap()\n+        // Windows always aligns, even small allocations.\n+        // Source: <https://support.microsoft.com/en-us/help/286470/how-to-use-pageheap-exe-in-windows-xp-windows-2000-and-windows-server>\n+        // But jemalloc does not, so for the C heap we only align if the allocation is sufficiently big.\n+        if kind == MiriMemoryKind::WinHeap || size >= min_align {\n+            return Align::from_bytes(min_align).unwrap();\n+        }\n+        // We have `size < min_align`. Round `size` *down* to the next power of two and use that.\n+        fn prev_power_of_two(x: u64) -> u64 {\n+            let next_pow2 = x.next_power_of_two();\n+            if next_pow2 == x {\n+                // x *is* a power of two, just use that.\n+                x\n+            } else {\n+                // x is between two powers, so next = 2*prev.\n+                next_pow2 / 2\n+            }\n+        }\n+        Align::from_bytes(prev_power_of_two(size)).unwrap()\n     }\n \n     fn malloc(\n         &mut self,\n         size: u64,\n         zero_init: bool,\n+        kind: MiriMemoryKind,\n     ) -> Scalar<Tag> {\n         let this = self.eval_context_mut();\n         let tcx = &{this.tcx.tcx};\n         if size == 0 {\n             Scalar::from_int(0, this.pointer_size())\n         } else {\n-            let align = this.min_align();\n-            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, MiriMemoryKind::C.into());\n+            let align = this.min_align(size, kind);\n+            let ptr = this.memory_mut().allocate(Size::from_bytes(size), align, kind.into());\n             if zero_init {\n                 // We just allocated this, the access cannot fail\n                 this.memory_mut()\n@@ -88,13 +65,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn free(\n         &mut self,\n         ptr: Scalar<Tag>,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if !ptr.is_null_ptr(this) {\n+        if !this.is_null(ptr)? {\n+            let ptr = this.force_ptr(ptr)?;\n             this.memory_mut().deallocate(\n-                ptr.to_ptr()?,\n+                ptr,\n                 None,\n-                MiriMemoryKind::C.into(),\n+                kind.into(),\n             )?;\n         }\n         Ok(())\n@@ -104,39 +83,38 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         old_ptr: Scalar<Tag>,\n         new_size: u64,\n+        kind: MiriMemoryKind,\n     ) -> InterpResult<'tcx, Scalar<Tag>> {\n         let this = self.eval_context_mut();\n-        let align = this.min_align();\n-        if old_ptr.is_null_ptr(this) {\n+        let new_align = this.min_align(new_size, kind);\n+        if this.is_null(old_ptr)? {\n             if new_size == 0 {\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = this.memory_mut().allocate(\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into()\n+                    new_align,\n+                    kind.into()\n                 );\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n         } else {\n-            let old_ptr = old_ptr.to_ptr()?;\n+            let old_ptr = this.force_ptr(old_ptr)?;\n             let memory = this.memory_mut();\n-            let old_size = Size::from_bytes(memory.get(old_ptr.alloc_id)?.bytes.len() as u64);\n             if new_size == 0 {\n                 memory.deallocate(\n                     old_ptr,\n-                    Some((old_size, align)),\n-                    MiriMemoryKind::C.into(),\n+                    None,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::from_int(0, this.pointer_size()))\n             } else {\n                 let new_ptr = memory.reallocate(\n                     old_ptr,\n-                    old_size,\n-                    align,\n+                    None,\n                     Size::from_bytes(new_size),\n-                    align,\n-                    MiriMemoryKind::C.into(),\n+                    new_align,\n+                    kind.into(),\n                 )?;\n                 Ok(Scalar::Ptr(new_ptr))\n             }\n@@ -185,14 +163,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         match link_name {\n             \"malloc\" => {\n                 let size = this.read_scalar(args[0])?.to_usize(this)?;\n-                let res = this.malloc(size, /*zero_init:*/ false);\n+                let res = this.malloc(size, /*zero_init:*/ false, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"calloc\" => {\n                 let items = this.read_scalar(args[0])?.to_usize(this)?;\n                 let len = this.read_scalar(args[1])?.to_usize(this)?;\n                 let size = items.checked_mul(len).ok_or_else(|| InterpError::Overflow(mir::BinOp::Mul))?;\n-                let res = this.malloc(size, /*zero_init:*/ true);\n+                let res = this.malloc(size, /*zero_init:*/ true, MiriMemoryKind::C);\n                 this.write_scalar(res, dest)?;\n             }\n             \"posix_memalign\" => {\n@@ -227,12 +205,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"free\" => {\n                 let ptr = this.read_scalar(args[0])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::C)?;\n             }\n             \"realloc\" => {\n                 let old_ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let new_size = this.read_scalar(args[1])?.to_usize(this)?;\n-                let res = this.realloc(old_ptr, new_size)?;\n+                let res = this.realloc(old_ptr, new_size, MiriMemoryKind::C)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n@@ -268,13 +246,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Align::from_bytes(align).unwrap(),\n                         MiriMemoryKind::Rust.into()\n                     );\n+                // We just allocated this, the access cannot fail\n                 this.memory_mut()\n-                    .get_mut(ptr.alloc_id)?\n-                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size))?;\n+                    .get_mut(ptr.alloc_id).unwrap()\n+                    .write_repeat(tcx, ptr, 0, Size::from_bytes(size)).unwrap();\n                 this.write_scalar(Scalar::Ptr(ptr), dest)?;\n             }\n             \"__rust_dealloc\" => {\n-                let ptr = this.read_scalar(args[0])?.to_ptr()?;\n+                let ptr = this.read_scalar(args[0])?.not_undef()?;\n                 let old_size = this.read_scalar(args[1])?.to_usize(this)?;\n                 let align = this.read_scalar(args[2])?.to_usize(this)?;\n                 if old_size == 0 {\n@@ -283,6 +262,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n+                let ptr = this.force_ptr(ptr)?;\n                 this.memory_mut().deallocate(\n                     ptr,\n                     Some((Size::from_bytes(old_size), Align::from_bytes(align).unwrap())),\n@@ -300,12 +280,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 if !align.is_power_of_two() {\n                     return err!(HeapAllocNonPowerOfTwoAlignment(align));\n                 }\n+                let align = Align::from_bytes(align).unwrap();\n                 let new_ptr = this.memory_mut().reallocate(\n                     ptr,\n-                    Size::from_bytes(old_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    Some((Size::from_bytes(old_size), align)),\n                     Size::from_bytes(new_size),\n-                    Align::from_bytes(align).unwrap(),\n+                    align,\n                     MiriMemoryKind::Rust.into(),\n                 )?;\n                 this.write_scalar(Scalar::Ptr(new_ptr), dest)?;\n@@ -365,7 +345,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n \n                 // Now we make a function call.\n-                // TODO: consider making this reusable? `InterpretCx::step` does something similar\n+                // TODO: consider making this reusable? `InterpCx::step` does something similar\n                 // for the TLS destructors, and of course `eval_main`.\n                 let mir = this.load_mir(f_instance.def)?;\n                 let ret_place = MPlaceTy::dangling(this.layout_of(this.tcx.mk_unit())?, this).into();\n@@ -467,7 +447,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let mut success = None;\n                 {\n                     let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n-                    if !name_ptr.is_null_ptr(this) {\n+                    if !this.is_null(name_ptr)? {\n                         let name_ptr = name_ptr.to_ptr()?;\n                         let name = this\n                             .memory()\n@@ -495,7 +475,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let name_ptr = this.read_scalar(args[0])?.not_undef()?;\n                     let value_ptr = this.read_scalar(args[1])?.to_ptr()?;\n                     let value = this.memory().get(value_ptr.alloc_id)?.read_c_str(tcx, value_ptr)?;\n-                    if !name_ptr.is_null_ptr(this) {\n+                    if !this.is_null(name_ptr)? {\n                         let name_ptr = name_ptr.to_ptr()?;\n                         let name = this.memory().get(name_ptr.alloc_id)?.read_c_str(tcx, name_ptr)?;\n                         if !name.is_empty() && !name.contains(&b'=') {\n@@ -510,15 +490,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         Align::from_bytes(1).unwrap(),\n                         MiriMemoryKind::Env.into(),\n                     );\n-                    {\n-                        let alloc = this.memory_mut().get_mut(value_copy.alloc_id)?;\n-                        alloc.write_bytes(tcx, value_copy, &value)?;\n-                        let trailing_zero_ptr = value_copy.offset(\n-                            Size::from_bytes(value.len() as u64),\n-                            tcx,\n-                        )?;\n-                        alloc.write_bytes(tcx, trailing_zero_ptr, &[0])?;\n-                    }\n+                    // We just allocated these, so the write cannot fail.\n+                    let alloc = this.memory_mut().get_mut(value_copy.alloc_id).unwrap();\n+                    alloc.write_bytes(tcx, value_copy, &value).unwrap();\n+                    let trailing_zero_ptr = value_copy.offset(\n+                        Size::from_bytes(value.len() as u64),\n+                        tcx,\n+                    ).unwrap();\n+                    alloc.write_bytes(tcx, trailing_zero_ptr, &[0]).unwrap();\n+\n                     if let Some(var) = this.machine.env_vars.insert(\n                         name.to_owned(),\n                         value_copy,\n@@ -678,14 +658,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let key_ptr = this.read_scalar(args[0])?.not_undef()?;\n \n                 // Extract the function type out of the signature (that seems easier than constructing it ourselves).\n-                let dtor = match this.read_scalar(args[1])?.not_undef()? {\n-                    Scalar::Ptr(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr)?),\n-                    Scalar::Raw { data: 0, size } => {\n-                        // NULL pointer\n-                        assert_eq!(size as u64, this.memory().pointer_size().bytes());\n-                        None\n-                    },\n-                    Scalar::Raw { .. } => return err!(ReadBytesAsPointer),\n+                let dtor = match this.test_null(this.read_scalar(args[1])?.not_undef()?)? {\n+                    Some(dtor_ptr) => Some(this.memory().get_fn(dtor_ptr.to_ptr()?)?),\n+                    None => None,\n                 };\n \n                 // Figure out how large a pthread TLS key actually is.\n@@ -697,7 +672,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let key_layout = this.layout_of(key_type)?;\n \n                 // Create key and write it into the memory where `key_ptr` wants it.\n-                let key = this.machine.tls.create_tls_key(dtor, tcx) as u128;\n+                let key = this.machine.tls.create_tls_key(dtor) as u128;\n                 if key_layout.size.bits() < 128 && key >= (1u128 << key_layout.size.bits() as u128) {\n                     return err!(OutOfTls);\n                 }\n@@ -722,13 +697,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"pthread_getspecific\" => {\n                 let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n-                let ptr = this.machine.tls.load_tls(key)?;\n+                let ptr = this.machine.tls.load_tls(key, tcx)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"pthread_setspecific\" => {\n                 let key = this.read_scalar(args[0])?.to_bits(args[0].layout.size)?;\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, new_ptr)?;\n+                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n \n                 // Return success (`0`).\n                 this.write_null(dest)?;\n@@ -808,22 +783,22 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let flags = this.read_scalar(args[1])?.to_u32()?;\n                 let size = this.read_scalar(args[2])?.to_usize(this)?;\n                 let zero_init = (flags & 0x00000008) != 0; // HEAP_ZERO_MEMORY\n-                let res = this.malloc(size, zero_init);\n+                let res = this.malloc(size, zero_init, MiriMemoryKind::WinHeap);\n                 this.write_scalar(res, dest)?;\n             }\n             \"HeapFree\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n-                this.free(ptr)?;\n+                this.free(ptr, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(Scalar::from_int(1, Size::from_bytes(4)), dest)?;\n             }\n             \"HeapReAlloc\" => {\n                 let _handle = this.read_scalar(args[0])?.to_isize(this)?;\n                 let _flags = this.read_scalar(args[1])?.to_u32()?;\n                 let ptr = this.read_scalar(args[2])?.not_undef()?;\n                 let size = this.read_scalar(args[3])?.to_usize(this)?;\n-                let res = this.realloc(ptr, size)?;\n+                let res = this.realloc(ptr, size, MiriMemoryKind::WinHeap)?;\n                 this.write_scalar(res, dest)?;\n             }\n \n@@ -855,7 +830,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             },\n             \"GetSystemInfo\" => {\n                 let system_info = this.deref_operand(args[0])?;\n-                let system_info_ptr = system_info.ptr.to_ptr()?;\n+                let (system_info_ptr, align) = system_info.to_scalar_ptr_align();\n+                let system_info_ptr = this.memory()\n+                    .check_ptr_access(\n+                        system_info_ptr,\n+                        system_info.layout.size,\n+                        align,\n+                    )?\n+                    .expect(\"cannot be a ZST\");\n                 // Initialize with `0`.\n                 this.memory_mut().get_mut(system_info_ptr.alloc_id)?\n                     .write_repeat(tcx, system_info_ptr, 0, system_info.layout.size)?;\n@@ -875,7 +857,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // This just creates a key; Windows does not natively support TLS destructors.\n \n                 // Create key and return it.\n-                let key = this.machine.tls.create_tls_key(None, tcx) as u128;\n+                let key = this.machine.tls.create_tls_key(None) as u128;\n \n                 // Figure out how large a TLS key actually is. This is `c::DWORD`.\n                 if dest.layout.size.bits() < 128\n@@ -886,13 +868,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n             \"TlsGetValue\" => {\n                 let key = this.read_scalar(args[0])?.to_u32()? as u128;\n-                let ptr = this.machine.tls.load_tls(key)?;\n+                let ptr = this.machine.tls.load_tls(key, tcx)?;\n                 this.write_scalar(ptr, dest)?;\n             }\n             \"TlsSetValue\" => {\n                 let key = this.read_scalar(args[0])?.to_u32()? as u128;\n                 let new_ptr = this.read_scalar(args[1])?.not_undef()?;\n-                this.machine.tls.store_tls(key, new_ptr)?;\n+                this.machine.tls.store_tls(key, this.test_null(new_ptr)?)?;\n \n                 // Return success (`1`).\n                 this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n@@ -969,10 +951,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn write_null(&mut self, dest: PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n-        self.eval_context_mut().write_scalar(Scalar::from_int(0, dest.layout.size), dest)\n-    }\n-\n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n     fn eval_path_scalar(&mut self, path: &[&str]) -> InterpResult<'tcx, Option<ScalarMaybeUndef<Tag>>> {"}, {"sha": "3258cf3d9c1da6ea8c9b45f831aa6becc23fd198", "filename": "src/shims/mod.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,2 +1,50 @@\n pub mod foreign_items;\n pub mod intrinsics;\n+pub mod tls;\n+\n+use rustc::{ty, mir};\n+\n+use crate::*;\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn find_fn(\n+        &mut self,\n+        instance: ty::Instance<'tcx>,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n+        let this = self.eval_context_mut();\n+        trace!(\"eval_fn_call: {:#?}, {:?}\", instance, dest.map(|place| *place));\n+\n+        // First, run the common hooks also supported by CTFE.\n+        if this.hook_fn(instance, args, dest)? {\n+            this.goto_block(ret)?;\n+            return Ok(None);\n+        }\n+        // There are some more lang items we want to hook that CTFE does not hook (yet).\n+        if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n+            // FIXME: return a real value in case the target allocation has an\n+            // alignment bigger than the one requested.\n+            let n = u128::max_value();\n+            let dest = dest.unwrap();\n+            let n = this.truncate(n, dest.layout);\n+            this.write_scalar(Scalar::from_uint(n, dest.layout.size), dest)?;\n+            this.goto_block(ret)?;\n+            return Ok(None);\n+        }\n+\n+        // Try to see if we can do something about foreign items.\n+        if this.tcx.is_foreign_item(instance.def_id()) {\n+            // An external function that we cannot find MIR for, but we can still run enough\n+            // of them to make miri viable.\n+            this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n+            // `goto_block` already handled.\n+            return Ok(None);\n+        }\n+\n+        // Otherwise, load the MIR.\n+        Ok(Some(this.load_mir(instance.def)?))\n+    }\n+}"}, {"sha": "e2f2dab518058169e33975a0d6006ea1a82a59c7", "filename": "src/shims/tls.rs", "status": "renamed", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -8,13 +8,17 @@ use rustc::{ty, ty::layout::HasDataLayout, mir};\n use crate::{\n     InterpResult, InterpError, StackPopCleanup,\n     MPlaceTy, Scalar, Tag,\n+    HelpersEvalContextExt,\n };\n \n pub type TlsKey = u128;\n \n #[derive(Copy, Clone, Debug)]\n pub struct TlsEntry<'tcx> {\n-    pub(crate) data: Scalar<Tag>, // Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    /// The data for this key. None is used to represent NULL.\n+    /// (We normalize this early to avoid having to do a NULL-ptr-test each time we access the data.)\n+    /// Will eventually become a map from thread IDs to `Scalar`s, if we ever support more than one thread.\n+    pub(crate) data: Option<Scalar<Tag>>,\n     pub(crate) dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -40,14 +44,13 @@ impl<'tcx> TlsData<'tcx> {\n     pub fn create_tls_key(\n         &mut self,\n         dtor: Option<ty::Instance<'tcx>>,\n-        cx: &impl HasDataLayout,\n     ) -> TlsKey {\n         let new_key = self.next_key;\n         self.next_key += 1;\n         self.keys.insert(\n             new_key,\n             TlsEntry {\n-                data: Scalar::ptr_null(cx).into(),\n+                data: None,\n                 dtor,\n             },\n         );\n@@ -65,17 +68,21 @@ impl<'tcx> TlsData<'tcx> {\n         }\n     }\n \n-    pub fn load_tls(&mut self, key: TlsKey) -> InterpResult<'tcx, Scalar<Tag>> {\n+    pub fn load_tls(\n+        &mut self,\n+        key: TlsKey,\n+        cx: &impl HasDataLayout,\n+    ) -> InterpResult<'tcx, Scalar<Tag>> {\n         match self.keys.get(&key) {\n             Some(&TlsEntry { data, .. }) => {\n                 trace!(\"TLS key {} loaded: {:?}\", key, data);\n-                Ok(data)\n+                Ok(data.unwrap_or_else(|| Scalar::ptr_null(cx).into()))\n             }\n             None => err!(TlsOutOfBounds),\n         }\n     }\n \n-    pub fn store_tls(&mut self, key: TlsKey, new_data: Scalar<Tag>) -> InterpResult<'tcx> {\n+    pub fn store_tls(&mut self, key: TlsKey, new_data: Option<Scalar<Tag>>) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n             Some(&mut TlsEntry { ref mut data, .. }) => {\n                 trace!(\"TLS key {} stored: {:?}\", key, new_data);\n@@ -107,7 +114,6 @@ impl<'tcx> TlsData<'tcx> {\n     fn fetch_tls_dtor(\n         &mut self,\n         key: Option<TlsKey>,\n-        cx: &impl HasDataLayout,\n     ) -> Option<(ty::Instance<'tcx>, Scalar<Tag>, TlsKey)> {\n         use std::collections::Bound::*;\n \n@@ -119,10 +125,10 @@ impl<'tcx> TlsData<'tcx> {\n         for (&key, &mut TlsEntry { ref mut data, dtor }) in\n             thread_local.range_mut((start, Unbounded))\n         {\n-            if !data.is_null_ptr(cx) {\n+            if let Some(data_scalar) = *data {\n                 if let Some(dtor) = dtor {\n-                    let ret = Some((dtor, *data, key));\n-                    *data = Scalar::ptr_null(cx);\n+                    let ret = Some((dtor, data_scalar, key));\n+                    *data = None;\n                     return ret;\n                 }\n             }\n@@ -135,10 +141,11 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn run_tls_dtors(&mut self) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let mut dtor = this.machine.tls.fetch_tls_dtor(None, &*this.tcx);\n+        let mut dtor = this.machine.tls.fetch_tls_dtor(None);\n         // FIXME: replace loop by some structure that works with stepping\n         while let Some((instance, ptr, key)) = dtor {\n             trace!(\"Running TLS dtor {:?} on {:?}\", instance, ptr);\n+            assert!(!this.is_null(ptr).unwrap(), \"Data can't be NULL when dtor is called!\");\n             // TODO: Potentially, this has to support all the other possible instances?\n             // See eval_fn_call in interpret/terminator/mod.rs\n             let mir = this.load_mir(instance.def)?;\n@@ -159,9 +166,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // step until out of stackframes\n             this.run()?;\n \n-            dtor = match this.machine.tls.fetch_tls_dtor(Some(key), &*this.tcx) {\n+            dtor = match this.machine.tls.fetch_tls_dtor(Some(key)) {\n                 dtor @ Some(_) => dtor,\n-                None => this.machine.tls.fetch_tls_dtor(None, &*this.tcx),\n+                None => this.machine.tls.fetch_tls_dtor(None),\n             };\n         }\n         // FIXME: On a windows target, call `unsafe extern \"system\" fn on_tls_callback`.", "previous_filename": "src/tls.rs"}, {"sha": "acd1aec5b770ba9f498160d51b1310566b07fcb1", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -541,6 +541,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Get the allocation. It might not be mutable, so we cannot use `get_mut`.\n         let alloc = this.memory().get(ptr.alloc_id)?;\n+        let stacked_borrows = alloc.extra.stacked_borrows.as_ref().expect(\"we should have Stacked Borrows data\");\n         // Update the stacks.\n         // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n         // There could be existing unique pointers reborrowed from them that should remain valid!\n@@ -556,14 +557,14 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n                     let item = Item { perm, tag: new_tag, protector };\n-                    alloc.extra.stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n+                    stacked_borrows.for_each(cur_ptr, size, |stack, global| {\n                         stack.grant(cur_ptr.tag, item, global)\n                     })\n                 });\n             }\n         };\n         let item = Item { perm, tag: new_tag, protector };\n-        alloc.extra.stacked_borrows.for_each(ptr, size, |stack, global| {\n+        stacked_borrows.for_each(ptr, size, |stack, global| {\n             stack.grant(ptr.tag, item, global)\n         })\n     }"}, {"sha": "a9aba008e9a927407c869110b4992f8e9b383b9d", "filename": "test-cargo-miri/run-test.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/test-cargo-miri%2Frun-test.py", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/test-cargo-miri%2Frun-test.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test-cargo-miri%2Frun-test.py?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -52,8 +52,9 @@ def test_cargo_miri_run():\n     )\n \n def test_cargo_miri_test():\n+    # FIXME: enable validation again, once that no longer conflicts with intptrcast\n     test(\"cargo miri test\",\n-        cargo_miri(\"test\") + [\"--\", \"-Zmiri-seed=feed\"],\n+        cargo_miri(\"test\") + [\"--\", \"-Zmiri-seed=feed\", \"-Zmiri-disable-validation\"],\n         \"test.stdout.ref\", \"test.stderr.ref\"\n     )\n     test(\"cargo miri test (with filter)\","}, {"sha": "2d3282a0a97a0c95c72d355de2aacba96e76c89d", "filename": "tests/compile-fail/ptr_offset_int_plus_int.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fptr_offset_int_plus_int.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: invalid arithmetic on pointers\n+// error-pattern: tried to interpret some bytes as a pointer\n \n fn main() {\n     // Can't offset an integer pointer by non-zero offset."}, {"sha": "076deca6a318c87e5b3dceaed2a77d5c703dc989", "filename": "tests/compiletest.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompiletest.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -69,7 +69,7 @@ fn compile_fail(path: &str, target: &str, opt: bool) {\n     run_tests(\"compile-fail\", path, target, flags);\n }\n \n-fn miri_pass(path: &str, target: &str, opt: bool) {\n+fn miri_pass(path: &str, target: &str, opt: bool, noseed: bool) {\n     let opt_str = if opt { \" with optimizations\" } else { \"\" };\n     eprintln!(\"{}\", format!(\n         \"## Running run-pass tests in {} against miri for target {}{}\",\n@@ -81,6 +81,9 @@ fn miri_pass(path: &str, target: &str, opt: bool) {\n     let mut flags = Vec::new();\n     if opt {\n         flags.push(\"-Zmir-opt-level=3\".to_owned());\n+    } else if !noseed {\n+        // Run with intptrcast.  Avoid test matrix explosion by doing either this or opt-level=3.\n+        flags.push(\"-Zmiri-seed=\".to_owned());\n     }\n \n     run_tests(\"ui\", path, target, flags);\n@@ -104,11 +107,14 @@ fn get_target() -> String {\n }\n \n fn run_pass_miri(opt: bool) {\n-    miri_pass(\"tests/run-pass\", &get_target(), opt);\n+    miri_pass(\"tests/run-pass\", &get_target(), opt, false);\n+    miri_pass(\"tests/run-pass-noseed\", &get_target(), opt, true);\n }\n \n fn compile_fail_miri(opt: bool) {\n-    compile_fail(\"tests/compile-fail\", &get_target(), opt);\n+    if !cfg!(windows) { // FIXME re-enable on Windows\n+        compile_fail(\"tests/compile-fail\", &get_target(), opt);\n+    }\n }\n \n fn test_runner(_tests: &[&()]) {"}, {"sha": "e249238d48cbff3893a0cc48cb415e1190612441", "filename": "tests/run-pass-noseed/hashmap.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fhashmap.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "previous_filename": "tests/run-pass/hashmap.rs"}, {"sha": "e7a609a7d98e97818f9b56e042e0241dab57552f", "filename": "tests/run-pass-noseed/heap_allocator.rs", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fheap_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fheap_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fheap_allocator.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -41,7 +41,7 @@ fn check_alloc<T: Alloc>(mut allocator: T) { unsafe {\n     }\n } }\n \n-fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n+fn check_align_requests<T: Alloc>(mut allocator: T) {\n     for &size in &[2, 8, 64] { // size less than and bigger than alignment\n         for &align in &[4, 8, 16, 32] { // Be sure to cover less than and bigger than `MIN_ALIGN` for all architectures\n             let iterations = 32;\n@@ -88,8 +88,8 @@ fn box_to_global() {\n fn main() {\n     check_alloc(System);\n     check_alloc(Global);\n-    check_overalign_requests(System);\n-    check_overalign_requests(Global);\n+    check_align_requests(System);\n+    check_align_requests(Global);\n     global_to_box();\n     box_to_global();\n }", "previous_filename": "tests/run-pass/heap_allocator.rs"}, {"sha": "1b5251c91119a074e5d3286837ea5e16e4575bcf", "filename": "tests/run-pass-noseed/intptrcast.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fintptrcast.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -0,0 +1,26 @@\n+// compile-flags: -Zmiri-seed=0000000000000000\n+\n+// This returns a miri pointer at type usize, if the argument is a proper pointer\n+fn transmute_ptr_to_int<T>(x: *const T) -> usize {\n+    unsafe { std::mem::transmute(x) }\n+}\n+\n+fn main() {\n+    // Some casting-to-int with arithmetic.\n+    let x = &42 as *const i32 as usize;\n+    let y = x * 2;\n+    assert_eq!(y, x + x);\n+    let z = y as u8 as usize;\n+    assert_eq!(z, y % 256);\n+\n+    // Pointer string formatting! We can't check the output as it changes when libstd changes,\n+    // but we can make sure Miri does not error.\n+    format!(\"{:?}\", &mut 13 as *mut _);\n+\n+    // Check that intptrcast is triggered for explicit casts and that it is consistent with\n+    // transmuting.\n+    let a: *const i32 = &42;\n+    let b = transmute_ptr_to_int(a) as u8;\n+    let c = a as usize as u8;\n+    assert_eq!(b, c);\n+}"}, {"sha": "bf51baacd35a9a9d7a548533eb343781968832c2", "filename": "tests/run-pass-noseed/malloc.rs", "status": "renamed", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fmalloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fmalloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fmalloc.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,4 +1,5 @@\n //ignore-windows: Uses POSIX APIs\n+//compile-flags: -Zmiri-seed=\n \n #![feature(rustc_private)]\n \n@@ -7,6 +8,14 @@ use core::{slice, ptr};\n extern crate libc;\n \n fn main() {\n+    // Test that small allocations sometimes *are* not very aligned.\n+    let saw_unaligned = (0..64).any(|_| unsafe {\n+        let p = libc::malloc(3);\n+        libc::free(p);\n+        (p as usize) % 4 != 0 // find any that this is *not* 4-aligned\n+    });\n+    assert!(saw_unaligned);\n+\n     unsafe {\n         // Use calloc for initialized memory\n         let p1 = libc::calloc(20, 1);", "previous_filename": "tests/run-pass/realloc.rs"}, {"sha": "ebf65ac3fe246fe0770f3c50a47d09117022cb38", "filename": "tests/run-pass-noseed/ptr_int_casts.rs", "status": "renamed", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fptr_int_casts.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,3 +1,4 @@\n+// FIXME move this to run-pass, it should work with intptrcast.\n use std::mem;\n use std::ptr;\n ", "previous_filename": "tests/run-pass/ptr_int_casts.rs"}, {"sha": "a836e02812da7b8af92b5346d7e9f78aee4b1c66", "filename": "tests/run-pass-noseed/ptr_offset.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fptr_offset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass-noseed%2Fptr_offset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass-noseed%2Fptr_offset.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,3 +1,5 @@\n+// FIXME move this to run-pass, it should work with intptrcast.\n+\n fn f() -> i32 { 42 }\n \n fn main() {", "previous_filename": "tests/run-pass/ptr_offset.rs"}, {"sha": "40b21f9a4729ee1510dd15dd1998d94be14de046", "filename": "tests/run-pass/intptrcast.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast.rs?ref=e82693fa23caea857ba83fa0963154627b5fe12c", "patch": "@@ -1,14 +0,0 @@\n-// compile-flags: -Zmiri-seed=0000000000000000\n-\n-fn main() {\n-    // Some casting-to-int with arithmetic.\n-    let x = &42 as *const i32 as usize; \n-    let y = x * 2;\n-    assert_eq!(y, x + x);\n-    let z = y as u8 as usize;\n-    assert_eq!(z, y % 256);\n-\n-    // Pointer string formatting! We can't check the output as it changes when libstd changes,\n-    // but we can make sure Miri does not error.\n-    format!(\"{:?}\", &mut 13 as *mut _);\n-}"}, {"sha": "c0d3e9398dc5d4eebb0a9c4e12ebd08d85020887", "filename": "tests/run-pass/intptrcast_format.rs", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast_format.rs?ref=e82693fa23caea857ba83fa0963154627b5fe12c", "patch": "@@ -1,6 +0,0 @@\n-// compile-flags: -Zmiri-seed=\n-\n-fn main() {\n-    println!(\"Hello {}\", 13);\n-    println!(\"{:0<width$}\", \"hello\", width = 10);\n-}"}, {"sha": "3c9a55d0d4c1aeb35639cb8a39eb742dc3fc6cf1", "filename": "tests/run-pass/intptrcast_format.stdout", "status": "removed", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast_format.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/e82693fa23caea857ba83fa0963154627b5fe12c/tests%2Frun-pass%2Fintptrcast_format.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fintptrcast_format.stdout?ref=e82693fa23caea857ba83fa0963154627b5fe12c", "patch": "@@ -1,2 +0,0 @@\n-Hello 13\n-hello00000"}, {"sha": "27da44935b106c98cba3c37c50e79e40fb890810", "filename": "tests/run-pass/transmute_fat.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass%2Ftransmute_fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b324cbf2821c7851829522a43ea07ca3229d0492/tests%2Frun-pass%2Ftransmute_fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ftransmute_fat.rs?ref=b324cbf2821c7851829522a43ea07ca3229d0492", "patch": "@@ -1,3 +1,6 @@\n+// Validation disallows this becuase the reference is never cast to a raw pointer.\n+// compile-flags: -Zmiri-disable-validation\n+\n fn main() {\n     // If we are careful, we can exploit data layout...\n     let raw = unsafe {"}]}