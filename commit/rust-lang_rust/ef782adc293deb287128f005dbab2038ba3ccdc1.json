{"sha": "ef782adc293deb287128f005dbab2038ba3ccdc1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmNzgyYWRjMjkzZGViMjg3MTI4ZjAwNWRiYWIyMDM4YmEzY2NkYzE=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-06T14:27:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-05-06T14:27:34Z"}, "message": "Merge #1163\n\n1163: fill struct fields diagnostic r=matklad a=pasa\n\nimplementation of #1095\n\nCo-authored-by: Sergey Parilin <sergey.parilin@fxdd.com>", "tree": {"sha": "6e451b71b482e75a5a30548ab8f769c5ec17864c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e451b71b482e75a5a30548ab8f769c5ec17864c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ef782adc293deb287128f005dbab2038ba3ccdc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ef782adc293deb287128f005dbab2038ba3ccdc1", "html_url": "https://github.com/rust-lang/rust/commit/ef782adc293deb287128f005dbab2038ba3ccdc1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ef782adc293deb287128f005dbab2038ba3ccdc1/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "32db5884ada59c72aa7ab9f88910ef7c8f882e7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/32db5884ada59c72aa7ab9f88910ef7c8f882e7d", "html_url": "https://github.com/rust-lang/rust/commit/32db5884ada59c72aa7ab9f88910ef7c8f882e7d"}, {"sha": "12f8472d2800b2d7c05cb1fc466c80072ed8e283", "url": "https://api.github.com/repos/rust-lang/rust/commits/12f8472d2800b2d7c05cb1fc466c80072ed8e283", "html_url": "https://github.com/rust-lang/rust/commit/12f8472d2800b2d7c05cb1fc466c80072ed8e283"}], "stats": {"total": 515, "additions": 269, "deletions": 246}, "files": [{"sha": "726e5c0a3e635f9b06ad4d6441b5ac7f949a4004", "filename": "crates/ra_assists/src/ast_editor.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_assists%2Fsrc%2Fast_editor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_editor.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -4,6 +4,7 @@ use arrayvec::ArrayVec;\n use ra_text_edit::TextEditBuilder;\n use ra_syntax::{AstNode, TreeArc, ast, SyntaxKind::*, SyntaxElement, SourceFile, InsertPosition, Direction};\n use ra_fmt::leading_indent;\n+use hir::Name;\n \n pub struct AstEditor<N: AstNode> {\n     original_ast: TreeArc<N>,\n@@ -235,6 +236,10 @@ pub struct AstBuilder<N: AstNode> {\n }\n \n impl AstBuilder<ast::NamedField> {\n+    pub fn from_name(name: &Name) -> TreeArc<ast::NamedField> {\n+        ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}: (), }} }}\", name))\n+    }\n+\n     fn from_text(text: &str) -> TreeArc<ast::NamedField> {\n         ast_node_from_file_text(&format!(\"fn f() {{ S {{ {}, }} }}\", text))\n     }"}, {"sha": "54b70e17dd54c38c3fd5059470680ceba2a385f8", "filename": "crates/ra_assists/src/fill_struct_fields.rs", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/32db5884ada59c72aa7ab9f88910ef7c8f882e7d/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/32db5884ada59c72aa7ab9f88910ef7c8f882e7d/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ffill_struct_fields.rs?ref=32db5884ada59c72aa7ab9f88910ef7c8f882e7d", "patch": "@@ -1,226 +0,0 @@\n-use hir::{AdtDef, db::HirDatabase};\n-\n-use ra_syntax::ast::{self, AstNode};\n-\n-use crate::{AssistCtx, Assist, AssistId, ast_editor::{AstEditor, AstBuilder}};\n-\n-pub(crate) fn fill_struct_fields(mut ctx: AssistCtx<impl HirDatabase>) -> Option<Assist> {\n-    let struct_lit = ctx.node_at_offset::<ast::StructLit>()?;\n-    let named_field_list = struct_lit.named_field_list()?;\n-\n-    // Collect all fields from struct definition\n-    let mut fields = {\n-        let analyzer =\n-            hir::SourceAnalyzer::new(ctx.db, ctx.frange.file_id, struct_lit.syntax(), None);\n-        let struct_lit_ty = analyzer.type_of(ctx.db, struct_lit.into())?;\n-        let struct_def = match struct_lit_ty.as_adt() {\n-            Some((AdtDef::Struct(s), _)) => s,\n-            _ => return None,\n-        };\n-        struct_def.fields(ctx.db)\n-    };\n-\n-    // Filter out existing fields\n-    for ast_field in named_field_list.fields() {\n-        let name_from_ast = ast_field.name_ref()?.text().to_string();\n-        fields.retain(|field| field.name(ctx.db).to_string() != name_from_ast);\n-    }\n-    if fields.is_empty() {\n-        return None;\n-    }\n-\n-    let db = ctx.db;\n-    ctx.add_action(AssistId(\"fill_struct_fields\"), \"fill struct fields\", |edit| {\n-        let mut ast_editor = AstEditor::new(named_field_list);\n-        if named_field_list.fields().count() == 0 && fields.len() > 2 {\n-            ast_editor.make_multiline();\n-        };\n-\n-        for field in fields {\n-            let field = AstBuilder::<ast::NamedField>::from_pieces(\n-                &AstBuilder::<ast::NameRef>::new(&field.name(db).to_string()),\n-                Some(&AstBuilder::<ast::Expr>::unit()),\n-            );\n-            ast_editor.append_field(&field);\n-        }\n-\n-        edit.target(struct_lit.syntax().range());\n-        edit.set_cursor(struct_lit.syntax().range().start());\n-\n-        ast_editor.into_text_edit(edit.text_edit_builder());\n-    });\n-    ctx.build()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use crate::helpers::{check_assist, check_assist_target};\n-\n-    use super::fill_struct_fields;\n-\n-    #[test]\n-    fn fill_struct_fields_empty_body() {\n-        check_assist(\n-            fill_struct_fields,\n-            r#\"\n-            struct S<'a, D> {\n-                a: u32,\n-                b: String,\n-                c: (i32, i32),\n-                d: D,\n-                e: &'a str,\n-            }\n-\n-            fn main() {\n-                let s = S<|> {}\n-            }\n-            \"#,\n-            r#\"\n-            struct S<'a, D> {\n-                a: u32,\n-                b: String,\n-                c: (i32, i32),\n-                d: D,\n-                e: &'a str,\n-            }\n-\n-            fn main() {\n-                let s = <|>S {\n-                    a: (),\n-                    b: (),\n-                    c: (),\n-                    d: (),\n-                    e: (),\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fill_struct_fields_target() {\n-        check_assist_target(\n-            fill_struct_fields,\n-            r#\"\n-            struct S<'a, D> {\n-                a: u32,\n-                b: String,\n-                c: (i32, i32),\n-                d: D,\n-                e: &'a str,\n-            }\n-\n-            fn main() {\n-                let s = S<|> {}\n-            }\n-            \"#,\n-            \"S {}\",\n-        );\n-    }\n-\n-    #[test]\n-    fn fill_struct_fields_preserve_self() {\n-        check_assist(\n-            fill_struct_fields,\n-            r#\"\n-            struct Foo {\n-                foo: u8,\n-                bar: String,\n-                baz: i128,\n-            }\n-\n-            impl Foo {\n-                pub fn new() -> Self {\n-                    Self <|>{}\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            struct Foo {\n-                foo: u8,\n-                bar: String,\n-                baz: i128,\n-            }\n-\n-            impl Foo {\n-                pub fn new() -> Self {\n-                    <|>Self {\n-                        foo: (),\n-                        bar: (),\n-                        baz: (),\n-                    }\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fill_struct_fields_partial() {\n-        check_assist(\n-            fill_struct_fields,\n-            r#\"\n-            struct S<'a, D> {\n-                a: u32,\n-                b: String,\n-                c: (i32, i32),\n-                d: D,\n-                e: &'a str,\n-            }\n-\n-            fn main() {\n-                let s = S {\n-                    c: (1, 2),\n-                    e: \"foo\",<|>\n-                }\n-            }\n-            \"#,\n-            r#\"\n-            struct S<'a, D> {\n-                a: u32,\n-                b: String,\n-                c: (i32, i32),\n-                d: D,\n-                e: &'a str,\n-            }\n-\n-            fn main() {\n-                let s = <|>S {\n-                    c: (1, 2),\n-                    e: \"foo\",\n-                    a: (),\n-                    b: (),\n-                    d: (),\n-                }\n-            }\n-            \"#,\n-        );\n-    }\n-\n-    #[test]\n-    fn fill_struct_short() {\n-        check_assist(\n-            fill_struct_fields,\n-            r#\"\n-            struct S {\n-                foo: u32,\n-                bar: String,\n-            }\n-\n-            fn main() {\n-                let s = S {<|> };\n-            }\n-            \"#,\n-            r#\"\n-            struct S {\n-                foo: u32,\n-                bar: String,\n-            }\n-\n-            fn main() {\n-                let s = <|>S { foo: (), bar: () };\n-            }\n-            \"#,\n-        );\n-    }\n-}"}, {"sha": "ae97a1ab5896321c1cd183fcd45274dec061897a", "filename": "crates/ra_assists/src/lib.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Flib.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -93,7 +93,6 @@ mod flip_comma;\n mod flip_binexpr;\n mod change_visibility;\n mod fill_match_arms;\n-mod fill_struct_fields;\n mod introduce_variable;\n mod inline_local_variable;\n mod replace_if_let_with_match;\n@@ -110,7 +109,6 @@ fn all_assists<DB: HirDatabase>() -> &'static [fn(AssistCtx<DB>) -> Option<Assis\n         add_impl::add_impl,\n         change_visibility::change_visibility,\n         fill_match_arms::fill_match_arms,\n-        fill_struct_fields::fill_struct_fields,\n         flip_comma::flip_comma,\n         flip_binexpr::flip_binexpr,\n         introduce_variable::introduce_variable,"}, {"sha": "55e1793c5060c66bc8743980f86b85be48728d01", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -8,15 +8,15 @@ use crate::{\n     HirDatabase, DefDatabase,\n     type_ref::TypeRef,\n     nameres::{ModuleScope, Namespace, ImportId, CrateModuleId},\n-    expr::{Body, BodySourceMap},\n+    expr::{Body, BodySourceMap, validation::ExprValidator},\n     ty::{ TraitRef, InferenceResult},\n     adt::{EnumVariantId, StructFieldId, VariantDef},\n     generics::HasGenericParams,\n     docs::{Documentation, Docs, docs_from_ast},\n     ids::{FunctionId, StructId, EnumId, AstItemDef, ConstId, StaticId, TraitId, TypeAliasId},\n     impl_block::ImplBlock,\n     resolve::Resolver,\n-    diagnostics::DiagnosticSink,\n+    diagnostics::{DiagnosticSink},\n     traits::{TraitItem, TraitData},\n };\n \n@@ -431,8 +431,8 @@ impl Docs for EnumVariant {\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum DefWithBody {\n     Function(Function),\n-    Const(Const),\n     Static(Static),\n+    Const(Const),\n }\n \n impl_froms!(DefWithBody: Function, Const, Static);\n@@ -562,7 +562,10 @@ impl Function {\n     }\n \n     pub fn diagnostics(&self, db: &impl HirDatabase, sink: &mut DiagnosticSink) {\n-        self.infer(db).add_diagnostics(db, *self, sink);\n+        let infer = self.infer(db);\n+        infer.add_diagnostics(db, *self, sink);\n+        let mut validator = ExprValidator::new(*self, infer, sink);\n+        validator.validate_body(db);\n     }\n }\n "}, {"sha": "61cd9d6b17b694521dbcd501c889bebc75656d71", "filename": "crates/ra_hir/src/diagnostics.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdiagnostics.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -3,7 +3,7 @@ use std::{fmt, any::Any};\n use ra_syntax::{SyntaxNodePtr, TreeArc, AstPtr, TextRange, ast, SyntaxNode};\n use relative_path::RelativePathBuf;\n \n-use crate::{HirFileId, HirDatabase};\n+use crate::{HirFileId, HirDatabase, Name};\n \n /// Diagnostic defines hir API for errors and warnings.\n ///\n@@ -113,3 +113,25 @@ impl Diagnostic for UnresolvedModule {\n         self\n     }\n }\n+\n+#[derive(Debug)]\n+pub struct MissingFields {\n+    pub file: HirFileId,\n+    pub field_list: AstPtr<ast::NamedFieldList>,\n+    pub missed_fields: Vec<Name>,\n+}\n+\n+impl Diagnostic for MissingFields {\n+    fn message(&self) -> String {\n+        \"fill structure fields\".to_string()\n+    }\n+    fn file(&self) -> HirFileId {\n+        self.file\n+    }\n+    fn syntax_node_ptr(&self) -> SyntaxNodePtr {\n+        self.field_list.into()\n+    }\n+    fn as_any(&self) -> &(dyn Any + Send + 'static) {\n+        self\n+    }\n+}"}, {"sha": "480eaf1716cf913bce5a85996d73fc582c172b72", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -19,6 +19,7 @@ use crate::{path::GenericArgs, ty::primitive::{IntTy, UncertainIntTy, FloatTy, U\n pub use self::scope::ExprScopes;\n \n pub(crate) mod scope;\n+pub(crate) mod validation;\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct ExprId(RawId);\n@@ -670,8 +671,9 @@ where\n             ast::ExprKind::StructLit(e) => {\n                 let path = e.path().and_then(Path::from_ast);\n                 let mut field_ptrs = Vec::new();\n-                let fields = if let Some(nfl) = e.named_field_list() {\n-                    nfl.fields()\n+                let struct_lit = if let Some(nfl) = e.named_field_list() {\n+                    let fields = nfl\n+                        .fields()\n                         .inspect(|field| field_ptrs.push(AstPtr::new(*field)))\n                         .map(|field| StructLitField {\n                             name: field\n@@ -694,12 +696,14 @@ where\n                                 self.exprs.alloc(Expr::Missing)\n                             },\n                         })\n-                        .collect()\n+                        .collect();\n+                    let spread = nfl.spread().map(|s| self.collect_expr(s));\n+                    Expr::StructLit { path, fields, spread }\n                 } else {\n-                    Vec::new()\n+                    Expr::StructLit { path, fields: Vec::new(), spread: None }\n                 };\n-                let spread = e.spread().map(|s| self.collect_expr(s));\n-                let res = self.alloc_expr(Expr::StructLit { path, fields, spread }, syntax_ptr);\n+\n+                let res = self.alloc_expr(struct_lit, syntax_ptr);\n                 for (i, ptr) in field_ptrs.into_iter().enumerate() {\n                     self.source_map.field_map.insert((res, i), ptr);\n                 }"}, {"sha": "fd49073136bf34b00af1a0cc47f5f2b49b0f252c", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -0,0 +1,92 @@\n+use std::sync::Arc;\n+use rustc_hash::FxHashSet;\n+\n+use ra_syntax::ast::{AstNode, StructLit};\n+\n+use crate::{\n+    expr::AstPtr,\n+    HirDatabase,\n+    Function,\n+    Name,\n+    diagnostics::{DiagnosticSink, MissingFields},\n+    adt::AdtDef,\n+    Path,\n+    ty::InferenceResult\n+};\n+use super::{Expr, StructLitField, ExprId};\n+\n+pub(crate) struct ExprValidator<'a, 'b: 'a> {\n+    func: Function,\n+    infer: Arc<InferenceResult>,\n+    sink: &'a mut DiagnosticSink<'b>,\n+}\n+\n+impl<'a, 'b> ExprValidator<'a, 'b> {\n+    pub(crate) fn new(\n+        func: Function,\n+        infer: Arc<InferenceResult>,\n+        sink: &'a mut DiagnosticSink<'b>,\n+    ) -> ExprValidator<'a, 'b> {\n+        ExprValidator { func, infer, sink }\n+    }\n+\n+    pub(crate) fn validate_body(&mut self, db: &impl HirDatabase) {\n+        let body = self.func.body(db);\n+        for e in body.exprs() {\n+            match e {\n+                (id, Expr::StructLit { path, fields, spread }) => {\n+                    self.validate_struct_literal(id, path, fields, spread, db)\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn validate_struct_literal(\n+        &mut self,\n+        id: ExprId,\n+        _path: &Option<Path>,\n+        fields: &Vec<StructLitField>,\n+        spread: &Option<ExprId>,\n+        db: &impl HirDatabase,\n+    ) {\n+        if let Some(_) = spread {\n+            return;\n+        }\n+        let lit_fields: FxHashSet<_> = fields.into_iter().map(|f| &f.name).collect();\n+        let struct_ty = &self.infer[id];\n+        if let Some((AdtDef::Struct(s), _)) = struct_ty.as_adt() {\n+            let missed_fields: Vec<Name> = s\n+                .fields(db)\n+                .iter()\n+                .filter_map(|f| {\n+                    let name = f.name(db);\n+                    if lit_fields.contains(&name) {\n+                        None\n+                    } else {\n+                        Some(name)\n+                    }\n+                })\n+                .collect();\n+            if missed_fields.is_empty() {\n+                return;\n+            }\n+            let source_map = self.func.body_source_map(db);\n+            let file_id = self.func.source(db).0;\n+            let source_file = db.parse(file_id.original_file(db));\n+            if let Some(field_list_node) = source_map\n+                .expr_syntax(id)\n+                .map(|ptr| ptr.to_node(&source_file))\n+                .and_then(StructLit::cast)\n+                .and_then(|lit| lit.named_field_list())\n+            {\n+                let field_list_ptr = AstPtr::new(field_list_node);\n+                self.sink.push(MissingFields {\n+                    file: file_id,\n+                    field_list: field_list_ptr,\n+                    missed_fields,\n+                })\n+            }\n+        }\n+    }\n+}"}, {"sha": "a38fe35c72930909d5b1e4c3eb398d601d64721b", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -2662,6 +2662,7 @@ fn no_such_field_diagnostics() {\n \n     assert_snapshot_matches!(diagnostics, @r###\"\n \"baz: 62\": no such field\n+\"{\\n            foo: 92,\\n            baz: 62,\\n        }\": fill structure fields\n \"###\n     );\n }"}, {"sha": "855a3ff0f85e39539081d0505334d274f69de1a7", "filename": "crates/ra_ide_api/src/diagnostics.rs", "status": "modified", "additions": 122, "deletions": 1, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fdiagnostics.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -5,8 +5,9 @@ use hir::{source_binder, diagnostics::{Diagnostic as _, DiagnosticSink}};\n use ra_db::SourceDatabase;\n use ra_syntax::{\n     Location, SourceFile, SyntaxKind, TextRange, SyntaxNode,\n-    ast::{self, AstNode},\n+    ast::{self, AstNode, NamedFieldList, NamedField},\n };\n+use ra_assists::ast_editor::{AstEditor, AstBuilder};\n use ra_text_edit::{TextEdit, TextEditBuilder};\n use ra_prof::profile;\n \n@@ -48,6 +49,27 @@ pub(crate) fn diagnostics(db: &RootDatabase, file_id: FileId) -> Vec<Diagnostic>\n             severity: Severity::Error,\n             fix: Some(fix),\n         })\n+    })\n+    .on::<hir::diagnostics::MissingFields, _>(|d| {\n+        let file_id = d.file().original_file(db);\n+        let source_file = db.parse(file_id);\n+        let syntax_node = d.syntax_node_ptr();\n+        let node = NamedFieldList::cast(syntax_node.to_node(&source_file)).unwrap();\n+        let mut ast_editor = AstEditor::new(node);\n+        for f in d.missed_fields.iter() {\n+            ast_editor.append_field(&AstBuilder::<NamedField>::from_name(f));\n+        }\n+\n+        let mut builder = TextEditBuilder::default();\n+        ast_editor.into_text_edit(&mut builder);\n+        let fix =\n+            SourceChange::source_file_edit_from(\"fill struct fields\", file_id, builder.finish());\n+        res.borrow_mut().push(Diagnostic {\n+            range: d.highlight_range(),\n+            message: d.message(),\n+            severity: Severity::Error,\n+            fix: Some(fix),\n+        })\n     });\n     if let Some(m) = source_binder::module_from_file_id(db, file_id) {\n         m.diagnostics(db, &mut sink);\n@@ -187,6 +209,105 @@ mod tests {\n         assert_eq_text!(after, &actual);\n     }\n \n+    fn check_apply_diagnostic_fix(before: &str, after: &str) {\n+        let (analysis, file_id) = single_file(before);\n+        let diagnostic = analysis.diagnostics(file_id).unwrap().pop().unwrap();\n+        let mut fix = diagnostic.fix.unwrap();\n+        let edit = fix.source_file_edits.pop().unwrap().edit;\n+        let actual = edit.apply(&before);\n+        assert_eq_text!(after, &actual);\n+    }\n+\n+    fn check_no_diagnostic(content: &str) {\n+        let (analysis, file_id) = single_file(content);\n+        let diagnostics = analysis.diagnostics(file_id).unwrap();\n+        assert_eq!(diagnostics.len(), 0);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_empty() {\n+        let before = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{};\n+            }\n+        \";\n+        let after = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ one: (), two: ()};\n+            }\n+        \";\n+        check_apply_diagnostic_fix(before, after);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_partial() {\n+        let before = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ two: 2 };\n+            }\n+        \";\n+        let after = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+\n+            fn test_fn() {\n+                let s = TestStruct{ two: 2, one: () };\n+            }\n+        \";\n+        check_apply_diagnostic_fix(before, after);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic() {\n+        let content = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+            \n+            fn test_fn() {\n+                let one = 1;\n+                let s = TestStruct{ one, two: 2 };\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n+    #[test]\n+    fn test_fill_struct_fields_no_diagnostic_on_spread() {\n+        let content = r\"\n+            struct TestStruct {\n+                one: i32,\n+                two: i64,\n+            }\n+            \n+            fn test_fn() {\n+                let one = 1;\n+                let s = TestStruct{ ..a };\n+            }\n+        \";\n+\n+        check_no_diagnostic(content);\n+    }\n+\n     #[test]\n     fn test_unresolved_module_diagnostic() {\n         let (analysis, file_id) = single_file(\"mod foo;\");"}, {"sha": "e73fe22e921f9fbb9ea185f9cce23c784e447b8d", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -2371,6 +2371,10 @@ impl NamedFieldList {\n     pub fn fields(&self) -> impl Iterator<Item = &NamedField> {\n         super::children(self)\n     }\n+\n+    pub fn spread(&self) -> Option<&Expr> {\n+        super::child_opt(self)\n+    }\n }\n \n // NeverType\n@@ -3564,10 +3568,6 @@ impl StructLit {\n     pub fn named_field_list(&self) -> Option<&NamedFieldList> {\n         super::child_opt(self)\n     }\n-\n-    pub fn spread(&self) -> Option<&Expr> {\n-        super::child_opt(self)\n-    }\n }\n \n // StructPat"}, {"sha": "b8665bbc8c95c17b962f4ad0fe547e529467d593", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/ef782adc293deb287128f005dbab2038ba3ccdc1/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=ef782adc293deb287128f005dbab2038ba3ccdc1", "patch": "@@ -451,8 +451,11 @@ Grammar(\n             traits: [ \"AttrsOwner\" ]\n         ),\n         \"MatchGuard\": (options: [\"Expr\"]),\n-        \"StructLit\": (options: [\"Path\", \"NamedFieldList\", [\"spread\", \"Expr\"]]),\n-        \"NamedFieldList\": (collections: [ [\"fields\", \"NamedField\"] ]),\n+        \"StructLit\": (options: [\"Path\", \"NamedFieldList\"]),\n+        \"NamedFieldList\": (\n+            collections: [ [\"fields\", \"NamedField\"] ],\n+            options: [[\"spread\", \"Expr\"]]\n+        ),\n         \"NamedField\": (options: [\"NameRef\", \"Expr\"]),\n         \"CallExpr\": (\n             traits: [\"ArgListOwner\"],"}]}