{"sha": "a9d4069975af1ef0192984ad033fd30ceca4fa78", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE5ZDQwNjk5NzVhZjFlZjAxOTI5ODRhZDAzM2ZkMzBjZWNhNGZhNzg=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-02T19:05:41Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2017-06-27T13:39:58Z"}, "message": "rustc_typeck: support functions in variance computation.", "tree": {"sha": "b17f4c1bc8ec65d1192c4f1305bc7a0c231347ab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b17f4c1bc8ec65d1192c4f1305bc7a0c231347ab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a9d4069975af1ef0192984ad033fd30ceca4fa78", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a9d4069975af1ef0192984ad033fd30ceca4fa78", "html_url": "https://github.com/rust-lang/rust/commit/a9d4069975af1ef0192984ad033fd30ceca4fa78", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a9d4069975af1ef0192984ad033fd30ceca4fa78/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "html_url": "https://github.com/rust-lang/rust/commit/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad"}], "stats": {"total": 822, "additions": 317, "deletions": 505}, "files": [{"sha": "2e9780572c9b40bfa8d4ac2a1b1aafee64fb9835", "filename": "src/librustc/ty/relate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Frelate.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -291,7 +291,7 @@ impl<'tcx> Relate<'tcx> for ty::TraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::TraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -308,7 +308,7 @@ impl<'tcx> Relate<'tcx> for ty::ExistentialTraitRef<'tcx> {\n         if a.def_id != b.def_id {\n             Err(TypeError::Traits(expected_found(relation, &a.def_id, &b.def_id)))\n         } else {\n-            let substs = relation.relate_item_substs(a.def_id, a.substs, b.substs)?;\n+            let substs = relate_substs(relation, None, a.substs, b.substs)?;\n             Ok(ty::ExistentialTraitRef { def_id: a.def_id, substs: substs })\n         }\n     }\n@@ -443,7 +443,7 @@ pub fn super_relate_tys<'a, 'gcx, 'tcx, R>(relation: &mut R,\n         (&ty::TyFnDef(a_def_id, a_substs), &ty::TyFnDef(b_def_id, b_substs))\n             if a_def_id == b_def_id =>\n         {\n-            let substs = relate_substs(relation, None, a_substs, b_substs)?;\n+            let substs = relation.relate_item_substs(a_def_id, a_substs, b_substs)?;\n             Ok(tcx.mk_fn_def(a_def_id, substs))\n         }\n "}, {"sha": "e9701b95002d4dc5d4706ffe6e1c94c29a7051cb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -524,7 +524,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -652,7 +656,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if variant.ctor_kind == CtorKind::Fn {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -744,7 +752,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 }\n             },\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if trait_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -821,7 +833,11 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: if impl_item.kind == ty::AssociatedKind::Method {\n+                self.encode_variances_of(def_id)\n+            } else {\n+                LazySeq::empty()\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n \n@@ -1055,7 +1071,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemEnum(..) |\n                 hir::ItemStruct(..) |\n                 hir::ItemUnion(..) |\n-                hir::ItemTrait(..) => self.encode_variances_of(def_id),\n+                hir::ItemFn(..) => self.encode_variances_of(def_id),\n                 _ => LazySeq::empty(),\n             },\n             generics: match item.node {\n@@ -1400,7 +1416,10 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n             ty: Some(self.encode_item_type(def_id)),\n             inherent_impls: LazySeq::empty(),\n-            variances: LazySeq::empty(),\n+            variances: match nitem.node {\n+                hir::ForeignItemFn(..) => self.encode_variances_of(def_id),\n+                _ => LazySeq::empty(),\n+            },\n             generics: Some(self.encode_generics(def_id)),\n             predicates: Some(self.encode_predicates(def_id)),\n "}, {"sha": "f4963619370e41ef2b1cc8f6e746b00596f62ace", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 145, "deletions": 247, "changes": 392, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -14,11 +14,9 @@\n //! We walk the set of items and, for each member, generate new constraints.\n \n use hir::def_id::DefId;\n-use middle::resolve_lifetime as rl;\n use rustc::dep_graph::{AssertDepGraphSafe, DepKind};\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n-use rustc::hir::map as hir_map;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -61,10 +59,10 @@ pub struct Constraint<'a> {\n ///     }\n ///\n /// then while we are visiting `Bar<T>`, the `CurrentItem` would have\n-/// the def-id and generics of `Foo`.\n-pub struct CurrentItem<'a> {\n+/// the def-id and the start of `Foo`'s inferreds.\n+pub struct CurrentItem {\n     def_id: DefId,\n-    generics: &'a ty::Generics,\n+    inferred_start: InferredIndex,\n }\n \n pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n@@ -91,29 +89,71 @@ pub fn add_constraints_from_crate<'a, 'tcx>(terms_cx: TermsContext<'a, 'tcx>)\n \n impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n+        match item.node {\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.visit_node_helper(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.visit_node_helper(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.visit_node_helper(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.visit_node_helper(item.id);\n+            }\n+\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.visit_node_helper(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n+        }\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.visit_node_helper(trait_item.id);\n+        }\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.visit_node_helper(impl_item.id);\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n+    fn visit_node_helper(&mut self, id: ast::NodeId) {\n         let tcx = self.terms_cx.tcx;\n-        let def_id = tcx.hir.local_def_id(item.id);\n+        let def_id = tcx.hir.local_def_id(id);\n \n         // Encapsulate constructing the constraints into a task we can\n         // reference later. This can go away once the red-green\n         // algorithm is in place.\n         //\n         // See README.md for a detailed discussion\n         // on dep-graph management.\n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                tcx.dep_graph.with_task(dep_node,\n-                                        AssertDepGraphSafe(self),\n-                                        def_id,\n-                                        visit_item_task);\n-            }\n-            _ => {\n-                // Nothing to do here, skip the task.\n-            }\n-        }\n+        let dep_node = def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+        tcx.dep_graph.with_task(dep_node,\n+                                AssertDepGraphSafe(self),\n+                                def_id,\n+                                visit_item_task);\n \n         fn visit_item_task<'a, 'tcx>(ccx: AssertDepGraphSafe<&mut ConstraintContext<'a, 'tcx>>,\n                                      def_id: DefId)\n@@ -122,197 +162,57 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for ConstraintContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n-    }\n-\n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n-    }\n-}\n-\n-/// Is `param_id` a lifetime according to `map`?\n-fn is_lifetime(map: &hir_map::Map, param_id: ast::NodeId) -> bool {\n-    match map.find(param_id) {\n-        Some(hir_map::NodeLifetime(..)) => true,\n-        _ => false,\n-    }\n-}\n-\n-impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n         self.terms_cx.tcx\n     }\n \n     fn build_constraints_for_item(&mut self, def_id: DefId) {\n         let tcx = self.tcx();\n-        let id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-        let item = tcx.hir.expect_item(id);\n-        debug!(\"visit_item item={}\", tcx.hir.node_to_string(item.id));\n+        debug!(\"build_constraints_for_item({})\", tcx.item_path_str(def_id));\n \n-        match item.node {\n-            hir::ItemEnum(..) |\n-            hir::ItemStruct(..) |\n-            hir::ItemUnion(..) => {\n-                let generics = tcx.generics_of(def_id);\n-                let current_item = &CurrentItem { def_id, generics };\n+        // Skip items with no generics - there's nothing to infer in them.\n+        if tcx.generics_of(def_id).count() == 0 {\n+            return;\n+        }\n \n+        let id = tcx.hir.as_local_node_id(def_id).unwrap();\n+        let inferred_start = self.terms_cx.inferred_starts[&id];\n+        let current_item = &CurrentItem { def_id, inferred_start };\n+        match tcx.type_of(def_id).sty {\n+            ty::TyAdt(def, _) => {\n                 // Not entirely obvious: constraints on structs/enums do not\n                 // affect the variance of their type parameters. See discussion\n                 // in comment at top of module.\n                 //\n                 // self.add_constraints_from_generics(generics);\n \n-                for field in tcx.adt_def(def_id).all_fields() {\n+                for field in def.all_fields() {\n                     self.add_constraints_from_ty(current_item,\n                                                  tcx.type_of(field.did),\n                                                  self.covariant);\n                 }\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemDefaultImpl(..) => {\n-                span_bug!(item.span, \"`build_constraints_for_item` invoked for non-type-def\");\n+            ty::TyFnDef(..) => {\n+                self.add_constraints_from_sig(current_item,\n+                                              tcx.fn_sig(def_id),\n+                                              self.covariant);\n             }\n-        }\n-    }\n-\n-    /// Load the generics for another item, adding a corresponding\n-    /// relation into the dependencies to indicate that the variance\n-    /// for `current` relies on `def_id`.\n-    fn read_generics(&mut self, current: &CurrentItem, def_id: DefId) -> &'tcx ty::Generics {\n-        let generics = self.tcx().generics_of(def_id);\n-        if self.tcx().dep_graph.is_fully_enabled() {\n-            self.dependencies.add(current.def_id, def_id);\n-        }\n-        generics\n-    }\n \n-    fn opt_inferred_index(&self, param_id: ast::NodeId) -> Option<&InferredIndex> {\n-        self.terms_cx.inferred_map.get(&param_id)\n-    }\n-\n-    fn find_binding_for_lifetime(&self, param_id: ast::NodeId) -> ast::NodeId {\n-        let tcx = self.terms_cx.tcx;\n-        assert!(is_lifetime(&tcx.hir, param_id));\n-        match tcx.named_region_map.defs.get(&param_id) {\n-            Some(&rl::Region::EarlyBound(_, lifetime_decl_id)) => lifetime_decl_id,\n-            Some(_) => bug!(\"should not encounter non early-bound cases\"),\n-\n-            // The lookup should only fail when `param_id` is\n-            // itself a lifetime binding: use it as the decl_id.\n-            None => param_id,\n-        }\n-\n-    }\n-\n-    /// Is `param_id` a type parameter for which we infer variance?\n-    fn is_to_be_inferred(&self, param_id: ast::NodeId) -> bool {\n-        let result = self.terms_cx.inferred_map.contains_key(&param_id);\n-\n-        // To safe-guard against invalid inferred_map constructions,\n-        // double-check if variance is inferred at some use of a type\n-        // parameter (by inspecting parent of its binding declaration\n-        // to see if it is introduced by a type or by a fn/impl).\n-\n-        let check_result = |this: &ConstraintContext| -> bool {\n-            let tcx = this.terms_cx.tcx;\n-            let decl_id = this.find_binding_for_lifetime(param_id);\n-            // Currently only called on lifetimes; double-checking that.\n-            assert!(is_lifetime(&tcx.hir, param_id));\n-            let parent_id = tcx.hir.get_parent(decl_id);\n-            let parent = tcx.hir\n-                .find(parent_id)\n-                .unwrap_or_else(|| bug!(\"tcx.hir missing entry for id: {}\", parent_id));\n-\n-            let is_inferred;\n-            macro_rules! cannot_happen { () => { {\n-                bug!(\"invalid parent: {} for {}\",\n-                     tcx.hir.node_to_string(parent_id),\n-                     tcx.hir.node_to_string(param_id));\n-            } } }\n-\n-            match parent {\n-                hir_map::NodeItem(p) => {\n-                    match p.node {\n-                        hir::ItemTy(..) |\n-                        hir::ItemEnum(..) |\n-                        hir::ItemStruct(..) |\n-                        hir::ItemUnion(..) |\n-                        hir::ItemTrait(..) => is_inferred = true,\n-                        hir::ItemFn(..) => is_inferred = false,\n-                        _ => cannot_happen!(),\n-                    }\n-                }\n-                hir_map::NodeTraitItem(..) => is_inferred = false,\n-                hir_map::NodeImplItem(..) => is_inferred = false,\n-                _ => cannot_happen!(),\n-            }\n-\n-            return is_inferred;\n-        };\n-\n-        assert_eq!(result, check_result(self));\n-\n-        return result;\n-    }\n-\n-    /// Returns a variance term representing the declared variance of the type/region parameter\n-    /// with the given id.\n-    fn declared_variance(&self,\n-                         param_def_id: DefId,\n-                         item_def_id: DefId,\n-                         index: usize)\n-                         -> VarianceTermPtr<'a> {\n-        assert_eq!(param_def_id.krate, item_def_id.krate);\n-\n-        if let Some(param_node_id) = self.tcx().hir.as_local_node_id(param_def_id) {\n-            // Parameter on an item defined within current crate:\n-            // variance not yet inferred, so return a symbolic\n-            // variance.\n-            if let Some(&InferredIndex(index)) = self.opt_inferred_index(param_node_id) {\n-                self.terms_cx.inferred_infos[index].term\n-            } else {\n-                // If there is no inferred entry for a type parameter,\n-                // it must be declared on a (locally defiend) trait -- they don't\n-                // get inferreds because they are always invariant.\n-                if cfg!(debug_assertions) {\n-                    let item_node_id = self.tcx().hir.as_local_node_id(item_def_id).unwrap();\n-                    let item = self.tcx().hir.expect_item(item_node_id);\n-                    let success = match item.node {\n-                        hir::ItemTrait(..) => true,\n-                        _ => false,\n-                    };\n-                    if !success {\n-                        bug!(\"parameter {:?} has no inferred, but declared on non-trait: {:?}\",\n-                             item_def_id,\n-                             item);\n-                    }\n-                }\n-                self.invariant\n+            _ => {\n+                span_bug!(tcx.def_span(def_id),\n+                          \"`build_constraints_for_item` unsupported for this item\");\n             }\n-        } else {\n-            // Parameter on an item defined within another crate:\n-            // variance already inferred, just look it up.\n-            let variances = self.tcx().variances_of(item_def_id);\n-            self.constant_term(variances[index])\n         }\n     }\n \n     fn add_constraint(&mut self,\n-                      InferredIndex(index): InferredIndex,\n+                      current: &CurrentItem,\n+                      index: u32,\n                       variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraint(index={}, variance={:?})\", index, variance);\n         self.constraints.push(Constraint {\n-            inferred: InferredIndex(index),\n+            inferred: InferredIndex(current.inferred_start.0 + index as usize),\n             variance: variance,\n         });\n     }\n@@ -354,15 +254,26 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         debug!(\"add_constraints_from_trait_ref: trait_ref={:?} variance={:?}\",\n                trait_ref,\n                variance);\n+        self.add_constraints_from_invariant_substs(current, trait_ref.substs, variance);\n+    }\n \n-        let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n+    fn add_constraints_from_invariant_substs(&mut self,\n+                                             current: &CurrentItem,\n+                                             substs: &Substs<'tcx>,\n+                                             variance: VarianceTermPtr<'a>) {\n+        debug!(\"add_constraints_from_invariant_substs: substs={:?} variance={:?}\",\n+               substs,\n+               variance);\n \n-        self.add_constraints_from_substs(current,\n-                                         trait_ref.def_id,\n-                                         &trait_generics.types,\n-                                         &trait_generics.regions,\n-                                         trait_ref.substs,\n-                                         variance);\n+        // Trait are always invariant so we can take advantage of that.\n+        let variance_i = self.invariant(variance);\n+        for ty in substs.types() {\n+            self.add_constraints_from_ty(current, ty, variance_i);\n+        }\n+\n+        for region in substs.regions() {\n+            self.add_constraints_from_region(current, region, variance_i);\n+        }\n     }\n \n     /// Adds constraints appropriate for an instance of `ty` appearing\n@@ -383,8 +294,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyFnDef(..) |\n-            ty::TyClosure(..) |\n-            ty::TyAnon(..) => {\n+            ty::TyClosure(..) => {\n                 bug!(\"Unexpected closure type in variance computation\");\n             }\n \n@@ -410,26 +320,15 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyAdt(def, substs) => {\n-                let adt_generics = self.read_generics(current, def.did);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 def.did,\n-                                                 &adt_generics.types,\n-                                                 &adt_generics.regions,\n-                                                 substs,\n-                                                 variance);\n+                self.add_constraints_from_substs(current, def.did, substs, variance);\n             }\n \n             ty::TyProjection(ref data) => {\n-                let trait_ref = &data.trait_ref;\n-                let trait_generics = self.tcx().generics_of(trait_ref.def_id);\n-\n-                self.add_constraints_from_substs(current,\n-                                                 trait_ref.def_id,\n-                                                 &trait_generics.types,\n-                                                 &trait_generics.regions,\n-                                                 trait_ref.substs,\n-                                                 variance);\n+                self.add_constraints_from_trait_ref(current, data.trait_ref, variance);\n+            }\n+\n+            ty::TyAnon(_, substs) => {\n+                self.add_constraints_from_invariant_substs(current, substs, variance);\n             }\n \n             ty::TyDynamic(ref data, r) => {\n@@ -448,23 +347,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             }\n \n             ty::TyParam(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let mut i = data.idx as usize;\n-                if !current.generics.has_self || i > 0 {\n-                    i -= current.generics.regions.len();\n-                }\n-                let def_id = current.generics.types[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                match self.terms_cx.inferred_map.get(&node_id) {\n-                    Some(&index) => {\n-                        self.add_constraint(index, variance);\n-                    }\n-                    None => {\n-                        // We do not infer variance for type parameters\n-                        // declared on methods. They will not be present\n-                        // in the inferred_map.\n-                    }\n-                }\n+                self.add_constraint(current, data.idx, variance);\n             }\n \n             ty::TyFnPtr(sig) => {\n@@ -489,30 +372,52 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n     fn add_constraints_from_substs(&mut self,\n                                    current: &CurrentItem,\n                                    def_id: DefId,\n-                                   type_param_defs: &[ty::TypeParameterDef],\n-                                   region_param_defs: &[ty::RegionParameterDef],\n                                    substs: &Substs<'tcx>,\n                                    variance: VarianceTermPtr<'a>) {\n         debug!(\"add_constraints_from_substs(def_id={:?}, substs={:?}, variance={:?})\",\n                def_id,\n                substs,\n                variance);\n \n-        for p in type_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n+        // We don't record `inferred_starts` entries for empty generics.\n+        if substs.is_empty() {\n+            return;\n+        }\n+\n+        // Add a corresponding relation into the dependencies to\n+        // indicate that the variance for `current` relies on `def_id`.\n+        if self.tcx().dep_graph.is_fully_enabled() {\n+            self.dependencies.add(current.def_id, def_id);\n+        }\n+\n+        let (local, remote) = if let Some(id) = self.tcx().hir.as_local_node_id(def_id) {\n+            (Some(self.terms_cx.inferred_starts[&id]), None)\n+        } else {\n+            (None, Some(self.tcx().variances_of(def_id)))\n+        };\n+\n+        for (i, k) in substs.iter().enumerate() {\n+            let variance_decl = if let Some(InferredIndex(start)) = local {\n+                // Parameter on an item defined within current crate:\n+                // variance not yet inferred, so return a symbolic\n+                // variance.\n+                self.terms_cx.inferred_terms[start + i]\n+            } else {\n+                // Parameter on an item defined within another crate:\n+                // variance already inferred, just look it up.\n+                self.constant_term(remote.as_ref().unwrap()[i])\n+            };\n             let variance_i = self.xform(variance, variance_decl);\n-            let substs_ty = substs.type_for_def(p);\n             debug!(\"add_constraints_from_substs: variance_decl={:?} variance_i={:?}\",\n                    variance_decl,\n                    variance_i);\n-            self.add_constraints_from_ty(current, substs_ty, variance_i);\n-        }\n-\n-        for p in region_param_defs {\n-            let variance_decl = self.declared_variance(p.def_id, def_id, p.index as usize);\n-            let variance_i = self.xform(variance, variance_decl);\n-            let substs_r = substs.region_for_def(p);\n-            self.add_constraints_from_region(current, substs_r, variance_i);\n+            if let Some(ty) = k.as_type() {\n+                self.add_constraints_from_ty(current, ty, variance_i);\n+            } else if let Some(r) = k.as_region() {\n+                self.add_constraints_from_region(current, r, variance_i);\n+            } else {\n+                bug!();\n+            }\n         }\n     }\n \n@@ -537,21 +442,14 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                                    variance: VarianceTermPtr<'a>) {\n         match *region {\n             ty::ReEarlyBound(ref data) => {\n-                assert_eq!(current.generics.parent, None);\n-                let i = data.index as usize - current.generics.has_self as usize;\n-                let def_id = current.generics.regions[i].def_id;\n-                let node_id = self.tcx().hir.as_local_node_id(def_id).unwrap();\n-                if self.is_to_be_inferred(node_id) {\n-                    let &index = self.opt_inferred_index(node_id).unwrap();\n-                    self.add_constraint(index, variance);\n-                }\n+                self.add_constraint(current, data.index, variance);\n             }\n \n             ty::ReStatic => {}\n \n             ty::ReLateBound(..) => {\n-                // We do not infer variance for region parameters on\n-                // methods or in fn types.\n+                // Late-bound regions do not get substituted the same\n+                // way early-bound regions do, so we skip them here.\n             }\n \n             ty::ReFree(..) |"}, {"sha": "7a9f35545e2f383defa9c09444aac638c0793c63", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 53, "deletions": 35, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -54,45 +54,63 @@ fn crate_variances<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, crate_num: CrateNum)\n \n fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n                             -> Rc<Vec<ty::Variance>> {\n-    let item_id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n-    let item = tcx.hir.expect_item(item_id);\n-    match item.node {\n-        hir::ItemTrait(..) => {\n-            // Traits are always invariant.\n-            let generics = tcx.generics_of(item_def_id);\n-            assert!(generics.parent.is_none());\n-            Rc::new(vec![ty::Variance::Invariant; generics.count()])\n-        }\n+    let id = tcx.hir.as_local_node_id(item_def_id).expect(\"expected local def-id\");\n+    let unsupported = || {\n+        // Variance not relevant.\n+        span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n+    };\n+    match tcx.hir.get(id) {\n+        hir::map::NodeItem(item) => match item.node {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) |\n+            hir::ItemFn(..) => {}\n \n-        hir::ItemEnum(..) |\n-        hir::ItemStruct(..) |\n-        hir::ItemUnion(..) => {\n-            // Everything else must be inferred.\n+            _ => unsupported()\n+        },\n \n-            // Lacking red/green, we read the variances for all items here\n-            // but ignore the dependencies, then re-synthesize the ones we need.\n-            let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n-            let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-            tcx.dep_graph.read(dep_node);\n-            for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n-                if dep_def_id.is_local() {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n-                    tcx.dep_graph.read(dep_node);\n-                } else {\n-                    let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n-                    tcx.dep_graph.read(dep_node);\n-                }\n-            }\n-\n-            crate_map.variances.get(&item_def_id)\n-                               .unwrap_or(&crate_map.empty_variance)\n-                               .clone()\n-        }\n+        hir::map::NodeTraitItem(item) => match item.node {\n+            hir::TraitItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeImplItem(item) => match item.node {\n+            hir::ImplItemKind::Method(..) => {}\n+\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeForeignItem(item) => match item.node {\n+            hir::ForeignItemFn(..) => {}\n \n-        _ => {\n-            // Variance not relevant.\n-            span_bug!(item.span, \"asked to compute variance for wrong kind of item\")\n+            _ => unsupported()\n+        },\n+\n+        hir::map::NodeVariant(_) | hir::map::NodeStructCtor(_) => {}\n+\n+        _ => unsupported()\n+    }\n+\n+    // Everything else must be inferred.\n+\n+    // Lacking red/green, we read the variances for all items here\n+    // but ignore the dependencies, then re-synthesize the ones we need.\n+    let crate_map = tcx.dep_graph.with_ignore(|| tcx.crate_variances(LOCAL_CRATE));\n+    let dep_node = item_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+    tcx.dep_graph.read(dep_node);\n+    for &dep_def_id in crate_map.dependencies.less_than(&item_def_id) {\n+        if dep_def_id.is_local() {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVarianceConstraints);\n+            tcx.dep_graph.read(dep_node);\n+        } else {\n+            let dep_node = dep_def_id.to_dep_node(tcx, DepKind::ItemVariances);\n+            tcx.dep_graph.read(dep_node);\n         }\n     }\n+\n+    crate_map.variances.get(&item_def_id)\n+                       .unwrap_or(&crate_map.empty_variance)\n+                       .clone()\n }\n "}, {"sha": "495eb95419a90876581ef3165507f97373e7c417", "filename": "src/librustc_typeck/variance/solve.rs", "status": "modified", "additions": 26, "deletions": 47, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fsolve.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -36,15 +36,18 @@ struct SolveContext<'a, 'tcx: 'a> {\n pub fn solve_constraints(constraints_cx: ConstraintContext) -> ty::CrateVariancesMap {\n     let ConstraintContext { terms_cx, dependencies, constraints, .. } = constraints_cx;\n \n-    let solutions = terms_cx.inferred_infos\n-        .iter()\n-        .map(|ii| ii.initial_variance)\n-        .collect();\n+    let mut solutions = vec![ty::Bivariant; terms_cx.inferred_terms.len()];\n+    for &(id, ref variances) in &terms_cx.lang_items {\n+        let InferredIndex(start) = terms_cx.inferred_starts[&id];\n+        for (i, &variance) in variances.iter().enumerate() {\n+            solutions[start + i] = variance;\n+        }\n+    }\n \n     let mut solutions_cx = SolveContext {\n-        terms_cx: terms_cx,\n-        constraints: constraints,\n-        solutions: solutions,\n+        terms_cx,\n+        constraints,\n+        solutions,\n     };\n     solutions_cx.solve();\n     let variances = solutions_cx.create_map();\n@@ -71,12 +74,9 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n                 let old_value = self.solutions[inferred];\n                 let new_value = glb(variance, old_value);\n                 if old_value != new_value {\n-                    debug!(\"Updating inferred {} (node {}) \\\n+                    debug!(\"Updating inferred {} \\\n                             from {:?} to {:?} due to {:?}\",\n                            inferred,\n-                           self.terms_cx\n-                                   .inferred_infos[inferred]\n-                               .param_id,\n                            old_value,\n                            new_value,\n                            term);\n@@ -89,49 +89,28 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n     }\n \n     fn create_map(&self) -> FxHashMap<DefId, Rc<Vec<ty::Variance>>> {\n-        // Collect all the variances for a particular item and stick\n-        // them into the variance map. We rely on the fact that we\n-        // generate all the inferreds for a particular item\n-        // consecutively (that is, we collect solutions for an item\n-        // until we see a new item id, and we assume (1) the solutions\n-        // are in the same order as the type parameters were declared\n-        // and (2) all solutions or a given item appear before a new\n-        // item id).\n-\n         let tcx = self.terms_cx.tcx;\n \n-        let mut map = FxHashMap();\n-\n         let solutions = &self.solutions;\n-        let inferred_infos = &self.terms_cx.inferred_infos;\n-        let mut index = 0;\n-        let num_inferred = self.terms_cx.num_inferred();\n-        while index < num_inferred {\n-            let item_id = inferred_infos[index].item_id;\n-\n-            let mut item_variances = vec![];\n-\n-            while index < num_inferred && inferred_infos[index].item_id == item_id {\n-                let info = &inferred_infos[index];\n-                let variance = solutions[index];\n-                debug!(\"Index {} Info {} Variance {:?}\",\n-                       index,\n-                       info.index,\n-                       variance);\n-\n-                assert_eq!(item_variances.len(), info.index);\n-                item_variances.push(variance);\n-                index += 1;\n-            }\n+        self.terms_cx.inferred_starts.iter().map(|(&id, &InferredIndex(start))| {\n+            let def_id = tcx.hir.local_def_id(id);\n+            let generics = tcx.generics_of(def_id);\n \n-            debug!(\"item_id={} item_variances={:?}\", item_id, item_variances);\n+            let mut variances = solutions[start..start+generics.count()].to_vec();\n \n-            let item_def_id = tcx.hir.local_def_id(item_id);\n+            debug!(\"id={} variances={:?}\", id, variances);\n \n-            map.insert(item_def_id, Rc::new(item_variances));\n-        }\n+            // Functions can have unused type parameters: make those invariant.\n+            if let ty::TyFnDef(..) = tcx.type_of(def_id).sty {\n+                for variance in &mut variances {\n+                    if *variance == ty::Bivariant {\n+                        *variance = ty::Invariant;\n+                    }\n+                }\n+            }\n \n-        map\n+            (def_id, Rc::new(variances))\n+        }).collect()\n     }\n \n     fn evaluate(&self, term: VarianceTermPtr<'a>) -> ty::Variance {"}, {"sha": "38457146a9714deebfa958aafa42959bed515e39", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 61, "deletions": 99, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -22,7 +22,6 @@\n use arena::TypedArena;\n use rustc::ty::{self, TyCtxt};\n use std::fmt;\n-use std::rc::Rc;\n use syntax::ast;\n use rustc::hir;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -63,31 +62,17 @@ pub struct TermsContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pub arena: &'a TypedArena<VarianceTerm<'a>>,\n \n-    pub empty_variances: Rc<Vec<ty::Variance>>,\n-\n     // For marker types, UnsafeCell, and other lang items where\n     // variance is hardcoded, records the item-id and the hardcoded\n     // variance.\n     pub lang_items: Vec<(ast::NodeId, Vec<ty::Variance>)>,\n \n-    // Maps from the node id of a type/generic parameter to the\n-    // corresponding inferred index.\n-    pub inferred_map: NodeMap<InferredIndex>,\n-\n-    // Maps from an InferredIndex to the info for that variable.\n-    pub inferred_infos: Vec<InferredInfo<'a>>,\n-}\n-\n-pub struct InferredInfo<'a> {\n-    pub item_id: ast::NodeId,\n-    pub index: usize,\n-    pub param_id: ast::NodeId,\n-    pub term: VarianceTermPtr<'a>,\n+    // Maps from the node id of an item to the first inferred index\n+    // used for its type & region parameters.\n+    pub inferred_starts: NodeMap<InferredIndex>,\n \n-    // Initial value to use for this parameter when inferring\n-    // variance. For most parameters, this is Bivariant. But for lang\n-    // items and input type parameters on traits, it is different.\n-    pub initial_variance: ty::Variance,\n+    // Maps from an InferredIndex to the term for that variable.\n+    pub inferred_terms: Vec<VarianceTermPtr<'a>>,\n }\n \n pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -96,14 +81,10 @@ pub fn determine_parameters_to_be_inferred<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>\n     let mut terms_cx = TermsContext {\n         tcx: tcx,\n         arena: arena,\n-        inferred_map: NodeMap(),\n-        inferred_infos: Vec::new(),\n+        inferred_starts: NodeMap(),\n+        inferred_terms: vec![],\n \n         lang_items: lang_items(tcx),\n-\n-        // cache and share the variance struct used for items with\n-        // no type/region parameters\n-        empty_variances: Rc::new(vec![]),\n     };\n \n     // See README.md for a discussion on dep-graph management.\n@@ -135,67 +116,28 @@ fn lang_items(tcx: TyCtxt) -> Vec<(ast::NodeId, Vec<ty::Variance>)> {\n }\n \n impl<'a, 'tcx> TermsContext<'a, 'tcx> {\n-    fn add_inferreds_for_item(&mut self,\n-                              item_id: ast::NodeId,\n-                              generics: &hir::Generics) {\n-        //! Add \"inferreds\" for the generic parameters declared on this\n-        //! item. This has a lot of annoying parameters because we are\n-        //! trying to drive this from the AST, rather than the\n-        //! ty::Generics, so that we can get span info -- but this\n-        //! means we must accommodate syntactic distinctions.\n-        //!\n+    fn add_inferreds_for_item(&mut self, id: ast::NodeId) {\n+        let tcx = self.tcx;\n+        let def_id = tcx.hir.local_def_id(id);\n+        let count = tcx.generics_of(def_id).count();\n \n-        // NB: In the code below for writing the results back into the\n-        // `CrateVariancesMap`, we rely on the fact that all inferreds\n-        // for a particular item are assigned continuous indices.\n-\n-        for (p, i) in generics.lifetimes.iter().zip(0..) {\n-            let id = p.lifetime.id;\n-            self.add_inferred(item_id, i, id);\n-        }\n-\n-        for (p, i) in generics.ty_params.iter().zip(generics.lifetimes.len()..) {\n-            self.add_inferred(item_id, i, p.id);\n+        if count == 0 {\n+            return;\n         }\n-    }\n \n-    fn add_inferred(&mut self, item_id: ast::NodeId, index: usize, param_id: ast::NodeId) {\n-        let inf_index = InferredIndex(self.inferred_infos.len());\n-        let term = self.arena.alloc(InferredTerm(inf_index));\n-        let initial_variance = self.pick_initial_variance(item_id, index);\n-        self.inferred_infos.push(InferredInfo {\n-            item_id: item_id,\n-            index: index,\n-            param_id: param_id,\n-            term: term,\n-            initial_variance: initial_variance,\n-        });\n-        let newly_added = self.inferred_map.insert(param_id, inf_index).is_none();\n+        // Record the start of this item's inferreds.\n+        let start = self.inferred_terms.len();\n+        let newly_added = self.inferred_starts.insert(id, InferredIndex(start)).is_none();\n         assert!(newly_added);\n \n-        debug!(\"add_inferred(item_path={}, \\\n-                item_id={}, \\\n-                index={}, \\\n-                param_id={}, \\\n-                inf_index={:?}, \\\n-                initial_variance={:?})\",\n-               self.tcx.item_path_str(self.tcx.hir.local_def_id(item_id)),\n-               item_id,\n-               index,\n-               param_id,\n-               inf_index,\n-               initial_variance);\n-    }\n-\n-    fn pick_initial_variance(&self, item_id: ast::NodeId, index: usize) -> ty::Variance {\n-        match self.lang_items.iter().find(|&&(n, _)| n == item_id) {\n-            Some(&(_, ref variances)) => variances[index],\n-            None => ty::Bivariant,\n-        }\n-    }\n+        // NB: In the code below for writing the results back into the\n+        // `CrateVariancesMap`, we rely on the fact that all inferreds\n+        // for a particular item are assigned continuous indices.\n \n-    pub fn num_inferred(&self) -> usize {\n-        self.inferred_infos.len()\n+        let arena = self.arena;\n+        self.inferred_terms.extend((start..start+count).map(|i| {\n+            &*arena.alloc(InferredTerm(InferredIndex(i)))\n+        }));\n     }\n }\n \n@@ -205,30 +147,50 @@ impl<'a, 'tcx, 'v> ItemLikeVisitor<'v> for TermsContext<'a, 'tcx> {\n                self.tcx.hir.node_to_string(item.id));\n \n         match item.node {\n-            hir::ItemEnum(_, ref generics) |\n-            hir::ItemStruct(_, ref generics) |\n-            hir::ItemUnion(_, ref generics) => {\n-                self.add_inferreds_for_item(item.id, generics);\n+            hir::ItemStruct(ref struct_def, _) |\n+            hir::ItemUnion(ref struct_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                if let hir::VariantData::Tuple(..) = *struct_def {\n+                    self.add_inferreds_for_item(struct_def.id());\n+                }\n+            }\n+\n+            hir::ItemEnum(ref enum_def, _) => {\n+                self.add_inferreds_for_item(item.id);\n+\n+                for variant in &enum_def.variants {\n+                    if let hir::VariantData::Tuple(..) = variant.node.data {\n+                        self.add_inferreds_for_item(variant.node.data.id());\n+                    }\n+                }\n+            }\n+\n+            hir::ItemFn(..) => {\n+                self.add_inferreds_for_item(item.id);\n             }\n \n-            hir::ItemTrait(..) |\n-            hir::ItemExternCrate(_) |\n-            hir::ItemUse(..) |\n-            hir::ItemDefaultImpl(..) |\n-            hir::ItemImpl(..) |\n-            hir::ItemStatic(..) |\n-            hir::ItemConst(..) |\n-            hir::ItemFn(..) |\n-            hir::ItemMod(..) |\n-            hir::ItemForeignMod(..) |\n-            hir::ItemGlobalAsm(..) |\n-            hir::ItemTy(..) => {}\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if let hir::ForeignItemFn(..) = foreign_item.node {\n+                        self.add_inferreds_for_item(foreign_item.id);\n+                    }\n+                }\n+            }\n+\n+            _ => {}\n         }\n     }\n \n-    fn visit_trait_item(&mut self, _trait_item: &hir::TraitItem) {\n+    fn visit_trait_item(&mut self, trait_item: &hir::TraitItem) {\n+        if let hir::TraitItemKind::Method(..) = trait_item.node {\n+            self.add_inferreds_for_item(trait_item.id);\n+        }\n     }\n \n-    fn visit_impl_item(&mut self, _impl_item: &hir::ImplItem) {\n+    fn visit_impl_item(&mut self, impl_item: &hir::ImplItem) {\n+        if let hir::ImplItemKind::Method(..) = impl_item.node {\n+            self.add_inferreds_for_item(impl_item.id);\n+        }\n     }\n }"}, {"sha": "41d204a541b5ad9b4481dd1fe51abff1d3afb359", "filename": "src/test/compile-fail/variance-region-bounds.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-region-bounds.rs?ref=33ecf72e8e26b5bf5449ae27297e83c9f78aa3ad", "patch": "@@ -1,25 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Check that `T:'a` is contravariant in T.\n-\n-#![feature(rustc_attrs)]\n-\n-#[rustc_variance]\n-trait Foo: 'static { //~ ERROR [o]\n-}\n-\n-#[rustc_variance]\n-trait Bar<T> { //~ ERROR [o, o]\n-    fn do_it(&self)\n-        where T: 'static;\n-}\n-\n-fn main() { }"}, {"sha": "9b88e38e085546feb68ef1435e7aa7a66334b182", "filename": "src/test/compile-fail/variance-trait-bounds.rs", "status": "modified", "additions": 2, "deletions": 18, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-trait-bounds.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -14,13 +14,11 @@\n // Check that bounds on type parameters (other than `Self`) do not\n // influence variance.\n \n-#[rustc_variance]\n-trait Getter<T> { //~ ERROR [o, o]\n+trait Getter<T> {\n     fn get(&self) -> T;\n }\n \n-#[rustc_variance]\n-trait Setter<T> { //~ ERROR [o, o]\n+trait Setter<T> {\n     fn get(&self, T);\n }\n \n@@ -34,20 +32,6 @@ enum TestEnum<U,T:Setter<U>> { //~ ERROR [*, +]\n     Foo(T)\n }\n \n-#[rustc_variance]\n-trait TestTrait<U,T:Setter<U>> { //~ ERROR [o, o, o]\n-    fn getter(&self, u: U) -> T;\n-}\n-\n-#[rustc_variance]\n-trait TestTrait2<U> : Getter<U> { //~ ERROR [o, o]\n-}\n-\n-#[rustc_variance]\n-trait TestTrait3<U> { //~ ERROR [o, o]\n-    fn getter<T:Getter<U>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestContraStruct<U,T:Setter<U>> { //~ ERROR [*, +]\n     t: T"}, {"sha": "5075dd2ceedc093ba972f70c5d952e6332bdc508", "filename": "src/test/compile-fail/variance-types-bounds.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a9d4069975af1ef0192984ad033fd30ceca4fa78/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fvariance-types-bounds.rs?ref=a9d4069975af1ef0192984ad033fd30ceca4fa78", "patch": "@@ -36,37 +36,14 @@ struct TestIndirect2<A:'static, B:'static> { //~ ERROR [o, o]\n     m: TestMut<B, A>\n }\n \n-#[rustc_variance]\n-trait Getter<A> { //~ ERROR [o, o]\n+trait Getter<A> {\n     fn get(&self) -> A;\n }\n \n-#[rustc_variance]\n-trait Setter<A> { //~ ERROR [o, o]\n-    fn set(&mut self, a: A);\n-}\n-\n-#[rustc_variance]\n-trait GetterSetter<A> { //~ ERROR [o, o]\n-    fn get(&self) -> A;\n+trait Setter<A> {\n     fn set(&mut self, a: A);\n }\n \n-#[rustc_variance]\n-trait GetterInTypeBound<A> { //~ ERROR [o, o]\n-    // Here, the use of `A` in the method bound *does* affect\n-    // variance.  Think of it as if the method requested a dictionary\n-    // for `T:Getter<A>`.  Since this dictionary is an input, it is\n-    // contravariant, and the Getter is covariant w/r/t A, yielding an\n-    // overall contravariant result.\n-    fn do_it<T:Getter<A>>(&self);\n-}\n-\n-#[rustc_variance]\n-trait SetterInTypeBound<A> { //~ ERROR [o, o]\n-    fn do_it<T:Setter<A>>(&self);\n-}\n-\n #[rustc_variance]\n struct TestObject<A, R> { //~ ERROR [o, o]\n     n: Box<Setter<A>+Send>,"}]}