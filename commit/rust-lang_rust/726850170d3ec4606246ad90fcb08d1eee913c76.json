{"sha": "726850170d3ec4606246ad90fcb08d1eee913c76", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNjg1MDE3MGQzZWM0NjA2MjQ2YWQ5MGZjYjA4ZDFlZWU5MTNjNzY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-09-15T12:46:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-09-15T12:46:19Z"}, "message": "Rollup merge of #36384 - petrochenkov:derclone, r=alexcrichton\n\nImprove shallow `Clone` deriving\n\n`Copy` unions now support `#[derive(Clone)]`.\nLess code is generated for `#[derive(Clone, Copy)]`.\n+\nUnions now support `#[derive(Eq)]`.\nLess code is generated for `#[derive(Eq)]`.\n\n---\nExample of code reduction:\n```\nenum E {\n\tA { a: u8, b: u16 },\n\tB { c: [u8; 100] },\n}\n```\nBefore:\n```\nfn clone(&self) -> E {\n    match (&*self,) {\n        (&E::A { a: ref __self_0, b: ref __self_1 },) => {\n            ::std::clone::assert_receiver_is_clone(&(*__self_0));\n            ::std::clone::assert_receiver_is_clone(&(*__self_1));\n            *self\n        }\n        (&E::B { c: ref __self_0 },) => {\n            ::std::clone::assert_receiver_is_clone(&(*__self_0));\n            *self\n        }\n    }\n}\n```\nAfter:\n```\nfn clone(&self) -> E {\n    {\n        let _: ::std::clone::AssertParamIsClone<u8>;\n        let _: ::std::clone::AssertParamIsClone<u16>;\n        let _: ::std::clone::AssertParamIsClone<[u8; 100]>;\n        *self\n    }\n}\n```\n\nAll the matches are removed, bound assertions are more lightweight.\n`let _: Checker<CheckMe>;`, unlike `checker(&check_me);`, doesn't have to be translated by rustc_trans and then inlined by LLVM, it doesn't even exist in MIR, this means faster compilation.\n\n---\nUnion impls are generated like this:\n```\nunion U {\n\ta: u8,\n\tb: u16,\n\tc: [u8; 100],\n}\n```\n```\nfn clone(&self) -> U {\n    {\n        let _: ::std::clone::AssertParamIsCopy<Self>;\n        *self\n    }\n}\n```\n\nFixes https://github.com/rust-lang/rust/issues/36043\ncc @durka\nr? @alexcrichton", "tree": {"sha": "fdffde4c348f7388797f45de4501e5a0ca91ba43", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fdffde4c348f7388797f45de4501e5a0ca91ba43"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/726850170d3ec4606246ad90fcb08d1eee913c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/726850170d3ec4606246ad90fcb08d1eee913c76", "html_url": "https://github.com/rust-lang/rust/commit/726850170d3ec4606246ad90fcb08d1eee913c76", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/726850170d3ec4606246ad90fcb08d1eee913c76/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "16ff9e22cdb552fd10e6cee2eb22f0c5da6d7e79", "url": "https://api.github.com/repos/rust-lang/rust/commits/16ff9e22cdb552fd10e6cee2eb22f0c5da6d7e79", "html_url": "https://github.com/rust-lang/rust/commit/16ff9e22cdb552fd10e6cee2eb22f0c5da6d7e79"}, {"sha": "62cb7510ac6285c93ec691198a92f910582d31a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/62cb7510ac6285c93ec691198a92f910582d31a2", "html_url": "https://github.com/rust-lang/rust/commit/62cb7510ac6285c93ec691198a92f910582d31a2"}], "stats": {"total": 414, "additions": 293, "deletions": 121}, "files": [{"sha": "0b800cacfc19adbd41909051c8c233b1ef5f83f1", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -113,10 +113,23 @@ pub trait Clone : Sized {\n     }\n }\n \n-// FIXME(aburka): this method is used solely by #[derive] to\n-// assert that every component of a type implements Clone.\n+// FIXME(aburka): these structs are used solely by #[derive] to\n+// assert that every component of a type implements Clone or Copy.\n //\n-// This should never be called by user code.\n+// These structs should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsClone<T: Clone + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_clone_copy\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsCopy<T: Copy + ?Sized> { _field: ::marker::PhantomData<T> }\n+#[cfg(stage0)]\n #[doc(hidden)]\n #[inline(always)]\n #[unstable(feature = \"derive_clone_copy\","}, {"sha": "f990a27e52b3190b8a00fd6840b7ad75ee546f62", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -129,7 +129,7 @@ pub trait PartialEq<Rhs: ?Sized = Self> {\n /// This trait can be used with `#[derive]`. When `derive`d, because `Eq` has\n /// no extra methods, it is only informing the compiler that this is an\n /// equivalence relation rather than a partial equivalence relation. Note that\n-/// the `derive` strategy requires all fields are `PartialEq`, which isn't\n+/// the `derive` strategy requires all fields are `Eq`, which isn't\n /// always desired.\n ///\n /// ## How can I implement `Eq`?\n@@ -165,6 +165,17 @@ pub trait Eq: PartialEq<Self> {\n     fn assert_receiver_is_total_eq(&self) {}\n }\n \n+// FIXME: this struct is used solely by #[derive] to\n+// assert that every component of a type implements Eq.\n+//\n+// This struct should never appear in user code.\n+#[doc(hidden)]\n+#[allow(missing_debug_implementations)]\n+#[unstable(feature = \"derive_eq\",\n+           reason = \"deriving hack, should not be public\",\n+           issue = \"0\")]\n+pub struct AssertParamIsEq<T: Eq + ?Sized> { _field: ::marker::PhantomData<T> }\n+\n /// An `Ordering` is the result of a comparison between two values.\n ///\n /// # Examples"}, {"sha": "b81d95a6998c310e01006df4c6733d0f81d28684", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -97,6 +97,7 @@ pub trait AstBuilder {\n                       typ: P<ast::Ty>,\n                       ex: P<ast::Expr>)\n                       -> P<ast::Stmt>;\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt;\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt;\n \n     // blocks\n@@ -577,6 +578,23 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         })\n     }\n \n+    // Generate `let _: Type;`, usually used for type assertions.\n+    fn stmt_let_type_only(&self, span: Span, ty: P<ast::Ty>) -> ast::Stmt {\n+        let local = P(ast::Local {\n+            pat: self.pat_wild(span),\n+            ty: Some(ty),\n+            init: None,\n+            id: ast::DUMMY_NODE_ID,\n+            span: span,\n+            attrs: ast::ThinVec::new(),\n+        });\n+        ast::Stmt {\n+            id: ast::DUMMY_NODE_ID,\n+            node: ast::StmtKind::Local(local),\n+            span: span,\n+        }\n+    }\n+\n     fn stmt_item(&self, sp: Span, item: P<ast::Item>) -> ast::Stmt {\n         ast::Stmt {\n             id: ast::DUMMY_NODE_ID,"}, {"sha": "d7bc2a6faeeb993f29f60007b80e88e07815bdb4", "filename": "src/libsyntax_ext/deriving/clone.rs", "status": "modified", "additions": 96, "deletions": 70, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -11,20 +11,14 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, Generics, ItemKind, MetaItem, VariantData};\n+use syntax::ast::{self, Expr, Generics, ItemKind, MetaItem, VariantData};\n use syntax::attr;\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n-use syntax::parse::token::InternedString;\n+use syntax::parse::token::{keywords, InternedString};\n use syntax::ptr::P;\n use syntax_pos::Span;\n \n-#[derive(PartialEq)]\n-enum Mode {\n-    Deep,\n-    Shallow,\n-}\n-\n pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                              span: Span,\n                              mitem: &MetaItem,\n@@ -40,29 +34,38 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n     //      if we used the short form with generics, we'd have to bound the generics with\n     //      Clone + Copy, and then there'd be no Clone impl at all if the user fills in something\n     //      that is Clone but not Copy. and until specialization we can't write both impls.\n+    // - the item is a union with Copy fields\n+    //      Unions with generic parameters still can derive Clone because they require Copy\n+    //      for deriving, Clone alone is not enough.\n+    //      Whever Clone is implemented for fields is irrelevant so we don't assert it.\n     let bounds;\n-    let unify_fieldless_variants;\n     let substructure;\n+    let is_shallow;\n     match *item {\n         Annotatable::Item(ref annitem) => {\n             match annitem.node {\n                 ItemKind::Struct(_, Generics { ref ty_params, .. }) |\n                 ItemKind::Enum(_, Generics { ref ty_params, .. })\n-                    if ty_params.is_empty() &&\n-                       attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") => {\n-\n+                        if attr::contains_name(&annitem.attrs, \"rustc_copy_clone_marker\") &&\n+                           ty_params.is_empty() => {\n+                    bounds = vec![];\n+                    is_shallow = true;\n+                    substructure = combine_substructure(Box::new(|c, s, sub| {\n+                        cs_clone_shallow(\"Clone\", c, s, sub, false)\n+                    }));\n+                }\n+                ItemKind::Union(..) => {\n                     bounds = vec![Literal(path_std!(cx, core::marker::Copy))];\n-                    unify_fieldless_variants = true;\n+                    is_shallow = true;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Shallow)\n+                        cs_clone_shallow(\"Clone\", c, s, sub, true)\n                     }));\n                 }\n-\n                 _ => {\n                     bounds = vec![];\n-                    unify_fieldless_variants = false;\n+                    is_shallow = false;\n                     substructure = combine_substructure(Box::new(|c, s, sub| {\n-                        cs_clone(\"Clone\", c, s, sub, Mode::Deep)\n+                        cs_clone(\"Clone\", c, s, sub)\n                     }));\n                 }\n             }\n@@ -80,7 +83,7 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n         additional_bounds: bounds,\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"clone\",\n                           generics: LifetimeBounds::empty(),\n@@ -89,37 +92,72 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                           ret_ty: Self_,\n                           attributes: attrs,\n                           is_unsafe: false,\n-                          unify_fieldless_variants: unify_fieldless_variants,\n+                          unify_fieldless_variants: false,\n                           combine_substructure: substructure,\n                       }],\n         associated_types: Vec::new(),\n     };\n \n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, is_shallow)\n+}\n+\n+fn cs_clone_shallow(name: &str,\n+                    cx: &mut ExtCtxt,\n+                    trait_span: Span,\n+                    substr: &Substructure,\n+                    is_union: bool)\n+                    -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Clone)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"clone\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsClone<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsClone\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    if is_union {\n+        // let _: AssertParamIsCopy<Self>;\n+        let self_ty = cx.ty_path(cx.path_ident(trait_span, keywords::SelfType.ident()));\n+        assert_ty_bounds(cx, &mut stmts, self_ty, trait_span, \"AssertParamIsCopy\");\n+    } else {\n+        match *substr.fields {\n+            StaticStruct(vdata, ..) => {\n+                process_variant(cx, &mut stmts, vdata);\n+            }\n+            StaticEnum(enum_def, ..) => {\n+                for variant in &enum_def.variants {\n+                    process_variant(cx, &mut stmts, &variant.node.data);\n+                }\n+            }\n+            _ => cx.span_bug(trait_span, &format!(\"unexpected substructure in \\\n+                                                    shallow `derive({})`\", name))\n+        }\n+    }\n+    stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n+    cx.expr_block(cx.block(trait_span, stmts))\n }\n \n fn cs_clone(name: &str,\n             cx: &mut ExtCtxt,\n             trait_span: Span,\n-            substr: &Substructure,\n-            mode: Mode)\n+            substr: &Substructure)\n             -> P<Expr> {\n     let ctor_path;\n     let all_fields;\n-    let fn_path = match mode {\n-        Mode::Shallow => cx.std_path(&[\"clone\", \"assert_receiver_is_clone\"]),\n-        Mode::Deep => cx.std_path(&[\"clone\", \"Clone\", \"clone\"]),\n-    };\n+    let fn_path = cx.std_path(&[\"clone\", \"Clone\", \"clone\"]);\n     let subcall = |cx: &mut ExtCtxt, field: &FieldInfo| {\n         let args = vec![cx.expr_addr_of(field.span, field.self_.clone())];\n-\n-        let span = if mode == Mode::Shallow {\n-            // set the expn ID so we can call the unstable method\n-            super::allow_unstable(cx, field.span, \"derive(Clone)\")\n-        } else {\n-            field.span\n-        };\n-        cx.expr_call_global(span, fn_path.clone(), args)\n+        cx.expr_call_global(field.span, fn_path.clone(), args)\n     };\n \n     let vdata;\n@@ -145,43 +183,31 @@ fn cs_clone(name: &str,\n         }\n     }\n \n-    match mode {\n-        Mode::Shallow => {\n-            let mut stmts = all_fields.iter().map(|f| {\n-                let call = subcall(cx, f);\n-                cx.stmt_expr(call)\n-            }).collect::<Vec<_>>();\n-            stmts.push(cx.stmt_expr(cx.expr_deref(trait_span, cx.expr_self(trait_span))));\n-            cx.expr_block(cx.block(trait_span, stmts))\n-        }\n-        Mode::Deep => {\n-            match *vdata {\n-                VariantData::Struct(..) => {\n-                    let fields = all_fields.iter()\n-                        .map(|field| {\n-                            let ident = match field.name {\n-                                Some(i) => i,\n-                                None => {\n-                                    cx.span_bug(trait_span,\n-                                                &format!(\"unnamed field in normal struct in \\\n-                                                     `derive({})`\",\n-                                                         name))\n-                                }\n-                            };\n-                            let call = subcall(cx, field);\n-                            cx.field_imm(field.span, ident, call)\n-                        })\n-                        .collect::<Vec<_>>();\n+    match *vdata {\n+        VariantData::Struct(..) => {\n+            let fields = all_fields.iter()\n+                .map(|field| {\n+                    let ident = match field.name {\n+                        Some(i) => i,\n+                        None => {\n+                            cx.span_bug(trait_span,\n+                                        &format!(\"unnamed field in normal struct in \\\n+                                                `derive({})`\",\n+                                                    name))\n+                        }\n+                    };\n+                    let call = subcall(cx, field);\n+                    cx.field_imm(field.span, ident, call)\n+                })\n+                .collect::<Vec<_>>();\n \n-                    cx.expr_struct(trait_span, ctor_path, fields)\n-                }\n-                VariantData::Tuple(..) => {\n-                    let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n-                    let path = cx.expr_path(ctor_path);\n-                    cx.expr_call(trait_span, path, subcalls)\n-                }\n-                VariantData::Unit(..) => cx.expr_path(ctor_path),\n-            }\n+            cx.expr_struct(trait_span, ctor_path, fields)\n+        }\n+        VariantData::Tuple(..) => {\n+            let subcalls = all_fields.iter().map(|f| subcall(cx, f)).collect();\n+            let path = cx.expr_path(ctor_path);\n+            cx.expr_call(trait_span, path, subcalls)\n         }\n+        VariantData::Unit(..) => cx.expr_path(ctor_path),\n     }\n }"}, {"sha": "fa0fb2492c551c439287a6be89795bbe1cbc758d", "filename": "src/libsyntax_ext/deriving/cmp/eq.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -11,7 +11,7 @@\n use deriving::generic::*;\n use deriving::generic::ty::*;\n \n-use syntax::ast::{Expr, MetaItem};\n+use syntax::ast::{self, Expr, MetaItem};\n use syntax::ext::base::{Annotatable, ExtCtxt};\n use syntax::ext::build::AstBuilder;\n use syntax::parse::token::InternedString;\n@@ -23,22 +23,6 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                           mitem: &MetaItem,\n                           item: &Annotatable,\n                           push: &mut FnMut(Annotatable)) {\n-    fn cs_total_eq_assert(cx: &mut ExtCtxt, span: Span, substr: &Substructure) -> P<Expr> {\n-        cs_same_method(|cx, span, exprs| {\n-            // create `a.<method>(); b.<method>(); c.<method>(); ...`\n-            // (where method is `assert_receiver_is_total_eq`)\n-            let stmts = exprs.into_iter().map(|e| cx.stmt_expr(e)).collect();\n-            let block = cx.block(span, stmts);\n-            cx.expr_block(block)\n-        },\n-                       Box::new(|cx, sp, _, _| {\n-                           cx.span_bug(sp, \"non matching enums in derive(Eq)?\")\n-                       }),\n-                       cx,\n-                       span,\n-                       substr)\n-    }\n-\n     let inline = cx.meta_word(span, InternedString::new(\"inline\"));\n     let hidden = cx.meta_list_item_word(span, InternedString::new(\"hidden\"));\n     let doc = cx.meta_list(span, InternedString::new(\"doc\"), vec![hidden]);\n@@ -50,7 +34,7 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n         additional_bounds: Vec::new(),\n         generics: LifetimeBounds::empty(),\n         is_unsafe: false,\n-        supports_unions: false,\n+        supports_unions: true,\n         methods: vec![MethodDef {\n                           name: \"assert_receiver_is_total_eq\",\n                           generics: LifetimeBounds::empty(),\n@@ -66,5 +50,38 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                       }],\n         associated_types: Vec::new(),\n     };\n-    trait_def.expand(cx, mitem, item, push)\n+    trait_def.expand_ext(cx, mitem, item, push, true)\n+}\n+\n+fn cs_total_eq_assert(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure) -> P<Expr> {\n+    fn assert_ty_bounds(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>,\n+                        ty: P<ast::Ty>, span: Span, helper_name: &str) {\n+        // Generate statement `let _: helper_name<ty>;`,\n+        // set the expn ID so we can use the unstable struct.\n+        let span = super::allow_unstable(cx, span, \"derive(Eq)\");\n+        let assert_path = cx.path_all(span, true,\n+                                        cx.std_path(&[\"cmp\", helper_name]),\n+                                        vec![], vec![ty], vec![]);\n+        stmts.push(cx.stmt_let_type_only(span, cx.ty_path(assert_path)));\n+    }\n+    fn process_variant(cx: &mut ExtCtxt, stmts: &mut Vec<ast::Stmt>, variant: &ast::VariantData) {\n+        for field in variant.fields() {\n+            // let _: AssertParamIsEq<FieldTy>;\n+            assert_ty_bounds(cx, stmts, field.ty.clone(), field.span, \"AssertParamIsEq\");\n+        }\n+    }\n+\n+    let mut stmts = Vec::new();\n+    match *substr.fields {\n+        StaticStruct(vdata, ..) => {\n+            process_variant(cx, &mut stmts, vdata);\n+        }\n+        StaticEnum(enum_def, ..) => {\n+            for variant in &enum_def.variants {\n+                process_variant(cx, &mut stmts, &variant.node.data);\n+            }\n+        }\n+        _ => cx.span_bug(trait_span, \"unexpected substructure in `derive(Eq)`\")\n+    }\n+    cx.expr_block(cx.block(trait_span, stmts))\n }"}, {"sha": "339a6c477ccd5df1a55fecfd3f91a357c12d9fbc", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -401,18 +401,29 @@ impl<'a> TraitDef<'a> {\n                   mitem: &ast::MetaItem,\n                   item: &'a Annotatable,\n                   push: &mut FnMut(Annotatable)) {\n+        self.expand_ext(cx, mitem, item, push, false);\n+    }\n+\n+    pub fn expand_ext(&self,\n+                      cx: &mut ExtCtxt,\n+                      mitem: &ast::MetaItem,\n+                      item: &'a Annotatable,\n+                      push: &mut FnMut(Annotatable),\n+                      from_scratch: bool) {\n         match *item {\n             Annotatable::Item(ref item) => {\n                 let newitem = match item.node {\n                     ast::ItemKind::Struct(ref struct_def, ref generics) => {\n-                        self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                        self.expand_struct_def(cx, &struct_def, item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Enum(ref enum_def, ref generics) => {\n-                        self.expand_enum_def(cx, enum_def, &item.attrs, item.ident, generics)\n+                        self.expand_enum_def(cx, enum_def, &item.attrs,\n+                                             item.ident, generics, from_scratch)\n                     }\n                     ast::ItemKind::Union(ref struct_def, ref generics) => {\n                         if self.supports_unions {\n-                            self.expand_struct_def(cx, &struct_def, item.ident, generics)\n+                            self.expand_struct_def(cx, &struct_def, item.ident,\n+                                                   generics, from_scratch)\n                         } else {\n                             cx.span_err(mitem.span,\n                                         \"this trait cannot be derived for unions\");\n@@ -661,7 +672,8 @@ impl<'a> TraitDef<'a> {\n                          cx: &mut ExtCtxt,\n                          struct_def: &'a VariantData,\n                          type_ident: Ident,\n-                         generics: &Generics)\n+                         generics: &Generics,\n+                         from_scratch: bool)\n                          -> P<ast::Item> {\n         let field_tys: Vec<P<ast::Ty>> = struct_def.fields()\n             .iter()\n@@ -674,7 +686,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_struct_method_body(cx,\n                                                                 self,\n                                                                 struct_def,\n@@ -709,7 +721,8 @@ impl<'a> TraitDef<'a> {\n                        enum_def: &'a EnumDef,\n                        type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n-                       generics: &Generics)\n+                       generics: &Generics,\n+                       from_scratch: bool)\n                        -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n \n@@ -727,7 +740,7 @@ impl<'a> TraitDef<'a> {\n                 let (explicit_self, self_args, nonself_args, tys) =\n                     method_def.split_self_nonself_args(cx, self, type_ident, generics);\n \n-                let body = if method_def.is_static() {\n+                let body = if from_scratch || method_def.is_static() {\n                     method_def.expand_static_enum_method_body(cx,\n                                                               self,\n                                                               enum_def,"}, {"sha": "8b6b8d9ecb08ed08c098bf2f2284a569a4df238a", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow-nested.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow-nested.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -18,16 +18,12 @@ struct S {\n     b: u16,\n }\n \n+#[derive(Clone, Copy)]\n union U {\n     s: S,\n     c: u32,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         {"}, {"sha": "ecc698acc317f7f09b7223757a83b74a87f5f433", "filename": "src/test/compile-fail/borrowck/borrowck-union-borrow.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-union-borrow.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -12,16 +12,12 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone, Copy)]\n union U {\n     a: u8,\n     b: u64,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n-}\n-impl Copy for U {}\n-\n fn main() {\n     unsafe {\n         let mut u = U { b: 0 };"}, {"sha": "9014b3f2956b7e7751c97a44d9d49ea1ee4f6637", "filename": "src/test/compile-fail/union/union-copy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-copy.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -10,16 +10,16 @@\n \n #![feature(untagged_unions)]\n \n+#[derive(Clone)]\n union U {\n     a: u8\n }\n \n+#[derive(Clone)]\n union W {\n     a: String\n }\n \n-impl Clone for U { fn clone(&self) { panic!(); } }\n-impl Clone for W { fn clone(&self) { panic!(); } }\n impl Copy for U {} // OK\n impl Copy for W {} //~ ERROR the trait `Copy` may not be implemented for this type\n "}, {"sha": "6e226d7d79f9f1faa12338fb94344bc47dc09c0a", "filename": "src/test/compile-fail/union/union-derive-clone.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-clone.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Clone)] //~ ERROR the trait bound `U1: std::marker::Copy` is not satisfied\n+union U1 {\n+    a: u8,\n+}\n+\n+#[derive(Clone)]\n+union U2 {\n+    a: u8, // OK\n+}\n+\n+impl Copy for U2 {}\n+\n+#[derive(Clone, Copy)]\n+union U3 {\n+    a: u8, // OK\n+}\n+\n+#[derive(Clone, Copy)]\n+union U4<T> {\n+    a: T, // OK\n+}\n+\n+#[derive(Clone)]\n+struct CloneNoCopy;\n+\n+fn main() {\n+    let u = U4 { a: CloneNoCopy };\n+    let w = u.clone(); //~ ERROR no method named `clone` found for type `U4<CloneNoCopy>`\n+}"}, {"sha": "9dfec288c157208697e8160d364ddf149aea8d51", "filename": "src/test/compile-fail/union/union-derive-eq.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive-eq.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(untagged_unions)]\n+\n+#[derive(Eq)] // OK\n+union U1 {\n+    a: u8,\n+}\n+\n+impl PartialEq for U1 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(PartialEq)]\n+struct PartialEqNotEq;\n+\n+#[derive(Eq)]\n+union U2 {\n+    a: PartialEqNotEq, //~ ERROR the trait bound `PartialEqNotEq: std::cmp::Eq` is not satisfied\n+}\n+\n+impl PartialEq for U2 { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+fn main() {}"}, {"sha": "26dbdfd0b411847a26b1855813b7119a1568d0fa", "filename": "src/test/compile-fail/union/union-derive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funion%2Funion-derive.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -13,9 +13,7 @@\n #![feature(untagged_unions)]\n \n #[derive(\n-    Clone, //~ ERROR this trait cannot be derived for unions\n     PartialEq, //~ ERROR this trait cannot be derived for unions\n-    Eq, //~ ERROR this trait cannot be derived for unions\n     PartialOrd, //~ ERROR this trait cannot be derived for unions\n     Ord, //~ ERROR this trait cannot be derived for unions\n     Hash, //~ ERROR this trait cannot be derived for unions"}, {"sha": "bea4d5f923e21f314f9caa22cd725c5bf21c0319", "filename": "src/test/run-pass/union/union-c-interop.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-c-interop.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -10,24 +10,21 @@\n \n #![feature(untagged_unions)]\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n struct LARGE_INTEGER_U {\n     LowPart: u32,\n     HighPart: u32,\n }\n \n-#[derive(Copy)]\n+#[derive(Clone, Copy)]\n #[repr(C)]\n union LARGE_INTEGER {\n   __unnamed__: LARGE_INTEGER_U,\n   u: LARGE_INTEGER_U,\n   QuadPart: u64,\n }\n \n-impl Clone for LARGE_INTEGER_U { fn clone(&self) -> Self { *self } }\n-impl Clone for LARGE_INTEGER { fn clone(&self) -> Self { *self } }\n-\n #[link(name = \"rust_test_helpers\")]\n extern \"C\" {\n     fn increment_all_parts(_: LARGE_INTEGER) -> LARGE_INTEGER;"}, {"sha": "8ff6f17394f9e91ba7ca8eae612f48c25455f971", "filename": "src/test/run-pass/union/union-derive.rs", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/726850170d3ec4606246ad90fcb08d1eee913c76/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funion%2Funion-derive.rs?ref=726850170d3ec4606246ad90fcb08d1eee913c76", "patch": "@@ -14,18 +14,34 @@\n \n #[derive(\n     Copy,\n+    Clone,\n+    Eq,\n )]\n union U {\n     a: u8,\n     b: u16,\n }\n \n-impl Clone for U {\n-    fn clone(&self) -> Self { *self }\n+impl PartialEq for U { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n+#[derive(\n+    Clone,\n+    Copy,\n+    Eq\n+)]\n+union W<T> {\n+    a: T,\n }\n \n+impl<T> PartialEq for W<T> { fn eq(&self, rhs: &Self) -> bool { true } }\n+\n fn main() {\n     let u = U { b: 0 };\n     let u1 = u;\n     let u2 = u.clone();\n+    assert!(u1 == u2);\n+\n+    let w = W { a: 0 };\n+    let w1 = w.clone();\n+    assert!(w == w1);\n }"}]}