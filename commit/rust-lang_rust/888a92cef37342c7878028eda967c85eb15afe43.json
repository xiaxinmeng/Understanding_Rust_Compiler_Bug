{"sha": "888a92cef37342c7878028eda967c85eb15afe43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4OGE5MmNlZjM3MzQyYzc4NzgwMjhlZGE5NjdjODVlYjE1YWZlNDM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-10-11T16:26:32Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-11-01T18:07:45Z"}, "message": "separate Diagnostic from DiagnosticBuilder", "tree": {"sha": "a26e908f88eac00cf57ed7123b80f761ec1c68c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a26e908f88eac00cf57ed7123b80f761ec1c68c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/888a92cef37342c7878028eda967c85eb15afe43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/888a92cef37342c7878028eda967c85eb15afe43", "html_url": "https://github.com/rust-lang/rust/commit/888a92cef37342c7878028eda967c85eb15afe43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/888a92cef37342c7878028eda967c85eb15afe43/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "75bc8bfa922e533f111e54b0d841d85d61c7f317", "url": "https://api.github.com/repos/rust-lang/rust/commits/75bc8bfa922e533f111e54b0d841d85d61c7f317", "html_url": "https://github.com/rust-lang/rust/commit/75bc8bfa922e533f111e54b0d841d85d61c7f317"}], "stats": {"total": 573, "additions": 358, "deletions": 215}, "files": [{"sha": "dab8fb665ac155bf0b69188ef2f9b8803a162e20", "filename": "src/librustc_errors/diagnostic.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=888a92cef37342c7878028eda967c85eb15afe43", "patch": "@@ -0,0 +1,190 @@\n+use CodeSuggestion;\n+use Level;\n+use RenderSpan;\n+use RenderSpan::Suggestion;\n+use std::fmt;\n+use syntax_pos::{MultiSpan, Span};\n+\n+#[must_use]\n+#[derive(Clone)]\n+pub struct Diagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub code: Option<String>,\n+    pub span: MultiSpan,\n+    pub children: Vec<SubDiagnostic>,\n+}\n+\n+/// For example a note attached to an error.\n+#[derive(Clone)]\n+pub struct SubDiagnostic {\n+    pub level: Level,\n+    pub message: String,\n+    pub span: MultiSpan,\n+    pub render_span: Option<RenderSpan>,\n+}\n+\n+impl Diagnostic {\n+    pub fn new(level: Level, message: &str) -> Self {\n+        Diagnostic::new_with_code(level, None, message)\n+    }\n+\n+    pub fn new_with_code(level: Level, code: Option<String>, message: &str) -> Self {\n+        Diagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            code: code,\n+            span: MultiSpan::new(),\n+            children: vec![],\n+        }\n+    }\n+\n+    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n+    /// cancelled or it will panic when dropped).\n+    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n+    /// bump the error count on the Handler and cancelling it won't undo that.\n+    /// If you want to decrement the error count you should use `Handler::cancel`.\n+    pub fn cancel(&mut self) {\n+        self.level = Level::Cancelled;\n+    }\n+\n+    pub fn cancelled(&self) -> bool {\n+        self.level == Level::Cancelled\n+    }\n+\n+    pub fn is_fatal(&self) -> bool {\n+        self.level == Level::Fatal\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                      -> &mut Self {\n+        self.span.push_span_label(span, format!(\"{}\", label));\n+        self\n+    }\n+\n+    pub fn note_expected_found(&mut self,\n+                               label: &fmt::Display,\n+                               expected: &fmt::Display,\n+                               found: &fmt::Display)\n+                               -> &mut Self\n+    {\n+        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n+    }\n+\n+    pub fn note_expected_found_extra(&mut self,\n+                                     label: &fmt::Display,\n+                                     expected: &fmt::Display,\n+                                     found: &fmt::Display,\n+                                     expected_extra: &fmt::Display,\n+                                     found_extra: &fmt::Display)\n+                                     -> &mut Self\n+    {\n+        // For now, just attach these as notes\n+        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n+        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n+        self\n+    }\n+\n+    pub fn note(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Note, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Note, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn warn(&mut self, msg: &str) -> &mut Self {\n+        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Warning, msg, sp.into(), None);\n+        self\n+    }\n+\n+    pub fn help(&mut self , msg: &str) -> &mut Self {\n+        self.sub(Level::Help, msg, MultiSpan::new(), None);\n+        self\n+    }\n+\n+    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                         sp: S,\n+                                         msg: &str)\n+                                         -> &mut Self {\n+        self.sub(Level::Help, msg, sp.into(), None);\n+        self\n+    }\n+\n+    /// Prints out a message with a suggested edit of the code.\n+    ///\n+    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n+    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                               sp: S,\n+                                               msg: &str,\n+                                               suggestion: String)\n+                                               -> &mut Self {\n+        self.sub(Level::Help,\n+                 msg,\n+                 MultiSpan::new(),\n+                 Some(Suggestion(CodeSuggestion {\n+                     msp: sp.into(),\n+                     substitutes: vec![suggestion],\n+                 })));\n+        self\n+    }\n+\n+    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n+        self.span = sp.into();\n+        self\n+    }\n+\n+    pub fn code(&mut self, s: String) -> &mut Self {\n+        self.code = Some(s);\n+        self\n+    }\n+\n+    pub fn message(&self) -> &str {\n+        &self.message\n+    }\n+\n+    pub fn level(&self) -> Level {\n+        self.level\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// public methods above.\n+    fn sub(&mut self,\n+           level: Level,\n+           message: &str,\n+           span: MultiSpan,\n+           render_span: Option<RenderSpan>) {\n+        let sub = SubDiagnostic {\n+            level: level,\n+            message: message.to_owned(),\n+            span: span,\n+            render_span: render_span,\n+        };\n+        self.children.push(sub);\n+    }\n+}\n+\n+impl fmt::Debug for Diagnostic {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.message.fmt(f)\n+    }\n+}"}, {"sha": "69532823f5a5b9cce295f6821d783d0c467891c6", "filename": "src/librustc_errors/diagnostic_builder.rs", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Fdiagnostic_builder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic_builder.rs?ref=888a92cef37342c7878028eda967c85eb15afe43", "patch": "@@ -0,0 +1,164 @@\n+use Diagnostic;\n+use Level;\n+use Handler;\n+use std::fmt::{self, Debug};\n+use std::ops::{Deref, DerefMut};\n+use std::thread::panicking;\n+use syntax_pos::{MultiSpan, Span};\n+\n+/// Used for emitting structured error messages and other diagnostic information.\n+#[must_use]\n+#[derive(Clone)]\n+pub struct DiagnosticBuilder<'a> {\n+    handler: &'a Handler,\n+    diagnostic: Diagnostic,\n+}\n+\n+/// In general, the `DiagnosticBuilder` uses deref to allow access to\n+/// the fields and methods of the embedded `diagnostic` in a\n+/// transparent way.  *However,* many of the methods are intended to\n+/// be used in a chained way, and hence ought to return `self`. In\n+/// that case, we can't just naively forward to the method on the\n+/// `diagnostic`, because the return type would be a `&Diagnostic`\n+/// instead of a `&DiagnosticBuilder<'a>`. This `forward!` macro makes\n+/// it easy to declare such methods on the builder.\n+macro_rules! forward {\n+    // Forward pattern for &self -> &Self\n+    (pub fn $n:ident(&self, $($name:ident: $ty:ty),*) -> &Self) => {\n+        pub fn $n(&self, $($name: $ty),*) -> &Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self\n+    (pub fn $n:ident(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+\n+    // Forward pattern for &mut self -> &mut Self, with S: Into<MultiSpan>\n+    // type parameter. No obvious way to make this more generic.\n+    (pub fn $n:ident<S: Into<MultiSpan>>(&mut self, $($name:ident: $ty:ty),*) -> &mut Self) => {\n+        pub fn $n<S: Into<MultiSpan>>(&mut self, $($name: $ty),*) -> &mut Self {\n+            self.diagnostic.$n($($name),*);\n+            self\n+        }\n+    };\n+}\n+\n+impl<'a> Deref for DiagnosticBuilder<'a> {\n+    type Target = Diagnostic;\n+\n+    fn deref(&self) -> &Diagnostic {\n+        &self.diagnostic\n+    }\n+}\n+\n+impl<'a> DerefMut for DiagnosticBuilder<'a> {\n+    fn deref_mut(&mut self) -> &mut Diagnostic {\n+        &mut self.diagnostic\n+    }\n+}\n+\n+impl<'a> DiagnosticBuilder<'a> {\n+    /// Emit the diagnostic.\n+    pub fn emit(&mut self) {\n+        if self.cancelled() {\n+            return;\n+        }\n+\n+        self.handler.emitter.borrow_mut().emit(&self);\n+        self.cancel();\n+        self.handler.panic_if_treat_err_as_bug();\n+\n+        // if self.is_fatal() {\n+        //     panic!(FatalError);\n+        // }\n+    }\n+\n+    /// Add a span/label to be included in the resulting snippet.\n+    /// This is pushed onto the `MultiSpan` that was created when the\n+    /// diagnostic was first built. If you don't call this function at\n+    /// all, and you just supplied a `Span` to create the diagnostic,\n+    /// then the snippet will just include that `Span`, which is\n+    /// called the primary span.\n+    forward!(pub fn span_label(&mut self, span: Span, label: &fmt::Display)\n+                               -> &mut Self);\n+\n+    forward!(pub fn note_expected_found(&mut self,\n+                                        label: &fmt::Display,\n+                                        expected: &fmt::Display,\n+                                        found: &fmt::Display)\n+                                        -> &mut Self);\n+\n+    forward!(pub fn note_expected_found_extra(&mut self,\n+                                              label: &fmt::Display,\n+                                              expected: &fmt::Display,\n+                                              found: &fmt::Display,\n+                                              expected_extra: &fmt::Display,\n+                                              found_extra: &fmt::Display)\n+                                              -> &mut Self);\n+\n+    forward!(pub fn note(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_note<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn warn(&mut self, msg: &str) -> &mut Self);\n+    forward!(pub fn span_warn<S: Into<MultiSpan>>(&mut self, sp: S, msg: &str) -> &mut Self);\n+    forward!(pub fn help(&mut self , msg: &str) -> &mut Self);\n+    forward!(pub fn span_help<S: Into<MultiSpan>>(&mut self,\n+                                                  sp: S,\n+                                                  msg: &str)\n+                                                  -> &mut Self);\n+    forward!(pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n+                                                        sp: S,\n+                                                        msg: &str,\n+                                                        suggestion: String)\n+                                                        -> &mut Self);\n+    forward!(pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self);\n+    forward!(pub fn code(&mut self, s: String) -> &mut Self);\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder::new_with_code(handler, level, None, message)\n+    }\n+\n+    /// Convenience function for internal use, clients should use one of the\n+    /// struct_* methods on Handler.\n+    pub fn new_with_code(handler: &'a Handler,\n+                         level: Level,\n+                         code: Option<String>,\n+                         message: &str)\n+                         -> DiagnosticBuilder<'a> {\n+        DiagnosticBuilder {\n+            handler: handler,\n+            diagnostic: Diagnostic::new_with_code(level, code, message)\n+        }\n+    }\n+}\n+\n+impl<'a> Debug for DiagnosticBuilder<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.diagnostic.fmt(f)\n+    }\n+}\n+\n+/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n+/// we emit a bug.\n+impl<'a> Drop for DiagnosticBuilder<'a> {\n+    fn drop(&mut self) {\n+        if !panicking() && !self.cancelled() {\n+            let mut db = DiagnosticBuilder::new(self.handler,\n+                                                Level::Bug,\n+                                                \"Error constructed but not emitted\");\n+            db.emit();\n+            panic!();\n+        }\n+    }\n+}\n+"}, {"sha": "203b96d9f9a29ee007b30f14f6d1d8b96e0ee2e6", "filename": "src/librustc_errors/lib.rs", "status": "modified", "additions": 4, "deletions": 215, "changes": 219, "blob_url": "https://github.com/rust-lang/rust/blob/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/888a92cef37342c7878028eda967c85eb15afe43/src%2Flibrustc_errors%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Flib.rs?ref=888a92cef37342c7878028eda967c85eb15afe43", "patch": "@@ -39,15 +39,15 @@ extern crate syntax_pos;\n pub use emitter::ColorConfig;\n \n use self::Level::*;\n-use self::RenderSpan::*;\n \n use emitter::{Emitter, EmitterWriter};\n \n use std::cell::{RefCell, Cell};\n use std::{error, fmt};\n use std::rc::Rc;\n-use std::thread::panicking;\n \n+pub mod diagnostic;\n+pub mod diagnostic_builder;\n pub mod emitter;\n pub mod snippet;\n pub mod registry;\n@@ -211,219 +211,8 @@ impl error::Error for ExplicitBug {\n     }\n }\n \n-/// Used for emitting structured error messages and other diagnostic information.\n-#[must_use]\n-#[derive(Clone)]\n-pub struct DiagnosticBuilder<'a> {\n-    handler: &'a Handler,\n-    pub level: Level,\n-    pub message: String,\n-    pub code: Option<String>,\n-    pub span: MultiSpan,\n-    pub children: Vec<SubDiagnostic>,\n-}\n-\n-/// For example a note attached to an error.\n-#[derive(Clone)]\n-pub struct SubDiagnostic {\n-    pub level: Level,\n-    pub message: String,\n-    pub span: MultiSpan,\n-    pub render_span: Option<RenderSpan>,\n-}\n-\n-impl<'a> DiagnosticBuilder<'a> {\n-    /// Emit the diagnostic.\n-    pub fn emit(&mut self) {\n-        if self.cancelled() {\n-            return;\n-        }\n-\n-        self.handler.emitter.borrow_mut().emit(&self);\n-        self.cancel();\n-        self.handler.panic_if_treat_err_as_bug();\n-\n-        // if self.is_fatal() {\n-        //     panic!(FatalError);\n-        // }\n-    }\n-\n-    /// Cancel the diagnostic (a structured diagnostic must either be emitted or\n-    /// cancelled or it will panic when dropped).\n-    /// BEWARE: if this DiagnosticBuilder is an error, then creating it will\n-    /// bump the error count on the Handler and cancelling it won't undo that.\n-    /// If you want to decrement the error count you should use `Handler::cancel`.\n-    pub fn cancel(&mut self) {\n-        self.level = Level::Cancelled;\n-    }\n-\n-    pub fn cancelled(&self) -> bool {\n-        self.level == Level::Cancelled\n-    }\n-\n-    pub fn is_fatal(&self) -> bool {\n-        self.level == Level::Fatal\n-    }\n-\n-    /// Add a span/label to be included in the resulting snippet.\n-    /// This is pushed onto the `MultiSpan` that was created when the\n-    /// diagnostic was first built. If you don't call this function at\n-    /// all, and you just supplied a `Span` to create the diagnostic,\n-    /// then the snippet will just include that `Span`, which is\n-    /// called the primary span.\n-    pub fn span_label(&mut self, span: Span, label: &fmt::Display) -> &mut DiagnosticBuilder<'a> {\n-        self.span.push_span_label(span, format!(\"{}\", label));\n-        self\n-    }\n-\n-    pub fn note_expected_found(&mut self,\n-                               label: &fmt::Display,\n-                               expected: &fmt::Display,\n-                               found: &fmt::Display)\n-                               -> &mut DiagnosticBuilder<'a> {\n-        self.note_expected_found_extra(label, expected, found, &\"\", &\"\")\n-    }\n-\n-    pub fn note_expected_found_extra(&mut self,\n-                                     label: &fmt::Display,\n-                                     expected: &fmt::Display,\n-                                     found: &fmt::Display,\n-                                     expected_extra: &fmt::Display,\n-                                     found_extra: &fmt::Display)\n-                                     -> &mut DiagnosticBuilder<'a> {\n-        // For now, just attach these as notes\n-        self.note(&format!(\"expected {} `{}`{}\", label, expected, expected_extra));\n-        self.note(&format!(\"   found {} `{}`{}\", label, found, found_extra));\n-        self\n-    }\n-\n-    pub fn note(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_note<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Note, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn warn(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_warn<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Warning, msg, sp.into(), None);\n-        self\n-    }\n-    pub fn help(&mut self, msg: &str) -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, MultiSpan::new(), None);\n-        self\n-    }\n-    pub fn span_help<S: Into<MultiSpan>>(&mut self,\n-                                         sp: S,\n-                                         msg: &str)\n-                                         -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help, msg, sp.into(), None);\n-        self\n-    }\n-    /// Prints out a message with a suggested edit of the code.\n-    ///\n-    /// See `diagnostic::RenderSpan::Suggestion` for more information.\n-    pub fn span_suggestion<S: Into<MultiSpan>>(&mut self,\n-                                               sp: S,\n-                                               msg: &str,\n-                                               suggestion: String)\n-                                               -> &mut DiagnosticBuilder<'a> {\n-        self.sub(Level::Help,\n-                 msg,\n-                 MultiSpan::new(),\n-                 Some(Suggestion(CodeSuggestion {\n-                     msp: sp.into(),\n-                     substitutes: vec![suggestion],\n-                 })));\n-        self\n-    }\n-\n-    pub fn set_span<S: Into<MultiSpan>>(&mut self, sp: S) -> &mut Self {\n-        self.span = sp.into();\n-        self\n-    }\n-\n-    pub fn code(&mut self, s: String) -> &mut Self {\n-        self.code = Some(s);\n-        self\n-    }\n-\n-    pub fn message(&self) -> &str {\n-        &self.message\n-    }\n-\n-    pub fn level(&self) -> Level {\n-        self.level\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new(handler: &'a Handler, level: Level, message: &str) -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder::new_with_code(handler, level, None, message)\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// struct_* methods on Handler.\n-    fn new_with_code(handler: &'a Handler,\n-                     level: Level,\n-                     code: Option<String>,\n-                     message: &str)\n-                     -> DiagnosticBuilder<'a> {\n-        DiagnosticBuilder {\n-            handler: handler,\n-            level: level,\n-            message: message.to_owned(),\n-            code: code,\n-            span: MultiSpan::new(),\n-            children: vec![],\n-        }\n-    }\n-\n-    /// Convenience function for internal use, clients should use one of the\n-    /// public methods above.\n-    fn sub(&mut self,\n-           level: Level,\n-           message: &str,\n-           span: MultiSpan,\n-           render_span: Option<RenderSpan>) {\n-        let sub = SubDiagnostic {\n-            level: level,\n-            message: message.to_owned(),\n-            span: span,\n-            render_span: render_span,\n-        };\n-        self.children.push(sub);\n-    }\n-}\n-\n-impl<'a> fmt::Debug for DiagnosticBuilder<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.message.fmt(f)\n-    }\n-}\n-\n-/// Destructor bomb - a DiagnosticBuilder must be either emitted or cancelled or\n-/// we emit a bug.\n-impl<'a> Drop for DiagnosticBuilder<'a> {\n-    fn drop(&mut self) {\n-        if !panicking() && !self.cancelled() {\n-            let mut db =\n-                DiagnosticBuilder::new(self.handler, Bug, \"Error constructed but not emitted\");\n-            db.emit();\n-            panic!();\n-        }\n-    }\n-}\n+pub use diagnostic::{Diagnostic, SubDiagnostic};\n+pub use diagnostic_builder::DiagnosticBuilder;\n \n /// A handler deals with errors; certain errors\n /// (fatal, bug, unimpl) may cause immediate exit,"}]}