{"sha": "7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmMmYwOWYxYjQ5Nzc3Y2RjODY4M2VmZTJjZTRiZGM2ZGVkMzYwM2Y=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2015-04-18T02:52:29Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2015-04-18T02:52:29Z"}, "message": "Eliminate the obsolete term 'slot'.", "tree": {"sha": "ea3e6c6a6a235e5171a15b659cc6e36d05978882", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea3e6c6a6a235e5171a15b659cc6e36d05978882"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "html_url": "https://github.com/rust-lang/rust/commit/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21e2e6eec86e84eee765c91803f3488a21923a67", "url": "https://api.github.com/repos/rust-lang/rust/commits/21e2e6eec86e84eee765c91803f3488a21923a67", "html_url": "https://github.com/rust-lang/rust/commit/21e2e6eec86e84eee765c91803f3488a21923a67"}], "stats": {"total": 56, "additions": 28, "deletions": 28}, "files": [{"sha": "f731a78ef1254b27785db30aa7285dd10934e687", "filename": "src/doc/complement-lang-faq.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Fcomplement-lang-faq.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Fcomplement-lang-faq.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fcomplement-lang-faq.md?ref=7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "patch": "@@ -124,7 +124,7 @@ Yes. Calling C code from Rust is simple and exactly as efficient as calling C co\n \n Yes. The Rust code has to be exposed via an `extern` declaration, which makes it C-ABI compatible. Such a function can be passed to C code as a function pointer or, if given the `#[no_mangle]` attribute to disable symbol mangling, can be called directly from C code.\n \n-## Why aren't function signatures inferred? Why only local slots?\n+## Why aren't function signatures inferred? Why only local variables?\n \n * Mechanically, it simplifies the inference algorithm; inference only requires looking at one function at a time.\n * The same simplification goes double for human readers. A reader does not need an IDE running an inference algorithm across an entire crate to be able to guess at a function's argument types; it's always explicit and nearby."}, {"sha": "3d9a5bafbd71ea2dba50df0c8c52d4fccd053edb", "filename": "src/doc/grammar.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Fgrammar.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Fgrammar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fgrammar.md?ref=7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "patch": "@@ -426,7 +426,7 @@ meta_seq : meta_item [ ',' meta_seq ] ? ;\n **FIXME:** grammar?\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -440,7 +440,7 @@ function, enumeration, structure, type, static, trait, implementation or module\n scope to a narrow region containing all of its uses; it is otherwise identical\n in meaning to declaring the item outside the statement block.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```antlr\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n@@ -762,7 +762,7 @@ bound := path | lifetime\n \n ### Memory ownership\n \n-### Memory slots\n+### Variables\n \n ### Boxes\n "}, {"sha": "2f0d8b1756a86b5557f5f14b407dc3aaea93545c", "filename": "src/doc/reference.md", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=7f2f09f1b49777cdc8683efe2ce4bdc6ded3603f", "patch": "@@ -564,7 +564,7 @@ type_path_tail : '<' type_expr [ ',' type_expr ] + '>'\n \n A _path_ is a sequence of one or more path components _logically_ separated by\n a namespace qualifier (`::`). If a path consists of only one component, it may\n-refer to either an [item](#items) or a [slot](#memory-slots) in a local control\n+refer to either an [item](#items) or a [variable](#variables) in a local control\n scope. If a path has multiple components, it refers to an item.\n \n Every item has a _canonical path_ within its crate, but the path naming an item\n@@ -1062,9 +1062,9 @@ fn main() {}\n A _function item_ defines a sequence of [statements](#statements) and an\n optional final [expression](#expressions), along with a name and a set of\n parameters. Functions are declared with the keyword `fn`. Functions declare a\n-set of *input* [*slots*](#memory-slots) as parameters, through which the caller\n-passes arguments into the function, and an *output* [*slot*](#memory-slots)\n-through which the function passes results back to the caller.\n+set of *input* [*variables*](#variables) as parameters, through which the caller\n+passes arguments into the function, and the *output* [*type*](#types)\n+of the value the function will return to its caller on completion.\n \n A function may also be copied into a first-class *value*, in which case the\n value has the corresponding [*function type*](#function-types), and can be used\n@@ -1227,7 +1227,7 @@ be undesired.\n #### Diverging functions\n \n A special kind of function can be declared with a `!` character where the\n-output slot type would normally be. For example:\n+output type would normally be. For example:\n \n ```\n fn my_err(s: &str) -> ! {\n@@ -2542,7 +2542,7 @@ statements](#expression-statements).\n ### Declaration statements\n \n A _declaration statement_ is one that introduces one or more *names* into the\n-enclosing statement block. The declared names may denote new slots or new\n+enclosing statement block. The declared names may denote new variables or new\n items.\n \n #### Item declarations\n@@ -2557,18 +2557,18 @@ in meaning to declaring the item outside the statement block.\n > **Note**: there is no implicit capture of the function's dynamic environment when\n > declaring a function-local item.\n \n-#### Slot declarations\n+#### Variable declarations\n \n ```{.ebnf .gram}\n let_decl : \"let\" pat [':' type ] ? [ init ] ? ';' ;\n init : [ '=' ] expr ;\n ```\n \n-A _slot declaration_ introduces a new set of slots, given by a pattern. The\n+A _variable declaration_ introduces a new set of variable, given by a pattern. The\n pattern may be followed by a type annotation, and/or an initializer expression.\n When no type annotation is given, the compiler will infer the type, or signal\n an error if insufficient type information is available for definite inference.\n-Any slots introduced by a slot declaration are visible from the point of\n+Any variables introduced by a variable declaration are visible from the point of\n declaration until the end of the enclosing block scope.\n \n ### Expression statements\n@@ -2623,7 +2623,7 @@ of any reference that points to it.\n \n #### Moved and copied types\n \n-When a [local variable](#memory-slots) is used as an\n+When a [local variable](#variables) is used as an\n [rvalue](#lvalues,-rvalues-and-temporaries) the variable will either be moved\n or copied, depending on its type. All values whose type implements `Copy` are\n copied, all others are moved.\n@@ -3033,10 +3033,9 @@ paren_expr_list : '(' expr_list ')' ;\n call_expr : expr paren_expr_list ;\n ```\n \n-A _call expression_ invokes a function, providing zero or more input slots and\n-an optional reference slot to serve as the function's output, bound to the\n-`lval` on the right hand side of the call. If the function eventually returns,\n-then the expression completes.\n+A _call expression_ invokes a function, providing zero or more input variables\n+and an optional location to move the function's output into. If the function\n+eventually returns, then the expression completes.\n \n Some examples of call expressions:\n \n@@ -3447,9 +3446,9 @@ return_expr : \"return\" expr ? ;\n ```\n \n Return expressions are denoted with the keyword `return`. Evaluating a `return`\n-expression moves its argument into the output slot of the current function,\n-destroys the current function activation frame, and transfers control to the\n-caller frame.\n+expression moves its argument into the designated output location for the\n+current function call, destroys the current function activation frame, and\n+transfers control to the caller frame.\n \n An example of a `return` expression:\n \n@@ -3466,7 +3465,7 @@ fn max(a: i32, b: i32) -> i32 {\n \n ## Types\n \n-Every slot, item and value in a Rust program has a type. The _type_ of a\n+Every variable, item and value in a Rust program has a type. The _type_ of a\n *value* defines the interpretation of the memory holding it.\n \n Built-in types and type-constructors are tightly integrated into the language,\n@@ -3484,7 +3483,7 @@ The primitive types are the following:\n * The machine-dependent integer and floating-point types.\n \n [^unittype]: The \"unit\" value `()` is *not* a sentinel \"null pointer\" value for\n-    reference slots; the \"unit\" type is the implicit return type from functions\n+    reference variables; the \"unit\" type is the implicit return type from functions\n     otherwise lacking a return type, and can be used in other contexts (such as\n     message-sending or type-parametric code) as a zero-size type.]\n \n@@ -3844,7 +3843,7 @@ A Rust program's memory consists of a static set of *items* and a *heap*.\n Immutable portions of the heap may be shared between threads, mutable portions\n may not.\n \n-Allocations in the stack consist of *slots*, and allocations in the heap\n+Allocations in the stack consist of *variables*, and allocations in the heap\n consist of *boxes*.\n \n ### Memory allocation and lifetime\n@@ -3863,10 +3862,11 @@ in the heap, heap allocations may outlive the frame they are allocated within.\n When a stack frame is exited, its local allocations are all released, and its\n references to boxes are dropped.\n \n-### Memory slots\n+### Variables\n \n-A _slot_ is a component of a stack frame, either a function parameter, a\n-[temporary](#lvalues,-rvalues-and-temporaries), or a local variable.\n+A _variable_ is a component of a stack frame, either a named function parameter,\n+an anonymous [temporary](#lvalues,-rvalues-and-temporaries), or a named local\n+variable.\n \n A _local variable_ (or *stack-local* allocation) holds a value directly,\n allocated within the stack's memory. The value is a part of the stack frame.\n@@ -3879,7 +3879,7 @@ Box<i32>, y: Box<i32>)` declare one mutable variable `x` and one immutable\n variable `y`).\n \n Methods that take either `self` or `Box<Self>` can optionally place them in a\n-mutable slot by prefixing them with `mut` (similar to regular arguments):\n+mutable variable by prefixing them with `mut` (similar to regular arguments):\n \n ```\n trait Changer {"}]}