{"sha": "9f53c87b4b1f097e111c9525d60470ed22631018", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNTNjODdiNGIxZjA5N2UxMTFjOTUyNWQ2MDQ3MGVkMjI2MzEwMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T15:01:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-09-15T15:01:51Z"}, "message": "Auto merge of #53527 - Emerentius:test_all, r=nrc\n\nAdd option to run all tests\n\nThis adds the \"--include-ignored\" flag to libtest, which allows running ignored and unignored tests in one go.\n\nCloses #50363", "tree": {"sha": "33a0d7f26ff646c33f2359350e393c1a49afaba6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33a0d7f26ff646c33f2359350e393c1a49afaba6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f53c87b4b1f097e111c9525d60470ed22631018", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f53c87b4b1f097e111c9525d60470ed22631018", "html_url": "https://github.com/rust-lang/rust/commit/9f53c87b4b1f097e111c9525d60470ed22631018", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f53c87b4b1f097e111c9525d60470ed22631018/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cba0fdf43c22795822e1d7c751a69e6c85007221", "url": "https://api.github.com/repos/rust-lang/rust/commits/cba0fdf43c22795822e1d7c751a69e6c85007221", "html_url": "https://github.com/rust-lang/rust/commit/cba0fdf43c22795822e1d7c751a69e6c85007221"}, {"sha": "f6f3228c5f284cfba89b6a70e0116f89663d0219", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6f3228c5f284cfba89b6a70e0116f89663d0219", "html_url": "https://github.com/rust-lang/rust/commit/f6f3228c5f284cfba89b6a70e0116f89663d0219"}], "stats": {"total": 200, "additions": 119, "deletions": 81}, "files": [{"sha": "95eca5ed7ff57b39f060c8a7bdcb388677c2d924", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 119, "deletions": 81, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/9f53c87b4b1f097e111c9525d60470ed22631018/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f53c87b4b1f097e111c9525d60470ed22631018/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=9f53c87b4b1f097e111c9525d60470ed22631018", "patch": "@@ -81,7 +81,7 @@ const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in qu\n // to be used by rustc to compile tests in libtest\n pub mod test {\n     pub use {assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, ShouldPanic,\n+             Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n              StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName,\n              TestOpts, TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk};\n }\n@@ -349,12 +349,19 @@ pub enum OutputFormat {\n     Json,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    Only,\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n     pub filter: Option<String>,\n     pub filter_exact: bool,\n-    pub run_ignored: bool,\n+    pub run_ignored: RunIgnored,\n     pub run_tests: bool,\n     pub bench_benchmarks: bool,\n     pub logfile: Option<PathBuf>,\n@@ -373,7 +380,7 @@ impl TestOpts {\n             list: false,\n             filter: None,\n             filter_exact: false,\n-            run_ignored: false,\n+            run_ignored: RunIgnored::No,\n             run_tests: false,\n             bench_benchmarks: false,\n             logfile: None,\n@@ -392,7 +399,8 @@ pub type OptRes = Result<TestOpts, String>;\n \n fn optgroups() -> getopts::Options {\n     let mut opts = getopts::Options::new();\n-    opts.optflag(\"\", \"ignored\", \"Run ignored tests\")\n+    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n         .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n@@ -491,8 +499,8 @@ Test Attributes:\n                      contain: #[should_panic(expected = \"foo\")].\n     #[ignore]      - When applied to a function which is already attributed as a\n                      test, then the test runner will ignore these tests during\n-                     normal test runs. Running with --ignored will run these\n-                     tests.\"#,\n+                     normal test runs. Running with --ignored or --include-ignored will run\n+                     these tests.\"#,\n         usage = options.usage(&message)\n     );\n }\n@@ -545,7 +553,21 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         None\n     };\n \n-    let run_ignored = matches.opt_present(\"ignored\");\n+    let include_ignored = matches.opt_present(\"include-ignored\");\n+    if !allow_unstable && include_ignored {\n+        return Some(Err(\n+            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into()\n+        ));\n+    }\n+\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => return Some(Err(\n+            \"the options --include-ignored and --ignored are mutually exclusive\".into()\n+        )),\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n     let quiet = matches.opt_present(\"quiet\");\n     let exact = matches.opt_present(\"exact\");\n     let list = matches.opt_present(\"list\");\n@@ -1297,55 +1319,36 @@ fn get_concurrency() -> usize {\n \n pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n     let mut filtered = tests;\n-    // Remove tests that don't match the test filter\n-    filtered = match opts.filter {\n-        None => filtered,\n-        Some(ref filter) => filtered\n-            .into_iter()\n-            .filter(|test| {\n-                if opts.filter_exact {\n-                    test.desc.name.as_slice() == &filter[..]\n-                } else {\n-                    test.desc.name.as_slice().contains(&filter[..])\n-                }\n-            })\n-            .collect(),\n+    let matches_filter = |test: &TestDescAndFn, filter: &str| {\n+        let test_name = test.desc.name.as_slice();\n+\n+        match opts.filter_exact {\n+            true => test_name == filter,\n+            false => test_name.contains(filter),\n+        }\n     };\n \n-    // Skip tests that match any of the skip filters\n-    filtered = filtered\n-        .into_iter()\n-        .filter(|t| {\n-            !opts.skip.iter().any(|sf| {\n-                if opts.filter_exact {\n-                    t.desc.name.as_slice() == &sf[..]\n-                } else {\n-                    t.desc.name.as_slice().contains(&sf[..])\n-                }\n-            })\n-        })\n-        .collect();\n+    // Remove tests that don't match the test filter\n+    if let Some(ref filter) = opts.filter {\n+        filtered.retain(|test| matches_filter(test, filter));\n+    }\n \n-    // Maybe pull out the ignored test and unignore them\n-    filtered = if !opts.run_ignored {\n-        filtered\n-    } else {\n-        fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n-            if test.desc.ignore {\n-                let TestDescAndFn { desc, testfn } = test;\n-                Some(TestDescAndFn {\n-                    desc: TestDesc {\n-                        ignore: false,\n-                        ..desc\n-                    },\n-                    testfn,\n-                })\n-            } else {\n-                None\n-            }\n+    // Skip tests that match any of the skip filters\n+    filtered.retain(|test| {\n+        !opts.skip.iter().any(|sf| matches_filter(test, sf))\n+    });\n+\n+    // maybe unignore tests\n+    match opts.run_ignored {\n+        RunIgnored::Yes => {\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n+        },\n+        RunIgnored::Only => {\n+            filtered.retain(|test| test.desc.ignore);\n+            filtered.iter_mut().for_each(|test| test.desc.ignore = false);\n         }\n-        filtered.into_iter().filter_map(filter).collect()\n-    };\n+        RunIgnored::No => {}\n+    }\n \n     // Sort the tests alphabetically\n     filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n@@ -1734,13 +1737,37 @@ pub mod bench {\n \n #[cfg(test)]\n mod tests {\n-    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, ShouldPanic,\n-               StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n-               TrIgnored, TrOk};\n+    use test::{filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+               ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed,\n+               TrFailedMsg, TrIgnored, TrOk};\n     use std::sync::mpsc::channel;\n     use bench;\n     use Bencher;\n \n+\n+    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+        vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ]\n+    }\n+\n     #[test]\n     pub fn do_not_run_ignored_tests() {\n         fn f() {\n@@ -1866,11 +1893,20 @@ mod tests {\n             \"filter\".to_string(),\n             \"--ignored\".to_string(),\n         ];\n-        let opts = match parse_opts(&args) {\n-            Some(Ok(o)) => o,\n-            _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n-        };\n-        assert!((opts.run_ignored));\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Only);\n+    }\n+\n+    #[test]\n+    fn parse_include_ignored_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"-Zunstable-options\".to_string(),\n+            \"--include-ignored\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n     }\n \n     #[test]\n@@ -1880,35 +1916,33 @@ mod tests {\n \n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n-        opts.run_ignored = true;\n+        opts.run_ignored = RunIgnored::Only;\n \n-        let tests = vec![\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"1\"),\n-                    ignore: true,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-            TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(\"2\"),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {})),\n-            },\n-        ];\n+        let tests = one_ignored_one_unignored_test();\n         let filtered = filter_tests(&opts, tests);\n \n         assert_eq!(filtered.len(), 1);\n         assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n         assert!(!filtered[0].desc.ignore);\n     }\n \n+    #[test]\n+    pub fn run_include_ignored_option() {\n+        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+        // all tests and no test filtered out\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Yes;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(!filtered[0].desc.ignore);\n+        assert!(!filtered[1].desc.ignore);\n+    }\n+\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n@@ -2016,7 +2050,9 @@ mod tests {\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n             \"test::filter_for_ignored_option\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n         let tests = {\n@@ -2047,6 +2083,8 @@ mod tests {\n             \"test::first_free_arg_should_be_a_filter\".to_string(),\n             \"test::ignored_tests_result_in_ignored\".to_string(),\n             \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n             \"test::sort_tests\".to_string(),\n         ];\n "}]}