{"sha": "8e1ae56bc612a888bbd0336255bdb431249b8c74", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhlMWFlNTZiYzYxMmE4ODhiYmQwMzM2MjU1YmRiNDMxMjQ5YjhjNzQ=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-03T14:33:27Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-11-07T18:06:12Z"}, "message": "rustc_metadata: Privatize everything in schema and schema/table", "tree": {"sha": "88c2dd26df6d1a1461dba370c1c00b157a827cea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88c2dd26df6d1a1461dba370c1c00b157a827cea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e1ae56bc612a888bbd0336255bdb431249b8c74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e1ae56bc612a888bbd0336255bdb431249b8c74", "html_url": "https://github.com/rust-lang/rust/commit/8e1ae56bc612a888bbd0336255bdb431249b8c74", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e1ae56bc612a888bbd0336255bdb431249b8c74/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8590b16d9b031014ddcda17b174645bb7ea8ebc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8590b16d9b031014ddcda17b174645bb7ea8ebc4", "html_url": "https://github.com/rust-lang/rust/commit/8590b16d9b031014ddcda17b174645bb7ea8ebc4"}], "stats": {"total": 162, "additions": 80, "deletions": 82}, "files": [{"sha": "dcee19be432b9a0445d9bb07687b105571710d07", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 71, "deletions": 73, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/8e1ae56bc612a888bbd0336255bdb431249b8c74/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1ae56bc612a888bbd0336255bdb431249b8c74/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=8e1ae56bc612a888bbd0336255bdb431249b8c74", "patch": "@@ -1,3 +1,4 @@\n+use decoder::Metadata;\n use table::PerDefTable;\n \n use rustc::hir;\n@@ -22,7 +23,6 @@ use syntax_pos::{self, Span};\n use std::marker::PhantomData;\n use std::num::NonZeroUsize;\n \n-crate use decoder::Metadata;\n crate use encoder::encode_metadata;\n \n mod decoder;\n@@ -110,13 +110,13 @@ crate struct Lazy<T, Meta = <T as LazyMeta>::Meta>\n     where T: ?Sized + LazyMeta<Meta = Meta>,\n           Meta: 'static + Copy,\n {\n-    pub position: NonZeroUsize,\n-    pub meta: Meta,\n+    position: NonZeroUsize,\n+    meta: Meta,\n     _marker: PhantomData<T>,\n }\n \n impl<T: ?Sized + LazyMeta> Lazy<T> {\n-     crate fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n+     fn from_position_and_meta(position: NonZeroUsize, meta: T::Meta) -> Lazy<T> {\n         Lazy {\n             position,\n             meta,\n@@ -126,13 +126,13 @@ impl<T: ?Sized + LazyMeta> Lazy<T> {\n }\n \n impl<T: Encodable> Lazy<T> {\n-    crate fn from_position(position: NonZeroUsize) -> Lazy<T> {\n+    fn from_position(position: NonZeroUsize) -> Lazy<T> {\n         Lazy::from_position_and_meta(position, ())\n     }\n }\n \n impl<T: Encodable> Lazy<[T]> {\n-    crate fn empty() -> Lazy<[T]> {\n+    fn empty() -> Lazy<[T]> {\n         Lazy::from_position_and_meta(NonZeroUsize::new(1).unwrap(), 0)\n     }\n }\n@@ -149,7 +149,7 @@ impl<T: ?Sized + LazyMeta> rustc_serialize::UseSpecializedDecodable for Lazy<T>\n \n /// Encoding / decoding state for `Lazy`.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-crate enum LazyState {\n+enum LazyState {\n     /// Outside of a metadata node.\n     NoNode,\n \n@@ -187,23 +187,23 @@ crate struct CrateRoot<'tcx> {\n     pub has_default_lib_allocator: bool,\n     pub plugin_registrar_fn: Option<DefIndex>,\n     pub proc_macro_decls_static: Option<DefIndex>,\n-    pub proc_macro_stability: Option<attr::Stability>,\n+    proc_macro_stability: Option<attr::Stability>,\n \n     pub crate_deps: Lazy<[CrateDep]>,\n-    pub dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n-    pub lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n-    pub lang_items: Lazy<[(DefIndex, usize)]>,\n-    pub lang_items_missing: Lazy<[lang_items::LangItem]>,\n-    pub diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n-    pub native_libraries: Lazy<[NativeLibrary]>,\n-    pub foreign_modules: Lazy<[ForeignModule]>,\n-    pub source_map: Lazy<[syntax_pos::SourceFile]>,\n+    dylib_dependency_formats: Lazy<[Option<LinkagePreference>]>,\n+    lib_features: Lazy<[(Symbol, Option<Symbol>)]>,\n+    lang_items: Lazy<[(DefIndex, usize)]>,\n+    lang_items_missing: Lazy<[lang_items::LangItem]>,\n+    diagnostic_items: Lazy<[(Symbol, DefIndex)]>,\n+    native_libraries: Lazy<[NativeLibrary]>,\n+    foreign_modules: Lazy<[ForeignModule]>,\n+    source_map: Lazy<[syntax_pos::SourceFile]>,\n     pub def_path_table: Lazy<hir::map::definitions::DefPathTable>,\n     pub impls: Lazy<[TraitImpls]>,\n-    pub exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n+    exported_symbols: Lazy!([(ExportedSymbol<'tcx>, SymbolExportLevel)]),\n     pub interpret_alloc_index: Lazy<[u32]>,\n \n-    pub per_def: LazyPerDefTables<'tcx>,\n+    per_def: LazyPerDefTables<'tcx>,\n \n     /// The DefIndex's of any proc macros delcared by\n     /// this crate\n@@ -236,35 +236,33 @@ crate struct TraitImpls {\n \n #[derive(RustcEncodable, RustcDecodable)]\n crate struct LazyPerDefTables<'tcx> {\n-    pub kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n-    pub visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n-    pub span: Lazy!(PerDefTable<Lazy<Span>>),\n-    pub attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n-    pub children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n-    pub deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n-\n-    pub ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n-    pub fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n-    pub impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n-    pub inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n-    pub variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n-    pub generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n-    pub explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    kind: Lazy!(PerDefTable<Lazy!(EntryKind<'tcx>)>),\n+    visibility: Lazy!(PerDefTable<Lazy<ty::Visibility>>),\n+    span: Lazy!(PerDefTable<Lazy<Span>>),\n+    attributes: Lazy!(PerDefTable<Lazy<[ast::Attribute]>>),\n+    children: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    stability: Lazy!(PerDefTable<Lazy<attr::Stability>>),\n+    deprecation: Lazy!(PerDefTable<Lazy<attr::Deprecation>>),\n+    ty: Lazy!(PerDefTable<Lazy!(Ty<'tcx>)>),\n+    fn_sig: Lazy!(PerDefTable<Lazy!(ty::PolyFnSig<'tcx>)>),\n+    impl_trait_ref: Lazy!(PerDefTable<Lazy!(ty::TraitRef<'tcx>)>),\n+    inherent_impls: Lazy!(PerDefTable<Lazy<[DefIndex]>>),\n+    variances: Lazy!(PerDefTable<Lazy<[ty::Variance]>>),\n+    generics: Lazy!(PerDefTable<Lazy<ty::Generics>>),\n+    explicit_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n     // FIXME(eddyb) this would ideally be `Lazy<[...]>` but `ty::Predicate`\n     // doesn't handle shorthands in its own (de)serialization impls,\n     // as it's an `enum` for which we want to derive (de)serialization,\n     // so the `ty::codec` APIs handle the whole `&'tcx [...]` at once.\n     // Also, as an optimization, a missing entry indicates an empty `&[]`.\n-    pub inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n-    pub super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n-\n-    pub mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n-    pub promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n+    inferred_outlives: Lazy!(PerDefTable<Lazy!(&'tcx [(ty::Predicate<'tcx>, Span)])>),\n+    super_predicates: Lazy!(PerDefTable<Lazy!(ty::GenericPredicates<'tcx>)>),\n+    mir: Lazy!(PerDefTable<Lazy!(mir::Body<'tcx>)>),\n+    promoted_mir: Lazy!(PerDefTable<Lazy!(IndexVec<mir::Promoted, mir::Body<'tcx>>)>),\n }\n \n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum EntryKind<'tcx> {\n+enum EntryKind<'tcx> {\n     Const(ConstQualif, Lazy<RenderedConst>),\n     ImmStatic,\n     MutStatic,\n@@ -299,18 +297,18 @@ crate enum EntryKind<'tcx> {\n \n /// Additional data for EntryKind::Const and EntryKind::AssocConst\n #[derive(Clone, Copy, RustcEncodable, RustcDecodable)]\n-crate struct ConstQualif {\n-    pub mir: u8,\n+struct ConstQualif {\n+    mir: u8,\n }\n \n /// Contains a constant which has been rendered to a String.\n /// Used by rustdoc.\n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct RenderedConst(pub String);\n+struct RenderedConst(String);\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ModData {\n-    pub reexports: Lazy<[def::Export<hir::HirId>]>,\n+struct ModData {\n+    reexports: Lazy<[def::Export<hir::HirId>]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n@@ -320,53 +318,53 @@ crate struct MacroDef {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct FnData {\n-    pub asyncness: hir::IsAsync,\n-    pub constness: hir::Constness,\n-    pub param_names: Lazy<[ast::Name]>,\n+struct FnData {\n+    asyncness: hir::IsAsync,\n+    constness: hir::Constness,\n+    param_names: Lazy<[ast::Name]>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct VariantData {\n-    pub ctor_kind: CtorKind,\n-    pub discr: ty::VariantDiscr,\n+struct VariantData {\n+    ctor_kind: CtorKind,\n+    discr: ty::VariantDiscr,\n     /// If this is unit or tuple-variant/struct, then this is the index of the ctor id.\n-    pub ctor: Option<DefIndex>,\n+    ctor: Option<DefIndex>,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct TraitData {\n-    pub unsafety: hir::Unsafety,\n-    pub paren_sugar: bool,\n-    pub has_auto_impl: bool,\n-    pub is_marker: bool,\n+struct TraitData {\n+    unsafety: hir::Unsafety,\n+    paren_sugar: bool,\n+    has_auto_impl: bool,\n+    is_marker: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct ImplData {\n-    pub polarity: ty::ImplPolarity,\n-    pub defaultness: hir::Defaultness,\n-    pub parent_impl: Option<DefId>,\n+struct ImplData {\n+    polarity: ty::ImplPolarity,\n+    defaultness: hir::Defaultness,\n+    parent_impl: Option<DefId>,\n \n     /// This is `Some` only for impls of `CoerceUnsized`.\n     // FIXME(eddyb) perhaps compute this on the fly if cheap enough?\n-    pub coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n+    coerce_unsized_info: Option<ty::adjustment::CoerceUnsizedInfo>,\n }\n \n \n /// Describes whether the container of an associated item\n /// is a trait or an impl and whether, in a trait, it has\n /// a default, or an in impl, whether it's marked \"default\".\n #[derive(Copy, Clone, RustcEncodable, RustcDecodable)]\n-crate enum AssocContainer {\n+enum AssocContainer {\n     TraitRequired,\n     TraitWithDefault,\n     ImplDefault,\n     ImplFinal,\n }\n \n impl AssocContainer {\n-    crate fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n+    fn with_def_id(&self, def_id: DefId) -> ty::AssocItemContainer {\n         match *self {\n             AssocContainer::TraitRequired |\n             AssocContainer::TraitWithDefault => ty::TraitContainer(def_id),\n@@ -376,7 +374,7 @@ impl AssocContainer {\n         }\n     }\n \n-    crate fn defaultness(&self) -> hir::Defaultness {\n+    fn defaultness(&self) -> hir::Defaultness {\n         match *self {\n             AssocContainer::TraitRequired => hir::Defaultness::Default {\n                 has_value: false,\n@@ -393,17 +391,17 @@ impl AssocContainer {\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct MethodData {\n-    pub fn_data: FnData,\n-    pub container: AssocContainer,\n-    pub has_self: bool,\n+struct MethodData {\n+    fn_data: FnData,\n+    container: AssocContainer,\n+    has_self: bool,\n }\n \n #[derive(RustcEncodable, RustcDecodable)]\n-crate struct GeneratorData<'tcx> {\n-    pub layout: mir::GeneratorLayout<'tcx>,\n+struct GeneratorData<'tcx> {\n+    layout: mir::GeneratorLayout<'tcx>,\n }\n \n // Tags used for encoding Spans:\n-crate const TAG_VALID_SPAN: u8 = 0;\n-crate const TAG_INVALID_SPAN: u8 = 1;\n+const TAG_VALID_SPAN: u8 = 0;\n+const TAG_INVALID_SPAN: u8 = 1;"}, {"sha": "cc65ab8a8ff554dfc72fe841ba7c448e08cef872", "filename": "src/librustc_metadata/schema/table.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/8e1ae56bc612a888bbd0336255bdb431249b8c74/src%2Flibrustc_metadata%2Fschema%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e1ae56bc612a888bbd0336255bdb431249b8c74/src%2Flibrustc_metadata%2Fschema%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema%2Ftable.rs?ref=8e1ae56bc612a888bbd0336255bdb431249b8c74", "patch": "@@ -11,7 +11,7 @@ use log::debug;\n /// Used mainly for Lazy positions and lengths.\n /// Unchecked invariant: `Self::default()` should encode as `[0; BYTE_LEN]`,\n /// but this has no impact on safety.\n-crate trait FixedSizeEncoding: Default {\n+pub(super) trait FixedSizeEncoding: Default {\n     const BYTE_LEN: usize;\n \n     // FIXME(eddyb) convert to and from `[u8; Self::BYTE_LEN]` instead,\n@@ -125,7 +125,7 @@ impl<T: Encodable> FixedSizeEncoding for Option<Lazy<[T]>> {\n // FIXME(eddyb) replace `Vec` with `[_]` here, such that `Box<Table<T>>` would be used\n // when building it, and `Lazy<Table<T>>` or `&Table<T>` when reading it.\n // (not sure if that is possible given that the `Vec` is being resized now)\n-crate struct Table<T> where Option<T>: FixedSizeEncoding {\n+pub(super) struct Table<T> where Option<T>: FixedSizeEncoding {\n     // FIXME(eddyb) store `[u8; <Option<T>>::BYTE_LEN]` instead of `u8` in `Vec`,\n     // once that starts being allowed by the compiler (i.e. lazy normalization).\n     bytes: Vec<u8>,\n@@ -142,7 +142,7 @@ impl<T> Default for Table<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, i: usize, value: T) {\n+    fn set(&mut self, i: usize, value: T) {\n         // FIXME(eddyb) investigate more compact encodings for sparse tables.\n         // On the PR @michaelwoerister mentioned:\n         // > Space requirements could perhaps be optimized by using the HAMT `popcnt`\n@@ -156,7 +156,7 @@ impl<T> Table<T> where Option<T>: FixedSizeEncoding {\n         Some(value).write_to_bytes_at(&mut self.bytes, i);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let pos = buf.position();\n         buf.emit_raw_bytes(&self.bytes);\n         Lazy::from_position_and_meta(\n@@ -177,7 +177,7 @@ impl<T> LazyMeta for Table<T> where Option<T>: FixedSizeEncoding {\n impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n     /// Given the metadata, extract out the value at a particular index (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         i: usize,\n@@ -193,7 +193,7 @@ impl<T> Lazy<Table<T>> where Option<T>: FixedSizeEncoding {\n /// Like a `Table` but using `DefIndex` instead of `usize` as keys.\n // FIXME(eddyb) replace by making `Table` behave like `IndexVec`,\n // and by using `newtype_index!` to define `DefIndex`.\n-crate struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n+pub(super) struct PerDefTable<T>(Table<T>) where Option<T>: FixedSizeEncoding;\n \n impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n     fn default() -> Self {\n@@ -202,12 +202,12 @@ impl<T> Default for PerDefTable<T> where Option<T>: FixedSizeEncoding {\n }\n \n impl<T> PerDefTable<T> where Option<T>: FixedSizeEncoding {\n-    crate fn set(&mut self, def_id: DefId, value: T) {\n+    pub(super) fn set(&mut self, def_id: DefId, value: T) {\n         assert!(def_id.is_local());\n         self.0.set(def_id.index.index(), value);\n     }\n \n-    crate fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n+    pub(super) fn encode(&self, buf: &mut Encoder) -> Lazy<Self> {\n         let lazy = self.0.encode(buf);\n         Lazy::from_position_and_meta(lazy.position, lazy.meta)\n     }\n@@ -228,7 +228,7 @@ impl<T> Lazy<PerDefTable<T>> where Option<T>: FixedSizeEncoding {\n \n     /// Given the metadata, extract out the value at a particular DefIndex (if any).\n     #[inline(never)]\n-    crate fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n+    pub(super) fn get<'a, 'tcx, M: Metadata<'a, 'tcx>>(\n         &self,\n         metadata: M,\n         def_index: DefIndex,"}]}