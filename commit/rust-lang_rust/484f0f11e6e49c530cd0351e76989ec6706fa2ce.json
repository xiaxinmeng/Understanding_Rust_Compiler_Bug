{"sha": "484f0f11e6e49c530cd0351e76989ec6706fa2ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ4NGYwZjExZTZlNDljNTMwY2QwMzUxZTc2OTg5ZWM2NzA2ZmEyY2U=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:03Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-11T21:55:25Z"}, "message": "Correct nits from @pcwalton", "tree": {"sha": "0906291d66e4c047f9d8e8992da33785483e37fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0906291d66e4c047f9d8e8992da33785483e37fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/484f0f11e6e49c530cd0351e76989ec6706fa2ce", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/484f0f11e6e49c530cd0351e76989ec6706fa2ce", "html_url": "https://github.com/rust-lang/rust/commit/484f0f11e6e49c530cd0351e76989ec6706fa2ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/484f0f11e6e49c530cd0351e76989ec6706fa2ce/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9e3cb678d556926c491d977550fbd805892d4af", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e3cb678d556926c491d977550fbd805892d4af", "html_url": "https://github.com/rust-lang/rust/commit/c9e3cb678d556926c491d977550fbd805892d4af"}], "stats": {"total": 28, "additions": 15, "deletions": 13}, "files": [{"sha": "efd19cf73c0abd555f1ef16317409d38279d03db", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/484f0f11e6e49c530cd0351e76989ec6706fa2ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484f0f11e6e49c530cd0351e76989ec6706fa2ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=484f0f11e6e49c530cd0351e76989ec6706fa2ce", "patch": "@@ -48,7 +48,7 @@\n  * ## By-reference upvars\n  *\n  * One part of the translation which may be non-obvious is that we translate\n- * closure upvars into the dereference of a borrow pointer; this more closely\n+ * closure upvars into the dereference of a borrowed pointer; this more closely\n  * resembles the runtime translation. So, for example, if we had:\n  *\n  *     let mut x = 3;\n@@ -246,7 +246,7 @@ pub struct MemCategorizationContext<TYPER> {\n pub type McResult<T> = Result<T, ()>;\n \n /**\n- * The `Typer` trait provides the interface fro the mem-categorization\n+ * The `Typer` trait provides the interface for the mem-categorization\n  * module to the results of the type check. It can be used to query\n  * the type assigned to an expression node, to inquire after adjustments,\n  * and so on."}, {"sha": "d3a0da4bbfd831d7993f6dd0e5fe169d7c70c175", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/484f0f11e6e49c530cd0351e76989ec6706fa2ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/484f0f11e6e49c530cd0351e76989ec6706fa2ce/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=484f0f11e6e49c530cd0351e76989ec6706fa2ce", "patch": "@@ -38,7 +38,7 @@ checks and effort.\n \n Whenever we introduce a borrowed pointer, for example as the result of\n a borrow expression `let x = &data`, the lifetime of the pointer `x`\n-is always specified as a region inferencr variable. `regionck` has the\n+is always specified as a region inference variable. `regionck` has the\n job of adding constraints such that this inference variable is as\n narrow as possible while still accommodating all uses (that is, every\n dereference of the resulting pointer must be within the lifetime).\n@@ -95,7 +95,7 @@ the following lattice:\n     ty::ImmBorrow -> ty::UniqueImmBorrow -> ty::MutBorrow\n \n So, for example, if we see an assignment `x = 5` to an upvar `x`, we\n-will promote it's borrow kind to mutable borrow. If we see an `&mut x`\n+will promote its borrow kind to mutable borrow. If we see an `&mut x`\n we'll do the same. Naturally, this applies not just to the upvar, but\n to everything owned by `x`, so the result is the same for something\n like `x.f = 5` and so on (presuming `x` is not a borrowed pointer to a\n@@ -107,7 +107,7 @@ The fact that we are inferring borrow kinds as we go results in a\n semi-hacky interaction with mem-categorization. In particular,\n mem-categorization will query the current borrow kind as it\n categorizes, and we'll return the *current* value, but this may get\n-adjusted later. Therefore, in this module, we genreally ignore the\n+adjusted later. Therefore, in this module, we generally ignore the\n borrow kind (and derived mutabilities) that are returned from\n mem-categorization, since they may be inaccurate. (Another option\n would be to use a unification scheme, where instead of returning a\n@@ -698,9 +698,9 @@ fn check_expr_fn_block(rcx: &mut Rcx,\n                     let inner_upvar_id = ty::UpvarId {\n                         var_id: var_id,\n                         closure_expr_id: expr.id };\n-                    link_upvar_borrow_kind(rcx,\n-                                           inner_upvar_id,\n-                                           outer_upvar_id);\n+                    link_upvar_borrow_kind_for_nested_closures(rcx,\n+                                                               inner_upvar_id,\n+                                                               outer_upvar_id);\n                 }\n                 _ => {}\n             }\n@@ -1114,7 +1114,7 @@ fn link_region_from_node_type(rcx: &mut Rcx,\n     /*!\n      * Like `link_region()`, except that the region is\n      * extracted from the type of `id`, which must be some\n-     * region-typed thing.\n+     * reference (`&T`, `&str`, etc).\n      */\n \n     let rptr_ty = rcx.resolve_node_type(id);\n@@ -1359,12 +1359,14 @@ fn adjust_upvar_borrow_kind_for_unique(rcx: &mut Rcx,\n     }\n }\n \n-fn link_upvar_borrow_kind(rcx: &mut Rcx,\n-                          inner_upvar_id: ty::UpvarId,\n-                          outer_upvar_id: ty::UpvarId) {\n+fn link_upvar_borrow_kind_for_nested_closures(rcx: &mut Rcx,\n+                                              inner_upvar_id: ty::UpvarId,\n+                                              outer_upvar_id: ty::UpvarId) {\n     /*!\n      * Indicates that the borrow_kind of `outer_upvar_id` must\n-     * permit a reborrowing with the borrow_kind of `inner_upvar_id`\n+     * permit a reborrowing with the borrow_kind of `inner_upvar_id`.\n+     * This occurs in nested closures, see comment above at the call to\n+     * this function.\n      */\n \n     debug!(\"link_upvar_borrow_kind: inner_upvar_id={:?} outer_upvar_id={:?}\","}]}