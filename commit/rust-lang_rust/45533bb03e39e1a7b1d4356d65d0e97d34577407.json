{"sha": "45533bb03e39e1a7b1d4356d65d0e97d34577407", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1NTMzYmIwM2UzOWUxYTdiMWQ0MzU2ZDY1ZDBlOTdkMzQ1Nzc0MDc=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-24T08:49:01Z"}, "committer": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2015-08-24T08:49:01Z"}, "message": "Merge pull request #220 from Robzz/cast_iusize_improvements\n\nCasts : architecture independent handling of *size types", "tree": {"sha": "5f3fae7c0720b9db12a8a3972d3cac17ef5d1303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3fae7c0720b9db12a8a3972d3cac17ef5d1303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/45533bb03e39e1a7b1d4356d65d0e97d34577407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/45533bb03e39e1a7b1d4356d65d0e97d34577407", "html_url": "https://github.com/rust-lang/rust/commit/45533bb03e39e1a7b1d4356d65d0e97d34577407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/45533bb03e39e1a7b1d4356d65d0e97d34577407/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90", "html_url": "https://github.com/rust-lang/rust/commit/5a5b1ba96b1b2d31ddeb7a6225e65007c2cf1c90"}, {"sha": "3af2e3ba857630214d9bc81756be1c07ae305fc4", "url": "https://api.github.com/repos/rust-lang/rust/commits/3af2e3ba857630214d9bc81756be1c07ae305fc4", "html_url": "https://github.com/rust-lang/rust/commit/3af2e3ba857630214d9bc81756be1c07ae305fc4"}], "stats": {"total": 209, "additions": 139, "deletions": 70}, "files": [{"sha": "66881b522903a1d8f4411586b53f11c5fbaa457b", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45533bb03e39e1a7b1d4356d65d0e97d34577407/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/45533bb03e39e1a7b1d4356d65d0e97d34577407/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=45533bb03e39e1a7b1d4356d65d0e97d34577407", "patch": "@@ -12,6 +12,7 @@ approx_constant          | warn    | the approximate of a known float constant (\n bad_bit_mask             | deny    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n box_vec                  | warn    | usage of `Box<Vec<T>>`, vector elements are already on the heap\n cast_possible_truncation | allow   | casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\n+cast_possible_wrap       | allow   | casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\n cast_precision_loss      | allow   | casts that cause loss of precision, e.g `x as f32` where `x: u64`\n cast_sign_loss           | allow   | casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\n cmp_nan                  | deny    | comparisons to NAN (which will always return false, which is probably not intended)"}, {"sha": "863ba2624dddb233b188139dd89edd4ae6343f27", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/45533bb03e39e1a7b1d4356d65d0e97d34577407/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45533bb03e39e1a7b1d4356d65d0e97d34577407/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=45533bb03e39e1a7b1d4356d65d0e97d34577407", "patch": "@@ -110,6 +110,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         strings::STRING_ADD_ASSIGN,\n         types::BOX_VEC,\n         types::CAST_POSSIBLE_TRUNCATION,\n+        types::CAST_POSSIBLE_WRAP,\n         types::CAST_PRECISION_LOSS,\n         types::CAST_SIGN_LOSS,\n         types::LET_UNIT_VALUE,"}, {"sha": "4e9dd133ac8e76d57c5417bb6b8cb589b42a183d", "filename": "src/types.rs", "status": "modified", "additions": 85, "deletions": 24, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/45533bb03e39e1a7b1d4356d65d0e97d34577407/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45533bb03e39e1a7b1d4356d65d0e97d34577407/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=45533bb03e39e1a7b1d4356d65d0e97d34577407", "patch": "@@ -112,6 +112,8 @@ declare_lint!(pub CAST_SIGN_LOSS, Allow,\n               \"casts from signed types to unsigned types, e.g `x as u32` where `x: i32`\");\n declare_lint!(pub CAST_POSSIBLE_TRUNCATION, Allow,\n               \"casts that may cause truncation of the value, e.g `x as u8` where `x: u32`, or `x as i32` where `x: f32`\");\n+declare_lint!(pub CAST_POSSIBLE_WRAP, Allow,\n+              \"casts that may cause wrapping around the value, e.g `x as i32` where `x: u32` and `x > i32::MAX`\");\n \n /// Returns the size in bits of an integral type.\n /// Will return 0 if the type is not an int or uint variant\n@@ -125,11 +127,85 @@ fn int_ty_to_nbits(typ: &ty::TyS) -> usize {\n     if n == 4 { ::std::usize::BITS } else { n }\n }\n \n+fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n+    match typ.sty {\n+        ty::TyInt(ast::TyIs) | ty::TyUint(ast::TyUs) => true,\n+        _ => false\n+    }\n+}\n+\n+fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+    let mantissa_nbits = if cast_to_f64 {52} else {23};\n+    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n+    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n+    let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n+                         else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n+                         else {int_ty_to_nbits(cast_from).to_string()};\n+    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+              &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n+                        ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n+                       cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n+                       if arch_dependent {arch_dependent_str} else {\"\"},\n+                       from_nbits_str,\n+                       mantissa_nbits));\n+}\n+\n+enum ArchSuffix {\n+    _32, _64, None\n+}\n+\n+fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n+    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n+    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n+    let (from_nbits, to_nbits) = (int_ty_to_nbits(cast_from), int_ty_to_nbits(cast_to));\n+    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n+        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+            (true, true) | (false, false) => (\n+                to_nbits < from_nbits,\n+                ArchSuffix::None,\n+                to_nbits == from_nbits && cast_unsigned_to_signed,\n+                ArchSuffix::None\n+                ),\n+            (true, false) => (\n+                to_nbits <= 32,\n+                if to_nbits == 32 {ArchSuffix::_64} else {ArchSuffix::None},\n+                to_nbits <= 32 && cast_unsigned_to_signed,\n+                ArchSuffix::_32\n+                ),\n+            (false, true) => (\n+                from_nbits == 64,\n+                ArchSuffix::_32,\n+                cast_unsigned_to_signed,\n+                if from_nbits == 64 {ArchSuffix::_64} else {ArchSuffix::_32}\n+                ),\n+        };\n+    if span_truncation {\n+        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                  &format!(\"casting {} to {} may truncate the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_truncation {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+    if span_wrap {\n+        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                  &format!(\"casting {} to {} may wrap around the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_wrap {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+}\n+\n impl LintPass for CastPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CAST_PRECISION_LOSS,\n                     CAST_SIGN_LOSS,\n-                    CAST_POSSIBLE_TRUNCATION)\n+                    CAST_POSSIBLE_TRUNCATION,\n+                    CAST_POSSIBLE_WRAP)\n     }\n \n     fn check_expr(&mut self, cx: &Context, expr: &Expr) {\n@@ -139,45 +215,30 @@ impl LintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits : usize = match cast_to.sty {\n-                            ty::TyFloat(ast::TyF32) => 32,\n-                            ty::TyFloat(ast::TyF64) => 64,\n-                            _ => 0\n-                        };\n-                        if from_nbits != 0 {\n-                            if from_nbits >= to_nbits {\n-                                span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                          &format!(\"converting from {0} to {1}, which causes a loss of precision \\\n-                                                    ({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n-                                                   cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n-                            }\n+                        let to_nbits = if let ty::TyFloat(ast::TyF32) = cast_to.sty {32} else {64};\n+                        if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n+                            span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n                         }\n                     },\n                     (false, true) => {\n                         span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                  &format!(\"casting {} to {} may cause truncation of the value\", cast_from, cast_to));\n+                                  &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n                         if !cast_to.is_signed() {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n                     },\n                     (true, true) => {\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n-                                      &format!(\"casting from {} to {} loses the sign of the value\", cast_from, cast_to));\n-                        }\n-                        let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits   = int_ty_to_nbits(cast_to);\n-                        if to_nbits < from_nbits ||\n-                           (!cast_from.is_signed() && cast_to.is_signed() && to_nbits <= from_nbits) {\n-                                span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                          &format!(\"casting {} to {} may cause truncation of the value\", cast_from, cast_to));\n+                                      &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n+                        check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),\n                                 &ty::TyFloat(ast::TyF32)) = (&cast_from.sty, &cast_to.sty) {\n-                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may cause truncation of the value\");\n+                            span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span, \"casting f64 to f32 may truncate the value\");\n                         }\n                     }\n                 }"}, {"sha": "b17f5de841b409dba142a8257e253202dac43754", "filename": "tests/compile-fail/cast.rs", "status": "modified", "additions": 52, "deletions": 46, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/45533bb03e39e1a7b1d4356d65d0e97d34577407/tests%2Fcompile-fail%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/45533bb03e39e1a7b1d4356d65d0e97d34577407/tests%2Fcompile-fail%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcast.rs?ref=45533bb03e39e1a7b1d4356d65d0e97d34577407", "patch": "@@ -1,57 +1,63 @@\n #![feature(plugin)]\n #![plugin(clippy)]\n \n-#[deny(cast_precision_loss, cast_possible_truncation, cast_sign_loss)]\n-#[allow(dead_code)]\n+#[deny(cast_precision_loss, cast_possible_truncation, cast_sign_loss, cast_possible_wrap)]\n fn main() {\n-    let i : i32 = 42;\n-    let u : u32 = 42;\n-    let f : f32 = 42.0;\n-\n     // Test cast_precision_loss\n-    i as f32; //~ERROR converting from i32 to f32, which causes a loss of precision (i32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n-    (i as i64) as f32; //~ERROR converting from i64 to f32, which causes a loss of precision (i64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n-    (i as i64) as f64; //~ERROR converting from i64 to f64, which causes a loss of precision (i64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n-    u as f32; //~ERROR converting from u32 to f32, which causes a loss of precision (u32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n-    (u as u64) as f32; //~ERROR converting from u64 to f32, which causes a loss of precision (u64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n-    (u as u64) as f64; //~ERROR converting from u64 to f64, which causes a loss of precision (u64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n-    i as f64; // Should not trigger the lint\n-    u as f64; // Should not trigger the lint\n+    1i32 as f32; //~ERROR casting i32 to f32 causes a loss of precision (i32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n+    1i64 as f32; //~ERROR casting i64 to f32 causes a loss of precision (i64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1i64 as f64; //~ERROR casting i64 to f64 causes a loss of precision (i64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1u32 as f32; //~ERROR casting u32 to f32 causes a loss of precision (u32 is 32 bits wide, but f32's mantissa is only 23 bits wide)\n+    1u64 as f32; //~ERROR casting u64 to f32 causes a loss of precision (u64 is 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1u64 as f64; //~ERROR casting u64 to f64 causes a loss of precision (u64 is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1i32 as f64; // Should not trigger the lint\n+    1u32 as f64; // Should not trigger the lint\n \n     // Test cast_possible_truncation\n-    f as i32; //~ERROR casting f32 to i32 may cause truncation of the value\n-    f as u32; //~ERROR casting f32 to u32 may cause truncation of the value\n-              //~^ERROR casting from f32 to u32 loses the sign of the value\n-    i as u8;  //~ERROR casting i32 to u8 may cause truncation of the value\n-              //~^ERROR casting from i32 to u8 loses the sign of the value\n-    (f as f64) as f32; //~ERROR casting f64 to f32 may cause truncation of the value\n-    i as i8;  //~ERROR casting i32 to i8 may cause truncation of the value\n-    u as i32; //~ERROR casting u32 to i32 may cause truncation of the value\n+    1f32 as i32;   //~ERROR casting f32 to i32 may truncate the value\n+    1f32 as u32;   //~ERROR casting f32 to u32 may truncate the value\n+                  //~^ERROR casting f32 to u32 may lose the sign of the value\n+    1f64 as f32;   //~ERROR casting f64 to f32 may truncate the value\n+    1i32 as i8;    //~ERROR casting i32 to i8 may truncate the value\n+    1i32 as u8;    //~ERROR casting i32 to u8 may truncate the value\n+                  //~^ERROR casting i32 to u8 may lose the sign of the value\n+    1f64 as isize; //~ERROR casting f64 to isize may truncate the value\n+    1f64 as usize; //~ERROR casting f64 to usize may truncate the value\n+                  //~^ERROR casting f64 to usize may lose the sign of the value\n \n-    // Test cast_sign_loss\n-    i as u32; //~ERROR casting from i32 to u32 loses the sign of the value\n+    // Test cast_possible_wrap\n+    1u8 as i8;       //~ERROR casting u8 to i8 may wrap around the value\n+    1u16 as i16;     //~ERROR casting u16 to i16 may wrap around the value\n+    1u32 as i32;     //~ERROR casting u32 to i32 may wrap around the value\n+    1u64 as i64;     //~ERROR casting u64 to i64 may wrap around the value\n+    1usize as isize; //~ERROR casting usize to isize may wrap around the value\n \n-    // Extra checks for usize/isize\n-    let is : isize = -42;\n-    is as usize; //~ERROR casting from isize to usize loses the sign of the value\n-    is as i8; //~ERROR casting isize to i8 may cause truncation of the value\n+    // Test cast_sign_loss\n+    1i32 as u32;     //~ERROR casting i32 to u32 may lose the sign of the value\n+    1isize as usize; //~ERROR casting isize to usize may lose the sign of the value\n \n-    // FIXME : enable these checks when we figure out a way to make compiletest deal with conditional compilation\n-    /*\n-    #[cfg(target_pointer_width = \"64\")]\n-    fn check_64() {\n-        let is : isize = -42;\n-        let us : usize = 42;\n-        is as f32; //ERROR converting from isize to f32, which causes a loss of precision (isize is 64 bits wide, but f32's mantissa is only 23 bits wide)\n-        us as u32; //ERROR casting usize to u32 may cause truncation of the value\n-        us as u64; // Should not trigger any lint\n-    }\n-    #[cfg(target_pointer_width = \"32\")]\n-    fn check_32() {\n-        let is : isize = -42;\n-        let us : usize = 42;\n-        is as f32; //ERROR converting from isize to f32, which causes a loss of precision (isize is 32 bits wide, but f32's mantissa is only 23 bits wide)\n-        us as u32; // Should not trigger any lint\n-        us as u64; // Should not trigger any lint\n-    }*/\n+    // Extra checks for *size\n+    // Casting from *size\n+    1isize as i8;  //~ERROR casting isize to i8 may truncate the value\n+    1isize as f64; //~ERROR casting isize to f64 causes a loss of precision on targets with 64-bit wide pointers (isize is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1usize as f64; //~ERROR casting usize to f64 causes a loss of precision on targets with 64-bit wide pointers (usize is 64 bits wide, but f64's mantissa is only 52 bits wide)\n+    1isize as f32; //~ERROR casting isize to f32 causes a loss of precision (isize is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1usize as f32; //~ERROR casting usize to f32 causes a loss of precision (usize is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\n+    1isize as i32; //~ERROR casting isize to i32 may truncate the value on targets with 64-bit wide pointers\n+    1isize as u32; //~ERROR casting isize to u32 may lose the sign of the value\n+                  //~^ERROR casting isize to u32 may truncate the value on targets with 64-bit wide pointers       \n+    1usize as u32; //~ERROR casting usize to u32 may truncate the value on targets with 64-bit wide pointers\n+    1usize as i32; //~ERROR casting usize to i32 may truncate the value on targets with 64-bit wide pointers\n+                  //~^ERROR casting usize to i32 may wrap around the value on targets with 32-bit wide pointers\n+    // Casting to *size\n+    1i64 as isize; //~ERROR casting i64 to isize may truncate the value on targets with 32-bit wide pointers\n+    1i64 as usize; //~ERROR casting i64 to usize may truncate the value on targets with 32-bit wide pointers\n+                  //~^ERROR casting i64 to usize may lose the sign of the value\n+    1u64 as isize; //~ERROR casting u64 to isize may truncate the value on targets with 32-bit wide pointers\n+                  //~^ERROR casting u64 to isize may wrap around the value on targets with 64-bit wide pointers\n+    1u64 as usize; //~ERROR casting u64 to usize may truncate the value on targets with 32-bit wide pointers\n+    1u32 as isize; //~ERROR casting u32 to isize may wrap around the value on targets with 32-bit wide pointers\n+    1u32 as usize; // Should not trigger any lint\n+    1i32 as isize; // Neither should this\n+    1i32 as usize; //~ERROR casting i32 to usize may lose the sign of the value\n }\n\\ No newline at end of file"}]}