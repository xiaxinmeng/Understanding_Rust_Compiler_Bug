{"sha": "30187c81f65aa29a53ad7c24fe3b4c7bff947094", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwMTg3YzgxZjY1YWEyOWE1M2FkN2MyNGZlM2I0YzdiZmY5NDcwOTQ=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-06T00:41:46Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-31T14:15:27Z"}, "message": "Track bound vars", "tree": {"sha": "85770181bda5407a809b80846672706ee2e97763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85770181bda5407a809b80846672706ee2e97763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30187c81f65aa29a53ad7c24fe3b4c7bff947094", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30187c81f65aa29a53ad7c24fe3b4c7bff947094", "html_url": "https://github.com/rust-lang/rust/commit/30187c81f65aa29a53ad7c24fe3b4c7bff947094", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30187c81f65aa29a53ad7c24fe3b4c7bff947094/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62a49c3bb8e0c82ee40b482f08a21a65f90b874b", "url": "https://api.github.com/repos/rust-lang/rust/commits/62a49c3bb8e0c82ee40b482f08a21a65f90b874b", "html_url": "https://github.com/rust-lang/rust/commit/62a49c3bb8e0c82ee40b482f08a21a65f90b874b"}], "stats": {"total": 842, "additions": 479, "deletions": 363}, "files": [{"sha": "4ff5c0a678e514324ce07fa6930471b3f3351b2f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -314,12 +314,12 @@ pub struct GenericArgs<'hir> {\n     pub parenthesized: bool,\n }\n \n-impl GenericArgs<'_> {\n+impl<'tcx> GenericArgs<'tcx> {\n     pub const fn none() -> Self {\n         Self { args: &[], bindings: &[], parenthesized: false }\n     }\n \n-    pub fn inputs(&self) -> &[Ty<'_>] {\n+    pub fn inputs(&self) -> &[Ty<'tcx>] {\n         if self.parenthesized {\n             for arg in self.args {\n                 match arg {"}, {"sha": "c39ea5825a762e40e0826cc820c4d0c1a2a0ff66", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -124,6 +124,7 @@ where\n {\n     fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n         self.as_ref().skip_binder().hash_stable(hcx, hasher);\n+        self.bound_vars().hash_stable(hcx, hasher);\n     }\n }\n "}, {"sha": "d7767dc39cb32a6f9db613fb345d708fea963606", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -122,6 +122,7 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n \n impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        self.bound_vars().encode(e)?;\n         encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n     }\n }\n@@ -228,16 +229,20 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n \n impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, ty::PredicateKind<'tcx>> {\n     fn decode(decoder: &mut D) -> Result<ty::Binder<'tcx, ty::PredicateKind<'tcx>>, D::Error> {\n+        let bound_vars = Decodable::decode(decoder)?;\n         // Handle shorthands first, if we have an usize > 0x80.\n-        Ok(ty::Binder::bind(if decoder.positioned_at_shorthand() {\n-            let pos = decoder.read_usize()?;\n-            assert!(pos >= SHORTHAND_OFFSET);\n-            let shorthand = pos - SHORTHAND_OFFSET;\n-\n-            decoder.with_position(shorthand, ty::PredicateKind::decode)?\n-        } else {\n-            ty::PredicateKind::decode(decoder)?\n-        }))\n+        Ok(ty::Binder::bind_with_vars(\n+            if decoder.positioned_at_shorthand() {\n+                let pos = decoder.read_usize()?;\n+                assert!(pos >= SHORTHAND_OFFSET);\n+                let shorthand = pos - SHORTHAND_OFFSET;\n+\n+                decoder.with_position(shorthand, ty::PredicateKind::decode)?\n+            } else {\n+                ty::PredicateKind::decode(decoder)?\n+            },\n+            bound_vars,\n+        ))\n     }\n }\n \n@@ -379,6 +384,13 @@ impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for [mir::abstract_const::N\n     }\n }\n \n+impl<'tcx, D: TyDecoder<'tcx>> RefDecodable<'tcx, D> for ty::List<ty::BoundVariableKind> {\n+    fn decode(decoder: &mut D) -> Result<&'tcx Self, D::Error> {\n+        let len = decoder.read_usize()?;\n+        Ok(decoder.tcx().mk_bound_variable_kinds((0..len).map(|_| Decodable::decode(decoder)))?)\n+    }\n+}\n+\n impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n@@ -387,7 +399,8 @@ impl_decodable_via_ref! {\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n-    &'tcx mir::coverage::CodeRegion\n+    &'tcx mir::coverage::CodeRegion,\n+    &'tcx ty::List<ty::BoundVariableKind>\n }\n \n #[macro_export]\n@@ -490,12 +503,14 @@ macro_rules! impl_binder_encode_decode {\n         $(\n             impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<'tcx, $t> {\n                 fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                    self.bound_vars().encode(e)?;\n                     self.as_ref().skip_binder().encode(e)\n                 }\n             }\n             impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<'tcx, $t> {\n                 fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n-                    Ok(ty::Binder::bind(Decodable::decode(decoder)?))\n+                    let bound_vars = Decodable::decode(decoder)?;\n+                    Ok(ty::Binder::bind_with_vars(Decodable::decode(decoder)?, bound_vars))\n                 }\n             }\n         )*"}, {"sha": "1f1840c0e4a04916a76d9ac1cd25cc837c27fbf0", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -96,6 +96,7 @@ pub struct CtxtInterners<'tcx> {\n     const_: InternedSet<'tcx, Const<'tcx>>,\n     /// Const allocations.\n     allocation: InternedSet<'tcx, Allocation>,\n+    bound_variable_kinds: InternedSet<'tcx, List<ty::BoundVariableKind>>,\n }\n \n impl<'tcx> CtxtInterners<'tcx> {\n@@ -114,6 +115,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n             place_elems: Default::default(),\n             const_: Default::default(),\n             allocation: Default::default(),\n+            bound_variable_kinds: Default::default(),\n         }\n     }\n \n@@ -1624,6 +1626,7 @@ nop_list_lift! {poly_existential_predicates; ty::Binder<'a, ExistentialPredicate\n nop_list_lift! {predicates; Predicate<'a> => Predicate<'tcx>}\n nop_list_lift! {canonical_var_infos; CanonicalVarInfo<'a> => CanonicalVarInfo<'tcx>}\n nop_list_lift! {projs; ProjectionKind => ProjectionKind}\n+nop_list_lift! {bound_variable_kinds; ty::BoundVariableKind => ty::BoundVariableKind}\n \n // This is the impl for `&'a InternalSubsts<'a>`.\n nop_list_lift! {substs; GenericArg<'a> => GenericArg<'tcx>}\n@@ -2080,6 +2083,7 @@ slice_interners!(\n     predicates: _intern_predicates(Predicate<'tcx>),\n     projs: _intern_projs(ProjectionKind),\n     place_elems: _intern_place_elems(PlaceElem<'tcx>),\n+    bound_variable_kinds: _intern_bound_variable_kinds(ty::BoundVariableKind),\n );\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -2516,6 +2520,13 @@ impl<'tcx> TyCtxt<'tcx> {\n         if ts.is_empty() { List::empty() } else { self._intern_canonical_var_infos(ts) }\n     }\n \n+    pub fn intern_bound_variable_kinds(\n+        self,\n+        ts: &[ty::BoundVariableKind],\n+    ) -> &'tcx List<ty::BoundVariableKind> {\n+        if ts.is_empty() { List::empty() } else { self._intern_bound_variable_kinds(ts) }\n+    }\n+\n     pub fn mk_fn_sig<I>(\n         self,\n         inputs: I,\n@@ -2576,6 +2587,15 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_substs(iter::once(self_ty.into()).chain(rest.iter().cloned()))\n     }\n \n+    pub fn mk_bound_variable_kinds<\n+        I: InternAs<[ty::BoundVariableKind], &'tcx List<ty::BoundVariableKind>>,\n+    >(\n+        self,\n+        iter: I,\n+    ) -> I::Output {\n+        iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n+    }\n+\n     /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n     /// It stops at `bound` and just returns it if reached.\n     pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {"}, {"sha": "32101b4c8c9287f269efda7153e7d230be3f9c99", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 100, "deletions": 51, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -35,6 +35,7 @@ use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n+use rustc_data_structures::sso::SsoHashSet;\n use std::collections::BTreeMap;\n use std::fmt;\n use std::ops::ControlFlow;\n@@ -702,10 +703,109 @@ impl<'tcx> TyCtxt<'tcx> {\n                 r\n             })\n             .0,\n+            self,\n         )\n     }\n }\n \n+pub struct BoundVarsCollector<'tcx> {\n+    binder_index: ty::DebruijnIndex,\n+    vars: BTreeMap<u32, ty::BoundVariableKind>,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> BoundVarsCollector<'tcx> {\n+    pub fn new() -> Self {\n+        BoundVarsCollector {\n+            binder_index: ty::INNERMOST,\n+            vars: BTreeMap::new(),\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+\n+    pub fn into_vars(self, tcx: TyCtxt<'tcx>) -> &'tcx ty::List<ty::BoundVariableKind> {\n+        let max = self.vars.iter().map(|(k, _)| *k).max().unwrap_or_else(|| 0);\n+        for i in 0..max {\n+            if let None = self.vars.get(&i) {\n+                panic!(\"Unknown variable: {:?}\", i);\n+            }\n+        }\n+\n+        tcx.mk_bound_variable_kinds(self.vars.into_iter().map(|(_, v)| v))\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::CONTINUE;\n+        }\n+        use std::collections::btree_map::Entry;\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                match self.vars.entry(bound_ty.var.as_u32()) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(ty::BoundVariableKind::Ty(bound_ty.kind));\n+                    }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        ty::BoundVariableKind::Ty(_) => {}\n+                        _ => bug!(\"Conflicting bound vars\"),\n+                    },\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        use std::collections::btree_map::Entry;\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n+                ty::BrNamed(_def_id, _name) => {\n+                    // FIXME\n+                }\n+\n+                ty::BrAnon(var) => match self.vars.entry(var) {\n+                    Entry::Vacant(entry) => {\n+                        entry.insert(ty::BoundVariableKind::Region(br.kind));\n+                    }\n+                    Entry::Occupied(entry) => match entry.get() {\n+                        ty::BoundVariableKind::Region(_) => {}\n+                        _ => bug!(\"Conflicting bound vars\"),\n+                    },\n+                },\n+\n+                ty::BrEnv => {\n+                    // FIXME\n+                }\n+            },\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n ///////////////////////////////////////////////////////////////////////////\n // Shifter\n //\n@@ -907,57 +1007,6 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n struct FoundFlags;\n \n-crate struct CountBoundVars {\n-    crate outer_index: ty::DebruijnIndex,\n-    crate bound_tys: FxHashSet<ty::BoundTy>,\n-    crate bound_regions: FxHashSet<ty::BoundRegion>,\n-    crate bound_consts: FxHashSet<ty::BoundVar>,\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for CountBoundVars {\n-    type BreakTy = ();\n-\n-    fn visit_binder<T: TypeFoldable<'tcx>>(\n-        &mut self,\n-        t: &Binder<'tcx, T>,\n-    ) -> ControlFlow<Self::BreakTy> {\n-        self.outer_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.outer_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match t.kind {\n-            ty::Bound(debruijn, ty) if debruijn == self.outer_index => {\n-                self.bound_tys.insert(ty);\n-                ControlFlow::CONTINUE\n-            }\n-            _ => t.super_visit_with(self),\n-        }\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match r {\n-            ty::ReLateBound(debruijn, re) if *debruijn == self.outer_index => {\n-                self.bound_regions.insert(*re);\n-                ControlFlow::CONTINUE\n-            }\n-            _ => r.super_visit_with(self),\n-        }\n-    }\n-\n-    fn visit_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        match ct.val {\n-            ty::ConstKind::Bound(debruijn, c) if debruijn == self.outer_index => {\n-                self.bound_consts.insert(c);\n-                ControlFlow::CONTINUE\n-            }\n-            _ => ct.super_visit_with(self),\n-        }\n-    }\n-}\n-\n // FIXME: Optimize for checking for infer flags\n struct HasTypeFlagsVisitor {\n     flags: ty::TypeFlags,"}, {"sha": "a09573fac0234b3ddc128aefea664d5b5a13ad21", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -67,12 +67,12 @@ pub use self::sty::BoundRegionKind::*;\n pub use self::sty::RegionKind::*;\n pub use self::sty::TyKind::*;\n pub use self::sty::{\n-    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, CanonicalPolyFnSig,\n-    ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion, ExistentialPredicate,\n-    ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig, GeneratorSubsts,\n-    GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection, PolyExistentialTraitRef,\n-    PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind, RegionVid, TraitRef,\n-    TyKind, TypeAndMut, UpvarSubsts,\n+    Binder, BoundRegion, BoundRegionKind, BoundTy, BoundTyKind, BoundVar, BoundVariableKind,\n+    CanonicalPolyFnSig, ClosureSubsts, ClosureSubstsParts, ConstVid, EarlyBoundRegion,\n+    ExistentialPredicate, ExistentialProjection, ExistentialTraitRef, FnSig, FreeRegion, GenSig,\n+    GeneratorSubsts, GeneratorSubstsParts, ParamConst, ParamTy, PolyExistentialProjection,\n+    PolyExistentialTraitRef, PolyFnSig, PolyGenSig, PolyTraitRef, ProjectionTy, Region, RegionKind,\n+    RegionVid, TraitRef, TyKind, TypeAndMut, UpvarSubsts,\n };\n pub use self::trait_def::TraitDef;\n \n@@ -546,7 +546,7 @@ impl<'tcx> Predicate<'tcx> {\n         let substs = trait_ref.skip_binder().substs;\n         let pred = self.kind().skip_binder();\n         let new = pred.subst(tcx, substs);\n-        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new))\n+        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new, tcx))\n     }\n }\n "}, {"sha": "a969626b370f5d2dc6320f245d05112343aa60e8", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -460,8 +460,10 @@ where\n {\n     type Lifted = ty::Binder<'tcx, T::Lifted>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        // FIXME: need to lift inner values\n-        tcx.lift(self.skip_binder()).map(|v| ty::Binder::bind(v))\n+        let bound_vars = tcx.lift(self.bound_vars());\n+        tcx.lift(self.skip_binder())\n+            .zip(bound_vars)\n+            .map(|(value, vars)| ty::Binder::bind_with_vars(value, vars))\n     }\n }\n "}, {"sha": "1884df0c67b44f0daa21410d89d1593e905d06be", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 26, "deletions": 43, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -5,6 +5,7 @@\n use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n+use crate::ty::fold::BoundVarsCollector;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{\n@@ -947,6 +948,14 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n     }\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+#[derive(HashStable)]\n+pub enum BoundVariableKind {\n+    Ty(BoundTyKind),\n+    Region(BoundRegionKind),\n+    Const,\n+}\n+\n /// Binder is a binder for higher-ranked lifetimes or types. It is part of the\n /// compiler's representation for things like `for<'a> Fn(&'a isize)`\n /// (which would be represented by the type `PolyTraitRef ==\n@@ -957,7 +966,7 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n ///\n /// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n-pub struct Binder<'tcx, T>(T, u32, std::marker::PhantomData<&'tcx ()>);\n+pub struct Binder<'tcx, T>(T, &'tcx List<BoundVariableKind>);\n \n impl<'tcx, T> Binder<'tcx, T>\n where\n@@ -969,48 +978,22 @@ where\n     /// different binding level.\n     pub fn dummy(value: T) -> Binder<'tcx, T> {\n         debug_assert!(!value.has_escaping_bound_vars());\n-        Binder(value, 0, std::marker::PhantomData)\n+        Binder(value, ty::List::empty())\n     }\n \n     /// Wraps `value` in a binder, binding higher-ranked vars (if any).\n-    pub fn bind(value: T) -> Binder<'tcx, T> {\n-        use crate::ty::fold::CountBoundVars;\n-        use rustc_data_structures::fx::FxHashSet;\n-        let mut counter = CountBoundVars {\n-            outer_index: ty::INNERMOST,\n-            bound_tys: FxHashSet::default(),\n-            bound_regions: FxHashSet::default(),\n-            bound_consts: FxHashSet::default(),\n-        };\n-        value.visit_with(&mut counter);\n-        let bound_tys = counter.bound_tys.len();\n-        let bound_regions = if !counter.bound_regions.is_empty() {\n-            let mut env = false;\n-            let mut anons = FxHashSet::default();\n-            let mut named = FxHashSet::default();\n-            for br in counter.bound_regions {\n-                match br.kind {\n-                    ty::BrAnon(idx) => {\n-                        anons.insert(idx);\n-                    }\n-                    ty::BrNamed(def_id, _) => {\n-                        named.insert(def_id);\n-                    }\n-                    ty::BrEnv => env = true,\n-                }\n-            }\n-            (if env { 1 } else { 0 }) + anons.len() + named.len()\n-        } else {\n-            0\n-        };\n-        let bound_consts = counter.bound_consts.len();\n-\n-        let bound_vars = bound_tys + bound_regions + bound_consts;\n-        Binder(value, bound_vars as u32, std::marker::PhantomData)\n+    pub fn bind(value: T, tcx: TyCtxt<'tcx>) -> Binder<'tcx, T> {\n+        let mut collector = BoundVarsCollector::new();\n+        value.visit_with(&mut collector);\n+        Binder(value, collector.into_vars(tcx))\n     }\n }\n \n impl<'tcx, T> Binder<'tcx, T> {\n+    pub fn bind_with_vars(value: T, vars: &'tcx List<BoundVariableKind>) -> Binder<'tcx, T> {\n+        Binder(value, vars)\n+    }\n+\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -1031,12 +1014,12 @@ impl<'tcx, T> Binder<'tcx, T> {\n         self.0\n     }\n \n-    pub fn bound_vars(&self) -> u32 {\n+    pub fn bound_vars(&self) -> &'tcx List<BoundVariableKind> {\n         self.1\n     }\n \n     pub fn as_ref(&self) -> Binder<'tcx, &T> {\n-        Binder(&self.0, self.1, std::marker::PhantomData)\n+        Binder(&self.0, self.1)\n     }\n \n     pub fn map_bound_ref<F, U>(&self, f: F) -> Binder<'tcx, U>\n@@ -1050,7 +1033,7 @@ impl<'tcx, T> Binder<'tcx, T> {\n     where\n         F: FnOnce(T) -> U,\n     {\n-        Binder(f(self.0), self.1, std::marker::PhantomData)\n+        Binder(f(self.0), self.1)\n     }\n \n     /// Wraps a `value` in a binder, using the same bound variables as the\n@@ -1063,7 +1046,7 @@ impl<'tcx, T> Binder<'tcx, T> {\n     /// because bound vars aren't allowed to change here, whereas they are\n     /// in `bind`. This may be (debug) asserted in the future.\n     pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U> {\n-        Binder(value, self.1, std::marker::PhantomData)\n+        Binder(value, self.1)\n     }\n \n     /// Unwraps and returns the value within, but only if it contains\n@@ -1094,7 +1077,7 @@ impl<'tcx, T> Binder<'tcx, T> {\n     where\n         F: FnOnce(T, U) -> R,\n     {\n-        Binder(f(self.0, u.0), self.1, std::marker::PhantomData)\n+        Binder(f(self.0, u.0), self.1)\n     }\n \n     /// Splits the contents into two things that share the same binder\n@@ -1108,14 +1091,14 @@ impl<'tcx, T> Binder<'tcx, T> {\n         F: FnOnce(T) -> (U, V),\n     {\n         let (u, v) = f(self.0);\n-        (Binder(u, self.1, std::marker::PhantomData), Binder(v, self.1, std::marker::PhantomData))\n+        (Binder(u, self.1), Binder(v, self.1))\n     }\n }\n \n impl<'tcx, T> Binder<'tcx, Option<T>> {\n     pub fn transpose(self) -> Option<Binder<'tcx, T>> {\n         let bound_vars = self.1;\n-        self.0.map(|v| Binder(v, bound_vars, std::marker::PhantomData))\n+        self.0.map(|v| Binder(v, bound_vars))\n     }\n }\n "}, {"sha": "93fbc1f53b2e4315b35ff19a03c5022f8c5aa858", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -510,7 +510,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n-        Some(ty::Binder::bind(env_ty))\n+        Some(ty::Binder::bind(env_ty, self))\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item."}, {"sha": "ce5e41d3e7c866289896035965f68414bea0f1f6", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -850,9 +850,12 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n                     let obligation = Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        Binder::bind(TraitPredicate {\n-                            trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n-                        }),\n+                        Binder::bind(\n+                            TraitPredicate {\n+                                trait_ref: TraitRef::from_method(tcx, trait_id, substs),\n+                            },\n+                            tcx,\n+                        ),\n                     );\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {"}, {"sha": "fc9739f70d40d6aadf4a885f26cea7f688a92336", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -684,7 +684,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n /// Returns the set of inference variables contained in `substs`.\n fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n-    substs: ty::Binder<SubstsRef<'tcx>>,\n+    substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n     selcx\n         .infcx()"}, {"sha": "b3e5df4da0a9fa8254dd5e38de95e66848ce09c5", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1275,6 +1275,9 @@ fn confirm_discriminant_kind_candidate<'cx, 'tcx>(\n     let tcx = selcx.tcx();\n \n     let self_ty = selcx.infcx().shallow_resolve(obligation.predicate.self_ty());\n+    // We get here from `poly_project_and_unify_type` which replaces bound vars\n+    // with placeholders\n+    debug_assert!(!self_ty.has_escaping_bound_vars());\n     let substs = tcx.mk_substs([self_ty.into()].iter());\n \n     let discriminant_def_id = tcx.require_lang_item(LangItem::Discriminant, None);\n@@ -1306,7 +1309,7 @@ fn confirm_pointee_candidate<'cx, 'tcx>(\n         ty: self_ty.ptr_metadata_ty(tcx),\n     };\n \n-    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate), false)\n+    confirm_param_env_candidate(selcx, obligation, ty::Binder::bind(predicate, tcx), false)\n }\n \n fn confirm_fn_pointer_candidate<'cx, 'tcx>("}, {"sha": "874289d02938d038817129714215a78e8453b1ef", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -115,7 +115,7 @@ fn resolve_associated_item<'tcx>(\n     );\n \n     let trait_ref = ty::TraitRef::from_method(tcx, trait_id, rcvr_substs);\n-    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref)))?;\n+    let vtbl = tcx.codegen_fulfill_obligation((param_env, ty::Binder::bind(trait_ref, tcx)))?;\n \n     // Now that we know which impl is being used, we can dispatch to\n     // the actual function:"}, {"sha": "48f2bf1518b17e36af616fd49cbed6b3d04430b7", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -658,7 +658,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs), self.tcx());\n \n         bounds.trait_bounds.push((poly_trait_ref, span, constness));\n \n@@ -741,7 +741,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             false,\n             Some(self_ty),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs));\n+        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs), self.tcx());\n         bounds.trait_bounds.push((poly_trait_ref, span, Constness::NotConst));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -878,9 +878,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     .instantiate_lang_item_trait_ref(\n                         *lang_item, *span, *hir_id, args, param_ty, bounds,\n                     ),\n-                hir::GenericBound::Outlives(ref l) => bounds\n-                    .region_bounds\n-                    .push((ty::Binder::bind(self.ast_region_to_region(l, None)), l.span)),\n+                hir::GenericBound::Outlives(ref l) => bounds.region_bounds.push((\n+                    ty::Binder::bind(self.ast_region_to_region(l, None), self.tcx()),\n+                    l.span,\n+                )),\n             }\n         }\n     }\n@@ -1664,7 +1665,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 };\n \n                 self.one_bound_for_assoc_type(\n-                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref)),\n+                    || traits::supertraits(tcx, ty::Binder::bind(trait_ref, tcx)),\n                     || \"Self\".to_string(),\n                     assoc_ident,\n                     span,\n@@ -2368,8 +2369,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        let bare_fn_ty =\n-            ty::Binder::bind(tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi));\n+        let bare_fn_ty = ty::Binder::bind(\n+            tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi),\n+            tcx,\n+        );\n \n         if !self.allow_ty_infer() {\n             // We always collect the spans for placeholder types when evaluating `fn`s, but we"}, {"sha": "2f30621b0195875c6e4481d198380e7269a26eaa", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -571,13 +571,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let result = ty::Binder::bind(self.tcx.mk_fn_sig(\n-            supplied_arguments,\n-            supplied_return,\n-            decl.c_variadic,\n-            hir::Unsafety::Normal,\n-            Abi::RustCall,\n-        ));\n+        let result = ty::Binder::bind(\n+            self.tcx.mk_fn_sig(\n+                supplied_arguments,\n+                supplied_return,\n+                decl.c_variadic,\n+                hir::Unsafety::Normal,\n+                Abi::RustCall,\n+            ),\n+            self.tcx,\n+        );\n \n         debug!(\"supplied_sig_of_closure: result={:?}\", result);\n "}, {"sha": "f044daa4509186c676629caa8a9bf20a670da719", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -225,7 +225,7 @@ fn compare_predicate_entailment<'tcx>(\n         let (impl_m_own_bounds, _) = infcx.replace_bound_vars_with_fresh_vars(\n             impl_m_span,\n             infer::HigherRankedType,\n-            ty::Binder::bind(impl_m_own_bounds.predicates),\n+            ty::Binder::bind(impl_m_own_bounds.predicates, tcx),\n         );\n         for predicate in impl_m_own_bounds {\n             let traits::Normalized { value: predicate, obligations } =\n@@ -258,14 +258,14 @@ fn compare_predicate_entailment<'tcx>(\n         );\n         let impl_sig =\n             inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, impl_sig);\n-        let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig));\n+        let impl_fty = tcx.mk_fn_ptr(ty::Binder::bind(impl_sig, tcx));\n         debug!(\"compare_impl_method: impl_fty={:?}\", impl_fty);\n \n         let trait_sig = tcx.liberate_late_bound_regions(impl_m.def_id, tcx.fn_sig(trait_m.def_id));\n         let trait_sig = trait_sig.subst(tcx, trait_to_placeholder_substs);\n         let trait_sig =\n             inh.normalize_associated_types_in(impl_m_span, impl_m_hir_id, param_env, trait_sig);\n-        let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig));\n+        let trait_fty = tcx.mk_fn_ptr(ty::Binder::bind(trait_sig, tcx));\n \n         debug!(\"compare_impl_method: trait_fty={:?}\", trait_fty);\n "}, {"sha": "b940e90fadb733c91da758f6c912382f2debb5fd", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let found = self.resolve_vars_with_obligations(found);\n         if let hir::FnRetTy::Return(ty) = fn_decl.output {\n             let ty = <dyn AstConv<'_>>::ast_ty_to_ty(self, ty);\n-            let ty = self.tcx.erase_late_bound_regions(Binder::bind(ty));\n+            let ty = self.tcx.erase_late_bound_regions(Binder::bind(ty, self.tcx));\n             let ty = self.normalize_associated_types_in(expr.span, ty);\n             if self.can_coerce(found, ty) {\n                 err.multipart_suggestion("}, {"sha": "969359a3c214560fc4e091ce0b54a8a2095aa00e", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -202,11 +202,11 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list));\n+    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list, fcx.tcx));\n \n     // Store the generator types and spans into the typeck results for this generator.\n     visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n-        ty::Binder::bind(type_causes);\n+        ty::Binder::bind(type_causes, fcx.tcx);\n \n     debug!(\n         \"types in generator after region replacement {:?}, span = {:?}\","}, {"sha": "3b399b86718a3af09691c2316211559f0b6aa262", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -366,7 +366,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         (n_tps, inputs, output, unsafety)\n     };\n     let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n-    let sig = ty::Binder::bind(sig);\n+    let sig = ty::Binder::bind(sig, tcx);\n     equate_intrinsic_type(tcx, it, n_tps, sig)\n }\n "}, {"sha": "900bd2885fd6fa6e3b92d6c3072a8e19e7c1402b", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -119,7 +119,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n         // We won't add these if we encountered an illegal sized bound, so that we can use\n         // a custom error in that case.\n         if illegal_sized_bound.is_none() {\n-            let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig));\n+            let method_ty = self.tcx.mk_fn_ptr(ty::Binder::bind(method_sig, self.tcx));\n             self.add_obligations(method_ty, all_substs, method_predicates);\n         }\n "}, {"sha": "bd7ffd057b466f9038fcd70f17eb40d4778c8248", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.extend(traits::predicates_for_generics(cause.clone(), self.param_env, bounds));\n \n         // Also add an obligation for the method type being well-formed.\n-        let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig));\n+        let method_ty = tcx.mk_fn_ptr(ty::Binder::bind(fn_sig, tcx));\n         debug!(\n             \"lookup_in_trait_adjusted: matched method method_ty={:?} obligation={:?}\",\n             method_ty, obligation"}, {"sha": "887cc42a1dd272bb058f5c5eac78be86cc141a1b", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1067,13 +1067,14 @@ fn check_method_receiver<'fcx, 'tcx>(\n     debug!(\"check_method_receiver: sig={:?}\", sig);\n \n     let self_ty = fcx.normalize_associated_types_in(span, self_ty);\n-    let self_ty = fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_ty));\n+    let self_ty =\n+        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(self_ty, fcx.tcx));\n \n     let receiver_ty = sig.inputs()[0];\n \n     let receiver_ty = fcx.normalize_associated_types_in(span, receiver_ty);\n     let receiver_ty =\n-        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(receiver_ty));\n+        fcx.tcx.liberate_late_bound_regions(method.def_id, ty::Binder::bind(receiver_ty, fcx.tcx));\n \n     if fcx.tcx.features().arbitrary_self_types {\n         if !receiver_is_valid(fcx, span, receiver_ty, self_ty, true) {"}, {"sha": "b42ef7efcbc946cd3b181686342da8acc0153826", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 19, "deletions": 15, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1707,7 +1707,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     }\n                     diag.emit();\n \n-                    ty::Binder::bind(fn_sig)\n+                    ty::Binder::bind(fn_sig, tcx)\n                 }\n                 None => <dyn AstConv<'_>>::ty_of_fn(\n                     &icx,\n@@ -1749,13 +1749,10 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             let ty = tcx.type_of(tcx.hir().get_parent_did(hir_id).to_def_id());\n             let inputs =\n                 data.fields().iter().map(|f| tcx.type_of(tcx.hir().local_def_id(f.hir_id)));\n-            ty::Binder::bind(tcx.mk_fn_sig(\n-                inputs,\n-                ty,\n-                false,\n-                hir::Unsafety::Normal,\n-                abi::Abi::Rust,\n-            ))\n+            ty::Binder::bind(\n+                tcx.mk_fn_sig(inputs, ty, false, hir::Unsafety::Normal, abi::Abi::Rust),\n+                tcx,\n+            )\n         }\n \n         Expr(&hir::Expr { kind: hir::ExprKind::Closure(..), .. }) => {\n@@ -2039,7 +2036,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 param.bounds.iter().for_each(|bound| match bound {\n                     hir::GenericBound::Outlives(lt) => {\n                         let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, &lt, None);\n-                        let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound));\n+                        let outlives = ty::Binder::bind(ty::OutlivesPredicate(region, bound), tcx);\n                         predicates.insert((outlives.to_predicate(tcx), lt.span));\n                     }\n                     _ => bug!(),\n@@ -2099,9 +2096,13 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n-                        let predicate = ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n-                            ty::OutlivesPredicate(ty, re_root_empty),\n-                        ));\n+                        let predicate = ty::Binder::bind(\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                ty,\n+                                re_root_empty,\n+                            )),\n+                            tcx,\n+                        );\n                         predicates.insert((predicate.to_predicate(tcx), span));\n                     }\n                 }\n@@ -2144,9 +2145,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                             let region =\n                                 <dyn AstConv<'_>>::ast_region_to_region(&icx, lifetime, None);\n                             predicates.insert((\n-                                ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n-                                    ty::OutlivesPredicate(ty, region),\n-                                ))\n+                                ty::Binder::bind(\n+                                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n+                                        ty, region,\n+                                    )),\n+                                    tcx,\n+                                )\n                                 .to_predicate(tcx),\n                                 lifetime.span,\n                             ));"}, {"sha": "dac42058b1b3716a7326fcff2dd138c3af2eb951", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 160, "deletions": 152, "changes": 312, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -48,42 +48,42 @@ crate use self::types::Type::*;\n crate use self::types::Visibility::{Inherited, Public};\n crate use self::types::*;\n \n-crate trait Clean<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> T;\n+crate trait Clean<'tcx, T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> T;\n }\n \n-impl<T: Clean<U>, U> Clean<Vec<U>> for [T] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<U> {\n+impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, Vec<U>> for [T] {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl<T: Clean<U>, U, V: Idx> Clean<IndexVec<V, U>> for IndexVec<V, T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> IndexVec<V, U> {\n+impl<'tcx, T: Clean<'tcx, U>, U, V: Idx> Clean<'tcx, IndexVec<V, U>> for IndexVec<V, T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> IndexVec<V, U> {\n         self.iter().map(|x| x.clean(cx)).collect()\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for &T {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n+impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, U> for &T {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> U {\n+impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, U> for Rc<T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> U {\n         (**self).clean(cx)\n     }\n }\n \n-impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<U> {\n+impl<'tcx, T: Clean<'tcx, U>, U> Clean<'tcx, Option<U>> for Option<T> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<U> {\n         self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n-impl Clean<ExternalCrate> for CrateNum {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> ExternalCrate {\n+impl<'tcx> Clean<'tcx, ExternalCrate> for CrateNum {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> ExternalCrate {\n         let tcx = cx.tcx;\n         let root = DefId { krate: *self, index: CRATE_DEF_INDEX };\n         let krate_span = tcx.def_span(root);\n@@ -204,8 +204,8 @@ impl Clean<ExternalCrate> for CrateNum {\n     }\n }\n \n-impl Clean<Item> for doctree::Module<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for doctree::Module<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let mut items: Vec<Item> = vec![];\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n@@ -237,14 +237,14 @@ impl Clean<Item> for doctree::Module<'_> {\n     }\n }\n \n-impl Clean<Attributes> for [ast::Attribute] {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Attributes {\n+impl<'tcx> Clean<'tcx, Attributes> for [ast::Attribute] {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Attributes {\n         Attributes::from_ast(cx.sess().diagnostic(), self, None)\n     }\n }\n \n-impl Clean<GenericBound> for hir::GenericBound<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for hir::GenericBound<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         match *self {\n             hir::GenericBound::Outlives(lt) => GenericBound::Outlives(lt.clean(cx)),\n             hir::GenericBound::LangItemTrait(lang_item, span, _, generic_args) => {\n@@ -270,8 +270,8 @@ impl Clean<GenericBound> for hir::GenericBound<'_> {\n     }\n }\n \n-impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for (ty::TraitRef<'tcx>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         let (trait_ref, bounds) = *self;\n         inline::record_extern_fqn(cx, trait_ref.def_id, TypeKind::Trait);\n         let path = external_path(\n@@ -289,17 +289,17 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n     }\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::TraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for ty::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         GenericBound::TraitBound(\n             PolyTrait { trait_: (*self, &[][..]).clean(cx), generic_params: vec![] },\n             hir::TraitBoundModifier::None,\n         )\n     }\n }\n \n-impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for (ty::PolyTraitRef<'tcx>, &[TypeBinding]) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         let (poly_trait_ref, bounds) = *self;\n         let poly_trait_ref = poly_trait_ref.lift_to_tcx(cx.tcx).unwrap();\n \n@@ -326,14 +326,14 @@ impl Clean<GenericBound> for (ty::PolyTraitRef<'_>, &[TypeBinding]) {\n     }\n }\n \n-impl<'tcx> Clean<GenericBound> for ty::PolyTraitRef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericBound {\n+impl<'tcx> Clean<'tcx, GenericBound> for ty::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericBound {\n         (*self, &[][..]).clean(cx)\n     }\n }\n \n-impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<Vec<GenericBound>> {\n+impl<'tcx> Clean<'tcx, Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<Vec<GenericBound>> {\n         let mut v = Vec::new();\n         v.extend(self.regions().filter_map(|r| r.clean(cx)).map(GenericBound::Outlives));\n         v.extend(self.types().map(|t| {\n@@ -346,8 +346,8 @@ impl<'tcx> Clean<Option<Vec<GenericBound>>> for InternalSubsts<'tcx> {\n     }\n }\n \n-impl Clean<Lifetime> for hir::Lifetime {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Lifetime {\n+impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Lifetime {\n         let def = cx.tcx.named_region(self.hir_id);\n         match def {\n             Some(\n@@ -365,8 +365,8 @@ impl Clean<Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl Clean<Lifetime> for hir::GenericParam<'_> {\n-    fn clean(&self, _: &mut DocContext<'_>) -> Lifetime {\n+impl<'tcx> Clean<'tcx, Lifetime> for hir::GenericParam<'tcx> {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> Lifetime {\n         match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 if !self.bounds.is_empty() {\n@@ -389,8 +389,8 @@ impl Clean<Lifetime> for hir::GenericParam<'_> {\n     }\n }\n \n-impl Clean<Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         Constant {\n             type_: cx\n                 .tcx\n@@ -401,14 +401,14 @@ impl Clean<Constant> for hir::ConstArg {\n     }\n }\n \n-impl Clean<Lifetime> for ty::GenericParamDef {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Lifetime {\n+impl<'tcx> Clean<'tcx, Lifetime> for ty::GenericParamDef {\n+    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Lifetime {\n         Lifetime(self.name)\n     }\n }\n \n-impl Clean<Option<Lifetime>> for ty::RegionKind {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n+impl<'tcx> Clean<'tcx, Option<Lifetime>> for ty::RegionKind {\n+    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n             ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) => {\n@@ -429,8 +429,8 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     }\n }\n \n-impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n+impl<'tcx> Clean<'tcx, WherePredicate> for hir::WherePredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n         match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n                 ty: wbp.bounded_ty.clean(cx),\n@@ -449,8 +449,8 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n     }\n }\n \n-impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'a> Clean<'a, Option<WherePredicate>> for ty::Predicate<'a> {\n+    fn clean(&self, cx: &mut DocContext<'a>) -> Option<WherePredicate> {\n         let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n             ty::PredicateKind::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n@@ -469,8 +469,8 @@ impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     }\n }\n \n-impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n+impl<'tcx> Clean<'tcx, WherePredicate> for ty::PolyTraitPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n         let poly_trait_ref = self.map_bound(|pred| pred.trait_ref);\n         WherePredicate::BoundPredicate {\n             ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n@@ -479,10 +479,10 @@ impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>>\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n     for ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(a, b) = self;\n \n         if let (ty::ReEmpty(_), ty::ReEmpty(_)) = (a, b) {\n@@ -496,8 +496,10 @@ impl<'tcx> Clean<Option<WherePredicate>>\n     }\n }\n \n-impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+impl<'tcx> Clean<'tcx, Option<WherePredicate>>\n+    for ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>\n+{\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Option<WherePredicate> {\n         let ty::OutlivesPredicate(ty, lt) = self;\n \n         if let ty::ReEmpty(_) = lt {\n@@ -511,15 +513,15 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n     }\n }\n \n-impl<'tcx> Clean<WherePredicate> for ty::ProjectionPredicate<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n+impl<'tcx> Clean<'tcx, WherePredicate> for ty::ProjectionPredicate<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> WherePredicate {\n         let ty::ProjectionPredicate { projection_ty, ty } = self;\n         WherePredicate::EqPredicate { lhs: projection_ty.clean(cx), rhs: ty.clean(cx) }\n     }\n }\n \n-impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for ty::ProjectionTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         let lifted = self.lift_to_tcx(cx.tcx).unwrap();\n         let trait_ = match lifted.trait_ref(cx.tcx).clean(cx) {\n             GenericBound::TraitBound(t, _) => t.trait_,\n@@ -533,8 +535,8 @@ impl<'tcx> Clean<Type> for ty::ProjectionTy<'tcx> {\n     }\n }\n \n-impl Clean<GenericParamDef> for ty::GenericParamDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n+impl<'tcx> Clean<'tcx, GenericParamDef> for ty::GenericParamDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             ty::GenericParamDefKind::Lifetime => (self.name, GenericParamDefKind::Lifetime),\n             ty::GenericParamDefKind::Type { has_default, synthetic, .. } => {\n@@ -563,8 +565,8 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n+impl<'tcx> Clean<'tcx, GenericParamDef> for hir::GenericParam<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericParamDef {\n         let (name, kind) = match self.kind {\n             hir::GenericParamKind::Lifetime { .. } => {\n                 let name = if !self.bounds.is_empty() {\n@@ -606,8 +608,8 @@ impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n     }\n }\n \n-impl Clean<Generics> for hir::Generics<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n+impl<'tcx> Clean<'tcx, Generics> for hir::Generics<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n         // Synthetic type-parameters are inserted after normal ones.\n         // In order for normal parameters to be able to refer to synthetic ones,\n         // scans them first.\n@@ -686,8 +688,8 @@ impl Clean<Generics> for hir::Generics<'_> {\n     }\n }\n \n-impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Generics {\n+impl<'a, 'tcx> Clean<'tcx, Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx>) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Generics {\n         use self::WherePredicate as WP;\n         use std::collections::BTreeMap;\n \n@@ -851,13 +853,13 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n     }\n }\n \n-fn clean_fn_or_proc_macro(\n-    item: &hir::Item<'_>,\n-    sig: &'a hir::FnSig<'a>,\n-    generics: &'a hir::Generics<'a>,\n+fn clean_fn_or_proc_macro<'a, 'tcx>(\n+    item: &hir::Item<'tcx>,\n+    sig: &'a hir::FnSig<'tcx>,\n+    generics: &'a hir::Generics<'tcx>,\n     body_id: hir::BodyId,\n     name: &mut Symbol,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> ItemKind {\n     let attrs = cx.tcx.hir().attrs(item.hir_id());\n     let macro_kind = attrs.iter().find_map(|a| {\n@@ -911,16 +913,18 @@ fn clean_fn_or_proc_macro(\n     }\n }\n \n-impl<'a> Clean<Function> for (&'a hir::FnSig<'a>, &'a hir::Generics<'a>, hir::BodyId) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Function {\n+impl<'a, 'tcx> Clean<'tcx, Function>\n+    for (&'a hir::FnSig<'tcx>, &'a hir::Generics<'tcx>, hir::BodyId)\n+{\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Function {\n         let (generics, decl) =\n             enter_impl_trait(cx, |cx| (self.1.clean(cx), (&*self.0.decl, self.2).clean(cx)));\n         Function { decl, generics, header: self.0.header }\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n+impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], &'a [Ident]) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Arguments {\n         Arguments {\n             values: self\n                 .0\n@@ -938,8 +942,8 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], &'a [Ident]) {\n     }\n }\n \n-impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Arguments {\n+impl<'a, 'tcx> Clean<'tcx, Arguments> for (&'a [hir::Ty<'tcx>], hir::BodyId) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Arguments {\n         let body = cx.tcx.hir().body(self.1);\n \n         Arguments {\n@@ -948,30 +952,30 @@ impl<'a> Clean<Arguments> for (&'a [hir::Ty<'a>], hir::BodyId) {\n                 .iter()\n                 .enumerate()\n                 .map(|(i, ty)| Argument {\n-                    name: name_from_pat(&body.params[i].pat),\n+                    name: Symbol::intern(&rustc_hir_pretty::param_to_string(&body.params[i])),\n                     type_: ty.clean(cx),\n                 })\n                 .collect(),\n         }\n     }\n }\n \n-impl<'a, A: Copy> Clean<FnDecl> for (&'a hir::FnDecl<'a>, A)\n+impl<'a, 'tcx, A: Copy> Clean<'tcx, FnDecl> for (&'a hir::FnDecl<'tcx>, A)\n where\n-    (&'a [hir::Ty<'a>], A): Clean<Arguments>,\n+    (&'a [hir::Ty<'a>], A): Clean<'tcx, Arguments>,\n {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnDecl {\n         FnDecl {\n-            inputs: (self.0.inputs, self.1).clean(cx),\n+            inputs: (&self.0.inputs[..], self.1).clean(cx),\n             output: self.0.output.clean(cx),\n             c_variadic: self.0.c_variadic,\n             attrs: Attributes::default(),\n         }\n     }\n }\n \n-impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnDecl {\n+impl<'tcx> Clean<'tcx, FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnDecl {\n         let (did, sig) = *self;\n         let mut names = if did.is_local() { &[] } else { cx.tcx.fn_arg_names(did) }.iter();\n \n@@ -994,16 +998,16 @@ impl<'tcx> Clean<FnDecl> for (DefId, ty::PolyFnSig<'tcx>) {\n     }\n }\n \n-impl Clean<FnRetTy> for hir::FnRetTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> FnRetTy {\n+impl<'tcx> Clean<'tcx, FnRetTy> for hir::FnRetTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> FnRetTy {\n         match *self {\n             Self::Return(ref typ) => Return(typ.clean(cx)),\n             Self::DefaultReturn(..) => DefaultReturn,\n         }\n     }\n }\n \n-impl Clean<bool> for hir::IsAuto {\n+impl Clean<'_, bool> for hir::IsAuto {\n     fn clean(&self, _: &mut DocContext<'_>) -> bool {\n         match *self {\n             hir::IsAuto::Yes => true,\n@@ -1012,30 +1016,30 @@ impl Clean<bool> for hir::IsAuto {\n     }\n }\n \n-impl Clean<Type> for hir::TraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for hir::TraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         let path = self.path.clean(cx);\n         resolve_type(cx, path, self.hir_ref_id)\n     }\n }\n \n-impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n+impl<'tcx> Clean<'tcx, PolyTrait> for hir::PolyTraitRef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n             generic_params: self.bound_generic_params.clean(cx),\n         }\n     }\n }\n \n-impl Clean<TypeKind> for hir::def::DefKind {\n-    fn clean(&self, _: &mut DocContext<'_>) -> TypeKind {\n+impl<'tcx> Clean<'tcx, TypeKind> for hir::def::DefKind {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> TypeKind {\n         (*self).into()\n     }\n }\n \n-impl Clean<Item> for hir::TraitItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::TraitItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1075,8 +1079,8 @@ impl Clean<Item> for hir::TraitItem<'_> {\n     }\n }\n \n-impl Clean<Item> for hir::ImplItem<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::ImplItem<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let local_did = self.def_id.to_def_id();\n         cx.with_param_env(local_did, |cx| {\n             let inner = match self.kind {\n@@ -1124,8 +1128,8 @@ impl Clean<Item> for hir::ImplItem<'_> {\n     }\n }\n \n-impl Clean<Item> for ty::AssocItem {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::AssocItem {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let tcx = cx.tcx;\n         let kind = match self.kind {\n             ty::AssocKind::Const => {\n@@ -1276,7 +1280,7 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n-fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n+fn clean_qpath<'tcx>(hir_ty: &hir::Ty<'tcx>, cx: &mut DocContext<'tcx>) -> Type {\n     use rustc_hir::GenericParamCount;\n     let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n     let qpath = match kind {\n@@ -1428,8 +1432,8 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n     }\n }\n \n-impl Clean<Type> for hir::Ty<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for hir::Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         use rustc_hir::*;\n \n         match self.kind {\n@@ -1531,8 +1535,8 @@ fn normalize(cx: &mut DocContext<'tcx>, ty: Ty<'_>) -> Option<Ty<'tcx>> {\n     }\n }\n \n-impl<'tcx> Clean<Type> for Ty<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Type {\n+impl<'tcx> Clean<'tcx, Type> for Ty<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Type {\n         debug!(\"cleaning type: {:?}\", self);\n         let ty = normalize(cx, self).unwrap_or(self);\n         match *ty.kind() {\n@@ -1739,8 +1743,8 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Constant {\n+impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n         // FIXME: instead of storing the stringified expression, store `self` directly instead.\n         Constant {\n             type_: self.ty.clean(cx),\n@@ -1749,8 +1753,8 @@ impl<'tcx> Clean<Constant> for ty::Const<'tcx> {\n     }\n }\n \n-impl Clean<Item> for hir::FieldDef<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let what_rustc_thinks = Item::from_hir_id_and_parts(\n             self.hir_id,\n             Some(self.ident.name),\n@@ -1762,8 +1766,8 @@ impl Clean<Item> for hir::FieldDef<'_> {\n     }\n }\n \n-impl Clean<Item> for ty::FieldDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl Clean<'tcx, Item> for ty::FieldDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let what_rustc_thinks = Item::from_def_id_and_parts(\n             self.did,\n             Some(self.ident.name),\n@@ -1775,8 +1779,8 @@ impl Clean<Item> for ty::FieldDef {\n     }\n }\n \n-impl Clean<Visibility> for hir::Visibility<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Visibility {\n+impl<'tcx> Clean<'tcx, Visibility> for hir::Visibility<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Visibility {\n         match self.node {\n             hir::VisibilityKind::Public => Visibility::Public,\n             hir::VisibilityKind::Inherited => Visibility::Inherited,\n@@ -1793,8 +1797,8 @@ impl Clean<Visibility> for hir::Visibility<'_> {\n     }\n }\n \n-impl Clean<Visibility> for ty::Visibility {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Visibility {\n+impl<'tcx> Clean<'tcx, Visibility> for ty::Visibility {\n+    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Visibility {\n         match *self {\n             ty::Visibility::Public => Visibility::Public,\n             // NOTE: this is not quite right: `ty` uses `Invisible` to mean 'private',\n@@ -1808,8 +1812,8 @@ impl Clean<Visibility> for ty::Visibility {\n     }\n }\n \n-impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> VariantStruct {\n+impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n             fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n@@ -1818,8 +1822,8 @@ impl Clean<VariantStruct> for rustc_hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Item> for ty::VariantDef {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n             CtorKind::Fn => Variant::Tuple(\n@@ -1849,8 +1853,8 @@ impl Clean<Item> for ty::VariantDef {\n     }\n }\n \n-impl Clean<Variant> for hir::VariantData<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Variant {\n+impl<'tcx> Clean<'tcx, Variant> for hir::VariantData<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Variant {\n         match self {\n             hir::VariantData::Struct(..) => Variant::Struct(self.clean(cx)),\n             hir::VariantData::Tuple(..) => {\n@@ -1861,14 +1865,14 @@ impl Clean<Variant> for hir::VariantData<'_> {\n     }\n }\n \n-impl Clean<Span> for rustc_span::Span {\n-    fn clean(&self, _cx: &mut DocContext<'_>) -> Span {\n+impl<'tcx> Clean<'tcx, Span> for rustc_span::Span {\n+    fn clean(&self, _cx: &mut DocContext<'tcx>) -> Span {\n         Span::from_rustc_span(*self)\n     }\n }\n \n-impl Clean<Path> for hir::Path<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Path {\n+impl<'tcx> Clean<'tcx, Path> for hir::Path<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Path {\n         Path {\n             global: self.is_global(),\n             res: self.res,\n@@ -1877,8 +1881,8 @@ impl Clean<Path> for hir::Path<'_> {\n     }\n }\n \n-impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericArgs {\n+impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> GenericArgs {\n         if self.parenthesized {\n             let output = self.bindings[0].ty().clean(cx);\n             GenericArgs::Parenthesized {\n@@ -1905,37 +1909,37 @@ impl Clean<GenericArgs> for hir::GenericArgs<'_> {\n     }\n }\n \n-impl Clean<PathSegment> for hir::PathSegment<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> PathSegment {\n+impl<'tcx> Clean<'tcx, PathSegment> for hir::PathSegment<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> PathSegment {\n         PathSegment { name: self.ident.name, args: self.args().clean(cx) }\n     }\n }\n \n-impl Clean<String> for Ident {\n+impl<'tcx> Clean<'tcx, String> for Ident {\n     #[inline]\n-    fn clean(&self, cx: &mut DocContext<'_>) -> String {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> String {\n         self.name.clean(cx)\n     }\n }\n \n-impl Clean<String> for Symbol {\n+impl<'tcx> Clean<'tcx, String> for Symbol {\n     #[inline]\n-    fn clean(&self, _: &mut DocContext<'_>) -> String {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> String {\n         self.to_string()\n     }\n }\n \n-impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n+impl<'tcx> Clean<'tcx, BareFunctionDecl> for hir::BareFnTy<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             (self.generic_params.clean(cx), (&*self.decl, self.param_names).clean(cx))\n         });\n         BareFunctionDecl { unsafety: self.unsafety, abi: self.abi, decl, generic_params }\n     }\n }\n \n-impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Vec<Item> {\n+impl<'tcx> Clean<'tcx, Vec<Item>> for (&hir::Item<'tcx>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n         use hir::ItemKind;\n \n         let (item, renamed) = self;\n@@ -2018,8 +2022,8 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n     }\n }\n \n-impl Clean<Item> for hir::Variant<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for hir::Variant<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = VariantItem(self.data.clean(cx));\n         let what_rustc_thinks =\n             Item::from_hir_id_and_parts(self.id, Some(self.ident.name), kind, cx);\n@@ -2028,9 +2032,9 @@ impl Clean<Item> for hir::Variant<'_> {\n     }\n }\n \n-impl Clean<bool> for ty::ImplPolarity {\n+impl<'tcx> Clean<'tcx, bool> for ty::ImplPolarity {\n     /// Returns whether the impl has negative polarity.\n-    fn clean(&self, _: &mut DocContext<'_>) -> bool {\n+    fn clean(&self, _: &mut DocContext<'tcx>) -> bool {\n         match self {\n             &ty::ImplPolarity::Positive |\n             // FIXME: do we want to do something else here?\n@@ -2040,7 +2044,11 @@ impl Clean<bool> for ty::ImplPolarity {\n     }\n }\n \n-fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>) -> Vec<Item> {\n+fn clean_impl<'tcx>(\n+    impl_: &hir::Impl<'tcx>,\n+    hir_id: hir::HirId,\n+    cx: &mut DocContext<'tcx>,\n+) -> Vec<Item> {\n     let tcx = cx.tcx;\n     let mut ret = Vec::new();\n     let trait_ = impl_.of_trait.clean(cx);\n@@ -2085,11 +2093,11 @@ fn clean_impl(impl_: &hir::Impl<'_>, hir_id: hir::HirId, cx: &mut DocContext<'_>\n     ret\n }\n \n-fn clean_extern_crate(\n-    krate: &hir::Item<'_>,\n+fn clean_extern_crate<'tcx>(\n+    krate: &hir::Item<'tcx>,\n     name: Symbol,\n     orig_name: Option<Symbol>,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // this is the ID of the `extern crate` statement\n     let cnum = cx.tcx.extern_mod_stmt_cnum(krate.def_id).unwrap_or(LOCAL_CRATE);\n@@ -2132,12 +2140,12 @@ fn clean_extern_crate(\n     }]\n }\n \n-fn clean_use_statement(\n-    import: &hir::Item<'_>,\n+fn clean_use_statement<'tcx>(\n+    import: &hir::Item<'tcx>,\n     name: Symbol,\n-    path: &hir::Path<'_>,\n+    path: &hir::Path<'tcx>,\n     kind: hir::UseKind,\n-    cx: &mut DocContext<'_>,\n+    cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     // We need this comparison because some imports (for std types for example)\n     // are \"inserted\" as well but directly by the compiler and they should not be\n@@ -2227,8 +2235,8 @@ fn clean_use_statement(\n     vec![Item::from_def_id_and_parts(import.def_id.to_def_id(), None, ImportItem(inner), cx)]\n }\n \n-impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for (&hir::ForeignItem<'tcx>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let (item, renamed) = self;\n         cx.with_param_env(item.def_id.to_def_id(), |cx| {\n             let kind = match item.kind {\n@@ -2264,8 +2272,8 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n     }\n }\n \n-impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n+impl<'tcx> Clean<'tcx, Item> for (&hir::MacroDef<'tcx>, Option<Symbol>) {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let (item, renamed) = self;\n         let name = renamed.unwrap_or(item.ident.name);\n         let tts = item.ast.body.inner_tokens().trees().collect::<Vec<_>>();\n@@ -2313,14 +2321,14 @@ impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n     }\n }\n \n-impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n+impl<'tcx> Clean<'tcx, TypeBinding> for hir::TypeBinding<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBinding {\n         TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }\n     }\n }\n \n-impl Clean<TypeBindingKind> for hir::TypeBindingKind<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> TypeBindingKind {\n+impl<'tcx> Clean<'tcx, TypeBindingKind> for hir::TypeBindingKind<'tcx> {\n+    fn clean(&self, cx: &mut DocContext<'tcx>) -> TypeBindingKind {\n         match *self {\n             hir::TypeBindingKind::Equality { ref ty } => {\n                 TypeBindingKind::Equality { ty: ty.clean(cx) }"}, {"sha": "ce802902f5bae3a7c64e01181fdf1f89d5b75175", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -84,12 +84,12 @@ crate fn krate(cx: &mut DocContext<'_>) -> Crate {\n     }\n }\n \n-fn external_generic_args(\n-    cx: &mut DocContext<'_>,\n+fn external_generic_args<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     trait_did: Option<DefId>,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> GenericArgs {\n     let mut skip_self = has_self;\n     let mut ty_kind = None;\n@@ -136,13 +136,13 @@ fn external_generic_args(\n \n // trait_did should be set to a trait's DefId if called on a TraitRef, in order to sugar\n // from Fn<(A, B,), C> to Fn(A, B) -> C\n-pub(super) fn external_path(\n-    cx: &mut DocContext<'_>,\n+pub(super) fn external_path<'tcx>(\n+    cx: &mut DocContext<'tcx>,\n     name: Symbol,\n     trait_did: Option<DefId>,\n     has_self: bool,\n     bindings: Vec<TypeBinding>,\n-    substs: SubstsRef<'_>,\n+    substs: SubstsRef<'tcx>,\n ) -> Path {\n     Path {\n         global: false,"}, {"sha": "0bcda8c01cd4ab63850dc8fc9bf9ca04d1cb9b88", "filename": "src/test/ui/hrtb/complex.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -0,0 +1,20 @@\n+// check-pass\n+\n+trait A<'a> {}\n+trait B<'b> {}\n+fn foo<T>() where for<'a> T: A<'a> + 'a {}\n+trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n+    type As;\n+}\n+struct D<T> where T: for<'c> C<'c, As=&'c ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n+trait E<'e> {\n+    type As;\n+}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e> {}\n+struct G<T> where T: for<'f> F<'f, As=&'f ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+fn main() {}"}, {"sha": "fa59d7a031397530d9114219be96e3c8097302f9", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,)))`\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,)), [])`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "3dd2b19fbf987f9cc290979b09f0988ac9c06fd5", "filename": "src/test/ui/symbol-names/basic.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fbasic.legacy.stderr?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN5basic4main17hfcf1daab33c43a6aE)\n+error: symbol-name(_ZN5basic4main17h6c535bbea2051f85E)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]\n    | ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(basic::main::hfcf1daab33c43a6a)\n+error: demangling(basic::main::h6c535bbea2051f85)\n   --> $DIR/basic.rs:8:1\n    |\n LL | #[rustc_symbol_name]"}, {"sha": "c9c2664e6de9b41124ead30e8e5195691650e4dc", "filename": "src/test/ui/symbol-names/impl1.legacy.stderr", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.legacy.stderr?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1,71 +1,71 @@\n-error: symbol-name(_ZN5impl13foo3Foo3bar17<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:15:9\n+error: symbol-name(_ZN5impl13foo3Foo3bar17h2e76f87b171019e0E)\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(impl1::foo::Foo::bar::<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:15:9\n+error: demangling(impl1::foo::Foo::bar::h2e76f87b171019e0)\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(impl1::foo::Foo::bar)\n-  --> $DIR/impl1.rs:15:9\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(foo::Foo::bar)\n-  --> $DIR/impl1.rs:22:9\n+  --> $DIR/impl1.rs:23:9\n    |\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:33:9\n+error: symbol-name(_ZN5impl13bar33_$LT$impl$u20$impl1..foo..Foo$GT$3baz17hb388a171ee84bca1E)\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(impl1::bar::<impl impl1::foo::Foo>::baz::<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:33:9\n+error: demangling(impl1::bar::<impl impl1::foo::Foo>::baz::hb388a171ee84bca1)\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(impl1::bar::<impl impl1::foo::Foo>::baz)\n-  --> $DIR/impl1.rs:33:9\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(bar::<impl foo::Foo>::baz)\n-  --> $DIR/impl1.rs:40:9\n+  --> $DIR/impl1.rs:41:9\n    |\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n-error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$3$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:63:13\n+error: symbol-name(_ZN209_$LT$$u5b$$RF$dyn$u20$impl1..Foo$u2b$Assoc$u20$$u3d$$u20$extern$u20$$u22$C$u22$$u20$fn$LP$$RF$u8$C$$u20$...$RP$$u2b$impl1..AutoTrait$u3b$$u20$3$u5d$$u20$as$u20$impl1..main..$u7b$$u7b$closure$u7d$$u7d$..Bar$GT$6method17SYMBOL_HASH)\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; 3] as impl1::main::{{closure}}::Bar>::method::<SYMBOL_HASH>)\n-  --> $DIR/impl1.rs:63:13\n+error: demangling(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; 3] as impl1::main::{{closure}}::Bar>::method::SYMBOL_HASH)\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(<[&dyn impl1::Foo+Assoc = extern \"C\" fn(&u8, ::.)+impl1::AutoTrait; 3] as impl1::main::{{closure}}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; 3] as main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:70:13\n+  --> $DIR/impl1.rs:71:13\n    |\n LL |             #[rustc_def_path]\n    |             ^^^^^^^^^^^^^^^^^"}, {"sha": "0a865a602f64b2aa90cf3252c00cfce74923f303", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -3,7 +3,8 @@\n // revisions: legacy v0\n //[legacy]compile-flags: -Z symbol-mangling-version=legacy\n     //[v0]compile-flags: -Z symbol-mangling-version=v0\n-//[legacy]normalize-stderr-test: \"h[\\w]{16}E?\\)\" -> \"<SYMBOL_HASH>)\"\n+//[legacy]normalize-stderr-test: \"method17h[\\d\\w]+\" -> \"method17SYMBOL_HASH\"\n+//[legacy]normalize-stderr-test: \"method::h[\\d\\w]+\" -> \"method::SYMBOL_HASH\"\n \n #![feature(auto_traits, rustc_attrs)]\n #![allow(dead_code)]"}, {"sha": "a68a74c8552539a18a84d49f944b3b0e12493532", "filename": "src/test/ui/symbol-names/impl1.v0.stderr", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.v0.stderr?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1,71 +1,71 @@\n error: symbol-name(_RNvMNtCs21hi0yVfW1J_5impl13fooNtB2_3Foo3bar)\n-  --> $DIR/impl1.rs:15:9\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling(<impl1[17891616a171812d]::foo::Foo>::bar)\n-  --> $DIR/impl1.rs:15:9\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(<impl1::foo::Foo>::bar)\n-  --> $DIR/impl1.rs:15:9\n+  --> $DIR/impl1.rs:16:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(foo::Foo::bar)\n-  --> $DIR/impl1.rs:22:9\n+  --> $DIR/impl1.rs:23:9\n    |\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n error: symbol-name(_RNvMNtCs21hi0yVfW1J_5impl13barNtNtB4_3foo3Foo3baz)\n-  --> $DIR/impl1.rs:33:9\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling(<impl1[17891616a171812d]::foo::Foo>::baz)\n-  --> $DIR/impl1.rs:33:9\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(<impl1::foo::Foo>::baz)\n-  --> $DIR/impl1.rs:33:9\n+  --> $DIR/impl1.rs:34:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(bar::<impl foo::Foo>::baz)\n-  --> $DIR/impl1.rs:40:9\n+  --> $DIR/impl1.rs:41:9\n    |\n LL |         #[rustc_def_path]\n    |         ^^^^^^^^^^^^^^^^^\n \n error: symbol-name(_RNvXNCNvCs21hi0yVfW1J_5impl14mains_0ARDNtB6_3Foop5AssocFG_KCRL0_hvEuNtB6_9AutoTraitEL_j3_NtB2_3Bar6method)\n-  --> $DIR/impl1.rs:63:13\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling(<[&dyn impl1[17891616a171812d]::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1[17891616a171812d]::AutoTrait; 3: usize] as impl1[17891616a171812d]::main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n error: demangling-alt(<[&dyn impl1::Foo<Assoc = for<'a> extern \"C\" fn(&'a u8, ...)> + impl1::AutoTrait; 3] as impl1::main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:63:13\n+  --> $DIR/impl1.rs:64:13\n    |\n LL |             #[rustc_symbol_name]\n    |             ^^^^^^^^^^^^^^^^^^^^\n \n error: def-path(<[&dyn Foo<Assoc = for<'r> extern \"C\" fn(&'r u8, ...)> + AutoTrait; 3] as main::{closure#1}::Bar>::method)\n-  --> $DIR/impl1.rs:70:13\n+  --> $DIR/impl1.rs:71:13\n    |\n LL |             #[rustc_def_path]\n    |             ^^^^^^^^^^^^^^^^^"}, {"sha": "65cc62b4d1dd6948889297f4de7083d58f58de44", "filename": "src/test/ui/symbol-names/issue-60925.legacy.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fissue-60925.legacy.stderr?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -1,10 +1,10 @@\n-error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17hb8ca3eb2682b1b51E)\n+error: symbol-name(_ZN11issue_609253foo37Foo$LT$issue_60925..llv$u6d$..Foo$GT$3foo17h6244e5288326926aE)\n   --> $DIR/issue-60925.rs:22:9\n    |\n LL |         #[rustc_symbol_name]\n    |         ^^^^^^^^^^^^^^^^^^^^\n \n-error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::hb8ca3eb2682b1b51)\n+error: demangling(issue_60925::foo::Foo<issue_60925::llvm::Foo>::foo::h6244e5288326926a)\n   --> $DIR/issue-60925.rs:22:9\n    |\n LL |         #[rustc_symbol_name]"}, {"sha": "4c13941f66599b28d3532e1f5ff2ff96ac20aff0", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30187c81f65aa29a53ad7c24fe3b4c7bff947094/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=30187c81f65aa29a53ad7c24fe3b4c7bff947094", "patch": "@@ -44,7 +44,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     for (pred, _) in generics.predicates {\n         if_chain! {\n             if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind().skip_binder();\n-            let trait_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(poly_trait_pred));\n+            let trait_pred = cx.tcx.erase_late_bound_regions(pred.kind().rebind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n             then {\n@@ -58,12 +58,12 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n fn get_projection_pred<'tcx>(\n     cx: &LateContext<'tcx>,\n     generics: GenericPredicates<'tcx>,\n-    pred: TraitPredicate<'tcx>,\n+    trait_pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let ty::PredicateKind::Projection(proj_pred) = proj_pred.kind().skip_binder() {\n-            let projection_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(proj_pred));\n-            if projection_pred.projection_ty.substs == pred.trait_ref.substs {\n+        if let ty::PredicateKind::Projection(pred) = proj_pred.kind().skip_binder() {\n+            let projection_pred = cx.tcx.erase_late_bound_regions(proj_pred.kind().rebind(pred));\n+            if projection_pred.projection_ty.substs == trait_pred.trait_ref.substs {\n                 return Some(projection_pred);\n             }\n         }"}]}