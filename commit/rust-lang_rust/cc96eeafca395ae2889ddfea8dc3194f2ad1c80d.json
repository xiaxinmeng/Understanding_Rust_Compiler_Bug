{"sha": "cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTZlZWFmY2EzOTVhZTI4ODlkZGZlYThkYzMxOTRmMmFkMWM4MGQ=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-31T18:03:42Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-05-31T18:32:08Z"}, "message": "Move rust_vec_append_glue to rt.", "tree": {"sha": "6e206122f0575a6fa84ab33220efd4603c74d552", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e206122f0575a6fa84ab33220efd4603c74d552"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "html_url": "https://github.com/rust-lang/rust/commit/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/comments", "author": null, "committer": null, "parents": [{"sha": "b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa", "html_url": "https://github.com/rust-lang/rust/commit/b6971d94dfa67f4e0ce81c2cd70af6f8b1dad8fa"}], "stats": {"total": 283, "additions": 140, "deletions": 143}, "files": [{"sha": "8139f9e4e794e2de1488414528b5bf3ef7ea6c73", "filename": "mk/rt.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "patch": "@@ -29,7 +29,7 @@ RUNTIME_CS := rt/sync/timer.cpp \\\n               rt/test/rust_test_runtime.cpp \\\n               rt/test/rust_test_util.cpp\n \n-RUNTIME_LL := rt/new_exit.ll\n+RUNTIME_LL := rt/new_exit.ll rt/vec_append.ll\n \n RUNTIME_S := rt/activate_glue.s rt/yield_glue.s\n "}, {"sha": "619854bc62233a5163f4a6d0dc91a78c893c7ac8", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "patch": "@@ -7997,147 +7997,6 @@ fn vec_p1_adjusted(&@block_ctxt bcx, ValueRef v,\n     ret bcx.build.GEP(vec_p0(bcx, v), [len]);\n }\n \n-fn trans_vec_append_glue(@local_ctxt cx, &ast::span sp) {\n-\n-    auto llfn = cx.ccx.glues.vec_append_glue;\n-\n-    let ValueRef lltaskptr = llvm::LLVMGetParam(llfn, 0u);\n-    let ValueRef llvec_tydesc = llvm::LLVMGetParam(llfn, 1u);\n-    let ValueRef llelt_tydesc = llvm::LLVMGetParam(llfn, 2u);\n-    let ValueRef lldst_vec_ptr = llvm::LLVMGetParam(llfn, 3u);\n-    let ValueRef llsrc_vec = llvm::LLVMGetParam(llfn, 4u);\n-    let ValueRef llskipnull = llvm::LLVMGetParam(llfn, 5u);\n-    auto derived_tydescs =\n-        map::mk_hashmap[ty::t, derived_tydesc_info](ty::hash_ty, ty::eq_ty);\n-\n-    auto llbbs = mk_standard_basic_blocks(llfn);\n-\n-    auto fcx = @rec(llfn=llfn,\n-                    lltaskptr=lltaskptr,\n-                    llenv=C_null(T_ptr(T_nil())),\n-                    llretptr=C_null(T_ptr(T_nil())),\n-                    mutable llallocas = llbbs._0,\n-                    mutable llcopyargs = llbbs._1,\n-                    mutable llderivedtydescs = llbbs._2,\n-                    mutable llself=none[self_vt],\n-                    mutable lliterbody=none[ValueRef],\n-                    llargs=new_def_hash[ValueRef](),\n-                    llobjfields=new_def_hash[ValueRef](),\n-                    lllocals=new_def_hash[ValueRef](),\n-                    llupvars=new_def_hash[ValueRef](),\n-                    mutable lltydescs=vec::empty[ValueRef](),\n-                    derived_tydescs=derived_tydescs,\n-                    sp=sp,\n-                    lcx=cx);\n-\n-    auto bcx = new_top_block_ctxt(fcx);\n-    auto lltop = bcx.llbb;\n-\n-    auto lldst_vec = bcx.build.Load(lldst_vec_ptr);\n-\n-    // First the dst vec needs to grow to accommodate the src vec.\n-    // To do this we have to figure out how many bytes to add.\n-\n-    auto llcopy_dst_ptr = alloca(bcx, T_int());\n-    auto llnew_vec = bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.vec_grow,\n-        [bcx.fcx.lltaskptr, lldst_vec,\n-            vec_fill_adjusted(bcx, llsrc_vec, llskipnull),\n-            llcopy_dst_ptr, llvec_tydesc]);\n-    maybe_name_value(bcx.fcx.lcx.ccx, llnew_vec, \"llnew_vec\");\n-\n-    auto copy_dst_cx = new_sub_block_ctxt(bcx, \"copy new <- dst\");\n-    auto copy_src_cx = new_sub_block_ctxt(bcx, \"copy new <- src\");\n-\n-    auto pp0 = alloca(bcx, T_ptr(T_i8()));\n-    bcx.build.Store(vec_p1_adjusted(bcx, llnew_vec, llskipnull), pp0);\n-    maybe_name_value(bcx.fcx.lcx.ccx, pp0, \"pp0\");\n-\n-    bcx.build.CondBr(bcx.build.TruncOrBitCast\n-                     (bcx.build.Load(llcopy_dst_ptr),\n-                      T_i1()),\n-                     copy_dst_cx.llbb,\n-                     copy_src_cx.llbb);\n-\n-\n-    fn copy_elts(&@block_ctxt cx,\n-                 ValueRef elt_tydesc,\n-                 ValueRef dst,\n-                 ValueRef src,\n-                 ValueRef n_bytes) -> result {\n-\n-        auto src_lim = cx.build.GEP(src, [n_bytes]);\n-        maybe_name_value(cx.fcx.lcx.ccx, src_lim, \"src_lim\");\n-\n-        auto elt_llsz =\n-            cx.build.Load(cx.build.GEP(elt_tydesc,\n-                                       [C_int(0),\n-                                           C_int(abi::tydesc_field_size)]));\n-        maybe_name_value(cx.fcx.lcx.ccx, elt_llsz, \"elt_llsz\");\n-\n-        auto elt_llalign =\n-            cx.build.Load(cx.build.GEP(elt_tydesc,\n-                                       [C_int(0),\n-                                           C_int(abi::tydesc_field_align)]));\n-        maybe_name_value(cx.fcx.lcx.ccx, elt_llsz, \"elt_llalign\");\n-\n-\n-        fn take_one(ValueRef elt_tydesc,\n-                    &@block_ctxt cx,\n-                    ValueRef dst, ValueRef src) -> result {\n-            auto ti = none[@tydesc_info];\n-            call_tydesc_glue_full(cx, src,\n-                                  elt_tydesc,\n-                                  abi::tydesc_field_take_glue, ti);\n-            ret res(cx, src);\n-        }\n-\n-        auto bcx = iter_sequence_raw(cx, dst, src, src_lim,\n-                                     elt_llsz, bind take_one(elt_tydesc,\n-                                                             _, _, _)).bcx;\n-\n-        ret call_memmove(bcx, dst, src, n_bytes, elt_llalign);\n-    }\n-\n-    // Copy any dst elements in, omitting null if doing str.\n-\n-    auto n_bytes = vec_fill_adjusted(copy_dst_cx, lldst_vec, llskipnull);\n-    maybe_name_value(copy_dst_cx.fcx.lcx.ccx, n_bytes, \"n_bytes\");\n-\n-    copy_dst_cx = copy_elts(copy_dst_cx,\n-                            llelt_tydesc,\n-                            vec_p0(copy_dst_cx, llnew_vec),\n-                            vec_p0(copy_dst_cx, lldst_vec),\n-                            n_bytes).bcx;\n-\n-    put_vec_fill(copy_dst_cx, llnew_vec, vec_fill(copy_dst_cx, lldst_vec));\n-\n-    copy_dst_cx.build.Store(vec_p1_adjusted(copy_dst_cx, llnew_vec,\n-                                            llskipnull), pp0);\n-    copy_dst_cx.build.Br(copy_src_cx.llbb);\n-\n-\n-    // Copy any src elements in, carrying along null if doing str.\n-    n_bytes = vec_fill(copy_src_cx, llsrc_vec);\n-    copy_src_cx = copy_elts(copy_src_cx,\n-                            llelt_tydesc,\n-                            copy_src_cx.build.Load(pp0),\n-                            vec_p0(copy_src_cx, llsrc_vec),\n-                            n_bytes).bcx;\n-\n-    put_vec_fill(copy_src_cx, llnew_vec,\n-                 copy_src_cx.build.Add(vec_fill_adjusted(copy_src_cx,\n-                                                         llnew_vec,\n-                                                         llskipnull),\n-                                        n_bytes));\n-\n-    // Write new_vec back through the alias we were given.\n-    copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);\n-    copy_src_cx.build.RetVoid();\n-\n-    finish_fn(fcx, lltop);\n-}\n-\n-\n fn make_glues(ModuleRef llmod, &type_names tn) -> @glue_fns {\n     ret @rec(yield_glue = decl_glue(llmod, tn, abi::yield_glue_name()),\n              no_op_type_glue = decl_no_op_type_glue(llmod, tn),\n@@ -8279,7 +8138,6 @@ fn trans_crate(&session::session sess, &@ast::crate crate,\n     collect_tag_ctors(ccx, crate);\n     trans_constants(ccx, crate);\n     trans_mod(cx, crate.node.module);\n-    trans_vec_append_glue(cx, crate.span);\n     auto crate_map = create_crate_map(ccx);\n     if (!sess.get_opts().shared) {\n         trans_main_fn(cx, crate_map);"}, {"sha": "2c189d18d1dd2a589dbde08f0e989440e2f00418", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "patch": "@@ -23,6 +23,7 @@ rust_process_wait\n rust_ptr_eq\n rust_run_program\n rust_start\n+rust_vec_append_glue\n size_of\n squareroot\n str_alloc"}, {"sha": "28a6e793cdb4b0db0456e06027d9ec7e800fe683", "filename": "src/rt/vec_append.ll", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Frt%2Fvec_append.ll", "raw_url": "https://github.com/rust-lang/rust/raw/cc96eeafca395ae2889ddfea8dc3194f2ad1c80d/src%2Frt%2Fvec_append.ll", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fvec_append.ll?ref=cc96eeafca395ae2889ddfea8dc3194f2ad1c80d", "patch": "@@ -0,0 +1,138 @@\n+%0 = type { i32, i32, i32, i32, [0 x i32] }\n+%task = type { i32, i32, i32, i32, i32, i32, i32, i32 }\n+%tydesc = type { %tydesc**, i32, i32, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*)*, void (i1*, %task*, i1*, %tydesc**, i8*, i8*, i8)* }\n+\n+declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n+\n+define fastcc void @rust_vec_append_glue(%task*, %tydesc*, %tydesc*, %0**, %0*, i1) {\n+allocas:\n+  %6 = alloca i32\n+  %7 = alloca i8*\n+  br label %copy_args\n+\n+copy_args:                                        ; preds = %allocas\n+  br label %derived_tydescs\n+\n+derived_tydescs:                                  ; preds = %copy_args\n+  br label %8\n+\n+; <label>:8                                       ; preds = %derived_tydescs\n+  %9 = load %0** %3\n+  %10 = getelementptr %0* %4, i32 0, i32 2\n+  %11 = load i32* %10\n+  %12 = sub i32 %11, 1\n+  %13 = select i1 %5, i32 %12, i32 %11\n+  %14 = call %0* @upcall_vec_grow(%task* %0, %0* %9, i32 %13, i32* %6, %tydesc* %1)\n+  %15 = getelementptr %0* %14, i32 0, i32 2\n+  %16 = load i32* %15\n+  %17 = sub i32 %16, 1\n+  %18 = select i1 %5, i32 %17, i32 %16\n+  %19 = getelementptr %0* %14, i32 0, i32 4\n+  %20 = bitcast [0 x i32]* %19 to i8*\n+  %21 = getelementptr i8* %20, i32 %18\n+  store i8* %21, i8** %7\n+  %22 = load i32* %6\n+  %23 = trunc i32 %22 to i1\n+  br i1 %23, label %24, label %41\n+\n+; <label>:24                                      ; preds = %8\n+  %25 = getelementptr %0* %9, i32 0, i32 2\n+  %26 = load i32* %25\n+  %27 = sub i32 %26, 1\n+  %28 = select i1 %5, i32 %27, i32 %26\n+  %29 = getelementptr %0* %14, i32 0, i32 4\n+  %30 = bitcast [0 x i32]* %29 to i8*\n+  %31 = getelementptr %0* %9, i32 0, i32 4\n+  %32 = bitcast [0 x i32]* %31 to i8*\n+  %33 = getelementptr i8* %32, i32 %28\n+  %34 = getelementptr %tydesc* %2, i32 0, i32 1\n+  %35 = load i32* %34\n+  %36 = getelementptr %tydesc* %2, i32 0, i32 2\n+  %37 = load i32* %36\n+  %38 = ptrtoint i8* %30 to i32\n+  %39 = ptrtoint i8* %32 to i32\n+  %40 = ptrtoint i8* %33 to i32\n+  br label %55\n+\n+; <label>:41                                      ; preds = %68, %8\n+  %42 = getelementptr %0* %4, i32 0, i32 2\n+  %43 = load i32* %42\n+  %44 = load i8** %7\n+  %45 = getelementptr %0* %4, i32 0, i32 4\n+  %46 = bitcast [0 x i32]* %45 to i8*\n+  %47 = getelementptr i8* %46, i32 %43\n+  %48 = getelementptr %tydesc* %2, i32 0, i32 1\n+  %49 = load i32* %48\n+  %50 = getelementptr %tydesc* %2, i32 0, i32 2\n+  %51 = load i32* %50\n+  %52 = ptrtoint i8* %44 to i32\n+  %53 = ptrtoint i8* %46 to i32\n+  %54 = ptrtoint i8* %47 to i32\n+  br label %79\n+\n+; <label>:55                                      ; preds = %59, %24\n+  %56 = phi i32 [ %38, %24 ], [ %66, %59 ]\n+  %57 = phi i32 [ %39, %24 ], [ %67, %59 ]\n+  %58 = icmp ult i32 %57, %40\n+  br i1 %58, label %59, label %68\n+\n+; <label>:59                                      ; preds = %55\n+  %60 = inttoptr i32 %56 to i8*\n+  %61 = inttoptr i32 %57 to i8*\n+  %62 = getelementptr %tydesc* %2, i32 0, i32 0\n+  %63 = load %tydesc*** %62\n+  %64 = getelementptr %tydesc* %2, i32 0, i32 3\n+  %65 = load void (i1*, %task*, i1*, %tydesc**, i8*)** %64\n+  call fastcc void %65(i1* null, %task* %0, i1* null, %tydesc** %63, i8* %61)\n+  %66 = add i32 %56, %35\n+  %67 = add i32 %57, %35\n+  br label %55\n+\n+; <label>:68                                      ; preds = %55\n+  call void @llvm.memmove.p0i8.p0i8.i32(i8* %30, i8* %32, i32 %28, i32 0, i1 false)\n+  %69 = getelementptr %0* %9, i32 0, i32 2\n+  %70 = load i32* %69\n+  %71 = getelementptr %0* %14, i32 0, i32 2\n+  store i32 %70, i32* %71\n+  %72 = getelementptr %0* %14, i32 0, i32 2\n+  %73 = load i32* %72\n+  %74 = sub i32 %73, 1\n+  %75 = select i1 %5, i32 %74, i32 %73\n+  %76 = getelementptr %0* %14, i32 0, i32 4\n+  %77 = bitcast [0 x i32]* %76 to i8*\n+  %78 = getelementptr i8* %77, i32 %75\n+  store i8* %78, i8** %7\n+  br label %41\n+\n+; <label>:79                                      ; preds = %83, %41\n+  %80 = phi i32 [ %52, %41 ], [ %90, %83 ]\n+  %81 = phi i32 [ %53, %41 ], [ %91, %83 ]\n+  %82 = icmp ult i32 %81, %54\n+  br i1 %82, label %83, label %92\n+\n+; <label>:83                                      ; preds = %79\n+  %84 = inttoptr i32 %80 to i8*\n+  %85 = inttoptr i32 %81 to i8*\n+  %86 = getelementptr %tydesc* %2, i32 0, i32 0\n+  %87 = load %tydesc*** %86\n+  %88 = getelementptr %tydesc* %2, i32 0, i32 3\n+  %89 = load void (i1*, %task*, i1*, %tydesc**, i8*)** %88\n+  call fastcc void %89(i1* null, %task* %0, i1* null, %tydesc** %87, i8* %85)\n+  %90 = add i32 %80, %49\n+  %91 = add i32 %81, %49\n+  br label %79\n+\n+; <label>:92                                      ; preds = %79\n+  call void @llvm.memmove.p0i8.p0i8.i32(i8* %44, i8* %46, i32 %43, i32 0, i1 false)\n+  %93 = getelementptr %0* %14, i32 0, i32 2\n+  %94 = load i32* %93\n+  %95 = sub i32 %94, 1\n+  %96 = select i1 %5, i32 %95, i32 %94\n+  %97 = add i32 %96, %43\n+  %98 = getelementptr %0* %14, i32 0, i32 2\n+  store i32 %97, i32* %98\n+  store %0* %14, %0** %3\n+  ret void\n+}\n+\n+declare %0* @upcall_vec_grow(%task*, %0*, i32, i32*, %tydesc*)"}]}