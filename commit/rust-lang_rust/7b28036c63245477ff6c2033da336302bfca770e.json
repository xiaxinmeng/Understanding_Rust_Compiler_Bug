{"sha": "7b28036c63245477ff6c2033da336302bfca770e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiMjgwMzZjNjMyNDU0NzdmZjZjMjAzM2RhMzM2MzAyYmZjYTc3MGU=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-08-02T08:56:44Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2021-08-02T11:23:24Z"}, "message": "BTree: merge the complication introduced by #81486 and #86031", "tree": {"sha": "5af109fc2fcb94721a10f2fc3ef66e577e645bdf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5af109fc2fcb94721a10f2fc3ef66e577e645bdf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b28036c63245477ff6c2033da336302bfca770e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b28036c63245477ff6c2033da336302bfca770e", "html_url": "https://github.com/rust-lang/rust/commit/7b28036c63245477ff6c2033da336302bfca770e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b28036c63245477ff6c2033da336302bfca770e/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b53a93db2d7717c3bde196cfcf5f214cc00d4937", "url": "https://api.github.com/repos/rust-lang/rust/commits/b53a93db2d7717c3bde196cfcf5f214cc00d4937", "html_url": "https://github.com/rust-lang/rust/commit/b53a93db2d7717c3bde196cfcf5f214cc00d4937"}], "stats": {"total": 112, "additions": 56, "deletions": 56}, "files": [{"sha": "4b649e43371dee25eaae95c3758662305ea22366", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 40, "deletions": 50, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=7b28036c63245477ff6c2033da336302bfca770e", "patch": "@@ -161,9 +161,7 @@ pub struct BTreeMap<K, V> {\n #[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for BTreeMap<K, V> {\n     fn drop(&mut self) {\n-        if let Some(root) = self.root.take() {\n-            Dropper { front: root.into_dying().first_leaf_edge(), remaining_length: self.length };\n-        }\n+        drop(unsafe { ptr::read(self) }.into_iter())\n     }\n }\n \n@@ -352,14 +350,6 @@ impl<K: fmt::Debug, V: fmt::Debug> fmt::Debug for IntoIter<K, V> {\n     }\n }\n \n-/// A simplified version of `IntoIter` that is not double-ended and has only one\n-/// purpose: to drop the remainder of an `IntoIter`. Therefore it also serves to\n-/// drop an entire tree without the need to first look up a `back` leaf edge.\n-struct Dropper<K, V> {\n-    front: Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>,\n-    remaining_length: usize,\n-}\n-\n /// An iterator over the keys of a `BTreeMap`.\n ///\n /// This `struct` is created by the [`keys`] method on [`BTreeMap`]. See its\n@@ -1458,47 +1448,57 @@ impl<K, V> IntoIterator for BTreeMap<K, V> {\n     }\n }\n \n-impl<K, V> Drop for Dropper<K, V> {\n+#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n+impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n-        // Similar to advancing a non-fusing iterator.\n-        fn next_or_end<K, V>(\n-            this: &mut Dropper<K, V>,\n-        ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>>\n-        {\n-            if this.remaining_length == 0 {\n-                unsafe { ptr::read(&this.front).deallocating_end() }\n-                None\n-            } else {\n-                this.remaining_length -= 1;\n-                Some(unsafe { this.front.deallocating_next_unchecked() })\n-            }\n-        }\n-\n-        struct DropGuard<'a, K, V>(&'a mut Dropper<K, V>);\n+        struct DropGuard<'a, K, V>(&'a mut IntoIter<K, V>);\n \n         impl<'a, K, V> Drop for DropGuard<'a, K, V> {\n             fn drop(&mut self) {\n                 // Continue the same loop we perform below. This only runs when unwinding, so we\n                 // don't have to care about panics this time (they'll abort).\n-                while let Some(kv) = next_or_end(&mut self.0) {\n-                    kv.drop_key_val();\n+                while let Some(kv) = self.0.dying_next() {\n+                    // SAFETY: we consume the dying handle immediately.\n+                    unsafe { kv.drop_key_val() };\n                 }\n             }\n         }\n \n-        while let Some(kv) = next_or_end(self) {\n+        while let Some(kv) = self.dying_next() {\n             let guard = DropGuard(self);\n-            kv.drop_key_val();\n+            // SAFETY: we don't touch the tree before consuming the dying handle.\n+            unsafe { kv.drop_key_val() };\n             mem::forget(guard);\n         }\n     }\n }\n \n-#[stable(feature = \"btree_drop\", since = \"1.7.0\")]\n-impl<K, V> Drop for IntoIter<K, V> {\n-    fn drop(&mut self) {\n-        if let Some(front) = self.range.take_front() {\n-            Dropper { front, remaining_length: self.length };\n+impl<K, V> IntoIter<K, V> {\n+    /// Core of a `next` method returning a dying KV handle,\n+    /// invalidated by further calls to this function and some others.\n+    fn dying_next(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        if self.length == 0 {\n+            self.range.deallocating_end();\n+            None\n+        } else {\n+            self.length -= 1;\n+            Some(unsafe { self.range.deallocating_next_unchecked() })\n+        }\n+    }\n+\n+    /// Core of a `next_back` method returning a dying KV handle,\n+    /// invalidated by further calls to this function and some others.\n+    fn dying_next_back(\n+        &mut self,\n+    ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV>> {\n+        if self.length == 0 {\n+            self.range.deallocating_end();\n+            None\n+        } else {\n+            self.length -= 1;\n+            Some(unsafe { self.range.deallocating_next_back_unchecked() })\n         }\n     }\n }\n@@ -1508,13 +1508,8 @@ impl<K, V> Iterator for IntoIter<K, V> {\n     type Item = (K, V);\n \n     fn next(&mut self) -> Option<(K, V)> {\n-        if self.length == 0 {\n-            None\n-        } else {\n-            self.length -= 1;\n-            let kv = unsafe { self.range.deallocating_next_unchecked() };\n-            Some(kv.into_key_val())\n-        }\n+        // SAFETY: we consume the dying handle immediately.\n+        self.dying_next().map(unsafe { |kv| kv.into_key_val() })\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n@@ -1525,13 +1520,8 @@ impl<K, V> Iterator for IntoIter<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K, V> DoubleEndedIterator for IntoIter<K, V> {\n     fn next_back(&mut self) -> Option<(K, V)> {\n-        if self.length == 0 {\n-            None\n-        } else {\n-            self.length -= 1;\n-            let kv = unsafe { self.range.deallocating_next_back_unchecked() };\n-            Some(kv.into_key_val())\n-        }\n+        // SAFETY: we consume the dying handle immediately.\n+        self.dying_next_back().map(unsafe { |kv| kv.into_key_val() })\n     }\n }\n "}, {"sha": "7b1d4d68c4f563769e1185463965f928ffb33d8d", "filename": "library/alloc/src/collections/btree/navigate.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=7b28036c63245477ff6c2033da336302bfca770e", "patch": "@@ -167,8 +167,7 @@ impl<'a, K, V> LazyLeafRange<marker::ValMut<'a>, K, V> {\n }\n \n impl<K, V> LazyLeafRange<marker::Dying, K, V> {\n-    #[inline]\n-    pub fn take_front(\n+    fn take_front(\n         &mut self,\n     ) -> Option<Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge>> {\n         match self.front.take()? {\n@@ -194,6 +193,13 @@ impl<K, V> LazyLeafRange<marker::Dying, K, V> {\n         let back = self.init_back().unwrap();\n         unsafe { back.deallocating_next_back_unchecked() }\n     }\n+\n+    #[inline]\n+    pub fn deallocating_end(&mut self) {\n+        if let Some(front) = self.take_front() {\n+            front.deallocating_end()\n+        }\n+    }\n }\n \n impl<BorrowType: marker::BorrowType, K, V> LazyLeafRange<BorrowType, K, V> {\n@@ -488,7 +494,7 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     /// both sides of the tree, and have hit the same edge. As it is intended\n     /// only to be called when all keys and values have been returned,\n     /// no cleanup is done on any of the keys or values.\n-    pub fn deallocating_end(self) {\n+    fn deallocating_end(self) {\n         let mut edge = self.forget_node_type();\n         while let Some(parent_edge) = unsafe { edge.into_node().deallocate_and_ascend() } {\n             edge = parent_edge.forget_node_type();\n@@ -565,7 +571,7 @@ impl<K, V> Handle<NodeRef<marker::Dying, K, V, marker::Leaf>, marker::Edge> {\n     ///\n     /// The only safe way to proceed with the updated handle is to compare it, drop it,\n     /// or call this method or counterpart `deallocating_next_back_unchecked` again.\n-    pub unsafe fn deallocating_next_unchecked(\n+    unsafe fn deallocating_next_unchecked(\n         &mut self,\n     ) -> Handle<NodeRef<marker::Dying, K, V, marker::LeafOrInternal>, marker::KV> {\n         super::mem::replace(self, |leaf_edge| unsafe { leaf_edge.deallocating_next().unwrap() })"}, {"sha": "8f6a2ec9ebd1ff002ee79cf8b7497cbcc9b3e347", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b28036c63245477ff6c2033da336302bfca770e/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=7b28036c63245477ff6c2033da336302bfca770e", "patch": "@@ -1058,7 +1058,9 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n \n impl<K, V, NodeType> Handle<NodeRef<marker::Dying, K, V, NodeType>, marker::KV> {\n     /// Extracts the key and value that the KV handle refers to.\n-    pub fn into_key_val(mut self) -> (K, V) {\n+    /// # Safety\n+    /// The node that the handle refers to must not yet have been deallocated.\n+    pub unsafe fn into_key_val(mut self) -> (K, V) {\n         debug_assert!(self.idx < self.node.len());\n         let leaf = self.node.as_leaf_dying();\n         unsafe {\n@@ -1069,8 +1071,10 @@ impl<K, V, NodeType> Handle<NodeRef<marker::Dying, K, V, NodeType>, marker::KV>\n     }\n \n     /// Drops the key and value that the KV handle refers to.\n+    /// # Safety\n+    /// The node that the handle refers to must not yet have been deallocated.\n     #[inline]\n-    pub fn drop_key_val(mut self) {\n+    pub unsafe fn drop_key_val(mut self) {\n         debug_assert!(self.idx < self.node.len());\n         let leaf = self.node.as_leaf_dying();\n         unsafe {"}]}