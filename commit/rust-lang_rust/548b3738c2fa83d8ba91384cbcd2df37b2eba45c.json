{"sha": "548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0OGIzNzM4YzJmYTgzZDhiYTkxMzg0Y2JjZDJkZjM3YjJlYmE0NWM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-24T16:36:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-27T16:12:49Z"}, "message": "dedicated handling for binops on bool and char (UB if they are not valid)", "tree": {"sha": "4ba3f8259ad2b058192ee9bd6513ee7e7a45c270", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ba3f8259ad2b058192ee9bd6513ee7e7a45c270"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "html_url": "https://github.com/rust-lang/rust/commit/548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/548b3738c2fa83d8ba91384cbcd2df37b2eba45c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7", "html_url": "https://github.com/rust-lang/rust/commit/9cfc9f07657dca1a08f99656dd1cd8da4b7db0c7"}], "stats": {"total": 173, "additions": 113, "deletions": 60}, "files": [{"sha": "d793bb1cc63ca7a9702d009b319afac180015a18", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/548b3738c2fa83d8ba91384cbcd2df37b2eba45c/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548b3738c2fa83d8ba91384cbcd2df37b2eba45c/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "patch": "@@ -187,43 +187,51 @@ impl<'tcx> Scalar {\n         }\n     }\n \n-    fn to_u8(self) -> EvalResult<'static, u8> {\n+    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+        let val = self.to_u32()?;\n+        match ::std::char::from_u32(val) {\n+            Some(c) => Ok(c),\n+            None => err!(InvalidChar(val as u128)),\n+        }\n+    }\n+\n+    pub fn to_u8(self) -> EvalResult<'static, u8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         assert_eq!(b as u8 as u128, b);\n         Ok(b as u8)\n     }\n \n-    fn to_u32(self) -> EvalResult<'static, u32> {\n+    pub fn to_u32(self) -> EvalResult<'static, u32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         assert_eq!(b as u32 as u128, b);\n         Ok(b as u32)\n     }\n \n-    fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n+    pub fn to_usize(self, cx: impl HasDataLayout) -> EvalResult<'static, u64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         assert_eq!(b as u64 as u128, b);\n         Ok(b as u64)\n     }\n \n-    fn to_i8(self) -> EvalResult<'static, i8> {\n+    pub fn to_i8(self) -> EvalResult<'static, i8> {\n         let sz = Size::from_bits(8);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         assert_eq!(b as i8 as i128, b);\n         Ok(b as i8)\n     }\n \n-    fn to_i32(self) -> EvalResult<'static, i32> {\n+    pub fn to_i32(self) -> EvalResult<'static, i32> {\n         let sz = Size::from_bits(32);\n         let b = self.to_bits(sz)?;\n         let b = sign_extend(b, sz) as i128;\n         assert_eq!(b as i32 as i128, b);\n         Ok(b as i32)\n     }\n \n-    fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n+    pub fn to_isize(self, cx: impl HasDataLayout) -> EvalResult<'static, i64> {\n         let b = self.to_bits(cx.data_layout().pointer_size)?;\n         let b = sign_extend(b, cx.data_layout().pointer_size) as i128;\n         assert_eq!(b as i64 as i128, b);\n@@ -295,6 +303,11 @@ impl<'tcx> ScalarMaybeUndef {\n         self.not_undef()?.to_bool()\n     }\n \n+    #[inline(always)]\n+    pub fn to_char(self) -> EvalResult<'tcx, char> {\n+        self.not_undef()?.to_char()\n+    }\n+\n     #[inline(always)]\n     pub fn to_u8(self) -> EvalResult<'tcx, u8> {\n         self.not_undef()?.to_u8()"}, {"sha": "b0c49efe8a2c12b6752a93118f9751c585f255cb", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 94, "deletions": 54, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/548b3738c2fa83d8ba91384cbcd2df37b2eba45c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/548b3738c2fa83d8ba91384cbcd2df37b2eba45c/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=548b3738c2fa83d8ba91384cbcd2df37b2eba45c", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use rustc::mir;\n-use rustc::ty::{self, layout::{self, TyLayout}};\n+use rustc::ty::{self, layout::TyLayout};\n use syntax::ast::FloatTy;\n use rustc_apfloat::ieee::{Double, Single};\n use rustc_apfloat::Float;\n@@ -60,32 +60,102 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n         let left = left.to_scalar()?;\n         let right = right.to_scalar()?;\n \n-        let left_kind = match left_layout.abi {\n-            layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(left_layout.ty)),\n-        };\n-        let right_kind = match right_layout.abi {\n-            layout::Abi::Scalar(ref scalar) => scalar.value,\n-            _ => return err!(TypeNotPrimitive(right_layout.ty)),\n-        };\n         trace!(\"Running binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n-        bin_op, left, left_kind, right, right_kind);\n+            bin_op, left, left_layout.ty.sty, right, right_layout.ty.sty);\n \n-        // I: Handle operations that support pointers\n-        if !left_kind.is_float() && !right_kind.is_float() {\n-            if let Some(handled) =\n-                M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n-            {\n-                return Ok(handled);\n+        // Handle non-integer operations\n+        if let ty::Char = left_layout.ty.sty {\n+            assert_eq!(right_layout.ty.sty, ty::Char);\n+            let l = left.to_char()?;\n+            let r = right.to_char()?;\n+            let res = match bin_op {\n+                Eq => l == r,\n+                Ne => l != r,\n+                Lt => l < r,\n+                Le => l <= r,\n+                Gt => l > r,\n+                Ge => l >= r,\n+                _ => bug!(\"Invalid operation on char: {:?}\", bin_op),\n+            };\n+            return Ok((Scalar::from_bool(res), false));\n+        }\n+        if let ty::Bool = left_layout.ty.sty {\n+            assert_eq!(right_layout.ty.sty, ty::Bool);\n+            let l = left.to_bool()?;\n+            let r = right.to_bool()?;\n+            let res = match bin_op {\n+                Eq => l == r,\n+                Ne => l != r,\n+                Lt => l < r,\n+                Le => l <= r,\n+                Gt => l > r,\n+                Ge => l >= r,\n+                BitAnd => l & r,\n+                BitOr => l | r,\n+                BitXor => l ^ r,\n+                _ => bug!(\"Invalid operation on bool: {:?}\", bin_op),\n+            };\n+            return Ok((Scalar::from_bool(res), false));\n+        }\n+        if let ty::Float(fty) = left_layout.ty.sty {\n+            let l = left.to_bits(left_layout.size)?;\n+            let r = right.to_bits(right_layout.size)?;\n+            assert_eq!(right_layout.ty.sty, ty::Float(fty));\n+            macro_rules! float_math {\n+                ($ty:path, $size:expr) => {{\n+                    let l = <$ty>::from_bits(l);\n+                    let r = <$ty>::from_bits(r);\n+                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n+                        bits: res.value.to_bits(),\n+                        size: $size,\n+                    };\n+                    let val = match bin_op {\n+                        Eq => Scalar::from_bool(l == r),\n+                        Ne => Scalar::from_bool(l != r),\n+                        Lt => Scalar::from_bool(l < r),\n+                        Le => Scalar::from_bool(l <= r),\n+                        Gt => Scalar::from_bool(l > r),\n+                        Ge => Scalar::from_bool(l >= r),\n+                        Add => bitify(l + r),\n+                        Sub => bitify(l - r),\n+                        Mul => bitify(l * r),\n+                        Div => bitify(l / r),\n+                        Rem => bitify(l % r),\n+                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n+                    };\n+                    return Ok((val, false));\n+                }};\n+            }\n+            match fty {\n+                FloatTy::F32 => float_math!(Single, 4),\n+                FloatTy::F64 => float_math!(Double, 8),\n             }\n         }\n+        // Only integers left\n+        #[inline]\n+        fn is_ptr<'tcx>(ty: ty::Ty<'tcx>) -> bool {\n+            match ty.sty {\n+                ty::RawPtr(..) | ty::Ref(..) | ty::FnPtr(..) => true,\n+                _ => false,\n+            }\n+        }\n+        assert!(left_layout.ty.is_integral() || is_ptr(left_layout.ty));\n+        assert!(right_layout.ty.is_integral() || is_ptr(right_layout.ty));\n+\n+        // Handle operations that support pointers\n+        if let Some(handled) =\n+            M::try_ptr_op(self, bin_op, left, left_layout, right, right_layout)?\n+        {\n+            return Ok(handled);\n+        }\n \n-        // II: From now on, everything must be bytes, no pointers\n+        // From now on, everything must be bytes, no pointer values\n+        // (this is independent of the type)\n         let l = left.to_bits(left_layout.size)?;\n         let r = right.to_bits(right_layout.size)?;\n \n-        // These ops can have an RHS with a different numeric type.\n-        if right_kind.is_int() && (bin_op == Shl || bin_op == Shr) {\n+        // Shift ops can have an RHS with a different numeric type.\n+        if bin_op == Shl || bin_op == Shr {\n             let signed = left_layout.abi.is_signed();\n             let mut oflo = (r as u32 as u128) != r;\n             let mut r = r as u32;\n@@ -116,18 +186,20 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }, oflo));\n         }\n \n-        if left_kind != right_kind {\n+        // For the remaining ops, the types must be the same on both sides\n+        if left_layout.ty != right_layout.ty {\n             let msg = format!(\n                 \"unimplemented binary op {:?}: {:?} ({:?}), {:?} ({:?})\",\n                 bin_op,\n                 left,\n-                left_kind,\n+                left_layout.ty,\n                 right,\n-                right_kind\n+                right_layout.ty\n             );\n             return err!(Unimplemented(msg));\n         }\n \n+        // Operations that need special treatment for signed integers\n         if left_layout.abi.is_signed() {\n             let op: Option<fn(&i128, &i128) -> bool> = match bin_op {\n                 Lt => Some(i128::lt),\n@@ -180,38 +252,6 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             }\n         }\n \n-        if let ty::Float(fty) = left_layout.ty.sty {\n-            macro_rules! float_math {\n-                ($ty:path, $size:expr) => {{\n-                    let l = <$ty>::from_bits(l);\n-                    let r = <$ty>::from_bits(r);\n-                    let bitify = |res: ::rustc_apfloat::StatusAnd<$ty>| Scalar::Bits {\n-                        bits: res.value.to_bits(),\n-                        size: $size,\n-                    };\n-                    let val = match bin_op {\n-                        Eq => Scalar::from_bool(l == r),\n-                        Ne => Scalar::from_bool(l != r),\n-                        Lt => Scalar::from_bool(l < r),\n-                        Le => Scalar::from_bool(l <= r),\n-                        Gt => Scalar::from_bool(l > r),\n-                        Ge => Scalar::from_bool(l >= r),\n-                        Add => bitify(l + r),\n-                        Sub => bitify(l - r),\n-                        Mul => bitify(l * r),\n-                        Div => bitify(l / r),\n-                        Rem => bitify(l % r),\n-                        _ => bug!(\"invalid float op: `{:?}`\", bin_op),\n-                    };\n-                    return Ok((val, false));\n-                }};\n-            }\n-            match fty {\n-                FloatTy::F32 => float_math!(Single, 4),\n-                FloatTy::F64 => float_math!(Double, 8),\n-            }\n-        }\n-\n         let size = left_layout.size.bytes() as u8;\n \n         // only ints left"}]}