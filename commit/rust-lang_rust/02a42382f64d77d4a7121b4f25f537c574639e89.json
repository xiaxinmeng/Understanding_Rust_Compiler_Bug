{"sha": "02a42382f64d77d4a7121b4f25f537c574639e89", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyYTQyMzgyZjY0ZDc3ZDRhNzEyMWI0ZjI1ZjUzN2M1NzQ2MzllODk=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-09-18T09:01:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-10-28T10:33:27Z"}, "message": "rename env var to control ctfe backtraces, and make it usually show the backtrace delayed\n\nThe env var is now RUST_CTFE_BACKTRACE.  Similar to RUST_BACKTRACE, it usually\nonly prints a backtrace when the error actually surfaces, not when it happens.\nThis makes a difference when we catch errors.\n\nAs per @oli-obk's request, one can set RUST_CTFE_BACKTRACE=immediate to get the\nbacktrace shown immediately.", "tree": {"sha": "51c1aeb886e70f894a4cbb8e418ccbed14923514", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51c1aeb886e70f894a4cbb8e418ccbed14923514"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02a42382f64d77d4a7121b4f25f537c574639e89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02a42382f64d77d4a7121b4f25f537c574639e89", "html_url": "https://github.com/rust-lang/rust/commit/02a42382f64d77d4a7121b4f25f537c574639e89", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02a42382f64d77d4a7121b4f25f537c574639e89/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1982f1887ad524951f24c12a6cc7bf05148aec14", "url": "https://api.github.com/repos/rust-lang/rust/commits/1982f1887ad524951f24c12a6cc7bf05148aec14", "html_url": "https://github.com/rust-lang/rust/commit/1982f1887ad524951f24c12a6cc7bf05148aec14"}], "stats": {"total": 143, "additions": 87, "deletions": 56}, "files": [{"sha": "6ce5e3f24ff09b11950fb1bca26dc53a048f3e80", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 66, "deletions": 36, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=02a42382f64d77d4a7121b4f25f537c574639e89", "patch": "@@ -53,7 +53,7 @@ pub type ConstEvalResult<'tcx> = Result<&'tcx ty::Const<'tcx>, ErrorHandled>;\n #[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n pub struct ConstEvalErr<'tcx> {\n     pub span: Span,\n-    pub error: ::mir::interpret::EvalError<'tcx>,\n+    pub error: ::mir::interpret::EvalErrorKind<'tcx, u64>,\n     pub stacktrace: Vec<FrameInfo>,\n }\n \n@@ -112,7 +112,7 @@ impl<'a, 'gcx, 'tcx> ConstEvalErr<'tcx> {\n         message: &str,\n         lint_root: Option<ast::NodeId>,\n     ) -> Result<DiagnosticBuilder<'tcx>, ErrorHandled> {\n-        match self.error.kind {\n+        match self.error {\n             EvalErrorKind::Layout(LayoutError::Unknown(_)) |\n             EvalErrorKind::TooGeneric => return Err(ErrorHandled::TooGeneric),\n             EvalErrorKind::Layout(LayoutError::SizeOverflow(_)) |\n@@ -151,50 +151,74 @@ pub fn struct_error<'a, 'gcx, 'tcx>(\n     struct_span_err!(tcx.sess, tcx.span, E0080, \"{}\", msg)\n }\n \n-#[derive(Debug, Clone, RustcEncodable, RustcDecodable)]\n+#[derive(Debug, Clone)]\n pub struct EvalError<'tcx> {\n     pub kind: EvalErrorKind<'tcx, u64>,\n+    pub backtrace: Option<Box<Backtrace>>,\n+}\n+\n+impl<'tcx> EvalError<'tcx> {\n+    pub fn print_backtrace(&mut self) {\n+        if let Some(ref mut backtrace) = self.backtrace {\n+            error!(\"{}\", print_backtrace(&mut *backtrace));\n+        }\n+    }\n+}\n+\n+fn print_backtrace(backtrace: &mut Backtrace) -> String {\n+    use std::fmt::Write;\n+\n+    backtrace.resolve();\n+\n+    let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n+    write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n+    'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n+        if frame.symbols().is_empty() {\n+            write!(trace_text, \"{}: no symbols\\n\", i).unwrap();\n+        }\n+        for symbol in frame.symbols() {\n+            write!(trace_text, \"{}: \", i).unwrap();\n+            if let Some(name) = symbol.name() {\n+                write!(trace_text, \"{}\\n\", name).unwrap();\n+            } else {\n+                write!(trace_text, \"<unknown>\\n\").unwrap();\n+            }\n+            write!(trace_text, \"\\tat \").unwrap();\n+            if let Some(file_path) = symbol.filename() {\n+                write!(trace_text, \"{}\", file_path.display()).unwrap();\n+            } else {\n+                write!(trace_text, \"<unknown_file>\").unwrap();\n+            }\n+            if let Some(line) = symbol.lineno() {\n+                write!(trace_text, \":{}\\n\", line).unwrap();\n+            } else {\n+                write!(trace_text, \"\\n\").unwrap();\n+            }\n+        }\n+    }\n+    trace_text\n }\n \n impl<'tcx> From<EvalErrorKind<'tcx, u64>> for EvalError<'tcx> {\n     fn from(kind: EvalErrorKind<'tcx, u64>) -> Self {\n-        match env::var(\"MIRI_BACKTRACE\") {\n-            Ok(ref val) if !val.is_empty() => {\n-                let backtrace = Backtrace::new();\n+        let backtrace = match env::var(\"RUST_CTFE_BACKTRACE\") {\n+            // matching RUST_BACKTRACE, we treat \"0\" the same as \"not present\".\n+            Ok(ref val) if val != \"0\" => {\n+                let mut backtrace = Backtrace::new_unresolved();\n \n-                use std::fmt::Write;\n-                let mut trace_text = \"\\n\\nAn error occurred in miri:\\n\".to_string();\n-                write!(trace_text, \"backtrace frames: {}\\n\", backtrace.frames().len()).unwrap();\n-                'frames: for (i, frame) in backtrace.frames().iter().enumerate() {\n-                    if frame.symbols().is_empty() {\n-                        write!(trace_text, \"{}: no symbols\\n\", i).unwrap();\n-                    }\n-                    for symbol in frame.symbols() {\n-                        write!(trace_text, \"{}: \", i).unwrap();\n-                        if let Some(name) = symbol.name() {\n-                            write!(trace_text, \"{}\\n\", name).unwrap();\n-                        } else {\n-                            write!(trace_text, \"<unknown>\\n\").unwrap();\n-                        }\n-                        write!(trace_text, \"\\tat \").unwrap();\n-                        if let Some(file_path) = symbol.filename() {\n-                            write!(trace_text, \"{}\", file_path.display()).unwrap();\n-                        } else {\n-                            write!(trace_text, \"<unknown_file>\").unwrap();\n-                        }\n-                        if let Some(line) = symbol.lineno() {\n-                            write!(trace_text, \":{}\\n\", line).unwrap();\n-                        } else {\n-                            write!(trace_text, \"\\n\").unwrap();\n-                        }\n-                    }\n+                if val == \"immediate\" {\n+                    // Print it now\n+                    error!(\"{}\", print_backtrace(&mut backtrace));\n+                    None\n+                } else {\n+                    Some(Box::new(backtrace))\n                 }\n-                error!(\"{}\", trace_text);\n             },\n-            _ => {},\n-        }\n+            _ => None,\n+        };\n         EvalError {\n             kind,\n+            backtrace,\n         }\n     }\n }\n@@ -452,7 +476,13 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n \n impl<'tcx> fmt::Display for EvalError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"{:?}\", self.kind)\n+        write!(f, \"{}\", self.kind)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for EvalErrorKind<'tcx, u64> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"{:?}\", self)\n     }\n }\n "}, {"sha": "ee610d213e7c79e939654622752aab8ac9799258", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=02a42382f64d77d4a7121b4f25f537c574639e89", "patch": "@@ -513,8 +513,7 @@ pub fn const_field<'a, 'tcx>(\n         op_to_const(&ecx, field, true)\n     })();\n     result.map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ::rustc::mir::interpret::ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         err.report_as_error(ecx.tcx, \"could not access field of constant\");\n         ErrorHandled::Reported\n     })\n@@ -532,6 +531,15 @@ pub fn const_variant_index<'a, 'tcx>(\n     Ok(ecx.read_discriminant(op)?.1)\n }\n \n+pub fn error_to_const_error<'a, 'mir, 'tcx>(\n+    ecx: &EvalContext<'a, 'mir, 'tcx, CompileTimeInterpreter<'a, 'mir, 'tcx>>,\n+    mut error: EvalError<'tcx>\n+) -> ConstEvalErr<'tcx> {\n+    error.print_backtrace();\n+    let stacktrace = ecx.generate_stacktrace(None);\n+    ConstEvalErr { error: error.kind, stacktrace, span: ecx.tcx.span }\n+}\n+\n fn validate_const<'a, 'tcx>(\n     tcx: ty::TyCtxt<'a, 'tcx, 'tcx>,\n     constant: &'tcx ty::Const<'tcx>,\n@@ -554,8 +562,7 @@ fn validate_const<'a, 'tcx>(\n     })();\n \n     val.map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ::rustc::mir::interpret::ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n             Ok(mut diag) => {\n                 diag.note(\"The rules on what exactly is undefined behavior aren't clear, \\\n@@ -647,8 +654,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n         }\n         op_to_const(&ecx, op, normalize)\n     }).map_err(|error| {\n-        let stacktrace = ecx.generate_stacktrace(None);\n-        let err = ConstEvalErr { error, stacktrace, span: ecx.tcx.span };\n+        let err = error_to_const_error(&ecx, error);\n         // errors in statics are always emitted as fatal errors\n         if tcx.is_static(def_id).is_some() {\n             let err = err.report_as_error(ecx.tcx, \"could not evaluate static initializer\");\n@@ -678,7 +684,7 @@ pub fn const_eval_raw_provider<'a, 'tcx>(\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n                     let span = tcx.optimized_mir(def_id).promoted[p].span;\n-                    if let EvalErrorKind::ReferencedConstant = err.error.kind {\n+                    if let EvalErrorKind::ReferencedConstant = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "52de65c184a7ab56e44770f9928a6661c0224ebc", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02a42382f64d77d4a7121b4f25f537c574639e89/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=02a42382f64d77d4a7121b4f25f537c574639e89", "patch": "@@ -17,13 +17,8 @@ use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n-use rustc::mir::interpret::{\n-    ConstEvalErr, EvalErrorKind, Scalar, GlobalId, EvalResult,\n-};\n+use rustc::mir::interpret::{EvalErrorKind, Scalar, GlobalId, EvalResult};\n use rustc::ty::{TyCtxt, self, Instance};\n-use interpret::{self, EvalContext, Value, OpTy, MemoryKind, ScalarMaybeUndef};\n-use const_eval::{CompileTimeInterpreter, eval_promoted, mk_borrowck_eval_cx};\n-use transform::{MirPass, MirSource};\n use syntax::source_map::{Span, DUMMY_SP};\n use rustc::ty::subst::Substs;\n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -33,6 +28,10 @@ use rustc::ty::layout::{\n     HasTyCtxt, TargetDataLayout, HasDataLayout,\n };\n \n+use interpret::{self, EvalContext, ScalarMaybeUndef, Value, OpTy, MemoryKind};\n+use const_eval::{CompileTimeInterpreter, error_to_const_error, eval_promoted, mk_borrowck_eval_cx};\n+use transform::{MirPass, MirSource};\n+\n pub struct ConstProp;\n \n impl MirPass for ConstProp {\n@@ -154,10 +153,9 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n         let r = match f(self) {\n             Ok(val) => Some(val),\n             Err(error) => {\n-                let stacktrace = self.ecx.generate_stacktrace(None);\n-                let diagnostic = ConstEvalErr { span: source_info.span, error, stacktrace };\n+                let diagnostic = error_to_const_error(&self.ecx, error);\n                 use rustc::mir::interpret::EvalErrorKind::*;\n-                match diagnostic.error.kind {\n+                match diagnostic.error {\n                     // don't report these, they make no sense in a const prop context\n                     | MachineError(_)\n                     // at runtime these transformations might make sense\n@@ -273,10 +271,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 Some((op, c.span))\n             },\n             Err(error) => {\n-                let stacktrace = self.ecx.generate_stacktrace(None);\n-                let err = ::rustc::mir::interpret::ConstEvalErr {\n-                    error, stacktrace, span: source_info.span,\n-                };\n+                let err = error_to_const_error(&self.ecx, error);\n                 err.report_as_error(self.ecx.tcx, \"erroneous constant used\");\n                 None\n             },"}]}