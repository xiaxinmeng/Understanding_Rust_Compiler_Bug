{"sha": "59cdb51ef3865582588f2735dc5479e9c205ddb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5Y2RiNTFlZjM4NjU1ODI1ODhmMjczNWRjNTQ3OWU5YzIwNWRkYjY=", "commit": {"author": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T22:29:38Z"}, "committer": {"name": "Yoshua Wuyts", "email": "yoshuawuyts@gmail.com", "date": "2021-08-08T22:29:38Z"}, "message": "Remove unwraps", "tree": {"sha": "619f8cb48b187fa155ac3b7eb7059bdc929e2ad6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/619f8cb48b187fa155ac3b7eb7059bdc929e2ad6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59cdb51ef3865582588f2735dc5479e9c205ddb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59cdb51ef3865582588f2735dc5479e9c205ddb6", "html_url": "https://github.com/rust-lang/rust/commit/59cdb51ef3865582588f2735dc5479e9c205ddb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59cdb51ef3865582588f2735dc5479e9c205ddb6/comments", "author": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "committer": {"login": "yoshuawuyts", "id": 2467194, "node_id": "MDQ6VXNlcjI0NjcxOTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/2467194?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yoshuawuyts", "html_url": "https://github.com/yoshuawuyts", "followers_url": "https://api.github.com/users/yoshuawuyts/followers", "following_url": "https://api.github.com/users/yoshuawuyts/following{/other_user}", "gists_url": "https://api.github.com/users/yoshuawuyts/gists{/gist_id}", "starred_url": "https://api.github.com/users/yoshuawuyts/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yoshuawuyts/subscriptions", "organizations_url": "https://api.github.com/users/yoshuawuyts/orgs", "repos_url": "https://api.github.com/users/yoshuawuyts/repos", "events_url": "https://api.github.com/users/yoshuawuyts/events{/privacy}", "received_events_url": "https://api.github.com/users/yoshuawuyts/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f424cd9c7e00509e6c5d077120f8bd20b19c5b51", "url": "https://api.github.com/repos/rust-lang/rust/commits/f424cd9c7e00509e6c5d077120f8bd20b19c5b51", "html_url": "https://github.com/rust-lang/rust/commit/f424cd9c7e00509e6c5d077120f8bd20b19c5b51"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "9da25b926c541b472a844024a929ebc18a5c7f74", "filename": "crates/ide_assists/src/handlers/replace_derive_with_manual_impl.rs", "status": "modified", "additions": 65, "deletions": 48, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/59cdb51ef3865582588f2735dc5479e9c205ddb6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59cdb51ef3865582588f2735dc5479e9c205ddb6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_derive_with_manual_impl.rs?ref=59cdb51ef3865582588f2735dc5479e9c205ddb6", "patch": "@@ -168,76 +168,92 @@ fn impl_def_from_trait(\n         add_trait_assoc_items_to_impl(sema, trait_items, trait_, impl_def, target_scope);\n \n     // Generate a default `impl` function body for the derived trait.\n-    if let ast::AssocItem::Fn(func) = &first_assoc_item {\n-        match trait_path.segment().unwrap().name_ref().unwrap().text().as_str() {\n-            \"Debug\" => gen_debug_impl(adt, func, annotated_name),\n-            _ => {}\n-        };\n-    }\n+    if let ast::AssocItem::Fn(ref func) = first_assoc_item {\n+        let _ = gen_default_impl(func, trait_path, adt, annotated_name);\n+    };\n+\n     Some((impl_def, first_assoc_item))\n }\n \n+/// Generate custom trait bodies where possible.\n+///\n+/// Returns `Option` so that we can use `?` rather than `if let Some`. Returning\n+/// `None` means that generating a custom trait body failed, and the body will remain\n+/// as `todo!` instead.\n+fn gen_default_impl(\n+    func: &ast::Fn,\n+    trait_path: &ast::Path,\n+    adt: &ast::Adt,\n+    annotated_name: &ast::Name,\n+) -> Option<()> {\n+    match trait_path.segment()?.name_ref()?.text().as_str() {\n+        \"Debug\" => gen_debug_impl(adt, func, annotated_name),\n+        _ => Some(()),\n+    }\n+}\n+\n /// Generate a `Debug` impl based on the fields and members of the target type.\n-fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n+fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) -> Option<()> {\n     match adt {\n-        ast::Adt::Union(_) => {} // `Debug` cannot be derived for unions, so no default impl can be provided.\n+        // `Debug` cannot be derived for unions, so no default impl can be provided.\n+        ast::Adt::Union(_) => Some(()),\n+\n+        // => match self { Self::Variant => write!(f, \"Variant\") }\n         ast::Adt::Enum(enum_) => {\n-            // => match self { Self::Variant => write!(f, \"Variant\") }\n-            if let Some(list) = enum_.variant_list() {\n-                let mut arms = vec![];\n-                for variant in list.variants() {\n-                    let name = variant.name().unwrap();\n-\n-                    let left = make::ext::ident_path(\"Self\");\n-                    let right = make::ext::ident_path(&format!(\"{}\", name));\n-                    let variant_name = make::path_pat(make::path_concat(left, right));\n-\n-                    let target = make::expr_path(make::ext::ident_path(\"f\").into());\n-                    let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n-                    let args = make::arg_list(vec![target, fmt_string]);\n-                    let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n-                    let macro_call = make::expr_macro_call(macro_name, args);\n-\n-                    arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n-                }\n+            let list = enum_.variant_list()?;\n+            let mut arms = vec![];\n+            for variant in list.variants() {\n+                let name = variant.name()?;\n+                let left = make::ext::ident_path(\"Self\");\n+                let right = make::ext::ident_path(&format!(\"{}\", name));\n+                let variant_name = make::path_pat(make::path_concat(left, right));\n+\n+                let target = make::expr_path(make::ext::ident_path(\"f\").into());\n+                let fmt_string = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                let args = make::arg_list(vec![target, fmt_string]);\n+                let macro_name = make::expr_path(make::ext::ident_path(\"write\"));\n+                let macro_call = make::expr_macro_call(macro_name, args);\n+\n+                arms.push(make::match_arm(Some(variant_name.into()), None, macro_call.into()));\n+            }\n \n-                let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n-                let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n-                let match_expr = make::expr_match(match_target, list);\n+            let match_target = make::expr_path(make::ext::ident_path(\"self\"));\n+            let list = make::match_arm_list(arms).indent(ast::edit::IndentLevel(1));\n+            let match_expr = make::expr_match(match_target, list);\n \n-                let body = make::block_expr(None, Some(match_expr));\n-                let body = body.indent(ast::edit::IndentLevel(1));\n-                ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n-            }\n+            let body = make::block_expr(None, Some(match_expr));\n+            let body = body.indent(ast::edit::IndentLevel(1));\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n         }\n+\n         ast::Adt::Struct(strukt) => {\n             let name = format!(\"\\\"{}\\\"\", annotated_name);\n             let args = make::arg_list(Some(make::expr_literal(&name).into()));\n             let target = make::expr_path(make::ext::ident_path(\"f\"));\n \n             let expr = match strukt.field_list() {\n-                None => {\n-                    // => f.debug_struct(\"Name\").finish()\n-                    make::expr_method_call(target, make::name_ref(\"debug_struct\"), args)\n-                }\n+                // => f.debug_struct(\"Name\").finish()\n+                None => make::expr_method_call(target, make::name_ref(\"debug_struct\"), args),\n+\n+                // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n                 Some(ast::FieldList::RecordFieldList(field_list)) => {\n-                    // => f.debug_struct(\"Name\").field(\"foo\", &self.foo).finish()\n                     let method = make::name_ref(\"debug_struct\");\n                     let mut expr = make::expr_method_call(target, method, args);\n                     for field in field_list.fields() {\n-                        if let Some(name) = field.name() {\n-                            let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n-                            let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n-                            let f_path = make::expr_ref(f_path, false);\n-                            let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n-                            let args = make::arg_list(vec![f_name, f_path]);\n-                            expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n-                        }\n+                        let name = field.name()?;\n+                        let f_name = make::expr_literal(&(format!(\"\\\"{}\\\"\", name))).into();\n+                        let f_path = make::expr_path(make::ext::ident_path(\"self\"));\n+                        let f_path = make::expr_ref(f_path, false);\n+                        let f_path = make::expr_field(f_path, &format!(\"{}\", name)).into();\n+                        let args = make::arg_list(vec![f_name, f_path]);\n+                        expr = make::expr_method_call(expr, make::name_ref(\"field\"), args);\n                     }\n                     expr\n                 }\n+\n+                // => f.debug_tuple(\"Name\").field(self.0).finish()\n                 Some(ast::FieldList::TupleFieldList(field_list)) => {\n-                    // => f.debug_tuple(\"Name\").field(self.0).finish()\n                     let method = make::name_ref(\"debug_tuple\");\n                     let mut expr = make::expr_method_call(target, method, args);\n                     for (idx, _) in field_list.fields().enumerate() {\n@@ -254,7 +270,8 @@ fn gen_debug_impl(adt: &ast::Adt, func: &ast::Fn, annotated_name: &ast::Name) {\n             let method = make::name_ref(\"finish\");\n             let expr = make::expr_method_call(expr, method, make::arg_list(None));\n             let body = make::block_expr(None, Some(expr)).indent(ast::edit::IndentLevel(1));\n-            ted::replace(func.body().unwrap().syntax(), body.clone_for_update().syntax());\n+            ted::replace(func.body()?.syntax(), body.clone_for_update().syntax());\n+            Some(())\n         }\n     }\n }"}]}