{"sha": "7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNWE4ZGNkYjk1YjA3MjM0ZDMyM2NhZDg0OTJiZWY5NmYyYmVlMWI=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T09:09:44Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-03-24T11:41:35Z"}, "message": "Remove `VariantDef::parent_did`", "tree": {"sha": "d332e61dbaca98800ab63e2744d7d878d92872f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d332e61dbaca98800ab63e2744d7d878d92872f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "html_url": "https://github.com/rust-lang/rust/commit/7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c667c2fc0896b2a58a363d2c535881e5b983857a", "url": "https://api.github.com/repos/rust-lang/rust/commits/c667c2fc0896b2a58a363d2c535881e5b983857a", "html_url": "https://github.com/rust-lang/rust/commit/c667c2fc0896b2a58a363d2c535881e5b983857a"}], "stats": {"total": 274, "additions": 72, "deletions": 202}, "files": [{"sha": "fe6667a94b815377535dc75bb0106d1b43f155ca", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -215,7 +215,7 @@ impl<'tcx> cmt_<'tcx> {\n         };\n         let variant_def = match self.cat {\n             Categorization::Downcast(_, variant_did) => {\n-                adt_def.variant_with_variant_id(variant_did)\n+                adt_def.variant_with_id(variant_did)\n             }\n             _ => {\n                 assert_eq!(adt_def.variants.len(), 1);"}, {"sha": "d747f348ac990c65b569470ef1cddee8ff4eb0e8", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -2405,13 +2405,12 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n-                        let did = variant_def.variant_did_or_parent_struct_did();\n \n                         let f = &mut *fmt;\n                         ty::tls::with(|tcx| {\n                             let substs = tcx.lift(&substs).expect(\"could not lift for printing\");\n                             FmtPrinter::new(tcx, f, Namespace::ValueNS)\n-                                .print_def_path(did, substs)?;\n+                                .print_def_path(variant_def.def_id, substs)?;\n                             Ok(())\n                         })?;\n "}, {"sha": "963b4b439f84da38c29f6641142de6c6e617b786", "filename": "src/librustc/ty/inhabitedness/mod.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finhabitedness%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -104,33 +104,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     fn ty_inhabitedness_forest(self, ty: Ty<'tcx>) -> DefIdForest {\n         ty.uninhabited_from(self)\n     }\n-\n-    pub fn is_enum_variant_uninhabited_from(self,\n-                                            module: DefId,\n-                                            variant: &'tcx VariantDef,\n-                                            substs: SubstsRef<'tcx>)\n-                                            -> bool\n-    {\n-        self.variant_inhabitedness_forest(variant, substs).contains(self, module)\n-    }\n-\n-    pub fn is_variant_uninhabited_from_all_modules(self,\n-                                                   variant: &'tcx VariantDef,\n-                                                   substs: SubstsRef<'tcx>)\n-                                                   -> bool\n-    {\n-        !self.variant_inhabitedness_forest(variant, substs).is_empty()\n-    }\n-\n-    fn variant_inhabitedness_forest(self, variant: &'tcx VariantDef, substs: SubstsRef<'tcx>)\n-                                    -> DefIdForest {\n-        // Determine the ADT kind:\n-        let adt_def_id = self.adt_def_id_of_variant(variant);\n-        let adt_kind = self.adt_def(adt_def_id).adt_kind();\n-\n-        // Compute inhabitedness forest:\n-        variant.uninhabited_from(self, substs, adt_kind)\n-    }\n }\n \n impl<'a, 'gcx, 'tcx> AdtDef {\n@@ -148,7 +121,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n \n impl<'a, 'gcx, 'tcx> VariantDef {\n     /// Calculate the forest of DefIds from which this variant is visibly uninhabited.\n-    fn uninhabited_from(\n+    pub fn uninhabited_from(\n         &self,\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         substs: SubstsRef<'tcx>,"}, {"sha": "10755a9c0218e798b031bb3428de9f94a9b5631e", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 26, "deletions": 106, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -1810,12 +1810,12 @@ bitflags! {\n /// Definition of a variant -- a struct's fields or a enum variant.\n #[derive(Debug)]\n pub struct VariantDef {\n-    /// `DefId` that identifies this enum variant. If this `VariantDef` is part of a struct or\n-    /// union then this is `None`.\n-    variant_did: Option<DefId>,\n-    /// `DefId` that identifies this enum variant or struct's constructor. If this is a\n-    /// `Struct`-variant then this is `None`.\n-    ctor_did: Option<DefId>,\n+    /// `DefId` that identifies the variant itself.\n+    /// If this variant belongs to a struct or union, then this is a copy of its `DefId`.\n+    pub def_id: DefId,\n+    /// `DefId` that identifies the variant's constructor.\n+    /// If this variant is a struct variant, then this is `None`.\n+    pub ctor_def_id: Option<DefId>,\n     /// Variant or struct name.\n     pub ident: Ident,\n     /// Discriminant of this variant.\n@@ -1824,11 +1824,6 @@ pub struct VariantDef {\n     pub fields: Vec<FieldDef>,\n     /// Type of constructor of variant.\n     pub ctor_kind: CtorKind,\n-    /// `DefId` of the parent `AdtDef` representing the struct or enum. This is required as there\n-    /// is a valid scenario where this type represents a `Struct`-struct and both `ctor_did` and\n-    /// `variant_did` would be `None` and we would still want a way to get back to the original\n-    /// `AdtDef`.\n-    parent_did: DefId,\n     /// Flags of the variant (e.g. is field list non-exhaustive)?\n     flags: VariantFlags,\n     /// Recovered?\n@@ -1856,7 +1851,7 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         ident: Ident,\n         variant_did: Option<DefId>,\n-        ctor_did: Option<DefId>,\n+        ctor_def_id: Option<DefId>,\n         discr: VariantDiscr,\n         fields: Vec<FieldDef>,\n         ctor_kind: CtorKind,\n@@ -1865,9 +1860,9 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         recovered: bool,\n     ) -> Self {\n         debug!(\n-            \"VariantDef::new(ident = {:?}, variant_did = {:?}, ctor_did = {:?}, discr = {:?},\n+            \"VariantDef::new(ident = {:?}, variant_did = {:?}, ctor_def_id = {:?}, discr = {:?},\n              fields = {:?}, ctor_kind = {:?}, adt_kind = {:?}, parent_did = {:?})\",\n-             ident, variant_did, ctor_did, discr, fields, ctor_kind, adt_kind, parent_did,\n+             ident, variant_did, ctor_def_id, discr, fields, ctor_kind, adt_kind, parent_did,\n         );\n \n         let mut flags = VariantFlags::NO_VARIANT_FLAGS;\n@@ -1877,14 +1872,13 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n         }\n \n         VariantDef {\n-            variant_did,\n-            ctor_did,\n+            def_id: variant_did.unwrap_or(parent_did),\n+            ctor_def_id,\n             ident,\n             discr,\n             fields,\n             ctor_kind,\n             flags,\n-            parent_did,\n             recovered,\n         }\n     }\n@@ -1894,62 +1888,16 @@ impl<'a, 'gcx, 'tcx> VariantDef {\n     pub fn is_field_list_non_exhaustive(&self) -> bool {\n         self.flags.intersects(VariantFlags::IS_FIELD_LIST_NON_EXHAUSTIVE)\n     }\n-\n-    /// Returns `true` if this `VariantDef` represents a enum's variant.\n-    #[inline]\n-    pub fn is_enum_variant(&self) -> bool {\n-        self.variant_did.is_some()\n-    }\n-\n-    /// Returns `true` if this `VariantDef` represents a struct.\n-    #[inline]\n-    pub fn is_struct(&self) -> bool {\n-        !self.is_enum_variant()\n-    }\n-\n-    /// Returns the `DefId` of this variant if this `VariantDef` represents an enum's variant, or\n-    /// returns the `DefId` of the parent struct.\n-    #[inline]\n-    pub fn variant_did_or_parent_struct_did(&self) -> DefId {\n-        self.variant_did.unwrap_or(self.parent_did)\n-    }\n-\n-    /// Returns `true` if the variant is defined in the local crate.\n-    #[inline]\n-    pub fn is_local(&self) -> bool {\n-        self.variant_did_or_parent_struct_did().krate == LOCAL_CRATE\n-    }\n-\n-    /// Returns the `DefId` of this variant if this `VariantDef` represents an enum's variant or\n-    /// panics.\n-    #[inline]\n-    pub fn variant_did(&self) -> DefId {\n-        self.variant_did.expect(\"enum variant without a variant id\")\n-    }\n-\n-    /// Returns the `DefId` of this variant's constructor if this is a unit or\n-    /// tuple-variant/struct.\n-    #[inline]\n-    pub fn ctor_did(&self) -> Option<DefId> {\n-        self.ctor_did\n-    }\n-\n-    /// Returns the `AdtDef` representing the struct or enum associated with this `VariantDef`.\n-    #[inline]\n-    pub fn adt_def(&self, tcx: TyCtxt<'a, 'tcx, 'gcx>) -> &'tcx AdtDef {\n-        tcx.adt_def(self.parent_did)\n-    }\n }\n \n impl_stable_hash_for!(struct VariantDef {\n-    variant_did,\n-    ctor_did,\n+    def_id,\n+    ctor_def_id,\n     ident -> (ident.name),\n     discr,\n     fields,\n     ctor_kind,\n     flags,\n-    parent_did,\n     recovered\n });\n \n@@ -2204,7 +2152,7 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             AdtKind::Struct => AdtFlags::IS_STRUCT,\n         };\n \n-        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_did.is_some() {\n+        if kind == AdtKind::Struct && variants[VariantIdx::new(0)].ctor_def_id.is_some() {\n             flags |= AdtFlags::HAS_CTOR;\n         }\n \n@@ -2351,51 +2299,29 @@ impl<'a, 'gcx, 'tcx> AdtDef {\n             self.variants.iter().all(|v| v.fields.is_empty())\n     }\n \n-    pub fn variant_with_variant_id(&self, vid: DefId) -> &VariantDef {\n-        self.variants\n-            .iter()\n-            .find(|v| v.variant_did.map(|did| did == vid).unwrap_or(false))\n-            .expect(\"variant_with_variant_id: unknown variant\")\n+    pub fn variant_with_id(&self, vid: DefId) -> &VariantDef {\n+        self.variants.iter().find(|v| v.def_id == vid)\n+            .expect(\"variant_with_id: unknown variant\")\n     }\n \n     pub fn variant_with_ctor_id(&self, cid: DefId) -> &VariantDef {\n-        self.variants\n-            .iter()\n-            .find(|v| v.ctor_did.map(|did| did == cid).unwrap_or(false))\n+        self.variants.iter().find(|v| v.ctor_def_id == Some(cid))\n             .expect(\"variant_with_ctor_id: unknown variant\")\n     }\n \n-    pub fn variant_index_with_variant_id(&self, vid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.variant_did.map(|did| did == vid).unwrap_or(false))\n-            .expect(\"variant_index_with_variant_id: unknown variant\")\n-            .0\n+    pub fn variant_index_with_id(&self, vid: DefId) -> VariantIdx {\n+        self.variants.iter_enumerated().find(|(_, v)| v.def_id == vid)\n+            .expect(\"variant_index_with_id: unknown variant\").0\n     }\n \n     pub fn variant_index_with_ctor_id(&self, cid: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| v.ctor_did.map(|did| did == cid).unwrap_or(false))\n-            .expect(\"variant_index_with_ctor_id: unknown variant\")\n-            .0\n-    }\n-\n-    pub fn variant_index_with_ctor_or_variant_id(&self, id: DefId) -> VariantIdx {\n-        self.variants\n-            .iter_enumerated()\n-            .find(|(_, v)| {\n-                let ctor = v.ctor_did.map(|did| did == id);\n-                let variant = v.variant_did.map(|did| did == id);\n-                ctor.or(variant).unwrap_or(false)\n-            })\n-            .expect(\"variant_index_with_ctor_or_variant_id: unknown variant\")\n-            .0\n+        self.variants.iter_enumerated().find(|(_, v)| v.ctor_def_id == Some(cid))\n+            .expect(\"variant_index_with_ctor_id: unknown variant\").0\n     }\n \n     pub fn variant_of_def(&self, def: Def) -> &VariantDef {\n         match def {\n-            Def::Variant(vid) => self.variant_with_variant_id(vid),\n+            Def::Variant(vid) => self.variant_with_id(vid),\n             Def::Ctor(hir::CtorOf::Variant, cid, ..) => self.variant_with_ctor_id(cid),\n             Def::Struct(..) | Def::Ctor(..) | Def::Union(..) |\n             Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) |\n@@ -2933,8 +2859,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn find_field_index(self, ident: Ident, variant: &VariantDef) -> Option<usize> {\n         variant.fields.iter().position(|field| {\n-            let did = variant.variant_did.unwrap_or(variant.parent_did);\n-            self.adjust_ident(ident, did, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n+            self.adjust_ident(ident, variant.def_id, hir::DUMMY_HIR_ID).0 == field.ident.modern()\n         })\n     }\n \n@@ -3011,7 +2936,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         match def {\n             Def::Variant(did) => {\n                 let enum_did = self.parent(did).unwrap();\n-                self.adt_def(enum_did).variant_with_variant_id(did)\n+                self.adt_def(enum_did).variant_with_id(did)\n             }\n             Def::Struct(did) | Def::Union(did) => {\n                 self.adt_def(did).non_enum_variant()\n@@ -3029,11 +2954,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    /// Given a `VariantDef`, returns the def-id of the `AdtDef` of which it is a part.\n-    pub fn adt_def_id_of_variant(self, variant_def: &'tcx VariantDef) -> DefId {\n-        variant_def.parent_did\n-    }\n-\n     pub fn item_name(self, id: DefId) -> InternedString {\n         if id.index == CRATE_DEF_INDEX {\n             self.original_crate_name(id.krate).as_interned_str()"}, {"sha": "78a186fbb714ae37c9cff0e3ae18601a7df314cb", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -579,13 +579,13 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n-        let def_id = variant.variant_did();\n+        let def_id = variant.def_id;\n         debug!(\"IsolatedEncoder::encode_enum_variant_info({:?})\", def_id);\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n             discr: variant.discr,\n-            ctor: variant.ctor_did().map(|did| did.index),\n+            ctor: variant.ctor_def_id.map(|did| did.index),\n             ctor_sig: None,\n         };\n \n@@ -628,7 +628,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let tcx = self.tcx;\n         let def = tcx.adt_def(enum_did);\n         let variant = &def.variants[index];\n-        let def_id = variant.ctor_did().unwrap();\n+        let def_id = variant.ctor_def_id.unwrap();\n         debug!(\"IsolatedEncoder::encode_enum_variant_ctor({:?})\", def_id);\n \n         let data = VariantData {\n@@ -726,9 +726,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n         let def_id = field.did;\n         debug!(\"IsolatedEncoder::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir()\n-            .as_local_hir_id(variant.variant_did_or_parent_struct_did())\n-            .unwrap();\n+        let variant_id = tcx.hir().as_local_hir_id(variant.def_id).unwrap();\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         Entry {\n@@ -1218,9 +1216,8 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 hir::ItemKind::Enum(..) => {\n                     let def = self.tcx.adt_def(def_id);\n                     self.lazy_seq(def.variants.iter().map(|v| {\n-                        let did = v.variant_did();\n-                        assert!(did.is_local());\n-                        did.index\n+                        assert!(v.def_id.is_local());\n+                        v.def_id.index\n                     }))\n                 }\n                 hir::ItemKind::Struct(..) |\n@@ -1813,12 +1810,12 @@ impl<'a, 'b, 'tcx> IndexBuilder<'a, 'b, 'tcx> {\n \n                 let def = self.tcx.adt_def(def_id);\n                 for (i, variant) in def.variants.iter_enumerated() {\n-                    self.record(variant.variant_did(),\n+                    self.record(variant.def_id,\n                                 IsolatedEncoder::encode_enum_variant_info,\n                                 (def_id, Untracked(i)));\n \n-                    if let Some(ctor_hir_did) = variant.ctor_did() {\n-                        self.record(ctor_hir_did,\n+                    if let Some(ctor_def_id) = variant.ctor_def_id {\n+                        self.record(ctor_def_id,\n                                     IsolatedEncoder::encode_enum_variant_ctor,\n                                     (def_id, Untracked(i)));\n                     }"}, {"sha": "2e4f53023f409e918cd5447f6fc1ef39e1dccb65", "filename": "src/librustc_mir/build/matches/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fsimplify.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -163,7 +163,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     i == variant_index || {\n                         self.hir.tcx().features().never_type &&\n                         self.hir.tcx().features().exhaustive_patterns &&\n-                        self.hir.tcx().is_variant_uninhabited_from_all_modules(v, substs)\n+                        !v.uninhabited_from(self.hir.tcx(), substs, adt_def.adt_kind()).is_empty()\n                     }\n                 });\n                 if irrefutable {"}, {"sha": "610c63b208cb6500349a39803ad41203da9374c0", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -486,7 +486,7 @@ fn make_mirror_unadjusted<'a, 'gcx, 'tcx>(cx: &mut Cx<'a, 'gcx, 'tcx>,\n                                 Def::Variant(variant_id) => {\n                                     assert!(base.is_none());\n \n-                                    let index = adt.variant_index_with_variant_id(variant_id);\n+                                    let index = adt.variant_index_with_id(variant_id);\n                                     let user_provided_types = cx.tables().user_provided_types();\n                                     let user_ty = user_provided_types.get(expr.hir_id)\n                                         .map(|u_ty| *u_ty);"}, {"sha": "303ffcb3bfb3ab653a5d17137982f0c59bb8add8", "filename": "src/librustc_mir/hair/pattern/_match.rs", "status": "modified", "additions": 10, "deletions": 23, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2F_match.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -168,7 +168,7 @@ use super::{PatternFoldable, PatternFolder, compare_const_vals};\n \n use rustc::hir::def_id::DefId;\n use rustc::hir::RangeEnd;\n-use rustc::ty::{self, subst::SubstsRef, Ty, TyCtxt, TypeFoldable, Const};\n+use rustc::ty::{self, Ty, TyCtxt, TypeFoldable, Const};\n use rustc::ty::layout::{Integer, IntegerExt, VariantIdx, Size};\n \n use rustc::mir::Field;\n@@ -399,22 +399,10 @@ impl<'a, 'tcx> MatchCheckCtxt<'a, 'tcx> {\n             _ => false,\n         }\n     }\n-\n-    fn is_variant_uninhabited(&self,\n-                              variant: &'tcx ty::VariantDef,\n-                              substs: SubstsRef<'tcx>)\n-                              -> bool\n-    {\n-        if self.tcx.features().exhaustive_patterns {\n-            self.tcx.is_enum_variant_uninhabited_from(self.module, variant, substs)\n-        } else {\n-            false\n-        }\n-    }\n }\n \n #[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor<'tcx> {\n+enum Constructor<'tcx> {\n     /// The constructor of all patterns that don't vary by constructor,\n     /// e.g., struct patterns and fixed-length arrays.\n     Single,\n@@ -435,7 +423,7 @@ impl<'tcx> Constructor<'tcx> {\n         adt: &'tcx ty::AdtDef,\n     ) -> VariantIdx {\n         match self {\n-            &Variant(id) => adt.variant_index_with_ctor_or_variant_id(id),\n+            &Variant(id) => adt.variant_index_with_id(id),\n             &Single => {\n                 assert!(!adt.is_enum());\n                 VariantIdx::new(0)\n@@ -658,8 +646,11 @@ fn all_constructors<'a, 'tcx: 'a>(cx: &mut MatchCheckCtxt<'a, 'tcx>,\n         }\n         ty::Adt(def, substs) if def.is_enum() => {\n             def.variants.iter()\n-                .filter(|v| !cx.is_variant_uninhabited(v, substs))\n-                .map(|v| v.ctor_did().map_or_else(|| Variant(v.variant_did()), |did| Variant(did)))\n+                .filter(|v| {\n+                    !cx.tcx.features().exhaustive_patterns ||\n+                    !v.uninhabited_from(cx.tcx, substs, def.adt_kind()).contains(cx.tcx, cx.module)\n+                })\n+                .map(|v| Variant(v.def_id))\n                 .collect()\n         }\n         ty::Char => {\n@@ -1307,9 +1298,7 @@ fn pat_constructors<'tcx>(cx: &mut MatchCheckCtxt<'_, 'tcx>,\n         PatternKind::Binding { .. } | PatternKind::Wild => None,\n         PatternKind::Leaf { .. } | PatternKind::Deref { .. } => Some(vec![Single]),\n         PatternKind::Variant { adt_def, variant_index, .. } => {\n-            let variant = &adt_def.variants[variant_index];\n-            Some(variant.ctor_did()\n-                .map_or_else(|| vec![Variant(variant.variant_did())], |did| vec![Variant(did)]))\n+            Some(vec![Variant(adt_def.variants[variant_index].def_id)])\n         }\n         PatternKind::Constant { value } => Some(vec![ConstantValue(value)]),\n         PatternKind::Range(PatternRange { lo, hi, ty, end }) =>\n@@ -1744,9 +1733,7 @@ fn specialize<'p, 'a: 'p, 'tcx: 'a>(\n \n         PatternKind::Variant { adt_def, variant_index, ref subpatterns, .. } => {\n             let ref variant = adt_def.variants[variant_index];\n-            variant.ctor_did()\n-                .map(|did| Variant(did))\n-                .or_else(|| Some(Variant(variant.variant_did())))\n+            Some(Variant(variant.def_id))\n                 .filter(|variant_constructor| variant_constructor == constructor)\n                 .map(|_| patterns_for_variant(subpatterns, wild_patterns))\n         }"}, {"sha": "2f1c542b4737c982ecb08f4892ca2ec7d35e918a", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -757,7 +757,7 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                     PatternKind::Variant {\n                         adt_def,\n                         substs,\n-                        variant_index: adt_def.variant_index_with_variant_id(variant_id),\n+                        variant_index: adt_def.variant_index_with_id(variant_id),\n                         subpatterns,\n                     }\n                 } else {"}, {"sha": "32986014282a5a8d12de10be616cbac38f36038b", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -1318,11 +1318,10 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx> + 'o {\n                     tcx.hygienic_eq(assoc_ident, vd.ident, adt_def.did)\n                 });\n                 if let Some(variant_def) = variant_def {\n-                    let did = variant_def.variant_did();\n-                    let def = Def::Variant(did);\n+                    let def = Def::Variant(variant_def.def_id);\n                     if permit_variants {\n                         check_type_alias_enum_variants_enabled(tcx, span);\n-                        tcx.check_stability(did, Some(hir_ref_id), span);\n+                        tcx.check_stability(variant_def.def_id, Some(hir_ref_id), span);\n                         return (qself_ty, def);\n                     } else {\n                         variant_resolution = Some(def);"}, {"sha": "d56a0dcc0446ca737f3d288c9f453cc93fee8276", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -947,8 +947,7 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n         let mut inexistent_fields = vec![];\n         // Typecheck each field.\n         for &Spanned { node: ref field, span } in fields {\n-            let ident = tcx.adjust_ident(\n-                field.ident, variant.variant_did_or_parent_struct_did(), self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n             let field_ty = match used_fields.entry(ident) {\n                 Occupied(occupied) => {\n                     struct_span_err!(tcx.sess, span, E0025,\n@@ -996,19 +995,18 @@ https://doc.rust-lang.org/reference/types.html#trait-objects\");\n                             .join(\", \")), \"these\", \"s\")\n             };\n             let spans = inexistent_fields.iter().map(|(span, _)| *span).collect::<Vec<_>>();\n-            let did = variant.variant_did_or_parent_struct_did();\n             let mut err = struct_span_err!(tcx.sess,\n                                            spans,\n                                            E0026,\n                                            \"{} `{}` does not have {}\",\n                                            kind_name,\n-                                           tcx.def_path_str(did),\n+                                           tcx.def_path_str(variant.def_id),\n                                            field_names);\n             if let Some((span, ident)) = inexistent_fields.last() {\n                 err.span_label(*span,\n                                format!(\"{} `{}` does not have {} field{}\",\n                                        kind_name,\n-                                       tcx.def_path_str(did),\n+                                       tcx.def_path_str(variant.def_id),\n                                        t,\n                                        plural));\n                 if plural == \"\" {"}, {"sha": "b1a249d821bec77b279f3d3629d90e2fbadc237d", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -130,7 +130,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                         let sole_field = &variant.fields[0];\n                         let sole_field_ty = sole_field.ty(self.tcx, substs);\n                         if self.can_coerce(expr_ty, sole_field_ty) {\n-                            let variant_path = self.tcx.def_path_str(variant.variant_did());\n+                            let variant_path = self.tcx.def_path_str(variant.def_id);\n                             // FIXME #56861: DRYer prelude filtering\n                             Some(variant_path.trim_start_matches(\"std::prelude::v1::\").to_string())\n                         } else {"}, {"sha": "0060b1031a761a837569fa6a528b4c3d99537344", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -417,13 +417,13 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                 if let Some(variant_def) = variant_def {\n                     check_type_alias_enum_variants_enabled(tcx, span);\n \n-                    let def = if let Some(ctor_did) = variant_def.ctor_did() {\n-                        Def::Ctor(hir::CtorOf::Variant, ctor_did, variant_def.ctor_kind)\n+                    let def = if let Some(ctor_def_id) = variant_def.ctor_def_id {\n+                        Def::Ctor(hir::CtorOf::Variant, ctor_def_id, variant_def.ctor_kind)\n                     } else {\n                         // Normally, there do not exist any `Def::Ctor` for `Struct`-variants but\n                         // in this case, we can get better error messages as diagnostics will\n                         // specialize the message around a `CtorKind::Fictive`.\n-                        Def::Ctor(hir::CtorOf::Variant, variant_def.variant_did(),\n+                        Def::Ctor(hir::CtorOf::Variant, variant_def.def_id,\n                                   hir::def::CtorKind::Fictive)\n                     };\n "}, {"sha": "b6bfa9ce27bd2a23e3dbf42912732f791ef6f675", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -1863,7 +1863,7 @@ pub fn check_enum<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     for ((_, discr), v) in def.discriminants(tcx).zip(vs) {\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n-            let variant_did = def.variants[VariantIdx::new(i)].variant_did();\n+            let variant_did = def.variants[VariantIdx::new(i)].def_id;\n             let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did).unwrap();\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.node.disr_expr {\n@@ -3693,7 +3693,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let names = variant.fields.iter().filter_map(|field| {\n             // ignore already set fields and private fields from non-local crates\n             if skip.iter().any(|x| *x == field.ident.as_str()) ||\n-               (!variant.is_local() && field.vis != Visibility::Public)\n+               (!variant.def_id.is_local() && field.vis != Visibility::Public)\n             {\n                 None\n             } else {\n@@ -3706,8 +3706,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n     fn available_field_names(&self, variant: &'tcx ty::VariantDef) -> Vec<ast::Name> {\n         variant.fields.iter().filter(|field| {\n-            let did = variant.variant_did_or_parent_struct_did();\n-            let def_scope = self.tcx.adjust_ident(field.ident, did, self.body_id).1;\n+            let def_scope = self.tcx.adjust_ident(field.ident, variant.def_id, self.body_id).1;\n             field.vis.is_accessible_from(def_scope, self.tcx)\n         })\n         .map(|field| field.ident.name)\n@@ -3825,8 +3824,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n \n         // Type-check each field.\n         for field in ast_fields {\n-            let ident = tcx.adjust_ident(\n-                field.ident, variant.variant_did_or_parent_struct_did(), self.body_id).0;\n+            let ident = tcx.adjust_ident(field.ident, variant.def_id, self.body_id).0;\n             let field_type = if let Some((i, v_field)) = remaining_fields.remove(&ident) {\n                 seen_fields.insert(ident, field.span);\n                 self.write_field_index(field.hir_id, i);\n@@ -5346,9 +5344,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             match adt_def {\n                 Some(adt_def) if adt_def.has_ctor() => {\n                     let variant = adt_def.non_enum_variant();\n-                    let ctor_did = variant.ctor_did().unwrap();\n-                    let def = Def::Ctor(hir::CtorOf::Struct, ctor_did, variant.ctor_kind);\n-                    (def, ctor_did, tcx.type_of(ctor_did))\n+                    let ctor_def_id = variant.ctor_def_id.unwrap();\n+                    let def = Def::Ctor(hir::CtorOf::Struct, ctor_def_id, variant.ctor_kind);\n+                    (def, ctor_def_id, tcx.type_of(ctor_def_id))\n                 }\n                 _ => {\n                     let mut err = tcx.sess.struct_span_err(span,"}, {"sha": "61dbf00a1f536af81fdc52ef1fd8b470cba2adf9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f5a8dcdb95b07234d323cad8492bef96f2bee1b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7f5a8dcdb95b07234d323cad8492bef96f2bee1b", "patch": "@@ -3169,16 +3169,15 @@ impl<'tcx> Clean<Item> for ty::VariantDef {\n                 })\n             }\n         };\n-        let did = self.variant_did_or_parent_struct_did();\n         Item {\n             name: Some(self.ident.clean(cx)),\n-            attrs: inline::load_attrs(cx, did),\n-            source: cx.tcx.def_span(did).clean(cx),\n+            attrs: inline::load_attrs(cx, self.def_id),\n+            source: cx.tcx.def_span(self.def_id).clean(cx),\n             visibility: Some(Inherited),\n-            def_id: did,\n+            def_id: self.def_id,\n             inner: VariantItem(Variant { kind }),\n-            stability: get_stability(cx, did),\n-            deprecation: get_deprecation(cx, did),\n+            stability: get_stability(cx, self.def_id),\n+            deprecation: get_deprecation(cx, self.def_id),\n         }\n     }\n }"}]}