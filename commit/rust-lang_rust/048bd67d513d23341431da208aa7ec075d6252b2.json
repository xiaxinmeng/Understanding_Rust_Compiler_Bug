{"sha": "048bd67d513d23341431da208aa7ec075d6252b2", "node_id": "C_kwDOAAsO6NoAKDA0OGJkNjdkNTEzZDIzMzQxNDMxZGEyMDhhYTdlYzA3NWQ2MjUyYjI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-30T20:00:07Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-31T00:48:36Z"}, "message": "Clarify `idx` handling in sequences.\n\nBy adding comments, and improving an assertion. I finally fully\nunderstand this part!", "tree": {"sha": "13725c98b7e39fc122ce23b5bd4116a950dcb2dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13725c98b7e39fc122ce23b5bd4116a950dcb2dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/048bd67d513d23341431da208aa7ec075d6252b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/048bd67d513d23341431da208aa7ec075d6252b2", "html_url": "https://github.com/rust-lang/rust/commit/048bd67d513d23341431da208aa7ec075d6252b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/048bd67d513d23341431da208aa7ec075d6252b2/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2e423c7fd06223a49e3f85636c620a7a70fbc221", "url": "https://api.github.com/repos/rust-lang/rust/commits/2e423c7fd06223a49e3f85636c620a7a70fbc221", "html_url": "https://github.com/rust-lang/rust/commit/2e423c7fd06223a49e3f85636c620a7a70fbc221"}], "stats": {"total": 27, "additions": 18, "deletions": 9}, "files": [{"sha": "3fd81e2d87d899ff857199aabfd0ad58dcc07d21", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/048bd67d513d23341431da208aa7ec075d6252b2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/048bd67d513d23341431da208aa7ec075d6252b2/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=048bd67d513d23341431da208aa7ec075d6252b2", "patch": "@@ -122,7 +122,9 @@ struct MatcherPos<'tt> {\n     /// submatcher, this is just the contents of that submatcher.\n     tts: &'tt [TokenTree],\n \n-    /// The \"dot\" position within the current submatcher, i.e. the index into `tts`.\n+    /// The \"dot\" position within the current submatcher, i.e. the index into `tts`. Can go one or\n+    /// two positions past the final elements in `tts` when dealing with sequences, see\n+    /// `parse_tt_inner` for details.\n     idx: usize,\n \n     /// This vector ends up with one element per metavar in the *top-level* matcher, even when this\n@@ -540,20 +542,26 @@ impl<'tt> TtParser<'tt> {\n                 }\n             } else if let Some(sequence) = &mp.sequence {\n                 // We are past the end of a sequence.\n-                debug_assert!(idx <= len + 1);\n+                // - If it has no separator, we must be only one past the end.\n+                // - If it has a separator, we may be one past the end, in which case we must\n+                //   look for a separator. Or we may be two past the end, in which case we have\n+                //   already dealt with the separator.\n+                debug_assert!(idx == len || idx == len + 1 && sequence.seq.separator.is_some());\n \n                 if idx == len {\n-                    // Add all matches from the sequence to `parent`, and move the \"dot\" past the\n-                    // sequence in `parent`. This allows for the case where the sequence matching\n-                    // is finished.\n+                    // Sequence matching may have finished: move the \"dot\" past the sequence in\n+                    // `parent`. This applies whether a separator is used or not. If sequence\n+                    // matching hasn't finished, this `new_mp` will fail quietly when it is\n+                    // processed next time around the loop.\n                     let mut new_mp = sequence.parent.clone();\n                     new_mp.matches = mp.matches.clone();\n                     new_mp.match_cur = mp.match_cur;\n                     new_mp.idx += 1;\n                     self.cur_mps.push(new_mp);\n                 }\n \n-                if idx == len && sequence.seq.separator.is_some() {\n+                if sequence.seq.separator.is_some() && idx == len {\n+                    // Look for the separator.\n                     if sequence\n                         .seq\n                         .separator\n@@ -566,9 +574,10 @@ impl<'tt> TtParser<'tt> {\n                         self.next_mps.push(mp);\n                     }\n                 } else if sequence.seq.kleene.op != mbe::KleeneOp::ZeroOrOne {\n-                    // We don't need a separator. Move the \"dot\" back to the beginning of the\n-                    // matcher and try to match again UNLESS we are only allowed to have _one_\n-                    // repetition.\n+                    // We don't need to look for a separator: either this sequence doesn't have\n+                    // one, or it does and we've already handled it. Also, we are allowed to have\n+                    // more than one repetition. Move the \"dot\" back to the beginning of the\n+                    // matcher and try to match again.\n                     mp.match_cur -= sequence.seq.num_captures;\n                     mp.idx = 0;\n                     self.cur_mps.push(mp);"}]}