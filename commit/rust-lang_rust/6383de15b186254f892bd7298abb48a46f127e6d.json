{"sha": "6383de15b186254f892bd7298abb48a46f127e6d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzODNkZTE1YjE4NjI1NGY4OTJiZDcyOThhYmI0OGE0NmYxMjdlNmQ=", "commit": {"author": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-04-11T21:37:40Z"}, "committer": {"name": "Cengiz Can", "email": "canc@thoughtworks.com", "date": "2017-04-18T18:43:22Z"}, "message": "fixes #40013", "tree": {"sha": "b54345798bdfc2f720ee73666dbda5daee6fba29", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b54345798bdfc2f720ee73666dbda5daee6fba29"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6383de15b186254f892bd7298abb48a46f127e6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6383de15b186254f892bd7298abb48a46f127e6d", "html_url": "https://github.com/rust-lang/rust/commit/6383de15b186254f892bd7298abb48a46f127e6d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6383de15b186254f892bd7298abb48a46f127e6d/comments", "author": null, "committer": null, "parents": [{"sha": "c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "url": "https://api.github.com/repos/rust-lang/rust/commits/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542", "html_url": "https://github.com/rust-lang/rust/commit/c398efc53f09f6e1a8cba4ec2259ffb9d89f0542"}], "stats": {"total": 531, "additions": 258, "deletions": 273}, "files": [{"sha": "ec4444ac4e36ff472922a7e6fd3f612c411b91d8", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1807,6 +1807,58 @@ makes a difference in practice.)\n [rfc401]: https://github.com/rust-lang/rfcs/blob/master/text/0401-coercions.md\n \"##,\n \n+/*\n+\n+E0101: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You hit this error because the compiler lacks the information to\n+determine a type for this expression. Erroneous code example:\n+\n+```ignore\n+let x = |_| {}; // error: cannot determine a type for this expression\n+```\n+\n+You have two possibilities to solve this situation:\n+\n+* Give an explicit definition of the expression\n+* Infer the expression\n+\n+Examples:\n+\n+```\n+let x = |_ : u32| {}; // ok!\n+// or:\n+let x = |_| {};\n+x(0u32);\n+```\n+\"##,\n+\n+E0102: r##\"\n+#### Note: this error code is no longer emitted by the compiler.\n+\n+You hit this error because the compiler lacks the information to\n+determine the type of this variable. Erroneous code example:\n+\n+```ignore\n+// could be an array of anything\n+let x = []; // error: cannot determine a type for this local variable\n+```\n+\n+To solve this situation, constrain the type of the variable.\n+Examples:\n+\n+```\n+#![allow(unused_variables)]\n+\n+fn main() {\n+    let x: [u8; 0] = [];\n+}\n+```\n+\"##,\n+\n+*/\n+\n }\n \n "}, {"sha": "8a8a5ef3e3afb1092b3bf9fe483add6f5beea7bd", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 84, "deletions": 41, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -25,16 +25,16 @@ use super::{\n \n use errors::DiagnosticBuilder;\n use fmt_macros::{Parser, Piece, Position};\n-use hir::{intravisit, Local, Pat};\n+use hir::{self, intravisit, Local, Pat, Body};\n use hir::intravisit::{Visitor, NestedVisitorMap};\n use hir::map::NodeExpr;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n use rustc::lint::builtin::EXTRA_REQUIREMENT_IN_IMPL;\n use std::fmt;\n-use syntax::ast;\n-use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable};\n+use syntax::ast::{self, NodeId};\n+use ty::{self, AdtKind, ToPredicate, ToPolyTraitRef, Ty, TyCtxt, TypeFoldable, TyInfer, TyVar};\n use ty::error::ExpectedFound;\n use ty::fast_reject;\n use ty::fold::TypeFolder;\n@@ -66,37 +66,52 @@ impl<'a, 'gcx, 'tcx> TraitErrorKey<'tcx> {\n struct FindLocalByTypeVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     infcx: &'a InferCtxt<'a, 'gcx, 'tcx>,\n     target_ty: &'a Ty<'tcx>,\n-    found_pattern: Option<&'a Pat>,\n+    hir_map: &'a hir::map::Map<'gcx>,\n+    found_local_pattern: Option<&'gcx Pat>,\n+    found_arg_pattern: Option<&'gcx Pat>,\n }\n \n impl<'a, 'gcx, 'tcx> FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn is_match(&self, ty: Ty<'tcx>) -> bool {\n-        ty == *self.target_ty || match (&ty.sty, &self.target_ty.sty) {\n-            (&ty::TyInfer(ty::TyVar(a_vid)), &ty::TyInfer(ty::TyVar(b_vid))) =>\n-                self.infcx.type_variables\n-                          .borrow_mut()\n-                          .sub_unified(a_vid, b_vid),\n-\n+    fn node_matches_type(&mut self, node_id: &'gcx NodeId) -> bool {\n+        match self.infcx.tables.borrow().node_types.get(node_id) {\n+            Some(&ty) => {\n+                let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n+                ty.walk().any(|inner_ty| {\n+                    inner_ty == *self.target_ty || match (&inner_ty.sty, &self.target_ty.sty) {\n+                        (&TyInfer(TyVar(a_vid)), &TyInfer(TyVar(b_vid))) => {\n+                            self.infcx\n+                                .type_variables\n+                                .borrow_mut()\n+                                .sub_unified(a_vid, b_vid)\n+                        }\n+                        _ => false,\n+                    }\n+                })\n+            }\n             _ => false,\n         }\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Visitor<'a> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'a> {\n-        NestedVisitorMap::None\n+impl<'a, 'gcx, 'tcx> Visitor<'gcx> for FindLocalByTypeVisitor<'a, 'gcx, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'gcx> {\n+        NestedVisitorMap::OnlyBodies(&self.hir_map)\n     }\n \n-    fn visit_local(&mut self, local: &'a Local) {\n-        if let Some(&ty) = self.infcx.tables.borrow().node_types.get(&local.id) {\n-            let ty = self.infcx.resolve_type_vars_if_possible(&ty);\n-            let is_match = ty.walk().any(|t| self.is_match(t));\n+    fn visit_local(&mut self, local: &'gcx Local) {\n+        if self.found_local_pattern.is_none() && self.node_matches_type(&local.id) {\n+            self.found_local_pattern = Some(&*local.pat);\n+        }\n+        intravisit::walk_local(self, local);\n+    }\n \n-            if is_match && self.found_pattern.is_none() {\n-                self.found_pattern = Some(&*local.pat);\n+    fn visit_body(&mut self, body: &'gcx Body) {\n+        for argument in &body.arguments {\n+            if self.found_arg_pattern.is_none() && self.node_matches_type(&argument.id) {\n+                self.found_arg_pattern = Some(&*argument.pat);\n             }\n         }\n-        intravisit::walk_local(self, local);\n+        intravisit::walk_body(self, body);\n     }\n }\n \n@@ -721,6 +736,8 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // coherence violation, so we don't report it here.\n \n         let predicate = self.resolve_type_vars_if_possible(&obligation.predicate);\n+        let body_id = hir::BodyId { node_id: obligation.cause.body_id };\n+        let span = obligation.cause.span;\n \n         debug!(\"maybe_report_ambiguity(predicate={:?}, obligation={:?})\",\n                predicate,\n@@ -768,10 +785,10 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         self.tcx.lang_items.sized_trait()\n                         .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n                     {\n-                        self.need_type_info(obligation, self_ty);\n+                        self.need_type_info(body_id, span, self_ty);\n                     } else {\n                         let mut err = struct_span_err!(self.tcx.sess,\n-                                                        obligation.cause.span, E0283,\n+                                                        span, E0283,\n                                                         \"type annotations required: \\\n                                                         cannot resolve `{}`\",\n                                                         predicate);\n@@ -785,7 +802,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if !ty.references_error() && !self.tcx.sess.has_errors() {\n-                    self.need_type_info(obligation, ty);\n+                    self.need_type_info(body_id, span, ty);\n                 }\n             }\n \n@@ -796,7 +813,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     let &SubtypePredicate { a_is_expected: _, a, b } = data.skip_binder();\n                     // both must be type variables, or the other would've been instantiated\n                     assert!(a.is_ty_var() && b.is_ty_var());\n-                    self.need_type_info(obligation, a);\n+                    self.need_type_info(hir::BodyId { node_id: obligation.cause.body_id },\n+                                        obligation.cause.span,\n+                                        a);\n                 }\n             }\n \n@@ -874,42 +893,66 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn need_type_info(&self, obligation: &PredicateObligation<'tcx>, ty: Ty<'tcx>) {\n+    pub fn need_type_info(&self, body_id: hir::BodyId, span: Span, ty: Ty<'tcx>) {\n         let ty = self.resolve_type_vars_if_possible(&ty);\n         let name = self.extract_type_name(&ty);\n-        let ref cause = obligation.cause;\n \n-        let mut err = struct_span_err!(self.tcx.sess,\n-                                       cause.span,\n-                                       E0282,\n-                                       \"type annotations needed\");\n-\n-        err.span_label(cause.span, &format!(\"cannot infer type for `{}`\", name));\n+        let mut err_span = span;\n+        let mut labels = vec![(span, format!(\"cannot infer type for `{}`\", name))];\n \n         let mut local_visitor = FindLocalByTypeVisitor {\n             infcx: &self,\n             target_ty: &ty,\n-            found_pattern: None,\n+            hir_map: &self.tcx.hir,\n+            found_local_pattern: None,\n+            found_arg_pattern: None,\n         };\n \n         // #40294: cause.body_id can also be a fn declaration.\n         // Currently, if it's anything other than NodeExpr, we just ignore it\n-        match self.tcx.hir.find(cause.body_id) {\n+        match self.tcx.hir.find(body_id.node_id) {\n             Some(NodeExpr(expr)) => local_visitor.visit_expr(expr),\n             _ => ()\n         }\n \n-        if let Some(pattern) = local_visitor.found_pattern {\n-            let pattern_span = pattern.span;\n+        if let Some(pattern) = local_visitor.found_arg_pattern {\n+            err_span = pattern.span;\n+            // We don't want to show the default label for closures.\n+            //\n+            // So, before clearing, the output would look something like this:\n+            // ```\n+            // let x = |_| {  };\n+            //          -  ^^^^ cannot infer type for `[_; 0]`\n+            //          |\n+            //          consider giving this closure parameter a type\n+            // ```\n+            //\n+            // After clearing, it looks something like this:\n+            // ```\n+            // let x = |_| {  };\n+            //          ^ consider giving this closure parameter a type\n+            // ```\n+            labels.clear();\n+            labels.push((pattern.span, format!(\"consider giving this closure parameter a type\")));\n+        }\n+\n+        if let Some(pattern) = local_visitor.found_local_pattern {\n             if let Some(simple_name) = pattern.simple_name() {\n-                err.span_label(pattern_span,\n-                               &format!(\"consider giving `{}` a type\",\n-                                        simple_name));\n+                labels.push((pattern.span, format!(\"consider giving `{}` a type\", simple_name)));\n             } else {\n-                err.span_label(pattern_span, &format!(\"consider giving a type to pattern\"));\n+                labels.push((pattern.span, format!(\"consider giving a type to pattern\")));\n             }\n         }\n \n+        let mut err = struct_span_err!(self.tcx.sess,\n+                                       err_span,\n+                                       E0282,\n+                                       \"type annotations needed\");\n+\n+        for (target_span, label_message) in labels {\n+            err.span_label(target_span, &label_message);\n+        }\n+\n         err.emit();\n     }\n "}, {"sha": "f196aa82b1ef3ebc7a76da218e2a1de2b5b52e68", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 85, "deletions": 166, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -11,22 +11,18 @@\n // Type resolution: the phase that finds all the types in the AST with\n // unresolved type variables and replaces \"ty_var\" types with their\n // substitutions.\n-use self::ResolveReason::*;\n \n use check::FnCtxt;\n+use rustc::hir;\n+use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n+use rustc::infer::{InferCtxt};\n use rustc::ty::{self, Ty, TyCtxt, MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::fold::{TypeFolder,TypeFoldable};\n-use rustc::infer::{InferCtxt, FixupError};\n use rustc::util::nodemap::{DefIdMap, DefIdSet};\n-\n-use std::mem;\n-\n use syntax::ast;\n use syntax_pos::Span;\n-\n-use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n-use rustc::hir;\n+use std::mem;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n@@ -37,9 +33,9 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         let item_id = self.tcx.hir.body_owner(body.id());\n         let item_def_id = self.tcx.hir.local_def_id(item_id);\n \n-        let mut wbcx = WritebackCx::new(self);\n+        let mut wbcx = WritebackCx::new(self, body);\n         for arg in &body.arguments {\n-            wbcx.visit_node_id(ResolvingPattern(arg.pat.span), arg.id);\n+            wbcx.visit_node_id(arg.pat.span, arg.id);\n         }\n         wbcx.visit_body(body);\n         wbcx.visit_upvar_borrow_map();\n@@ -80,15 +76,19 @@ struct WritebackCx<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     // early-bound versions of them, visible from the\n     // outside of the function. This is needed by, and\n     // only populated if there are any `impl Trait`.\n-    free_to_bound_regions: DefIdMap<&'gcx ty::Region>\n+    free_to_bound_regions: DefIdMap<&'gcx ty::Region>,\n+\n+    body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>) -> WritebackCx<'cx, 'gcx, 'tcx> {\n+    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, body: &'gcx hir::Body)\n+        -> WritebackCx<'cx, 'gcx, 'tcx> {\n         let mut wbcx = WritebackCx {\n             fcx: fcx,\n             tables: ty::TypeckTables::empty(),\n-            free_to_bound_regions: DefIdMap()\n+            free_to_bound_regions: DefIdMap(),\n+            body: body\n         };\n \n         // Only build the reverse mapping if `impl Trait` is used.\n@@ -195,21 +195,20 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_stmt(&mut self, s: &'gcx hir::Stmt) {\n-        self.visit_node_id(ResolvingExpr(s.span), s.node.id());\n+        self.visit_node_id(s.span, s.node.id());\n         intravisit::walk_stmt(self, s);\n     }\n \n     fn visit_expr(&mut self, e: &'gcx hir::Expr) {\n         self.fix_scalar_builtin_expr(e);\n \n-        self.visit_node_id(ResolvingExpr(e.span), e.id);\n-        self.visit_method_map_entry(ResolvingExpr(e.span),\n-                                    MethodCall::expr(e.id));\n+        self.visit_node_id(e.span, e.id);\n+        self.visit_method_map_entry(e.span, MethodCall::expr(e.id));\n \n         if let hir::ExprClosure(_, _, body, _) = e.node {\n             let body = self.fcx.tcx.hir.body(body);\n             for arg in &body.arguments {\n-                self.visit_node_id(ResolvingExpr(e.span), arg.id);\n+                self.visit_node_id(e.span, arg.id);\n             }\n \n             self.visit_body(body);\n@@ -219,20 +218,20 @@ impl<'cx, 'gcx, 'tcx> Visitor<'gcx> for WritebackCx<'cx, 'gcx, 'tcx> {\n     }\n \n     fn visit_block(&mut self, b: &'gcx hir::Block) {\n-        self.visit_node_id(ResolvingExpr(b.span), b.id);\n+        self.visit_node_id(b.span, b.id);\n         intravisit::walk_block(self, b);\n     }\n \n     fn visit_pat(&mut self, p: &'gcx hir::Pat) {\n-        self.visit_node_id(ResolvingPattern(p.span), p.id);\n+        self.visit_node_id(p.span, p.id);\n         intravisit::walk_pat(self, p);\n     }\n \n     fn visit_local(&mut self, l: &'gcx hir::Local) {\n+        intravisit::walk_local(self, l);\n         let var_ty = self.fcx.local_ty(l.span, l.id);\n-        let var_ty = self.resolve(&var_ty, ResolvingLocal(l.span));\n+        let var_ty = self.resolve(&var_ty, &l.span);\n         self.write_ty_to_tables(l.id, var_ty);\n-        intravisit::walk_local(self, l);\n     }\n }\n \n@@ -243,7 +242,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n                     let r = upvar_borrow.region;\n-                    let r = self.resolve(&r, ResolvingUpvar(*upvar_id));\n+                    let r = self.resolve(&r, &upvar_id.var_id);\n                     ty::UpvarCapture::ByRef(\n                         ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n                 }\n@@ -257,7 +256,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_closures(&mut self) {\n         for (&id, closure_ty) in self.fcx.tables.borrow().closure_tys.iter() {\n-            let closure_ty = self.resolve(closure_ty, ResolvingClosure(id));\n+            let closure_ty = self.resolve(closure_ty, &id);\n             self.tables.closure_tys.insert(id, closure_ty);\n         }\n \n@@ -282,8 +281,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n     fn visit_anon_types(&mut self) {\n         let gcx = self.tcx().global_tcx();\n         for (&node_id, &concrete_ty) in self.fcx.anon_types.borrow().iter() {\n-            let reason = ResolvingAnonTy(node_id);\n-            let inside_ty = self.resolve(&concrete_ty, reason);\n+            let inside_ty = self.resolve(&concrete_ty, &node_id);\n \n             // Convert the type from the function into a type valid outside\n             // the function, by replacing free regions with early-bound ones.\n@@ -305,7 +303,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                     ty::ReLateBound(..) |\n                     ty::ReScope(_) |\n                     ty::ReSkolemized(..) => {\n-                        let span = reason.span(self.tcx());\n+                        let span = node_id.to_span(&self.fcx.tcx);\n                         span_err!(self.tcx().sess, span, E0564,\n                                   \"only named lifetimes are allowed in `impl Trait`, \\\n                                    but `{}` was found in the type `{}`\", r, inside_ty);\n@@ -314,7 +312,7 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                     ty::ReVar(_) |\n                     ty::ReErased => {\n-                        let span = reason.span(self.tcx());\n+                        let span = node_id.to_span(&self.fcx.tcx);\n                         span_bug!(span, \"invalid region in impl Trait: {:?}\", r);\n                     }\n                 }\n@@ -324,37 +322,37 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n         }\n     }\n \n-    fn visit_node_id(&mut self, reason: ResolveReason, id: ast::NodeId) {\n+    fn visit_node_id(&mut self, span: Span, node_id: ast::NodeId) {\n         // Export associated path extensions.\n-        if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&id) {\n-            self.tables.type_relative_path_defs.insert(id, def);\n+        if let Some(def) = self.fcx.tables.borrow_mut().type_relative_path_defs.remove(&node_id) {\n+            self.tables.type_relative_path_defs.insert(node_id, def);\n         }\n \n-        // Resolve any borrowings for the node with id `id`\n-        self.visit_adjustments(reason, id);\n+        // Resolve any borrowings for the node with id `node_id`\n+        self.visit_adjustments(span, node_id);\n \n-        // Resolve the type of the node with id `id`\n-        let n_ty = self.fcx.node_ty(id);\n-        let n_ty = self.resolve(&n_ty, reason);\n-        self.write_ty_to_tables(id, n_ty);\n-        debug!(\"Node {} has type {:?}\", id, n_ty);\n+        // Resolve the type of the node with id `node_id`\n+        let n_ty = self.fcx.node_ty(node_id);\n+        let n_ty = self.resolve(&n_ty, &span);\n+        self.write_ty_to_tables(node_id, n_ty);\n+        debug!(\"Node {} has type {:?}\", node_id, n_ty);\n \n         // Resolve any substitutions\n-        self.fcx.opt_node_ty_substs(id, |item_substs| {\n-            let item_substs = self.resolve(item_substs, reason);\n+        self.fcx.opt_node_ty_substs(node_id, |item_substs| {\n+            let item_substs = self.resolve(item_substs, &span);\n             if !item_substs.is_noop() {\n-                debug!(\"write_substs_to_tcx({}, {:?})\", id, item_substs);\n+                debug!(\"write_substs_to_tcx({}, {:?})\", node_id, item_substs);\n                 assert!(!item_substs.substs.needs_infer());\n-                self.tables.item_substs.insert(id, item_substs);\n+                self.tables.item_substs.insert(node_id, item_substs);\n             }\n         });\n     }\n \n-    fn visit_adjustments(&mut self, reason: ResolveReason, id: ast::NodeId) {\n-        let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&id);\n+    fn visit_adjustments(&mut self, span: Span, node_id: ast::NodeId) {\n+        let adjustments = self.fcx.tables.borrow_mut().adjustments.remove(&node_id);\n         match adjustments {\n             None => {\n-                debug!(\"No adjustments for node {}\", id);\n+                debug!(\"No adjustments for node {}\", node_id);\n             }\n \n             Some(adjustment) => {\n@@ -381,29 +379,29 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n                     adjustment::Adjust::DerefRef { autoderefs, autoref, unsize } => {\n                         for autoderef in 0..autoderefs {\n-                            let method_call = MethodCall::autoderef(id, autoderef as u32);\n-                            self.visit_method_map_entry(reason, method_call);\n+                            let method_call = MethodCall::autoderef(node_id, autoderef as u32);\n+                            self.visit_method_map_entry(span, method_call);\n                         }\n \n                         adjustment::Adjust::DerefRef {\n                             autoderefs: autoderefs,\n-                            autoref: self.resolve(&autoref, reason),\n+                            autoref: self.resolve(&autoref, &span),\n                             unsize: unsize,\n                         }\n                     }\n                 };\n                 let resolved_adjustment = adjustment::Adjustment {\n                     kind: resolved_adjustment,\n-                    target: self.resolve(&adjustment.target, reason)\n+                    target: self.resolve(&adjustment.target, &span)\n                 };\n-                debug!(\"Adjustments for node {}: {:?}\", id, resolved_adjustment);\n-                self.tables.adjustments.insert(id, resolved_adjustment);\n+                debug!(\"Adjustments for node {}: {:?}\", node_id, resolved_adjustment);\n+                self.tables.adjustments.insert(node_id, resolved_adjustment);\n             }\n         }\n     }\n \n     fn visit_method_map_entry(&mut self,\n-                              reason: ResolveReason,\n+                              method_span: Span,\n                               method_call: MethodCall) {\n         // Resolve any method map entry\n         let new_method = match self.fcx.tables.borrow_mut().method_map.remove(&method_call) {\n@@ -413,8 +411,8 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n                        method);\n                 let new_method = MethodCallee {\n                     def_id: method.def_id,\n-                    ty: self.resolve(&method.ty, reason),\n-                    substs: self.resolve(&method.substs, reason),\n+                    ty: self.resolve(&method.ty, &method_span),\n+                    substs: self.resolve(&method.substs, &method_span),\n                 };\n \n                 Some(new_method)\n@@ -430,72 +428,49 @@ impl<'cx, 'gcx, 'tcx> WritebackCx<'cx, 'gcx, 'tcx> {\n \n     fn visit_liberated_fn_sigs(&mut self) {\n         for (&node_id, fn_sig) in self.fcx.tables.borrow().liberated_fn_sigs.iter() {\n-            let fn_sig = self.resolve(fn_sig, ResolvingFnSig(node_id));\n+            let fn_sig = self.resolve(fn_sig, &node_id);\n             self.tables.liberated_fn_sigs.insert(node_id, fn_sig.clone());\n         }\n     }\n \n     fn visit_fru_field_types(&mut self) {\n         for (&node_id, ftys) in self.fcx.tables.borrow().fru_field_types.iter() {\n-            let ftys = self.resolve(ftys, ResolvingFieldTypes(node_id));\n+            let ftys = self.resolve(ftys, &node_id);\n             self.tables.fru_field_types.insert(node_id, ftys);\n         }\n     }\n \n     fn visit_type_nodes(&self) {\n         for (&id, ty) in self.fcx.ast_ty_to_ty_cache.borrow().iter() {\n-            let ty = self.resolve(ty, ResolvingTyNode(id));\n+            let ty = self.resolve(ty, &id);\n             self.fcx.tcx.ast_ty_to_ty_cache.borrow_mut().insert(id, ty);\n         }\n     }\n \n-    fn resolve<T>(&self, x: &T, reason: ResolveReason) -> T::Lifted\n+    fn resolve<T>(&self, x: &T, span: &Locatable) -> T::Lifted\n         where T: TypeFoldable<'tcx> + ty::Lift<'gcx>\n     {\n-        let x = x.fold_with(&mut Resolver::new(self.fcx, reason));\n+        let x = x.fold_with(&mut Resolver::new(self.fcx, span, self.body));\n         if let Some(lifted) = self.tcx().lift_to_global(&x) {\n             lifted\n         } else {\n-            span_bug!(reason.span(self.tcx()),\n-                      \"writeback: `{:?}` missing from the global type context\", x);\n+            span_bug!(span.to_span(&self.fcx.tcx),\n+                      \"writeback: `{:?}` missing from the global type context\",\n+                      x);\n         }\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// Resolution reason.\n-\n-#[derive(Copy, Clone, Debug)]\n-enum ResolveReason {\n-    ResolvingExpr(Span),\n-    ResolvingLocal(Span),\n-    ResolvingPattern(Span),\n-    ResolvingUpvar(ty::UpvarId),\n-    ResolvingClosure(ast::NodeId),\n-    ResolvingFnSig(ast::NodeId),\n-    ResolvingFieldTypes(ast::NodeId),\n-    ResolvingAnonTy(ast::NodeId),\n-    ResolvingTyNode(ast::NodeId),\n+trait Locatable {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span;\n }\n \n-impl<'a, 'gcx, 'tcx> ResolveReason {\n-    fn span(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> Span {\n-        match *self {\n-            ResolvingExpr(s) => s,\n-            ResolvingLocal(s) => s,\n-            ResolvingPattern(s) => s,\n-            ResolvingUpvar(upvar_id) => {\n-                tcx.expr_span(upvar_id.closure_expr_id)\n-            }\n-            ResolvingClosure(id) |\n-            ResolvingFnSig(id) |\n-            ResolvingFieldTypes(id) |\n-            ResolvingTyNode(id) |\n-            ResolvingAnonTy(id) => {\n-                tcx.hir.span(id)\n-            }\n-        }\n-    }\n+impl Locatable for Span {\n+    fn to_span(&self, _: &TyCtxt) -> Span { *self }\n+}\n+\n+impl Locatable for ast::NodeId {\n+    fn to_span(&self, tcx: &TyCtxt) -> Span { tcx.hir.span(*self) }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -505,82 +480,25 @@ impl<'a, 'gcx, 'tcx> ResolveReason {\n struct Resolver<'cx, 'gcx: 'cx+'tcx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'gcx, 'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-    reason: ResolveReason,\n+    span: &'cx Locatable,\n+    body: &'gcx hir::Body,\n }\n \n impl<'cx, 'gcx, 'tcx> Resolver<'cx, 'gcx, 'tcx> {\n-    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>,\n-           reason: ResolveReason)\n-           -> Resolver<'cx, 'gcx, 'tcx>\n+    fn new(fcx: &'cx FnCtxt<'cx, 'gcx, 'tcx>, span: &'cx Locatable, body: &'gcx hir::Body)\n+        -> Resolver<'cx, 'gcx, 'tcx>\n     {\n-        Resolver::from_infcx(fcx, reason)\n-    }\n-\n-    fn from_infcx(infcx: &'cx InferCtxt<'cx, 'gcx, 'tcx>,\n-                  reason: ResolveReason)\n-                  -> Resolver<'cx, 'gcx, 'tcx>\n-    {\n-        Resolver { infcx: infcx,\n-                   tcx: infcx.tcx,\n-                   reason: reason }\n+        Resolver {\n+            tcx: fcx.tcx,\n+            infcx: fcx,\n+            span: span,\n+            body: body,\n+        }\n     }\n \n-    fn report_error(&self, e: FixupError) {\n+    fn report_error(&self, t: Ty<'tcx>) {\n         if !self.tcx.sess.has_errors() {\n-            match self.reason {\n-                ResolvingExpr(span) => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0101,\n-                        \"cannot determine a type for this expression: {}\", e)\n-                        .span_label(span, &format!(\"cannot resolve type of expression\"))\n-                        .emit();\n-                }\n-\n-                ResolvingLocal(span) => {\n-                    struct_span_err!(\n-                        self.tcx.sess, span, E0102,\n-                        \"cannot determine a type for this local variable: {}\", e)\n-                        .span_label(span, &format!(\"cannot resolve type of variable\"))\n-                        .emit();\n-                }\n-\n-                ResolvingPattern(span) => {\n-                    span_err!(self.tcx.sess, span, E0103,\n-                        \"cannot determine a type for this pattern binding: {}\", e);\n-                }\n-\n-                ResolvingUpvar(upvar_id) => {\n-                    let span = self.reason.span(self.tcx);\n-                    span_err!(self.tcx.sess, span, E0104,\n-                        \"cannot resolve lifetime for captured variable `{}`: {}\",\n-                        self.tcx.local_var_name_str(upvar_id.var_id), e);\n-                }\n-\n-                ResolvingClosure(_) => {\n-                    let span = self.reason.span(self.tcx);\n-                    span_err!(self.tcx.sess, span, E0196,\n-                              \"cannot determine a type for this closure\")\n-                }\n-\n-                ResolvingFnSig(_) |\n-                ResolvingFieldTypes(_) |\n-                ResolvingTyNode(_) => {\n-                    // any failures here should also fail when\n-                    // resolving the patterns, closure types, or\n-                    // something else.\n-                    let span = self.reason.span(self.tcx);\n-                    self.tcx.sess.delay_span_bug(\n-                        span,\n-                        &format!(\"cannot resolve some aspect of data for {:?}: {}\",\n-                                 self.reason, e));\n-                }\n-\n-                ResolvingAnonTy(_) => {\n-                    let span = self.reason.span(self.tcx);\n-                    span_err!(self.tcx.sess, span, E0563,\n-                              \"cannot determine a type for this `impl Trait`: {}\", e)\n-                }\n-            }\n+            self.infcx.need_type_info(self.body.id(), self.span.to_span(&self.tcx), t);\n         }\n     }\n }\n@@ -593,20 +511,21 @@ impl<'cx, 'gcx, 'tcx> TypeFolder<'gcx, 'tcx> for Resolver<'cx, 'gcx, 'tcx> {\n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.infcx.fully_resolve(&t) {\n             Ok(t) => t,\n-            Err(e) => {\n+            Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\",\n                        t);\n-                self.report_error(e);\n+                self.report_error(t);\n                 self.tcx().types.err\n             }\n         }\n     }\n \n+    // FIXME This should be carefully checked\n+    // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n     fn fold_region(&mut self, r: &'tcx ty::Region) -> &'tcx ty::Region {\n         match self.infcx.fully_resolve(&r) {\n             Ok(r) => r,\n-            Err(e) => {\n-                self.report_error(e);\n+            Err(_) => {\n                 self.tcx.mk_region(ty::ReStatic)\n             }\n         }"}, {"sha": "36094d6a8f6b19639969efa72969e6b0db7b38f2", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 47, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1351,50 +1351,6 @@ extern \"rust-intrinsic\" {\n ```\n \"##,\n \n-E0101: r##\"\n-You hit this error because the compiler lacks the information to\n-determine a type for this expression. Erroneous code example:\n-\n-```compile_fail,E0101\n-let x = |_| {}; // error: cannot determine a type for this expression\n-```\n-\n-You have two possibilities to solve this situation:\n-\n-* Give an explicit definition of the expression\n-* Infer the expression\n-\n-Examples:\n-\n-```\n-let x = |_ : u32| {}; // ok!\n-// or:\n-let x = |_| {};\n-x(0u32);\n-```\n-\"##,\n-\n-E0102: r##\"\n-You hit this error because the compiler lacks the information to\n-determine the type of this variable. Erroneous code example:\n-\n-```compile_fail,E0282\n-// could be an array of anything\n-let x = []; // error: cannot determine a type for this local variable\n-```\n-\n-To solve this situation, constrain the type of the variable.\n-Examples:\n-\n-```\n-#![allow(unused_variables)]\n-\n-fn main() {\n-    let x: [u8; 0] = [];\n-}\n-```\n-\"##,\n-\n E0107: r##\"\n This error means that an incorrect number of lifetime parameters were provided\n for a type (like a struct or enum) or trait:\n@@ -4146,8 +4102,6 @@ register_diagnostics! {\n //  E0068,\n //  E0085,\n //  E0086,\n-    E0103, // @GuillaumeGomez: I was unable to get this error, try your best!\n-    E0104,\n //  E0123,\n //  E0127,\n //  E0129,\n@@ -4164,7 +4118,7 @@ register_diagnostics! {\n //  E0188, // can not cast an immutable reference to a mutable pointer\n //  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n //  E0190, // deprecated: can only cast a &-pointer to an &-object\n-    E0196, // cannot determine a type for this closure\n+    E0196, // cannot determine a type for this closure // @cengizIO: this is no longer thrown. should I DELETE THIS?\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n     E0208,"}, {"sha": "0b35a9c3dbebc49ef4e9828df49b64fff45cc685", "filename": "src/test/ui/type-check/cannot_infer_local_or_array.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -9,5 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let (x,) = (vec![],);\n+    let x = [];\n }", "previous_filename": "src/test/ui/type-check/issue-38812-2.rs"}, {"sha": "8c52bb5a1d3a51d9401efe7d30800c019f4b8323", "filename": "src/test/ui/type-check/cannot_infer_local_or_array.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_array.stderr?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -0,0 +1,10 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/cannot_infer_local_or_array.rs:12:13\n+   |\n+12 |     let x = [];\n+   |         -   ^^ cannot infer type for `_`\n+   |         |\n+   |         consider giving `x` a type\n+\n+error: aborting due to previous error\n+"}, {"sha": "a9943f753366da8d794a144eed344cb7b1597d06", "filename": "src/test/ui/type-check/cannot_infer_local_or_vec.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "previous_filename": "src/test/ui/type-check/issue-38812.rs"}, {"sha": "4788fad20889e4123904a479d13ed2ade197b7c7", "filename": "src/test/ui/type-check/cannot_infer_local_or_vec.stderr", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec.stderr?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1,5 +1,5 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-38812.rs:12:13\n+  --> $DIR/cannot_infer_local_or_vec.rs:12:13\n    |\n 12 |     let x = vec![];\n    |         -   ^^^^^^ cannot infer type for `T`", "previous_filename": "src/test/ui/type-check/issue-38812.stderr"}, {"sha": "8d32c1ff683bb950f648f36671a3ca2a2e52300b", "filename": "src/test/ui/type-check/cannot_infer_local_or_vec_in_tuples.rs", "status": "renamed", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,7 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let x = |_| {};\n-    //~^ ERROR E0101\n-    //~| NOTE cannot resolve type of expression\n+    let (x, ) = (vec![], );\n }", "previous_filename": "src/test/compile-fail/E0101.rs"}, {"sha": "3431a1d5bb92adb5a4413e4ed9d2e6ecee069f8f", "filename": "src/test/ui/type-check/cannot_infer_local_or_vec_in_tuples.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fcannot_infer_local_or_vec_in_tuples.stderr?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1,8 +1,8 @@\n error[E0282]: type annotations needed\n-  --> $DIR/issue-38812-2.rs:12:17\n+  --> $DIR/cannot_infer_local_or_vec_in_tuples.rs:12:18\n    |\n-12 |     let (x,) = (vec![],);\n-   |         ----    ^^^^^^ cannot infer type for `T`\n+12 |     let (x, ) = (vec![], );\n+   |         -----    ^^^^^^ cannot infer type for `T`\n    |         |\n    |         consider giving a type to pattern\n    |", "previous_filename": "src/test/ui/type-check/issue-38812-2.stderr"}, {"sha": "296dc81a89bcf94e041ff53749c443faccfc47a4", "filename": "src/test/ui/type-check/issue-22897.rs", "status": "renamed", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -10,10 +10,6 @@\n \n fn main() { }\n \n-// Before these errors would ICE as \"cat_expr Errd\" because the errors\n-// were unknown when the bug was triggered.\n-\n fn unconstrained_type() {\n     [];\n-    //~^ ERROR cannot determine a type for this expression: unconstrained type\n }", "previous_filename": "src/test/compile-fail/issue-22897.rs"}, {"sha": "9568411885192a04f4002f0ca87a138159b22f1e", "filename": "src/test/ui/type-check/issue-22897.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Fissue-22897.stderr?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -0,0 +1,8 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-22897.rs:14:5\n+   |\n+14 |     [];\n+   |     ^^ cannot infer type for `[_; 0]`\n+\n+error: aborting due to previous error\n+"}, {"sha": "f1d357df12c43deede0f7b665d00794d16cfa020", "filename": "src/test/ui/type-check/unknown_type_for_closure.rs", "status": "renamed", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.rs?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -9,8 +9,5 @@\n // except according to those terms.\n \n fn main() {\n-    let x = [];\n-    //~^ ERROR type annotations needed\n-    //~| NOTE consider giving `x` a type\n-    //~| NOTE cannot infer type for `_`\n+    let x = |_| {    };\n }", "previous_filename": "src/test/compile-fail/E0102.rs"}, {"sha": "afbd15ca486bd1e66566ee1269341879986d5e45", "filename": "src/test/ui/type-check/unknown_type_for_closure.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6383de15b186254f892bd7298abb48a46f127e6d/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-check%2Funknown_type_for_closure.stderr?ref=6383de15b186254f892bd7298abb48a46f127e6d", "patch": "@@ -0,0 +1,8 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/unknown_type_for_closure.rs:12:14\n+   |\n+12 |     let x = |_| {    };\n+   |              ^ consider giving this closure parameter a type\n+\n+error: aborting due to previous error\n+"}]}