{"sha": "91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxYzE2ZmM4ZTYwNWRkYjdmMGI0Zjk2N2JkN2ZiZjYyY2NkNmEyOTI=", "commit": {"author": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-06T19:13:25Z"}, "committer": {"name": "mcarton", "email": "cartonmartin+git@gmail.com", "date": "2016-02-12T13:30:26Z"}, "message": "Refactor Expr comparisons", "tree": {"sha": "21e69b9e46471a1d8e960fc8016c8db65438489b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21e69b9e46471a1d8e960fc8016c8db65438489b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "html_url": "https://github.com/rust-lang/rust/commit/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1c7914c2e1afe34073f01acb5638963029cb961", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1c7914c2e1afe34073f01acb5638963029cb961", "html_url": "https://github.com/rust-lang/rust/commit/e1c7914c2e1afe34073f01acb5638963029cb961"}], "stats": {"total": 489, "additions": 254, "deletions": 235}, "files": [{"sha": "b1ea8f0c34742af59fe084d5a820c9cc03b9e8ad", "filename": "src/copies.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcopies.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -1,6 +1,7 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n-use utils::{get_parent_expr, in_macro, is_block_equal, is_exp_equal, span_lint, span_note_and_lint};\n+use utils::SpanlessEq;\n+use utils::{get_parent_expr, in_macro, span_lint, span_note_and_lint};\n \n /// **What it does:** This lint checks for consecutive `ifs` with the same condition. This lint is\n /// `Warn` by default.\n@@ -55,7 +56,7 @@ impl LateLintPass for CopyAndPaste {\n fn lint_same_then_else(cx: &LateContext, expr: &Expr) {\n     if let ExprIf(_, ref then_block, Some(ref else_expr)) = expr.node {\n         if let ExprBlock(ref else_block) = else_expr.node {\n-            if is_block_equal(cx, &then_block, &else_block, false) {\n+            if SpanlessEq::new(cx).eq_block(&then_block, &else_block) {\n                 span_lint(cx, IF_SAME_THEN_ELSE, expr.span, \"this if has the same then and else blocks\");\n             }\n         }\n@@ -75,7 +76,7 @@ fn lint_same_cond(cx: &LateContext, expr: &Expr) {\n \n     for (n, i) in conds.iter().enumerate() {\n         for j in conds.iter().skip(n+1) {\n-            if is_exp_equal(cx, i, j, true) {\n+            if SpanlessEq::new(cx).ignore_fn().eq_expr(i, j) {\n                 span_note_and_lint(cx, IFS_SAME_COND, j.span, \"this if has the same condition as a previous if\", i.span, \"same as this\");\n             }\n         }"}, {"sha": "c2f2e956e5e46b55d8f5040e24f8b87423ef4b13", "filename": "src/entry.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fentry.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -1,8 +1,9 @@\n use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Span;\n-use utils::{get_item_name, is_exp_equal, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n+use utils::SpanlessEq;\n use utils::{BTREEMAP_PATH, HASHMAP_PATH};\n+use utils::{get_item_name, match_type, snippet, span_lint_and_then, walk_ptrs_ty};\n \n /// **What it does:** This lint checks for uses of `contains_key` + `insert` on `HashMap` or\n /// `BTreeMap`.\n@@ -89,7 +90,7 @@ fn check_for_insert(cx: &LateContext, span: Span, map: &Expr, key: &Expr, expr:\n             params.len() == 3,\n             name.node.as_str() == \"insert\",\n             get_item_name(cx, map) == get_item_name(cx, &*params[0]),\n-            is_exp_equal(cx, key, &params[1], false)\n+            SpanlessEq::new(cx).eq_expr(key, &params[1])\n         ], {\n             let help = if sole_expr {\n                 format!(\"{}.entry({}).or_insert({})\","}, {"sha": "fc1cab2cd71460f3f07460291ade54a3672c63c4", "filename": "src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feq_op.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use rustc_front::util as ast_util;\n \n-use utils::{is_exp_equal, span_lint};\n+use utils::{SpanlessEq, span_lint};\n \n /// **What it does:** This lint checks for equal operands to comparison, logical and bitwise,\n /// difference and division binary operators (`==`, `>`, etc., `&&`, `||`, `&`, `|`, `^`, `-` and\n@@ -31,7 +31,7 @@ impl LintPass for EqOp {\n impl LateLintPass for EqOp {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n-            if is_valid_operator(op) && is_exp_equal(cx, left, right, true) {\n+            if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,\n                           EQ_OP,\n                           e.span,"}, {"sha": "40d137101a68591aee66b8e51e307d4c21e908f2", "filename": "src/strings.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstrings.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -7,7 +7,8 @@ use rustc::lint::*;\n use rustc_front::hir::*;\n use syntax::codemap::Spanned;\n \n-use utils::{is_exp_equal, match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::{match_type, span_lint, walk_ptrs_ty, get_parent_expr};\n+use utils::SpanlessEq;\n use utils::STRING_PATH;\n \n /// **What it does:** This lint matches code of the form `x = x + y` (without `let`!).\n@@ -84,7 +85,7 @@ impl LateLintPass for StringAdd {\n                     if let Some(ref p) = parent {\n                         if let ExprAssign(ref target, _) = p.node {\n                             // avoid duplicate matches\n-                            if is_exp_equal(cx, target, left, false) {\n+                            if SpanlessEq::new(cx).eq_expr(target, left) {\n                                 return;\n                             }\n                         }\n@@ -113,7 +114,7 @@ fn is_string(cx: &LateContext, e: &Expr) -> bool {\n \n fn is_add(cx: &LateContext, src: &Expr, target: &Expr) -> bool {\n     match src.node {\n-        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => is_exp_equal(cx, target, left, false),\n+        ExprBinary(Spanned{ node: BiAdd, .. }, ref left, _) => SpanlessEq::new(cx).eq_expr(target, left),\n         ExprBlock(ref block) => {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |expr| is_add(cx, expr, target))\n         }"}, {"sha": "95356772e608c6f906f437fdc956f2a7fed7702b", "filename": "src/utils/hir.rs", "status": "added", "additions": 239, "deletions": 0, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fhir.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -0,0 +1,239 @@\n+use consts::constant;\n+use rustc::lint::*;\n+use rustc_front::hir::*;\n+use syntax::ptr::P;\n+\n+/// Type used to check whether two ast are the same. This is different from the operator\n+/// `==` on ast types as this operator would compare true equality with ID and span.\n+///\n+/// Note that some expressions kinds are not considered but could be added.\n+pub struct SpanlessEq<'a, 'tcx: 'a> {\n+    /// Context used to evaluate constant expressions.\n+    cx: &'a LateContext<'a, 'tcx>,\n+    /// If is true, never consider as equal expressions containing fonction calls.\n+    ignore_fn: bool,\n+}\n+\n+impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n+    pub fn new(cx: &'a LateContext<'a, 'tcx>) -> Self {\n+        SpanlessEq { cx: cx, ignore_fn: false }\n+    }\n+\n+    pub fn ignore_fn(self) -> Self {\n+        SpanlessEq { cx: self.cx, ignore_fn: true }\n+    }\n+\n+    /// Check whether two statements are the same.\n+    pub fn eq_stmt(&self, left: &Stmt, right: &Stmt) -> bool {\n+        match (&left.node, &right.node) {\n+            (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n+                if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n+                    // TODO: tys\n+                    l.ty.is_none() && r.ty.is_none() &&\n+                        both(&l.init, &r.init, |l, r| self.eq_expr(l, r))\n+                }\n+                else {\n+                    false\n+                }\n+            }\n+            (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => self.eq_expr(l, r),\n+            (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => self.eq_expr(l, r),\n+            _ => false,\n+        }\n+    }\n+\n+    /// Check whether two blocks are the same.\n+    pub fn eq_block(&self, left: &Block, right: &Block) -> bool {\n+        over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r)) &&\n+            both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n+    }\n+\n+    // ok, it\u2019s a big function, but mostly one big match with simples cases\n+    #[allow(cyclomatic_complexity)]\n+    pub fn eq_expr(&self, left: &Expr, right: &Expr) -> bool {\n+        if let (Some(l), Some(r)) = (constant(self.cx, left), constant(self.cx, right)) {\n+            if l == r {\n+                return true;\n+            }\n+        }\n+\n+        match (&left.node, &right.node) {\n+            (&ExprAddrOf(ref lmut, ref le), &ExprAddrOf(ref rmut, ref re)) => {\n+                lmut == rmut && self.eq_expr(le, re)\n+            }\n+            (&ExprAgain(li), &ExprAgain(ri)) => {\n+                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+            }\n+            (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n+                self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n+                lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n+                self.eq_block(l, r)\n+            }\n+            (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n+                lop.node == rop.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+            }\n+            (&ExprBreak(li), &ExprBreak(ri)) => {\n+                both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n+            }\n+            (&ExprBox(ref l), &ExprBox(ref r)) => {\n+                self.eq_expr(l, r)\n+            }\n+            (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n+                !self.ignore_fn &&\n+                    self.eq_expr(lfun, rfun) &&\n+                    self.eq_exprs(largs, rargs)\n+            }\n+            (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n+                self.eq_expr(lx, rx) && self.eq_ty(lt, rt)\n+            }\n+            (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n+                lfident.node == rfident.node && self.eq_expr(lfexp, rfexp)\n+            }\n+            (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n+                self.eq_expr(la, ra) && self.eq_expr(li, ri)\n+            }\n+            (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n+                self.eq_expr(lc, rc) &&\n+                    self.eq_block(lt, rt) &&\n+                    both(le, re, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n+            (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n+                ls == rs &&\n+                    self.eq_expr(le, re) &&\n+                    over(la, ra, |l, r| {\n+                        self.eq_expr(&l.body, &r.body) &&\n+                            both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                            over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n+                    })\n+            }\n+            (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n+                // TODO: tys\n+                !self.ignore_fn &&\n+                    lname.node == rname.node &&\n+                    ltys.is_empty() &&\n+                    rtys.is_empty() &&\n+                    self.eq_exprs(largs, rargs)\n+            }\n+            (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n+                both(lb, rb, |l, r| self.eq_expr(l, r)) &&\n+                both(le, re, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n+                self.eq_expr(le, re) && self.eq_expr(ll, rl)\n+            }\n+            (&ExprRet(ref l), &ExprRet(ref r)) => {\n+                both(l, r, |l, r| self.eq_expr(l, r))\n+            }\n+            (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n+                both(lqself, rqself, |l, r| self.eq_qself(l, r)) && self.eq_path(lsubpath, rsubpath)\n+            }\n+            (&ExprTup(ref ltup), &ExprTup(ref rtup)) => self.eq_exprs(ltup, rtup),\n+            (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n+                li.node == ri.node && self.eq_expr(le, re)\n+            }\n+            (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n+                lop == rop && self.eq_expr(le, re)\n+            }\n+            (&ExprVec(ref l), &ExprVec(ref r)) => self.eq_exprs(l, r),\n+            (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n+                self.eq_expr(lc, rc) &&\n+                    self.eq_block(lb, rb) &&\n+                    both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n+            }\n+            _ => false,\n+        }\n+    }\n+\n+    fn eq_exprs(&self, left: &[P<Expr>], right: &[P<Expr>]) -> bool {\n+        over(left, right, |l, r| self.eq_expr(l, r))\n+    }\n+\n+    /// Check whether two patterns are the same.\n+    pub fn eq_pat(&self, left: &Pat, right: &Pat) -> bool {\n+        match (&left.node, &right.node) {\n+            (&PatBox(ref l), &PatBox(ref r)) => {\n+                self.eq_pat(l, r)\n+            }\n+            (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n+                self.eq_path(lp, rp) &&\n+                    both(la, ra, |l, r| {\n+                        over(l, r, |l, r| self.eq_pat(l, r))\n+                    })\n+            }\n+            (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n+                lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n+                    both(lp, rp, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatLit(ref l), &PatLit(ref r)) => {\n+                self.eq_expr(l, r)\n+            }\n+            (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n+                self.eq_qself(ls, rs) && self.eq_path(lp, rp)\n+            }\n+            (&PatTup(ref l), &PatTup(ref r)) => {\n+                over(l, r, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n+                self.eq_expr(ls, rs) &&\n+                    self.eq_expr(le, re)\n+            }\n+            (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n+                lm == rm && self.eq_pat(le, re)\n+            }\n+            (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n+                over(ls, rs, |l, r| self.eq_pat(l, r)) &&\n+                    over(le, re, |l, r| self.eq_pat(l, r)) &&\n+                    both(li, ri, |l, r| self.eq_pat(l, r))\n+            }\n+            (&PatWild, &PatWild) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn eq_path(&self, left: &Path, right: &Path) -> bool {\n+        // The == of idents doesn't work with different contexts,\n+        // we have to be explicit about hygiene\n+        left.global == right.global &&\n+        over(&left.segments,\n+             &right.segments,\n+             |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n+    }\n+\n+    fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n+        left.ty.node == right.ty.node && left.position == right.position\n+    }\n+\n+    fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n+        match (&left.node, &right.node) {\n+            (&TyVec(ref lvec), &TyVec(ref rvec)) => self.eq_ty(lvec, rvec),\n+            (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && self.eq_ty(&*lmut.ty, &*rmut.ty),\n+            (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n+                lrmut.mutbl == rrmut.mutbl && self.eq_ty(&*lrmut.ty, &*rrmut.ty)\n+            }\n+            (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n+                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(lpath, rpath)\n+            }\n+            (&TyInfer, &TyInfer) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n+fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n+}\n+\n+/// Check if two slices are equal as per `eq_fn`.\n+fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n+    where F: FnMut(&X, &X) -> bool\n+{\n+    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n+}"}, {"sha": "d666ee36bcefa6e45ba84bcb38153bba79f39745", "filename": "src/utils/mod.rs", "status": "renamed", "additions": 2, "deletions": 225, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292/src%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils%2Fmod.rs?ref=91c16fc8e605ddb7f0b4f967bd7fbf62ccd6a292", "patch": "@@ -1,4 +1,3 @@\n-use consts::constant;\n use reexport::*;\n use rustc::front::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n@@ -16,6 +15,8 @@ use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+mod hir;\n+pub use self::hir::SpanlessEq;\n pub type MethodArgs = HirVec<P<Expr>>;\n \n // module DefPaths for certain structs/enums we check for\n@@ -591,230 +592,6 @@ fn parse_attrs<F: FnMut(u64)>(sess: &Session, attrs: &[ast::Attribute], name: &'\n     }\n }\n \n-/// Check whether two statements are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_stmt_equal(cx: &LateContext, left: &Stmt, right: &Stmt, ignore_fn: bool) -> bool {\n-    match (&left.node, &right.node) {\n-        (&StmtDecl(ref l, _), &StmtDecl(ref r, _)) => {\n-            if let (&DeclLocal(ref l), &DeclLocal(ref r)) = (&l.node, &r.node) {\n-                // TODO: tys\n-                l.ty.is_none() && r.ty.is_none() &&\n-                    both(&l.init, &r.init, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-            }\n-            else {\n-                false\n-            }\n-        }\n-        (&StmtExpr(ref l, _), &StmtExpr(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n-        (&StmtSemi(ref l, _), &StmtSemi(ref r, _)) => is_exp_equal(cx, l, r, ignore_fn),\n-        _ => false,\n-    }\n-}\n-\n-/// Check whether two blocks are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_block_equal(cx: &LateContext, left: &Block, right: &Block, ignore_fn: bool) -> bool {\n-    over(&left.stmts, &right.stmts, |l, r| is_stmt_equal(cx, l, r, ignore_fn)) &&\n-        both(&left.expr, &right.expr, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-}\n-\n-/// Check whether two pattern are the same.\n-/// See also `is_exp_equal`.\n-pub fn is_pat_equal(cx: &LateContext, left: &Pat, right: &Pat, ignore_fn: bool) -> bool {\n-    match (&left.node, &right.node) {\n-        (&PatBox(ref l), &PatBox(ref r)) => {\n-            is_pat_equal(cx, l, r, ignore_fn)\n-        }\n-        (&PatEnum(ref lp, ref la), &PatEnum(ref rp, ref ra)) => {\n-            is_path_equal(lp, rp) &&\n-                both(la, ra, |l, r| {\n-                    over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-                })\n-        }\n-        (&PatIdent(ref lb, ref li, ref lp), &PatIdent(ref rb, ref ri, ref rp)) => {\n-            lb == rb && li.node.name.as_str() == ri.node.name.as_str() &&\n-                both(lp, rp, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatLit(ref l), &PatLit(ref r)) => {\n-            is_exp_equal(cx, l, r, ignore_fn)\n-        }\n-        (&PatQPath(ref ls, ref lp), &PatQPath(ref rs, ref rp)) => {\n-            is_qself_equal(ls, rs) && is_path_equal(lp, rp)\n-        }\n-        (&PatTup(ref l), &PatTup(ref r)) => {\n-            over(l, r, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatRange(ref ls, ref le), &PatRange(ref rs, ref re)) => {\n-            is_exp_equal(cx, ls, rs, ignore_fn) &&\n-                is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&PatRegion(ref le, ref lm), &PatRegion(ref re, ref rm)) => {\n-            lm == rm && is_pat_equal(cx, le, re, ignore_fn)\n-        }\n-        (&PatVec(ref ls, ref li, ref le), &PatVec(ref rs, ref ri, ref re)) => {\n-            over(ls, rs, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n-                over(le, re, |l, r| is_pat_equal(cx, l, r, ignore_fn)) &&\n-                both(li, ri, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-        }\n-        (&PatWild, &PatWild) => true,\n-        _ => false,\n-    }\n-}\n-\n-/// Check whether two expressions are the same. This is different from the operator `==` on\n-/// expression as this operator would compare true equality with ID and span.\n-/// If `ignore_fn` is true, never consider as equal fonction calls.\n-///\n-/// Note that some expression kinds are not considered but could be added.\n-#[allow(cyclomatic_complexity)] // ok, it\u2019s a big function, but mostly one big match with simples cases\n-pub fn is_exp_equal(cx: &LateContext, left: &Expr, right: &Expr, ignore_fn: bool) -> bool {\n-    if let (Some(l), Some(r)) = (constant(cx, left), constant(cx, right)) {\n-        if l == r {\n-            return true;\n-        }\n-    }\n-\n-    match (&left.node, &right.node) {\n-        (&ExprAddrOf(ref lmut, ref le), &ExprAddrOf(ref rmut, ref re)) => {\n-            lmut == rmut && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprAgain(li), &ExprAgain(ri)) => {\n-            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-        }\n-        (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => {\n-            is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n-            lo.node == ro.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprBlock(ref l), &ExprBlock(ref r)) => {\n-            is_block_equal(cx, l, r, ignore_fn)\n-        }\n-        (&ExprBinary(lop, ref ll, ref lr), &ExprBinary(rop, ref rl, ref rr)) => {\n-            lop.node == rop.node && is_exp_equal(cx, ll, rl, ignore_fn) && is_exp_equal(cx, lr, rr, ignore_fn)\n-        }\n-        (&ExprBreak(li), &ExprBreak(ri)) => {\n-            both(&li, &ri, |l, r| l.node.name.as_str() == r.node.name.as_str())\n-        }\n-        (&ExprBox(ref l), &ExprBox(ref r)) => {\n-            is_exp_equal(cx, l, r, ignore_fn)\n-        }\n-        (&ExprCall(ref lfun, ref largs), &ExprCall(ref rfun, ref rargs)) => {\n-            !ignore_fn &&\n-                is_exp_equal(cx, lfun, rfun, ignore_fn) &&\n-                is_exps_equal(cx, largs, rargs, ignore_fn)\n-        }\n-        (&ExprCast(ref lx, ref lt), &ExprCast(ref rx, ref rt)) => {\n-            is_exp_equal(cx, lx, rx, ignore_fn) && is_cast_ty_equal(lt, rt)\n-        }\n-        (&ExprField(ref lfexp, ref lfident), &ExprField(ref rfexp, ref rfident)) => {\n-            lfident.node == rfident.node && is_exp_equal(cx, lfexp, rfexp, ignore_fn)\n-        }\n-        (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n-            is_exp_equal(cx, la, ra, ignore_fn) && is_exp_equal(cx, li, ri, ignore_fn)\n-        }\n-        (&ExprIf(ref lc, ref lt, ref le), &ExprIf(ref rc, ref rt, ref re)) => {\n-            is_exp_equal(cx, lc, rc, ignore_fn) &&\n-                is_block_equal(cx, lt, rt, ignore_fn) &&\n-                both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprIndex(ref la, ref li), &ExprIndex(ref ra, ref ri)) => {\n-            is_exp_equal(cx, la, ra) && is_exp_equal(cx, li, ri)\n-        }\n-        (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n-        (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n-            ls == rs &&\n-                is_exp_equal(cx, le, re, ignore_fn) &&\n-                over(la, ra, |l, r| {\n-                    is_exp_equal(cx, &l.body, &r.body, ignore_fn) &&\n-                        both(&l.guard, &r.guard, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n-                        over(&l.pats, &r.pats, |l, r| is_pat_equal(cx, l, r, ignore_fn))\n-                })\n-        }\n-        (&ExprMethodCall(ref lname, ref ltys, ref largs), &ExprMethodCall(ref rname, ref rtys, ref rargs)) => {\n-            // TODO: tys\n-            !ignore_fn &&\n-                lname.node == rname.node &&\n-                ltys.is_empty() &&\n-                rtys.is_empty() &&\n-                is_exps_equal(cx, largs, rargs, ignore_fn)\n-        }\n-        (&ExprRange(ref lb, ref le), &ExprRange(ref rb, ref re)) => {\n-            both(lb, rb, |l, r| is_exp_equal(cx, l, r, ignore_fn)) &&\n-            both(le, re, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => {\n-            is_exp_equal(cx, le, re, ignore_fn) && is_exp_equal(cx, ll, rl, ignore_fn)\n-        }\n-        (&ExprRet(ref l), &ExprRet(ref r)) => {\n-            both(l, r, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-        }\n-        (&ExprPath(ref lqself, ref lsubpath), &ExprPath(ref rqself, ref rsubpath)) => {\n-            both(lqself, rqself, is_qself_equal) && is_path_equal(lsubpath, rsubpath)\n-        }\n-        (&ExprTup(ref ltup), &ExprTup(ref rtup)) => is_exps_equal(cx, ltup, rtup, ignore_fn),\n-        (&ExprTupField(ref le, li), &ExprTupField(ref re, ri)) => {\n-            li.node == ri.node && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprUnary(lop, ref le), &ExprUnary(rop, ref re)) => {\n-            lop == rop && is_exp_equal(cx, le, re, ignore_fn)\n-        }\n-        (&ExprVec(ref l), &ExprVec(ref r)) => is_exps_equal(cx, l, r, ignore_fn),\n-        (&ExprWhile(ref lc, ref lb, ref ll), &ExprWhile(ref rc, ref rb, ref rl)) => {\n-            is_exp_equal(cx, lc, rc, ignore_fn) &&\n-                is_block_equal(cx, lb, rb, ignore_fn) &&\n-                both(ll, rl, |l, r| l.name.as_str() == r.name.as_str())\n-        }\n-        _ => false,\n-    }\n-}\n-\n-fn is_exps_equal(cx: &LateContext, left: &[P<Expr>], right: &[P<Expr>], ignore_fn: bool) -> bool {\n-    over(left, right, |l, r| is_exp_equal(cx, l, r, ignore_fn))\n-}\n-\n-fn is_path_equal(left: &Path, right: &Path) -> bool {\n-    // The == of idents doesn't work with different contexts,\n-    // we have to be explicit about hygiene\n-    left.global == right.global &&\n-    over(&left.segments,\n-         &right.segments,\n-         |l, r| l.identifier.name.as_str() == r.identifier.name.as_str() && l.parameters == r.parameters)\n-}\n-\n-fn is_qself_equal(left: &QSelf, right: &QSelf) -> bool {\n-    left.ty.node == right.ty.node && left.position == right.position\n-}\n-\n-/// Check if two slices are equal as per `eq_fn`.\n-pub fn over<X, F>(left: &[X], right: &[X], mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n-{\n-    left.len() == right.len() && left.iter().zip(right).all(|(x, y)| eq_fn(x, y))\n-}\n-\n-/// Check if the two `Option`s are both `None` or some equal values as per `eq_fn`.\n-pub fn both<X, F>(l: &Option<X>, r: &Option<X>, mut eq_fn: F) -> bool\n-    where F: FnMut(&X, &X) -> bool\n-{\n-    l.as_ref().map_or_else(|| r.is_none(), |x| r.as_ref().map_or(false, |y| eq_fn(x, y)))\n-}\n-\n-fn is_cast_ty_equal(left: &Ty, right: &Ty) -> bool {\n-    match (&left.node, &right.node) {\n-        (&TyVec(ref lvec), &TyVec(ref rvec)) => is_cast_ty_equal(lvec, rvec),\n-        (&TyPtr(ref lmut), &TyPtr(ref rmut)) => lmut.mutbl == rmut.mutbl && is_cast_ty_equal(&*lmut.ty, &*rmut.ty),\n-        (&TyRptr(_, ref lrmut), &TyRptr(_, ref rrmut)) => {\n-            lrmut.mutbl == rrmut.mutbl && is_cast_ty_equal(&*lrmut.ty, &*rrmut.ty)\n-        }\n-        (&TyPath(ref lq, ref lpath), &TyPath(ref rq, ref rpath)) => {\n-            both(lq, rq, is_qself_equal) && is_path_equal(lpath, rpath)\n-        }\n-        (&TyInfer, &TyInfer) => true,\n-        _ => false,\n-    }\n-}\n-\n /// Return the pre-expansion span if is this comes from an expansion of the macro `name`.\n pub fn is_expn_of(cx: &LateContext, mut span: Span, name: &str) -> Option<Span> {\n     loop {", "previous_filename": "src/utils.rs"}]}