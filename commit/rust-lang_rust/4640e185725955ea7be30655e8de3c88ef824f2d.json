{"sha": "4640e185725955ea7be30655e8de3c88ef824f2d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2NDBlMTg1NzI1OTU1ZWE3YmUzMDY1NWU4ZGUzYzg4ZWY4MjRmMmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T21:44:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-17T21:44:08Z"}, "message": "Auto merge of #41911 - michaelwoerister:querify_trait_def, r=nikomatsakis\n\nRemove interior mutability from TraitDef by turning fields into queries\n\nThis PR gets rid of anything `std::cell` in `TraitDef` by\n- moving the global list of trait impls from `TraitDef` into a query,\n- moving the list of trait impls relevent for some self-type from `TraitDef` into a query\n- moving the specialization graph of trait impls into a query, and\n- moving `TraitDef::object_safety` into a query.\n\nI really like how querifying things not only helps with incremental compilation and on-demand, but also just plain makes the code cleaner `:)`\n\nThere are also some smaller fixes in the PR. Commits can be reviewed separately.\n\nr? @eddyb or @nikomatsakis", "tree": {"sha": "9ac769e2c05b8f8dc833f59fcb8a3c689dc65b6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ac769e2c05b8f8dc833f59fcb8a3c689dc65b6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4640e185725955ea7be30655e8de3c88ef824f2d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4640e185725955ea7be30655e8de3c88ef824f2d", "html_url": "https://github.com/rust-lang/rust/commit/4640e185725955ea7be30655e8de3c88ef824f2d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4640e185725955ea7be30655e8de3c88ef824f2d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b5c3d2b208f47b0750ea6c39f6f3f97cb1ca1bb", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b5c3d2b208f47b0750ea6c39f6f3f97cb1ca1bb", "html_url": "https://github.com/rust-lang/rust/commit/7b5c3d2b208f47b0750ea6c39f6f3f97cb1ca1bb"}, {"sha": "08660afe90d6c2257c59408116c718929af58963", "url": "https://api.github.com/repos/rust-lang/rust/commits/08660afe90d6c2257c59408116c718929af58963", "html_url": "https://github.com/rust-lang/rust/commit/08660afe90d6c2257c59408116c718929af58963"}], "stats": {"total": 1265, "additions": 678, "deletions": 587}, "files": [{"sha": "15c4469b74694c98d3108c0002a9840329f6b53f", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -106,6 +106,8 @@ pub enum DepNode<D: Clone + Debug> {\n     UsedTraitImports(D),\n     ConstEval(D),\n     SymbolName(D),\n+    SpecializationGraph(D),\n+    ObjectSafety(D),\n \n     // The set of impls for a given trait. Ultimately, it would be\n     // nice to get more fine-grained here (e.g., to include a\n@@ -116,6 +118,8 @@ pub enum DepNode<D: Clone + Debug> {\n     // than changes in the impl body.\n     TraitImpls(D),\n \n+    AllLocalTraitImpls,\n+\n     // Nodes representing caches. To properly handle a true cache, we\n     // don't use a DepTrackingMap, but rather we push a task node.\n     // Otherwise the write into the map would be incorrectly\n@@ -262,7 +266,10 @@ impl<D: Clone + Debug> DepNode<D> {\n             UsedTraitImports(ref d) => op(d).map(UsedTraitImports),\n             ConstEval(ref d) => op(d).map(ConstEval),\n             SymbolName(ref d) => op(d).map(SymbolName),\n+            SpecializationGraph(ref d) => op(d).map(SpecializationGraph),\n+            ObjectSafety(ref d) => op(d).map(ObjectSafety),\n             TraitImpls(ref d) => op(d).map(TraitImpls),\n+            AllLocalTraitImpls => Some(AllLocalTraitImpls),\n             TraitItems(ref d) => op(d).map(TraitItems),\n             ReprHints(ref d) => op(d).map(ReprHints),\n             TraitSelect { ref trait_def_id, ref input_def_id } => {"}, {"sha": "470dcb4bd61e10e431bf8e3392e3734c288081c7", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -409,6 +409,67 @@ RFC. It is, however, [currently unimplemented][iss15872].\n [iss15872]: https://github.com/rust-lang/rust/issues/15872\n \"##,\n \n+E0119: r##\"\n+There are conflicting trait implementations for the same type.\n+Example of erroneous code:\n+\n+```compile_fail,E0119\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo {\n+    value: usize\n+}\n+\n+impl MyTrait for Foo { // error: conflicting implementations of trait\n+                       //        `MyTrait` for type `Foo`\n+    fn get(&self) -> usize { self.value }\n+}\n+```\n+\n+When looking for the implementation for the trait, the compiler finds\n+both the `impl<T> MyTrait for T` where T is all types and the `impl\n+MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n+this is an error. So, when you write:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+```\n+\n+This makes the trait implemented on all types in the scope. So if you\n+try to implement it on another one after that, the implementations will\n+conflict. Example:\n+\n+```\n+trait MyTrait {\n+    fn get(&self) -> usize;\n+}\n+\n+impl<T> MyTrait for T {\n+    fn get(&self) -> usize { 0 }\n+}\n+\n+struct Foo;\n+\n+fn main() {\n+    let f = Foo;\n+\n+    f.get(); // the trait is implemented so we can use it\n+}\n+```\n+\"##,\n+\n E0133: r##\"\n Unsafe code was used outside of an unsafe function or block.\n "}, {"sha": "868730edfedda83b1d4d10ef586ca3f37b75dc58", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -497,15 +497,15 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn trait_impls(&self, trait_did: DefId) -> &'hir [NodeId] {\n-        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here\n         self.forest.krate.trait_impls.get(&trait_did).map_or(&[], |xs| &xs[..])\n     }\n \n     pub fn trait_default_impl(&self, trait_did: DefId) -> Option<NodeId> {\n-        self.dep_graph.read(DepNode::TraitImpls(trait_did));\n+        self.dep_graph.read(DepNode::AllLocalTraitImpls);\n \n         // NB: intentionally bypass `self.forest.krate()` so that we\n         // do not trigger a read of the whole krate here"}, {"sha": "ccdbab88b8b9c17e9e9916804d194c2d953392ae", "filename": "src/librustc/ich/fingerprint.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Ffingerprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Ffingerprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Ffingerprint.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -94,3 +94,11 @@ impl stable_hasher::StableHasherResult for Fingerprint {\n         fingerprint\n     }\n }\n+\n+impl<CTX> stable_hasher::HashStable<CTX> for Fingerprint {\n+    fn hash_stable<W: stable_hasher::StableHasherResult>(&self,\n+                                          _: &mut CTX,\n+                                          hasher: &mut stable_hasher::StableHasher<W>) {\n+        ::std::hash::Hash::hash(&self.0, hasher);\n+    }\n+}"}, {"sha": "786d1c5035d96fa388278aa906c362e2c6467ffa", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -16,7 +16,7 @@ use ty;\n use util::nodemap::NodeMap;\n \n use std::hash as std_hash;\n-use std::collections::{HashMap, HashSet};\n+use std::collections::{HashMap, HashSet, BTreeMap};\n \n use syntax::ast;\n use syntax::attr;\n@@ -348,3 +348,25 @@ pub fn hash_stable_nodemap<'a, 'tcx, V, W>(hcx: &mut StableHashingContext<'a, 't\n         hcx.tcx.hir.definitions().node_to_hir_id(*node_id).local_id\n     });\n }\n+\n+\n+pub fn hash_stable_btreemap<'a, 'tcx, K, V, SK, F, W>(hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                                      hasher: &mut StableHasher<W>,\n+                                                      map: &BTreeMap<K, V>,\n+                                                      extract_stable_key: F)\n+    where K: Eq + Ord,\n+          V: HashStable<StableHashingContext<'a, 'tcx>>,\n+          SK: HashStable<StableHashingContext<'a, 'tcx>> + Ord + Clone,\n+          F: Fn(&mut StableHashingContext<'a, 'tcx>, &K) -> SK,\n+          W: StableHasherResult,\n+{\n+    let mut keys: Vec<_> = map.keys()\n+                              .map(|k| (extract_stable_key(hcx, k), k))\n+                              .collect();\n+    keys.sort_unstable_by_key(|&(ref stable_key, _)| stable_key.clone());\n+    keys.len().hash_stable(hcx, hasher);\n+    for (stable_key, key) in keys {\n+        stable_key.hash_stable(hcx, hasher);\n+        map[key].hash_stable(hcx, hasher);\n+    }\n+}"}, {"sha": "5b23809085053d09b2cf6a821a25140dc9315602", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -13,7 +13,8 @@\n pub use self::fingerprint::Fingerprint;\n pub use self::caching_codemap_view::CachingCodemapView;\n pub use self::hcx::{StableHashingContext, NodeIdHashingMode, hash_stable_hashmap,\n-                    hash_stable_hashset, hash_stable_nodemap};\n+                    hash_stable_hashset, hash_stable_nodemap,\n+                    hash_stable_btreemap};\n mod fingerprint;\n mod caching_codemap_view;\n mod hcx;"}, {"sha": "1823373348badfb8ef177602d852f4ed29ff0217", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -619,8 +619,6 @@ pub fn get_vtable_methods<'a, 'tcx>(\n     debug!(\"get_vtable_methods({:?})\", trait_ref);\n \n     supertraits(tcx, trait_ref).flat_map(move |trait_ref| {\n-        tcx.populate_implementations_for_trait_if_necessary(trait_ref.def_id());\n-\n         let trait_methods = tcx.associated_items(trait_ref.def_id())\n             .filter(|item| item.kind == ty::AssociatedKind::Method);\n \n@@ -782,3 +780,19 @@ impl<'tcx> TraitObligation<'tcx> {\n         ty::Binder(self.predicate.skip_binder().self_ty())\n     }\n }\n+\n+pub fn provide(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}\n+\n+pub fn provide_extern(providers: &mut ty::maps::Providers) {\n+    *providers = ty::maps::Providers {\n+        is_object_safe: object_safety::is_object_safe_provider,\n+        specialization_graph_of: specialize::specialization_graph_provider,\n+        ..*providers\n+    };\n+}"}, {"sha": "0e3a53129d157fe2af455cacd25a59597c87b22f", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -77,25 +77,6 @@ pub enum MethodViolationCode {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n-    pub fn is_object_safe(self, trait_def_id: DefId) -> bool {\n-        // Because we query yes/no results frequently, we keep a cache:\n-        let def = self.trait_def(trait_def_id);\n-\n-        let result = def.object_safety().unwrap_or_else(|| {\n-            let result = self.object_safety_violations(trait_def_id).is_empty();\n-\n-            // Record just a yes/no result in the cache; this is what is\n-            // queried most frequently. Note that this may overwrite a\n-            // previous result, but always with the same thing.\n-            def.set_object_safety(result);\n-\n-            result\n-        });\n-\n-        debug!(\"is_object_safe({:?}) = {}\", trait_def_id, result);\n-\n-        result\n-    }\n \n     /// Returns the object safety violations that affect\n     /// astconv - currently, Self in supertraits. This is needed\n@@ -391,3 +372,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         error\n     }\n }\n+\n+pub(super) fn is_object_safe_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                         trait_def_id: DefId)\n+                                         -> bool {\n+    tcx.object_safety_violations(trait_def_id).is_empty()\n+}"}, {"sha": "d7911870f391a541dfd36297c3437999350603b1", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 89, "deletions": 129, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -900,96 +900,50 @@ fn assemble_candidates_from_impls<'cx, 'gcx, 'tcx>(\n                 // In either case, we handle this by not adding a\n                 // candidate for an impl if it contains a `default`\n                 // type.\n-                let opt_node_item = assoc_ty_def(selcx,\n-                                                 impl_data.impl_def_id,\n-                                                 obligation.predicate.item_name);\n-                let new_candidate = if let Some(node_item) = opt_node_item {\n-                    let is_default = if node_item.node.is_from_trait() {\n-                        // If true, the impl inherited a `type Foo = Bar`\n-                        // given in the trait, which is implicitly default.\n-                        // Otherwise, the impl did not specify `type` and\n-                        // neither did the trait:\n-                        //\n-                        // ```rust\n-                        // trait Foo { type T; }\n-                        // impl Foo for Bar { }\n-                        // ```\n-                        //\n-                        // This is an error, but it will be\n-                        // reported in `check_impl_items_against_trait`.\n-                        // We accept it here but will flag it as\n-                        // an error when we confirm the candidate\n-                        // (which will ultimately lead to `normalize_to_error`\n-                        // being invoked).\n-                        node_item.item.defaultness.has_value()\n-                    } else {\n-                        node_item.item.defaultness.is_default() ||\n-                        selcx.tcx().impl_is_default(node_item.node.def_id())\n-                    };\n-\n-                    // Only reveal a specializable default if we're past type-checking\n-                    // and the obligations is monomorphic, otherwise passes such as\n-                    // transmute checking and polymorphic MIR optimizations could\n-                    // get a result which isn't correct for all monomorphizations.\n-                    if !is_default {\n+                let node_item = assoc_ty_def(selcx,\n+                                             impl_data.impl_def_id,\n+                                             obligation.predicate.item_name);\n+\n+                let is_default = if node_item.node.is_from_trait() {\n+                    // If true, the impl inherited a `type Foo = Bar`\n+                    // given in the trait, which is implicitly default.\n+                    // Otherwise, the impl did not specify `type` and\n+                    // neither did the trait:\n+                    //\n+                    // ```rust\n+                    // trait Foo { type T; }\n+                    // impl Foo for Bar { }\n+                    // ```\n+                    //\n+                    // This is an error, but it will be\n+                    // reported in `check_impl_items_against_trait`.\n+                    // We accept it here but will flag it as\n+                    // an error when we confirm the candidate\n+                    // (which will ultimately lead to `normalize_to_error`\n+                    // being invoked).\n+                    node_item.item.defaultness.has_value()\n+                } else {\n+                    node_item.item.defaultness.is_default() ||\n+                    selcx.tcx().impl_is_default(node_item.node.def_id())\n+                };\n+\n+                // Only reveal a specializable default if we're past type-checking\n+                // and the obligations is monomorphic, otherwise passes such as\n+                // transmute checking and polymorphic MIR optimizations could\n+                // get a result which isn't correct for all monomorphizations.\n+                let new_candidate = if !is_default {\n+                    Some(ProjectionTyCandidate::Select)\n+                } else if selcx.projection_mode() == Reveal::All {\n+                    assert!(!poly_trait_ref.needs_infer());\n+                    if !poly_trait_ref.needs_subst() {\n                         Some(ProjectionTyCandidate::Select)\n-                    } else if selcx.projection_mode() == Reveal::All {\n-                        assert!(!poly_trait_ref.needs_infer());\n-                        if !poly_trait_ref.needs_subst() {\n-                            Some(ProjectionTyCandidate::Select)\n-                        } else {\n-                            None\n-                        }\n                     } else {\n                         None\n                     }\n                 } else {\n-                    // This is saying that neither the trait nor\n-                    // the impl contain a definition for this\n-                    // associated type.  Normally this situation\n-                    // could only arise through a compiler bug --\n-                    // if the user wrote a bad item name, it\n-                    // should have failed in astconv. **However**,\n-                    // at coherence-checking time, we only look at\n-                    // the topmost impl (we don't even consider\n-                    // the trait itself) for the definition -- and\n-                    // so in that case it may be that the trait\n-                    // *DOES* have a declaration, but we don't see\n-                    // it, and we end up in this branch.\n-                    //\n-                    // This is kind of tricky to handle actually.\n-                    // For now, we just unconditionally ICE,\n-                    // because otherwise, examples like the\n-                    // following will succeed:\n-                    //\n-                    // ```\n-                    // trait Assoc {\n-                    //     type Output;\n-                    // }\n-                    //\n-                    // impl<T> Assoc for T {\n-                    //     default type Output = bool;\n-                    // }\n-                    //\n-                    // impl Assoc for u8 {}\n-                    // impl Assoc for u16 {}\n-                    //\n-                    // trait Foo {}\n-                    // impl Foo for <u8 as Assoc>::Output {}\n-                    // impl Foo for <u16 as Assoc>::Output {}\n-                    //     return None;\n-                    // }\n-                    // ```\n-                    //\n-                    // The essential problem here is that the\n-                    // projection fails, leaving two unnormalized\n-                    // types, which appear not to unify -- so the\n-                    // overlap check succeeds, when it should\n-                    // fail.\n-                    span_bug!(obligation.cause.span,\n-                              \"Tried to project an inherited associated type during \\\n-                               coherence checking, which is currently not supported.\");\n+                    None\n                 };\n+\n                 candidate_set.vec.extend(new_candidate);\n             }\n             super::VtableParam(..) => {\n@@ -1274,35 +1228,25 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     let VtableImplData { substs, nested, impl_def_id } = impl_vtable;\n \n     let tcx = selcx.tcx();\n-    let trait_ref = obligation.predicate.trait_ref;\n     let assoc_ty = assoc_ty_def(selcx, impl_def_id, obligation.predicate.item_name);\n \n-    match assoc_ty {\n-        Some(node_item) => {\n-            let ty = if !node_item.item.defaultness.has_value() {\n-                // This means that the impl is missing a definition for the\n-                // associated type. This error will be reported by the type\n-                // checker method `check_impl_items_against_trait`, so here we\n-                // just return TyError.\n-                debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n-                       node_item.item.name,\n-                       obligation.predicate.trait_ref);\n-                tcx.types.err\n-            } else {\n-                tcx.type_of(node_item.item.def_id)\n-            };\n-            let substs = translate_substs(selcx.infcx(), impl_def_id, substs, node_item.node);\n-            Progress {\n-                ty: ty.subst(tcx, substs),\n-                obligations: nested,\n-                cacheable: true\n-            }\n-        }\n-        None => {\n-            span_bug!(obligation.cause.span,\n-                      \"No associated type for {:?}\",\n-                      trait_ref);\n-        }\n+    let ty = if !assoc_ty.item.defaultness.has_value() {\n+        // This means that the impl is missing a definition for the\n+        // associated type. This error will be reported by the type\n+        // checker method `check_impl_items_against_trait`, so here we\n+        // just return TyError.\n+        debug!(\"confirm_impl_candidate: no associated type {:?} for {:?}\",\n+               assoc_ty.item.name,\n+               obligation.predicate.trait_ref);\n+        tcx.types.err\n+    } else {\n+        tcx.type_of(assoc_ty.item.def_id)\n+    };\n+    let substs = translate_substs(selcx.infcx(), impl_def_id, substs, assoc_ty.node);\n+    Progress {\n+        ty: ty.subst(tcx, substs),\n+        obligations: nested,\n+        cacheable: true\n     }\n }\n \n@@ -1315,27 +1259,43 @@ fn assoc_ty_def<'cx, 'gcx, 'tcx>(\n     selcx: &SelectionContext<'cx, 'gcx, 'tcx>,\n     impl_def_id: DefId,\n     assoc_ty_name: ast::Name)\n-    -> Option<specialization_graph::NodeItem<ty::AssociatedItem>>\n+    -> specialization_graph::NodeItem<ty::AssociatedItem>\n {\n-    let trait_def_id = selcx.tcx().impl_trait_ref(impl_def_id).unwrap().def_id;\n-    let trait_def = selcx.tcx().trait_def(trait_def_id);\n-\n-    if !trait_def.is_complete(selcx.tcx()) {\n-        let impl_node = specialization_graph::Node::Impl(impl_def_id);\n-        for item in impl_node.items(selcx.tcx()) {\n-            if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n-                return Some(specialization_graph::NodeItem {\n-                    node: specialization_graph::Node::Impl(impl_def_id),\n-                    item: item,\n-                });\n-            }\n+    let tcx = selcx.tcx();\n+    let trait_def_id = tcx.impl_trait_ref(impl_def_id).unwrap().def_id;\n+    let trait_def = tcx.trait_def(trait_def_id);\n+\n+    // This function may be called while we are still building the\n+    // specialization graph that is queried below (via TraidDef::ancestors()),\n+    // so, in order to avoid unnecessary infinite recursion, we manually look\n+    // for the associated item at the given impl.\n+    // If there is no such item in that impl, this function will fail with a\n+    // cycle error if the specialization graph is currently being built.\n+    let impl_node = specialization_graph::Node::Impl(impl_def_id);\n+    for item in impl_node.items(tcx) {\n+        if item.kind == ty::AssociatedKind::Type && item.name == assoc_ty_name {\n+            return specialization_graph::NodeItem {\n+                node: specialization_graph::Node::Impl(impl_def_id),\n+                item: item,\n+            };\n         }\n-        None\n+    }\n+\n+    if let Some(assoc_item) = trait_def\n+        .ancestors(tcx, impl_def_id)\n+        .defs(tcx, assoc_ty_name, ty::AssociatedKind::Type)\n+        .next() {\n+        assoc_item\n     } else {\n-        trait_def\n-            .ancestors(impl_def_id)\n-            .defs(selcx.tcx(), assoc_ty_name, ty::AssociatedKind::Type)\n-            .next()\n+        // This is saying that neither the trait nor\n+        // the impl contain a definition for this\n+        // associated type.  Normally this situation\n+        // could only arise through a compiler bug --\n+        // if the user wrote a bad item name, it\n+        // should have failed in astconv.\n+        bug!(\"No associated type `{}` for {}\",\n+             assoc_ty_name,\n+             tcx.item_path_str(impl_def_id))\n     }\n }\n "}, {"sha": "0e5779f9d17935b291fc1d72aec74fd879166c0f", "filename": "src/librustc/traits/specialize/mod.rs", "status": "modified", "additions": 61, "deletions": 1, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -27,6 +27,7 @@ use ty::subst::{Subst, Substs};\n use traits::{self, Reveal, ObligationCause};\n use ty::{self, TyCtxt, TypeFoldable};\n use syntax_pos::DUMMY_SP;\n+use std::rc::Rc;\n \n pub mod specialization_graph;\n \n@@ -118,7 +119,7 @@ pub fn find_associated_item<'a, 'tcx>(\n     let trait_def_id = tcx.trait_id_of_impl(impl_data.impl_def_id).unwrap();\n     let trait_def = tcx.trait_def(trait_def_id);\n \n-    let ancestors = trait_def.ancestors(impl_data.impl_def_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_data.impl_def_id);\n     match ancestors.defs(tcx, item.name, item.kind).next() {\n         Some(node_item) => {\n             let substs = tcx.infer_ctxt((), Reveal::All).enter(|infcx| {\n@@ -285,3 +286,62 @@ impl SpecializesCache {\n         self.map.insert((a, b), result);\n     }\n }\n+\n+// Query provider for `specialization_graph_of`.\n+pub(super) fn specialization_graph_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                      trait_id: DefId)\n+                                                      -> Rc<specialization_graph::Graph> {\n+    let mut sg = specialization_graph::Graph::new();\n+\n+    let mut trait_impls: Vec<DefId> = tcx.trait_impls_of(trait_id).iter().collect();\n+\n+    // The coherence checking implementation seems to rely on impls being\n+    // iterated over (roughly) in definition order, so we are sorting by\n+    // negated CrateNum (so remote definitions are visited first) and then\n+    // by a flattend version of the DefIndex.\n+    trait_impls.sort_unstable_by_key(|def_id| {\n+        (-(def_id.krate.as_u32() as i64),\n+         def_id.index.address_space().index(),\n+         def_id.index.as_array_index())\n+    });\n+\n+    for impl_def_id in trait_impls {\n+        if impl_def_id.is_local() {\n+            // This is where impl overlap checking happens:\n+            let insert_result = sg.insert(tcx, impl_def_id);\n+            // Report error if there was one.\n+            if let Err(overlap) = insert_result {\n+                let mut err = struct_span_err!(tcx.sess,\n+                                               tcx.span_of_impl(impl_def_id).unwrap(),\n+                                               E0119,\n+                                               \"conflicting implementations of trait `{}`{}:\",\n+                                               overlap.trait_desc,\n+                                               overlap.self_desc.clone().map_or(String::new(),\n+                                                                                |ty| {\n+                    format!(\" for type `{}`\", ty)\n+                }));\n+\n+                match tcx.span_of_impl(overlap.with_impl) {\n+                    Ok(span) => {\n+                        err.span_label(span, format!(\"first implementation here\"));\n+                        err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n+                                       format!(\"conflicting implementation{}\",\n+                                                overlap.self_desc\n+                                                    .map_or(String::new(),\n+                                                            |ty| format!(\" for `{}`\", ty))));\n+                    }\n+                    Err(cname) => {\n+                        err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n+                    }\n+                }\n+\n+                err.emit();\n+            }\n+        } else {\n+            let parent = tcx.impl_parent(impl_def_id).unwrap_or(trait_id);\n+            sg.record_impl_from_cstore(tcx, parent, impl_def_id)\n+        }\n+    }\n+\n+    Rc::new(sg)\n+}"}, {"sha": "87c98a0ef0ed6daf16839d7a96f712dd99bde1f4", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -12,8 +12,9 @@ use super::{OverlapError, specializes};\n \n use hir::def_id::DefId;\n use traits::{self, Reveal};\n-use ty::{self, TyCtxt, TraitDef, TypeFoldable};\n+use ty::{self, TyCtxt, TypeFoldable};\n use ty::fast_reject::{self, SimplifiedType};\n+use std::rc::Rc;\n use syntax::ast::Name;\n use util::nodemap::{DefIdMap, FxHashMap};\n \n@@ -301,18 +302,19 @@ impl<'a, 'gcx, 'tcx> Node {\n     }\n }\n \n-pub struct Ancestors<'a> {\n-    trait_def: &'a TraitDef,\n+pub struct Ancestors {\n+    trait_def_id: DefId,\n+    specialization_graph: Rc<Graph>,\n     current_source: Option<Node>,\n }\n \n-impl<'a> Iterator for Ancestors<'a> {\n+impl Iterator for Ancestors {\n     type Item = Node;\n     fn next(&mut self) -> Option<Node> {\n         let cur = self.current_source.take();\n         if let Some(Node::Impl(cur_impl)) = cur {\n-            let parent = self.trait_def.specialization_graph.borrow().parent(cur_impl);\n-            if parent == self.trait_def.def_id {\n+            let parent = self.specialization_graph.parent(cur_impl);\n+            if parent == self.trait_def_id {\n                 self.current_source = Some(Node::Trait(parent));\n             } else {\n                 self.current_source = Some(Node::Impl(parent));\n@@ -336,7 +338,7 @@ impl<T> NodeItem<T> {\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n+impl<'a, 'gcx, 'tcx> Ancestors {\n     /// Search the items from the given ancestors, returning each definition\n     /// with the given name and the given kind.\n     #[inline] // FIXME(#35870) Avoid closures being unexported due to impl Trait.\n@@ -351,9 +353,14 @@ impl<'a, 'gcx, 'tcx> Ancestors<'a> {\n \n /// Walk up the specialization ancestors of a given impl, starting with that\n /// impl itself.\n-pub fn ancestors<'a>(trait_def: &'a TraitDef, start_from_impl: DefId) -> Ancestors<'a> {\n+pub fn ancestors(tcx: TyCtxt,\n+                 trait_def_id: DefId,\n+                 start_from_impl: DefId)\n+                 -> Ancestors {\n+    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n     Ancestors {\n-        trait_def: trait_def,\n+        trait_def_id,\n+        specialization_graph,\n         current_source: Some(Node::Impl(start_from_impl)),\n     }\n }"}, {"sha": "85462bd9b1273ca2a40946ace10c0355abcb9212", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -18,10 +18,12 @@ use middle::region::RegionMaps;\n use mir;\n use mir::transform::{MirSuite, MirPassIndex};\n use session::CompileResult;\n+use traits::specialization_graph;\n use ty::{self, CrateInherentImpls, Ty, TyCtxt};\n use ty::item_path;\n use ty::steal::Steal;\n use ty::subst::Substs;\n+use ty::fast_reject::SimplifiedType;\n use util::nodemap::{DefIdSet, NodeSet};\n \n use rustc_data_structures::indexed_vec::IndexVec;\n@@ -98,6 +100,15 @@ impl Key for (CrateNum, DefId) {\n     }\n }\n \n+impl Key for (DefId, SimplifiedType) {\n+    fn map_crate(&self) -> CrateNum {\n+        self.0.krate\n+    }\n+    fn default_span(&self, tcx: TyCtxt) -> Span {\n+        self.0.default_span(tcx)\n+    }\n+}\n+\n impl<'tcx> Key for (DefId, &'tcx Substs<'tcx>) {\n     fn map_crate(&self) -> CrateNum {\n         self.0.krate\n@@ -391,6 +402,24 @@ impl<'tcx> QueryDescription for queries::is_mir_available<'tcx> {\n     }\n }\n \n+impl<'tcx> QueryDescription for queries::trait_impls_of<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"trait impls of `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::relevant_trait_impls_for<'tcx> {\n+    fn describe(tcx: TyCtxt, (def_id, ty): (DefId, SimplifiedType)) -> String {\n+        format!(\"relevant impls for: `({}, {:?})`\", tcx.item_path_str(def_id), ty)\n+    }\n+}\n+\n+impl<'tcx> QueryDescription for queries::is_object_safe<'tcx> {\n+    fn describe(tcx: TyCtxt, def_id: DefId) -> String {\n+        format!(\"determine object safety of trait `{}`\", tcx.item_path_str(def_id))\n+    }\n+}\n+\n macro_rules! define_maps {\n     (<$tcx:tt>\n      $($(#[$attr:meta])*\n@@ -820,6 +849,13 @@ define_maps! { <'tcx>\n     [] item_body_nested_bodies: ItemBodyNestedBodies(DefId) -> Rc<BTreeMap<hir::BodyId, hir::Body>>,\n     [] const_is_rvalue_promotable_to_static: ConstIsRvaluePromotableToStatic(DefId) -> bool,\n     [] is_mir_available: IsMirAvailable(DefId) -> bool,\n+\n+    [] trait_impls_of: TraitImpls(DefId) -> ty::trait_def::TraitImpls,\n+    // Note that TraitDef::for_each_relevant_impl() will do type simplication for you.\n+    [] relevant_trait_impls_for: relevant_trait_impls_for((DefId, SimplifiedType))\n+        -> ty::trait_def::TraitImpls,\n+    [] specialization_graph_of: SpecializationGraph(DefId) -> Rc<specialization_graph::Graph>,\n+    [] is_object_safe: ObjectSafety(DefId) -> bool,\n }\n \n fn coherent_trait_dep_node((_, def_id): (CrateNum, DefId)) -> DepNode<DefId> {\n@@ -859,3 +895,7 @@ fn mir_keys(_: CrateNum) -> DepNode<DefId> {\n fn crate_variances(_: CrateNum) -> DepNode<DefId> {\n     DepNode::CrateVariances\n }\n+\n+fn relevant_trait_impls_for((def_id, _): (DefId, SimplifiedType)) -> DepNode<DefId> {\n+    DepNode::TraitImpls(def_id)\n+}"}, {"sha": "a86d7351ef472be7116ff228da20fcfc47d54c53", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -80,7 +80,7 @@ pub use self::context::{Lift, TypeckTables};\n \n pub use self::instance::{Instance, InstanceDef};\n \n-pub use self::trait_def::{TraitDef, TraitFlags};\n+pub use self::trait_def::TraitDef;\n \n pub use self::maps::queries;\n \n@@ -2324,37 +2324,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn trait_has_default_impl(self, trait_def_id: DefId) -> bool {\n-        let def = self.trait_def(trait_def_id);\n-        def.flags.get().intersects(TraitFlags::HAS_DEFAULT_IMPL)\n-    }\n-\n-    /// Populates the type context with all the implementations for the given\n-    /// trait if necessary.\n-    pub fn populate_implementations_for_trait_if_necessary(self, trait_id: DefId) {\n-        if trait_id.is_local() {\n-            return\n-        }\n-\n-        // The type is not local, hence we are reading this out of\n-        // metadata and don't need to track edges.\n-        let _ignore = self.dep_graph.in_ignore();\n-\n-        let def = self.trait_def(trait_id);\n-        if def.flags.get().intersects(TraitFlags::HAS_REMOTE_IMPLS) {\n-            return;\n-        }\n-\n-        debug!(\"populate_implementations_for_trait_if_necessary: searching for {:?}\", def);\n-\n-        for impl_def_id in self.sess.cstore.implementations_of_trait(Some(trait_id)) {\n-            let trait_ref = self.impl_trait_ref(impl_def_id).unwrap();\n-\n-            // Record the trait->implementation mapping.\n-            let parent = self.impl_parent(impl_def_id).unwrap_or(trait_id);\n-            def.record_remote_impl(self, impl_def_id, trait_ref, parent);\n-        }\n-\n-        def.flags.set(def.flags.get() | TraitFlags::HAS_REMOTE_IMPLS);\n+        self.trait_def(trait_def_id).has_default_impl\n     }\n \n     /// Given the def_id of an impl, return the def_id of the trait it implements.\n@@ -2603,6 +2573,8 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n         adt_dtorck_constraint,\n         def_span,\n         trait_of_item,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }\n@@ -2611,6 +2583,8 @@ pub fn provide_extern(providers: &mut ty::maps::Providers) {\n     *providers = ty::maps::Providers {\n         adt_sized_constraint,\n         adt_dtorck_constraint,\n+        trait_impls_of: trait_def::trait_impls_of_provider,\n+        relevant_trait_impls_for: trait_def::relevant_trait_impls_provider,\n         ..*providers\n     };\n }"}, {"sha": "865297c7ecbfd5fa67ec69dac06e3b609133e9df", "filename": "src/librustc/ty/trait_def.rs", "status": "modified", "additions": 140, "deletions": 251, "changes": 391, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc%2Fty%2Ftrait_def.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ftrait_def.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -8,18 +8,13 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use dep_graph::DepNode;\n-use hir::def_id::{DefId, LOCAL_CRATE};\n-use traits::{self, specialization_graph};\n-use ty;\n+use hir::def_id::DefId;\n+use traits::specialization_graph;\n use ty::fast_reject;\n-use ty::{Ty, TyCtxt, TraitRef};\n-use std::cell::{Cell, RefCell};\n+use ty::fold::TypeFoldable;\n+use ty::{Ty, TyCtxt};\n+use std::rc::Rc;\n use hir;\n-use util::nodemap::FxHashMap;\n-\n-use syntax::ast;\n-use syntax_pos::DUMMY_SP;\n \n /// A trait's definition with type information.\n pub struct TraitDef {\n@@ -33,237 +28,93 @@ pub struct TraitDef {\n     /// be usable with the sugar (or without it).\n     pub paren_sugar: bool,\n \n-    // Impls of a trait. To allow for quicker lookup, the impls are indexed by a\n-    // simplified version of their `Self` type: impls with a simplifiable `Self`\n-    // are stored in `nonblanket_impls` keyed by it, while all other impls are\n-    // stored in `blanket_impls`.\n-    //\n-    // A similar division is used within `specialization_graph`, but the ones\n-    // here are (1) stored as a flat list for the trait and (2) populated prior\n-    // to -- and used while -- determining specialization order.\n-    //\n-    // FIXME: solve the reentrancy issues and remove these lists in favor of the\n-    // ones in `specialization_graph`.\n-    //\n-    // These lists are tracked by `DepNode::TraitImpls`; we don't use\n-    // a DepTrackingMap but instead have the `TraitDef` insert the\n-    // required reads/writes.\n-\n-    /// Impls of the trait.\n-    nonblanket_impls: RefCell<\n-        FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>\n-    >,\n-\n-    /// Blanket impls associated with the trait.\n-    blanket_impls: RefCell<Vec<DefId>>,\n-\n-    /// The specialization order for impls of this trait.\n-    pub specialization_graph: RefCell<traits::specialization_graph::Graph>,\n-\n-    /// Various flags\n-    pub flags: Cell<TraitFlags>,\n-\n-    /// The number of impls we've added from the local crate.\n-    /// When this number matches up the list in the HIR map,\n-    /// we're done, and the specialization graph is correct.\n-    local_impl_count: Cell<usize>,\n+    pub has_default_impl: bool,\n \n     /// The ICH of this trait's DefPath, cached here so it doesn't have to be\n     /// recomputed all the time.\n     pub def_path_hash: u64,\n }\n \n-impl<'a, 'gcx, 'tcx> TraitDef {\n-    pub fn new(def_id: DefId,\n-               unsafety: hir::Unsafety,\n-               paren_sugar: bool,\n-               def_path_hash: u64)\n-               -> TraitDef {\n-        TraitDef {\n-            def_id: def_id,\n-            paren_sugar: paren_sugar,\n-            unsafety: unsafety,\n-            nonblanket_impls: RefCell::new(FxHashMap()),\n-            blanket_impls: RefCell::new(vec![]),\n-            flags: Cell::new(ty::TraitFlags::NO_TRAIT_FLAGS),\n-            local_impl_count: Cell::new(0),\n-            specialization_graph: RefCell::new(traits::specialization_graph::Graph::new()),\n-            def_path_hash: def_path_hash,\n-        }\n-    }\n+// We don't store the list of impls in a flat list because each cached list of\n+// `relevant_impls_for` we would then duplicate all blanket impls. By keeping\n+// blanket and non-blanket impls separate, we can share the list of blanket\n+// impls.\n+#[derive(Clone)]\n+pub struct TraitImpls {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+}\n \n-    // returns None if not yet calculated\n-    pub fn object_safety(&self) -> Option<bool> {\n-        if self.flags.get().intersects(TraitFlags::OBJECT_SAFETY_VALID) {\n-            Some(self.flags.get().intersects(TraitFlags::IS_OBJECT_SAFE))\n-        } else {\n-            None\n+impl TraitImpls {\n+    pub fn iter(&self) -> TraitImplsIter {\n+        TraitImplsIter {\n+            blanket_impls: self.blanket_impls.clone(),\n+            non_blanket_impls: self.non_blanket_impls.clone(),\n+            index: 0\n         }\n     }\n+}\n \n-    pub fn set_object_safety(&self, is_safe: bool) {\n-        assert!(self.object_safety().map(|cs| cs == is_safe).unwrap_or(true));\n-        self.flags.set(\n-            self.flags.get() | if is_safe {\n-                TraitFlags::OBJECT_SAFETY_VALID | TraitFlags::IS_OBJECT_SAFE\n-            } else {\n-                TraitFlags::OBJECT_SAFETY_VALID\n-            }\n-        );\n-    }\n-\n-    fn write_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.write(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    fn read_trait_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) {\n-        tcx.dep_graph.read(DepNode::TraitImpls(self.def_id));\n-    }\n-\n-    /// Records a basic trait-to-implementation mapping.\n-    ///\n-    /// Returns `true` iff the impl has not previously been recorded.\n-    fn record_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                   impl_def_id: DefId,\n-                   impl_trait_ref: TraitRef<'tcx>)\n-                   -> bool {\n-        debug!(\"TraitDef::record_impl for {:?}, from {:?}\",\n-               self, impl_trait_ref);\n+#[derive(Clone)]\n+pub struct TraitImplsIter {\n+    blanket_impls: Rc<Vec<DefId>>,\n+    non_blanket_impls: Rc<Vec<DefId>>,\n+    index: usize,\n+}\n \n-        // Record the write into the impl set, but only for local\n-        // impls: external impls are handled differently.\n-        if impl_def_id.is_local() {\n-            self.write_trait_impls(tcx);\n-        }\n+impl Iterator for TraitImplsIter {\n+    type Item = DefId;\n \n-        // We don't want to borrow_mut after we already populated all impls,\n-        // so check if an impl is present with an immutable borrow first.\n-        if let Some(sty) = fast_reject::simplify_type(tcx,\n-                                                      impl_trait_ref.self_ty(), false) {\n-            if let Some(is) = self.nonblanket_impls.borrow().get(&sty) {\n-                if is.contains(&impl_def_id) {\n-                    return false; // duplicate - skip\n-                }\n-            }\n-\n-            self.nonblanket_impls.borrow_mut().entry(sty).or_insert(vec![]).push(impl_def_id)\n+    fn next(&mut self) -> Option<DefId> {\n+        if self.index < self.blanket_impls.len() {\n+            let bi_index = self.index;\n+            self.index += 1;\n+            Some(self.blanket_impls[bi_index])\n         } else {\n-            if self.blanket_impls.borrow().contains(&impl_def_id) {\n-                return false; // duplicate - skip\n+            let nbi_index = self.index - self.blanket_impls.len();\n+            if nbi_index < self.non_blanket_impls.len() {\n+                self.index += 1;\n+                Some(self.non_blanket_impls[nbi_index])\n+            } else {\n+                None\n             }\n-            self.blanket_impls.borrow_mut().push(impl_def_id)\n         }\n-\n-        true\n-    }\n-\n-    /// Records a trait-to-implementation mapping for a crate-local impl.\n-    pub fn record_local_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                             impl_def_id: DefId,\n-                             impl_trait_ref: TraitRef<'tcx>) {\n-        assert!(impl_def_id.is_local());\n-        let was_new = self.record_impl(tcx, impl_def_id, impl_trait_ref);\n-        assert!(was_new);\n-\n-        self.local_impl_count.set(self.local_impl_count.get() + 1);\n     }\n \n-    /// Records a trait-to-implementation mapping.\n-    pub fn record_has_default_impl(&self) {\n-        self.flags.set(self.flags.get() | TraitFlags::HAS_DEFAULT_IMPL);\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let items_left = (self.blanket_impls.len() + self.non_blanket_impls.len()) - self.index;\n+        (items_left, Some(items_left))\n     }\n+}\n \n-    /// Records a trait-to-implementation mapping for a non-local impl.\n-    ///\n-    /// The `parent_impl` is the immediately-less-specialized impl, or the\n-    /// trait's def ID if the impl is not a specialization -- information that\n-    /// should be pulled from the metadata.\n-    pub fn record_remote_impl(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                              impl_def_id: DefId,\n-                              impl_trait_ref: TraitRef<'tcx>,\n-                              parent_impl: DefId) {\n-        assert!(!impl_def_id.is_local());\n+impl ExactSizeIterator for TraitImplsIter {}\n \n-        // if the impl has not previously been recorded\n-        if self.record_impl(tcx, impl_def_id, impl_trait_ref) {\n-            // if the impl is non-local, it's placed directly into the\n-            // specialization graph using parent information drawn from metadata.\n-            self.specialization_graph.borrow_mut()\n-                .record_impl_from_cstore(tcx, parent_impl, impl_def_id)\n+impl<'a, 'gcx, 'tcx> TraitDef {\n+    pub fn new(def_id: DefId,\n+               unsafety: hir::Unsafety,\n+               paren_sugar: bool,\n+               has_default_impl: bool,\n+               def_path_hash: u64)\n+               -> TraitDef {\n+        TraitDef {\n+            def_id,\n+            paren_sugar,\n+            unsafety,\n+            has_default_impl,\n+            def_path_hash,\n         }\n     }\n \n-    /// Adds a local impl into the specialization graph, returning an error with\n-    /// overlap information if the impl overlaps but does not specialize an\n-    /// existing impl.\n-    pub fn add_impl_for_specialization(&self,\n-                                       tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                       impl_def_id: DefId)\n-                                       -> Result<(), traits::OverlapError> {\n-        assert!(impl_def_id.is_local());\n-\n-        self.specialization_graph.borrow_mut()\n-            .insert(tcx, impl_def_id)\n-    }\n-\n-    pub fn ancestors(&'a self, of_impl: DefId) -> specialization_graph::Ancestors<'a> {\n-        specialization_graph::ancestors(self, of_impl)\n-    }\n-\n-    /// Whether the impl set and specialization graphs are complete.\n-    pub fn is_complete(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> bool {\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-        ty::queries::coherent_trait::try_get(tcx, DUMMY_SP, (LOCAL_CRATE, self.def_id)).is_ok()\n-    }\n-\n-    /// If any local impls haven't been added yet, returns\n-    /// Some(list of local impls for this trait).\n-    fn missing_local_impls(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>)\n-                           -> Option<&'gcx [ast::NodeId]> {\n-        if self.flags.get().intersects(TraitFlags::HAS_LOCAL_IMPLS) {\n-            return None;\n-        }\n-\n-        if self.is_complete(tcx) {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        let impls = tcx.hir.trait_impls(self.def_id);\n-        assert!(self.local_impl_count.get() <= impls.len());\n-        if self.local_impl_count.get() == impls.len() {\n-            self.flags.set(self.flags.get() | TraitFlags::HAS_LOCAL_IMPLS);\n-            return None;\n-        }\n-\n-        Some(impls)\n+    pub fn ancestors(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                     of_impl: DefId)\n+                     -> specialization_graph::Ancestors {\n+        specialization_graph::ancestors(tcx, self.def_id, of_impl)\n     }\n \n     pub fn for_each_impl<F: FnMut(DefId)>(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>, mut f: F) {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n+        for impl_def_id in tcx.trait_impls_of(self.def_id).iter() {\n             f(impl_def_id);\n         }\n-\n-        for v in self.nonblanket_impls.borrow().values() {\n-            for &impl_def_id in v {\n-                f(impl_def_id);\n-            }\n-        }\n     }\n \n     /// Iterate over every impl that could possibly match the\n@@ -273,25 +124,6 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n                                                    self_ty: Ty<'tcx>,\n                                                    mut f: F)\n     {\n-        self.read_trait_impls(tcx);\n-        tcx.populate_implementations_for_trait_if_necessary(self.def_id);\n-\n-        let local_impls = self.missing_local_impls(tcx);\n-        if let Some(impls) = local_impls {\n-            for &id in impls {\n-                f(tcx.hir.local_def_id(id));\n-            }\n-        }\n-        let mut f = |def_id: DefId| {\n-            if !(local_impls.is_some() && def_id.is_local()) {\n-                f(def_id);\n-            }\n-        };\n-\n-        for &impl_def_id in self.blanket_impls.borrow().iter() {\n-            f(impl_def_id);\n-        }\n-\n         // simplify_type(.., false) basically replaces type parameters and\n         // projections with infer-variables. This is, of course, done on\n         // the impl trait-ref when it is instantiated, but not on the\n@@ -304,29 +136,86 @@ impl<'a, 'gcx, 'tcx> TraitDef {\n         // replace `S` with anything - this impl of course can't be\n         // selected, and as there are hundreds of similar impls,\n         // considering them would significantly harm performance.\n-        if let Some(simp) = fast_reject::simplify_type(tcx, self_ty, true) {\n-            if let Some(impls) = self.nonblanket_impls.borrow().get(&simp) {\n-                for &impl_def_id in impls {\n-                    f(impl_def_id);\n-                }\n-            }\n+        let relevant_impls = if let Some(simplified_self_ty) =\n+                fast_reject::simplify_type(tcx, self_ty, true) {\n+            tcx.relevant_trait_impls_for((self.def_id, simplified_self_ty))\n         } else {\n-            for v in self.nonblanket_impls.borrow().values() {\n-                for &impl_def_id in v {\n-                    f(impl_def_id);\n-                }\n-            }\n+            tcx.trait_impls_of(self.def_id)\n+        };\n+\n+        for impl_def_id in relevant_impls.iter() {\n+            f(impl_def_id);\n         }\n     }\n }\n \n-bitflags! {\n-    flags TraitFlags: u32 {\n-        const NO_TRAIT_FLAGS        = 0,\n-        const HAS_DEFAULT_IMPL      = 1 << 0,\n-        const IS_OBJECT_SAFE        = 1 << 1,\n-        const OBJECT_SAFETY_VALID   = 1 << 2,\n-        const HAS_REMOTE_IMPLS      = 1 << 3,\n-        const HAS_LOCAL_IMPLS       = 1 << 4,\n+// Query provider for `trait_impls_of`.\n+pub(super) fn trait_impls_of_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                                trait_id: DefId)\n+                                                -> TraitImpls {\n+    let remote_impls = if trait_id.is_local() {\n+        // Traits defined in the current crate can't have impls in upstream\n+        // crates, so we don't bother querying the cstore.\n+        Vec::new()\n+    } else {\n+        tcx.sess.cstore.implementations_of_trait(Some(trait_id))\n+    };\n+\n+    let mut blanket_impls = Vec::new();\n+    let mut non_blanket_impls = Vec::new();\n+\n+    let local_impls = tcx.hir\n+                         .trait_impls(trait_id)\n+                         .into_iter()\n+                         .map(|&node_id| tcx.hir.local_def_id(node_id));\n+\n+     for impl_def_id in local_impls.chain(remote_impls.into_iter()) {\n+        let impl_self_ty = tcx.type_of(impl_def_id);\n+        if impl_def_id.is_local() && impl_self_ty.references_error() {\n+            continue\n+        }\n+\n+        if fast_reject::simplify_type(tcx, impl_self_ty, false).is_some() {\n+            non_blanket_impls.push(impl_def_id);\n+        } else {\n+            blanket_impls.push(impl_def_id);\n+        }\n+    }\n+\n+    TraitImpls {\n+        blanket_impls: Rc::new(blanket_impls),\n+        non_blanket_impls: Rc::new(non_blanket_impls),\n+    }\n+}\n+\n+// Query provider for `relevant_trait_impls_for`.\n+pub(super) fn relevant_trait_impls_provider<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    (trait_id, self_ty): (DefId, fast_reject::SimplifiedType))\n+    -> TraitImpls\n+{\n+    let all_trait_impls = tcx.trait_impls_of(trait_id);\n+\n+    let relevant: Vec<DefId> = all_trait_impls\n+        .non_blanket_impls\n+        .iter()\n+        .cloned()\n+        .filter(|&impl_def_id| {\n+            let impl_self_ty = tcx.type_of(impl_def_id);\n+            let impl_simple_self_ty = fast_reject::simplify_type(tcx,\n+                                                                 impl_self_ty,\n+                                                                 false).unwrap();\n+            impl_simple_self_ty == self_ty\n+        })\n+        .collect();\n+\n+    if all_trait_impls.non_blanket_impls.len() == relevant.len() {\n+        // If we didn't filter anything out, re-use the existing vec.\n+        all_trait_impls\n+    } else {\n+        TraitImpls {\n+            blanket_impls: all_trait_impls.blanket_impls.clone(),\n+            non_blanket_impls: Rc::new(relevant),\n+        }\n     }\n }"}, {"sha": "bca82ff9a46dfb803dfa7ec8947763c66ad5a468", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -22,6 +22,7 @@ use rustc::middle::{self, dependency_format, stability, reachable};\n use rustc::middle::privacy::AccessLevels;\n use rustc::mir::transform::{MIR_CONST, MIR_VALIDATED, MIR_OPTIMIZED, Passes};\n use rustc::ty::{self, TyCtxt, Resolutions, GlobalArenas};\n+use rustc::traits;\n use rustc::util::common::time;\n use rustc::util::nodemap::NodeSet;\n use rustc::util::fs::rename_or_copy_remove;\n@@ -894,6 +895,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     trans::provide(&mut local_providers);\n     typeck::provide(&mut local_providers);\n     ty::provide(&mut local_providers);\n+    traits::provide(&mut local_providers);\n     reachable::provide(&mut local_providers);\n     rustc_const_eval::provide(&mut local_providers);\n     middle::region::provide(&mut local_providers);\n@@ -902,6 +904,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n     cstore::provide(&mut extern_providers);\n     trans::provide(&mut extern_providers);\n     ty::provide_extern(&mut extern_providers);\n+    traits::provide_extern(&mut extern_providers);\n     // FIXME(eddyb) get rid of this once we replace const_eval with miri.\n     rustc_const_eval::provide(&mut extern_providers);\n "}, {"sha": "8cdabc1d894e229af7070f87337312e11c5fda0b", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -36,9 +36,10 @@ use rustc::hir::def_id::{LOCAL_CRATE, CRATE_DEF_INDEX, DefId};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n use rustc::ty::TyCtxt;\n+use rustc::util::common::record_time;\n use rustc_data_structures::stable_hasher::{StableHasher, HashStable};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc::util::common::record_time;\n+use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n pub type IchHasher = StableHasher<Fingerprint>;\n \n@@ -159,6 +160,11 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                         // difference, filter them out.\n                                         return None\n                                     }\n+                                    DepNode::AllLocalTraitImpls => {\n+                                        // These are already covered by hashing\n+                                        // the HIR.\n+                                        return None\n+                                    }\n                                     ref other => {\n                                         bug!(\"Found unexpected DepNode during \\\n                                               SVH computation: {:?}\",\n@@ -213,6 +219,49 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                                  true,\n                                                  (module, (span, attrs)));\n     }\n+\n+    fn compute_and_store_ich_for_trait_impls(&mut self, krate: &'tcx hir::Crate)\n+    {\n+        let tcx = self.hcx.tcx();\n+\n+        let mut impls: Vec<(u64, Fingerprint)> = krate\n+            .trait_impls\n+            .iter()\n+            .map(|(&trait_id, impls)| {\n+                let trait_id = tcx.def_path_hash(trait_id);\n+                let mut impls: AccumulateVec<[_; 32]> = impls\n+                    .iter()\n+                    .map(|&node_id| {\n+                        let def_id = tcx.hir.local_def_id(node_id);\n+                        tcx.def_path_hash(def_id)\n+                    })\n+                    .collect();\n+\n+                impls.sort_unstable();\n+                let mut hasher = StableHasher::new();\n+                impls.hash_stable(&mut self.hcx, &mut hasher);\n+                (trait_id, hasher.finish())\n+            })\n+            .collect();\n+\n+        impls.sort_unstable();\n+\n+        let mut default_impls: AccumulateVec<[_; 32]> = krate\n+            .trait_default_impl\n+            .iter()\n+            .map(|(&trait_def_id, &impl_node_id)| {\n+                let impl_def_id = tcx.hir.local_def_id(impl_node_id);\n+                (tcx.def_path_hash(trait_def_id), tcx.def_path_hash(impl_def_id))\n+            })\n+            .collect();\n+\n+        default_impls.sort_unstable();\n+\n+        let mut hasher = StableHasher::new();\n+        impls.hash_stable(&mut self.hcx, &mut hasher);\n+\n+        self.hashes.insert(DepNode::AllLocalTraitImpls, hasher.finish());\n+    }\n }\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n@@ -235,6 +284,8 @@ impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx>\n     }\n }\n \n+\n+\n pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                                                     -> IncrementalHashesMap {\n     let _ignore = tcx.dep_graph.in_ignore();\n@@ -272,6 +323,8 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n             let fingerprint = hasher.finish();\n             visitor.hashes.insert(dep_node, fingerprint);\n         }\n+\n+        visitor.compute_and_store_ich_for_trait_impls(krate);\n     });\n \n     tcx.sess.perf_stats.incr_comp_hashes_count.set(visitor.hashes.len() as u64);"}, {"sha": "ec6947b4a486c31ebcaa1444fc827d2115c72f04", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -315,11 +315,20 @@ impl<'a> CrateLoader<'a> {\n         let exported_symbols = crate_root.exported_symbols\n                                          .map(|x| x.decode(&metadata).collect());\n \n+        let trait_impls = crate_root\n+            .impls\n+            .map(|impls| {\n+                impls.decode(&metadata)\n+                     .map(|trait_impls| (trait_impls.trait_id, trait_impls.impls))\n+                     .collect()\n+            });\n+\n         let mut cmeta = cstore::CrateMetadata {\n             name: name,\n             extern_crate: Cell::new(None),\n             def_path_table: def_path_table,\n             exported_symbols: exported_symbols,\n+            trait_impls: trait_impls,\n             proc_macros: crate_root.macro_derive_registrar.map(|_| {\n                 self.load_derive_macros(&crate_root, dylib.clone().map(|p| p.0), span)\n             }),"}, {"sha": "64fccb0314e97d67743a613a58406568dbcde43f", "filename": "src/librustc_metadata/cstore.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -80,6 +80,8 @@ pub struct CrateMetadata {\n \n     pub exported_symbols: Tracked<FxHashSet<DefIndex>>,\n \n+    pub trait_impls: Tracked<FxHashMap<(u32, DefIndex), schema::LazySeq<DefIndex>>>,\n+\n     pub dep_kind: Cell<DepKind>,\n     pub source: CrateSource,\n "}, {"sha": "4b7083590d24af70af5fe809b12a06351564f494", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -149,10 +149,8 @@ impl CrateStore for cstore::CStore {\n \n     fn implementations_of_trait(&self, filter: Option<DefId>) -> Vec<DefId>\n     {\n-        if let Some(def_id) = filter {\n-            self.dep_graph.read(DepNode::MetaData(def_id));\n-        }\n         let mut result = vec![];\n+\n         self.iter_crate_data(|_, cdata| {\n             cdata.get_implementations_for_trait(filter, &self.dep_graph, &mut result)\n         });"}, {"sha": "754f27810c453962e405463e3a83317896382c38", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -501,16 +501,11 @@ impl<'a, 'tcx> CrateMetadata {\n             _ => bug!(),\n         };\n \n-        let def = ty::TraitDef::new(self.local_def_id(item_id),\n-                                    data.unsafety,\n-                                    data.paren_sugar,\n-                                    self.def_path_table.def_path_hash(item_id));\n-\n-        if data.has_default_impl {\n-            def.record_has_default_impl();\n-        }\n-\n-        def\n+        ty::TraitDef::new(self.local_def_id(item_id),\n+                          data.unsafety,\n+                          data.paren_sugar,\n+                          data.has_default_impl,\n+                          self.def_path_table.def_path_hash(item_id))\n     }\n \n     fn get_variant(&self, item: &Entry, index: DefIndex) -> ty::VariantDef {\n@@ -957,17 +952,17 @@ impl<'a, 'tcx> CrateMetadata {\n             None => None,\n         };\n \n-        // FIXME(eddyb) Make this O(1) instead of O(n).\n         let dep_node = self.metadata_dep_node(GlobalMetaDataKind::Impls);\n-        for trait_impls in self.root.impls.get(dep_graph, dep_node).decode(self) {\n-            if filter.is_some() && filter != Some(trait_impls.trait_id) {\n-                continue;\n-            }\n \n-            result.extend(trait_impls.impls.decode(self).map(|index| self.local_def_id(index)));\n-\n-            if filter.is_some() {\n-                break;\n+        if let Some(filter) = filter {\n+            if let Some(impls) = self.trait_impls\n+                                     .get(dep_graph, dep_node)\n+                                     .get(&filter) {\n+                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n+            }\n+        } else {\n+            for impls in self.trait_impls.get(dep_graph, dep_node).values() {\n+                result.extend(impls.decode(self).map(|idx| self.local_def_id(idx)));\n             }\n         }\n     }"}, {"sha": "93fcdc455e5dd3762dc7dfe7d6f78e13c4e66ea0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -943,7 +943,7 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n                 let trait_ref = tcx.impl_trait_ref(def_id);\n                 let parent = if let Some(trait_ref) = trait_ref {\n                     let trait_def = tcx.trait_def(trait_ref.def_id);\n-                    trait_def.ancestors(def_id).skip(1).next().and_then(|node| {\n+                    trait_def.ancestors(tcx, def_id).skip(1).next().and_then(|node| {\n                         match node {\n                             specialization_graph::Node::Impl(parent) => Some(parent),\n                             _ => None,\n@@ -1295,23 +1295,37 @@ impl<'a, 'b: 'a, 'tcx: 'b> IsolatedEncoder<'a, 'b, 'tcx> {\n \n     /// Encodes an index, mapping each trait to its (local) implementations.\n     fn encode_impls(&mut self, _: ()) -> LazySeq<TraitImpls> {\n+        debug!(\"IsolatedEncoder::encode_impls()\");\n+        let tcx = self.tcx;\n         let mut visitor = ImplVisitor {\n-            tcx: self.tcx,\n+            tcx: tcx,\n             impls: FxHashMap(),\n         };\n-        self.tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+        tcx.hir.krate().visit_all_item_likes(&mut visitor);\n+\n+        let mut all_impls: Vec<_> = visitor.impls.into_iter().collect();\n \n-        let all_impls: Vec<_> = visitor.impls\n+        // Bring everything into deterministic order for hashing\n+        all_impls.sort_unstable_by_key(|&(trait_def_id, _)| {\n+            tcx.def_path_hash(trait_def_id)\n+        });\n+\n+        let all_impls: Vec<_> = all_impls\n             .into_iter()\n-            .map(|(trait_def_id, impls)| {\n+            .map(|(trait_def_id, mut impls)| {\n+                // Bring everything into deterministic order for hashing\n+                impls.sort_unstable_by_key(|&def_index| {\n+                    tcx.hir.definitions().def_path_hash(def_index)\n+                });\n+\n                 TraitImpls {\n                     trait_id: (trait_def_id.krate.as_u32(), trait_def_id.index),\n-                    impls: self.lazy_seq(impls),\n+                    impls: self.lazy_seq_from_slice(&impls[..]),\n                 }\n             })\n             .collect();\n \n-        self.lazy_seq(all_impls)\n+        self.lazy_seq_from_slice(&all_impls[..])\n     }\n \n     // Encodes all symbols exported from this crate into the metadata."}, {"sha": "56c150fd4c82f27608f2c6bc57da9df72c08762a", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -29,6 +29,7 @@\n \n #![cfg_attr(stage0, unstable(feature = \"rustc_private\", issue = \"27812\"))]\n #![cfg_attr(stage0, feature(staged_api))]\n+#![feature(sort_unstable)]\n \n #[macro_use]\n extern crate log;"}, {"sha": "91a22d922199da6d2e6f3e35192ec9957a9491e1", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -221,6 +221,20 @@ impl<T> Tracked<T> {\n     }\n }\n \n+impl<'a, 'tcx, T> HashStable<StableHashingContext<'a, 'tcx>> for Tracked<T>\n+    where T: HashStable<StableHashingContext<'a, 'tcx>>\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut StableHashingContext<'a, 'tcx>,\n+                                          hasher: &mut StableHasher<W>) {\n+        let Tracked {\n+            ref state\n+        } = *self;\n+\n+        state.hash_stable(hcx, hasher);\n+    }\n+}\n+\n \n #[derive(RustcEncodable, RustcDecodable)]\n pub struct CrateRoot {"}, {"sha": "d304d79bc52c8342b8ce1ad65cf1226f2cfb277a", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -1200,7 +1200,7 @@ fn check_specialization_validity<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                            impl_id: DefId,\n                                            impl_item: &hir::ImplItem)\n {\n-    let ancestors = trait_def.ancestors(impl_id);\n+    let ancestors = trait_def.ancestors(tcx, impl_id);\n \n     let kind = match impl_item.node {\n         hir::ImplItemKind::Const(..) => ty::AssociatedKind::Const,\n@@ -1330,7 +1330,7 @@ fn check_impl_items_against_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut invalidated_items = Vec::new();\n     let associated_type_overridden = overridden_associated_type.is_some();\n     for trait_item in tcx.associated_items(impl_trait_ref.def_id) {\n-        let is_implemented = trait_def.ancestors(impl_id)\n+        let is_implemented = trait_def.ancestors(tcx, impl_id)\n             .defs(tcx, trait_item.name, trait_item.kind)\n             .next()\n             .map(|node_item| !node_item.node.is_from_trait())"}, {"sha": "165be49f7603de1d73ff00a03519187585980996", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -46,8 +46,6 @@ fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n         }\n \n         enforce_trait_manually_implementable(tcx, impl_def_id, trait_ref.def_id);\n-        let trait_def = tcx.trait_def(trait_ref.def_id);\n-        trait_def.record_local_impl(tcx, impl_def_id, trait_ref);\n     }\n }\n \n@@ -117,8 +115,6 @@ pub fn provide(providers: &mut Providers) {\n \n fn coherent_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             (_, def_id): (CrateNum, DefId)) {\n-    tcx.populate_implementations_for_trait_if_necessary(def_id);\n-\n     let impls = tcx.hir.trait_impls(def_id);\n     for &impl_id in impls {\n         check_impl(tcx, impl_id);"}, {"sha": "ba1d7b18e8c7faeb29dcc40e41f84cf13426d211", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 3, "deletions": 32, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -41,39 +41,10 @@ pub fn check_impl<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, node_id: ast::NodeId) {\n     let _task =\n         tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n-    let def = tcx.trait_def(trait_def_id);\n-\n-    // attempt to insert into the specialization graph\n-    let insert_result = def.add_impl_for_specialization(tcx, impl_def_id);\n-\n-    // insertion failed due to overlap\n-    if let Err(overlap) = insert_result {\n-        let mut err = struct_span_err!(tcx.sess,\n-                                       tcx.span_of_impl(impl_def_id).unwrap(),\n-                                       E0119,\n-                                       \"conflicting implementations of trait `{}`{}:\",\n-                                       overlap.trait_desc,\n-                                       overlap.self_desc.clone().map_or(String::new(),\n-                                                                        |ty| {\n-            format!(\" for type `{}`\", ty)\n-        }));\n-\n-        match tcx.span_of_impl(overlap.with_impl) {\n-            Ok(span) => {\n-                err.span_label(span, \"first implementation here\");\n-                err.span_label(tcx.span_of_impl(impl_def_id).unwrap(),\n-                               format!(\"conflicting implementation{}\",\n-                                        overlap.self_desc\n-                                            .map_or(String::new(),\n-                                                    |ty| format!(\" for `{}`\", ty))));\n-            }\n-            Err(cname) => {\n-                err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n-            }\n-        }\n+    // Trigger building the specialization graph for the trait of this impl.\n+    // This will detect any overlap errors.\n+    tcx.specialization_graph_of(trait_def_id);\n \n-        err.emit();\n-    }\n \n     // check for overlap with the automatic `impl Trait for Trait`\n     if let ty::TyDynamic(ref data, ..) = trait_ref.self_ty().sty {"}, {"sha": "cb1bd3e099d54c31ef6b468cf0cc619a1cb69e4a", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -749,12 +749,12 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n \n     let def_path_hash = tcx.def_path_hash(def_id);\n-    let def = ty::TraitDef::new(def_id, unsafety, paren_sugar, def_path_hash);\n-\n-    if tcx.hir.trait_is_auto(def_id) {\n-        def.record_has_default_impl();\n-    }\n-\n+    let has_default_impl = tcx.hir.trait_is_auto(def_id);\n+    let def = ty::TraitDef::new(def_id,\n+                                unsafety,\n+                                paren_sugar,\n+                                has_default_impl,\n+                                def_path_hash);\n     tcx.alloc_trait_def(def)\n }\n "}, {"sha": "f9ebe3fff5beb951478ecbe9f8442cc48b8cf679", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -1524,67 +1524,6 @@ impl TypeWrapper {\n ```\n \"##,\n \n-E0119: r##\"\n-There are conflicting trait implementations for the same type.\n-Example of erroneous code:\n-\n-```compile_fail,E0119\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo {\n-    value: usize\n-}\n-\n-impl MyTrait for Foo { // error: conflicting implementations of trait\n-                       //        `MyTrait` for type `Foo`\n-    fn get(&self) -> usize { self.value }\n-}\n-```\n-\n-When looking for the implementation for the trait, the compiler finds\n-both the `impl<T> MyTrait for T` where T is all types and the `impl\n-MyTrait for Foo`. Since a trait cannot be implemented multiple times,\n-this is an error. So, when you write:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-```\n-\n-This makes the trait implemented on all types in the scope. So if you\n-try to implement it on another one after that, the implementations will\n-conflict. Example:\n-\n-```\n-trait MyTrait {\n-    fn get(&self) -> usize;\n-}\n-\n-impl<T> MyTrait for T {\n-    fn get(&self) -> usize { 0 }\n-}\n-\n-struct Foo;\n-\n-fn main() {\n-    let f = Foo;\n-\n-    f.get(); // the trait is implemented so we can use it\n-}\n-```\n-\"##,\n-\n E0120: r##\"\n An attempt was made to implement Drop on a trait, which is not allowed: only\n structs and enums can implement Drop. An example causing this error:"}, {"sha": "5d7f33967402c217b27edb2b860b3c188e7179bb", "filename": "src/test/compile-fail/coherence-inherited-assoc-ty-cycle-err.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence-inherited-assoc-ty-cycle-err.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Formerly this ICEd with the following message:\n+// Tried to project an inherited associated type during coherence checking,\n+// which is currently not supported.\n+//\n+// No we expect to run into a more user-friendly cycle error instead.\n+\n+#![feature(specialization)]\n+\n+trait Trait<T> { type Assoc; }\n+//~^ unsupported cyclic reference between types/traits detected [E0391]\n+\n+impl<T> Trait<T> for Vec<T> {\n+    type Assoc = ();\n+}\n+\n+impl Trait<u8> for Vec<u8> {}\n+\n+impl<T> Trait<T> for String {\n+    type Assoc = ();\n+}\n+\n+impl Trait<<Vec<u8> as Trait<u8>>::Assoc> for String {}\n+\n+fn main() {}"}, {"sha": "9feefb4c037724659d7c20116ad5d72372180257", "filename": "src/test/incremental/remapped_paths_cc/auxiliary/extern_crate.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fauxiliary%2Fextern_crate.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -10,10 +10,9 @@\n \n // ignore-tidy-linelength\n \n-// aux-build:extern_crate.rs\n-//[rpass1] compile-flags: -g\n-//[rpass2] compile-flags: -g\n-//[rpass3] compile-flags: -g -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n+//[rpass1] compile-flags: -g -Zincremental-cc\n+//[rpass2] compile-flags: -g -Zincremental-cc\n+//[rpass3] compile-flags: -g -Zincremental-cc -Zremap-path-prefix-from={{src-base}} -Zremap-path-prefix-to=/the/src\n \n #![feature(rustc_attrs)]\n #![crate_type=\"rlib\"]"}, {"sha": "be4764c7d9948288d25bc00493f4e5706a48dccd", "filename": "src/test/incremental/remapped_paths_cc/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fremapped_paths_cc%2Fmain.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n // revisions:rpass1 rpass2 rpass3\n-// compile-flags: -Z query-dep-graph -g\n+// compile-flags: -Z query-dep-graph -g -Zincremental-cc\n // aux-build:extern_crate.rs\n \n "}, {"sha": "a65dcf33d85b1a2d77fba47eab0fcc3833c4358a", "filename": "src/test/run-pass/specialization/assoc-ty-graph-cycle.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4640e185725955ea7be30655e8de3c88ef824f2d/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fspecialization%2Fassoc-ty-graph-cycle.rs?ref=4640e185725955ea7be30655e8de3c88ef824f2d", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Make sure we don't crash with a cycle error during coherence.\n+\n+#![feature(specialization)]\n+\n+trait Trait<T> {\n+    type Assoc;\n+}\n+\n+impl<T> Trait<T> for Vec<T> {\n+    default type Assoc = ();\n+}\n+\n+impl Trait<u8> for Vec<u8> {\n+    type Assoc = u8;\n+}\n+\n+impl<T> Trait<T> for String {\n+    type Assoc = ();\n+}\n+\n+impl Trait<<Vec<u8> as Trait<u8>>::Assoc> for String {}\n+\n+fn main() {}"}]}