{"sha": "bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkNWRmZjQwMTJhNzNhZDRjNWViNWRiMWRiYjExMWJkOTJlZDMxZGQ=", "commit": {"author": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2020-03-27T02:25:34Z"}, "committer": {"name": "Caleb Cartwright", "email": "caleb.cartwright@outlook.com", "date": "2020-03-27T02:25:34Z"}, "message": "refactor: backport syntux mod", "tree": {"sha": "b781aa6ed959466d2b6605ab844a2ba7fe56b6a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b781aa6ed959466d2b6605ab844a2ba7fe56b6a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "html_url": "https://github.com/rust-lang/rust/commit/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/comments", "author": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebcartwright", "id": 13042488, "node_id": "MDQ6VXNlcjEzMDQyNDg4", "avatar_url": "https://avatars.githubusercontent.com/u/13042488?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebcartwright", "html_url": "https://github.com/calebcartwright", "followers_url": "https://api.github.com/users/calebcartwright/followers", "following_url": "https://api.github.com/users/calebcartwright/following{/other_user}", "gists_url": "https://api.github.com/users/calebcartwright/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebcartwright/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebcartwright/subscriptions", "organizations_url": "https://api.github.com/users/calebcartwright/orgs", "repos_url": "https://api.github.com/users/calebcartwright/repos", "events_url": "https://api.github.com/users/calebcartwright/events{/privacy}", "received_events_url": "https://api.github.com/users/calebcartwright/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9699c96cf1e6a13e0cc12e17c55ca11d2f9a6bf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/9699c96cf1e6a13e0cc12e17c55ca11d2f9a6bf2", "html_url": "https://github.com/rust-lang/rust/commit/9699c96cf1e6a13e0cc12e17c55ca11d2f9a6bf2"}], "stats": {"total": 1725, "additions": 959, "deletions": 766}, "files": [{"sha": "18d3df1fa7c61190d18dd66fd69906c729079283", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -56,6 +56,7 @@ ignore = \"0.4.11\"\n annotate-snippets = { version = \"0.6\", features = [\"ansi_term\"] }\n structopt = \"0.3\"\n rustfmt-config_proc_macro = { version = \"0.2\", path = \"config_proc_macro\" }\n+lazy_static = \"1.0.0\"\n \n # A noop dependency that changes in the Rust repository, it's a bit of a hack.\n # See the `src/tools/rustc-workspace-hack/README.md` file in `rust-lang/rust`\n@@ -93,6 +94,3 @@ version = \"647.0.0\"\n [dependencies.syntax]\n package = \"rustc-ap-rustc_ast\"\n version = \"647.0.0\"\n-\n-[dev-dependencies]\n-lazy_static = \"1.0.0\""}, {"sha": "625ef4a81f9c7f98ac66881c3300667604465088", "filename": "src/closures.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fclosures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fclosures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fclosures.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -43,7 +43,7 @@ pub(crate) fn rewrite_closure(\n \n     if let ast::ExprKind::Block(ref block, _) = body.kind {\n         // The body of the closure is an empty block.\n-        if block.stmts.is_empty() && !block_contains_comment(block, context.source_map) {\n+        if block.stmts.is_empty() && !block_contains_comment(context, block) {\n             return body\n                 .rewrite(context, shape)\n                 .map(|s| format!(\"{} {}\", prefix, s));\n@@ -116,7 +116,7 @@ fn needs_block(block: &ast::Block, prefix: &str, context: &RewriteContext<'_>) -\n     is_unsafe_block(block)\n         || block.stmts.len() > 1\n         || has_attributes\n-        || block_contains_comment(block, context.source_map)\n+        || block_contains_comment(context, block)\n         || prefix.contains('\\n')\n }\n \n@@ -309,7 +309,7 @@ pub(crate) fn rewrite_last_closure(\n             ast::ExprKind::Block(ref block, _)\n                 if !is_unsafe_block(block)\n                     && !context.inside_macro()\n-                    && is_simple_block(block, Some(&body.attrs), context.source_map) =>\n+                    && is_simple_block(context, block, Some(&body.attrs)) =>\n             {\n                 stmt_expr(&block.stmts[0]).unwrap_or(body)\n             }"}, {"sha": "518f2bcda0c38dbd3db5a83a9a552e3173b0709a", "filename": "src/comment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -1556,10 +1556,10 @@ pub(crate) fn recover_comment_removed(\n         // We missed some comments. Warn and keep the original text.\n         if context.config.error_on_unformatted() {\n             context.report.append(\n-                context.source_map.span_to_filename(span).into(),\n+                context.parse_sess.span_to_filename(span),\n                 vec![FormattingError::from_span(\n                     span,\n-                    &context.source_map,\n+                    &context.parse_sess,\n                     ErrorKind::LostComment,\n                 )],\n             );"}, {"sha": "608425b34bdcbffbae23d409712bc3ffd04b6554", "filename": "src/expr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -2,7 +2,7 @@ use std::borrow::Cow;\n use std::cmp::min;\n \n use itertools::Itertools;\n-use rustc_span::{source_map::SourceMap, BytePos, Span};\n+use rustc_span::{BytePos, Span};\n use syntax::token::{DelimToken, LitKind};\n use syntax::{ast, ptr};\n \n@@ -430,7 +430,7 @@ fn rewrite_empty_block(\n         return None;\n     }\n \n-    if !block_contains_comment(block, context.source_map) && shape.width >= 2 {\n+    if !block_contains_comment(context, block) && shape.width >= 2 {\n         return Some(format!(\"{}{}{{}}\", prefix, label_str));\n     }\n \n@@ -487,7 +487,7 @@ fn rewrite_single_line_block(\n     label: Option<ast::Label>,\n     shape: Shape,\n ) -> Option<String> {\n-    if is_simple_block(block, attrs, context.source_map) {\n+    if is_simple_block(context, block, attrs) {\n         let expr_shape = shape.offset_left(last_line_width(prefix))?;\n         let expr_str = block.stmts[0].rewrite(context, expr_shape)?;\n         let label_str = rewrite_label(label);\n@@ -750,8 +750,8 @@ impl<'a> ControlFlow<'a> {\n         let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n \n         if let ast::ExprKind::Block(ref else_node, _) = else_block.kind {\n-            if !is_simple_block(self.block, None, context.source_map)\n-                || !is_simple_block(else_node, None, context.source_map)\n+            if !is_simple_block(context, self.block, None)\n+                || !is_simple_block(context, else_node, None)\n                 || pat_expr_str.contains('\\n')\n             {\n                 return None;\n@@ -1134,47 +1134,46 @@ fn extract_comment(span: Span, context: &RewriteContext<'_>, shape: Shape) -> Op\n     }\n }\n \n-pub(crate) fn block_contains_comment(block: &ast::Block, source_map: &SourceMap) -> bool {\n-    let snippet = source_map.span_to_snippet(block.span).unwrap();\n-    contains_comment(&snippet)\n+pub(crate) fn block_contains_comment(context: &RewriteContext<'_>, block: &ast::Block) -> bool {\n+    contains_comment(context.snippet(block.span))\n }\n \n // Checks that a block contains no statements, an expression and no comments or\n // attributes.\n // FIXME: incorrectly returns false when comment is contained completely within\n // the expression.\n pub(crate) fn is_simple_block(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.len() == 1\n         && stmt_is_expr(&block.stmts[0])\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| a.is_empty())\n }\n \n /// Checks whether a block contains at most one statement or expression, and no\n /// comments or attributes.\n pub(crate) fn is_simple_block_stmt(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.len() <= 1\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| a.is_empty())\n }\n \n /// Checks whether a block contains no statements, expressions, comments, or\n /// inner attributes.\n pub(crate) fn is_empty_block(\n+    context: &RewriteContext<'_>,\n     block: &ast::Block,\n     attrs: Option<&[ast::Attribute]>,\n-    source_map: &SourceMap,\n ) -> bool {\n     block.stmts.is_empty()\n-        && !block_contains_comment(block, source_map)\n+        && !block_contains_comment(context, block)\n         && attrs.map_or(true, |a| inner_attributes(a).is_empty())\n }\n "}, {"sha": "104e631f4416862c537b8e7d4c0fdf0465db2fb5", "filename": "src/formatting.rs", "status": "modified", "additions": 39, "deletions": 419, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fformatting.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -1,29 +1,20 @@\n // High level formatting functions.\n \n-use std::cell::RefCell;\n use std::collections::HashMap;\n use std::io::{self, Write};\n-use std::panic::{catch_unwind, AssertUnwindSafe};\n-use std::rc::Rc;\n use std::time::{Duration, Instant};\n \n-use rustc_data_structures::sync::{Lrc, Send};\n-use rustc_errors::emitter::{Emitter, EmitterWriter};\n-use rustc_errors::{ColorConfig, Diagnostic, DiagnosticBuilder, Handler, Level as DiagnosticLevel};\n-use rustc_session::parse::ParseSess;\n-use rustc_span::{\n-    source_map::{FilePathMapping, SourceMap},\n-    Span, DUMMY_SP,\n-};\n+use rustc_span::Span;\n use syntax::ast;\n \n use self::newline_style::apply_newline_style;\n use crate::comment::{CharClasses, FullCodeCharKind};\n use crate::config::{Config, FileName, Verbosity};\n-use crate::ignore_path::IgnorePathSet;\n use crate::issues::BadIssueSeeker;\n+use crate::syntux::parser::{DirectoryOwnership, Parser, ParserError};\n+use crate::syntux::session::ParseSess;\n use crate::utils::count_newlines;\n-use crate::visitor::{FmtVisitor, SnippetProvider};\n+use crate::visitor::FmtVisitor;\n use crate::{modules, source_file, ErrorKind, FormatReport, Input, Session};\n \n mod newline_style;\n@@ -71,54 +62,41 @@ fn format_project<T: FormatHandler>(\n     let main_file = input.file_name();\n     let input_is_stdin = main_file == FileName::Stdin;\n \n-    let ignore_path_set = match IgnorePathSet::from_ignore_list(&config.ignore()) {\n-        Ok(set) => Rc::new(set),\n-        Err(e) => return Err(ErrorKind::InvalidGlobPattern(e)),\n-    };\n-    if config.skip_children() && ignore_path_set.is_match(&main_file) {\n+    let mut parse_session = ParseSess::new(config)?;\n+    if config.skip_children() && parse_session.ignore_file(&main_file) {\n         return Ok(FormatReport::new());\n     }\n \n     // Parse the crate.\n-    let can_reset_parser_errors = Rc::new(RefCell::new(false));\n-    let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-    let mut parse_session = make_parse_sess(\n-        source_map.clone(),\n-        config,\n-        Rc::clone(&ignore_path_set),\n-        can_reset_parser_errors.clone(),\n-    );\n     let mut report = FormatReport::new();\n     let directory_ownership = input.to_directory_ownership();\n-    let krate = match parse_crate(\n-        input,\n-        &parse_session,\n-        config,\n-        &mut report,\n-        directory_ownership,\n-        can_reset_parser_errors.clone(),\n-    ) {\n+    let krate = match Parser::parse_crate(config, input, directory_ownership, &parse_session) {\n         Ok(krate) => krate,\n         // Surface parse error via Session (errors are merged there from report)\n-        Err(ErrorKind::ParseError) => return Ok(report),\n-        Err(e) => return Err(e),\n+        Err(e) => {\n+            let forbid_verbose = input_is_stdin || e != ParserError::ParsePanicError;\n+            should_emit_verbose(forbid_verbose, config, || {\n+                eprintln!(\"The Rust parser panicked\");\n+            });\n+            report.add_parsing_error();\n+            return Ok(report);\n+        }\n     };\n     timer = timer.done_parsing();\n \n     // Suppress error output if we have to do any further parsing.\n-    let silent_emitter = silent_emitter();\n-    parse_session.span_diagnostic = Handler::with_emitter(true, None, silent_emitter);\n+    parse_session.set_silent_emitter();\n \n     let mut context = FormatContext::new(&krate, report, parse_session, config, handler);\n     let files = modules::ModResolver::new(\n         &context.parse_session,\n-        directory_ownership.unwrap_or(rustc_parse::DirectoryOwnership::UnownedViaMod),\n+        directory_ownership.unwrap_or(DirectoryOwnership::UnownedViaMod),\n         !(input_is_stdin || config.skip_children()),\n     )\n     .visit_crate(&krate)\n     .map_err(|e| io::Error::new(io::ErrorKind::Other, e))?;\n     for (path, module) in files {\n-        let should_ignore = !input_is_stdin && ignore_path_set.is_match(&path);\n+        let should_ignore = !input_is_stdin && context.ignore_file(&path);\n         if (config.skip_children() && path != main_file) || should_ignore {\n             continue;\n         }\n@@ -150,22 +128,19 @@ struct FormatContext<'a, T: FormatHandler> {\n }\n \n impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n+    fn ignore_file(&self, path: &FileName) -> bool {\n+        self.parse_session.ignore_file(path)\n+    }\n+\n     // Formats a single file/module.\n     fn format_file(\n         &mut self,\n         path: FileName,\n         module: &ast::Mod,\n         is_root: bool,\n     ) -> Result<(), ErrorKind> {\n-        let source_file = self\n-            .parse_session\n-            .source_map()\n-            .lookup_char_pos(module.inner.lo())\n-            .file;\n-        let big_snippet = source_file.src.as_ref().unwrap();\n-        let snippet_provider =\n-            SnippetProvider::new(source_file.start_pos, source_file.end_pos, big_snippet);\n-        let mut visitor = FmtVisitor::from_source_map(\n+        let snippet_provider = self.parse_session.snippet_provider(module.inner);\n+        let mut visitor = FmtVisitor::from_parse_sess(\n             &self.parse_session,\n             &self.config,\n             &snippet_provider,\n@@ -175,16 +150,16 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n \n         // Format inner attributes if available.\n         if !self.krate.attrs.is_empty() && is_root {\n-            visitor.skip_empty_lines(source_file.end_pos);\n+            visitor.skip_empty_lines(snippet_provider.end_pos());\n             if visitor.visit_attrs(&self.krate.attrs, ast::AttrStyle::Inner) {\n                 visitor.push_rewrite(module.inner, None);\n             } else {\n-                visitor.format_separate_mod(module, &*source_file);\n+                visitor.format_separate_mod(module, snippet_provider.end_pos());\n             }\n         } else {\n-            visitor.last_pos = source_file.start_pos;\n-            visitor.skip_empty_lines(source_file.end_pos);\n-            visitor.format_separate_mod(module, &*source_file);\n+            visitor.last_pos = snippet_provider.start_pos();\n+            visitor.skip_empty_lines(snippet_provider.end_pos());\n+            visitor.format_separate_mod(module, snippet_provider.end_pos());\n         };\n \n         debug_assert_eq!(\n@@ -209,7 +184,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n         apply_newline_style(\n             self.config.newline_style(),\n             &mut visitor.buffer,\n-            &big_snippet,\n+            snippet_provider.entire_snippet(),\n         );\n \n         if visitor.macro_rewrite_failure {\n@@ -219,7 +194,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n             .add_non_formatted_ranges(visitor.skipped_range.borrow().clone());\n \n         self.handler.handle_formatted_file(\n-            self.parse_session.source_map(),\n+            &self.parse_session,\n             path,\n             visitor.buffer.to_owned(),\n             &mut self.report,\n@@ -231,7 +206,7 @@ impl<'a, T: FormatHandler + 'a> FormatContext<'a, T> {\n trait FormatHandler {\n     fn handle_formatted_file(\n         &mut self,\n-        source_map: &SourceMap,\n+        parse_session: &ParseSess,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n@@ -242,14 +217,14 @@ impl<'b, T: Write + 'b> FormatHandler for Session<'b, T> {\n     // Called for each formatted file.\n     fn handle_formatted_file(\n         &mut self,\n-        source_map: &SourceMap,\n+        parse_session: &ParseSess,\n         path: FileName,\n         result: String,\n         report: &mut FormatReport,\n     ) -> Result<(), ErrorKind> {\n         if let Some(ref mut out) = self.out {\n             match source_file::write_file(\n-                Some(source_map),\n+                Some(parse_session),\n                 &path,\n                 &result,\n                 out,\n@@ -282,23 +257,15 @@ pub(crate) struct FormattingError {\n impl FormattingError {\n     pub(crate) fn from_span(\n         span: Span,\n-        source_map: &SourceMap,\n+        parse_sess: &ParseSess,\n         kind: ErrorKind,\n     ) -> FormattingError {\n         FormattingError {\n-            line: source_map.lookup_char_pos(span.lo()).line,\n+            line: parse_sess.line_of_byte_pos(span.lo()),\n             is_comment: kind.is_comment(),\n             kind,\n             is_string: false,\n-            line_buffer: source_map\n-                .span_to_lines(span)\n-                .ok()\n-                .and_then(|fl| {\n-                    fl.file\n-                        .get_line(fl.lines[0].line_index)\n-                        .map(std::borrow::Cow::into_owned)\n-                })\n-                .unwrap_or_else(String::new),\n+            line_buffer: parse_sess.span_to_first_line_string(span),\n         }\n     }\n \n@@ -633,358 +600,11 @@ impl<'a> FormatLines<'a> {\n     }\n }\n \n-fn parse_crate(\n-    input: Input,\n-    parse_session: &ParseSess,\n-    config: &Config,\n-    report: &mut FormatReport,\n-    directory_ownership: Option<rustc_parse::DirectoryOwnership>,\n-    can_reset_parser_errors: Rc<RefCell<bool>>,\n-) -> Result<ast::Crate, ErrorKind> {\n-    let input_is_stdin = input.is_text();\n-\n-    let parser = match input {\n-        Input::File(ref file) => {\n-            // Use `new_sub_parser_from_file` when we the input is a submodule.\n-            Ok(if let Some(dir_own) = directory_ownership {\n-                rustc_parse::new_sub_parser_from_file(parse_session, file, dir_own, None, DUMMY_SP)\n-            } else {\n-                rustc_parse::new_parser_from_file(parse_session, file)\n-            })\n-        }\n-        Input::Text(text) => rustc_parse::maybe_new_parser_from_source_str(\n-            parse_session,\n-            rustc_span::FileName::Custom(\"stdin\".to_owned()),\n-            text,\n-        )\n-        .map(|mut parser| {\n-            parser.recurse_into_file_modules = false;\n-            parser\n-        }),\n-    };\n-\n-    let result = match parser {\n-        Ok(mut parser) => {\n-            parser.cfg_mods = false;\n-            if config.skip_children() {\n-                parser.recurse_into_file_modules = false;\n-            }\n-\n-            let mut parser = AssertUnwindSafe(parser);\n-            catch_unwind(move || parser.0.parse_crate_mod().map_err(|d| vec![d]))\n-        }\n-        Err(diagnostics) => {\n-            for diagnostic in diagnostics {\n-                parse_session.span_diagnostic.emit_diagnostic(&diagnostic);\n-            }\n-            report.add_parsing_error();\n-            return Err(ErrorKind::ParseError);\n-        }\n-    };\n-\n-    match result {\n-        Ok(Ok(c)) => {\n-            if !parse_session.span_diagnostic.has_errors() {\n-                return Ok(c);\n-            }\n-            // This scenario occurs when the parser encountered errors\n-            // but was still able to recover. If all of the parser errors\n-            // occurred in files that are ignored, then reset\n-            // the error count and continue.\n-            // https://github.com/rust-lang/rustfmt/issues/3779\n-            if *can_reset_parser_errors.borrow() {\n-                parse_session.span_diagnostic.reset_err_count();\n-                return Ok(c);\n-            }\n-        }\n-        Ok(Err(mut diagnostics)) => diagnostics.iter_mut().for_each(DiagnosticBuilder::emit),\n-        Err(_) => {\n-            // Note that if you see this message and want more information,\n-            // then run the `parse_crate_mod` function above without\n-            // `catch_unwind` so rustfmt panics and you can get a backtrace.\n-            should_emit_verbose(input_is_stdin, config, || {\n-                println!(\"The Rust parser panicked\")\n-            });\n-        }\n-    }\n-\n-    report.add_parsing_error();\n-    Err(ErrorKind::ParseError)\n-}\n-\n-struct SilentOnIgnoredFilesEmitter {\n-    ignore_path_set: Rc<IgnorePathSet>,\n-    source_map: Rc<SourceMap>,\n-    emitter: Box<dyn Emitter + Send>,\n-    has_non_ignorable_parser_errors: bool,\n-    can_reset: Rc<RefCell<bool>>,\n-}\n-\n-impl SilentOnIgnoredFilesEmitter {\n-    fn handle_non_ignoreable_error(&mut self, db: &Diagnostic) {\n-        self.has_non_ignorable_parser_errors = true;\n-        *self.can_reset.borrow_mut() = false;\n-        self.emitter.emit_diagnostic(db);\n-    }\n-}\n-\n-impl Emitter for SilentOnIgnoredFilesEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-\n-    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n-        if db.level == DiagnosticLevel::Fatal {\n-            return self.handle_non_ignoreable_error(db);\n-        }\n-        if let Some(primary_span) = &db.span.primary_span() {\n-            let file_name = self.source_map.span_to_filename(*primary_span);\n-            if let rustc_span::FileName::Real(ref path) = file_name {\n-                if self\n-                    .ignore_path_set\n-                    .is_match(&FileName::Real(path.to_path_buf()))\n-                {\n-                    if !self.has_non_ignorable_parser_errors {\n-                        *self.can_reset.borrow_mut() = true;\n-                    }\n-                    return;\n-                }\n-            };\n-        }\n-        self.handle_non_ignoreable_error(db);\n-    }\n-}\n-\n-/// Emitter which discards every error.\n-struct SilentEmitter;\n-\n-impl Emitter for SilentEmitter {\n-    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-        None\n-    }\n-    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n-}\n-\n-fn silent_emitter() -> Box<dyn Emitter + Send> {\n-    Box::new(SilentEmitter {})\n-}\n-\n-fn make_parse_sess(\n-    source_map: Rc<SourceMap>,\n-    config: &Config,\n-    ignore_path_set: Rc<IgnorePathSet>,\n-    can_reset: Rc<RefCell<bool>>,\n-) -> ParseSess {\n-    let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n-    let color_cfg = if supports_color {\n-        ColorConfig::Auto\n-    } else {\n-        ColorConfig::Never\n-    };\n-\n-    let emitter = if config.hide_parse_errors() {\n-        silent_emitter()\n-    } else {\n-        Box::new(EmitterWriter::stderr(\n-            color_cfg,\n-            Some(source_map.clone()),\n-            false,\n-            false,\n-            None,\n-            false,\n-        ))\n-    };\n-    let handler = Handler::with_emitter(\n-        true,\n-        None,\n-        Box::new(SilentOnIgnoredFilesEmitter {\n-            has_non_ignorable_parser_errors: false,\n-            source_map: source_map.clone(),\n-            emitter,\n-            ignore_path_set,\n-            can_reset,\n-        }),\n-    );\n-\n-    ParseSess::with_span_handler(handler, source_map)\n-}\n-\n-fn should_emit_verbose<F>(is_stdin: bool, config: &Config, f: F)\n+fn should_emit_verbose<F>(forbid_verbose_output: bool, config: &Config, f: F)\n where\n     F: Fn(),\n {\n-    if config.verbose() == Verbosity::Verbose && !is_stdin {\n+    if config.verbose() == Verbosity::Verbose && !forbid_verbose_output {\n         f();\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    mod emitter {\n-        use super::*;\n-        use crate::config::IgnoreList;\n-        use crate::is_nightly_channel;\n-        use crate::utils::mk_sp;\n-        use rustc_span::{BytePos, FileName as SourceMapFileName, MultiSpan, DUMMY_SP};\n-        use std::path::{Path, PathBuf};\n-\n-        struct TestEmitter {\n-            num_emitted_errors: Rc<RefCell<u32>>,\n-        }\n-\n-        impl Emitter for TestEmitter {\n-            fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n-                None\n-            }\n-            fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n-                *self.num_emitted_errors.borrow_mut() += 1;\n-            }\n-        }\n-\n-        fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n-            Diagnostic {\n-                level,\n-                code: None,\n-                message: vec![],\n-                children: vec![],\n-                suggestions: vec![],\n-                span: span.unwrap_or_else(MultiSpan::new),\n-                sort_span: DUMMY_SP,\n-            }\n-        }\n-\n-        fn build_emitter(\n-            num_emitted_errors: Rc<RefCell<u32>>,\n-            can_reset: Rc<RefCell<bool>>,\n-            source_map: Option<Rc<SourceMap>>,\n-            ignore_list: Option<IgnoreList>,\n-        ) -> SilentOnIgnoredFilesEmitter {\n-            let emitter_writer = TestEmitter { num_emitted_errors };\n-            let source_map =\n-                source_map.unwrap_or_else(|| Rc::new(SourceMap::new(FilePathMapping::empty())));\n-            let ignore_path_set =\n-                Rc::new(IgnorePathSet::from_ignore_list(&ignore_list.unwrap_or_default()).unwrap());\n-            SilentOnIgnoredFilesEmitter {\n-                has_non_ignorable_parser_errors: false,\n-                source_map,\n-                emitter: Box::new(emitter_writer),\n-                ignore_path_set,\n-                can_reset,\n-            }\n-        }\n-\n-        fn get_ignore_list(config: &str) -> IgnoreList {\n-            Config::from_toml(config, Path::new(\"\")).unwrap().ignore()\n-        }\n-\n-        #[test]\n-        fn handles_fatal_parse_error_in_ignored_file() {\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source =\n-                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, Some(span));\n-            emitter.emit_diagnostic(&fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 1);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-\n-        #[test]\n-        fn handles_recoverable_parse_error_in_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n-            emitter.emit_diagnostic(&non_fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 0);\n-            assert_eq!(*can_reset_errors.borrow(), true);\n-        }\n-\n-        #[test]\n-        fn handles_recoverable_parse_error_in_non_ignored_file() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                None,\n-            );\n-            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n-            emitter.emit_diagnostic(&non_fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 1);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-\n-        #[test]\n-        fn handles_mix_of_recoverable_parse_error() {\n-            if !is_nightly_channel!() {\n-                return;\n-            }\n-            let num_emitted_errors = Rc::new(RefCell::new(0));\n-            let can_reset_errors = Rc::new(RefCell::new(false));\n-            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n-            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n-            let bar_source = String::from(r#\"pub fn bar() { 1x; }\"#);\n-            let foo_source = String::from(r#\"pub fn foo() { 1x; }\"#);\n-            let fatal_source =\n-                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n-            source_map\n-                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"bar.rs\")), bar_source);\n-            source_map\n-                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), foo_source);\n-            source_map.new_source_file(\n-                SourceMapFileName::Real(PathBuf::from(\"fatal.rs\")),\n-                fatal_source,\n-            );\n-            let mut emitter = build_emitter(\n-                Rc::clone(&num_emitted_errors),\n-                Rc::clone(&can_reset_errors),\n-                Some(Rc::clone(&source_map)),\n-                Some(ignore_list),\n-            );\n-            let bar_span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n-            let foo_span = MultiSpan::from_span(mk_sp(BytePos(21), BytePos(22)));\n-            let bar_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(bar_span));\n-            let foo_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(foo_span));\n-            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, None);\n-            emitter.emit_diagnostic(&bar_diagnostic);\n-            emitter.emit_diagnostic(&foo_diagnostic);\n-            emitter.emit_diagnostic(&fatal_diagnostic);\n-            assert_eq!(*num_emitted_errors.borrow(), 2);\n-            assert_eq!(*can_reset_errors.borrow(), false);\n-        }\n-    }\n-}"}, {"sha": "9bd254250cc99947078e92b531f3b9fdd746b8fb", "filename": "src/items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -363,17 +363,17 @@ impl<'a> FmtVisitor<'a> {\n             return None;\n         }\n \n-        let source_map = self.get_context().source_map;\n+        let context = self.get_context();\n \n         if self.config.empty_item_single_line()\n-            && is_empty_block(block, None, source_map)\n+            && is_empty_block(&context, block, None)\n             && self.block_indent.width() + fn_str.len() + 3 <= self.config.max_width()\n             && !last_line_contains_single_line_comment(fn_str)\n         {\n             return Some(format!(\"{} {{}}\", fn_str));\n         }\n \n-        if !self.config.fn_single_line() || !is_simple_block_stmt(block, None, source_map) {\n+        if !self.config.fn_single_line() || !is_simple_block_stmt(&context, block, None) {\n             return None;\n         }\n "}, {"sha": "dbd9469908e3a24276c3bbf1e4b26325cb66e717", "filename": "src/lib.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -3,7 +3,6 @@\n \n #[macro_use]\n extern crate derive_new;\n-#[cfg(test)]\n #[macro_use]\n extern crate lazy_static;\n #[macro_use]\n@@ -20,14 +19,14 @@ use std::rc::Rc;\n \n use failure::Fail;\n use ignore;\n-use rustc_parse::DirectoryOwnership;\n use syntax::ast;\n \n use crate::comment::LineClasses;\n use crate::emitter::Emitter;\n use crate::formatting::{FormatErrorMap, FormattingError, ReportedErrors, SourceFile};\n use crate::issues::Issue;\n use crate::shape::Indent;\n+use crate::syntux::parser::DirectoryOwnership;\n use crate::utils::indent_next_line;\n \n pub use crate::config::{\n@@ -75,6 +74,7 @@ pub(crate) mod source_map;\n mod spanned;\n mod stmt;\n mod string;\n+mod syntux;\n #[cfg(test)]\n mod test;\n mod types;\n@@ -509,13 +509,6 @@ pub enum Input {\n }\n \n impl Input {\n-    fn is_text(&self) -> bool {\n-        match *self {\n-            Input::File(_) => false,\n-            Input::Text(_) => true,\n-        }\n-    }\n-\n     fn file_name(&self) -> FileName {\n         match *self {\n             Input::File(ref file) => FileName::Real(file.clone()),"}, {"sha": "bc55ef6686ac3ec45f50e13ea5ab0be341b0bb5c", "filename": "src/lists.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -560,7 +560,7 @@ pub(crate) struct ListItems<'a, I, F1, F2, F3>\n where\n     I: Iterator,\n {\n-    snippet_provider: &'a SnippetProvider<'a>,\n+    snippet_provider: &'a SnippetProvider,\n     inner: Peekable<I>,\n     get_lo: F1,\n     get_hi: F2,\n@@ -777,7 +777,7 @@ where\n #[allow(clippy::too_many_arguments)]\n // Creates an iterator over a list's items with associated comments.\n pub(crate) fn itemize_list<'a, T, I, F1, F2, F3>(\n-    snippet_provider: &'a SnippetProvider<'_>,\n+    snippet_provider: &'a SnippetProvider,\n     inner: I,\n     terminator: &'a str,\n     separator: &'a str,"}, {"sha": "482b680310cd248466519549489bb347ed947ef2", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -178,8 +178,8 @@ fn return_macro_parse_failure_fallback(\n     }\n \n     context.skipped_range.borrow_mut().push((\n-        context.source_map.lookup_line(span.lo()).unwrap().line,\n-        context.source_map.lookup_line(span.hi()).unwrap().line,\n+        context.parse_sess.line_of_byte_pos(span.lo()),\n+        context.parse_sess.line_of_byte_pos(span.hi()),\n     ));\n \n     // Return the snippet unmodified if the macro is not block-like\n@@ -286,7 +286,7 @@ fn rewrite_macro_inner(\n         }\n     }\n \n-    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n     let mut arg_vec = Vec::new();\n     let mut vec_with_semi = false;\n     let mut trailing_comma = false;\n@@ -1190,7 +1190,7 @@ pub(crate) fn convert_try_mac(mac: &ast::Mac, context: &RewriteContext<'_>) -> O\n     let path = &pprust::path_to_string(&mac.path);\n     if path == \"try\" || path == \"r#try\" {\n         let ts = mac.args.inner_tokens();\n-        let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+        let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n \n         Some(ast::Expr {\n             id: ast::NodeId::root(), // dummy value\n@@ -1422,7 +1422,7 @@ fn format_lazy_static(\n     ts: &TokenStream,\n ) -> Option<String> {\n     let mut result = String::with_capacity(1024);\n-    let mut parser = new_parser_from_tts(context.parse_session, ts.trees().collect());\n+    let mut parser = new_parser_from_tts(context.parse_sess.inner(), ts.trees().collect());\n     let nested_shape = shape\n         .block_indent(context.config.tab_spaces())\n         .with_max_width(context.config);"}, {"sha": "792b3bfd466f0a1da1a4a8c7253676f8c25d7b22", "filename": "src/matches.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -276,7 +276,7 @@ fn block_can_be_flattened<'a>(\n         ast::ExprKind::Block(ref block, _)\n             if !is_unsafe_block(block)\n                 && !context.inside_macro()\n-                && is_simple_block(block, Some(&expr.attrs), context.source_map) =>\n+                && is_simple_block(context, block, Some(&expr.attrs)) =>\n         {\n             Some(&*block)\n         }\n@@ -332,10 +332,7 @@ fn rewrite_match_body(\n         shape.offset_left(extra_offset(pats_str, shape) + 4),\n     );\n     let (is_block, is_empty_block) = if let ast::ExprKind::Block(ref block, _) = body.kind {\n-        (\n-            true,\n-            is_empty_block(block, Some(&body.attrs), context.source_map),\n-        )\n+        (true, is_empty_block(context, block, Some(&body.attrs)))\n     } else {\n         (false, false)\n     };"}, {"sha": "e6889ae97865b690a9174126a74ea05704657038", "filename": "src/missed_spans.rs", "status": "modified", "additions": 10, "deletions": 15, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmissed_spans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmissed_spans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmissed_spans.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -86,9 +86,8 @@ impl<'a> FmtVisitor<'a> {\n \n         assert!(\n             start < end,\n-            \"Request to format inverted span: {:?} to {:?}\",\n-            self.source_map.lookup_char_pos(start),\n-            self.source_map.lookup_char_pos(end)\n+            \"Request to format inverted span: {}\",\n+            self.parse_sess.span_to_debug_info(mk_sp(start, end)),\n         );\n \n         self.last_pos = end;\n@@ -139,26 +138,22 @@ impl<'a> FmtVisitor<'a> {\n         // Get a snippet from the file start to the span's hi without allocating.\n         // We need it to determine what precedes the current comment. If the comment\n         // follows code on the same line, we won't touch it.\n-        let big_span_lo = self.source_map.lookup_char_pos(span.lo()).file.start_pos;\n-        let local_begin = self.source_map.lookup_byte_offset(big_span_lo);\n-        let local_end = self.source_map.lookup_byte_offset(span.hi());\n-        let start_index = local_begin.pos.to_usize();\n-        let end_index = local_end.pos.to_usize();\n-        let big_snippet = &local_begin.sf.src.as_ref().unwrap()[start_index..end_index];\n-\n+        let big_span_lo = self.snippet_provider.start_pos();\n+        let big_snippet = self.snippet_provider.entire_snippet();\n         let big_diff = (span.lo() - big_span_lo).to_usize();\n+\n         let snippet = self.snippet(span);\n \n         debug!(\"write_snippet `{}`\", snippet);\n \n-        self.write_snippet_inner(big_snippet, big_diff, snippet, span, process_last_snippet);\n+        self.write_snippet_inner(big_snippet, snippet, big_diff, span, process_last_snippet);\n     }\n \n     fn write_snippet_inner<F>(\n         &mut self,\n         big_snippet: &str,\n-        big_diff: usize,\n         old_snippet: &str,\n+        big_diff: usize,\n         span: Span,\n         process_last_snippet: F,\n     ) where\n@@ -167,9 +162,9 @@ impl<'a> FmtVisitor<'a> {\n         // Trim whitespace from the right hand side of each line.\n         // Annoyingly, the library functions for splitting by lines etc. are not\n         // quite right, so we must do it ourselves.\n-        let char_pos = self.source_map.lookup_char_pos(span.lo());\n-        let file_name = &char_pos.file.name.clone().into();\n-        let mut status = SnippetStatus::new(char_pos.line);\n+        let line = self.parse_sess.line_of_byte_pos(span.lo());\n+        let file_name = &self.parse_sess.span_to_filename(span);\n+        let mut status = SnippetStatus::new(line);\n \n         let snippet = &*transform_missing_snippet(self.config, old_snippet);\n "}, {"sha": "bb0effedfa8633f0910954b1f55c8ae415bb00b7", "filename": "src/modules.rs", "status": "modified", "additions": 27, "deletions": 143, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -2,24 +2,25 @@ use std::borrow::Cow;\n use std::collections::BTreeMap;\n use std::path::{Path, PathBuf};\n \n-use rustc_errors::PResult;\n-use rustc_parse::{new_sub_parser_from_file, parser, DirectoryOwnership};\n-use rustc_session::parse::ParseSess;\n use rustc_span::symbol::{sym, Symbol};\n-use rustc_span::{source_map, Span, DUMMY_SP};\n use syntax::ast;\n-use syntax::token::TokenKind;\n use syntax::visit::Visitor;\n \n use crate::attr::MetaVisitor;\n use crate::config::FileName;\n use crate::items::is_mod_decl;\n+use crate::syntux::parser::{Directory, DirectoryOwnership, ModulePathSuccess, Parser};\n+use crate::syntux::session::ParseSess;\n use crate::utils::contains_skip;\n \n mod visitor;\n \n type FileModMap<'ast> = BTreeMap<FileName, Cow<'ast, ast::Mod>>;\n \n+lazy_static! {\n+    static ref CFG_IF: Symbol = Symbol::intern(\"cfg_if\");\n+}\n+\n /// Maps each module to the corresponding file.\n pub(crate) struct ModResolver<'ast, 'sess> {\n     parse_sess: &'sess ParseSess,\n@@ -28,21 +29,6 @@ pub(crate) struct ModResolver<'ast, 'sess> {\n     recursive: bool,\n }\n \n-#[derive(Clone)]\n-struct Directory {\n-    path: PathBuf,\n-    ownership: DirectoryOwnership,\n-}\n-\n-impl<'a> Directory {\n-    fn to_syntax_directory(&'a self) -> rustc_parse::Directory {\n-        rustc_parse::Directory {\n-            path: self.path.clone(),\n-            ownership: self.ownership.clone(),\n-        }\n-    }\n-}\n-\n #[derive(Clone)]\n enum SubModKind<'a, 'ast> {\n     /// `mod foo;`\n@@ -78,12 +64,9 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         mut self,\n         krate: &'ast ast::Crate,\n     ) -> Result<FileModMap<'ast>, String> {\n-        let root_filename = self.parse_sess.source_map().span_to_filename(krate.span);\n+        let root_filename = self.parse_sess.span_to_filename(krate.span);\n         self.directory.path = match root_filename {\n-            source_map::FileName::Real(ref path) => path\n-                .parent()\n-                .expect(\"Parent directory should exists\")\n-                .to_path_buf(),\n+            FileName::Real(ref p) => p.parent().unwrap_or(Path::new(\"\")).to_path_buf(),\n             _ => PathBuf::new(),\n         };\n \n@@ -93,14 +76,13 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         }\n \n         self.file_map\n-            .insert(root_filename.into(), Cow::Borrowed(&krate.module));\n+            .insert(root_filename, Cow::Borrowed(&krate.module));\n         Ok(self.file_map)\n     }\n \n     /// Visit `cfg_if` macro and look for module declarations.\n     fn visit_cfg_if(&mut self, item: Cow<'ast, ast::Item>) -> Result<(), String> {\n-        let mut visitor =\n-            visitor::CfgIfVisitor::new(self.parse_sess, self.directory.to_syntax_directory());\n+        let mut visitor = visitor::CfgIfVisitor::new(self.parse_sess, &self.directory);\n         visitor.visit_item(&item);\n         for module_item in visitor.mods() {\n             if let ast::ItemKind::Mod(ref sub_mod) = module_item.item.kind {\n@@ -258,31 +240,26 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         attrs: &[ast::Attribute],\n         sub_mod: &Cow<'ast, ast::Mod>,\n     ) -> Result<SubModKind<'c, 'ast>, String> {\n-        if let Some(path) = parser::Parser::submod_path_from_attr(attrs, &self.directory.path) {\n+        if let Some(path) = Parser::submod_path_from_attr(attrs, &self.directory.path) {\n             return Ok(SubModKind::External(\n                 path,\n                 DirectoryOwnership::Owned { relative: None },\n             ));\n         }\n \n         // Look for nested path, like `#[cfg_attr(feature = \"foo\", path = \"bar.rs\")]`.\n-        let mut mods_outside_ast = self\n-            .find_mods_ouside_of_ast(attrs, sub_mod)\n-            .unwrap_or(vec![]);\n+        let mut mods_outside_ast = self.find_mods_outside_of_ast(attrs, sub_mod);\n \n         let relative = match self.directory.ownership {\n             DirectoryOwnership::Owned { relative } => relative,\n             DirectoryOwnership::UnownedViaBlock | DirectoryOwnership::UnownedViaMod => None,\n         };\n-        match parser::Parser::default_submod_path(\n-            mod_name,\n-            relative,\n-            &self.directory.path,\n-            self.parse_sess.source_map(),\n-        )\n-        .result\n+        match self\n+            .parse_sess\n+            .default_submod_path(mod_name, relative, &self.directory.path)\n+            .result\n         {\n-            Ok(parser::ModulePathSuccess {\n+            Ok(ModulePathSuccess {\n                 path,\n                 directory_ownership,\n                 ..\n@@ -323,21 +300,7 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n         }\n     }\n \n-    fn find_mods_ouside_of_ast(\n-        &self,\n-        attrs: &[ast::Attribute],\n-        sub_mod: &Cow<'ast, ast::Mod>,\n-    ) -> Option<Vec<(PathBuf, DirectoryOwnership, Cow<'ast, ast::Mod>)>> {\n-        use std::panic::{catch_unwind, AssertUnwindSafe};\n-        Some(\n-            catch_unwind(AssertUnwindSafe(|| {\n-                self.find_mods_ouside_of_ast_inner(attrs, sub_mod)\n-            }))\n-            .ok()?,\n-        )\n-    }\n-\n-    fn find_mods_ouside_of_ast_inner(\n+    fn find_mods_outside_of_ast(\n         &self,\n         attrs: &[ast::Attribute],\n         sub_mod: &Cow<'ast, ast::Mod>,\n@@ -356,47 +319,24 @@ impl<'ast, 'sess, 'c> ModResolver<'ast, 'sess> {\n             if !actual_path.exists() {\n                 continue;\n             }\n-            let file_name = rustc_span::FileName::Real(actual_path.clone());\n-            if self\n-                .parse_sess\n-                .source_map()\n-                .get_source_file(&file_name)\n-                .is_some()\n-            {\n-                // If the specfied file is already parsed, then we just use that.\n+            if self.parse_sess.is_file_parsed(&actual_path) {\n+                // If the specified file is already parsed, then we just use that.\n                 result.push((\n                     actual_path,\n                     DirectoryOwnership::Owned { relative: None },\n                     sub_mod.clone(),\n                 ));\n                 continue;\n             }\n-            let mut parser = new_sub_parser_from_file(\n+            let m = match Parser::parse_file_as_module(\n+                self.directory.ownership,\n                 self.parse_sess,\n                 &actual_path,\n-                self.directory.ownership,\n-                None,\n-                DUMMY_SP,\n-            );\n-            parser.cfg_mods = false;\n-            let lo = parser.token.span;\n-            // FIXME(topecongiro) Format inner attributes (#3606).\n-            let _mod_attrs = match parse_inner_attributes(&mut parser) {\n-                Ok(attrs) => attrs,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                    continue;\n-                }\n-            };\n-            let m = match parse_mod_items(&mut parser, lo) {\n-                Ok(m) => m,\n-                Err(mut e) => {\n-                    e.cancel();\n-                    parser.sess.span_diagnostic.reset_err_count();\n-                    continue;\n-                }\n+            ) {\n+                Some(m) => m,\n+                None => continue,\n             };\n+\n             result.push((\n                 actual_path,\n                 DirectoryOwnership::Owned { relative: None },\n@@ -422,67 +362,11 @@ fn find_path_value(attrs: &[ast::Attribute]) -> Option<Symbol> {\n     attrs.iter().flat_map(path_value).next()\n }\n \n-// FIXME(topecongiro) Use the method from libsyntax[1] once it become public.\n-//\n-// [1] https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/attr.rs\n-fn parse_inner_attributes<'a>(parser: &mut parser::Parser<'a>) -> PResult<'a, Vec<ast::Attribute>> {\n-    let mut attrs: Vec<ast::Attribute> = vec![];\n-    loop {\n-        match parser.token.kind {\n-            TokenKind::Pound => {\n-                // Don't even try to parse if it's not an inner attribute.\n-                if !parser.look_ahead(1, |t| t == &TokenKind::Not) {\n-                    break;\n-                }\n-\n-                let attr = parser.parse_attribute(true)?;\n-                assert_eq!(attr.style, ast::AttrStyle::Inner);\n-                attrs.push(attr);\n-            }\n-            TokenKind::DocComment(s) => {\n-                // we need to get the position of this token before we bump.\n-                let attr = syntax::attr::mk_doc_comment(\n-                    syntax::util::comments::doc_comment_style(&s.as_str()),\n-                    s,\n-                    parser.token.span,\n-                );\n-                if attr.style == ast::AttrStyle::Inner {\n-                    attrs.push(attr);\n-                    parser.bump();\n-                } else {\n-                    break;\n-                }\n-            }\n-            _ => break,\n-        }\n-    }\n-    Ok(attrs)\n-}\n-\n-fn parse_mod_items<'a>(parser: &mut parser::Parser<'a>, inner_lo: Span) -> PResult<'a, ast::Mod> {\n-    let mut items = vec![];\n-    while let Some(item) = parser.parse_item()? {\n-        items.push(item);\n-    }\n-\n-    let hi = if parser.token.span.is_dummy() {\n-        inner_lo\n-    } else {\n-        parser.prev_token.span\n-    };\n-\n-    Ok(ast::Mod {\n-        inner: inner_lo.to(hi),\n-        items,\n-        inline: false,\n-    })\n-}\n-\n fn is_cfg_if(item: &ast::Item) -> bool {\n     match item.kind {\n         ast::ItemKind::Mac(ref mac) => {\n             if let Some(first_segment) = mac.path.segments.first() {\n-                if first_segment.ident.name == Symbol::intern(\"cfg_if\") {\n+                if first_segment.ident.name == *CFG_IF {\n                     return true;\n                 }\n             }"}, {"sha": "ad9111f7a9fefcdab873cadc4c2a159bf63c2708", "filename": "src/modules/visitor.rs", "status": "modified", "additions": 8, "deletions": 59, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmodules%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fmodules%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules%2Fvisitor.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -1,11 +1,10 @@\n-use rustc_parse::{stream_to_parser_with_base_dir, Directory};\n-use rustc_session::parse::ParseSess;\n-use rustc_span::{symbol::kw, Symbol};\n+use rustc_span::Symbol;\n use syntax::ast;\n-use syntax::token::{DelimToken, TokenKind};\n use syntax::visit::Visitor;\n \n use crate::attr::MetaVisitor;\n+use crate::syntux::parser::{Directory, Parser};\n+use crate::syntux::session::ParseSess;\n \n pub(crate) struct ModItem {\n     pub(crate) item: ast::Item,\n@@ -15,11 +14,11 @@ pub(crate) struct ModItem {\n pub(crate) struct CfgIfVisitor<'a> {\n     parse_sess: &'a ParseSess,\n     mods: Vec<ModItem>,\n-    base_dir: Directory,\n+    base_dir: &'a Directory,\n }\n \n impl<'a> CfgIfVisitor<'a> {\n-    pub(crate) fn new(parse_sess: &'a ParseSess, base_dir: Directory) -> CfgIfVisitor<'a> {\n+    pub(crate) fn new(parse_sess: &'a ParseSess, base_dir: &'a Directory) -> CfgIfVisitor<'a> {\n         CfgIfVisitor {\n             mods: vec![],\n             parse_sess,\n@@ -65,59 +64,9 @@ impl<'a, 'ast: 'a> CfgIfVisitor<'a> {\n             }\n         };\n \n-        let ts = mac.args.inner_tokens();\n-        let mut parser =\n-            stream_to_parser_with_base_dir(self.parse_sess, ts.clone(), self.base_dir.clone());\n-        parser.cfg_mods = false;\n-        let mut process_if_cfg = true;\n-\n-        while parser.token.kind != TokenKind::Eof {\n-            if process_if_cfg {\n-                if !parser.eat_keyword(kw::If) {\n-                    return Err(\"Expected `if`\");\n-                }\n-                parser\n-                    .parse_attribute(false)\n-                    .map_err(|_| \"Failed to parse attributes\")?;\n-            }\n-\n-            if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n-                return Err(\"Expected an opening brace\");\n-            }\n-\n-            while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n-                && parser.token.kind != TokenKind::Eof\n-            {\n-                let item = match parser.parse_item() {\n-                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n-                    Ok(None) => continue,\n-                    Err(mut err) => {\n-                        err.cancel();\n-                        parser.sess.span_diagnostic.reset_err_count();\n-                        return Err(\n-                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n-                        );\n-                    }\n-                };\n-                if let ast::ItemKind::Mod(..) = item.kind {\n-                    self.mods.push(ModItem { item });\n-                }\n-            }\n-\n-            if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n-                return Err(\"Expected a closing brace\");\n-            }\n-\n-            if parser.eat(&TokenKind::Eof) {\n-                break;\n-            }\n-\n-            if !parser.eat_keyword(kw::Else) {\n-                return Err(\"Expected `else`\");\n-            }\n-\n-            process_if_cfg = parser.token.is_keyword(kw::If);\n-        }\n+        let items = Parser::parse_cfg_if(self.parse_sess, mac, &self.base_dir)?;\n+        self.mods\n+            .append(&mut items.into_iter().map(|item| ModItem { item }).collect());\n \n         Ok(())\n     }"}, {"sha": "0235e552be787f0c2d58bd347fc35d44c67c158c", "filename": "src/reorder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Freorder.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -207,13 +207,13 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         item_kind: ReorderableItemKind,\n         in_group: bool,\n     ) -> usize {\n-        let mut last = self.source_map.lookup_line_range(items[0].span());\n+        let mut last = self.parse_sess.lookup_line_range(items[0].span());\n         let item_length = items\n             .iter()\n             .take_while(|ppi| {\n                 item_kind.is_same_item_kind(&***ppi)\n                     && (!in_group || {\n-                        let current = self.source_map.lookup_line_range(ppi.span());\n+                        let current = self.parse_sess.lookup_line_range(ppi.span());\n                         let in_same_group = current.lo < last.hi + 2;\n                         last = current;\n                         in_same_group"}, {"sha": "f73602f09a2aecd0a5cf41e6282ebf48d8e61e6d", "filename": "src/rewrite.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -3,13 +3,13 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_session::parse::ParseSess;\n-use rustc_span::{source_map::SourceMap, Span};\n+use rustc_span::Span;\n use syntax::ptr;\n \n use crate::config::{Config, IndentStyle};\n use crate::shape::Shape;\n use crate::skip::SkipContext;\n+use crate::syntux::session::ParseSess;\n use crate::visitor::SnippetProvider;\n use crate::FormatReport;\n \n@@ -26,8 +26,7 @@ impl<T: Rewrite> Rewrite for ptr::P<T> {\n \n #[derive(Clone)]\n pub(crate) struct RewriteContext<'a> {\n-    pub(crate) parse_session: &'a ParseSess,\n-    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) config: &'a Config,\n     pub(crate) inside_macro: Rc<Cell<bool>>,\n     // Force block indent style even if we are using visual indent style.\n@@ -37,7 +36,7 @@ pub(crate) struct RewriteContext<'a> {\n     pub(crate) is_if_else_block: Cell<bool>,\n     // When rewriting chain, veto going multi line except the last element\n     pub(crate) force_one_line_chain: Cell<bool>,\n-    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) snippet_provider: &'a SnippetProvider,\n     // Used for `format_snippet`\n     pub(crate) macro_rewrite_failure: Cell<bool>,\n     pub(crate) report: FormatReport,"}, {"sha": "4f02d8224e27bef3ef8711f3bf723360cc9c6e9c", "filename": "src/source_file.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsource_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsource_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_file.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -2,10 +2,9 @@ use std::fs;\n use std::io::{self, Write};\n use std::path::Path;\n \n-use rustc_span::source_map::SourceMap;\n-\n use crate::config::FileName;\n use crate::emitter::{self, Emitter};\n+use crate::syntux::session::ParseSess;\n use crate::NewlineStyle;\n \n #[cfg(test)]\n@@ -14,6 +13,7 @@ use crate::config::Config;\n use crate::create_emitter;\n #[cfg(test)]\n use crate::formatting::FileRecord;\n+use std::rc::Rc;\n \n // Append a newline to the end of each file.\n pub(crate) fn append_newline(s: &mut String) {\n@@ -48,7 +48,7 @@ where\n }\n \n pub(crate) fn write_file<T>(\n-    source_map: Option<&SourceMap>,\n+    parse_sess: Option<&ParseSess>,\n     filename: &FileName,\n     formatted_text: &str,\n     out: &mut T,\n@@ -84,20 +84,17 @@ where\n     // source map instead of hitting the file system. This also supports getting\n     // original text for `FileName::Stdin`.\n     let original_text = if newline_style != NewlineStyle::Auto && *filename != FileName::Stdin {\n-        fs::read_to_string(ensure_real_path(filename))?\n+        Rc::new(fs::read_to_string(ensure_real_path(filename))?)\n     } else {\n-        match source_map\n-            .and_then(|x| x.get_source_file(&filename.into()))\n-            .and_then(|x| x.src.as_ref().map(ToString::to_string))\n-        {\n+        match parse_sess.and_then(|sess| sess.get_original_snippet(filename)) {\n             Some(ori) => ori,\n-            None => fs::read_to_string(ensure_real_path(filename))?,\n+            None => Rc::new(fs::read_to_string(ensure_real_path(filename))?),\n         }\n     };\n \n     let formatted_file = emitter::FormattedFile {\n         filename,\n-        original_text: &original_text,\n+        original_text: original_text.as_str(),\n         formatted_text,\n     };\n "}, {"sha": "76e0d24cf1eb6d325cb2201e7f179888f25fbace", "filename": "src/source_map.rs", "status": "modified", "additions": 2, "deletions": 27, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsource_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsource_map.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -1,11 +1,10 @@\n //! This module contains utilities that work with the `SourceMap` from `libsyntax`/`syntex_syntax`.\n //! This includes extension traits and methods for looking up spans and line ranges for AST nodes.\n \n-use rustc_span::{source_map::SourceMap, BytePos, Span};\n+use rustc_span::{BytePos, Span};\n \n use crate::comment::FindUncommented;\n use crate::config::file_lines::LineRange;\n-use crate::utils::starts_with_newline;\n use crate::visitor::SnippetProvider;\n \n pub(crate) trait SpanUtils {\n@@ -26,7 +25,7 @@ pub(crate) trait LineRangeUtils {\n     fn lookup_line_range(&self, span: Span) -> LineRange;\n }\n \n-impl<'a> SpanUtils for SnippetProvider<'a> {\n+impl SpanUtils for SnippetProvider {\n     fn span_after(&self, original: Span, needle: &str) -> BytePos {\n         self.opt_span_after(original, needle).unwrap_or_else(|| {\n             panic!(\n@@ -81,27 +80,3 @@ impl<'a> SpanUtils for SnippetProvider<'a> {\n         Some(original.lo() + BytePos(offset as u32))\n     }\n }\n-\n-impl LineRangeUtils for SourceMap {\n-    fn lookup_line_range(&self, span: Span) -> LineRange {\n-        let snippet = self.span_to_snippet(span).unwrap_or_default();\n-        let lo = self.lookup_line(span.lo()).unwrap();\n-        let hi = self.lookup_line(span.hi()).unwrap();\n-\n-        debug_assert_eq!(\n-            lo.sf.name, hi.sf.name,\n-            \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n-            lo, hi\n-        );\n-\n-        // in case the span starts with a newline, the line range is off by 1 without the\n-        // adjustment below\n-        let offset = 1 + if starts_with_newline(&snippet) { 1 } else { 0 };\n-        // Line numbers start at 1\n-        LineRange {\n-            file: lo.sf.clone(),\n-            lo: lo.line + offset,\n-            hi: hi.line + offset,\n-        }\n-    }\n-}"}, {"sha": "845576bd8d8bb1ea5015db3c864fefcb0194b22e", "filename": "src/syntux.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -0,0 +1,4 @@\n+//! This module defines a thin abstract layer on top of the rustc's parser and syntax libraries.\n+\n+pub(crate) mod parser;\n+pub(crate) mod session;"}, {"sha": "6e3cd5e2375440a21061d53926b22fb64fcda38d", "filename": "src/syntux/parser.rs", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fparser.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -0,0 +1,348 @@\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::path::{Path, PathBuf};\n+\n+use rustc_errors::{Diagnostic, PResult};\n+use rustc_parse::{new_sub_parser_from_file, parser::Parser as RawParser};\n+use rustc_span::{symbol::kw, Span, DUMMY_SP};\n+use syntax::ast;\n+use syntax::token::{DelimToken, TokenKind};\n+\n+use crate::syntux::session::ParseSess;\n+use crate::{Config, Input};\n+\n+pub(crate) type DirectoryOwnership = rustc_parse::DirectoryOwnership;\n+pub(crate) type ModulePathSuccess = rustc_parse::parser::ModulePathSuccess;\n+\n+#[derive(Clone)]\n+pub(crate) struct Directory {\n+    pub(crate) path: PathBuf,\n+    pub(crate) ownership: DirectoryOwnership,\n+}\n+\n+impl<'a> Directory {\n+    fn to_syntax_directory(&'a self) -> rustc_parse::Directory {\n+        rustc_parse::Directory {\n+            path: self.path.clone(),\n+            ownership: self.ownership,\n+        }\n+    }\n+}\n+\n+/// A parser for Rust source code.\n+pub(crate) struct Parser<'a> {\n+    parser: RawParser<'a>,\n+    sess: &'a ParseSess,\n+}\n+\n+/// A builder for the `Parser`.\n+#[derive(Default)]\n+pub(crate) struct ParserBuilder<'a> {\n+    config: Option<&'a Config>,\n+    sess: Option<&'a ParseSess>,\n+    input: Option<Input>,\n+    directory_ownership: Option<DirectoryOwnership>,\n+}\n+\n+impl<'a> ParserBuilder<'a> {\n+    pub(crate) fn input(mut self, input: Input) -> ParserBuilder<'a> {\n+        self.input = Some(input);\n+        self\n+    }\n+\n+    pub(crate) fn sess(mut self, sess: &'a ParseSess) -> ParserBuilder<'a> {\n+        self.sess = Some(sess);\n+        self\n+    }\n+\n+    pub(crate) fn config(mut self, config: &'a Config) -> ParserBuilder<'a> {\n+        self.config = Some(config);\n+        self\n+    }\n+\n+    pub(crate) fn directory_ownership(\n+        mut self,\n+        directory_ownership: Option<DirectoryOwnership>,\n+    ) -> ParserBuilder<'a> {\n+        self.directory_ownership = directory_ownership;\n+        self\n+    }\n+\n+    pub(crate) fn build(self) -> Result<Parser<'a>, ParserError> {\n+        let config = self.config.ok_or(ParserError::NoConfig)?;\n+        let sess = self.sess.ok_or(ParserError::NoParseSess)?;\n+        let input = self.input.ok_or(ParserError::NoInput)?;\n+\n+        let mut parser = match Self::parser(sess.inner(), input, self.directory_ownership) {\n+            Ok(p) => p,\n+            Err(db) => {\n+                sess.emit_diagnostics(db);\n+                return Err(ParserError::ParserCreationError);\n+            }\n+        };\n+\n+        parser.cfg_mods = false;\n+        if config.skip_children() {\n+            parser.recurse_into_file_modules = false;\n+        }\n+\n+        Ok(Parser { parser, sess })\n+    }\n+\n+    fn parser(\n+        sess: &'a rustc_session::parse::ParseSess,\n+        input: Input,\n+        directory_ownership: Option<DirectoryOwnership>,\n+    ) -> Result<rustc_parse::parser::Parser<'a>, Vec<Diagnostic>> {\n+        match input {\n+            Input::File(ref file) => Ok(if let Some(directory_ownership) = directory_ownership {\n+                rustc_parse::new_sub_parser_from_file(\n+                    sess,\n+                    file,\n+                    directory_ownership,\n+                    None,\n+                    DUMMY_SP,\n+                )\n+            } else {\n+                rustc_parse::new_parser_from_file(sess, file)\n+            }),\n+            Input::Text(text) => rustc_parse::maybe_new_parser_from_source_str(\n+                sess,\n+                rustc_span::FileName::Custom(\"stdin\".to_owned()),\n+                text,\n+            )\n+            .map(|mut parser| {\n+                parser.recurse_into_file_modules = false;\n+                parser\n+            }),\n+        }\n+    }\n+}\n+\n+#[derive(Debug, PartialEq)]\n+pub(crate) enum ParserError {\n+    NoConfig,\n+    NoParseSess,\n+    NoInput,\n+    ParserCreationError,\n+    ParseError,\n+    ParsePanicError,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub(crate) fn submod_path_from_attr(attrs: &[ast::Attribute], path: &Path) -> Option<PathBuf> {\n+        rustc_parse::parser::Parser::submod_path_from_attr(attrs, path)\n+    }\n+\n+    // FIXME(topecongiro) Use the method from libsyntax[1] once it become public.\n+    //\n+    // [1] https://github.com/rust-lang/rust/blob/master/src/libsyntax/parse/attr.rs\n+    fn parse_inner_attrs(parser: &mut RawParser<'a>) -> PResult<'a, Vec<ast::Attribute>> {\n+        let mut attrs: Vec<ast::Attribute> = vec![];\n+        loop {\n+            match parser.token.kind {\n+                TokenKind::Pound => {\n+                    // Don't even try to parse if it's not an inner attribute.\n+                    if !parser.look_ahead(1, |t| t == &TokenKind::Not) {\n+                        break;\n+                    }\n+\n+                    let attr = parser.parse_attribute(true)?;\n+                    assert_eq!(attr.style, ast::AttrStyle::Inner);\n+                    attrs.push(attr);\n+                }\n+                TokenKind::DocComment(s) => {\n+                    // we need to get the position of this token before we bump.\n+                    let attr = syntax::attr::mk_doc_comment(\n+                        syntax::util::comments::doc_comment_style(&s.as_str()),\n+                        s,\n+                        parser.token.span,\n+                    );\n+                    if attr.style == ast::AttrStyle::Inner {\n+                        attrs.push(attr);\n+                        parser.bump();\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        Ok(attrs)\n+    }\n+\n+    fn parse_mod_items(parser: &mut RawParser<'a>, span: Span) -> PResult<'a, ast::Mod> {\n+        let mut items = vec![];\n+        while let Some(item) = parser.parse_item()? {\n+            items.push(item);\n+        }\n+\n+        let hi = if parser.token.span.is_dummy() {\n+            span\n+        } else {\n+            parser.prev_token.span\n+        };\n+\n+        Ok(ast::Mod {\n+            inner: span.to(hi),\n+            items,\n+            inline: false,\n+        })\n+    }\n+\n+    pub(crate) fn parse_file_as_module(\n+        directory_ownership: DirectoryOwnership,\n+        sess: &'a ParseSess,\n+        path: &Path,\n+    ) -> Option<ast::Mod> {\n+        let result = catch_unwind(AssertUnwindSafe(|| {\n+            let mut parser =\n+                new_sub_parser_from_file(sess.inner(), &path, directory_ownership, None, DUMMY_SP);\n+\n+            parser.cfg_mods = false;\n+            let lo = parser.token.span;\n+            // FIXME(topecongiro) Format inner attributes (#3606).\n+            match Parser::parse_inner_attrs(&mut parser) {\n+                Ok(_attrs) => (),\n+                Err(mut e) => {\n+                    e.cancel();\n+                    sess.reset_errors();\n+                    return None;\n+                }\n+            }\n+\n+            match Parser::parse_mod_items(&mut parser, lo) {\n+                Ok(m) => Some(m),\n+                Err(mut db) => {\n+                    db.cancel();\n+                    sess.reset_errors();\n+                    None\n+                }\n+            }\n+        }));\n+        match result {\n+            Ok(Some(m)) => Some(m),\n+            _ => None,\n+        }\n+    }\n+\n+    pub(crate) fn parse_crate(\n+        config: &'a Config,\n+        input: Input,\n+        directory_ownership: Option<DirectoryOwnership>,\n+        sess: &'a ParseSess,\n+    ) -> Result<ast::Crate, ParserError> {\n+        let mut parser = ParserBuilder::default()\n+            .config(config)\n+            .input(input)\n+            .directory_ownership(directory_ownership)\n+            .sess(sess)\n+            .build()?;\n+\n+        parser.parse_crate_inner()\n+    }\n+\n+    fn parse_crate_inner(&mut self) -> Result<ast::Crate, ParserError> {\n+        let mut parser = AssertUnwindSafe(&mut self.parser);\n+\n+        match catch_unwind(move || parser.parse_crate_mod()) {\n+            Ok(Ok(krate)) => {\n+                if !self.sess.has_errors() {\n+                    return Ok(krate);\n+                }\n+\n+                if self.sess.can_reset_errors() {\n+                    self.sess.reset_errors();\n+                    return Ok(krate);\n+                }\n+\n+                Err(ParserError::ParseError)\n+            }\n+            Ok(Err(mut db)) => {\n+                db.emit();\n+                Err(ParserError::ParseError)\n+            }\n+            Err(_) => Err(ParserError::ParsePanicError),\n+        }\n+    }\n+\n+    pub(crate) fn parse_cfg_if(\n+        sess: &'a ParseSess,\n+        mac: &'a ast::Mac,\n+        base_dir: &Directory,\n+    ) -> Result<Vec<ast::Item>, &'static str> {\n+        match catch_unwind(AssertUnwindSafe(|| {\n+            Parser::parse_cfg_if_inner(sess, mac, base_dir)\n+        })) {\n+            Ok(Ok(items)) => Ok(items),\n+            Ok(err @ Err(_)) => err,\n+            Err(..) => Err(\"failed to parse cfg_if!\"),\n+        }\n+    }\n+\n+    fn parse_cfg_if_inner(\n+        sess: &'a ParseSess,\n+        mac: &'a ast::Mac,\n+        base_dir: &Directory,\n+    ) -> Result<Vec<ast::Item>, &'static str> {\n+        let token_stream = mac.args.inner_tokens();\n+        let mut parser = rustc_parse::stream_to_parser_with_base_dir(\n+            sess.inner(),\n+            token_stream.clone(),\n+            base_dir.to_syntax_directory(),\n+        );\n+\n+        parser.cfg_mods = false;\n+        let mut items = vec![];\n+        let mut process_if_cfg = true;\n+\n+        while parser.token.kind != TokenKind::Eof {\n+            if process_if_cfg {\n+                if !parser.eat_keyword(kw::If) {\n+                    return Err(\"Expected `if`\");\n+                }\n+                parser\n+                    .parse_attribute(false)\n+                    .map_err(|_| \"Failed to parse attributes\")?;\n+            }\n+\n+            if !parser.eat(&TokenKind::OpenDelim(DelimToken::Brace)) {\n+                return Err(\"Expected an opening brace\");\n+            }\n+\n+            while parser.token != TokenKind::CloseDelim(DelimToken::Brace)\n+                && parser.token.kind != TokenKind::Eof\n+            {\n+                let item = match parser.parse_item() {\n+                    Ok(Some(item_ptr)) => item_ptr.into_inner(),\n+                    Ok(None) => continue,\n+                    Err(mut err) => {\n+                        err.cancel();\n+                        parser.sess.span_diagnostic.reset_err_count();\n+                        return Err(\n+                            \"Expected item inside cfg_if block, but failed to parse it as an item\",\n+                        );\n+                    }\n+                };\n+                if let ast::ItemKind::Mod(..) = item.kind {\n+                    items.push(item);\n+                }\n+            }\n+\n+            if !parser.eat(&TokenKind::CloseDelim(DelimToken::Brace)) {\n+                return Err(\"Expected a closing brace\");\n+            }\n+\n+            if parser.eat(&TokenKind::Eof) {\n+                break;\n+            }\n+\n+            if !parser.eat_keyword(kw::Else) {\n+                return Err(\"Expected `else`\");\n+            }\n+\n+            process_if_cfg = parser.token.is_keyword(kw::If);\n+        }\n+\n+        Ok(items)\n+    }\n+}"}, {"sha": "9ec85efb1096a8254f8e279a3a0efed0d085cb01", "filename": "src/syntux/session.rs", "status": "added", "additions": 440, "deletions": 0, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux%2Fsession.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fsyntux%2Fsession.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsyntux%2Fsession.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -0,0 +1,440 @@\n+use std::cell::RefCell;\n+use std::path::Path;\n+use std::rc::Rc;\n+\n+use rustc_data_structures::sync::{Lrc, Send};\n+use rustc_errors::emitter::{Emitter, EmitterWriter};\n+use rustc_errors::{ColorConfig, Diagnostic, Handler, Level as DiagnosticLevel};\n+use rustc_session::parse::ParseSess as RawParseSess;\n+use rustc_span::{\n+    source_map::{FilePathMapping, SourceMap},\n+    BytePos, Span,\n+};\n+use syntax::ast;\n+\n+use crate::config::file_lines::LineRange;\n+use crate::ignore_path::IgnorePathSet;\n+use crate::source_map::LineRangeUtils;\n+use crate::utils::starts_with_newline;\n+use crate::visitor::SnippetProvider;\n+use crate::{Config, ErrorKind, FileName};\n+\n+/// ParseSess holds structs necessary for constructing a parser.\n+pub(crate) struct ParseSess {\n+    parse_sess: RawParseSess,\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    can_reset_errors: Rc<RefCell<bool>>,\n+}\n+\n+/// Emitter which discards every error.\n+struct SilentEmitter;\n+\n+impl Emitter for SilentEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+    fn emit_diagnostic(&mut self, _db: &Diagnostic) {}\n+}\n+\n+fn silent_emitter() -> Box<dyn Emitter + Send> {\n+    Box::new(SilentEmitter {})\n+}\n+\n+/// Emit errors against every files expect ones specified in the `ignore_path_set`.\n+struct SilentOnIgnoredFilesEmitter {\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    source_map: Rc<SourceMap>,\n+    emitter: Box<dyn Emitter + Send>,\n+    has_non_ignorable_parser_errors: bool,\n+    can_reset: Rc<RefCell<bool>>,\n+}\n+\n+impl SilentOnIgnoredFilesEmitter {\n+    fn handle_non_ignoreable_error(&mut self, db: &Diagnostic) {\n+        self.has_non_ignorable_parser_errors = true;\n+        *self.can_reset.borrow_mut() = false;\n+        self.emitter.emit_diagnostic(db);\n+    }\n+}\n+\n+impl Emitter for SilentOnIgnoredFilesEmitter {\n+    fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+        None\n+    }\n+    fn emit_diagnostic(&mut self, db: &Diagnostic) {\n+        if db.level == DiagnosticLevel::Fatal {\n+            return self.handle_non_ignoreable_error(db);\n+        }\n+        if let Some(primary_span) = &db.span.primary_span() {\n+            let file_name = self.source_map.span_to_filename(*primary_span);\n+            if let rustc_span::FileName::Real(ref path) = file_name {\n+                if self\n+                    .ignore_path_set\n+                    .is_match(&FileName::Real(path.to_path_buf()))\n+                {\n+                    if !self.has_non_ignorable_parser_errors {\n+                        *self.can_reset.borrow_mut() = true;\n+                    }\n+                    return;\n+                }\n+            };\n+        }\n+        self.handle_non_ignoreable_error(db);\n+    }\n+}\n+\n+fn default_handler(\n+    source_map: Rc<SourceMap>,\n+    ignore_path_set: Rc<IgnorePathSet>,\n+    can_reset: Rc<RefCell<bool>>,\n+    hide_parse_errors: bool,\n+) -> Handler {\n+    let supports_color = term::stderr().map_or(false, |term| term.supports_color());\n+    let color_cfg = if supports_color {\n+        ColorConfig::Auto\n+    } else {\n+        ColorConfig::Never\n+    };\n+\n+    let emitter = if hide_parse_errors {\n+        silent_emitter()\n+    } else {\n+        Box::new(EmitterWriter::stderr(\n+            color_cfg,\n+            Some(source_map.clone()),\n+            false,\n+            false,\n+            None,\n+            false,\n+        ))\n+    };\n+    Handler::with_emitter(\n+        true,\n+        None,\n+        Box::new(SilentOnIgnoredFilesEmitter {\n+            has_non_ignorable_parser_errors: false,\n+            source_map,\n+            emitter,\n+            ignore_path_set,\n+            can_reset,\n+        }),\n+    )\n+}\n+\n+impl ParseSess {\n+    pub(crate) fn new(config: &Config) -> Result<ParseSess, ErrorKind> {\n+        let ignore_path_set = match IgnorePathSet::from_ignore_list(&config.ignore()) {\n+            Ok(ignore_path_set) => Rc::new(ignore_path_set),\n+            Err(e) => return Err(ErrorKind::InvalidGlobPattern(e)),\n+        };\n+        let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+        let can_reset_errors = Rc::new(RefCell::new(false));\n+\n+        let handler = default_handler(\n+            Rc::clone(&source_map),\n+            Rc::clone(&ignore_path_set),\n+            Rc::clone(&can_reset_errors),\n+            config.hide_parse_errors(),\n+        );\n+        let parse_sess = RawParseSess::with_span_handler(handler, source_map);\n+\n+        Ok(ParseSess {\n+            parse_sess,\n+            ignore_path_set,\n+            can_reset_errors,\n+        })\n+    }\n+\n+    pub(crate) fn default_submod_path(\n+        &self,\n+        id: ast::Ident,\n+        relative: Option<ast::Ident>,\n+        dir_path: &Path,\n+    ) -> rustc_parse::parser::ModulePath {\n+        rustc_parse::parser::Parser::default_submod_path(\n+            id,\n+            relative,\n+            dir_path,\n+            self.parse_sess.source_map(),\n+        )\n+    }\n+\n+    pub(crate) fn is_file_parsed(&self, path: &Path) -> bool {\n+        self.parse_sess\n+            .source_map()\n+            .get_source_file(&rustc_span::FileName::Real(path.to_path_buf()))\n+            .is_some()\n+    }\n+\n+    pub(crate) fn ignore_file(&self, path: &FileName) -> bool {\n+        self.ignore_path_set.as_ref().is_match(&path)\n+    }\n+\n+    pub(crate) fn set_silent_emitter(&mut self) {\n+        self.parse_sess.span_diagnostic = Handler::with_emitter(true, None, silent_emitter());\n+    }\n+\n+    pub(crate) fn span_to_filename(&self, span: Span) -> FileName {\n+        self.parse_sess.source_map().span_to_filename(span).into()\n+    }\n+\n+    pub(crate) fn span_to_first_line_string(&self, span: Span) -> String {\n+        let file_lines = self.parse_sess.source_map().span_to_lines(span).ok();\n+\n+        match file_lines {\n+            Some(fl) => fl\n+                .file\n+                .get_line(fl.lines[0].line_index)\n+                .map_or_else(String::new, |s| s.to_string()),\n+            None => String::new(),\n+        }\n+    }\n+\n+    pub(crate) fn line_of_byte_pos(&self, pos: BytePos) -> usize {\n+        self.parse_sess.source_map().lookup_char_pos(pos).line\n+    }\n+\n+    pub(crate) fn span_to_debug_info(&self, span: Span) -> String {\n+        self.parse_sess.source_map().span_to_string(span)\n+    }\n+\n+    pub(crate) fn inner(&self) -> &RawParseSess {\n+        &self.parse_sess\n+    }\n+\n+    pub(crate) fn snippet_provider(&self, span: Span) -> SnippetProvider {\n+        let source_file = self.parse_sess.source_map().lookup_char_pos(span.lo()).file;\n+        SnippetProvider::new(\n+            source_file.start_pos,\n+            source_file.end_pos,\n+            Rc::clone(source_file.src.as_ref().unwrap()),\n+        )\n+    }\n+\n+    pub(crate) fn get_original_snippet(&self, file_name: &FileName) -> Option<Rc<String>> {\n+        self.parse_sess\n+            .source_map()\n+            .get_source_file(&file_name.into())\n+            .and_then(|source_file| source_file.src.clone())\n+    }\n+}\n+\n+// Methods that should be restricted within the syntux module.\n+impl ParseSess {\n+    pub(super) fn emit_diagnostics(&self, diagnostics: Vec<Diagnostic>) {\n+        for diagnostic in diagnostics {\n+            self.parse_sess.span_diagnostic.emit_diagnostic(&diagnostic);\n+        }\n+    }\n+\n+    pub(super) fn can_reset_errors(&self) -> bool {\n+        *self.can_reset_errors.borrow()\n+    }\n+\n+    pub(super) fn has_errors(&self) -> bool {\n+        self.parse_sess.span_diagnostic.has_errors()\n+    }\n+\n+    pub(super) fn reset_errors(&self) {\n+        self.parse_sess.span_diagnostic.reset_err_count();\n+    }\n+}\n+\n+impl LineRangeUtils for ParseSess {\n+    fn lookup_line_range(&self, span: Span) -> LineRange {\n+        let snippet = self\n+            .parse_sess\n+            .source_map()\n+            .span_to_snippet(span)\n+            .unwrap_or_default();\n+        let lo = self.parse_sess.source_map().lookup_line(span.lo()).unwrap();\n+        let hi = self.parse_sess.source_map().lookup_line(span.hi()).unwrap();\n+\n+        debug_assert_eq!(\n+            lo.sf.name, hi.sf.name,\n+            \"span crossed file boundary: lo: {:?}, hi: {:?}\",\n+            lo, hi\n+        );\n+\n+        // in case the span starts with a newline, the line range is off by 1 without the\n+        // adjustment below\n+        let offset = 1 + if starts_with_newline(&snippet) { 1 } else { 0 };\n+        // Line numbers start at 1\n+        LineRange {\n+            file: lo.sf.clone(),\n+            lo: lo.line + offset,\n+            hi: hi.line + offset,\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    mod emitter {\n+        use super::*;\n+        use crate::config::IgnoreList;\n+        use crate::is_nightly_channel;\n+        use crate::utils::mk_sp;\n+        use rustc_span::{FileName as SourceMapFileName, MultiSpan, DUMMY_SP};\n+        use std::path::PathBuf;\n+\n+        struct TestEmitter {\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+        }\n+\n+        impl Emitter for TestEmitter {\n+            fn source_map(&self) -> Option<&Lrc<SourceMap>> {\n+                None\n+            }\n+            fn emit_diagnostic(&mut self, _db: &Diagnostic) {\n+                *self.num_emitted_errors.borrow_mut() += 1;\n+            }\n+        }\n+\n+        fn build_diagnostic(level: DiagnosticLevel, span: Option<MultiSpan>) -> Diagnostic {\n+            Diagnostic {\n+                level,\n+                code: None,\n+                message: vec![],\n+                children: vec![],\n+                suggestions: vec![],\n+                span: span.unwrap_or_else(MultiSpan::new),\n+                sort_span: DUMMY_SP,\n+            }\n+        }\n+\n+        fn build_emitter(\n+            num_emitted_errors: Rc<RefCell<u32>>,\n+            can_reset: Rc<RefCell<bool>>,\n+            source_map: Option<Rc<SourceMap>>,\n+            ignore_list: Option<IgnoreList>,\n+        ) -> SilentOnIgnoredFilesEmitter {\n+            let emitter_writer = TestEmitter { num_emitted_errors };\n+            let source_map =\n+                source_map.unwrap_or_else(|| Rc::new(SourceMap::new(FilePathMapping::empty())));\n+            let ignore_path_set =\n+                Rc::new(IgnorePathSet::from_ignore_list(&ignore_list.unwrap_or_default()).unwrap());\n+            SilentOnIgnoredFilesEmitter {\n+                has_non_ignorable_parser_errors: false,\n+                source_map,\n+                emitter: Box::new(emitter_writer),\n+                ignore_path_set,\n+                can_reset,\n+            }\n+        }\n+\n+        fn get_ignore_list(config: &str) -> IgnoreList {\n+            Config::from_toml(config, Path::new(\"\")).unwrap().ignore()\n+        }\n+\n+        #[test]\n+        fn handles_fatal_parse_error_in_ignored_file() {\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, Some(span));\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 0);\n+            assert_eq!(*can_reset_errors.borrow(), true);\n+        }\n+\n+        #[test]\n+        fn handles_recoverable_parse_error_in_non_ignored_file() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            source_map.new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), source);\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                None,\n+            );\n+            let span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let non_fatal_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(span));\n+            emitter.emit_diagnostic(&non_fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 1);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+\n+        #[test]\n+        fn handles_mix_of_recoverable_parse_error() {\n+            if !is_nightly_channel!() {\n+                return;\n+            }\n+            let num_emitted_errors = Rc::new(RefCell::new(0));\n+            let can_reset_errors = Rc::new(RefCell::new(false));\n+            let source_map = Rc::new(SourceMap::new(FilePathMapping::empty()));\n+            let ignore_list = get_ignore_list(r#\"ignore = [\"foo.rs\"]\"#);\n+            let bar_source = String::from(r#\"pub fn bar() { 1x; }\"#);\n+            let foo_source = String::from(r#\"pub fn foo() { 1x; }\"#);\n+            let fatal_source =\n+                String::from(r#\"extern \"system\" fn jni_symbol!( funcName ) ( ... ) -> {} \"#);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"bar.rs\")), bar_source);\n+            source_map\n+                .new_source_file(SourceMapFileName::Real(PathBuf::from(\"foo.rs\")), foo_source);\n+            source_map.new_source_file(\n+                SourceMapFileName::Real(PathBuf::from(\"fatal.rs\")),\n+                fatal_source,\n+            );\n+            let mut emitter = build_emitter(\n+                Rc::clone(&num_emitted_errors),\n+                Rc::clone(&can_reset_errors),\n+                Some(Rc::clone(&source_map)),\n+                Some(ignore_list),\n+            );\n+            let bar_span = MultiSpan::from_span(mk_sp(BytePos(0), BytePos(1)));\n+            let foo_span = MultiSpan::from_span(mk_sp(BytePos(21), BytePos(22)));\n+            let bar_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(bar_span));\n+            let foo_diagnostic = build_diagnostic(DiagnosticLevel::Warning, Some(foo_span));\n+            let fatal_diagnostic = build_diagnostic(DiagnosticLevel::Fatal, None);\n+            emitter.emit_diagnostic(&bar_diagnostic);\n+            emitter.emit_diagnostic(&foo_diagnostic);\n+            emitter.emit_diagnostic(&fatal_diagnostic);\n+            assert_eq!(*num_emitted_errors.borrow(), 2);\n+            assert_eq!(*can_reset_errors.borrow(), false);\n+        }\n+    }\n+}"}, {"sha": "7e287a4b80a04ba9fbd0c5352cdc26ab0d6fc238", "filename": "src/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -355,7 +355,7 @@ macro_rules! out_of_file_lines_range {\n             && !$self\n                 .config\n                 .file_lines()\n-                .intersects(&$self.source_map.lookup_line_range($span))\n+                .intersects(&$self.parse_sess.lookup_line_range($span))\n     };\n }\n "}, {"sha": "fe489f32a16938165ad635b80573ba94a313ec1f", "filename": "src/visitor.rs", "status": "modified", "additions": 34, "deletions": 39, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=bd5dff4012a73ad4c5eb5db1dbb111bd92ed31dd", "patch": "@@ -1,11 +1,7 @@\n use std::cell::{Cell, RefCell};\n use std::rc::Rc;\n \n-use rustc_session::parse::ParseSess;\n-use rustc_span::{\n-    source_map::{self, SourceMap},\n-    BytePos, Pos, Span,\n-};\n+use rustc_span::{BytePos, Pos, Span};\n use syntax::token::DelimToken;\n use syntax::{ast, visit};\n \n@@ -27,30 +23,31 @@ use crate::skip::{is_skip_attr, SkipContext};\n use crate::source_map::{LineRangeUtils, SpanUtils};\n use crate::spanned::Spanned;\n use crate::stmt::Stmt;\n+use crate::syntux::session::ParseSess;\n use crate::utils::{\n     self, contains_skip, count_newlines, depr_skip_annotation, inner_attributes, last_line_width,\n     mk_sp, ptr_vec_to_ref_vec, rewrite_ident, stmt_expr,\n };\n use crate::{ErrorKind, FormatReport, FormattingError};\n \n /// Creates a string slice corresponding to the specified span.\n-pub(crate) struct SnippetProvider<'a> {\n+pub(crate) struct SnippetProvider {\n     /// A pointer to the content of the file we are formatting.\n-    big_snippet: &'a str,\n+    big_snippet: Rc<String>,\n     /// A position of the start of `big_snippet`, used as an offset.\n     start_pos: usize,\n     /// A end position of the file that this snippet lives.\n     end_pos: usize,\n }\n \n-impl<'a> SnippetProvider<'a> {\n+impl SnippetProvider {\n     pub(crate) fn span_to_snippet(&self, span: Span) -> Option<&str> {\n         let start_index = span.lo().to_usize().checked_sub(self.start_pos)?;\n         let end_index = span.hi().to_usize().checked_sub(self.start_pos)?;\n         Some(&self.big_snippet[start_index..end_index])\n     }\n \n-    pub(crate) fn new(start_pos: BytePos, end_pos: BytePos, big_snippet: &'a str) -> Self {\n+    pub(crate) fn new(start_pos: BytePos, end_pos: BytePos, big_snippet: Rc<String>) -> Self {\n         let start_pos = start_pos.to_usize();\n         let end_pos = end_pos.to_usize();\n         SnippetProvider {\n@@ -60,22 +57,29 @@ impl<'a> SnippetProvider<'a> {\n         }\n     }\n \n+    pub(crate) fn entire_snippet(&self) -> &str {\n+        self.big_snippet.as_str()\n+    }\n+\n+    pub(crate) fn start_pos(&self) -> BytePos {\n+        BytePos::from_usize(self.start_pos)\n+    }\n+\n     pub(crate) fn end_pos(&self) -> BytePos {\n         BytePos::from_usize(self.end_pos)\n     }\n }\n \n pub(crate) struct FmtVisitor<'a> {\n     parent_context: Option<&'a RewriteContext<'a>>,\n-    pub(crate) parse_session: &'a ParseSess,\n-    pub(crate) source_map: &'a SourceMap,\n+    pub(crate) parse_sess: &'a ParseSess,\n     pub(crate) buffer: String,\n     pub(crate) last_pos: BytePos,\n     // FIXME: use an RAII util or closure for indenting\n     pub(crate) block_indent: Indent,\n     pub(crate) config: &'a Config,\n     pub(crate) is_if_else_block: bool,\n-    pub(crate) snippet_provider: &'a SnippetProvider<'a>,\n+    pub(crate) snippet_provider: &'a SnippetProvider,\n     pub(crate) line_number: usize,\n     /// List of 1-based line ranges which were annotated with skip\n     /// Both bounds are inclusifs.\n@@ -110,10 +114,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     fn visit_stmt(&mut self, stmt: &Stmt<'_>) {\n         debug!(\n-            \"visit_stmt: {:?} {:?} `{}`\",\n-            self.source_map.lookup_char_pos(stmt.span().lo()),\n-            self.source_map.lookup_char_pos(stmt.span().hi()),\n-            self.snippet(stmt.span()),\n+            \"visit_stmt: {}\",\n+            self.parse_sess.span_to_debug_info(stmt.span())\n         );\n \n         // https://github.com/rust-lang/rust/issues/63679.\n@@ -201,9 +203,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         has_braces: bool,\n     ) {\n         debug!(\n-            \"visit_block: {:?} {:?}\",\n-            self.source_map.lookup_char_pos(b.span.lo()),\n-            self.source_map.lookup_char_pos(b.span.hi())\n+            \"visit_block: {}\",\n+            self.parse_sess.span_to_debug_info(b.span),\n         );\n \n         // Check if this block has braces.\n@@ -744,10 +745,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         // do not take into account the lines with attributes as part of the skipped range\n         let attrs_end = attrs\n             .iter()\n-            .map(|attr| self.source_map.lookup_char_pos(attr.span.hi()).line)\n+            .map(|attr| self.parse_sess.line_of_byte_pos(attr.span.hi()))\n             .max()\n             .unwrap_or(1);\n-        let first_line = self.source_map.lookup_char_pos(main_span.lo()).line;\n+        let first_line = self.parse_sess.line_of_byte_pos(main_span.lo());\n         // Statement can start after some newlines and/or spaces\n         // or it can be on the same line as the last attribute.\n         // So here we need to take a minimum between the two.\n@@ -758,8 +759,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     }\n \n     pub(crate) fn from_context(ctx: &'a RewriteContext<'_>) -> FmtVisitor<'a> {\n-        let mut visitor = FmtVisitor::from_source_map(\n-            ctx.parse_session,\n+        let mut visitor = FmtVisitor::from_parse_sess(\n+            ctx.parse_sess,\n             ctx.config,\n             ctx.snippet_provider,\n             ctx.report.clone(),\n@@ -769,16 +770,15 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         visitor\n     }\n \n-    pub(crate) fn from_source_map(\n+    pub(crate) fn from_parse_sess(\n         parse_session: &'a ParseSess,\n         config: &'a Config,\n-        snippet_provider: &'a SnippetProvider<'_>,\n+        snippet_provider: &'a SnippetProvider,\n         report: FormatReport,\n     ) -> FmtVisitor<'a> {\n         FmtVisitor {\n             parent_context: None,\n-            parse_session,\n-            source_map: parse_session.source_map(),\n+            parse_sess: parse_session,\n             buffer: String::with_capacity(snippet_provider.big_snippet.len() * 2),\n             last_pos: BytePos(0),\n             block_indent: Indent::empty(),\n@@ -805,12 +805,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n     pub(crate) fn visit_attrs(&mut self, attrs: &[ast::Attribute], style: ast::AttrStyle) -> bool {\n         for attr in attrs {\n             if attr.check_name(depr_skip_annotation()) {\n-                let file_name = self.source_map.span_to_filename(attr.span).into();\n+                let file_name = self.parse_sess.span_to_filename(attr.span);\n                 self.report.append(\n                     file_name,\n                     vec![FormattingError::from_span(\n                         attr.span,\n-                        &self.source_map,\n+                        self.parse_sess,\n                         ErrorKind::DeprecatedAttr,\n                     )],\n                 );\n@@ -819,12 +819,12 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n                     ast::AttrKind::Normal(ref attribute_item)\n                         if self.is_unknown_rustfmt_attr(&attribute_item.path.segments) =>\n                     {\n-                        let file_name = self.source_map.span_to_filename(attr.span).into();\n+                        let file_name = self.parse_sess.span_to_filename(attr.span);\n                         self.report.append(\n                             file_name,\n                             vec![FormattingError::from_span(\n                                 attr.span,\n-                                self.source_map,\n+                                self.parse_sess,\n                                 ErrorKind::BadAttr,\n                             )],\n                         );\n@@ -932,14 +932,10 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         }\n     }\n \n-    pub(crate) fn format_separate_mod(\n-        &mut self,\n-        m: &ast::Mod,\n-        source_file: &source_map::SourceFile,\n-    ) {\n+    pub(crate) fn format_separate_mod(&mut self, m: &ast::Mod, end_pos: BytePos) {\n         self.block_indent = Indent::empty();\n         self.walk_mod_items(m);\n-        self.format_missing_with_indent(source_file.end_pos);\n+        self.format_missing_with_indent(end_pos);\n     }\n \n     pub(crate) fn skip_empty_lines(&mut self, end_pos: BytePos) {\n@@ -970,8 +966,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n \n     pub(crate) fn get_context(&self) -> RewriteContext<'_> {\n         RewriteContext {\n-            parse_session: self.parse_session,\n-            source_map: self.source_map,\n+            parse_sess: self.parse_sess,\n             config: self.config,\n             inside_macro: Rc::new(Cell::new(false)),\n             use_block: Cell::new(false),"}]}