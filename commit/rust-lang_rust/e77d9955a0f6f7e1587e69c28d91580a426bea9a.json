{"sha": "e77d9955a0f6f7e1587e69c28d91580a426bea9a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU3N2Q5OTU1YTBmNmY3ZTE1ODdlNjljMjhkOTE1ODBhNDI2YmVhOWE=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-08-14T15:59:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-14T15:59:12Z"}, "message": "Rollup merge of #53246 - ljedrz:cleanup_various, r=kennytm\n\nA few cleanups\n\n- change `skip(1).next()` to `nth(1)`\n- collapse some `if-else` expressions\n- remove a few explicit `return`s\n- remove an unnecessary field name\n- dereference once instead of matching on multiple references\n- prefer `iter().enumerate()` to indexing with `for`\n- remove some unnecessary lifetime annotations\n- use `writeln!()` instead of `write!()`+`\\n`\n- remove redundant parentheses\n- shorten some enum variant names\n- a few other cleanups suggested by `clippy`", "tree": {"sha": "0ffea17d7694c0ad63b5d6496962db24814b6719", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0ffea17d7694c0ad63b5d6496962db24814b6719"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e77d9955a0f6f7e1587e69c28d91580a426bea9a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbcvxQCRBK7hj4Ov3rIwAAdHIIAKBMicpXPhQuY8bKJ/PPERAG\nV3sODFLbR0NW8adccLeggPMqaudOQHbGT88GO1Z22ZTQMPkjfT5yxT0CGneWizHr\n5Ci0hsydibobwObxg12tNEwCqt2J6g1BG0NqJQpVMUExTSO0OHITCm35Vi6b1EUo\n5GAe7lxKdPBoGSRUwjd/oTK076iBtHEqKI1CaTb0m6/7U/JMp2GQlVqomKNrf7IU\n0m4ZRJE2JfhrIVk57jEX5azucND9hNwRhhDjORDOeVMYdszhnFcpthR32RqV28W0\nAvsmB4v8ra+tqaHr1i3EXUhvVOJmwL+1UujtrRp1yVjCEQ6E7fwUt/SURiLVUfk=\n=vxNa\n-----END PGP SIGNATURE-----\n", "payload": "tree 0ffea17d7694c0ad63b5d6496962db24814b6719\nparent 764755b0b0367fcd79133f783efaebd7bcfb82a0\nparent 535bd13fe432aacccfbce058eed9b0b71aa8fab0\nauthor kennytm <kennytm@gmail.com> 1534262352 +0800\ncommitter GitHub <noreply@github.com> 1534262352 +0800\n\nRollup merge of #53246 - ljedrz:cleanup_various, r=kennytm\n\nA few cleanups\n\n- change `skip(1).next()` to `nth(1)`\n- collapse some `if-else` expressions\n- remove a few explicit `return`s\n- remove an unnecessary field name\n- dereference once instead of matching on multiple references\n- prefer `iter().enumerate()` to indexing with `for`\n- remove some unnecessary lifetime annotations\n- use `writeln!()` instead of `write!()`+`\\n`\n- remove redundant parentheses\n- shorten some enum variant names\n- a few other cleanups suggested by `clippy`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e77d9955a0f6f7e1587e69c28d91580a426bea9a", "html_url": "https://github.com/rust-lang/rust/commit/e77d9955a0f6f7e1587e69c28d91580a426bea9a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e77d9955a0f6f7e1587e69c28d91580a426bea9a/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "764755b0b0367fcd79133f783efaebd7bcfb82a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/764755b0b0367fcd79133f783efaebd7bcfb82a0", "html_url": "https://github.com/rust-lang/rust/commit/764755b0b0367fcd79133f783efaebd7bcfb82a0"}, {"sha": "535bd13fe432aacccfbce058eed9b0b71aa8fab0", "url": "https://api.github.com/repos/rust-lang/rust/commits/535bd13fe432aacccfbce058eed9b0b71aa8fab0", "html_url": "https://github.com/rust-lang/rust/commit/535bd13fe432aacccfbce058eed9b0b71aa8fab0"}], "stats": {"total": 294, "additions": 141, "deletions": 153}, "files": [{"sha": "e2380f0fe2ff389464c4fb302de6bf7849e9d6b1", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -411,7 +411,7 @@ impl<'a> Parser<'a> {\n \n         // fill character\n         if let Some(&(_, c)) = self.cur.peek() {\n-            match self.cur.clone().skip(1).next() {\n+            match self.cur.clone().nth(1) {\n                 Some((_, '>')) | Some((_, '<')) | Some((_, '^')) => {\n                     spec.fill = Some(c);\n                     self.cur.next();\n@@ -504,13 +504,11 @@ impl<'a> Parser<'a> {\n             if word.is_empty() {\n                 self.cur = tmp;\n                 CountImplied\n+            } else if self.consume('$') {\n+                CountIsName(word)\n             } else {\n-                if self.consume('$') {\n-                    CountIsName(word)\n-                } else {\n-                    self.cur = tmp;\n-                    CountImplied\n-                }\n+                self.cur = tmp;\n+                CountImplied\n             }\n         }\n     }"}, {"sha": "9fa48adebdf07a523411152409a2e1465c07fc37", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -420,7 +420,8 @@ impl<'a> Id<'a> {\n         if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '_' ) {\n             return Err(());\n         }\n-        return Ok(Id { name: name });\n+\n+        Ok(Id { name })\n     }\n \n     pub fn as_slice(&'a self) -> &'a str {\n@@ -533,10 +534,10 @@ impl<'a> LabelText<'a> {\n     /// Renders text as string suitable for a label in a .dot file.\n     /// This includes quotes or suitable delimiters.\n     pub fn to_dot_string(&self) -> String {\n-        match self {\n-            &LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n-            &EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n-            &HtmlStr(ref s) => format!(\"<{}>\", s),\n+        match *self {\n+            LabelStr(ref s) => format!(\"\\\"{}\\\"\", s.escape_default()),\n+            EscStr(ref s) => format!(\"\\\"{}\\\"\", LabelText::escape_str(&s)),\n+            HtmlStr(ref s) => format!(\"<{}>\", s),\n         }\n     }\n "}, {"sha": "45279f18117c16329e8c45b4c584e89cd47f607b", "filename": "src/librustc_apfloat/ieee.rs", "status": "modified", "additions": 44, "deletions": 47, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibrustc_apfloat%2Fieee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibrustc_apfloat%2Fieee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_apfloat%2Fieee.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -536,23 +536,21 @@ impl<S: Semantics> fmt::Display for IeeeFloat<S> {\n         // Check whether we should use scientific notation.\n         let scientific = if width == 0 {\n             true\n+        } else if exp >= 0 {\n+            // 765e3 --> 765000\n+            //              ^^^\n+            // But we shouldn't make the number look more precise than it is.\n+            exp as usize > width || digits + exp as usize > precision\n         } else {\n-            if exp >= 0 {\n-                // 765e3 --> 765000\n-                //              ^^^\n-                // But we shouldn't make the number look more precise than it is.\n-                exp as usize > width || digits + exp as usize > precision\n+            // Power of the most significant digit.\n+            let msd = exp + (digits - 1) as ExpInt;\n+            if msd >= 0 {\n+                // 765e-2 == 7.65\n+                false\n             } else {\n-                // Power of the most significant digit.\n-                let msd = exp + (digits - 1) as ExpInt;\n-                if msd >= 0 {\n-                    // 765e-2 == 7.65\n-                    false\n-                } else {\n-                    // 765e-5 == 0.00765\n-                    //           ^ ^^\n-                    -msd as usize > width\n-                }\n+                // 765e-5 == 0.00765\n+                //           ^ ^^\n+                -msd as usize > width\n             }\n         };\n \n@@ -702,7 +700,7 @@ impl<S: Semantics> Float for IeeeFloat<S> {\n         //   exponent = 1..10\n         //   significand = 1..1\n         IeeeFloat {\n-            sig: [!0 & ((1 << S::PRECISION) - 1)],\n+            sig: [(1 << S::PRECISION) - 1],\n             exp: S::MAX_EXP,\n             category: Category::Normal,\n             sign: false,\n@@ -1507,10 +1505,11 @@ impl<S: Semantics, T: Semantics> FloatConvert<IeeeFloat<T>> for IeeeFloat<S> {\n         }\n \n         // If this is a truncation, perform the shift.\n-        let mut loss = Loss::ExactlyZero;\n-        if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n-            loss = sig::shift_right(&mut r.sig, &mut 0, -shift as usize);\n-        }\n+        let loss = if shift < 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n+            sig::shift_right(&mut r.sig, &mut 0, -shift as usize)\n+        } else {\n+            Loss::ExactlyZero\n+        };\n \n         // If this is an extension, perform the shift.\n         if shift > 0 && (r.is_finite_non_zero() || r.category == Category::NaN) {\n@@ -1738,27 +1737,25 @@ impl<S: Semantics> IeeeFloat<S> {\n                 bit_pos -= 4;\n                 if bit_pos >= 0 {\n                     r.sig[0] |= (hex_value as Limb) << bit_pos;\n-                } else {\n-                    // If zero or one-half (the hexadecimal digit 8) are followed\n-                    // by non-zero, they're a little more than zero or one-half.\n-                    if let Some(ref mut loss) = loss {\n-                        if hex_value != 0 {\n-                            if *loss == Loss::ExactlyZero {\n-                                *loss = Loss::LessThanHalf;\n-                            }\n-                            if *loss == Loss::ExactlyHalf {\n-                                *loss = Loss::MoreThanHalf;\n-                            }\n+                // If zero or one-half (the hexadecimal digit 8) are followed\n+                // by non-zero, they're a little more than zero or one-half.\n+                } else if let Some(ref mut loss) = loss {\n+                    if hex_value != 0 {\n+                        if *loss == Loss::ExactlyZero {\n+                            *loss = Loss::LessThanHalf;\n+                        }\n+                        if *loss == Loss::ExactlyHalf {\n+                            *loss = Loss::MoreThanHalf;\n                         }\n-                    } else {\n-                        loss = Some(match hex_value {\n-                            0 => Loss::ExactlyZero,\n-                            1..=7 => Loss::LessThanHalf,\n-                            8 => Loss::ExactlyHalf,\n-                            9..=15 => Loss::MoreThanHalf,\n-                            _ => unreachable!(),\n-                        });\n                     }\n+                } else {\n+                    loss = Some(match hex_value {\n+                        0 => Loss::ExactlyZero,\n+                        1..=7 => Loss::LessThanHalf,\n+                        8 => Loss::ExactlyHalf,\n+                        9..=15 => Loss::MoreThanHalf,\n+                        _ => unreachable!(),\n+                    });\n                 }\n             } else if c == 'p' || c == 'P' {\n                 if !any_digits {\n@@ -2309,9 +2306,9 @@ mod sig {\n \n     /// One, not zero, based LSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn olsb(limbs: &[Limb]) -> usize {\n-        for i in 0..limbs.len() {\n-            if limbs[i] != 0 {\n-                return i * LIMB_BITS + limbs[i].trailing_zeros() as usize + 1;\n+        for (i, &limb) in limbs.iter().enumerate() {\n+            if limb != 0 {\n+                return i * LIMB_BITS + limb.trailing_zeros() as usize + 1;\n             }\n         }\n \n@@ -2320,9 +2317,9 @@ mod sig {\n \n     /// One, not zero, based MSB. That is, returns 0 for a zeroed significand.\n     pub(super) fn omsb(limbs: &[Limb]) -> usize {\n-        for i in (0..limbs.len()).rev() {\n-            if limbs[i] != 0 {\n-                return (i + 1) * LIMB_BITS - limbs[i].leading_zeros() as usize;\n+        for (i, &limb) in limbs.iter().enumerate().rev() {\n+            if limb != 0 {\n+                return (i + 1) * LIMB_BITS - limb.leading_zeros() as usize;\n             }\n         }\n \n@@ -2378,7 +2375,7 @@ mod sig {\n                     limb = dst[i - jump];\n                     if shift > 0 {\n                         limb <<= shift;\n-                        if i >= jump + 1 {\n+                        if i > jump {\n                             limb |= dst[i - jump - 1] >> (LIMB_BITS - shift);\n                         }\n                     }\n@@ -2448,7 +2445,7 @@ mod sig {\n         let n = dst_limbs * LIMB_BITS - shift;\n         if n < src_bits {\n             let mask = (1 << (src_bits - n)) - 1;\n-            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << n % LIMB_BITS;\n+            dst[dst_limbs - 1] |= (src[dst_limbs] & mask) << (n % LIMB_BITS);\n         } else if n > src_bits && src_bits % LIMB_BITS > 0 {\n             dst[dst_limbs - 1] &= (1 << (src_bits % LIMB_BITS)) - 1;\n         }"}, {"sha": "d55762e03eee3d3e3a40a8ded6e9c1f060a6ea2d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -767,14 +767,10 @@ impl Target {\n         // the JSON parser is not updated to match the structs.\n \n         let get_req_field = |name: &str| {\n-            match obj.find(name)\n-                     .map(|s| s.as_string())\n-                     .and_then(|os| os.map(|s| s.to_string())) {\n-                Some(val) => Ok(val),\n-                None => {\n-                    return Err(format!(\"Field {} in target specification is required\", name))\n-                }\n-            }\n+            obj.find(name)\n+               .map(|s| s.as_string())\n+               .and_then(|os| os.map(|s| s.to_string()))\n+               .ok_or_else(|| format!(\"Field {} in target specification is required\", name))\n         };\n \n         let get_opt_field = |name: &str, default: &str| {"}, {"sha": "7f3736e82caa66e10de1f1a1782f0b4a2a8e96f6", "filename": "src/libserialize/hex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fhex.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -22,7 +22,7 @@ pub trait ToHex {\n     fn to_hex(&self) -> String;\n }\n \n-const CHARS: &'static [u8] = b\"0123456789abcdef\";\n+const CHARS: &[u8] = b\"0123456789abcdef\";\n \n impl ToHex for [u8] {\n     /// Turn a vector of `u8` bytes into a hexadecimal string."}, {"sha": "0361718eb7337d9fb9003605b4bdbaa6dc116189", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -438,7 +438,7 @@ fn escape_char(writer: &mut dyn fmt::Write, v: char) -> EncodeResult {\n }\n \n fn spaces(wr: &mut dyn fmt::Write, mut n: usize) -> EncodeResult {\n-    const BUF: &'static str = \"                \";\n+    const BUF: &str = \"                \";\n \n     while n >= BUF.len() {\n         wr.write_str(BUF)?;\n@@ -799,21 +799,21 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             escape_str(self.writer, name)\n         } else {\n             if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n-            write!(self.writer, \"{{\\n\")?;\n+            writeln!(self.writer, \"{{\")?;\n             self.curr_indent += self.indent;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"\\\"variant\\\": \")?;\n             escape_str(self.writer, name)?;\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n             spaces(self.writer, self.curr_indent)?;\n-            write!(self.writer, \"\\\"fields\\\": [\\n\")?;\n+            writeln!(self.writer, \"\\\"fields\\\": [\")?;\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"]\\n\")?;\n+            writeln!(self.writer, \"]\")?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n             Ok(())\n@@ -825,7 +825,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx != 0 {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n@@ -864,7 +864,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n         }\n@@ -876,9 +876,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         escape_str(self.writer, name)?;\n@@ -940,7 +940,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"]\")?;\n         }\n@@ -952,9 +952,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n@@ -971,7 +971,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             self.curr_indent += self.indent;\n             f(self)?;\n             self.curr_indent -= self.indent;\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n             spaces(self.writer, self.curr_indent)?;\n             write!(self.writer, \"}}\")?;\n         }\n@@ -983,9 +983,9 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     {\n         if self.is_emitting_map_key { return Err(EncoderError::BadHashmapKey); }\n         if idx == 0 {\n-            write!(self.writer, \"\\n\")?;\n+            writeln!(self.writer)?;\n         } else {\n-            write!(self.writer, \",\\n\")?;\n+            writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         self.is_emitting_map_key = true;\n@@ -1387,10 +1387,10 @@ impl Stack {\n \n     // Used by Parser to test whether the top-most element is an index.\n     fn last_is_index(&self) -> bool {\n-        if self.is_empty() { return false; }\n-        return match *self.stack.last().unwrap() {\n-            InternalIndex(_) => true,\n-            _ => false,\n+        if let Some(InternalIndex(_)) = self.stack.last() {\n+            true\n+        } else {\n+            false\n         }\n     }\n \n@@ -1530,19 +1530,17 @@ impl<T: Iterator<Item=char>> Parser<T> {\n             }\n \n             F64Value(res)\n-        } else {\n-            if neg {\n-                let res = (res as i64).wrapping_neg();\n+        } else if neg {\n+            let res = (res as i64).wrapping_neg();\n \n-                // Make sure we didn't underflow.\n-                if res > 0 {\n-                    Error(SyntaxError(InvalidNumber, self.line, self.col))\n-                } else {\n-                    I64Value(res)\n-                }\n+            // Make sure we didn't underflow.\n+            if res > 0 {\n+                Error(SyntaxError(InvalidNumber, self.line, self.col))\n             } else {\n-                U64Value(res)\n+                I64Value(res)\n             }\n+        } else {\n+            U64Value(res)\n         }\n     }\n "}, {"sha": "eee95d9fa67774406bb3569ab95fb9a0a8672621", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -103,8 +103,8 @@ pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W)\n     loop {\n         let mut byte = (value as u8) & 0x7f;\n         value >>= 7;\n-        let more = !((((value == 0) && ((byte & 0x40) == 0)) ||\n-                      ((value == -1) && ((byte & 0x40) != 0))));\n+        let more = !(((value == 0) && ((byte & 0x40) == 0)) ||\n+                     ((value == -1) && ((byte & 0x40) != 0)));\n \n         if more {\n             byte |= 0x80; // Mark this byte to show that more bytes will follow."}, {"sha": "adfc7078ebacb6d05f86981a06c01c5b1c86c5d4", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -60,8 +60,8 @@ impl error::Error for Error {\n \n     fn cause(&self) -> Option<&dyn error::Error> {\n         use self::Error::*;\n-        match self {\n-            &IoError(ref e) => Some(e),\n+        match *self {\n+            IoError(ref e) => Some(e),\n             _ => None,\n         }\n     }\n@@ -70,10 +70,10 @@ impl error::Error for Error {\n impl fmt::Display for Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         use self::Error::*;\n-        match self {\n-            &TermUnset => Ok(()),\n-            &MalformedTerminfo(ref e) => e.fmt(f),\n-            &IoError(ref e) => e.fmt(f),\n+        match *self {\n+            TermUnset => Ok(()),\n+            MalformedTerminfo(ref e) => e.fmt(f),\n+            IoError(ref e) => e.fmt(f),\n         }\n     }\n }\n@@ -109,9 +109,9 @@ impl TermInfo {\n     }\n     // Keep the metadata small\n     fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n-        let file = File::open(path).map_err(|e| Error::IoError(e))?;\n+        let file = File::open(path).map_err(Error::IoError)?;\n         let mut reader = BufReader::new(file);\n-        parse(&mut reader, false).map_err(|e| Error::MalformedTerminfo(e))\n+        parse(&mut reader, false).map_err(Error::MalformedTerminfo)\n     }\n }\n "}, {"sha": "31e1b18485ca40451aaa0e9953bf65689c1d7ca8", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -12,8 +12,6 @@\n \n use self::Param::*;\n use self::States::*;\n-use self::FormatState::*;\n-use self::FormatOp::*;\n \n use std::iter::repeat;\n \n@@ -36,9 +34,9 @@ enum States {\n \n #[derive(Copy, PartialEq, Clone)]\n enum FormatState {\n-    FormatStateFlags,\n-    FormatStateWidth,\n-    FormatStatePrecision,\n+    Flags,\n+    Width,\n+    Precision,\n }\n \n /// Types of parameters a capability can use\n@@ -210,22 +208,22 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                         if let Some(arg) = stack.pop() {\n                             let flags = Flags::new();\n                             let res = format(arg, FormatOp::from_char(cur), flags)?;\n-                            output.extend(res.iter().map(|x| *x));\n+                            output.extend(res.iter().cloned());\n                         } else {\n                             return Err(\"stack is empty\".to_string());\n                         }\n                     }\n                     ':' | '#' | ' ' | '.' | '0'..='9' => {\n                         let mut flags = Flags::new();\n-                        let mut fstate = FormatStateFlags;\n+                        let mut fstate = FormatState::Flags;\n                         match cur {\n                             ':' => (),\n                             '#' => flags.alternate = true,\n                             ' ' => flags.space = true,\n-                            '.' => fstate = FormatStatePrecision,\n+                            '.' => fstate = FormatState::Precision,\n                             '0'..='9' => {\n                                 flags.width = cur as usize - '0' as usize;\n-                                fstate = FormatStateWidth;\n+                                fstate = FormatState::Width;\n                             }\n                             _ => unreachable!(),\n                         }\n@@ -318,43 +316,43 @@ pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<\n                     (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n                         if let Some(arg) = stack.pop() {\n                             let res = format(arg, FormatOp::from_char(cur), *flags)?;\n-                            output.extend(res.iter().map(|x| *x));\n+                            output.extend(res.iter().cloned());\n                             // will cause state to go to Nothing\n                             old_state = FormatPattern(*flags, *fstate);\n                         } else {\n                             return Err(\"stack is empty\".to_string());\n                         }\n                     }\n-                    (FormatStateFlags, '#') => {\n+                    (FormatState::Flags, '#') => {\n                         flags.alternate = true;\n                     }\n-                    (FormatStateFlags, '-') => {\n+                    (FormatState::Flags, '-') => {\n                         flags.left = true;\n                     }\n-                    (FormatStateFlags, '+') => {\n+                    (FormatState::Flags, '+') => {\n                         flags.sign = true;\n                     }\n-                    (FormatStateFlags, ' ') => {\n+                    (FormatState::Flags, ' ') => {\n                         flags.space = true;\n                     }\n-                    (FormatStateFlags, '0'..='9') => {\n+                    (FormatState::Flags, '0'..='9') => {\n                         flags.width = cur as usize - '0' as usize;\n-                        *fstate = FormatStateWidth;\n+                        *fstate = FormatState::Width;\n                     }\n-                    (FormatStateFlags, '.') => {\n-                        *fstate = FormatStatePrecision;\n+                    (FormatState::Flags, '.') => {\n+                        *fstate = FormatState::Precision;\n                     }\n-                    (FormatStateWidth, '0'..='9') => {\n+                    (FormatState::Width, '0'..='9') => {\n                         let old = flags.width;\n                         flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n                         if flags.width < old {\n                             return Err(\"format width overflow\".to_string());\n                         }\n                     }\n-                    (FormatStateWidth, '.') => {\n-                        *fstate = FormatStatePrecision;\n+                    (FormatState::Width, '.') => {\n+                        *fstate = FormatState::Precision;\n                     }\n-                    (FormatStatePrecision, '0'..='9') => {\n+                    (FormatState::Precision, '0'..='9') => {\n                         let old = flags.precision;\n                         flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n                         if flags.precision < old {\n@@ -437,31 +435,31 @@ impl Flags {\n \n #[derive(Copy, Clone)]\n enum FormatOp {\n-    FormatDigit,\n-    FormatOctal,\n-    FormatHex,\n-    FormatHEX,\n-    FormatString,\n+    Digit,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n+    String,\n }\n \n impl FormatOp {\n     fn from_char(c: char) -> FormatOp {\n         match c {\n-            'd' => FormatDigit,\n-            'o' => FormatOctal,\n-            'x' => FormatHex,\n-            'X' => FormatHEX,\n-            's' => FormatString,\n+            'd' => FormatOp::Digit,\n+            'o' => FormatOp::Octal,\n+            'x' => FormatOp::LowerHex,\n+            'X' => FormatOp::UpperHex,\n+            's' => FormatOp::String,\n             _ => panic!(\"bad FormatOp char\"),\n         }\n     }\n     fn to_char(self) -> char {\n         match self {\n-            FormatDigit => 'd',\n-            FormatOctal => 'o',\n-            FormatHex => 'x',\n-            FormatHEX => 'X',\n-            FormatString => 's',\n+            FormatOp::Digit => 'd',\n+            FormatOp::Octal => 'o',\n+            FormatOp::LowerHex => 'x',\n+            FormatOp::UpperHex => 'X',\n+            FormatOp::String => 's',\n         }\n     }\n }\n@@ -470,7 +468,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n     let mut s = match val {\n         Number(d) => {\n             match op {\n-                FormatDigit => {\n+                FormatOp::Digit => {\n                     if flags.sign {\n                         format!(\"{:+01$}\", d, flags.precision)\n                     } else if d < 0 {\n@@ -482,35 +480,35 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n                         format!(\"{:01$}\", d, flags.precision)\n                     }\n                 }\n-                FormatOctal => {\n+                FormatOp::Octal => {\n                     if flags.alternate {\n                         // Leading octal zero counts against precision.\n                         format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n                     } else {\n                         format!(\"{:01$o}\", d, flags.precision)\n                     }\n                 }\n-                FormatHex => {\n+                FormatOp::LowerHex => {\n                     if flags.alternate && d != 0 {\n                         format!(\"0x{:01$x}\", d, flags.precision)\n                     } else {\n                         format!(\"{:01$x}\", d, flags.precision)\n                     }\n                 }\n-                FormatHEX => {\n+                FormatOp::UpperHex => {\n                     if flags.alternate && d != 0 {\n                         format!(\"0X{:01$X}\", d, flags.precision)\n                     } else {\n                         format!(\"{:01$X}\", d, flags.precision)\n                     }\n                 }\n-                FormatString => return Err(\"non-number on stack with %s\".to_string()),\n+                FormatOp::String => return Err(\"non-number on stack with %s\".to_string()),\n             }\n             .into_bytes()\n         }\n         Words(s) => {\n             match op {\n-                FormatString => {\n+                FormatOp::String => {\n                     let mut s = s.into_bytes();\n                     if flags.precision > 0 && flags.precision < s.len() {\n                         s.truncate(flags.precision);"}, {"sha": "e0b60eead497a6b45b0f98f3a9eaf761cce31ee7", "filename": "src/libterm/win.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e77d9955a0f6f7e1587e69c28d91580a426bea9a/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=e77d9955a0f6f7e1587e69c28d91580a426bea9a", "patch": "@@ -198,11 +198,11 @@ impl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n         Ok(true)\n     }\n \n-    fn get_ref<'a>(&'a self) -> &'a T {\n+    fn get_ref(&self) -> &T {\n         &self.buf\n     }\n \n-    fn get_mut<'a>(&'a mut self) -> &'a mut T {\n+    fn get_mut(&mut self) -> &mut T {\n         &mut self.buf\n     }\n "}]}