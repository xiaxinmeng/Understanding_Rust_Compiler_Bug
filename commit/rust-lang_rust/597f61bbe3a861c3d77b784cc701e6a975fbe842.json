{"sha": "597f61bbe3a861c3d77b784cc701e6a975fbe842", "node_id": "C_kwDOAAsO6NoAKDU5N2Y2MWJiZTNhODYxYzNkNzdiNzg0Y2M3MDFlNmE5NzVmYmU4NDI", "commit": {"author": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-05-08T10:44:58Z"}, "committer": {"name": "Samuel E. Moelius III", "email": "sam@moeli.us", "date": "2022-05-08T11:18:31Z"}, "message": "Optionally allow `expect` and `unwrap` in tests", "tree": {"sha": "e0deb4a19ca2bee054e23f3dc52fb922b5acc62b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0deb4a19ca2bee054e23f3dc52fb922b5acc62b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/597f61bbe3a861c3d77b784cc701e6a975fbe842", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/597f61bbe3a861c3d77b784cc701e6a975fbe842", "html_url": "https://github.com/rust-lang/rust/commit/597f61bbe3a861c3d77b784cc701e6a975fbe842", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/597f61bbe3a861c3d77b784cc701e6a975fbe842/comments", "author": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "committer": {"login": "smoelius", "id": 35515885, "node_id": "MDQ6VXNlcjM1NTE1ODg1", "avatar_url": "https://avatars.githubusercontent.com/u/35515885?v=4", "gravatar_id": "", "url": "https://api.github.com/users/smoelius", "html_url": "https://github.com/smoelius", "followers_url": "https://api.github.com/users/smoelius/followers", "following_url": "https://api.github.com/users/smoelius/following{/other_user}", "gists_url": "https://api.github.com/users/smoelius/gists{/gist_id}", "starred_url": "https://api.github.com/users/smoelius/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/smoelius/subscriptions", "organizations_url": "https://api.github.com/users/smoelius/orgs", "repos_url": "https://api.github.com/users/smoelius/repos", "events_url": "https://api.github.com/users/smoelius/events{/privacy}", "received_events_url": "https://api.github.com/users/smoelius/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bdfea1c095d0a98e759eeb680d34d2d6da51132c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bdfea1c095d0a98e759eeb680d34d2d6da51132c", "html_url": "https://github.com/rust-lang/rust/commit/bdfea1c095d0a98e759eeb680d34d2d6da51132c"}], "stats": {"total": 724, "additions": 543, "deletions": 181}, "files": [{"sha": "6970757b56d5c6bb116360777f120aab6a709a01", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -582,8 +582,17 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n \n     let avoid_breaking_exported_api = conf.avoid_breaking_exported_api;\n+    let allow_expect_in_tests = conf.allow_expect_in_tests;\n+    let allow_unwrap_in_tests = conf.allow_unwrap_in_tests;\n     store.register_late_pass(move || Box::new(approx_const::ApproxConstant::new(msrv)));\n-    store.register_late_pass(move || Box::new(methods::Methods::new(avoid_breaking_exported_api, msrv)));\n+    store.register_late_pass(move || {\n+        Box::new(methods::Methods::new(\n+            avoid_breaking_exported_api,\n+            msrv,\n+            allow_expect_in_tests,\n+            allow_unwrap_in_tests,\n+        ))\n+    });\n     store.register_late_pass(move || Box::new(matches::Matches::new(msrv)));\n     store.register_early_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveStruct::new(msrv)));\n     store.register_late_pass(move || Box::new(manual_non_exhaustive::ManualNonExhaustiveEnum::new(msrv)));"}, {"sha": "fbc3348f1855fe3b7a8af071101bde3548905971", "filename": "clippy_lints/src/methods/expect_used.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_used.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_in_test_function;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -7,7 +8,7 @@ use rustc_span::sym;\n use super::EXPECT_USED;\n \n /// lint use of `expect()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, allow_expect_in_tests: bool) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) {\n@@ -18,6 +19,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         None\n     };\n \n+    if allow_expect_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n+        return;\n+    }\n+\n     if let Some((lint, kind, none_value)) = mess {\n         span_lint_and_help(\n             cx,"}, {"sha": "e452614ce17fe41ca262b5006f4412d790c82d49", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 191, "deletions": 177, "changes": 368, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -2200,14 +2200,23 @@ declare_clippy_lint! {\n pub struct Methods {\n     avoid_breaking_exported_api: bool,\n     msrv: Option<RustcVersion>,\n+    allow_expect_in_tests: bool,\n+    allow_unwrap_in_tests: bool,\n }\n \n impl Methods {\n     #[must_use]\n-    pub fn new(avoid_breaking_exported_api: bool, msrv: Option<RustcVersion>) -> Self {\n+    pub fn new(\n+        avoid_breaking_exported_api: bool,\n+        msrv: Option<RustcVersion>,\n+        allow_expect_in_tests: bool,\n+        allow_unwrap_in_tests: bool,\n+    ) -> Self {\n         Self {\n             avoid_breaking_exported_api,\n             msrv,\n+            allow_expect_in_tests,\n+            allow_unwrap_in_tests,\n         }\n     }\n }\n@@ -2306,7 +2315,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             return;\n         }\n \n-        check_methods(cx, expr, self.msrv);\n+        self.check_methods(cx, expr);\n \n         match expr.kind {\n             hir::ExprKind::Call(func, args) => {\n@@ -2505,196 +2514,201 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n-#[allow(clippy::too_many_lines)]\n-fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Option<RustcVersion>) {\n-    if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n-        match (name, args) {\n-            (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n-                zst_offset::check(cx, expr, recv);\n-            },\n-            (\"and_then\", [arg]) => {\n-                let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n-                let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n-                if !biom_option_linted && !biom_result_linted {\n-                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n-                }\n-            },\n-            (\"as_deref\" | \"as_deref_mut\", []) => {\n-                needless_option_as_deref::check(cx, expr, recv, name);\n-            },\n-            (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n-            (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n-            (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n-            (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, msrv),\n-            (\"collect\", []) => match method_call(recv) {\n-                Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n-                    iter_cloned_collect::check(cx, name, expr, recv2);\n+impl Methods {\n+    #[allow(clippy::too_many_lines)]\n+    fn check_methods<'tcx>(&self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let Some((name, [recv, args @ ..], span)) = method_call(expr) {\n+            match (name, args) {\n+                (\"add\" | \"offset\" | \"sub\" | \"wrapping_offset\" | \"wrapping_add\" | \"wrapping_sub\", [_arg]) => {\n+                    zst_offset::check(cx, expr, recv);\n+                },\n+                (\"and_then\", [arg]) => {\n+                    let biom_option_linted = bind_instead_of_map::OptionAndThenSome::check(cx, expr, recv, arg);\n+                    let biom_result_linted = bind_instead_of_map::ResultAndThenOk::check(cx, expr, recv, arg);\n+                    if !biom_option_linted && !biom_result_linted {\n+                        unnecessary_lazy_eval::check(cx, expr, recv, arg, \"and\");\n+                    }\n+                },\n+                (\"as_deref\" | \"as_deref_mut\", []) => {\n+                    needless_option_as_deref::check(cx, expr, recv, name);\n+                },\n+                (\"as_mut\", []) => useless_asref::check(cx, expr, \"as_mut\", recv),\n+                (\"as_ref\", []) => useless_asref::check(cx, expr, \"as_ref\", recv),\n+                (\"assume_init\", []) => uninit_assumed_init::check(cx, expr, recv),\n+                (\"cloned\", []) => cloned_instead_of_copied::check(cx, expr, recv, span, self.msrv),\n+                (\"collect\", []) => match method_call(recv) {\n+                    Some((name @ (\"cloned\" | \"copied\"), [recv2], _)) => {\n+                        iter_cloned_collect::check(cx, name, expr, recv2);\n+                    },\n+                    Some((\"map\", [m_recv, m_arg], _)) => {\n+                        map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                    },\n+                    Some((\"take\", [take_self_arg, take_arg], _)) => {\n+                        if meets_msrv(self.msrv, msrvs::STR_REPEAT) {\n+                            manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                        }\n+                    },\n+                    _ => {},\n+                },\n+                (name @ \"count\", args @ []) => match method_call(recv) {\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n+                        iter_count::check(cx, expr, recv2, name2);\n+                    },\n+                    Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n+                    _ => {},\n+                },\n+                (\"drain\", [arg]) => {\n+                    iter_with_drain::check(cx, expr, recv, span, arg);\n+                },\n+                (\"expect\", [_]) => match method_call(recv) {\n+                    Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n+                    Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, self.msrv, span, err_span),\n+                    _ => expect_used::check(cx, expr, recv, self.allow_expect_in_tests),\n+                },\n+                (\"extend\", [arg]) => {\n+                    string_extend_chars::check(cx, expr, recv, arg);\n+                    extend_with_drain::check(cx, expr, recv, arg);\n+                },\n+                (\"filter_map\", [arg]) => {\n+                    unnecessary_filter_map::check(cx, expr, arg, name);\n+                    filter_map_identity::check(cx, expr, arg, span);\n+                },\n+                (\"find_map\", [arg]) => {\n+                    unnecessary_filter_map::check(cx, expr, arg, name);\n                 },\n-                Some((\"map\", [m_recv, m_arg], _)) => {\n-                    map_collect_result_unit::check(cx, expr, m_recv, m_arg, recv);\n+                (\"flat_map\", [arg]) => {\n+                    flat_map_identity::check(cx, expr, arg, span);\n+                    flat_map_option::check(cx, expr, arg, span);\n                 },\n-                Some((\"take\", [take_self_arg, take_arg], _)) => {\n-                    if meets_msrv(msrv, msrvs::STR_REPEAT) {\n-                        manual_str_repeat::check(cx, expr, recv, take_self_arg, take_arg);\n+                (name @ \"flatten\", args @ []) => match method_call(recv) {\n+                    Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    _ => {},\n+                },\n+                (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n+                (\"for_each\", [_]) => {\n+                    if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n+                        inspect_for_each::check(cx, expr, span2);\n                     }\n                 },\n-                _ => {},\n-            },\n-            (name @ \"count\", args @ []) => match method_call(recv) {\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                Some((name2 @ (\"into_iter\" | \"iter\" | \"iter_mut\"), [recv2], _)) => {\n-                    iter_count::check(cx, expr, recv2, name2);\n+                (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n+                (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n+                (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, self.msrv),\n+                (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n+                (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n+                (\"join\", [join_arg]) => {\n+                    if let Some((\"collect\", _, span)) = method_call(recv) {\n+                        unnecessary_join::check(cx, expr, recv, join_arg, span);\n+                    }\n                 },\n-                Some((\"map\", [_, arg], _)) => suspicious_map::check(cx, expr, recv, arg),\n-                _ => {},\n-            },\n-            (\"drain\", [arg]) => {\n-                iter_with_drain::check(cx, expr, recv, span, arg);\n-            },\n-            (\"expect\", [_]) => match method_call(recv) {\n-                Some((\"ok\", [recv], _)) => ok_expect::check(cx, expr, recv),\n-                Some((\"err\", [recv], err_span)) => err_expect::check(cx, expr, recv, msrv, span, err_span),\n-                _ => expect_used::check(cx, expr, recv),\n-            },\n-            (\"extend\", [arg]) => {\n-                string_extend_chars::check(cx, expr, recv, arg);\n-                extend_with_drain::check(cx, expr, recv, arg);\n-            },\n-            (\"filter_map\", [arg]) => {\n-                unnecessary_filter_map::check(cx, expr, arg, name);\n-                filter_map_identity::check(cx, expr, arg, span);\n-            },\n-            (\"find_map\", [arg]) => {\n-                unnecessary_filter_map::check(cx, expr, arg, name);\n-            },\n-            (\"flat_map\", [arg]) => {\n-                flat_map_identity::check(cx, expr, arg, span);\n-                flat_map_option::check(cx, expr, arg, span);\n-            },\n-            (name @ \"flatten\", args @ []) => match method_call(recv) {\n-                Some((\"map\", [recv, map_arg], map_span)) => map_flatten::check(cx, expr, recv, map_arg, map_span),\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                _ => {},\n-            },\n-            (\"fold\", [init, acc]) => unnecessary_fold::check(cx, expr, init, acc, span),\n-            (\"for_each\", [_]) => {\n-                if let Some((\"inspect\", [_, _], span2)) = method_call(recv) {\n-                    inspect_for_each::check(cx, expr, span2);\n-                }\n-            },\n-            (\"get_or_insert_with\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"get_or_insert\"),\n-            (\"is_file\", []) => filetype_is_file::check(cx, expr, recv),\n-            (\"is_digit\", [radix]) => is_digit_ascii_radix::check(cx, expr, recv, radix, msrv),\n-            (\"is_none\", []) => check_is_some_is_none(cx, expr, recv, false),\n-            (\"is_some\", []) => check_is_some_is_none(cx, expr, recv, true),\n-            (\"join\", [join_arg]) => {\n-                if let Some((\"collect\", _, span)) = method_call(recv) {\n-                    unnecessary_join::check(cx, expr, recv, join_arg, span);\n-                }\n-            },\n-            (\"last\", args @ []) | (\"skip\", args @ [_]) => {\n-                if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n-                    if let (\"cloned\", []) = (name2, args2) {\n-                        iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                (\"last\", args @ []) | (\"skip\", args @ [_]) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                        if let (\"cloned\", []) = (name2, args2) {\n+                            iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                        }\n                     }\n-                }\n-            },\n-            (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n-                if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n-                    match (name, args) {\n-                        (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, msrv),\n-                        (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, msrv),\n-                        (\"filter\", [f_arg]) => {\n-                            filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false);\n-                        },\n-                        (\"find\", [f_arg]) => filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true),\n-                        _ => {},\n+                },\n+                (name @ (\"map\" | \"map_err\"), [m_arg]) => {\n+                    if let Some((name, [recv2, args @ ..], span2)) = method_call(recv) {\n+                        match (name, args) {\n+                            (\"as_mut\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, true, self.msrv),\n+                            (\"as_ref\", []) => option_as_ref_deref::check(cx, expr, recv2, m_arg, false, self.msrv),\n+                            (\"filter\", [f_arg]) => {\n+                                filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, false);\n+                            },\n+                            (\"find\", [f_arg]) => {\n+                                filter_map::check(cx, expr, recv2, f_arg, span2, recv, m_arg, span, true);\n+                            },\n+                            _ => {},\n+                        }\n                     }\n-                }\n-                map_identity::check(cx, expr, recv, m_arg, name, span);\n-            },\n-            (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n-            (name @ \"next\", args @ []) => {\n-                if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n-                    match (name2, args2) {\n-                        (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                        (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n-                        (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv2, arg, msrv),\n-                        (\"iter\", []) => iter_next_slice::check(cx, expr, recv2),\n-                        (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv2, arg),\n-                        (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n-                        _ => {},\n+                    map_identity::check(cx, expr, recv, m_arg, name, span);\n+                },\n+                (\"map_or\", [def, map]) => option_map_or_none::check(cx, expr, recv, def, map),\n+                (name @ \"next\", args @ []) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _)) = method_call(recv) {\n+                        match (name2, args2) {\n+                            (\"cloned\", []) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                            (\"filter\", [arg]) => filter_next::check(cx, expr, recv2, arg),\n+                            (\"filter_map\", [arg]) => filter_map_next::check(cx, expr, recv2, arg, self.msrv),\n+                            (\"iter\", []) => iter_next_slice::check(cx, expr, recv2),\n+                            (\"skip\", [arg]) => iter_skip_next::check(cx, expr, recv2, arg),\n+                            (\"skip_while\", [_]) => skip_while_next::check(cx, expr),\n+                            _ => {},\n+                        }\n                     }\n-                }\n-            },\n-            (\"nth\", args @ [n_arg]) => match method_call(recv) {\n-                Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n-                Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n-                Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n-                Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n-                _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n-            },\n-            (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n-            (\"or_else\", [arg]) => {\n-                if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n-                    unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n-                }\n-            },\n-            (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n-                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n-                    suspicious_splitn::check(cx, name, expr, recv, count);\n-                    str_splitn::check(cx, name, expr, recv, pat_arg, count, msrv);\n-                }\n-            },\n-            (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n-                if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n-                    suspicious_splitn::check(cx, name, expr, recv, count);\n-                }\n-            },\n-            (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n-            (\"take\", args @ [_arg]) => {\n-                if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n-                    if let (\"cloned\", []) = (name2, args2) {\n-                        iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                },\n+                (\"nth\", args @ [n_arg]) => match method_call(recv) {\n+                    Some((\"bytes\", [recv2], _)) => bytes_nth::check(cx, expr, recv2, n_arg),\n+                    Some((\"cloned\", [recv2], _)) => iter_overeager_cloned::check(cx, expr, recv2, name, args),\n+                    Some((\"iter\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, false),\n+                    Some((\"iter_mut\", [recv2], _)) => iter_nth::check(cx, expr, recv2, recv, n_arg, true),\n+                    _ => iter_nth_zero::check(cx, expr, recv, n_arg),\n+                },\n+                (\"ok_or_else\", [arg]) => unnecessary_lazy_eval::check(cx, expr, recv, arg, \"ok_or\"),\n+                (\"or_else\", [arg]) => {\n+                    if !bind_instead_of_map::ResultOrElseErrInfo::check(cx, expr, recv, arg) {\n+                        unnecessary_lazy_eval::check(cx, expr, recv, arg, \"or\");\n                     }\n-                }\n-            },\n-            (\"take\", []) => needless_option_take::check(cx, expr, recv),\n-            (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n-                implicit_clone::check(cx, name, expr, recv);\n-            },\n-            (\"unwrap\", []) => {\n-                match method_call(recv) {\n-                    Some((\"get\", [recv, get_arg], _)) => {\n-                        get_unwrap::check(cx, expr, recv, get_arg, false);\n-                    },\n-                    Some((\"get_mut\", [recv, get_arg], _)) => {\n-                        get_unwrap::check(cx, expr, recv, get_arg, true);\n+                },\n+                (\"splitn\" | \"rsplitn\", [count_arg, pat_arg]) => {\n+                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                        suspicious_splitn::check(cx, name, expr, recv, count);\n+                        str_splitn::check(cx, name, expr, recv, pat_arg, count, self.msrv);\n+                    }\n+                },\n+                (\"splitn_mut\" | \"rsplitn_mut\", [count_arg, _]) => {\n+                    if let Some((Constant::Int(count), _)) = constant(cx, cx.typeck_results(), count_arg) {\n+                        suspicious_splitn::check(cx, name, expr, recv, count);\n+                    }\n+                },\n+                (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n+                (\"take\", args @ [_arg]) => {\n+                    if let Some((name2, [recv2, args2 @ ..], _span2)) = method_call(recv) {\n+                        if let (\"cloned\", []) = (name2, args2) {\n+                            iter_overeager_cloned::check(cx, expr, recv2, name, args);\n+                        }\n+                    }\n+                },\n+                (\"take\", []) => needless_option_take::check(cx, expr, recv),\n+                (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n+                    implicit_clone::check(cx, name, expr, recv);\n+                },\n+                (\"unwrap\", []) => {\n+                    match method_call(recv) {\n+                        Some((\"get\", [recv, get_arg], _)) => {\n+                            get_unwrap::check(cx, expr, recv, get_arg, false);\n+                        },\n+                        Some((\"get_mut\", [recv, get_arg], _)) => {\n+                            get_unwrap::check(cx, expr, recv, get_arg, true);\n+                        },\n+                        Some((\"or\", [recv, or_arg], or_span)) => {\n+                            or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n+                        },\n+                        _ => {},\n+                    }\n+                    unwrap_used::check(cx, expr, recv, self.allow_unwrap_in_tests);\n+                },\n+                (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n+                    Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n+                        manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                     },\n-                    Some((\"or\", [recv, or_arg], or_span)) => {\n-                        or_then_unwrap::check(cx, expr, recv, or_arg, or_span);\n+                    Some((\"map\", [m_recv, m_arg], span)) => {\n+                        option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n                     },\n                     _ => {},\n-                }\n-                unwrap_used::check(cx, expr, recv);\n-            },\n-            (\"unwrap_or\", [u_arg]) => match method_call(recv) {\n-                Some((arith @ (\"checked_add\" | \"checked_sub\" | \"checked_mul\"), [lhs, rhs], _)) => {\n-                    manual_saturating_arithmetic::check(cx, expr, lhs, rhs, u_arg, &arith[\"checked_\".len()..]);\n                 },\n-                Some((\"map\", [m_recv, m_arg], span)) => {\n-                    option_map_unwrap_or::check(cx, expr, m_recv, m_arg, recv, u_arg, span);\n+                (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n+                    Some((\"map\", [recv, map_arg], _))\n+                        if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, self.msrv) => {},\n+                    _ => {\n+                        unwrap_or_else_default::check(cx, expr, recv, u_arg);\n+                        unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n+                    },\n                 },\n                 _ => {},\n-            },\n-            (\"unwrap_or_else\", [u_arg]) => match method_call(recv) {\n-                Some((\"map\", [recv, map_arg], _)) if map_unwrap_or::check(cx, expr, recv, map_arg, u_arg, msrv) => {},\n-                _ => {\n-                    unwrap_or_else_default::check(cx, expr, recv, u_arg);\n-                    unnecessary_lazy_eval::check(cx, expr, recv, u_arg, \"unwrap_or\");\n-                },\n-            },\n-            _ => {},\n+            }\n         }\n     }\n }"}, {"sha": "5c761014927c28dae2af593d4dcfaf5d46efb28e", "filename": "clippy_lints/src/methods/unwrap_used.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funwrap_used.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -1,4 +1,5 @@\n use clippy_utils::diagnostics::span_lint_and_help;\n+use clippy_utils::is_in_test_function;\n use clippy_utils::ty::is_type_diagnostic_item;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n@@ -7,7 +8,7 @@ use rustc_span::sym;\n use super::UNWRAP_USED;\n \n /// lint use of `unwrap()` for `Option`s and `Result`s\n-pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, allow_unwrap_in_tests: bool) {\n     let obj_ty = cx.typeck_results().expr_ty(recv).peel_refs();\n \n     let mess = if is_type_diagnostic_item(cx, obj_ty, sym::Option) {\n@@ -18,6 +19,10 @@ pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, recv: &hir::Expr\n         None\n     };\n \n+    if allow_unwrap_in_tests && is_in_test_function(cx.tcx, expr.hir_id) {\n+        return;\n+    }\n+\n     if let Some((lint, kind, none_value)) = mess {\n         span_lint_and_help(\n             cx,"}, {"sha": "bdcd76d153fb0cc3d2d773fd2b73dcd423ce075f", "filename": "clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/clippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -316,6 +316,14 @@ define_Conf! {\n     ///\n     /// The maximum size of a file included via `include_bytes!()` or `include_str!()`, in bytes\n     (max_include_file_size: u64 = 1_000_000),\n+    /// Lint: EXPECT_USED.\n+    ///\n+    /// Whether `expect` should be allowed in test functions\n+    (allow_expect_in_tests: bool = false),\n+    /// Lint: UNWRAP_USED.\n+    ///\n+    /// Whether `unwrap` should be allowed in test functions\n+    (allow_unwrap_in_tests: bool = false),\n }\n \n /// Search for the configuration file."}, {"sha": "6933b8164195a21ef31133fa297065e8b0e18f7f", "filename": "tests/ui-toml/expect_used/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fexpect_used%2Fclippy.toml?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1 @@\n+allow-expect-in-tests = true"}, {"sha": "22dcd3ae9d697a6b9ef2ac140c560f662350c551", "filename": "tests/ui-toml/expect_used/expect_used.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1,29 @@\n+// compile-flags: --test\n+#![warn(clippy::expect_used)]\n+\n+fn expect_option() {\n+    let opt = Some(0);\n+    let _ = opt.expect(\"\");\n+}\n+\n+fn expect_result() {\n+    let res: Result<u8, ()> = Ok(0);\n+    let _ = res.expect(\"\");\n+}\n+\n+fn main() {\n+    expect_option();\n+    expect_result();\n+}\n+\n+#[test]\n+fn test_expect_option() {\n+    let opt = Some(0);\n+    let _ = opt.expect(\"\");\n+}\n+\n+#[test]\n+fn test_expect_result() {\n+    let res: Result<u8, ()> = Ok(0);\n+    let _ = res.expect(\"\");\n+}"}, {"sha": "9cb2199ed21cb0604af19671c66f490b79f50408", "filename": "tests/ui-toml/expect_used/expect_used.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Fexpect_used%2Fexpect_used.stderr?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1,19 @@\n+error: used `expect()` on `an Option` value\n+  --> $DIR/expect_used.rs:6:13\n+   |\n+LL |     let _ = opt.expect(\"\");\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::expect-used` implied by `-D warnings`\n+   = help: if this value is an `None`, it will panic\n+\n+error: used `expect()` on `a Result` value\n+  --> $DIR/expect_used.rs:11:13\n+   |\n+LL |     let _ = res.expect(\"\");\n+   |             ^^^^^^^^^^^^^^\n+   |\n+   = help: if this value is an `Err`, it will panic\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "65277dd03e8305091a4fd76fb1d74e9079d47dca", "filename": "tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `max-suggested-slice-pattern-length`, `await-holding-invalid-types`, `max-include-file-size`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `avoid-breaking-exported-api`, `msrv`, `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `pass-by-value-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `disallowed-methods`, `disallowed-types`, `unreadable-literal-lint-fractions`, `upper-case-acronyms-aggressive`, `cargo-ignore-publish`, `standard-macro-braces`, `enforced-import-renames`, `allowed-scripts`, `enable-raw-pointer-heuristic-for-send`, `max-suggested-slice-pattern-length`, `await-holding-invalid-types`, `max-include-file-size`, `allow-expect-in-tests`, `allow-unwrap-in-tests`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "154626ef4e81f6aa3e7c271ef613fe017ad658f9", "filename": "tests/ui-toml/unwrap_used/clippy.toml", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Fclippy.toml", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Fclippy.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Funwrap_used%2Fclippy.toml?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1 @@\n+allow-unwrap-in-tests = true"}, {"sha": "a639de0797156509c953d0d0cc571df90a98b379", "filename": "tests/ui-toml/unwrap_used/unwrap_used.rs", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.rs", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.rs?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1,74 @@\n+// compile-flags: --test\n+\n+#![allow(unused_mut, clippy::from_iter_instead_of_collect)]\n+#![warn(clippy::unwrap_used)]\n+#![deny(clippy::get_unwrap)]\n+\n+use std::collections::BTreeMap;\n+use std::collections::HashMap;\n+use std::collections::VecDeque;\n+use std::iter::FromIterator;\n+\n+struct GetFalsePositive {\n+    arr: [u32; 3],\n+}\n+\n+impl GetFalsePositive {\n+    fn get(&self, pos: usize) -> Option<&u32> {\n+        self.arr.get(pos)\n+    }\n+    fn get_mut(&mut self, pos: usize) -> Option<&mut u32> {\n+        self.arr.get_mut(pos)\n+    }\n+}\n+\n+fn main() {\n+    let mut boxed_slice: Box<[u8]> = Box::new([0, 1, 2, 3]);\n+    let mut some_slice = &mut [0, 1, 2, 3];\n+    let mut some_vec = vec![0, 1, 2, 3];\n+    let mut some_vecdeque: VecDeque<_> = some_vec.iter().cloned().collect();\n+    let mut some_hashmap: HashMap<u8, char> = HashMap::from_iter(vec![(1, 'a'), (2, 'b')]);\n+    let mut some_btreemap: BTreeMap<u8, char> = BTreeMap::from_iter(vec![(1, 'a'), (2, 'b')]);\n+    let mut false_positive = GetFalsePositive { arr: [0, 1, 2] };\n+\n+    {\n+        // Test `get().unwrap()`\n+        let _ = boxed_slice.get(1).unwrap();\n+        let _ = some_slice.get(0).unwrap();\n+        let _ = some_vec.get(0).unwrap();\n+        let _ = some_vecdeque.get(0).unwrap();\n+        let _ = some_hashmap.get(&1).unwrap();\n+        let _ = some_btreemap.get(&1).unwrap();\n+        #[allow(clippy::unwrap_used)]\n+        let _ = false_positive.get(0).unwrap();\n+        // Test with deref\n+        let _: u8 = *boxed_slice.get(1).unwrap();\n+    }\n+\n+    {\n+        // Test `get_mut().unwrap()`\n+        *boxed_slice.get_mut(0).unwrap() = 1;\n+        *some_slice.get_mut(0).unwrap() = 1;\n+        *some_vec.get_mut(0).unwrap() = 1;\n+        *some_vecdeque.get_mut(0).unwrap() = 1;\n+        // Check false positives\n+        #[allow(clippy::unwrap_used)]\n+        {\n+            *some_hashmap.get_mut(&1).unwrap() = 'b';\n+            *some_btreemap.get_mut(&1).unwrap() = 'b';\n+            *false_positive.get_mut(0).unwrap() = 1;\n+        }\n+    }\n+\n+    {\n+        // Test `get().unwrap().foo()` and `get_mut().unwrap().bar()`\n+        let _ = some_vec.get(0..1).unwrap().to_vec();\n+        let _ = some_vec.get_mut(0..1).unwrap().to_vec();\n+    }\n+}\n+\n+#[test]\n+fn test() {\n+    let boxed_slice: Box<[u8]> = Box::new([0, 1, 2, 3]);\n+    let _ = boxed_slice.get(1).unwrap();\n+}"}, {"sha": "6c3adc5395f7184bc2454f35bb1e459227a0f8fc", "filename": "tests/ui-toml/unwrap_used/unwrap_used.stderr", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/597f61bbe3a861c3d77b784cc701e6a975fbe842/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui-toml%2Funwrap_used%2Funwrap_used.stderr?ref=597f61bbe3a861c3d77b784cc701e6a975fbe842", "patch": "@@ -0,0 +1,197 @@\n+error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:36:17\n+   |\n+LL |         let _ = boxed_slice.get(1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&boxed_slice[1]`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/unwrap_used.rs:5:9\n+   |\n+LL | #![deny(clippy::get_unwrap)]\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:36:17\n+   |\n+LL |         let _ = boxed_slice.get(1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::unwrap-used` implied by `-D warnings`\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:37:17\n+   |\n+LL |         let _ = some_slice.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_slice[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:37:17\n+   |\n+LL |         let _ = some_slice.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a Vec. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:38:17\n+   |\n+LL |         let _ = some_vec.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_vec[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:38:17\n+   |\n+LL |         let _ = some_vec.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a VecDeque. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:39:17\n+   |\n+LL |         let _ = some_vecdeque.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_vecdeque[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:39:17\n+   |\n+LL |         let _ = some_vecdeque.get(0).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a HashMap. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:40:17\n+   |\n+LL |         let _ = some_hashmap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_hashmap[&1]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:40:17\n+   |\n+LL |         let _ = some_hashmap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a BTreeMap. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:41:17\n+   |\n+LL |         let _ = some_btreemap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&some_btreemap[&1]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:41:17\n+   |\n+LL |         let _ = some_btreemap.get(&1).unwrap();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:45:21\n+   |\n+LL |         let _: u8 = *boxed_slice.get(1).unwrap();\n+   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `boxed_slice[1]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:45:22\n+   |\n+LL |         let _: u8 = *boxed_slice.get(1).unwrap();\n+   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get_mut().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:50:9\n+   |\n+LL |         *boxed_slice.get_mut(0).unwrap() = 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `boxed_slice[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:50:10\n+   |\n+LL |         *boxed_slice.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get_mut().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:51:9\n+   |\n+LL |         *some_slice.get_mut(0).unwrap() = 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_slice[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:51:10\n+   |\n+LL |         *some_slice.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get_mut().unwrap()` on a Vec. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:52:9\n+   |\n+LL |         *some_vec.get_mut(0).unwrap() = 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:52:10\n+   |\n+LL |         *some_vec.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get_mut().unwrap()` on a VecDeque. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:53:9\n+   |\n+LL |         *some_vecdeque.get_mut(0).unwrap() = 1;\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vecdeque[0]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:53:10\n+   |\n+LL |         *some_vecdeque.get_mut(0).unwrap() = 1;\n+   |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a Vec. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:65:17\n+   |\n+LL |         let _ = some_vec.get(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0..1]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:65:17\n+   |\n+LL |         let _ = some_vec.get(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get_mut().unwrap()` on a Vec. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:66:17\n+   |\n+LL |         let _ = some_vec.get_mut(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `some_vec[0..1]`\n+\n+error: used `unwrap()` on `an Option` value\n+  --> $DIR/unwrap_used.rs:66:17\n+   |\n+LL |         let _ = some_vec.get_mut(0..1).unwrap().to_vec();\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: if you don't want to handle the `None` case gracefully, consider using `expect()` to provide a better panic message\n+\n+error: called `.get().unwrap()` on a slice. Using `[]` is more clear and more concise\n+  --> $DIR/unwrap_used.rs:73:13\n+   |\n+LL |     let _ = boxed_slice.get(1).unwrap();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&boxed_slice[1]`\n+\n+error: aborting due to 27 previous errors\n+"}]}