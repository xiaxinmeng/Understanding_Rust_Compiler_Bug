{"sha": "5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhYjVhODgwMWUwNWQ2YWNjMDY0MTNjMjYwMjFkZDRjZWI1NjA2YWQ=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-18T13:27:35Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-01-18T13:27:35Z"}, "message": "Merge pull request #556 from mcarton/or_fun_call\n\nNew lint, new utility functions and nightly fix", "tree": {"sha": "7a17529508bcb9e6d0b2d3ff59ea21170136ae94", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a17529508bcb9e6d0b2d3ff59ea21170136ae94"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "html_url": "https://github.com/rust-lang/rust/commit/5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2b1a050b197c233be983a1cedb97468afbd85f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2b1a050b197c233be983a1cedb97468afbd85f7", "html_url": "https://github.com/rust-lang/rust/commit/e2b1a050b197c233be983a1cedb97468afbd85f7"}, {"sha": "8642306f090f2f91c89d5cb992b3085ec0f39699", "url": "https://api.github.com/repos/rust-lang/rust/commits/8642306f090f2f91c89d5cb992b3085ec0f39699", "html_url": "https://github.com/rust-lang/rust/commit/8642306f090f2f91c89d5cb992b3085ec0f39699"}], "stats": {"total": 298, "additions": 277, "deletions": 21}, "files": [{"sha": "29644a14fc48a7c4d22d347f128a9923b547a691", "filename": "README.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -6,7 +6,7 @@ A collection of lints to catch common mistakes and improve your Rust code.\n [Jump to usage instructions](#usage)\n \n ##Lints\n-There are 92 lints included in this crate:\n+There are 93 lints included in this crate:\n \n name                                                                                                           | default | meaning\n ---------------------------------------------------------------------------------------------------------------|---------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\n@@ -63,6 +63,7 @@ name\n [option_map_unwrap_or](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or)                   | warn    | using `Option.map(f).unwrap_or(a)`, which is more succinctly expressed as `map_or(a, f)`\n [option_map_unwrap_or_else](https://github.com/Manishearth/rust-clippy/wiki#option_map_unwrap_or_else)         | warn    | using `Option.map(f).unwrap_or_else(g)`, which is more succinctly expressed as `map_or_else(g, f)`\n [option_unwrap_used](https://github.com/Manishearth/rust-clippy/wiki#option_unwrap_used)                       | allow   | using `Option.unwrap()`, which should at least get a better message using `expect()`\n+[or_fun_call](https://github.com/Manishearth/rust-clippy/wiki#or_fun_call)                                     | warn    | using any `*or` method when the `*or_else` would do\n [out_of_bounds_indexing](https://github.com/Manishearth/rust-clippy/wiki#out_of_bounds_indexing)               | deny    | out of bound constant indexing\n [panic_params](https://github.com/Manishearth/rust-clippy/wiki#panic_params)                                   | warn    | missing parameters in `panic!`\n [precedence](https://github.com/Manishearth/rust-clippy/wiki#precedence)                                       | warn    | catches operations where precedence may be unclear. See the wiki for a list of cases caught"}, {"sha": "0e98f5a93a94ec56bde93d57ca392c730ef11363", "filename": "src/bit_mask.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbit_mask.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -278,7 +278,7 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                     _ => None,\n                 }\n             }\n-            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n+            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None, None))\n             .and_then(|l| fetch_int_literal(cx, l))\n         }\n         _ => None,"}, {"sha": "7b022947719a59efd0fa30d9e39f319b3c34a39d", "filename": "src/consts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconsts.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -484,9 +484,9 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n             if let Some(&PathResolution { base_def: DefConst(id), ..}) = lcx.tcx.def_map.borrow().get(&e.id) {\n                 maybe_id = Some(id);\n             }\n-            // separate if lets to avoid doubleborrowing the defmap\n+            // separate if lets to avoid double borrowing the def_map\n             if let Some(id) = maybe_id {\n-                if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None) {\n+                if let Some(const_expr) = lookup_const_by_id(lcx.tcx, id, None, None) {\n                     let ret = self.expr(const_expr);\n                     if ret.is_some() {\n                         self.needed_resolution = true;"}, {"sha": "70151054e9553dad6963e4dd15c770aac200f2cb", "filename": "src/escape.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fescape.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -52,7 +52,7 @@ impl LintPass for EscapePass {\n impl LateLintPass for EscapePass {\n     fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Block, _: Span, id: NodeId) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n-        let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(param_env), false);\n+        let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, Some(param_env));\n         let mut v = EscapeDelegate {\n             cx: cx,\n             set: NodeSet(),"}, {"sha": "4e13ba5c45838b72c82f3e80b6b6e9fd02a17390", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -194,6 +194,7 @@ pub fn plugin_registrar(reg: &mut Registry) {\n         methods::OK_EXPECT,\n         methods::OPTION_MAP_UNWRAP_OR,\n         methods::OPTION_MAP_UNWRAP_OR_ELSE,\n+        methods::OR_FUN_CALL,\n         methods::SEARCH_IS_SOME,\n         methods::SHOULD_IMPLEMENT_TRAIT,\n         methods::STR_TO_STRING,"}, {"sha": "b5ce82f1a43a0c16fc44842b11976fb4ff6f9347", "filename": "src/methods.rs", "status": "modified", "additions": 126, "deletions": 4, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmethods.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -4,11 +4,14 @@ use rustc::middle::ty;\n use rustc::middle::subst::{Subst, TypeSpace};\n use std::iter;\n use std::borrow::Cow;\n+use syntax::ptr::P;\n+use syntax::codemap::Span;\n \n use utils::{snippet, span_lint, span_note_and_lint, match_path, match_type, method_chain_args, match_trait_method,\n-            walk_ptrs_ty_depth, walk_ptrs_ty};\n-use utils::{OPTION_PATH, RESULT_PATH, STRING_PATH};\n+            walk_ptrs_ty_depth, walk_ptrs_ty, get_trait_def_id, implements_trait};\n+use utils::{DEFAULT_TRAIT_PATH, OPTION_PATH, RESULT_PATH, STRING_PATH};\n use utils::MethodArgs;\n+use rustc::middle::cstore::CrateStore;\n \n use self::SelfKind::*;\n use self::OutType::*;\n@@ -170,6 +173,28 @@ declare_lint!(pub SEARCH_IS_SOME, Warn,\n               \"using an iterator search followed by `is_some()`, which is more succinctly \\\n                expressed as a call to `any()`\");\n \n+/// **What it does:** This lint checks for calls to `.or(foo(..))`, `.unwrap_or(foo(..))`, etc., and\n+/// suggests to use `or_else`, `unwrap_or_else`, etc., or `unwrap_or_default` instead.\n+///\n+/// **Why is this bad?** The function will always be called and potentially allocate an object\n+/// in expressions such as:\n+/// ```rust\n+/// foo.unwrap_or(String::new())\n+/// ```\n+/// this can instead be written:\n+/// ```rust\n+/// foo.unwrap_or_else(String::new)\n+/// ```\n+/// or\n+/// ```rust\n+/// foo.unwrap_or_default()\n+/// ```\n+///\n+/// **Known problems:** If the function as side-effects, not calling it will change the semantic of\n+/// the program, but you shouldn't rely on that anyway.\n+declare_lint!(pub OR_FUN_CALL, Warn,\n+              \"using any `*or` method when the `*or_else` would do\");\n+\n impl LintPass for MethodsPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(OPTION_UNWRAP_USED,\n@@ -181,13 +206,15 @@ impl LintPass for MethodsPass {\n                     WRONG_PUB_SELF_CONVENTION,\n                     OK_EXPECT,\n                     OPTION_MAP_UNWRAP_OR,\n-                    OPTION_MAP_UNWRAP_OR_ELSE)\n+                    OPTION_MAP_UNWRAP_OR_ELSE,\n+                    OR_FUN_CALL)\n     }\n }\n \n impl LateLintPass for MethodsPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let ExprMethodCall(_, _, _) = expr.node {\n+        if let ExprMethodCall(name, _, ref args) = expr.node {\n+            // Chain calls\n             if let Some(arglists) = method_chain_args(expr, &[\"unwrap\"]) {\n                 lint_unwrap(cx, expr, arglists[0]);\n             } else if let Some(arglists) = method_chain_args(expr, &[\"to_string\"]) {\n@@ -207,6 +234,8 @@ impl LateLintPass for MethodsPass {\n             } else if let Some(arglists) = method_chain_args(expr, &[\"rposition\", \"is_some\"]) {\n                 lint_search_is_some(cx, expr, \"rposition\", arglists[0], arglists[1]);\n             }\n+\n+            lint_or_fun_call(cx, expr, &name.node.as_str(), &args);\n         }\n     }\n \n@@ -258,6 +287,99 @@ impl LateLintPass for MethodsPass {\n     }\n }\n \n+/// Checks for the `OR_FUN_CALL` lint.\n+fn lint_or_fun_call(cx: &LateContext, expr: &Expr, name: &str, args: &[P<Expr>]) {\n+    /// Check for `unwrap_or(T::new())` or `unwrap_or(T::default())`.\n+    fn check_unwrap_or_default(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &Expr,\n+        self_expr: &Expr,\n+        arg: &Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) -> bool {\n+        if or_has_args {\n+            return false;\n+        }\n+\n+        if name == \"unwrap_or\" {\n+            if let ExprPath(_, ref path) = fun.node {\n+                let path : &str = &path.segments.last()\n+                    .expect(\"A path must have at least one segment\")\n+                    .identifier.name.as_str();\n+\n+                if [\"default\", \"new\"].contains(&path) {\n+                    let arg_ty = cx.tcx.expr_ty(arg);\n+                    let default_trait_id = if let Some(default_trait_id) = get_trait_def_id(cx, &DEFAULT_TRAIT_PATH) {\n+                        default_trait_id\n+                    }\n+                    else {\n+                        return false;\n+                    };\n+\n+                    if implements_trait(cx, arg_ty, default_trait_id) {\n+                        span_lint(cx, OR_FUN_CALL, span,\n+                                  &format!(\"use of `{}` followed by a call to `{}`\", name, path))\n+                            .span_suggestion(span, \"try this\",\n+                                             format!(\"{}.unwrap_or_default()\",\n+                                                     snippet(cx, self_expr.span, \"_\")));\n+                        return true;\n+                    }\n+                }\n+            }\n+        }\n+\n+        false\n+    }\n+\n+    /// Check for `*or(foo())`.\n+    fn check_general_case(\n+        cx: &LateContext,\n+        name: &str,\n+        fun: &Expr,\n+        self_expr: &Expr,\n+        arg: &Expr,\n+        or_has_args: bool,\n+        span: Span\n+    ) {\n+        let self_ty = cx.tcx.expr_ty(self_expr);\n+\n+        let is_result = if match_type(cx, self_ty, &RESULT_PATH) {\n+            true\n+        }\n+        else if match_type(cx, self_ty, &OPTION_PATH) {\n+            false\n+        }\n+        else {\n+            return;\n+        };\n+\n+        let sugg = match (is_result, !or_has_args) {\n+            (true, _) => format!(\"|_| {}\", snippet(cx, arg.span, \"..\")),\n+            (false, false) => format!(\"|| {}\", snippet(cx, arg.span, \"..\")),\n+            (false, true) => format!(\"{}\", snippet(cx, fun.span, \"..\")),\n+        };\n+\n+        span_lint(cx, OR_FUN_CALL, span,\n+                  &format!(\"use of `{}` followed by a function call\", name))\n+            .span_suggestion(span, \"try this\",\n+                             format!(\"{}.{}_else({})\",\n+                                     snippet(cx, self_expr.span, \"_\"),\n+                                     name,\n+                                     sugg));\n+    }\n+\n+    if args.len() == 2 && [\"map_or\", \"ok_or\", \"or\", \"unwrap_or\"].contains(&name) {\n+        if let ExprCall(ref fun, ref or_args) = args[1].node {\n+            let or_has_args = !or_args.is_empty();\n+            if !check_unwrap_or_default(cx, name, fun, &args[0], &args[1], or_has_args, expr.span) {\n+                check_general_case(cx, name, fun, &args[0], &args[1], or_has_args, expr.span);\n+            }\n+        }\n+    }\n+}\n+\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n /// lint use of `unwrap()` for `Option`s and `Result`s"}, {"sha": "446303f8bb192a95bdc348882a1576703e2652b3", "filename": "src/utils.rs", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -1,20 +1,20 @@\n-use rustc::lint::*;\n-use rustc_front::hir::*;\n+use consts::constant;\n use reexport::*;\n-use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use rustc::front::map::Node::*;\n+use rustc::lint::*;\n use rustc::middle::def_id::DefId;\n-use rustc::middle::ty;\n+use rustc::middle::{cstore, def, infer, ty, traits};\n+use rustc::session::Session;\n+use rustc_front::hir::*;\n use std::borrow::Cow;\n+use std::mem;\n+use std::ops::{Deref, DerefMut};\n+use std::str::FromStr;\n use syntax::ast::Lit_::*;\n use syntax::ast;\n+use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n-use consts::constant;\n-\n-use rustc::session::Session;\n-use std::str::FromStr;\n-use std::ops::{Deref, DerefMut};\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -23,6 +23,7 @@ pub const BEGIN_UNWIND: [&'static str; 3] = [\"std\", \"rt\", \"begin_unwind\"];\n pub const BTREEMAP_PATH: [&'static str; 4] = [\"collections\", \"btree\", \"map\", \"BTreeMap\"];\n pub const CLONE_PATH: [&'static str; 2] = [\"Clone\", \"clone\"];\n pub const COW_PATH: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n+pub const DEFAULT_TRAIT_PATH: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const HASHMAP_PATH: [&'static str; 5] = [\"std\", \"collections\", \"hash\", \"map\", \"HashMap\"];\n pub const LL_PATH: [&'static str; 3] = [\"collections\", \"linked_list\", \"LinkedList\"];\n pub const MUTEX_PATH: [&'static str; 4] = [\"std\", \"sync\", \"mutex\", \"Mutex\"];\n@@ -132,7 +133,7 @@ pub fn match_type(cx: &LateContext, ty: ty::Ty, path: &[&str]) -> bool {\n     }\n }\n \n-/// Check if the method call given in `expr` belongs to given trait.\n+/// Check if the method call given in `expr` belongs to given type.\n pub fn match_impl_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool {\n     let method_call = ty::MethodCall::expr(expr.id);\n \n@@ -186,6 +187,73 @@ pub fn match_path_ast(path: &ast::Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.identifier.name.as_str() == *b)\n }\n \n+/// Get the definition associated to a path.\n+/// TODO: investigate if there is something more efficient for that.\n+pub fn path_to_def(cx: &LateContext, path: &[&str]) -> Option<cstore::DefLike> {\n+    let cstore = &cx.tcx.sess.cstore;\n+\n+    let crates = cstore.crates();\n+    let krate = crates.iter().find(|&&krate| cstore.crate_name(krate) == path[0]);\n+    if let Some(krate) = krate {\n+        let mut items = cstore.crate_top_level_items(*krate);\n+        let mut path_it = path.iter().skip(1).peekable();\n+\n+        loop {\n+            let segment = match path_it.next() {\n+                Some(segment) => segment,\n+                None => return None\n+            };\n+\n+            for item in &mem::replace(&mut items, vec![]) {\n+                if item.name.as_str() == *segment {\n+                    if path_it.peek().is_none() {\n+                        return Some(item.def);\n+                    }\n+\n+                    let def_id = match item.def {\n+                        cstore::DefLike::DlDef(def) => def.def_id(),\n+                        cstore::DefLike::DlImpl(def_id) => def_id,\n+                        _ => panic!(\"Unexpected {:?}\", item.def),\n+                    };\n+\n+                    items = cstore.item_children(def_id);\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    else {\n+        None\n+    }\n+}\n+\n+/// Convenience function to get the `DefId` of a trait by path.\n+pub fn get_trait_def_id(cx: &LateContext, path: &[&str]) -> Option<DefId> {\n+    let def = match path_to_def(cx, path) {\n+        Some(def) => def,\n+        None => return None,\n+    };\n+\n+    match def {\n+        cstore::DlDef(def::DefTrait(trait_id)) => Some(trait_id),\n+        _ => None,\n+    }\n+}\n+\n+/// Check whether a type implements a trait.\n+/// See also `get_trait_def_id`.\n+pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, trait_id: DefId) -> bool {\n+    cx.tcx.populate_implementations_for_trait_if_necessary(trait_id);\n+\n+    let infcx = infer::new_infer_ctxt(cx.tcx, &cx.tcx.tables, None);\n+    let obligation = traits::predicate_for_trait_def(cx.tcx,\n+                                                     traits::ObligationCause::dummy(),\n+                                                     trait_id, 0, ty,\n+                                                     vec![]);\n+\n+    traits::SelectionContext::new(&infcx).evaluate_obligation_conservatively(&obligation)\n+}\n+\n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n ///\n /// For example, if `expr` represents the `.baz()` in `foo.bar().baz()`,\n@@ -244,7 +312,7 @@ pub fn is_from_for_desugar(decl: &Decl) -> bool {\n /// snippet(cx, expr.span, \"..\")\n /// ```\n pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n-    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or(Cow::Borrowed(default))\n+    cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available."}, {"sha": "f8642cb3ed8c99cc5c2d0475b53506456a8a886e", "filename": "tests/compile-fail/methods.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/tests%2Fcompile-fail%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/tests%2Fcompile-fail%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmethods.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -175,6 +175,71 @@ fn search_is_some() {\n     let _ = foo.rposition().is_some();\n }\n \n+/// Checks implementation of the OR_FUN_CALL lint\n+fn or_fun_call() {\n+    struct Foo;\n+\n+    impl Foo {\n+        fn new() -> Foo { Foo }\n+    }\n+\n+    fn make<T>() -> T { unimplemented!(); }\n+\n+    let with_constructor = Some(vec![1]);\n+    with_constructor.unwrap_or(make());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_constructor.unwrap_or_else(make)\n+\n+    let with_new = Some(vec![1]);\n+    with_new.unwrap_or(Vec::new());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_new.unwrap_or_default();\n+\n+    let with_const_args = Some(vec![1]);\n+    with_const_args.unwrap_or(Vec::with_capacity(12));\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_const_args.unwrap_or_else(|| Vec::with_capacity(12));\n+\n+    let with_err : Result<_, ()> = Ok(vec![1]);\n+    with_err.unwrap_or(make());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_err.unwrap_or_else(|_| make());\n+\n+    let with_err_args : Result<_, ()> = Ok(vec![1]);\n+    with_err_args.unwrap_or(Vec::with_capacity(12));\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_err_args.unwrap_or_else(|_| Vec::with_capacity(12));\n+\n+    let with_default_trait = Some(1);\n+    with_default_trait.unwrap_or(Default::default());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_default_trait.unwrap_or_default();\n+\n+    let with_default_type = Some(1);\n+    with_default_type.unwrap_or(u64::default());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_default_type.unwrap_or_default();\n+\n+    let with_vec = Some(vec![1]);\n+    with_vec.unwrap_or(vec![]);\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION with_vec.unwrap_or_else(|| vec![]);\n+\n+    let without_default = Some(Foo);\n+    without_default.unwrap_or(Foo::new());\n+    //~^ERROR use of `unwrap_or`\n+    //~|HELP try this\n+    //~|SUGGESTION without_default.unwrap_or_else(Foo::new);\n+}\n+\n fn main() {\n     use std::io;\n "}, {"sha": "c5c82c7072b75439ae38f74c8ca7939b6678e996", "filename": "tests/compile-fail/needless_features.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/tests%2Fcompile-fail%2Fneedless_features.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5ab5a8801e05d6acc06413c26021dd4ceb5606ad/tests%2Fcompile-fail%2Fneedless_features.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_features.rs?ref=5ab5a8801e05d6acc06413c26021dd4ceb5606ad", "patch": "@@ -1,5 +1,4 @@\n #![feature(plugin)]\n-#![feature(convert)]\n #![plugin(clippy)]\n \n #![deny(clippy)]"}]}