{"sha": "a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE0ZDIyNjM1ZTE0NTNkNzdlOTBjNDMzNWY1YzJlMWY2MmUzMTg1ZWI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T19:41:31Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T21:29:41Z"}, "message": "add an initial radix trie implementation", "tree": {"sha": "137be82a6f92599c623f0ef17c13fd1f4b985a7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/137be82a6f92599c623f0ef17c13fd1f4b985a7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "comment_count": 6, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "html_url": "https://github.com/rust-lang/rust/commit/a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4d22635e1453d77e90c4335f5c2e1f62e3185eb/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c", "html_url": "https://github.com/rust-lang/rust/commit/afdd0b868a4b94e828ccf7e1f68a2b0017943e2c"}], "stats": {"total": 370, "additions": 370, "deletions": 0}, "files": [{"sha": "6d4063a62262ba5e9a7b759f7f114596651d640d", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4d22635e1453d77e90c4335f5c2e1f62e3185eb/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a4d22635e1453d77e90c4335f5c2e1f62e3185eb/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "patch": "@@ -144,6 +144,7 @@ pub mod dlist;\n pub mod dlist_iter;\n pub mod hashmap;\n pub mod cell;\n+pub mod trie;\n \n \n /* Tasks and communication */"}, {"sha": "c8faccf28f25540ec0b22c39ec66219b10a809b4", "filename": "src/libcore/trie.rs", "status": "added", "additions": 369, "deletions": 0, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/a4d22635e1453d77e90c4335f5c2e1f62e3185eb/src%2Flibcore%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4d22635e1453d77e90c4335f5c2e1f62e3185eb/src%2Flibcore%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftrie.rs?ref=a4d22635e1453d77e90c4335f5c2e1f62e3185eb", "patch": "@@ -0,0 +1,369 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! A radix trie for storing integers in sorted order\n+\n+use prelude::*;\n+\n+// FIXME: #3469: need to manually update TrieNode when SHIFT changes\n+const SHIFT: uint = 4;\n+const SIZE: uint = 1 << SHIFT;\n+const MASK: uint = SIZE - 1;\n+\n+enum Child<T> {\n+    Internal(~TrieNode<T>),\n+    External(uint, T),\n+    Nothing\n+}\n+\n+pub struct TrieMap<T> {\n+    priv root: TrieNode<T>,\n+    priv length: uint\n+}\n+\n+impl<T> BaseIter<(uint, &T)> for TrieMap<T> {\n+    /// Visit all key-value pairs in order\n+    #[inline(always)]\n+    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        self.root.each(f)\n+    }\n+    #[inline(always)]\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl<T> ReverseIter<(uint, &T)> for TrieMap<T> {\n+    /// Visit all key-value pairs in reverse order\n+    #[inline(always)]\n+    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        self.root.each_reverse(f)\n+    }\n+}\n+\n+impl<T> Container for TrieMap<T> {\n+    /// Return the number of elements in the map\n+    #[inline(always)]\n+    pure fn len(&self) -> uint { self.length }\n+\n+    /// Return true if the map contains no elements\n+    #[inline(always)]\n+    pure fn is_empty(&self) -> bool { self.len() == 0 }\n+}\n+\n+impl<T: Copy> Mutable for TrieMap<T> {\n+    /// Clear the map, removing all values.\n+    #[inline(always)]\n+    fn clear(&mut self) {\n+        self.root = TrieNode::new();\n+        self.length = 0;\n+    }\n+}\n+\n+impl<T: Copy> Map<uint, T> for TrieMap<T> {\n+    /// Return true if the map contains a value for the specified key\n+    #[inline(always)]\n+    pure fn contains_key(&self, key: &uint) -> bool {\n+        self.find(key).is_some()\n+    }\n+\n+    /// Visit all keys in order\n+    #[inline(always)]\n+    pure fn each_key(&self, f: fn(&uint) -> bool) {\n+        self.each(|&(k, _)| f(&k))\n+    }\n+\n+    /// Visit all values in order\n+    #[inline(always)]\n+    pure fn each_value(&self, f: fn(&T) -> bool) { self.each(|&(_, v)| f(v)) }\n+\n+    /// Return the value corresponding to the key in the map\n+    #[inline(hint)]\n+    pure fn find(&self, key: &uint) -> Option<&self/T> {\n+        let mut node: &self/TrieNode<T> = &self.root;\n+        let mut idx = 0;\n+        loop {\n+            match node.children[chunk(*key, idx)] {\n+              Internal(ref x) => node = &**x,\n+              External(stored, ref value) => {\n+                if stored == *key {\n+                    return Some(value)\n+                } else {\n+                    return None\n+                }\n+              }\n+              Nothing => return None\n+            }\n+            idx += 1;\n+        }\n+    }\n+\n+    /// Insert a key-value pair into the map. An existing value for a\n+    /// key is replaced by the new value. Return true if the key did\n+    /// not already exist in the map.\n+    #[inline(always)]\n+    fn insert(&mut self, key: uint, value: T) -> bool {\n+        let ret = insert(&mut self.root.count,\n+                         &mut self.root.children[chunk(key, 0)],\n+                         key, value, 1);\n+        if ret { self.length += 1 }\n+        ret\n+    }\n+\n+    /// Remove a key-value pair from the map. Return true if the key\n+    /// was present in the map, otherwise false.\n+    #[inline(always)]\n+    fn remove(&mut self, key: &uint) -> bool {\n+        let ret = remove(&mut self.root.count,\n+                         &mut self.root.children[chunk(*key, 0)],\n+                         *key, 1);\n+        if ret { self.length -= 1 }\n+        ret\n+    }\n+}\n+\n+impl<T: Copy> TrieMap<T> {\n+    #[inline(always)]\n+    static pure fn new() -> TrieMap<T> {\n+        TrieMap{root: TrieNode::new(), length: 0}\n+    }\n+}\n+\n+impl<T> TrieMap<T> {\n+    /// Visit all keys in reverse order\n+    #[inline(always)]\n+    pure fn each_key_reverse(&self, f: fn(&uint) -> bool) {\n+        self.each_reverse(|&(k, _)| f(&k))\n+    }\n+\n+    /// Visit all values in reverse order\n+    #[inline(always)]\n+    pure fn each_value_reverse(&self, f: fn(&T) -> bool) {\n+        self.each_reverse(|&(_, v)| f(v))\n+    }\n+\n+    /// Iterate over the map and mutate the contained values\n+    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+        self.root.mutate_values(f)\n+    }\n+}\n+\n+pub struct TrieSet {\n+    priv map: TrieMap<()>\n+}\n+\n+impl BaseIter<uint> for TrieSet {\n+    /// Visit all values in order\n+    pure fn each(&self, f: fn(&uint) -> bool) { self.map.each_key(f) }\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl ReverseIter<uint> for TrieSet {\n+    /// Visit all values in reverse order\n+    pure fn each_reverse(&self, f: fn(&uint) -> bool) {\n+        self.map.each_key_reverse(f)\n+    }\n+}\n+\n+impl Container for TrieSet {\n+    /// Return the number of elements in the set\n+    #[inline(always)]\n+    pure fn len(&self) -> uint { self.map.len() }\n+\n+    /// Return true if the set contains no elements\n+    #[inline(always)]\n+    pure fn is_empty(&self) -> bool { self.map.is_empty() }\n+}\n+\n+impl Mutable for TrieSet {\n+    /// Clear the set, removing all values.\n+    #[inline(always)]\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n+impl TrieSet {\n+    /// Return true if the set contains a value\n+    #[inline(always)]\n+    pure fn contains(&self, value: &uint) -> bool {\n+        self.map.contains_key(value)\n+    }\n+\n+    /// Add a value to the set. Return true if the value was not already\n+    /// present in the set.\n+    #[inline(always)]\n+    fn insert(&mut self, value: uint) -> bool { self.map.insert(value, ()) }\n+\n+    /// Remove a value from the set. Return true if the value was\n+    /// present in the set.\n+    #[inline(always)]\n+    fn remove(&mut self, value: &uint) -> bool { self.map.remove(value) }\n+}\n+\n+struct TrieNode<T> {\n+    count: uint,\n+    children: [Child<T> * 16] // FIXME: #3469: can't use the SIZE constant yet\n+}\n+\n+impl<T: Copy> TrieNode<T> {\n+    #[inline(always)]\n+    static pure fn new() -> TrieNode<T> {\n+        TrieNode{count: 0, children: [Nothing, ..SIZE]}\n+    }\n+}\n+\n+impl<T> TrieNode<T> {\n+    pure fn each(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        for uint::range(0, self.children.len()) |idx| {\n+            match self.children[idx] {\n+                Internal(ref x) => x.each(f),\n+                External(k, ref v) => if !f(&(k, v)) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+\n+    pure fn each_reverse(&self, f: fn(&(uint, &self/T)) -> bool) {\n+        for uint::range_rev(self.children.len(), 0) |idx| {\n+            match self.children[idx - 1] {\n+                Internal(ref x) => x.each(f),\n+                External(k, ref v) => if !f(&(k, v)) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+\n+    fn mutate_values(&mut self, f: fn(uint, &mut T) -> bool) {\n+        for vec::each_mut(self.children) |child| {\n+            match *child {\n+                Internal(ref mut x) => x.mutate_values(f),\n+                External(k, ref mut v) => if !f(k, v) { return },\n+                Nothing => ()\n+            }\n+        }\n+    }\n+}\n+\n+// if this was done via a trait, the key could be generic\n+#[inline(always)]\n+pure fn chunk(n: uint, idx: uint) -> uint {\n+    let real_idx = uint::bytes - 1 - idx;\n+    (n >> (SHIFT * real_idx)) & MASK\n+}\n+\n+fn insert<T: Copy>(count: &mut uint, child: &mut Child<T>, key: uint,\n+                   value: T, idx: uint) -> bool {\n+    match *child {\n+      External(stored_key, stored_value) => {\n+          if stored_key == key {\n+              false // already in the trie\n+          } else {\n+              // conflict - split the node\n+              let mut new = ~TrieNode::new();\n+              insert(&mut new.count,\n+                     &mut new.children[chunk(stored_key, idx)],\n+                     stored_key, stored_value, idx + 1);\n+              insert(&mut new.count, &mut new.children[chunk(key, idx)], key,\n+                     value, idx + 1);\n+              *child = Internal(new);\n+              true\n+          }\n+      }\n+      Internal(ref mut x) => {\n+        insert(&mut x.count, &mut x.children[chunk(key, idx)], key, value,\n+               idx + 1)\n+      }\n+      Nothing => {\n+        *count += 1;\n+        *child = External(key, value);\n+        true\n+      }\n+    }\n+}\n+\n+fn remove<T>(count: &mut uint, child: &mut Child<T>, key: uint,\n+             idx: uint) -> bool {\n+    let (ret, this) = match *child {\n+      External(stored, _) => {\n+          if stored == key { (true, true) } else { (false, false) }\n+      }\n+      Internal(ref mut x) => {\n+          let ret = remove(&mut x.count, &mut x.children[chunk(key, idx)],\n+                           key, idx + 1);\n+          (ret, x.count == 0)\n+      }\n+      Nothing => (false, false)\n+    };\n+\n+    if this {\n+        *child = Nothing;\n+        *count -= 1;\n+    }\n+    ret\n+}\n+\n+#[cfg(test)]\n+pub fn check_integrity<T>(trie: &TrieNode<T>) {\n+    assert trie.count != 0;\n+\n+    let mut sum = 0;\n+\n+    for trie.children.each |x| {\n+        match *x {\n+          Nothing => (),\n+          Internal(ref y) => {\n+              check_integrity(&**y);\n+              sum += 1\n+          }\n+          External(_, _) => { sum += 1 }\n+        }\n+    }\n+\n+    assert sum == trie.count;\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use uint;\n+\n+    #[test]\n+    fn test_step() {\n+        let mut trie = TrieMap::new();\n+        let n = 300;\n+\n+        for uint::range_step(1, n, 2) |x| {\n+            assert trie.insert(x, x + 1);\n+            assert trie.contains_key(&x);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(0, n, 2) |x| {\n+            assert !trie.contains_key(&x);\n+            assert trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range(0, n) |x| {\n+            assert trie.contains_key(&x);\n+            assert !trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(1, n, 2) |x| {\n+            assert trie.remove(&x);\n+            assert !trie.contains_key(&x);\n+            check_integrity(&trie.root);\n+        }\n+\n+        for uint::range_step(0, n, 2) |x| {\n+            assert trie.contains_key(&x);\n+            assert !trie.insert(x, x + 1);\n+            check_integrity(&trie.root);\n+        }\n+    }\n+}"}]}