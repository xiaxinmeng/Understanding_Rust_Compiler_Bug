{"sha": "26ab36afb1e3bdce8c6cd995aa964d2730aec268", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI2YWIzNmFmYjFlM2JkY2U4YzZjZDk5NWFhOTY0ZDI3MzBhZWMyNjg=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-11T18:56:49Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-05-11T19:05:02Z"}, "message": "rustc: Hoist derived type descriptors to the top of the function", "tree": {"sha": "f16bdea2968a556587fc6491ba0bb4e9c068df5e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f16bdea2968a556587fc6491ba0bb4e9c068df5e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/26ab36afb1e3bdce8c6cd995aa964d2730aec268", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/26ab36afb1e3bdce8c6cd995aa964d2730aec268", "html_url": "https://github.com/rust-lang/rust/commit/26ab36afb1e3bdce8c6cd995aa964d2730aec268", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/26ab36afb1e3bdce8c6cd995aa964d2730aec268/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c787d6d4f370507677cf34855a274204201506c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c787d6d4f370507677cf34855a274204201506c9", "html_url": "https://github.com/rust-lang/rust/commit/c787d6d4f370507677cf34855a274204201506c9"}], "stats": {"total": 189, "additions": 120, "deletions": 69}, "files": [{"sha": "d9d520e253f296fb86fc498469a0f2c26c38def9", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 120, "deletions": 69, "changes": 189, "blob_url": "https://github.com/rust-lang/rust/blob/26ab36afb1e3bdce8c6cd995aa964d2730aec268/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/26ab36afb1e3bdce8c6cd995aa964d2730aec268/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=26ab36afb1e3bdce8c6cd995aa964d2730aec268", "patch": "@@ -52,6 +52,8 @@ state obj namegen(mutable int i) {\n     }\n }\n \n+type derived_tydesc_info = rec(ValueRef lltydesc, bool escapes);\n+\n type glue_fns = rec(ValueRef activate_glue,\n                     ValueRef yield_glue,\n                     ValueRef exit_task_glue,\n@@ -131,13 +133,16 @@ state type fn_ctxt = rec(ValueRef llfn,\n                          ValueRef llenv,\n                          ValueRef llretptr,\n                          mutable BasicBlockRef llallocas,\n+                         mutable BasicBlockRef llcopyargs,\n+                         mutable BasicBlockRef llderivedtydescs,\n                          mutable Option.t[self_vt] llself,\n                          mutable Option.t[ValueRef] lliterbody,\n                          hashmap[ast.def_id, ValueRef] llargs,\n                          hashmap[ast.def_id, ValueRef] llobjfields,\n                          hashmap[ast.def_id, ValueRef] lllocals,\n                          hashmap[ast.def_id, ValueRef] llupvars,\n                          mutable vec[ValueRef] lltydescs,\n+                         hashmap[ty.t, derived_tydesc_info] derived_tydescs,\n                          @local_ctxt lcx);\n \n tag cleanup {\n@@ -1613,7 +1618,7 @@ fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n                                     ValueRef llalign,\n                                     ValueRef llroottydesc,\n                                     &Option.t[ValueRef] llparamtydescs)\n-    -> result {\n+        -> ValueRef {\n     auto llmyroottydesc = alloca(cx, T_tydesc(cx.fcx.lcx.ccx.tn));\n \n     // By convention, desc 0 is the root descriptor.\n@@ -1642,36 +1647,47 @@ fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n     cx.build.Store(llalign,\n                    cx.build.GEP(llmyroottydesc, vec(C_int(0), C_int(2))));\n \n-    ret res(cx, llmyroottydesc);\n+    ret llmyroottydesc;\n }\n \n fn mk_derived_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n-    let uint n_params = ty.count_ty_params(cx.fcx.lcx.ccx.tcx, t);\n-    auto tys = linearize_ty_params(cx, t);\n+    alt (cx.fcx.derived_tydescs.find(t)) {\n+        case (some[derived_tydesc_info](?info)) {\n+            // If the tydesc escapes in this context, the cached derived\n+            // tydesc also has to be one that was marked as escaping.\n+            if (!(escapes && !info.escapes)) { ret res(cx, info.lltydesc); }\n+        }\n+        case (none[derived_tydesc_info]) { /* fall through */ }\n+    }\n+\n+    auto bcx = new_raw_block_ctxt(cx.fcx, cx.fcx.llderivedtydescs);\n+\n+    let uint n_params = ty.count_ty_params(bcx.fcx.lcx.ccx.tcx, t);\n+    auto tys = linearize_ty_params(bcx, t);\n \n     assert (n_params == Vec.len[uint](tys._0));\n     assert (n_params == Vec.len[ValueRef](tys._1));\n \n-    auto root = get_static_tydesc(cx, t, tys._0).tydesc;\n+    auto root = get_static_tydesc(bcx, t, tys._0).tydesc;\n \n-    auto bcx = cx;\n     auto sz = size_of(bcx, t);\n     bcx = sz.bcx;\n     auto align = align_of(bcx, t);\n     bcx = align.bcx;\n \n     auto v;\n     if (escapes) {\n-        auto tydescs = alloca(cx, T_array(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)),\n-                                          1u /* for root*/ + n_params));\n+        auto tydescs = alloca(bcx,\n+                              T_array(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)),\n+                                      1u /* for root*/ + n_params));\n \n         auto i = 0;\n-        auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n-        cx.build.Store(root, tdp);\n+        auto tdp = bcx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n+        bcx.build.Store(root, tdp);\n         i += 1;\n         for (ValueRef td in tys._1) {\n-            auto tdp = cx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n-            cx.build.Store(td, tdp);\n+            auto tdp = bcx.build.GEP(tydescs, vec(C_int(0), C_int(i)));\n+            bcx.build.Store(td, tdp);\n             i += 1;\n         }\n \n@@ -1684,20 +1700,20 @@ fn mk_derived_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n                 align.val,\n                 C_int((1u + n_params) as int),\n                 lltydescsptr));\n-        v = res(bcx, td_val);\n+        v = td_val;\n     } else {\n         auto llparamtydescs_opt;\n         if (n_params == 0u) {\n             llparamtydescs_opt = none[ValueRef];\n         } else {\n-            auto llparamtydescs = alloca(cx,\n-                T_array(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)), n_params));\n+            auto llparamtydescs = alloca(bcx,\n+                T_array(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)), n_params));\n \n             auto i = 0;\n             for (ValueRef td in tys._1) {\n-                auto tdp = cx.build.GEP(llparamtydescs,\n+                auto tdp = bcx.build.GEP(llparamtydescs,\n                                         vec(C_int(0), C_int(i)));\n-                cx.build.Store(td, tdp);\n+                bcx.build.Store(td, tdp);\n                 i += 1;\n             }\n \n@@ -1708,7 +1724,9 @@ fn mk_derived_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n                                              llparamtydescs_opt);\n     }\n \n-    ret v;\n+    bcx.fcx.derived_tydescs.insert(t, rec(lltydesc=v, escapes=escapes));\n+\n+    ret res(cx, v);\n }\n \n fn get_tydesc(&@block_ctxt cx, &ty.t t, bool escapes) -> result {\n@@ -1863,8 +1881,6 @@ fn make_generic_glue(&@local_ctxt cx,\n                      &make_generic_glue_helper_fn helper,\n                      &vec[uint] ty_params) -> ValueRef {\n     auto fcx = new_fn_ctxt(cx, llfn);\n-    auto bcx = new_top_block_ctxt(fcx);\n-    auto lltop = bcx.llbb;\n \n     // Any nontrivial glue is with values passed *by alias*; this is a\n     // requirement since in many contexts glue is invoked indirectly and\n@@ -1882,16 +1898,22 @@ fn make_generic_glue(&@local_ctxt cx,\n \n     auto lltyparams = llvm.LLVMGetParam(llfn, 3u);\n \n+    auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n+\n     auto lltydescs = Vec.empty_mut[ValueRef]();\n     auto p = 0u;\n     while (p < ty_param_count) {\n-        auto llparam = bcx.build.GEP(lltyparams, vec(C_int(p as int)));\n-        llparam = bcx.build.Load(llparam);\n+        auto llparam = copy_args_bcx.build.GEP(lltyparams,\n+                                               vec(C_int(p as int)));\n+        llparam = copy_args_bcx.build.Load(llparam);\n         Vec.grow_set[ValueRef](lltydescs, ty_params.(p), 0 as ValueRef,\n                                 llparam);\n         p += 1u;\n     }\n-    bcx.fcx.lltydescs = Vec.freeze[ValueRef](lltydescs);\n+    fcx.lltydescs = Vec.freeze[ValueRef](lltydescs);\n+\n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n \n     auto llrawptr0 = llvm.LLVMGetParam(llfn, 4u);\n     auto llval0 = bcx.build.BitCast(llrawptr0, llty);\n@@ -1910,8 +1932,7 @@ fn make_generic_glue(&@local_ctxt cx,\n         }\n     }\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n \n     ret llfn;\n }\n@@ -3779,52 +3800,57 @@ fn trans_for_each(&@block_ctxt cx,\n                                                        s, iter_body_llty);\n \n     auto fcx = new_fn_ctxt(lcx, lliterbody);\n-    auto bcx = new_top_block_ctxt(fcx);\n-    auto lltop = bcx.llbb;\n+\n+    auto copy_args_bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n     // Populate the upvars from the environment.\n-    auto llremoteenvptr = bcx.build.PointerCast(fcx.llenv, llenvptrty);\n+    auto llremoteenvptr = copy_args_bcx.build.PointerCast(fcx.llenv,\n+                                                          llenvptrty);\n     auto llremotebindingsptrptr =\n-        bcx.build.GEP(llremoteenvptr, vec(C_int(0),\n-                                          C_int(abi.box_rc_field_body),\n-                                          C_int(abi.closure_elt_bindings)));\n-    auto llremotebindingsptr = bcx.build.Load(llremotebindingsptrptr);\n+        copy_args_bcx.build.GEP(llremoteenvptr,\n+                                vec(C_int(0),\n+                                    C_int(abi.box_rc_field_body),\n+                                    C_int(abi.closure_elt_bindings)));\n+    auto llremotebindingsptr =\n+        copy_args_bcx.build.Load(llremotebindingsptrptr);\n \n     i = 0u;\n     while (i < upvar_count) {\n         auto upvar_id = upvars.(i);\n-        auto llupvarptrptr = bcx.build.GEP(llremotebindingsptr,\n-                                           vec(C_int(0), C_int(i as int)));\n-        auto llupvarptr = bcx.build.Load(llupvarptrptr);\n+        auto llupvarptrptr =\n+            copy_args_bcx.build.GEP(llremotebindingsptr,\n+                                    vec(C_int(0), C_int(i as int)));\n+        auto llupvarptr = copy_args_bcx.build.Load(llupvarptrptr);\n         fcx.llupvars.insert(upvar_id, llupvarptr);\n \n         i += 1u;\n     }\n \n     // Populate the type parameters from the environment.\n     auto llremotetydescsptr =\n-        bcx.build.GEP(llremoteenvptr,\n-                      vec(C_int(0),\n-                          C_int(abi.box_rc_field_body),\n-                          C_int(abi.closure_elt_ty_params)));\n+        copy_args_bcx.build.GEP(llremoteenvptr,\n+                                vec(C_int(0),\n+                                    C_int(abi.box_rc_field_body),\n+                                    C_int(abi.closure_elt_ty_params)));\n \n     i = 0u;\n     while (i < tydesc_count) {\n-        auto llremotetydescptr = bcx.build.GEP(llremotetydescsptr,\n-                                               vec(C_int(0),\n-                                                   C_int(i as int)));\n-        auto llremotetydesc = bcx.build.Load(llremotetydescptr);\n+        auto llremotetydescptr =\n+            copy_args_bcx.build.GEP(llremotetydescsptr, vec(C_int(0),\n+                                                            C_int(i as int)));\n+        auto llremotetydesc = copy_args_bcx.build.Load(llremotetydescptr);\n         fcx.lltydescs += vec(llremotetydesc);\n         i += 1u;\n     }\n \n     // Add an upvar for the loop variable alias.\n     fcx.llupvars.insert(decl_id, llvm.LLVMGetParam(fcx.llfn, 3u));\n \n+    auto bcx = new_top_block_ctxt(fcx);\n+    auto lltop = bcx.llbb;\n     auto r = trans_block(bcx, body);\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n \n     r.bcx.build.RetVoid();\n \n@@ -4599,8 +4625,7 @@ fn trans_bind_thunk(&@local_ctxt cx,\n     auto r = bcx.build.FastCall(lltargetfn, llargs);\n     bcx.build.RetVoid();\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n \n     ret llthunk;\n }\n@@ -5890,6 +5915,12 @@ fn new_sub_block_ctxt(&@block_ctxt bcx, &str n) -> @block_ctxt {\n     ret new_block_ctxt(bcx.fcx, parent_some(bcx), NON_SCOPE_BLOCK, n);\n }\n \n+fn new_raw_block_ctxt(&@fn_ctxt fcx, BasicBlockRef llbb) -> @block_ctxt {\n+    let vec[cleanup] cleanups = vec();\n+    ret @rec(llbb=llbb, build=new_builder(llbb), parent=parent_none,\n+             kind=NON_SCOPE_BLOCK, mutable cleanups=cleanups, fcx=fcx);\n+}\n+\n \n fn trans_block_cleanups(&@block_ctxt cx,\n                         &@block_ctxt cleanup_cx) -> @block_ctxt {\n@@ -6056,6 +6087,15 @@ fn new_local_ctxt(&@crate_ctxt ccx) -> @local_ctxt {\n              ccx = ccx);\n }\n \n+// Creates the standard trio of basic blocks: allocas, copy-args, and derived\n+// tydescs.\n+fn mk_standard_basic_blocks(ValueRef llfn) ->\n+        tup(BasicBlockRef, BasicBlockRef, BasicBlockRef) {\n+    ret tup(llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"allocas\")),\n+            llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"copy_args\")),\n+            llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"derived_tydescs\")));\n+}\n+\n // NB: must keep 4 fns in sync:\n //\n //  - type_of_fn_full\n@@ -6075,21 +6115,26 @@ fn new_fn_ctxt(@local_ctxt cx,\n     let hashmap[ast.def_id, ValueRef] lllocals = new_def_hash[ValueRef]();\n     let hashmap[ast.def_id, ValueRef] llupvars = new_def_hash[ValueRef]();\n \n-    let BasicBlockRef llallocas =\n-        llvm.LLVMAppendBasicBlock(llfndecl, Str.buf(\"allocas\"));\n+    auto derived_tydescs =\n+        Map.mk_hashmap[ty.t, derived_tydesc_info](ty.hash_ty, ty.eq_ty);\n+\n+    auto llbbs = mk_standard_basic_blocks(llfndecl);\n \n     ret @rec(llfn=llfndecl,\n              lltaskptr=lltaskptr,\n              llenv=llenv,\n              llretptr=llretptr,\n-             mutable llallocas = llallocas,\n+             mutable llallocas=llbbs._0,\n+             mutable llcopyargs=llbbs._1,\n+             mutable llderivedtydescs=llbbs._2,\n              mutable llself=none[self_vt],\n              mutable lliterbody=none[ValueRef],\n              llargs=llargs,\n              llobjfields=llobjfields,\n              lllocals=lllocals,\n              llupvars=llupvars,\n              mutable lltydescs=Vec.empty[ValueRef](),\n+             derived_tydescs=derived_tydescs,\n              lcx=cx);\n }\n \n@@ -6165,12 +6210,13 @@ fn copy_any_self_to_alloca(@fn_ctxt fcx,\n }\n \n \n-fn copy_args_to_allocas(@block_ctxt bcx,\n+fn copy_args_to_allocas(@fn_ctxt fcx,\n                         vec[ast.arg] args,\n                         vec[ty.arg] arg_tys) {\n \n-    let uint arg_n = 0u;\n+    auto bcx = new_raw_block_ctxt(fcx, fcx.llcopyargs);\n \n+    let uint arg_n = 0u;\n     for (ast.arg aarg in args) {\n         if (aarg.mode != ast.alias) {\n             auto arg_t = type_of_arg(bcx.fcx.lcx, arg_tys.(arg_n));\n@@ -6297,6 +6343,13 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, self_vt llself) {\n     fcx.llallocas = bcx.llbb;\n }\n \n+// Ties up the llallocas -> llcopyargs -> llderivedtydescs -> lltop edges.\n+fn finish_fn(&@fn_ctxt fcx, BasicBlockRef lltop) {\n+    new_builder(fcx.llallocas).Br(fcx.llcopyargs);\n+    new_builder(fcx.llcopyargs).Br(fcx.llderivedtydescs);\n+    new_builder(fcx.llderivedtydescs).Br(lltop);\n+}\n+\n fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n             Option.t[tup(TypeRef, ty.t)] ty_self,\n             &vec[ast.ty_param] ty_params, &ast.ann ann) {\n@@ -6318,10 +6371,9 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n     }\n \n     auto arg_tys = arg_tys_of_fn(fcx.lcx.ccx, ann);\n+    copy_args_to_allocas(fcx, f.decl.inputs, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n-    copy_args_to_allocas(bcx, f.decl.inputs, arg_tys);\n-\n     add_cleanups_for_args(bcx, f.decl.inputs, arg_tys);\n \n     auto lltop = bcx.llbb;\n@@ -6333,8 +6385,7 @@ fn trans_fn(@local_ctxt cx, &ast._fn f, ast.def_id fid,\n         res.bcx.build.RetVoid();\n     }\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n }\n \n fn trans_vtbl(@local_ctxt cx,\n@@ -6432,9 +6483,9 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n                               fn_args, ty_params);\n \n     let vec[ty.arg] arg_tys = arg_tys_of_fn(ccx, ann);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n-    copy_args_to_allocas(bcx, fn_args, arg_tys);\n     auto lltop = bcx.llbb;\n \n     auto self_ty = ret_ty_of_fn(ccx, ann);\n@@ -6546,8 +6597,7 @@ fn trans_obj(@local_ctxt cx, &ast._obj ob, ast.def_id oid,\n     }\n     bcx.build.RetVoid();\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n }\n \n fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n@@ -6585,9 +6635,9 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     }\n \n     auto arg_tys = arg_tys_of_fn(cx.ccx, variant.node.ann);\n+    copy_args_to_allocas(fcx, fn_args, arg_tys);\n \n     auto bcx = new_top_block_ctxt(fcx);\n-    copy_args_to_allocas(bcx, fn_args, arg_tys);\n     auto lltop = bcx.llbb;\n \n     // Cast the tag to a type we can GEP into.\n@@ -6632,8 +6682,7 @@ fn trans_tag_variant(@local_ctxt cx, ast.def_id tag_id,\n     bcx = trans_block_cleanups(bcx, find_scope_cx(bcx));\n     bcx.build.RetVoid();\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n }\n \n // FIXME: this should do some structural hash-consing to avoid\n@@ -6973,8 +7022,7 @@ fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n \n     bcx.build.RetVoid();\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n }\n \n type walk_ctxt = rec(mutable vec[str] path);\n@@ -7469,22 +7517,26 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     let ValueRef lldst_vec_ptr = llvm.LLVMGetParam(llfn, 3u);\n     let ValueRef llsrc_vec = llvm.LLVMGetParam(llfn, 4u);\n     let ValueRef llskipnull = llvm.LLVMGetParam(llfn, 5u);\n+    auto derived_tydescs =\n+        Map.mk_hashmap[ty.t, derived_tydesc_info](ty.hash_ty, ty.eq_ty);\n \n-    let BasicBlockRef llallocas =\n-        llvm.LLVMAppendBasicBlock(llfn, Str.buf(\"allocas\"));\n+    auto llbbs = mk_standard_basic_blocks(llfn);\n \n     auto fcx = @rec(llfn=llfn,\n                     lltaskptr=lltaskptr,\n                     llenv=C_null(T_ptr(T_nil())),\n                     llretptr=C_null(T_ptr(T_nil())),\n-                    mutable llallocas = llallocas,\n+                    mutable llallocas = llbbs._0,\n+                    mutable llcopyargs = llbbs._1,\n+                    mutable llderivedtydescs = llbbs._2,\n                     mutable llself=none[self_vt],\n                     mutable lliterbody=none[ValueRef],\n                     llargs=new_def_hash[ValueRef](),\n                     llobjfields=new_def_hash[ValueRef](),\n                     lllocals=new_def_hash[ValueRef](),\n                     llupvars=new_def_hash[ValueRef](),\n                     mutable lltydescs=Vec.empty[ValueRef](),\n+                    derived_tydescs=derived_tydescs,\n                     lcx=cx);\n \n     auto bcx = new_top_block_ctxt(fcx);\n@@ -7590,8 +7642,7 @@ fn trans_vec_append_glue(@local_ctxt cx) {\n     copy_src_cx.build.Store(llnew_vec, lldst_vec_ptr);\n     copy_src_cx.build.RetVoid();\n \n-    // Tie up the llallocas -> lltop edge.\n-    new_builder(fcx.llallocas).Br(lltop);\n+    finish_fn(fcx, lltop);\n }\n \n "}]}