{"sha": "62850d882b1f546783d064ca3b51d1f85b92eeb7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyODUwZDg4MmIxZjU0Njc4M2QwNjRjYTNiNTFkMWY4NWI5MmVlYjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-30T00:47:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-30T00:47:37Z"}, "message": "Auto merge of #76090 - Dylan-DPC:rollup-eksndcr, r=Dylan-DPC\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #75832 (Move to intra-doc links for wasi/ext/fs.rs, os_str_bytes.rs\u2026)\n - #75852 (Switch to intra-doc links in `core::hash`)\n - #75874 (Shorten liballoc doc intra link while readable)\n - #75881 (Expand rustdoc theme chooser x padding)\n - #75885 (Fix another clashing_extern_declarations false positive.)\n - #75892 (Fix typo in TLS Model in Unstable Book)\n - #75910 (Add test for issue #27130)\n - #75917 (Move to intra doc links for core::ptr::non_null)\n - #75975 (Allow --bess ing expect-tests in tools)\n - #75990 (Add __fastfail for Windows on arm/aarch64)\n - #76015 (Fix loading pretty-printers in rust-lldb script)\n - #76022 (Clean up rustdoc front-end source code)\n - #76029 (Move to intra-doc links for library/core/src/sync/atomic.rs)\n - #76057 (Move retokenize hack to save_analysis)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "f03f9e31723ac3561c7fa3ecbda1c4e41ccdbf41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f03f9e31723ac3561c7fa3ecbda1c4e41ccdbf41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62850d882b1f546783d064ca3b51d1f85b92eeb7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62850d882b1f546783d064ca3b51d1f85b92eeb7", "html_url": "https://github.com/rust-lang/rust/commit/62850d882b1f546783d064ca3b51d1f85b92eeb7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62850d882b1f546783d064ca3b51d1f85b92eeb7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ced37a53d9a4d46c5d3137e1e8666897474bd7d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/ced37a53d9a4d46c5d3137e1e8666897474bd7d6", "html_url": "https://github.com/rust-lang/rust/commit/ced37a53d9a4d46c5d3137e1e8666897474bd7d6"}, {"sha": "9d7d24d5160469741de87df98664b27b09393488", "url": "https://api.github.com/repos/rust-lang/rust/commits/9d7d24d5160469741de87df98664b27b09393488", "html_url": "https://github.com/rust-lang/rust/commit/9d7d24d5160469741de87df98664b27b09393488"}], "stats": {"total": 938, "additions": 349, "deletions": 589}, "files": [{"sha": "ffc1f0dec1d9a2f412ff2445286330abd9e39ed5", "filename": "Cargo.lock", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -3927,8 +3927,8 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_hir\",\n  \"rustc_hir_pretty\",\n+ \"rustc_lexer\",\n  \"rustc_middle\",\n- \"rustc_parse\",\n  \"rustc_session\",\n  \"rustc_span\",\n  \"serde_json\","}, {"sha": "61e1245f0735c32dbbda6b2845492798c98ceaeb", "filename": "library/alloc/src/vec.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Falloc%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Falloc%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -9,7 +9,7 @@\n //!\n //! # Examples\n //!\n-//! You can explicitly create a [`Vec<T>`] with [`new`]:\n+//! You can explicitly create a [`Vec`] with [`Vec::new`]:\n //!\n //! ```\n //! let v: Vec<i32> = Vec::new();\n@@ -50,8 +50,6 @@\n //! v[1] = v[1] + 5;\n //! ```\n //!\n-//! [`Vec<T>`]: Vec\n-//! [`new`]: Vec::new\n //! [`push`]: Vec::push\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "f53ba98143842d5f50ca9f40918a8f9f8e6ecb8a", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -39,8 +39,6 @@\n //! If you need more control over how a value is hashed, you need to implement\n //! the [`Hash`] trait:\n //!\n-//! [`Hash`]: trait.Hash.html\n-//!\n //! ```rust\n //! use std::collections::hash_map::DefaultHasher;\n //! use std::hash::{Hash, Hasher};\n@@ -149,11 +147,9 @@ mod sip;\n /// Thankfully, you won't need to worry about upholding this property when\n /// deriving both [`Eq`] and `Hash` with `#[derive(PartialEq, Eq, Hash)]`.\n ///\n-/// [`Eq`]: ../../std/cmp/trait.Eq.html\n-/// [`Hasher`]: trait.Hasher.html\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n /// [`HashSet`]: ../../std/collections/struct.HashSet.html\n-/// [`hash`]: #tymethod.hash\n+/// [`hash`]: Hash::hash\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hash {\n     /// Feeds this value into the given [`Hasher`].\n@@ -168,8 +164,6 @@ pub trait Hash {\n     /// 7920.hash(&mut hasher);\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n-    ///\n-    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn hash<H: Hasher>(&self, state: &mut H);\n \n@@ -186,8 +180,6 @@ pub trait Hash {\n     /// Hash::hash_slice(&numbers, &mut hasher);\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n-    ///\n-    /// [`Hasher`]: trait.Hasher.html\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n     fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n     where\n@@ -239,10 +231,9 @@ pub use macros::Hash;\n /// println!(\"Hash is {:x}!\", hasher.finish());\n /// ```\n ///\n-/// [`Hash`]: trait.Hash.html\n-/// [`finish`]: #tymethod.finish\n-/// [`write`]: #tymethod.write\n-/// [`write_u8`]: #method.write_u8\n+/// [`finish`]: Hasher::finish\n+/// [`write`]: Hasher::write\n+/// [`write_u8`]: Hasher::write_u8\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Hasher {\n     /// Returns the hash value for the values written so far.\n@@ -264,7 +255,7 @@ pub trait Hasher {\n     /// println!(\"Hash is {:x}!\", hasher.finish());\n     /// ```\n     ///\n-    /// [`write`]: #tymethod.write\n+    /// [`write`]: Hasher::write\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn finish(&self) -> u64;\n \n@@ -433,8 +424,7 @@ impl<H: Hasher + ?Sized> Hasher for &mut H {\n /// assert_eq!(hasher_1.finish(), hasher_2.finish());\n /// ```\n ///\n-/// [`build_hasher`]: #tymethod.build_hasher\n-/// [`Hasher`]: trait.Hasher.html\n+/// [`build_hasher`]: BuildHasher::build_hasher\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n pub trait BuildHasher {\n@@ -456,8 +446,6 @@ pub trait BuildHasher {\n     /// let s = RandomState::new();\n     /// let new_s = s.build_hasher();\n     /// ```\n-    ///\n-    /// [`Hasher`]: trait.Hasher.html\n     #[stable(since = \"1.7.0\", feature = \"build_hasher\")]\n     fn build_hasher(&self) -> Self::Hasher;\n }\n@@ -470,7 +458,7 @@ pub trait BuildHasher {\n /// defined.\n ///\n /// Any `BuildHasherDefault` is [zero-sized]. It can be created with\n-/// [`default`][method.Default]. When using `BuildHasherDefault` with [`HashMap`] or\n+/// [`default`][method.default]. When using `BuildHasherDefault` with [`HashMap`] or\n /// [`HashSet`], this doesn't need to be done, since they implement appropriate\n /// [`Default`] instances themselves.\n ///\n@@ -503,10 +491,7 @@ pub trait BuildHasher {\n /// let hash_map = HashMap::<u32, u32, MyBuildHasher>::default();\n /// ```\n ///\n-/// [`BuildHasher`]: trait.BuildHasher.html\n-/// [`Default`]: ../default/trait.Default.html\n-/// [method.default]: #method.default\n-/// [`Hasher`]: trait.Hasher.html\n+/// [method.default]: BuildHasherDefault::default\n /// [`HashMap`]: ../../std/collections/struct.HashMap.html\n /// [`HashSet`]: ../../std/collections/struct.HashSet.html\n /// [zero-sized]: https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts"}, {"sha": "87a59c873b1976340924cbcd86ed7e89a085d1ba", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 16, "deletions": 20, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -34,8 +34,8 @@ use crate::slice::{self, SliceIndex};\n /// it is your responsibility to ensure that `as_mut` is never called, and `as_ptr`\n /// is never used for mutation.\n ///\n-/// [`PhantomData`]: ../marker/struct.PhantomData.html\n-/// [`UnsafeCell<T>`]: ../cell/struct.UnsafeCell.html\n+/// [`PhantomData`]: crate::marker::PhantomData\n+/// [`UnsafeCell<T>`]: crate::cell::UnsafeCell\n #[stable(feature = \"nonnull\", since = \"1.25.0\")]\n #[repr(transparent)]\n #[rustc_layout_scalar_valid_range_start(1)]\n@@ -82,8 +82,8 @@ impl<T: Sized> NonNull<T> {\n     ///\n     /// For the mutable counterpart see [`as_uninit_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref\n-    /// [`as_uninit_mut`]: #method.as_uninit_mut\n+    /// [`as_ref`]: NonNull::as_ref\n+    /// [`as_uninit_mut`]: NonNull::as_uninit_mut\n     ///\n     /// # Safety\n     ///\n@@ -114,8 +114,8 @@ impl<T: Sized> NonNull<T> {\n     ///\n     /// For the shared counterpart see [`as_uninit_ref`].\n     ///\n-    /// [`as_mut`]: #method.as_mut\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref\n+    /// [`as_mut`]: NonNull::as_mut\n+    /// [`as_uninit_ref`]: NonNull::as_uninit_ref\n     ///\n     /// # Safety\n     ///\n@@ -181,8 +181,8 @@ impl<T: ?Sized> NonNull<T> {\n     ///\n     /// For the mutable counterpart see [`as_mut`].\n     ///\n-    /// [`as_uninit_ref`]: #method.as_uninit_ref\n-    /// [`as_mut`]: #method.as_mut\n+    /// [`as_uninit_ref`]: NonNull::as_uninit_ref\n+    /// [`as_mut`]: NonNull::as_mut\n     ///\n     /// # Safety\n     ///\n@@ -217,8 +217,8 @@ impl<T: ?Sized> NonNull<T> {\n     ///\n     /// For the shared counterpart see [`as_ref`].\n     ///\n-    /// [`as_uninit_mut`]: #method.as_uninit_mut\n-    /// [`as_ref`]: #method.as_ref\n+    /// [`as_uninit_mut`]: NonNull::as_uninit_mut\n+    /// [`as_ref`]: NonNull::as_ref\n     ///\n     /// # Safety\n     ///\n@@ -266,8 +266,6 @@ impl<T> NonNull<[T]> {\n     /// This function is safe, but dereferencing the return value is unsafe.\n     /// See the documentation of [`slice::from_raw_parts`] for slice safety requirements.\n     ///\n-    /// [`slice::from_raw_parts`]: ../../std/slice/fn.from_raw_parts.html\n-    ///\n     /// # Examples\n     ///\n     /// ```rust\n@@ -357,8 +355,8 @@ impl<T> NonNull<[T]> {\n     ///\n     /// For the mutable counterpart see [`as_uninit_slice_mut`].\n     ///\n-    /// [`as_ref`]: #method.as_ref\n-    /// [`as_uninit_slice_mut`]: #method.as_uninit_slice_mut\n+    /// [`as_ref`]: NonNull::as_ref\n+    /// [`as_uninit_slice_mut`]: NonNull::as_uninit_slice_mut\n     ///\n     /// # Safety\n     ///\n@@ -386,10 +384,9 @@ impl<T> NonNull<[T]> {\n     ///\n     /// This applies even if the result of this method is unused!\n     ///\n-    /// See also [`slice::from_raw_parts`][].\n+    /// See also [`slice::from_raw_parts`].\n     ///\n     /// [valid]: crate::ptr#safety\n-    /// [`NonNull::dangling()`]: NonNull::dangling\n     /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n     #[inline]\n     #[unstable(feature = \"ptr_as_uninit\", issue = \"75402\")]\n@@ -403,8 +400,8 @@ impl<T> NonNull<[T]> {\n     ///\n     /// For the shared counterpart see [`as_uninit_slice`].\n     ///\n-    /// [`as_mut`]: #method.as_mut\n-    /// [`as_uninit_slice`]: #method.as_uninit_slice\n+    /// [`as_mut`]: NonNull::as_mut\n+    /// [`as_uninit_slice`]: NonNull::as_uninit_slice\n     ///\n     /// # Safety\n     ///\n@@ -432,10 +429,9 @@ impl<T> NonNull<[T]> {\n     ///\n     /// This applies even if the result of this method is unused!\n     ///\n-    /// See also [`slice::from_raw_parts_mut`][].\n+    /// See also [`slice::from_raw_parts_mut`].\n     ///\n     /// [valid]: crate::ptr#safety\n-    /// [`NonNull::dangling()`]: NonNull::dangling\n     /// [`pointer::offset`]: ../../std/primitive.pointer.html#method.offset\n     ///\n     /// # Examples"}, {"sha": "1aec7e1b5f871d935c1494de6924ae1ed458e148", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 7, "deletions": 239, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -10,18 +10,10 @@\n //! Atomic types present operations that, when used correctly, synchronize\n //! updates between threads.\n //!\n-//! [`AtomicBool`]: struct.AtomicBool.html\n-//! [`AtomicIsize`]: struct.AtomicIsize.html\n-//! [`AtomicUsize`]: struct.AtomicUsize.html\n-//! [`AtomicI8`]: struct.AtomicI8.html\n-//! [`AtomicU16`]: struct.AtomicU16.html\n-//!\n //! Each method takes an [`Ordering`] which represents the strength of\n //! the memory barrier for that operation. These orderings are the\n //! same as the [C++20 atomic orderings][1]. For more information see the [nomicon][2].\n //!\n-//! [`Ordering`]: enum.Ordering.html\n-//!\n //! [1]: https://en.cppreference.com/w/cpp/atomic/memory_order\n //! [2]: ../../../nomicon/atomics.html\n //!\n@@ -31,15 +23,12 @@\n //! The most common way to share an atomic variable is to put it into an [`Arc`][arc] (an\n //! atomically-reference-counted shared pointer).\n //!\n-//! [`Sync`]: ../../marker/trait.Sync.html\n //! [arc]: ../../../std/sync/struct.Arc.html\n //!\n //! Atomic types may be stored in static variables, initialized using\n //! the constant initializers like [`AtomicBool::new`]. Atomic statics\n //! are often used for lazy global initialization.\n //!\n-//! [`AtomicBool::new`]: struct.AtomicBool.html#method.new\n-//!\n //! # Portability\n //!\n //! All atomic types in this module are guaranteed to be [lock-free] if they're\n@@ -155,8 +144,6 @@ pub fn spin_loop_hint() {\n ///\n /// **Note**: This type is only available on platforms that support atomic\n /// loads and stores of `u8`.\n-///\n-/// [`bool`]: ../../../std/primitive.bool.html\n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[repr(C, align(1))]\n@@ -212,8 +199,8 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// Atomic memory orderings\n ///\n /// Memory orderings specify the way atomic operations synchronize memory.\n-/// In its weakest [`Relaxed`][Ordering::Relaxed], only the memory directly touched by the\n-/// operation is synchronized. On the other hand, a store-load pair of [`SeqCst`][Ordering::SeqCst]\n+/// In its weakest [`Ordering::Relaxed`], only the memory directly touched by the\n+/// operation is synchronized. On the other hand, a store-load pair of [`Ordering::SeqCst`]\n /// operations synchronize other memory while additionally preserving a total order of such\n /// operations across all threads.\n ///\n@@ -223,8 +210,6 @@ unsafe impl<T> Sync for AtomicPtr<T> {}\n /// For more information see the [nomicon].\n ///\n /// [nomicon]: ../../../nomicon/atomics.html\n-/// [Ordering::Relaxed]: #variant.Relaxed\n-/// [Ordering::SeqCst]: #variant.SeqCst\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Copy, Clone, Debug, Eq, PartialEq, Hash)]\n #[non_exhaustive]\n@@ -248,9 +233,6 @@ pub enum Ordering {\n     ///\n     /// Corresponds to [`memory_order_release`] in C++20.\n     ///\n-    /// [`Release`]: #variant.Release\n-    /// [`Acquire`]: #variant.Acquire\n-    /// [`Relaxed`]: #variant.Relaxed\n     /// [`memory_order_release`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Release,\n@@ -266,9 +248,6 @@ pub enum Ordering {\n     ///\n     /// Corresponds to [`memory_order_acquire`] in C++20.\n     ///\n-    /// [`Acquire`]: #variant.Acquire\n-    /// [`Release`]: #variant.Release\n-    /// [`Relaxed`]: #variant.Relaxed\n     /// [`memory_order_acquire`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     Acquire,\n@@ -284,9 +263,6 @@ pub enum Ordering {\n     /// Corresponds to [`memory_order_acq_rel`] in C++20.\n     ///\n     /// [`memory_order_acq_rel`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Release-Acquire_ordering\n-    /// [`Acquire`]: #variant.Acquire\n-    /// [`Release`]: #variant.Release\n-    /// [`Relaxed`]: #variant.Relaxed\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     AcqRel,\n     /// Like [`Acquire`]/[`Release`]/[`AcqRel`] (for load, store, and load-with-store\n@@ -296,16 +272,11 @@ pub enum Ordering {\n     /// Corresponds to [`memory_order_seq_cst`] in C++20.\n     ///\n     /// [`memory_order_seq_cst`]: https://en.cppreference.com/w/cpp/atomic/memory_order#Sequentially-consistent_ordering\n-    /// [`Acquire`]: #variant.Acquire\n-    /// [`Release`]: #variant.Release\n-    /// [`AcqRel`]: #variant.AcqRel\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     SeqCst,\n }\n \n /// An [`AtomicBool`] initialized to `false`.\n-///\n-/// [`AtomicBool`]: struct.AtomicBool.html\n #[cfg(target_has_atomic_load_store = \"8\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[rustc_deprecated(\n@@ -339,8 +310,6 @@ impl AtomicBool {\n     /// This is safe because the mutable reference guarantees that no other threads are\n     /// concurrently accessing the atomic data.\n     ///\n-    /// [`bool`]: ../../../std/primitive.bool.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -386,13 +355,6 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -419,13 +381,6 @@ impl AtomicBool {\n     ///\n     /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -456,11 +411,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -493,13 +443,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    /// [`bool`]: ../../../std/primitive.bool.html\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -539,13 +482,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`bool`]: ../../../std/primitive.bool.html\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -587,7 +523,7 @@ impl AtomicBool {\n \n     /// Stores a value into the [`bool`] if the current value is the same as the `current` value.\n     ///\n-    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n+    /// Unlike [`AtomicBool::compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n@@ -603,14 +539,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`bool`]: ../../../std/primitive.bool.html\n-    /// [`compare_exchange`]: #method.compare_exchange\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -658,11 +586,6 @@ impl AtomicBool {\n     /// [`Acquire`] makes the store part of this operation [`Relaxed`], and\n     /// using [`Release`] makes the load part [`Relaxed`].\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n@@ -706,11 +629,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -763,11 +681,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -808,11 +721,6 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -850,8 +758,6 @@ impl AtomicBool {\n     /// use of the returned raw pointer requires an `unsafe` block and still has to uphold the same\n     /// restriction: operations on it must be atomic.\n     ///\n-    /// [`bool`]: ../../../std/primitive.bool.html\n-    ///\n     /// # Examples\n     ///\n     /// ```ignore (extern-declaration)\n@@ -942,13 +848,6 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is [`Release`] or [`AcqRel`].\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -975,13 +874,6 @@ impl<T> AtomicPtr<T> {\n     ///\n     /// Panics if `order` is [`Acquire`] or [`AcqRel`].\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1013,11 +905,6 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1052,12 +939,6 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1096,12 +977,6 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1143,7 +1018,7 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n+    /// Unlike [`AtomicPtr::compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n@@ -1159,13 +1034,6 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n-    /// [`compare_exchange`]: #method.compare_exchange\n-    /// [`Ordering`]: enum.Ordering.html\n-    /// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-    /// [`Release`]: enum.Ordering.html#variant.Release\n-    /// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-    /// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-    ///\n     /// # Examples\n     ///\n     /// ```\n@@ -1271,7 +1139,7 @@ macro_rules! atomic_int {\n         #[doc = $int_ref]\n         /// ).\n         ///\n-        /// [module-level documentation]: index.html\n+        /// [module-level documentation]: crate::sync::atomic\n         #[$stable]\n         #[repr(C, align($align))]\n         pub struct $atomic_type {\n@@ -1389,13 +1257,6 @@ Possible values are [`SeqCst`], [`Acquire`] and [`Relaxed`].\n \n Panics if `order` is [`Release`] or [`AcqRel`].\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-\n # Examples\n \n ```\n@@ -1423,13 +1284,6 @@ assert_eq!(some_var.load(Ordering::Relaxed), 5);\n \n Panics if `order` is [`Acquire`] or [`AcqRel`].\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-\n # Examples\n \n ```\n@@ -1459,11 +1313,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1498,12 +1347,6 @@ happens, and using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-\n # Examples\n \n ```\n@@ -1553,12 +1396,6 @@ and must be equivalent to or weaker than the success ordering.\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-\n # Examples\n \n ```\n@@ -1595,7 +1432,7 @@ assert_eq!(some_var.load(Ordering::Relaxed), 10);\n                 concat!(\"Stores a value into the atomic integer if the current value is the same as\n the `current` value.\n \n-Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+Unlike [`\", stringify!($atomic_type), \"::compare_exchange`], this function is allowed to spuriously fail even\n when the comparison succeeds, which can result in more efficient code on some\n platforms. The return value is a result indicating whether the new value was\n written and containing the previous value.\n@@ -1608,13 +1445,6 @@ of this operation [`Relaxed`], and using [`Release`] makes the successful load\n [`Relaxed`]. The failure ordering can only be [`SeqCst`], [`Acquire`] or [`Relaxed`]\n and must be equivalent to or weaker than the success ordering.\n \n-[`compare_exchange`]: #method.compare_exchange\n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n@@ -1662,11 +1492,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1698,11 +1523,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1737,11 +1557,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1776,11 +1591,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1816,11 +1626,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1855,11 +1660,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -1890,7 +1690,7 @@ only once to the stored value.\n `fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n The first describes the required ordering for when the operation finally succeeds while the second\n describes the required ordering for loads. These correspond to the success and failure orderings of\n-[`compare_exchange`] respectively.\n+[`\", stringify!($atomic_type), \"::compare_exchange`] respectively.\n \n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n@@ -1900,14 +1700,6 @@ and must be equivalent to or weaker than the success ordering.\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`bool`]: ../../../std/primitive.bool.html\n-[`compare_exchange`]: #method.compare_exchange\n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-[`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-\n # Examples\n \n ```rust\n@@ -1954,11 +1746,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -2004,11 +1791,6 @@ using [`Release`] makes the load part [`Relaxed`].\n **Note**: This method is only available on platforms that support atomic\n operations on [`\", $s_int_type, \"`](\", $int_ref, \").\n \n-[`Ordering`]: enum.Ordering.html\n-[`Relaxed`]: enum.Ordering.html#variant.Relaxed\n-[`Release`]: enum.Ordering.html#variant.Release\n-[`Acquire`]: enum.Ordering.html#variant.Acquire\n-\n # Examples\n \n ```\n@@ -2660,13 +2442,6 @@ unsafe fn atomic_umin<T: Copy>(dst: *mut T, val: T, order: Ordering) -> T {\n ///     }\n /// }\n /// ```\n-///\n-/// [`Ordering`]: enum.Ordering.html\n-/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-/// [`Release`]: enum.Ordering.html#variant.Release\n-/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {\n@@ -2747,13 +2522,6 @@ pub fn fence(order: Ordering) {\n /// }\n /// ```\n ///\n-/// [`fence`]: fn.fence.html\n-/// [`Ordering`]: enum.Ordering.html\n-/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n-/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n-/// [`Release`]: enum.Ordering.html#variant.Release\n-/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n-/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n /// [memory barriers]: https://www.kernel.org/doc/Documentation/memory-barriers.txt\n #[inline]\n #[stable(feature = \"compiler_fences\", since = \"1.21.0\")]"}, {"sha": "3b08a64b22d85f89a562cd23a893a815a2019bf8", "filename": "library/panic_abort/src/lib.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fpanic_abort%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fpanic_abort%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fpanic_abort%2Fsrc%2Flib.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -17,7 +17,7 @@\n #![feature(panic_runtime)]\n #![feature(staged_api)]\n #![feature(rustc_attrs)]\n-#![feature(llvm_asm)]\n+#![feature(asm)]\n \n use core::any::Any;\n \n@@ -47,7 +47,7 @@ pub unsafe extern \"C\" fn __rust_start_panic(_payload: usize) -> u32 {\n                 }\n                 __rust_abort();\n             }\n-        } else if #[cfg(all(windows, any(target_arch = \"x86\", target_arch = \"x86_64\")))] {\n+        } else if #[cfg(windows)] {\n             // On Windows, use the processor-specific __fastfail mechanism. In Windows 8\n             // and later, this will terminate the process immediately without running any\n             // in-process exception handlers. In earlier versions of Windows, this\n@@ -59,7 +59,18 @@ pub unsafe extern \"C\" fn __rust_start_panic(_payload: usize) -> u32 {\n             //\n             // Note: this is the same implementation as in libstd's `abort_internal`\n             unsafe fn abort() -> ! {\n-                llvm_asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n+                const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n+                cfg_if::cfg_if! {\n+                    if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+                        asm!(\"int $$0x29\", in(\"ecx\") FAST_FAIL_FATAL_APP_EXIT);\n+                    } else if #[cfg(all(target_arch = \"arm\", target_feature = \"thumb-mode\"))] {\n+                        asm!(\".inst 0xDEFB\", in(\"r0\") FAST_FAIL_FATAL_APP_EXIT);\n+                    } else if #[cfg(target_arch = \"aarch64\")] {\n+                        asm!(\"brk 0xF003\", in(\"x0\") FAST_FAIL_FATAL_APP_EXIT);\n+                    } else {\n+                        core::intrinsics::abort();\n+                    }\n+                }\n                 core::intrinsics::unreachable();\n             }\n         } else {"}, {"sha": "2339ca527bd832f2734496aaf72d3067c2539ad5", "filename": "library/std/src/primitive_docs.rs", "status": "modified", "additions": 67, "deletions": 117, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprimitive_docs.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -20,10 +20,9 @@\n /// assert!(!bool_val);\n /// ```\n ///\n-/// [`assert!`]: macro.assert.html\n-/// [`BitAnd`]: ops/trait.BitAnd.html\n-/// [`BitOr`]: ops/trait.BitOr.html\n-/// [`Not`]: ops/trait.Not.html\n+/// [`BitAnd`]: ops::BitAnd\n+/// [`BitOr`]: ops::BitOr\n+/// [`Not`]: ops::Not\n ///\n /// # Examples\n ///\n@@ -46,7 +45,7 @@\n /// }\n /// ```\n ///\n-/// Also, since `bool` implements the [`Copy`](marker/trait.Copy.html) trait, we don't\n+/// Also, since `bool` implements the [`Copy`] trait, we don't\n /// have to worry about the move semantics (just like the integer and float primitives).\n ///\n /// Now an example of `bool` cast to integer type:\n@@ -100,8 +99,8 @@ mod prim_bool {}\n /// at all we know it can never produce a value which isn't a [`u32`]. This illustrates another\n /// behaviour of the `!` type - expressions with type `!` will coerce into any other type.\n ///\n-/// [`u32`]: primitive.str.html\n-/// [`exit`]: process/fn.exit.html\n+/// [`u32`]: prim@u32\n+/// [`exit`]: process::exit\n ///\n /// # `!` and generics\n ///\n@@ -185,14 +184,12 @@ mod prim_bool {}\n /// ever stops, it means that an error occurred. We don't even have to wrap the loop in an `Ok`\n /// because `!` coerces to `Result<!, ConnectionError>` automatically.\n ///\n-/// [`String::from_str`]: str/trait.FromStr.html#tymethod.from_str\n-/// [`Result<String, !>`]: result/enum.Result.html\n-/// [`Result<T, !>`]: result/enum.Result.html\n-/// [`Result<!, E>`]: result/enum.Result.html\n-/// [`Ok`]: result/enum.Result.html#variant.Ok\n-/// [`String`]: string/struct.String.html\n-/// [`Err`]: result/enum.Result.html#variant.Err\n-/// [`FromStr`]: str/trait.FromStr.html\n+/// [`String::from_str`]: str::FromStr::from_str\n+/// [`Result<String, !>`]: Result\n+/// [`Result<T, !>`]: Result\n+/// [`Result<!, E>`]: Result\n+/// [`String`]: string::String\n+/// [`FromStr`]: str::FromStr\n ///\n /// # `!` and traits\n ///\n@@ -233,11 +230,9 @@ mod prim_bool {}\n /// `impl` for this which simply panics, but the same is true for any type (we could `impl\n /// Default` for (eg.) [`File`] by just making [`default()`] panic.)\n ///\n-/// [`fmt::Result`]: fmt/type.Result.html\n-/// [`File`]: fs/struct.File.html\n-/// [`Debug`]: fmt/trait.Debug.html\n-/// [`Default`]: default/trait.Default.html\n-/// [`default()`]: default/trait.Default.html#tymethod.default\n+/// [`File`]: fs::File\n+/// [`Debug`]: fmt::Debug\n+/// [`default()`]: Default::default\n ///\n #[unstable(feature = \"never_type\", issue = \"35121\")]\n mod prim_never {}\n@@ -360,7 +355,7 @@ mod prim_unit {}\n //\n /// Raw, unsafe pointers, `*const T`, and `*mut T`.\n ///\n-/// *[See also the `std::ptr` module](ptr/index.html).*\n+/// *[See also the `std::ptr` module][`ptr`].*\n ///\n /// Working with raw pointers in Rust is uncommon, typically limited to a few patterns.\n /// Raw pointers can be unaligned or [`null`]. However, when a raw pointer is\n@@ -439,13 +434,13 @@ mod prim_unit {}\n /// but C APIs hand out a lot of pointers generally, so are a common source\n /// of raw pointers in Rust.\n ///\n-/// [`null`]: ../std/ptr/fn.null.html\n-/// [`null_mut`]: ../std/ptr/fn.null_mut.html\n+/// [`null`]: ptr::null\n+/// [`null_mut`]: ptr::null_mut\n /// [`is_null`]: ../std/primitive.pointer.html#method.is_null\n /// [`offset`]: ../std/primitive.pointer.html#method.offset\n-/// [`into_raw`]: ../std/boxed/struct.Box.html#method.into_raw\n-/// [`drop`]: ../std/mem/fn.drop.html\n-/// [`write`]: ../std/ptr/fn.write.html\n+/// [`into_raw`]: Box::into_raw\n+/// [`drop`]: mem::drop\n+/// [`write`]: ptr::write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_pointer {}\n \n@@ -458,32 +453,32 @@ mod prim_pointer {}\n ///\n /// * A list with each element, i.e., `[x, y, z]`.\n /// * A repeat expression `[x; N]`, which produces an array with `N` copies of `x`.\n-///   The type of `x` must be [`Copy`][copy].\n+///   The type of `x` must be [`Copy`].\n ///\n /// Arrays of *any* size implement the following traits if the element type allows it:\n ///\n-/// - [`Debug`][debug]\n-/// - [`IntoIterator`][intoiterator] (implemented for `&[T; N]` and `&mut [T; N]`)\n-/// - [`PartialEq`][partialeq], [`PartialOrd`][partialord], [`Eq`][eq], [`Ord`][ord]\n-/// - [`Hash`][hash]\n-/// - [`AsRef`][asref], [`AsMut`][asmut]\n-/// - [`Borrow`][borrow], [`BorrowMut`][borrowmut]\n+/// - [`Debug`]\n+/// - [`IntoIterator`] (implemented for `&[T; N]` and `&mut [T; N]`)\n+/// - [`PartialEq`], [`PartialOrd`], [`Eq`], [`Ord`]\n+/// - [`Hash`]\n+/// - [`AsRef`], [`AsMut`]\n+/// - [`Borrow`], [`BorrowMut`]\n ///\n-/// Arrays of sizes from 0 to 32 (inclusive) implement [`Default`][default] trait\n+/// Arrays of sizes from 0 to 32 (inclusive) implement [`Default`] trait\n /// if the element type allows it. As a stopgap, trait implementations are\n /// statically generated up to size 32.\n ///\n-/// Arrays of *any* size are [`Copy`][copy] if the element type is [`Copy`][copy]\n-/// and [`Clone`][clone] if the element type is [`Clone`][clone]. This works\n-/// because [`Copy`][copy] and [`Clone`][clone] traits are specially known\n+/// Arrays of *any* size are [`Copy`] if the element type is [`Copy`]\n+/// and [`Clone`] if the element type is [`Clone`]. This works\n+/// because [`Copy`] and [`Clone`] traits are specially known\n /// to the compiler.\n ///\n /// Arrays coerce to [slices (`[T]`)][slice], so a slice method may be called on\n /// an array. Indeed, this provides most of the API for working with arrays.\n /// Slices have a dynamic size and do not coerce to arrays.\n ///\n /// You can move elements out of an array with a slice pattern. If you want\n-/// one element, see [`mem::replace`][replace].\n+/// one element, see [`mem::replace`].\n ///\n /// # Examples\n ///\n@@ -535,22 +530,10 @@ mod prim_pointer {}\n /// ```\n ///\n /// [slice]: primitive.slice.html\n-/// [copy]: marker/trait.Copy.html\n-/// [clone]: clone/trait.Clone.html\n-/// [debug]: fmt/trait.Debug.html\n-/// [intoiterator]: iter/trait.IntoIterator.html\n-/// [partialeq]: cmp/trait.PartialEq.html\n-/// [partialord]: cmp/trait.PartialOrd.html\n-/// [eq]: cmp/trait.Eq.html\n-/// [ord]: cmp/trait.Ord.html\n-/// [hash]: hash/trait.Hash.html\n-/// [asref]: convert/trait.AsRef.html\n-/// [asmut]: convert/trait.AsMut.html\n-/// [borrow]: borrow/trait.Borrow.html\n-/// [borrowmut]: borrow/trait.BorrowMut.html\n-/// [default]: default/trait.Default.html\n-/// [replace]: mem/fn.replace.html\n-/// [`IntoIterator`]: iter/trait.IntoIterator.html\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n+/// [`Borrow`]: borrow::Borrow\n+/// [`BorrowMut`]: borrow::BorrowMut\n ///\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_array {}\n@@ -563,7 +546,7 @@ mod prim_array {}\n /// means that elements are laid out so that every element is the same\n /// distance from its neighbors.\n ///\n-/// *[See also the `std::slice` module](slice/index.html).*\n+/// *[See also the `std::slice` module][`crate::slice`].*\n ///\n /// Slices are a view into a block of memory represented as a pointer and a\n /// length.\n@@ -608,7 +591,7 @@ mod prim_slice {}\n //\n /// String slices.\n ///\n-/// *[See also the `std::str` module](str/index.html).*\n+/// *[See also the `std::str` module][`crate::str`].*\n ///\n /// The `str` type, also called a 'string slice', is the most primitive string\n /// type. It is usually seen in its borrowed form, `&str`. It is also the type\n@@ -660,8 +643,8 @@ mod prim_slice {}\n /// assert_eq!(s, Ok(story));\n /// ```\n ///\n-/// [`as_ptr`]: #method.as_ptr\n-/// [`len`]: #method.len\n+/// [`as_ptr`]: str::as_ptr\n+/// [`len`]: str::len\n ///\n /// Note: This example shows the internals of `&str`. `unsafe` should not be\n /// used to get a string slice under normal circumstances. Use `as_str`\n@@ -729,15 +712,8 @@ mod prim_str {}\n /// * [`Default`]\n /// * [`Hash`]\n ///\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`Copy`]: marker/trait.Copy.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`Debug`]: fmt/trait.Debug.html\n-/// [`Default`]: default/trait.Default.html\n-/// [`Hash`]: hash/trait.Hash.html\n+/// [`Debug`]: fmt::Debug\n+/// [`Hash`]: hash::Hash\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only\n /// implemented on tuples of arity 12 or less. In the future, this may change.\n@@ -810,7 +786,7 @@ mod prim_tuple {}\n ///\n /// For more information on floating point numbers, see [Wikipedia][wikipedia].\n ///\n-/// *[See also the `std::f32::consts` module](f32/consts/index.html).*\n+/// *[See also the `std::f32::consts` module][`crate::f32::consts`].*\n ///\n /// [wikipedia]: https://en.wikipedia.org/wiki/Single-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -819,13 +795,14 @@ mod prim_f32 {}\n #[doc(primitive = \"f64\")]\n /// A 64-bit floating point type (specifically, the \"binary64\" type defined in IEEE 754-2008).\n ///\n-/// This type is very similar to [`f32`](primitive.f32.html), but has increased\n+/// This type is very similar to [`f32`], but has increased\n /// precision by using twice as many bits. Please see [the documentation for\n-/// `f32`](primitive.f32.html) or [Wikipedia on double precision\n+/// `f32`][`f32`] or [Wikipedia on double precision\n /// values][wikipedia] for more information.\n ///\n-/// *[See also the `std::f64::consts` module](f64/consts/index.html).*\n+/// *[See also the `std::f64::consts` module][`crate::f64::consts`].*\n ///\n+/// [`f32`]: prim@f32\n /// [wikipedia]: https://en.wikipedia.org/wiki/Double-precision_floating-point_format\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_f64 {}\n@@ -945,9 +922,6 @@ mod prim_usize {}\n /// implicit reference-pointer coercion and raw pointer equality via [`ptr::eq`], while\n /// [`PartialEq`] compares values.\n ///\n-/// [`ptr::eq`]: ptr/fn.eq.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-///\n /// ```\n /// use std::ptr;\n ///\n@@ -979,11 +953,9 @@ mod prim_usize {}\n /// * [`Borrow`]\n /// * [`Pointer`]\n ///\n-/// [`Copy`]: marker/trait.Copy.html\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`Deref`]: ops/trait.Deref.html\n-/// [`Borrow`]: borrow/trait.Borrow.html\n-/// [`Pointer`]: fmt/trait.Pointer.html\n+/// [`Deref`]: ops::Deref\n+/// [`Borrow`]: borrow::Borrow\n+/// [`Pointer`]: fmt::Pointer\n ///\n /// `&mut T` references get all of the above except `Copy` and `Clone` (to prevent creating\n /// multiple simultaneous mutable borrows), plus the following, regardless of the type of its\n@@ -992,8 +964,8 @@ mod prim_usize {}\n /// * [`DerefMut`]\n /// * [`BorrowMut`]\n ///\n-/// [`DerefMut`]: ops/trait.DerefMut.html\n-/// [`BorrowMut`]: borrow/trait.BorrowMut.html\n+/// [`DerefMut`]: ops::DerefMut\n+/// [`BorrowMut`]: borrow::BorrowMut\n ///\n /// The following traits are implemented on `&T` references if the underlying `T` also implements\n /// that trait:\n@@ -1008,18 +980,10 @@ mod prim_usize {}\n /// * [`Hash`]\n /// * [`ToSocketAddrs`]\n ///\n-/// [`std::fmt`]: fmt/index.html\n-/// [`fmt::Write`]: fmt/trait.Write.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`AsRef`]: convert/trait.AsRef.html\n-/// [`Fn`]: ops/trait.Fn.html\n-/// [`FnMut`]: ops/trait.FnMut.html\n-/// [`FnOnce`]: ops/trait.FnOnce.html\n-/// [`Hash`]: hash/trait.Hash.html\n-/// [`ToSocketAddrs`]: net/trait.ToSocketAddrs.html\n+/// [`std::fmt`]: fmt\n+/// ['Pointer`]: fmt::Pointer\n+/// [`Hash`]: hash::Hash\n+/// [`ToSocketAddrs`]: net::ToSocketAddrs\n ///\n /// `&mut T` references get all of the above except `ToSocketAddrs`, plus the following, if `T`\n /// implements that trait:\n@@ -1038,17 +1002,11 @@ mod prim_usize {}\n /// * [`Seek`]\n /// * [`BufRead`]\n ///\n-/// [`AsMut`]: convert/trait.AsMut.html\n-/// [`Iterator`]: iter/trait.Iterator.html\n-/// [`DoubleEndedIterator`]: iter/trait.DoubleEndedIterator.html\n-/// [`ExactSizeIterator`]: iter/trait.ExactSizeIterator.html\n-/// [`FusedIterator`]: iter/trait.FusedIterator.html\n-/// [`TrustedLen`]: iter/trait.TrustedLen.html\n-/// [`Send`]: marker/trait.Send.html\n-/// [`io::Write`]: io/trait.Write.html\n-/// [`Read`]: io/trait.Read.html\n-/// [`Seek`]: io/trait.Seek.html\n-/// [`BufRead`]: io/trait.BufRead.html\n+/// [`FusedIterator`]: iter::FusedIterator\n+/// [`TrustedLen`]: iter::TrustedLen\n+/// [`Seek`]: io::Seek\n+/// [`BufRead`]: io::BufRead\n+/// [`Read`]: io::Read\n ///\n /// Note that due to method call deref coercion, simply calling a trait method will act like they\n /// work on references as well as they do on owned values! The implementations described here are\n@@ -1063,9 +1021,9 @@ mod prim_ref {}\n ///\n /// *See also the traits [`Fn`], [`FnMut`], and [`FnOnce`].*\n ///\n-/// [`Fn`]: ops/trait.Fn.html\n-/// [`FnMut`]: ops/trait.FnMut.html\n-/// [`FnOnce`]: ops/trait.FnOnce.html\n+/// [`Fn`]: ops::Fn\n+/// [`FnMut`]: ops::FnMut\n+/// [`FnOnce`]: ops::FnOnce\n ///\n /// Function pointers are pointers that point to *code*, not data. They can be called\n /// just like functions. Like references, function pointers are, among other things, assumed to\n@@ -1177,14 +1135,8 @@ mod prim_ref {}\n /// * [`Pointer`]\n /// * [`Debug`]\n ///\n-/// [`Clone`]: clone/trait.Clone.html\n-/// [`PartialEq`]: cmp/trait.PartialEq.html\n-/// [`Eq`]: cmp/trait.Eq.html\n-/// [`PartialOrd`]: cmp/trait.PartialOrd.html\n-/// [`Ord`]: cmp/trait.Ord.html\n-/// [`Hash`]: hash/trait.Hash.html\n-/// [`Pointer`]: fmt/trait.Pointer.html\n-/// [`Debug`]: fmt/trait.Debug.html\n+/// [`Hash`]: hash::Hash\n+/// [`Pointer`]: fmt::Pointer\n ///\n /// Due to a temporary restriction in Rust's type system, these traits are only implemented on\n /// functions that take 12 arguments or less, with the `\"Rust\"` and `\"C\"` ABIs. In the future, this\n@@ -1193,7 +1145,5 @@ mod prim_ref {}\n /// In addition, function pointers of *any* signature, ABI, or safety are [`Copy`], and all *safe*\n /// function pointers implement [`Fn`], [`FnMut`], and [`FnOnce`]. This works because these traits\n /// are specially known to the compiler.\n-///\n-/// [`Copy`]: marker/trait.Copy.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n mod prim_fn {}"}, {"sha": "501ad8ee7d6b3c390afc75128232db04752c973f", "filename": "library/std/src/sys/wasi/ext/fs.rs", "status": "modified", "additions": 2, "deletions": 25, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Fext%2Ffs.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -9,8 +9,6 @@ use crate::sys::fs::osstr2str;\n use crate::sys_common::{AsInner, AsInnerMut, FromInner};\n \n /// WASI-specific extensions to [`File`].\n-///\n-/// [`File`]: ../../../../std/fs/struct.File.html\n pub trait FileExt {\n     /// Reads a number of bytes starting from a given offset.\n     ///\n@@ -23,8 +21,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::read`], it is not an error to return with a\n     /// short read.\n-    ///\n-    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read\n     fn read_at(&self, buf: &mut [u8], offset: u64) -> io::Result<usize> {\n         let bufs = &mut [IoSliceMut::new(buf)];\n         self.read_vectored_at(bufs, offset)\n@@ -41,8 +37,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::read_vectored`], it is not an error to\n     /// return with a short read.\n-    ///\n-    /// [`File::read`]: ../../../../std/fs/struct.File.html#method.read_vectored\n     fn read_vectored_at(&self, bufs: &mut [IoSliceMut<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Reads the exact number of byte required to fill `buf` from the given offset.\n@@ -54,8 +48,7 @@ pub trait FileExt {\n     ///\n     /// Similar to [`Read::read_exact`] but uses [`read_at`] instead of `read`.\n     ///\n-    /// [`Read::read_exact`]: ../../../../std/io/trait.Read.html#method.read_exact\n-    /// [`read_at`]: #tymethod.read_at\n+    /// [`read_at`]: FileExt::read_at\n     ///\n     /// # Errors\n     ///\n@@ -73,9 +66,6 @@ pub trait FileExt {\n     /// If this function returns an error, it is unspecified how many bytes it\n     /// has read, but it will never read more than would be necessary to\n     /// completely fill the buffer.\n-    ///\n-    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`ErrorKind::UnexpectedEof`]: ../../../../std/io/enum.ErrorKind.html#variant.UnexpectedEof\n     #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n     fn read_exact_at(&self, mut buf: &mut [u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n@@ -111,8 +101,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::write`], it is not an error to return a\n     /// short write.\n-    ///\n-    /// [`File::write`]: ../../../../std/fs/struct.File.html#write.v\n     fn write_at(&self, buf: &[u8], offset: u64) -> io::Result<usize> {\n         let bufs = &[IoSlice::new(buf)];\n         self.write_vectored_at(bufs, offset)\n@@ -132,8 +120,6 @@ pub trait FileExt {\n     ///\n     /// Note that similar to [`File::write_vectored`], it is not an error to return a\n     /// short write.\n-    ///\n-    /// [`File::write`]: ../../../../std/fs/struct.File.html#method.write_vectored\n     fn write_vectored_at(&self, bufs: &[IoSlice<'_>], offset: u64) -> io::Result<usize>;\n \n     /// Attempts to write an entire buffer starting from a given offset.\n@@ -155,8 +141,7 @@ pub trait FileExt {\n     /// This function will return the first error of\n     /// non-[`ErrorKind::Interrupted`] kind that [`write_at`] returns.\n     ///\n-    /// [`ErrorKind::Interrupted`]: ../../../../std/io/enum.ErrorKind.html#variant.Interrupted\n-    /// [`write_at`]: #tymethod.write_at\n+    /// [`write_at`]: FileExt::write_at\n     #[stable(feature = \"rw_exact_all_at\", since = \"1.33.0\")]\n     fn write_all_at(&self, mut buf: &[u8], mut offset: u64) -> io::Result<()> {\n         while !buf.is_empty() {\n@@ -289,8 +274,6 @@ impl FileExt for fs::File {\n }\n \n /// WASI-specific extensions to [`fs::OpenOptions`].\n-///\n-/// [`fs::OpenOptions`]: ../../../../std/fs/struct.OpenOptions.html\n pub trait OpenOptionsExt {\n     /// Pass custom `dirflags` argument to `path_open`.\n     ///\n@@ -406,8 +389,6 @@ impl OpenOptionsExt for OpenOptions {\n }\n \n /// WASI-specific extensions to [`fs::Metadata`].\n-///\n-/// [`fs::Metadata`]: ../../../../std/fs/struct.Metadata.html\n pub trait MetadataExt {\n     /// Returns the `st_dev` field of the internal `filestat_t`\n     fn dev(&self) -> u64;\n@@ -448,8 +429,6 @@ impl MetadataExt for fs::Metadata {\n ///\n /// Adds support for special WASI file types such as block/character devices,\n /// pipes, and sockets.\n-///\n-/// [`FileType`]: ../../../../std/fs/struct.FileType.html\n pub trait FileTypeExt {\n     /// Returns `true` if this file type is a block device.\n     fn is_block_device(&self) -> bool;\n@@ -477,8 +456,6 @@ impl FileTypeExt for fs::FileType {\n }\n \n /// WASI-specific extension methods for [`fs::DirEntry`].\n-///\n-/// [`fs::DirEntry`]: ../../../../std/fs/struct.DirEntry.html\n pub trait DirEntryExt {\n     /// Returns the underlying `d_ino` field of the `dirent_t`\n     fn ino(&self) -> u64;"}, {"sha": "8178e6806b9b30ddcd3db1cdc3b07086e79bb96f", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -306,10 +306,20 @@ pub fn dur2timeout(dur: Duration) -> c::DWORD {\n /// that function for more information on `__fastfail`\n #[allow(unreachable_code)]\n pub fn abort_internal() -> ! {\n-    #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))]\n+    const FAST_FAIL_FATAL_APP_EXIT: usize = 7;\n     unsafe {\n-        llvm_asm!(\"int $$0x29\" :: \"{ecx}\"(7) ::: volatile); // 7 is FAST_FAIL_FATAL_APP_EXIT\n-        crate::intrinsics::unreachable();\n+        cfg_if::cfg_if! {\n+            if #[cfg(any(target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+                asm!(\"int $$0x29\", in(\"ecx\") FAST_FAIL_FATAL_APP_EXIT);\n+                crate::intrinsics::unreachable();\n+            } else if #[cfg(all(target_arch = \"arm\", target_feature = \"thumb-mode\"))] {\n+                asm!(\".inst 0xDEFB\", in(\"r0\") FAST_FAIL_FATAL_APP_EXIT);\n+                crate::intrinsics::unreachable();\n+            } else if #[cfg(target_arch = \"aarch64\")] {\n+                asm!(\"brk 0xF003\", in(\"x0\") FAST_FAIL_FATAL_APP_EXIT);\n+                crate::intrinsics::unreachable();\n+            }\n+        }\n     }\n     crate::intrinsics::abort();\n }"}, {"sha": "323165cda6bd5387f7cdf2bd9f4f1d8adff42070", "filename": "library/std/src/sys_common/os_str_bytes.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fos_str_bytes.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -232,23 +232,17 @@ impl Slice {\n }\n \n /// Platform-specific extensions to [`OsString`].\n-///\n-/// [`OsString`]: ../../../../std/ffi/struct.OsString.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStringExt {\n     /// Creates an [`OsString`] from a byte vector.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsString`]: ../../../ffi/struct.OsString.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn from_vec(vec: Vec<u8>) -> Self;\n \n     /// Yields the underlying byte vector of this [`OsString`].\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsString`]: ../../../ffi/struct.OsString.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn into_vec(self) -> Vec<u8>;\n }\n@@ -264,23 +258,17 @@ impl OsStringExt for OsString {\n }\n \n /// Platform-specific extensions to [`OsStr`].\n-///\n-/// [`OsStr`]: ../../../../std/ffi/struct.OsStr.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait OsStrExt {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Creates an [`OsStr`] from a byte slice.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n     fn from_bytes(slice: &[u8]) -> &Self;\n \n     /// Gets the underlying byte view of the [`OsStr`] slice.\n     ///\n     /// See the module documentation for an example.\n-    ///\n-    /// [`OsStr`]: ../../../ffi/struct.OsStr.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn as_bytes(&self) -> &[u8];\n }"}, {"sha": "3f079da9098c7ef89f809f8d9b0f4ac757cdcf7f", "filename": "library/std/src/sys_common/poison.rs", "status": "modified", "additions": 7, "deletions": 18, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fpoison.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -3,6 +3,9 @@ use crate::fmt;\n use crate::sync::atomic::{AtomicBool, Ordering};\n use crate::thread;\n \n+#[allow(unused_imports)] // for intra-doc links\n+use crate::sync::{Mutex, RwLock};\n+\n pub struct Flag {\n     failed: AtomicBool,\n }\n@@ -77,9 +80,6 @@ pub struct Guard {\n ///     }\n /// };\n /// ```\n-///\n-/// [`Mutex`]: ../../std/sync/struct.Mutex.html\n-/// [`RwLock`]: ../../std/sync/struct.RwLock.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct PoisonError<T> {\n     guard: T,\n@@ -89,12 +89,9 @@ pub struct PoisonError<T> {\n /// can occur while trying to acquire a lock, from the [`try_lock`] method on a\n /// [`Mutex`] or the [`try_read`] and [`try_write`] methods on an [`RwLock`].\n ///\n-/// [`Mutex`]: struct.Mutex.html\n-/// [`RwLock`]: struct.RwLock.html\n-/// [`TryLockResult`]: type.TryLockResult.html\n-/// [`try_lock`]: struct.Mutex.html#method.try_lock\n-/// [`try_read`]: struct.RwLock.html#method.try_read\n-/// [`try_write`]: struct.RwLock.html#method.try_write\n+/// [`try_lock`]: Mutex::try_lock\n+/// [`try_read`]: RwLock::try_read\n+/// [`try_write`]: RwLock::try_write\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum TryLockError<T> {\n     /// The lock could not be acquired because another thread failed while holding\n@@ -115,9 +112,7 @@ pub enum TryLockError<T> {\n /// the associated guard, and it can be acquired through the [`into_inner`]\n /// method.\n ///\n-/// [`Ok`]: ../../std/result/enum.Result.html#variant.Ok\n-/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n-/// [`into_inner`]: ../../std/sync/struct.PoisonError.html#method.into_inner\n+/// [`into_inner`]: PoisonError::into_inner\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n \n@@ -126,9 +121,6 @@ pub type LockResult<Guard> = Result<Guard, PoisonError<Guard>>;\n /// For more information, see [`LockResult`]. A `TryLockResult` doesn't\n /// necessarily hold the associated guard in the [`Err`] type as the lock may not\n /// have been acquired for other reasons.\n-///\n-/// [`LockResult`]: ../../std/sync/type.LockResult.html\n-/// [`Err`]: ../../std/result/enum.Result.html#variant.Err\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub type TryLockResult<Guard> = Result<Guard, TryLockError<Guard>>;\n \n@@ -158,9 +150,6 @@ impl<T> PoisonError<T> {\n     /// Creates a `PoisonError`.\n     ///\n     /// This is generally created by methods like [`Mutex::lock`] or [`RwLock::read`].\n-    ///\n-    /// [`Mutex::lock`]: ../../std/sync/struct.Mutex.html#method.lock\n-    /// [`RwLock::read`]: ../../std/sync/struct.RwLock.html#method.read\n     #[stable(feature = \"sync_poison\", since = \"1.2.0\")]\n     pub fn new(guard: T) -> PoisonError<T> {\n         PoisonError { guard }"}, {"sha": "54eb2e99b8ff8f0bd82bf0363509c4d2577786bc", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -1079,6 +1079,11 @@ impl<'a> Builder<'a> {\n             },\n         );\n \n+        if self.config.cmd.bless() {\n+            // Bless `expect!` tests.\n+            cargo.env(\"UPDATE_EXPECT\", \"1\");\n+        }\n+\n         if !mode.is_tool() {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n         }"}, {"sha": "d021feafbe416cba705ae8a5b4ec6b1f17b3da8c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -647,6 +647,7 @@ impl Step for DebuggerScripts {\n \n             cp_debugger_script(\"lldb_lookup.py\");\n             cp_debugger_script(\"lldb_providers.py\");\n+            cp_debugger_script(\"lldb_commands\")\n         }\n     }\n }"}, {"sha": "ac833a55d4c53bbf2224fa0adf7fffba6b76de73", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -1754,11 +1754,6 @@ impl Step for Crate {\n             cargo.arg(\"--quiet\");\n         }\n \n-        if builder.config.cmd.bless() {\n-            // Bless `expect!` tests.\n-            cargo.env(\"UPDATE_EXPECT\", \"1\");\n-        }\n-\n         if target.contains(\"emscripten\") {\n             cargo.env(\n                 format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),"}, {"sha": "cd625f3fd096cf2f692daf11ccd902433fb593a5", "filename": "src/doc/unstable-book/src/compiler-flags/tls-model.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fcompiler-flags%2Ftls-model.md?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -22,4 +22,4 @@ The TLS data must not be in a library loaded after startup (via `dlopen`).\n but not in a shared library, and is accessed only from that executable.\n \n `rustc` and LLVM may use a more optimized model than specified if they know that we are producing\n-and executable rather than a library, or that the `static` item is private enough.\n+an executable rather than a library, or that the `static` item is private enough."}, {"sha": "979f2fa7ae8283d8bcff20579f0e474db2378b4c", "filename": "src/etc/lldb_commands", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fetc%2Flldb_commands", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fetc%2Flldb_commands", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Flldb_commands?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -1,4 +1,3 @@\n-command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_lookup.py\\\"\n type synthetic add -l lldb_lookup.synthetic_lookup -x \\\".*\\\" --category Rust\n type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^(alloc::([a-z_]+::)+)String$\\\" --category Rust\n type summary add -F lldb_lookup.summary_lookup  -e -x -h \\\"^&str$\\\" --category Rust"}, {"sha": "bce72f1bad698d45b0743adf0b9fb78fc9f039b2", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -30,5 +30,8 @@ EOF\n     fi\n fi\n \n+script_import=\"command script import \\\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_lookup.py\\\"\"\n+commands_file=\"$RUSTC_SYSROOT/lib/rustlib/etc/lldb_commands\"\n+\n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --source-before-file ./lldb_commands \"$@\"\n+exec \"$lldb\" --one-line-before-file \"$script_import\" --source-before-file \"$commands_file\" \"$@\""}, {"sha": "ea624b9ed300320005f09a304256ecfde485f372", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -38,6 +38,7 @@ use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{ForeignItemKind, GenericParamKind, PatKind};\n use rustc_hir::{HirId, HirIdSet, Node};\n+use rustc_index::vec::Idx;\n use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::ty::subst::{GenericArgKind, Subst};\n use rustc_middle::ty::{self, layout::LayoutError, Ty, TyCtxt};\n@@ -2162,6 +2163,40 @@ impl ClashingExternDeclarations {\n             ckind: CItemKind,\n         ) -> bool {\n             debug!(\"structurally_same_type_impl(cx, a = {:?}, b = {:?})\", a, b);\n+            let tcx = cx.tcx;\n+\n+            // Given a transparent newtype, reach through and grab the inner\n+            // type unless the newtype makes the type non-null.\n+            let non_transparent_ty = |ty: Ty<'tcx>| -> Ty<'tcx> {\n+                let mut ty = ty;\n+                loop {\n+                    if let ty::Adt(def, substs) = ty.kind {\n+                        let is_transparent = def.subst(tcx, substs).repr.transparent();\n+                        let is_non_null = crate::types::nonnull_optimization_guaranteed(tcx, &def);\n+                        debug!(\n+                            \"non_transparent_ty({:?}) -- type is transparent? {}, type is non-null? {}\",\n+                            ty, is_transparent, is_non_null\n+                        );\n+                        if is_transparent && !is_non_null {\n+                            debug_assert!(def.variants.len() == 1);\n+                            let v = &def.variants[VariantIdx::new(0)];\n+                            ty = v\n+                                .transparent_newtype_field(tcx)\n+                                .expect(\n+                                    \"single-variant transparent structure with zero-sized field\",\n+                                )\n+                                .ty(tcx, substs);\n+                            continue;\n+                        }\n+                    }\n+                    debug!(\"non_transparent_ty -> {:?}\", ty);\n+                    return ty;\n+                }\n+            };\n+\n+            let a = non_transparent_ty(a);\n+            let b = non_transparent_ty(b);\n+\n             if !seen_types.insert((a, b)) {\n                 // We've encountered a cycle. There's no point going any further -- the types are\n                 // structurally the same."}, {"sha": "35c462c24c8e88a0b229e182e4c20a65e313dfac", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -11,7 +11,7 @@ use rustc_index::vec::Idx;\n use rustc_middle::mir::interpret::{sign_extend, truncate};\n use rustc_middle::ty::layout::{IntegerExt, SizeSkeleton};\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::{self, AdtKind, Ty, TypeFoldable};\n+use rustc_middle::ty::{self, AdtKind, Ty, TyCtxt, TypeFoldable};\n use rustc_span::source_map;\n use rustc_span::symbol::sym;\n use rustc_span::{Span, DUMMY_SP};\n@@ -527,22 +527,26 @@ enum FfiResult<'tcx> {\n     FfiUnsafe { ty: Ty<'tcx>, reason: String, help: Option<String> },\n }\n \n+crate fn nonnull_optimization_guaranteed<'tcx>(tcx: TyCtxt<'tcx>, def: &ty::AdtDef) -> bool {\n+    tcx.get_attrs(def.did)\n+        .iter()\n+        .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed))\n+}\n+\n /// Is type known to be non-null?\n-fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n+crate fn ty_is_known_nonnull<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, mode: CItemKind) -> bool {\n     let tcx = cx.tcx;\n     match ty.kind {\n         ty::FnPtr(_) => true,\n         ty::Ref(..) => true,\n         ty::Adt(def, _) if def.is_box() && matches!(mode, CItemKind::Definition) => true,\n         ty::Adt(def, substs) if def.repr.transparent() && !def.is_union() => {\n-            let guaranteed_nonnull_optimization = tcx\n-                .get_attrs(def.did)\n-                .iter()\n-                .any(|a| tcx.sess.check_name(a, sym::rustc_nonnull_optimization_guaranteed));\n+            let marked_non_null = nonnull_optimization_guaranteed(tcx, &def);\n \n-            if guaranteed_nonnull_optimization {\n+            if marked_non_null {\n                 return true;\n             }\n+\n             for variant in &def.variants {\n                 if let Some(field) = variant.transparent_newtype_field(tcx) {\n                     if ty_is_known_nonnull(cx, field.ty(tcx, substs), mode) {"}, {"sha": "a65d3446819244de1dd443eef8267a40b16bff8d", "filename": "src/librustc_parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_parse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flexer%2Fmod.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -46,19 +46,10 @@ impl<'a> StringReader<'a> {\n         source_file: Lrc<rustc_span::SourceFile>,\n         override_span: Option<Span>,\n     ) -> Self {\n-        // Make sure external source is loaded first, before accessing it.\n-        // While this can't show up during normal parsing, `retokenize` may\n-        // be called with a source file from an external crate.\n-        sess.source_map().ensure_source_file_source_present(Lrc::clone(&source_file));\n-\n-        let src = if let Some(src) = &source_file.src {\n-            Lrc::clone(&src)\n-        } else if let Some(src) = source_file.external_src.borrow().get_source() {\n-            Lrc::clone(&src)\n-        } else {\n+        let src = source_file.src.clone().unwrap_or_else(|| {\n             sess.span_diagnostic\n                 .bug(&format!(\"cannot lex `source_file` without source: {}\", source_file.name));\n-        };\n+        });\n \n         StringReader {\n             sess,\n@@ -70,23 +61,6 @@ impl<'a> StringReader<'a> {\n         }\n     }\n \n-    pub fn retokenize(sess: &'a ParseSess, mut span: Span) -> Self {\n-        let begin = sess.source_map().lookup_byte_offset(span.lo());\n-        let end = sess.source_map().lookup_byte_offset(span.hi());\n-\n-        // Make the range zero-length if the span is invalid.\n-        if begin.sf.start_pos != end.sf.start_pos {\n-            span = span.shrink_to_lo();\n-        }\n-\n-        let mut sr = StringReader::new(sess, begin.sf, None);\n-\n-        // Seek the lexer to the right byte range.\n-        sr.end_src_index = sr.src_index(span.hi());\n-\n-        sr\n-    }\n-\n     fn mk_sp(&self, lo: BytePos, hi: BytePos) -> Span {\n         self.override_span.unwrap_or_else(|| Span::with_root_ctxt(lo, hi))\n     }"}, {"sha": "979a8da2a9f682740c96ea0579bd180a0372a2f2", "filename": "src/librustc_save_analysis/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2FCargo.toml?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -16,7 +16,7 @@ rustc_ast_pretty = { path = \"../librustc_ast_pretty\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_hir = { path = \"../librustc_hir\" }\n rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n-rustc_parse = { path = \"../librustc_parse\" }\n+rustc_lexer = { path = \"../librustc_lexer\" }\n serde_json = \"1\"\n rustc_session = { path = \"../librustc_session\" }\n rustc_span = { path = \"../librustc_span\" }"}, {"sha": "ce484858cbb66e1b74a73a0c3f91d62e34391161", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -14,7 +14,7 @@\n //! recording the output.\n \n use rustc_ast as ast;\n-use rustc_ast::{token, walk_list};\n+use rustc_ast::walk_list;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind as HirDefKind, Res};\n@@ -1207,9 +1207,7 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n \n                 // Otherwise it's a span with wrong macro expansion info, which\n                 // we don't want to track anyway, since it's probably macro-internal `use`\n-                if let Some(sub_span) =\n-                    self.span.sub_span_of_token(item.span, token::BinOp(token::Star))\n-                {\n+                if let Some(sub_span) = self.span.sub_span_of_star(item.span) {\n                     if !self.span.filter_generated(item.span) {\n                         let access = access_from!(self.save_ctxt, item, item.hir_id);\n                         let span = self.span_from_span(sub_span);"}, {"sha": "edcd4925773743270fc2b97e280b6a3e1599e6d4", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 30, "deletions": 54, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -1,6 +1,6 @@\n use crate::generated_code;\n-use rustc_ast::token::{self, TokenKind};\n-use rustc_parse::lexer::{self, StringReader};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_lexer::{tokenize, TokenKind};\n use rustc_session::Session;\n use rustc_span::*;\n \n@@ -43,61 +43,37 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn retokenise_span(&self, span: Span) -> StringReader<'a> {\n-        lexer::StringReader::retokenize(&self.sess.parse_sess, span)\n-    }\n-\n-    pub fn sub_span_of_token(&self, span: Span, tok: TokenKind) -> Option<Span> {\n-        let mut toks = self.retokenise_span(span);\n-        loop {\n-            let next = toks.next_token();\n-            if next == token::Eof {\n-                return None;\n-            }\n-            if next == tok {\n-                return Some(next.span);\n-            }\n+    /// Finds the span of `*` token withing the larger `span`.\n+    pub fn sub_span_of_star(&self, mut span: Span) -> Option<Span> {\n+        let begin = self.sess.source_map().lookup_byte_offset(span.lo());\n+        let end = self.sess.source_map().lookup_byte_offset(span.hi());\n+        // Make the range zero-length if the span is invalid.\n+        if begin.sf.start_pos != end.sf.start_pos {\n+            span = span.shrink_to_lo();\n         }\n-    }\n \n-    // // Return the name for a macro definition (identifier after first `!`)\n-    // pub fn span_for_macro_def_name(&self, span: Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     loop {\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Eof {\n-    //             return None;\n-    //         }\n-    //         if ts == token::Not {\n-    //             let ts = toks.real_token();\n-    //             if ts.kind.is_ident() {\n-    //                 return Some(ts.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //     }\n-    // }\n+        let sf = Lrc::clone(&begin.sf);\n \n-    // // Return the name for a macro use (identifier before first `!`).\n-    // pub fn span_for_macro_use_name(&self, span:Span) -> Option<Span> {\n-    //     let mut toks = self.retokenise_span(span);\n-    //     let mut prev = toks.real_token();\n-    //     loop {\n-    //         if prev == token::Eof {\n-    //             return None;\n-    //         }\n-    //         let ts = toks.real_token();\n-    //         if ts == token::Not {\n-    //             if prev.kind.is_ident() {\n-    //                 return Some(prev.sp);\n-    //             } else {\n-    //                 return None;\n-    //             }\n-    //         }\n-    //         prev = ts;\n-    //     }\n-    // }\n+        self.sess.source_map().ensure_source_file_source_present(Lrc::clone(&sf));\n+        let src =\n+            sf.src.clone().or_else(|| sf.external_src.borrow().get_source().map(Lrc::clone))?;\n+        let to_index = |pos: BytePos| -> usize { (pos - sf.start_pos).0 as usize };\n+        let text = &src[to_index(span.lo())..to_index(span.hi())];\n+        let start_pos = {\n+            let mut pos = 0;\n+            tokenize(text)\n+                .map(|token| {\n+                    let start = pos;\n+                    pos += token.len;\n+                    (start, token)\n+                })\n+                .find(|(_pos, token)| token.kind == TokenKind::Star)?\n+                .0\n+        };\n+        let lo = span.lo() + BytePos(start_pos as u32);\n+        let hi = lo + BytePos(1);\n+        Some(span.with_lo(lo).with_hi(hi))\n+    }\n \n     /// Return true if the span is generated code, and\n     /// it is not a subspan of the root callsite."}, {"sha": "a1eef5c1202cbf7d5b4701eff86e4447dc0372e9", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -92,6 +92,7 @@ function defocusSearchBar() {\n     var disableShortcuts = getCurrentValue(\"rustdoc-disable-shortcuts\") === \"true\";\n     var search_input = getSearchInput();\n     var searchTimeout = null;\n+    var toggleAllDocsId = \"toggle-all-docs\";\n \n     // On the search screen, so you remain on the last tab you opened.\n     //\n@@ -1397,8 +1398,8 @@ function defocusSearchBar() {\n                 // \"current\" is used to know which tab we're looking into.\n                 var current = 0;\n                 onEachLazy(document.getElementById(\"results\").childNodes, function(e) {\n-                    onEachLazy(e.getElementsByClassName(\"highlighted\"), function(e) {\n-                        actives[current].push(e);\n+                    onEachLazy(e.getElementsByClassName(\"highlighted\"), function(h_e) {\n+                        actives[current].push(h_e);\n                     });\n                     current += 1;\n                 });\n@@ -2121,7 +2122,7 @@ function defocusSearchBar() {\n     }\n \n     function toggleAllDocs(pageId, fromAutoCollapse) {\n-        var innerToggle = document.getElementById(\"toggle-all-docs\");\n+        var innerToggle = document.getElementById(toggleAllDocsId);\n         if (!innerToggle) {\n             return;\n         }\n@@ -2314,11 +2315,6 @@ function defocusSearchBar() {\n         }\n     }\n \n-    var toggles = document.getElementById(\"toggle-all-docs\");\n-    if (toggles) {\n-        toggles.onclick = toggleAllDocs;\n-    }\n-\n     function insertAfter(newNode, referenceNode) {\n         referenceNode.parentNode.insertBefore(newNode, referenceNode.nextSibling);\n     }\n@@ -2368,6 +2364,11 @@ function defocusSearchBar() {\n     }\n \n     (function() {\n+        var toggles = document.getElementById(toggleAllDocsId);\n+        if (toggles) {\n+            toggles.onclick = toggleAllDocs;\n+        }\n+\n         var toggle = createSimpleToggle(false);\n         var hideMethodDocs = getCurrentValue(\"rustdoc-auto-hide-method-docs\") === \"true\";\n         var hideImplementors = getCurrentValue(\"rustdoc-auto-collapse-implementors\") !== \"false\";"}, {"sha": "55dcaec8ae1e160191a494709b973623b3650fb1", "filename": "src/librustdoc/html/static/rustdoc.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Frustdoc.css?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -1290,7 +1290,7 @@ h4 > .notable-traits {\n #theme-choices > button {\n \tborder: none;\n \twidth: 100%;\n-\tpadding: 4px;\n+\tpadding: 4px 8px;\n \ttext-align: center;\n \tbackground: rgba(0,0,0,0);\n }"}, {"sha": "7ae78782ff9d1477cf2545e434da06d184ccdf3b", "filename": "src/test/codegen/issue-27130.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fcodegen%2Fissue-27130.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fcodegen%2Fissue-27130.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fissue-27130.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -0,0 +1,22 @@\n+// compile-flags: -O\n+// min-llvm-version: 11.0\n+\n+#![crate_type = \"lib\"]\n+\n+// CHECK-LABEL: @trim_in_place\n+#[no_mangle]\n+pub fn trim_in_place(a: &mut &[u8]) {\n+    while a.first() == Some(&42) {\n+        // CHECK-NOT: slice_index_order_fail\n+        *a = &a[1..];\n+    }\n+}\n+\n+// CHECK-LABEL: @trim_in_place2\n+#[no_mangle]\n+pub fn trim_in_place2(a: &mut &[u8]) {\n+    while let Some(&42) = a.first() {\n+        // CHECK-NOT: slice_index_order_fail\n+        *a = &a[2..];\n+    }\n+}"}, {"sha": "41f0baecf24a892704d45d95beaed02c808b5fea", "filename": "src/test/ui/lint/clashing-extern-fn.rs", "status": "modified", "additions": 78, "deletions": 3, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.rs?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -182,7 +182,9 @@ mod same_sized_members_clash {\n             y: f32,\n             z: f32,\n         }\n-        extern \"C\" { fn origin() -> Point3; }\n+        extern \"C\" {\n+            fn origin() -> Point3;\n+        }\n     }\n     mod b {\n         #[repr(C)]\n@@ -191,8 +193,9 @@ mod same_sized_members_clash {\n             y: i32,\n             z: i32, // NOTE: Incorrectly redeclared as i32\n         }\n-        extern \"C\" { fn origin() -> Point3; }\n-        //~^ WARN `origin` redeclared with a different signature\n+        extern \"C\" {\n+            fn origin() -> Point3; //~ WARN `origin` redeclared with a different signature\n+        }\n     }\n }\n \n@@ -258,6 +261,78 @@ mod non_zero_and_non_null {\n     }\n }\n \n+// See #75739\n+mod non_zero_transparent {\n+    mod a1 {\n+        use std::num::NonZeroUsize;\n+        extern \"C\" {\n+            fn f1() -> NonZeroUsize;\n+        }\n+    }\n+\n+    mod b1 {\n+        #[repr(transparent)]\n+        struct X(NonZeroUsize);\n+        use std::num::NonZeroUsize;\n+        extern \"C\" {\n+            fn f1() -> X;\n+        }\n+    }\n+\n+    mod a2 {\n+        use std::num::NonZeroUsize;\n+        extern \"C\" {\n+            fn f2() -> NonZeroUsize;\n+        }\n+    }\n+\n+    mod b2 {\n+        #[repr(transparent)]\n+        struct X1(NonZeroUsize);\n+\n+        #[repr(transparent)]\n+        struct X(X1);\n+\n+        use std::num::NonZeroUsize;\n+        extern \"C\" {\n+            // Same case as above, but with two layers of newtyping.\n+            fn f2() -> X;\n+        }\n+    }\n+\n+    mod a3 {\n+        #[repr(transparent)]\n+        struct X(core::ptr::NonNull<i32>);\n+\n+        use std::num::NonZeroUsize;\n+        extern \"C\" {\n+            fn f3() -> X;\n+        }\n+    }\n+\n+    mod b3 {\n+        extern \"C\" {\n+            fn f3() -> core::ptr::NonNull<i32>;\n+        }\n+    }\n+\n+    mod a4 {\n+        #[repr(transparent)]\n+        enum E {\n+            X(std::num::NonZeroUsize),\n+        }\n+        extern \"C\" {\n+            fn f4() -> E;\n+        }\n+    }\n+\n+    mod b4 {\n+        extern \"C\" {\n+            fn f4() -> std::num::NonZeroUsize;\n+        }\n+    }\n+}\n+\n mod null_optimised_enums {\n     mod a {\n         extern \"C\" {"}, {"sha": "0a18f05ba2903ca915219a80db4fd94fbd35ede1", "filename": "src/test/ui/lint/clashing-extern-fn.stderr", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/62850d882b1f546783d064ca3b51d1f85b92eeb7/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn.stderr?ref=62850d882b1f546783d064ca3b51d1f85b92eeb7", "patch": "@@ -106,19 +106,19 @@ LL |             fn draw_point(p: Point);\n               found `unsafe extern \"C\" fn(sameish_members::b::Point)`\n \n warning: `origin` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:194:22\n+  --> $DIR/clashing-extern-fn.rs:197:13\n    |\n-LL |         extern \"C\" { fn origin() -> Point3; }\n-   |                      ---------------------- `origin` previously declared here\n+LL |             fn origin() -> Point3;\n+   |             ---------------------- `origin` previously declared here\n ...\n-LL |         extern \"C\" { fn origin() -> Point3; }\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n+LL |             fn origin() -> Point3;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ this signature doesn't match the previous declaration\n    |\n    = note: expected `unsafe extern \"C\" fn() -> same_sized_members_clash::a::Point3`\n               found `unsafe extern \"C\" fn() -> same_sized_members_clash::b::Point3`\n \n warning: `transparent_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:217:13\n+  --> $DIR/clashing-extern-fn.rs:220:13\n    |\n LL |             fn transparent_incorrect() -> T;\n    |             -------------------------------- `transparent_incorrect` previously declared here\n@@ -130,7 +130,7 @@ LL |             fn transparent_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `missing_return_type` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:235:13\n+  --> $DIR/clashing-extern-fn.rs:238:13\n    |\n LL |             fn missing_return_type() -> usize;\n    |             ---------------------------------- `missing_return_type` previously declared here\n@@ -142,7 +142,7 @@ LL |             fn missing_return_type();\n               found `unsafe extern \"C\" fn()`\n \n warning: `non_zero_usize` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:253:13\n+  --> $DIR/clashing-extern-fn.rs:256:13\n    |\n LL |             fn non_zero_usize() -> core::num::NonZeroUsize;\n    |             ----------------------------------------------- `non_zero_usize` previously declared here\n@@ -154,7 +154,7 @@ LL |             fn non_zero_usize() -> usize;\n               found `unsafe extern \"C\" fn() -> usize`\n \n warning: `non_null_ptr` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:255:13\n+  --> $DIR/clashing-extern-fn.rs:258:13\n    |\n LL |             fn non_null_ptr() -> core::ptr::NonNull<usize>;\n    |             ----------------------------------------------- `non_null_ptr` previously declared here\n@@ -166,7 +166,7 @@ LL |             fn non_null_ptr() -> *const usize;\n               found `unsafe extern \"C\" fn() -> *const usize`\n \n warning: `option_non_zero_usize_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:281:13\n+  --> $DIR/clashing-extern-fn.rs:356:13\n    |\n LL |             fn option_non_zero_usize_incorrect() -> usize;\n    |             ---------------------------------------------- `option_non_zero_usize_incorrect` previously declared here\n@@ -178,7 +178,7 @@ LL |             fn option_non_zero_usize_incorrect() -> isize;\n               found `unsafe extern \"C\" fn() -> isize`\n \n warning: `option_non_null_ptr_incorrect` redeclared with a different signature\n-  --> $DIR/clashing-extern-fn.rs:283:13\n+  --> $DIR/clashing-extern-fn.rs:358:13\n    |\n LL |             fn option_non_null_ptr_incorrect() -> *const usize;\n    |             --------------------------------------------------- `option_non_null_ptr_incorrect` previously declared here"}]}