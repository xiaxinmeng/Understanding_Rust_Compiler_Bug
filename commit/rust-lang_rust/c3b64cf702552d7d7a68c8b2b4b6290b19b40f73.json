{"sha": "c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzYjY0Y2Y3MDI1NTJkN2Q3YTY4YzhiMmI0YjYyOTBiMTliNDBmNzM=", "commit": {"author": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2017-02-07T17:35:06Z"}, "committer": {"name": "Austin Hicks", "email": "camlorn@camlorn.net", "date": "2017-02-07T17:35:06Z"}, "message": "Refactor layout to use the new ReprOptions", "tree": {"sha": "675fc7109d15babbe244849c8ce6a3c21271ff2a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/675fc7109d15babbe244849c8ce6a3c21271ff2a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "html_url": "https://github.com/rust-lang/rust/commit/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73/comments", "author": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ahicks92", "id": 6968705, "node_id": "MDQ6VXNlcjY5Njg3MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/6968705?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ahicks92", "html_url": "https://github.com/ahicks92", "followers_url": "https://api.github.com/users/ahicks92/followers", "following_url": "https://api.github.com/users/ahicks92/following{/other_user}", "gists_url": "https://api.github.com/users/ahicks92/gists{/gist_id}", "starred_url": "https://api.github.com/users/ahicks92/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ahicks92/subscriptions", "organizations_url": "https://api.github.com/users/ahicks92/orgs", "repos_url": "https://api.github.com/users/ahicks92/repos", "events_url": "https://api.github.com/users/ahicks92/events{/privacy}", "received_events_url": "https://api.github.com/users/ahicks92/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "541aa8a27039b196df626193886f39373dd09b0b", "url": "https://api.github.com/repos/rust-lang/rust/commits/541aa8a27039b196df626193886f39373dd09b0b", "html_url": "https://github.com/rust-lang/rust/commit/541aa8a27039b196df626193886f39373dd09b0b"}], "stats": {"total": 102, "additions": 39, "deletions": 63}, "files": [{"sha": "3a463e981a6272e152b598113b32bdd4154de9fd", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 39, "deletions": 63, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3b64cf702552d7d7a68c8b2b4b6290b19b40f73/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=c3b64cf702552d7d7a68c8b2b4b6290b19b40f73", "patch": "@@ -15,7 +15,7 @@ pub use self::Primitive::*;\n use infer::InferCtxt;\n use session::Session;\n use traits;\n-use ty::{self, Ty, TyCtxt, TypeFoldable};\n+use ty::{self, Ty, TyCtxt, TypeFoldable, ReprOptions};\n \n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n@@ -437,7 +437,7 @@ impl Integer {\n     /// signed discriminant range and #[repr] attribute.\n     /// N.B.: u64 values above i64::MAX will be treated as signed, but\n     /// that shouldn't affect anything, other than maybe debuginfo.\n-    fn repr_discr(tcx: TyCtxt, ty: Ty, hints: &[attr::ReprAttr], min: i64, max: i64)\n+    fn repr_discr(tcx: TyCtxt, ty: Ty, repr: &ReprOptions, min: i64, max: i64)\n                       -> (Integer, bool) {\n         // Theoretically, negative values could be larger in unsigned representation\n         // than the unsigned representation of the signed minimum. However, if there\n@@ -449,34 +449,24 @@ impl Integer {\n         let mut min_from_extern = None;\n         let min_default = I8;\n \n-        for &r in hints.iter() {\n-            match r {\n-                attr::ReprInt(ity) => {\n-                    let discr = Integer::from_attr(&tcx.data_layout, ity);\n-                    let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n-                    if discr < fit {\n-                        bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n-                              discriminant range of enum `{}\", ty)\n-                    }\n-                    return (discr, ity.is_signed());\n-                }\n-                attr::ReprExtern => {\n-                    match &tcx.sess.target.target.arch[..] {\n-                        // WARNING: the ARM EABI has two variants; the one corresponding\n-                        // to `at_least == I32` appears to be used on Linux and NetBSD,\n-                        // but some systems may use the variant corresponding to no\n-                        // lower bound.  However, we don't run on those yet...?\n-                        \"arm\" => min_from_extern = Some(I32),\n-                        _ => min_from_extern = Some(I32),\n-                    }\n-                }\n-                attr::ReprAny => {},\n-                attr::ReprPacked => {\n-                    bug!(\"Integer::repr_discr: found #[repr(packed)] on enum `{}\", ty);\n-                }\n-                attr::ReprSimd => {\n-                    bug!(\"Integer::repr_discr: found #[repr(simd)] on enum `{}\", ty);\n-                }\n+        if let Some(ity) = repr.int {\n+            let discr = Integer::from_attr(&tcx.data_layout, ity);\n+            let fit = if ity.is_signed() { signed_fit } else { unsigned_fit };\n+            if discr < fit {\n+                bug!(\"Integer::repr_discr: `#[repr]` hint too small for \\\n+                  discriminant range of enum `{}\", ty)\n+            }\n+            return (discr, ity.is_signed());\n+        }\n+\n+        if repr.c {\n+            match &tcx.sess.target.target.arch[..] {\n+                // WARNING: the ARM EABI has two variants; the one corresponding\n+                // to `at_least == I32` appears to be used on Linux and NetBSD,\n+                // but some systems may use the variant corresponding to no\n+                // lower bound.  However, we don't run on those yet...?\n+                \"arm\" => min_from_extern = Some(I32),\n+                _ => min_from_extern = Some(I32),\n             }\n         }\n \n@@ -568,9 +558,9 @@ enum StructKind {\n impl<'a, 'gcx, 'tcx> Struct {\n     // FIXME(camlorn): reprs need a better representation to deal with multiple reprs on one type.\n     fn new(dl: &TargetDataLayout, fields: &Vec<&'a Layout>,\n-                  reprs: &[attr::ReprAttr], kind: StructKind,\n+                  repr: &ReprOptions, kind: StructKind,\n                   scapegoat: Ty<'gcx>) -> Result<Struct, LayoutError<'gcx>> {\n-        let packed = reprs.contains(&attr::ReprPacked);\n+        let packed = repr.packed;\n         let mut ret = Struct {\n             align: if packed { dl.i8_align } else { dl.aggregate_align },\n             packed: packed,\n@@ -580,27 +570,16 @@ impl<'a, 'gcx, 'tcx> Struct {\n             min_size: Size::from_bytes(0),\n         };\n \n-        // Anything with ReprExtern or ReprPacked doesn't optimize.\n+        // Anything with repr(C) or repr(packed) doesn't optimize.\n         // Neither do  1-member and 2-member structs.\n         // In addition, code in trans assume that 2-element structs can become pairs.\n         // It's easier to just short-circuit here.\n-        let mut can_optimize = fields.len() > 2 || StructKind::EnumVariant == kind;\n-        if can_optimize {\n-            // This exhaustive match makes new reprs force the adder to modify this function.\n-            // Otherwise, things can silently break.\n-            // Note the inversion, return true to stop optimizing.\n-            can_optimize = !reprs.iter().any(|r| {\n-                match *r {\n-                    attr::ReprAny | attr::ReprInt(_) => false,\n-                    attr::ReprExtern | attr::ReprPacked => true,\n-                    attr::ReprSimd => bug!(\"Simd  vectors should be represented as layout::Vector\")\n-                }\n-            });\n-        }\n+        let mut can_optimize = (fields.len() > 2 || StructKind::EnumVariant == kind)\n+            && ! (repr.c || repr.packed);\n \n         // Disable field reordering until we can decide what to do.\n         // The odd pattern here avoids a warning about the value never being read.\n-        if can_optimize { can_optimize = false }\n+        if can_optimize { can_optimize = false; }\n \n         let (optimize, sort_ascending) = match kind {\n             StructKind::AlwaysSizedUnivariant => (can_optimize, false),\n@@ -1092,7 +1071,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // The never type.\n             ty::TyNever => Univariant {\n-                variant: Struct::new(dl, &vec![], &[],\n+                variant: Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?,\n                 non_zero: false\n             },\n@@ -1135,12 +1114,12 @@ impl<'a, 'gcx, 'tcx> Layout {\n             ty::TyFnDef(..) => {\n                 Univariant {\n                     variant: Struct::new(dl, &vec![],\n-                      &[], StructKind::AlwaysSizedUnivariant, ty)?,\n+                      &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?,\n                     non_zero: false\n                 }\n             }\n             ty::TyDynamic(..) => {\n-                let mut unit = Struct::new(dl, &vec![], &[],\n+                let mut unit = Struct::new(dl, &vec![], &ReprOptions::default(),\n                   StructKind::AlwaysSizedUnivariant, ty)?;\n                 unit.sized = false;\n                 Univariant { variant: unit, non_zero: false }\n@@ -1152,7 +1131,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[],\n+                    &ReprOptions::default(),\n                     StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n@@ -1163,7 +1142,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 let st = Struct::new(dl,\n                     &tys.iter().map(|ty| ty.layout(infcx))\n                       .collect::<Result<Vec<_>, _>>()?,\n-                    &[], StructKind::AlwaysSizedUnivariant, ty)?;\n+                    &ReprOptions::default(), StructKind::AlwaysSizedUnivariant, ty)?;\n                 Univariant { variant: st, non_zero: false }\n             }\n \n@@ -1187,16 +1166,13 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n             // ADTs.\n             ty::TyAdt(def, substs) => {\n-                let hints = &tcx.lookup_repr_hints(def.did)[..];\n-\n                 if def.variants.is_empty() {\n                     // Uninhabitable; represent as unit\n                     // (Typechecking will reject discriminant-sizing attrs.)\n-                    assert_eq!(hints.len(), 0);\n \n                     return success(Univariant {\n                         variant: Struct::new(dl, &vec![],\n-                          &hints[..], StructKind::AlwaysSizedUnivariant, ty)?,\n+                          &def.repr, StructKind::AlwaysSizedUnivariant, ty)?,\n                         non_zero: false\n                     });\n                 }\n@@ -1219,7 +1195,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                     // FIXME: should handle i128? signed-value based impl is weird and hard to\n                     // grok.\n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &def.repr,\n                                                               min,\n                                                               max);\n                     return success(CEnum {\n@@ -1232,7 +1208,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     });\n                 }\n \n-                if !def.is_enum() || def.variants.len() == 1 && hints.is_empty() {\n+                if !def.is_enum() || def.variants.len() == 1 {\n                     // Struct, or union, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n@@ -1259,7 +1235,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         un.extend(dl, fields.iter().map(|&f| Ok(f)), ty)?;\n                         UntaggedUnion { variants: un }\n                     } else {\n-                        let st = Struct::new(dl, &fields, &hints[..],\n+                        let st = Struct::new(dl, &fields, &def.repr,\n                           kind, ty)?;\n                         let non_zero = Some(def.did) == tcx.lang_items.non_zero();\n                         Univariant { variant: st, non_zero: non_zero }\n@@ -1282,7 +1258,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     v.fields.iter().map(|field| field.ty(tcx, substs)).collect::<Vec<_>>()\n                 }).collect::<Vec<_>>();\n \n-                if variants.len() == 2 && hints.is_empty() {\n+                if variants.len() == 2 && !def.repr.c {\n                     // Nullable pointer optimization\n                     for discr in 0..2 {\n                         let other_fields = variants[1 - discr].iter().map(|ty| {\n@@ -1315,7 +1291,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                         let st = Struct::new(dl,\n                             &variants[discr].iter().map(|ty| ty.layout(infcx))\n                               .collect::<Result<Vec<_>, _>>()?,\n-                            &hints[..], StructKind::AlwaysSizedUnivariant, ty)?;\n+                            &def.repr, StructKind::AlwaysSizedUnivariant, ty)?;\n \n                         // We have to fix the last element of path here.\n                         let mut i = *path.last().unwrap();\n@@ -1338,7 +1314,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // The general case.\n                 let discr_max = (variants.len() - 1) as i64;\n                 assert!(discr_max >= 0);\n-                let (min_ity, _) = Integer::repr_discr(tcx, ty, &hints[..], 0, discr_max);\n+                let (min_ity, _) = Integer::repr_discr(tcx, ty, &def.repr, 0, discr_max);\n \n                 let mut align = dl.aggregate_align;\n                 let mut size = Size::from_bytes(0);\n@@ -1356,7 +1332,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                     fields.insert(0, &discr);\n                     let st = Struct::new(dl,\n                         &fields,\n-                        &hints[..], StructKind::EnumVariant, ty)?;\n+                        &def.repr, StructKind::EnumVariant, ty)?;\n                     // Find the first field we can't move later\n                     // to make room for a larger discriminant.\n                     // It is important to skip the first field."}]}