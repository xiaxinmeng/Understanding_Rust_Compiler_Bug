{"sha": "347fa7a26f3eb6085418a26cef18f133635f7a9f", "node_id": "C_kwDOAAsO6NoAKDM0N2ZhN2EyNmYzZWI2MDg1NDE4YTI2Y2VmMThmMTMzNjM1ZjdhOWY", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-26T10:30:28Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2023-01-26T12:45:49Z"}, "message": "rustdoc: Stop using `HirId`s\n\nUse `LocalDefId`s instead", "tree": {"sha": "93061be1a973e1a45539c406109b27d4f089f7a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93061be1a973e1a45539c406109b27d4f089f7a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/347fa7a26f3eb6085418a26cef18f133635f7a9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/347fa7a26f3eb6085418a26cef18f133635f7a9f", "html_url": "https://github.com/rust-lang/rust/commit/347fa7a26f3eb6085418a26cef18f133635f7a9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/347fa7a26f3eb6085418a26cef18f133635f7a9f/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e187f8871e3d553181c9d2d4ac111197a139ca0d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e187f8871e3d553181c9d2d4ac111197a139ca0d", "html_url": "https://github.com/rust-lang/rust/commit/e187f8871e3d553181c9d2d4ac111197a139ca0d"}], "stats": {"total": 264, "additions": 113, "deletions": 151}, "files": [{"sha": "3cb6ad10e72b8e43cad38a6cb60e2427f6fa03b4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -15,7 +15,7 @@ use rustc_attr as attr;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap, FxIndexSet, IndexEntry};\n use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LOCAL_CRATE};\n+use rustc_hir::def_id::{DefId, DefIdMap, DefIdSet, LocalDefId, LOCAL_CRATE};\n use rustc_hir::PredicateOrigin;\n use rustc_hir_analysis::hir_ty_to_ty;\n use rustc_infer::infer::region_constraints::{Constraint, RegionConstraintData};\n@@ -116,7 +116,8 @@ pub(crate) fn clean_doc_module<'tcx>(doc: &DocModule<'tcx>, cx: &mut DocContext<\n         }\n     });\n \n-    Item::from_hir_id_and_parts(doc.id, Some(doc.name), ModuleItem(Module { items, span }), cx)\n+    let kind = ModuleItem(Module { items, span });\n+    Item::from_def_id_and_parts(doc.def_id.to_def_id(), Some(doc.name), kind, cx)\n }\n \n fn clean_generic_bound<'tcx>(\n@@ -2067,12 +2068,12 @@ struct OneLevelVisitor<'hir> {\n     map: rustc_middle::hir::map::Map<'hir>,\n     item: Option<&'hir hir::Item<'hir>>,\n     looking_for: Ident,\n-    target_hir_id: hir::HirId,\n+    target_def_id: LocalDefId,\n }\n \n impl<'hir> OneLevelVisitor<'hir> {\n-    fn new(map: rustc_middle::hir::map::Map<'hir>, target_hir_id: hir::HirId) -> Self {\n-        Self { map, item: None, looking_for: Ident::empty(), target_hir_id }\n+    fn new(map: rustc_middle::hir::map::Map<'hir>, target_def_id: LocalDefId) -> Self {\n+        Self { map, item: None, looking_for: Ident::empty(), target_def_id }\n     }\n \n     fn reset(&mut self, looking_for: Ident) {\n@@ -2092,7 +2093,7 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n         if self.item.is_none()\n             && item.ident == self.looking_for\n             && matches!(item.kind, hir::ItemKind::Use(_, _))\n-            || item.hir_id() == self.target_hir_id\n+            || item.owner_id.def_id == self.target_def_id\n         {\n             self.item = Some(item);\n         }\n@@ -2106,11 +2107,11 @@ impl<'hir> hir::intravisit::Visitor<'hir> for OneLevelVisitor<'hir> {\n fn get_all_import_attributes<'hir>(\n     mut item: &hir::Item<'hir>,\n     tcx: TyCtxt<'hir>,\n-    target_hir_id: hir::HirId,\n+    target_def_id: LocalDefId,\n     attributes: &mut Vec<ast::Attribute>,\n ) {\n     let hir_map = tcx.hir();\n-    let mut visitor = OneLevelVisitor::new(hir_map, target_hir_id);\n+    let mut visitor = OneLevelVisitor::new(hir_map, target_def_id);\n     // If the item is an import and has at least a path with two parts, we go into it.\n     while let hir::ItemKind::Use(path, _) = item.kind &&\n         path.segments.len() > 1 &&\n@@ -2138,7 +2139,7 @@ fn clean_maybe_renamed_item<'tcx>(\n     cx: &mut DocContext<'tcx>,\n     item: &hir::Item<'tcx>,\n     renamed: Option<Symbol>,\n-    import_id: Option<hir::HirId>,\n+    import_id: Option<LocalDefId>,\n ) -> Vec<Item> {\n     use hir::ItemKind;\n \n@@ -2183,7 +2184,7 @@ fn clean_maybe_renamed_item<'tcx>(\n                 generics: clean_generics(generics, cx),\n                 fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n-            ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n+            ItemKind::Impl(impl_) => return clean_impl(impl_, item.owner_id.def_id, cx),\n             // proc macros can have a name set by attributes\n             ItemKind::Fn(ref sig, generics, body_id) => {\n                 clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n@@ -2218,10 +2219,10 @@ fn clean_maybe_renamed_item<'tcx>(\n \n         let mut extra_attrs = Vec::new();\n         if let Some(hir::Node::Item(use_node)) =\n-            import_id.and_then(|hir_id| cx.tcx.hir().find(hir_id))\n+            import_id.and_then(|def_id| cx.tcx.hir().find_by_def_id(def_id))\n         {\n             // We get all the various imports' attributes.\n-            get_all_import_attributes(use_node, cx.tcx, item.hir_id(), &mut extra_attrs);\n+            get_all_import_attributes(use_node, cx.tcx, item.owner_id.def_id, &mut extra_attrs);\n         }\n \n         if !extra_attrs.is_empty() {\n@@ -2244,12 +2245,12 @@ fn clean_maybe_renamed_item<'tcx>(\n \n fn clean_variant<'tcx>(variant: &hir::Variant<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n     let kind = VariantItem(clean_variant_data(&variant.data, &variant.disr_expr, cx));\n-    Item::from_hir_id_and_parts(variant.hir_id, Some(variant.ident.name), kind, cx)\n+    Item::from_def_id_and_parts(variant.def_id.to_def_id(), Some(variant.ident.name), kind, cx)\n }\n \n fn clean_impl<'tcx>(\n     impl_: &hir::Impl<'tcx>,\n-    hir_id: hir::HirId,\n+    def_id: LocalDefId,\n     cx: &mut DocContext<'tcx>,\n ) -> Vec<Item> {\n     let tcx = cx.tcx;\n@@ -2260,7 +2261,6 @@ fn clean_impl<'tcx>(\n         .iter()\n         .map(|ii| clean_impl_item(tcx.hir().impl_item(ii.id), cx))\n         .collect::<Vec<_>>();\n-    let def_id = tcx.hir().local_def_id(hir_id);\n \n     // If this impl block is an implementation of the Deref trait, then we\n     // need to try inlining the target's inherent impl blocks as well.\n@@ -2289,7 +2289,7 @@ fn clean_impl<'tcx>(\n                 ImplKind::Normal\n             },\n         }));\n-        Item::from_hir_id_and_parts(hir_id, None, kind, cx)\n+        Item::from_def_id_and_parts(def_id.to_def_id(), None, kind, cx)\n     };\n     if let Some(type_alias) = type_alias {\n         ret.push(make_item(trait_.clone(), type_alias, items.clone()));\n@@ -2510,8 +2510,8 @@ fn clean_maybe_renamed_foreign_item<'tcx>(\n             hir::ForeignItemKind::Type => ForeignTypeItem,\n         };\n \n-        Item::from_hir_id_and_parts(\n-            item.hir_id(),\n+        Item::from_def_id_and_parts(\n+            item.owner_id.def_id.to_def_id(),\n             Some(renamed.unwrap_or(item.ident.name)),\n             kind,\n             cx,"}, {"sha": "3b258c4d919f84e385c841bdcec428fd8ba0a9ec", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 15, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -439,17 +439,6 @@ impl Item {\n         self.attrs.doc_value()\n     }\n \n-    /// Convenience wrapper around [`Self::from_def_id_and_parts`] which converts\n-    /// `hir_id` to a [`DefId`]\n-    pub(crate) fn from_hir_id_and_parts(\n-        hir_id: hir::HirId,\n-        name: Option<Symbol>,\n-        kind: ItemKind,\n-        cx: &mut DocContext<'_>,\n-    ) -> Item {\n-        Item::from_def_id_and_parts(cx.tcx.hir().local_def_id(hir_id).to_def_id(), name, kind, cx)\n-    }\n-\n     pub(crate) fn from_def_id_and_parts(\n         def_id: DefId,\n         name: Option<Symbol>,\n@@ -2416,10 +2405,7 @@ impl ConstantKind {\n \n     pub(crate) fn is_literal(&self, tcx: TyCtxt<'_>) -> bool {\n         match *self {\n-            ConstantKind::TyConst { .. } => false,\n-            ConstantKind::Extern { def_id } => def_id.as_local().map_or(false, |def_id| {\n-                is_literal_expr(tcx, tcx.hir().local_def_id_to_hir_id(def_id))\n-            }),\n+            ConstantKind::TyConst { .. } | ConstantKind::Extern { .. } => false,\n             ConstantKind::Local { body, .. } | ConstantKind::Anonymous { body } => {\n                 is_literal_expr(tcx, body.hir_id)\n             }"}, {"sha": "37a1005cba1fc82a97ef7690805aac5a121c5a3b", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 12, "deletions": 14, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -2,10 +2,8 @@ use rustc_ast as ast;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::Lrc;\n use rustc_errors::{ColorConfig, ErrorGuaranteed, FatalError};\n-use rustc_hir as hir;\n-use rustc_hir::def_id::LOCAL_CRATE;\n-use rustc_hir::intravisit;\n-use rustc_hir::{HirId, CRATE_HIR_ID};\n+use rustc_hir::def_id::{LocalDefId, CRATE_DEF_ID, LOCAL_CRATE};\n+use rustc_hir::{self as hir, intravisit, CRATE_HIR_ID};\n use rustc_interface::interface;\n use rustc_middle::hir::map::Map;\n use rustc_middle::hir::nested_filter;\n@@ -140,7 +138,7 @@ pub(crate) fn run(options: RustdocOptions) -> Result<(), ErrorGuaranteed> {\n                     };\n                     hir_collector.visit_testable(\n                         \"\".to_string(),\n-                        CRATE_HIR_ID,\n+                        CRATE_DEF_ID,\n                         tcx.hir().span(CRATE_HIR_ID),\n                         |this| tcx.hir().walk_toplevel_module(this),\n                     );\n@@ -1214,11 +1212,11 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n     fn visit_testable<F: FnOnce(&mut Self)>(\n         &mut self,\n         name: String,\n-        hir_id: HirId,\n+        def_id: LocalDefId,\n         sp: Span,\n         nested: F,\n     ) {\n-        let ast_attrs = self.tcx.hir().attrs(hir_id);\n+        let ast_attrs = self.tcx.hir().attrs(self.tcx.hir().local_def_id_to_hir_id(def_id));\n         if let Some(ref cfg) = ast_attrs.cfg(self.tcx, &FxHashSet::default()) {\n             if !cfg.matches(&self.sess.parse_sess, Some(self.tcx.features())) {\n                 return;\n@@ -1247,7 +1245,7 @@ impl<'a, 'hir, 'tcx> HirCollector<'a, 'hir, 'tcx> {\n                 self.collector.enable_per_target_ignores,\n                 Some(&crate::html::markdown::ExtraInfo::new(\n                     self.tcx,\n-                    hir_id,\n+                    def_id.to_def_id(),\n                     span_of_attrs(&attrs).unwrap_or(sp),\n                 )),\n             );\n@@ -1276,37 +1274,37 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             _ => item.ident.to_string(),\n         };\n \n-        self.visit_testable(name, item.hir_id(), item.span, |this| {\n+        self.visit_testable(name, item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_item(this, item);\n         });\n     }\n \n     fn visit_trait_item(&mut self, item: &'hir hir::TraitItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_trait_item(this, item);\n         });\n     }\n \n     fn visit_impl_item(&mut self, item: &'hir hir::ImplItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_impl_item(this, item);\n         });\n     }\n \n     fn visit_foreign_item(&mut self, item: &'hir hir::ForeignItem<'_>) {\n-        self.visit_testable(item.ident.to_string(), item.hir_id(), item.span, |this| {\n+        self.visit_testable(item.ident.to_string(), item.owner_id.def_id, item.span, |this| {\n             intravisit::walk_foreign_item(this, item);\n         });\n     }\n \n     fn visit_variant(&mut self, v: &'hir hir::Variant<'_>) {\n-        self.visit_testable(v.ident.to_string(), v.hir_id, v.span, |this| {\n+        self.visit_testable(v.ident.to_string(), v.def_id, v.span, |this| {\n             intravisit::walk_variant(this, v);\n         });\n     }\n \n     fn visit_field_def(&mut self, f: &'hir hir::FieldDef<'_>) {\n-        self.visit_testable(f.ident.to_string(), f.hir_id, f.span, |this| {\n+        self.visit_testable(f.ident.to_string(), f.def_id, f.span, |this| {\n             intravisit::walk_field_def(this, f);\n         });\n     }"}, {"sha": "33bff01b64fed79601e2a366a163bae6d5882b00", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 12, "deletions": 32, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -27,7 +27,6 @@\n \n use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::HirId;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::edition::Edition;\n use rustc_span::{Span, Symbol};\n@@ -784,45 +783,26 @@ pub(crate) fn find_testable_code<T: doctest::Tester>(\n }\n \n pub(crate) struct ExtraInfo<'tcx> {\n-    id: ExtraInfoId,\n+    def_id: DefId,\n     sp: Span,\n     tcx: TyCtxt<'tcx>,\n }\n \n-enum ExtraInfoId {\n-    Hir(HirId),\n-    Def(DefId),\n-}\n-\n impl<'tcx> ExtraInfo<'tcx> {\n-    pub(crate) fn new(tcx: TyCtxt<'tcx>, hir_id: HirId, sp: Span) -> ExtraInfo<'tcx> {\n-        ExtraInfo { id: ExtraInfoId::Hir(hir_id), sp, tcx }\n-    }\n-\n-    pub(crate) fn new_did(tcx: TyCtxt<'tcx>, did: DefId, sp: Span) -> ExtraInfo<'tcx> {\n-        ExtraInfo { id: ExtraInfoId::Def(did), sp, tcx }\n+    pub(crate) fn new(tcx: TyCtxt<'tcx>, def_id: DefId, sp: Span) -> ExtraInfo<'tcx> {\n+        ExtraInfo { def_id, sp, tcx }\n     }\n \n     fn error_invalid_codeblock_attr(&self, msg: &str, help: &str) {\n-        let hir_id = match self.id {\n-            ExtraInfoId::Hir(hir_id) => hir_id,\n-            ExtraInfoId::Def(item_did) => {\n-                match item_did.as_local() {\n-                    Some(item_did) => self.tcx.hir().local_def_id_to_hir_id(item_did),\n-                    None => {\n-                        // If non-local, no need to check anything.\n-                        return;\n-                    }\n-                }\n-            }\n-        };\n-        self.tcx.struct_span_lint_hir(\n-            crate::lint::INVALID_CODEBLOCK_ATTRIBUTES,\n-            hir_id,\n-            self.sp,\n-            msg,\n-            |lint| lint.help(help),\n-        );\n+        if let Some(def_id) = self.def_id.as_local() {\n+            self.tcx.struct_span_lint_hir(\n+                crate::lint::INVALID_CODEBLOCK_ATTRIBUTES,\n+                self.tcx.hir().local_def_id_to_hir_id(def_id),\n+                self.sp,\n+                msg,\n+                |lint| lint.help(help),\n+            );\n+        }\n     }\n }\n "}, {"sha": "0b22f943dab99db214553c2696f25beeacc8b0c0", "filename": "src/librustdoc/passes/calculate_doc_coverage.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcalculate_doc_coverage.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -216,13 +216,7 @@ impl<'a, 'b> DocVisitor for CoverageCalculator<'a, 'b> {\n                 );\n \n                 let has_doc_example = tests.found_tests != 0;\n-                // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n-                // would presumably panic if a fake `DefIndex` were passed.\n-                let hir_id = self\n-                    .ctx\n-                    .tcx\n-                    .hir()\n-                    .local_def_id_to_hir_id(i.item_id.expect_def_id().expect_local());\n+                let hir_id = DocContext::as_local_hir_id(self.ctx.tcx, i.item_id).unwrap();\n                 let (level, source) = self.ctx.tcx.lint_level_at_node(MISSING_DOCS, hir_id);\n \n                 // In case we have:"}, {"sha": "f3961d5017ef4b99c80b7831446733a60c0c1648", "filename": "src/librustdoc/passes/check_doc_test_visibility.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcheck_doc_test_visibility.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -14,8 +14,8 @@ use crate::visit::DocVisitor;\n use crate::visit_ast::inherits_doc_hidden;\n use rustc_hir as hir;\n use rustc_middle::lint::LintLevelSource;\n+use rustc_middle::ty::DefIdTree;\n use rustc_session::lint;\n-use rustc_span::symbol::sym;\n \n pub(crate) const CHECK_DOC_TEST_VISIBILITY: Pass = Pass {\n     name: \"check_doc_test_visibility\",\n@@ -79,11 +79,11 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n \n     // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n     // would presumably panic if a fake `DefIndex` were passed.\n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(item.item_id.expect_def_id().expect_local());\n+    let def_id = item.item_id.expect_def_id().expect_local();\n \n     // check if parent is trait impl\n-    if let Some(parent_hir_id) = cx.tcx.hir().opt_parent_id(hir_id) {\n-        if let Some(parent_node) = cx.tcx.hir().find(parent_hir_id) {\n+    if let Some(parent_def_id) = cx.tcx.opt_local_parent(def_id) {\n+        if let Some(parent_node) = cx.tcx.hir().find_by_def_id(parent_def_id) {\n             if matches!(\n                 parent_node,\n                 hir::Node::Item(hir::Item {\n@@ -96,13 +96,16 @@ pub(crate) fn should_have_doc_example(cx: &DocContext<'_>, item: &clean::Item) -\n         }\n     }\n \n-    if cx.tcx.hir().attrs(hir_id).lists(sym::doc).has_word(sym::hidden)\n-        || inherits_doc_hidden(cx.tcx, hir_id)\n-        || cx.tcx.hir().span(hir_id).in_derive_expansion()\n+    if cx.tcx.is_doc_hidden(def_id.to_def_id())\n+        || inherits_doc_hidden(cx.tcx, def_id)\n+        || cx.tcx.def_span(def_id.to_def_id()).in_derive_expansion()\n     {\n         return false;\n     }\n-    let (level, source) = cx.tcx.lint_level_at_node(crate::lint::MISSING_DOC_CODE_EXAMPLES, hir_id);\n+    let (level, source) = cx.tcx.lint_level_at_node(\n+        crate::lint::MISSING_DOC_CODE_EXAMPLES,\n+        cx.tcx.hir().local_def_id_to_hir_id(def_id),\n+    );\n     level != lint::Level::Allow || matches!(source, LintLevelSource::Default)\n }\n "}, {"sha": "e42921c080945f4b6c6a9df05d02ca0d76e409a8", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -1194,14 +1194,9 @@ impl LinkCollector<'_, '_> {\n             }\n \n         // item can be non-local e.g. when using #[doc(primitive = \"pointer\")]\n-        if let Some((src_id, dst_id)) = id\n-            .as_local()\n-            // The `expect_def_id()` should be okay because `local_def_id_to_hir_id`\n-            // would presumably panic if a fake `DefIndex` were passed.\n-            .and_then(|dst_id| {\n-                item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n-            })\n-        {\n+        if let Some((src_id, dst_id)) = id.as_local().and_then(|dst_id| {\n+            item.item_id.expect_def_id().as_local().map(|src_id| (src_id, dst_id))\n+        }) {\n             if self.cx.tcx.effective_visibilities(()).is_exported(src_id)\n                 && !self.cx.tcx.effective_visibilities(()).is_exported(dst_id)\n             {"}, {"sha": "03be5e799716706d2cccda938dff8a90d8154246", "filename": "src/librustdoc/passes/lint/check_code_block_syntax.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Flint%2Fcheck_code_block_syntax.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -19,8 +19,7 @@ use crate::passes::source_span_for_markdown_range;\n pub(crate) fn visit_item(cx: &DocContext<'_>, item: &clean::Item) {\n     if let Some(dox) = &item.attrs.collapsed_doc_value() {\n         let sp = item.attr_span(cx.tcx);\n-        let extra =\n-            crate::html::markdown::ExtraInfo::new_did(cx.tcx, item.item_id.expect_def_id(), sp);\n+        let extra = crate::html::markdown::ExtraInfo::new(cx.tcx, item.item_id.expect_def_id(), sp);\n         for code_block in markdown::rust_code_blocks(dox, &extra) {\n             check_rust_syntax(cx, item, dox, code_block);\n         }\n@@ -73,7 +72,6 @@ fn check_rust_syntax(\n             return;\n         };\n \n-    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n     let empty_block = code_block.lang_string == Default::default() && code_block.is_fenced;\n     let is_ignore = code_block.lang_string.ignore != markdown::Ignore::None;\n \n@@ -93,6 +91,7 @@ fn check_rust_syntax(\n     // Finally build and emit the completed diagnostic.\n     // All points of divergence have been handled earlier so this can be\n     // done the same way whether the span is precise or not.\n+    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_id);\n     cx.tcx.struct_span_lint_hir(crate::lint::INVALID_RUST_CODEBLOCKS, hir_id, sp, msg, |lint| {\n         let explanation = if is_ignore {\n             \"`ignore` code blocks require valid Rust code for syntax highlighting; \\"}, {"sha": "a4bc486900b3e92e88e6e3262a2067f212b67de2", "filename": "src/librustdoc/passes/propagate_doc_cfg.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fpropagate_doc_cfg.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -9,6 +9,7 @@ use crate::fold::DocFolder;\n use crate::passes::Pass;\n \n use rustc_hir::def_id::LocalDefId;\n+use rustc_middle::ty::DefIdTree;\n \n pub(crate) const PROPAGATE_DOC_CFG: Pass = Pass {\n     name: \"propagate-doc-cfg\",\n@@ -41,24 +42,22 @@ impl<'a, 'tcx> CfgPropagator<'a, 'tcx> {\n         let Some(def_id) = item.item_id.as_def_id().and_then(|def_id| def_id.as_local())\n             else { return };\n \n-        let hir = self.cx.tcx.hir();\n-        let hir_id = hir.local_def_id_to_hir_id(def_id);\n-\n         if check_parent {\n-            let expected_parent = hir.get_parent_item(hir_id);\n+            let expected_parent = self.cx.tcx.opt_local_parent(def_id);\n             // If parents are different, it means that `item` is a reexport and we need\n             // to compute the actual `cfg` by iterating through its \"real\" parents.\n-            if self.parent == Some(expected_parent.def_id) {\n+            if self.parent.is_some() && self.parent == expected_parent {\n                 return;\n             }\n         }\n \n         let mut attrs = Vec::new();\n-        for (parent_hir_id, _) in hir.parent_iter(hir_id) {\n-            if let Some(def_id) = hir.opt_local_def_id(parent_hir_id) {\n-                attrs.extend_from_slice(load_attrs(self.cx, def_id.to_def_id()));\n-            }\n+        let mut next_def_id = def_id;\n+        while let Some(parent_def_id) = self.cx.tcx.opt_local_parent(next_def_id) {\n+            attrs.extend_from_slice(load_attrs(self.cx, parent_def_id.to_def_id()));\n+            next_def_id = parent_def_id;\n         }\n+\n         let (_, cfg) = merge_attrs(self.cx, None, item.attrs.other_attrs.as_slice(), Some(&attrs));\n         item.cfg = cfg;\n     }"}, {"sha": "a89d6fa83983d685e8a6baf94d63327320beca71", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 45, "deletions": 37, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/347fa7a26f3eb6085418a26cef18f133635f7a9f/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=347fa7a26f3eb6085418a26cef18f133635f7a9f", "patch": "@@ -4,9 +4,9 @@\n use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n-use rustc_hir::def_id::{DefId, DefIdMap};\n-use rustc_hir::{HirIdSet, Node, CRATE_HIR_ID};\n-use rustc_middle::ty::TyCtxt;\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LocalDefIdSet};\n+use rustc_hir::{Node, CRATE_HIR_ID};\n+use rustc_middle::ty::{DefIdTree, TyCtxt};\n use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_span::Span;\n@@ -23,19 +23,26 @@ pub(crate) struct Module<'hir> {\n     pub(crate) name: Symbol,\n     pub(crate) where_inner: Span,\n     pub(crate) mods: Vec<Module<'hir>>,\n-    pub(crate) id: hir::HirId,\n+    pub(crate) def_id: LocalDefId,\n     // (item, renamed, import_id)\n-    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<hir::HirId>)>,\n+    pub(crate) items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>, Option<LocalDefId>)>,\n     pub(crate) foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'_> {\n-    pub(crate) fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Self {\n-        Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n+    pub(crate) fn new(name: Symbol, def_id: LocalDefId, where_inner: Span) -> Self {\n+        Module {\n+            name,\n+            def_id,\n+            where_inner,\n+            mods: Vec::new(),\n+            items: Vec::new(),\n+            foreigns: Vec::new(),\n+        }\n     }\n \n     pub(crate) fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {\n-        tcx.hir().span(self.id)\n+        tcx.def_span(self.def_id)\n     }\n }\n \n@@ -46,10 +53,10 @@ fn def_id_to_path(tcx: TyCtxt<'_>, did: DefId) -> Vec<Symbol> {\n     std::iter::once(crate_name).chain(relative).collect()\n }\n \n-pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool {\n-    while let Some(id) = tcx.hir().get_enclosing_scope(node) {\n+pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: LocalDefId) -> bool {\n+    while let Some(id) = tcx.opt_local_parent(node) {\n         node = id;\n-        if tcx.hir().attrs(node).lists(sym::doc).has_word(sym::hidden) {\n+        if tcx.is_doc_hidden(node.to_def_id()) {\n             return true;\n         }\n     }\n@@ -61,7 +68,7 @@ pub(crate) fn inherits_doc_hidden(tcx: TyCtxt<'_>, mut node: hir::HirId) -> bool\n \n pub(crate) struct RustdocVisitor<'a, 'tcx> {\n     cx: &'a mut core::DocContext<'tcx>,\n-    view_item_stack: HirIdSet,\n+    view_item_stack: LocalDefIdSet,\n     inlining: bool,\n     /// Are the current module and all of its parents public?\n     inside_public_path: bool,\n@@ -71,8 +78,8 @@ pub(crate) struct RustdocVisitor<'a, 'tcx> {\n impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     pub(crate) fn new(cx: &'a mut core::DocContext<'tcx>) -> RustdocVisitor<'a, 'tcx> {\n         // If the root is re-exported, terminate all recursion.\n-        let mut stack = HirIdSet::default();\n-        stack.insert(hir::CRATE_HIR_ID);\n+        let mut stack = LocalDefIdSet::default();\n+        stack.insert(CRATE_DEF_ID);\n         RustdocVisitor {\n             cx,\n             view_item_stack: stack,\n@@ -89,7 +96,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub(crate) fn visit(mut self) -> Module<'tcx> {\n         let mut top_level_module = self.visit_mod_contents(\n-            hir::CRATE_HIR_ID,\n+            CRATE_DEF_ID,\n             self.cx.tcx.hir().root_module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n             None,\n@@ -152,16 +159,15 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     fn visit_mod_contents(\n         &mut self,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         m: &'tcx hir::Mod<'tcx>,\n         name: Symbol,\n-        parent_id: Option<hir::HirId>,\n+        parent_id: Option<LocalDefId>,\n     ) -> Module<'tcx> {\n-        let mut om = Module::new(name, id, m.spans.inner_span);\n-        let def_id = self.cx.tcx.hir().local_def_id(id).to_def_id();\n+        let mut om = Module::new(name, def_id, m.spans.inner_span);\n         // Keep track of if there were any private modules in the path.\n         let orig_inside_public_path = self.inside_public_path;\n-        self.inside_public_path &= self.cx.tcx.visibility(def_id).is_public();\n+        self.inside_public_path &= self.cx.tcx.local_visibility(def_id).is_public();\n         for &i in m.item_ids {\n             let item = self.cx.tcx.hir().item(i);\n             if matches!(item.kind, hir::ItemKind::Use(_, hir::UseKind::Glob)) {\n@@ -193,7 +199,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     /// Returns `true` if the target has been inlined.\n     fn maybe_inline_local(\n         &mut self,\n-        id: hir::HirId,\n+        def_id: LocalDefId,\n         res: Res,\n         renamed: Option<Symbol>,\n         glob: bool,\n@@ -211,10 +217,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         };\n \n-        let use_attrs = tcx.hir().attrs(id);\n+        let use_attrs = tcx.hir().attrs(tcx.hir().local_def_id_to_hir_id(def_id));\n         // Don't inline `doc(hidden)` imports so they can be stripped at a later stage.\n         let is_no_inline = use_attrs.lists(sym::doc).has_word(sym::no_inline)\n-            || use_attrs.lists(sym::doc).has_word(sym::hidden);\n+            || tcx.is_doc_hidden(def_id.to_def_id());\n \n         // For cross-crate impl inlining we need to know whether items are\n         // reachable in documentation -- a previously unreachable item can be\n@@ -225,37 +231,39 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             return false;\n         }\n \n-        let res_hir_id = match res_did.as_local() {\n-            Some(n) => tcx.hir().local_def_id_to_hir_id(n),\n-            None => return false,\n+        let Some(res_did) = res_did.as_local() else {\n+            return false;\n         };\n \n-        let is_private =\n-            !self.cx.cache.effective_visibilities.is_directly_public(self.cx.tcx, res_did);\n-        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_hir_id);\n+        let is_private = !self\n+            .cx\n+            .cache\n+            .effective_visibilities\n+            .is_directly_public(self.cx.tcx, res_did.to_def_id());\n+        let is_hidden = inherits_doc_hidden(self.cx.tcx, res_did);\n \n         // Only inline if requested or if the item would otherwise be stripped.\n         if (!please_inline && !is_private && !is_hidden) || is_no_inline {\n             return false;\n         }\n \n-        if !self.view_item_stack.insert(res_hir_id) {\n+        if !self.view_item_stack.insert(res_did) {\n             return false;\n         }\n \n-        let ret = match tcx.hir().get(res_hir_id) {\n+        let ret = match tcx.hir().get_by_def_id(res_did) {\n             Node::Item(&hir::Item { kind: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for &i in m.item_ids {\n                     let i = self.cx.tcx.hir().item(i);\n-                    self.visit_item(i, None, om, Some(id));\n+                    self.visit_item(i, None, om, Some(def_id));\n                 }\n                 self.inlining = prev;\n                 true\n             }\n             Node::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n-                self.visit_item(it, renamed, om, Some(id));\n+                self.visit_item(it, renamed, om, Some(def_id));\n                 self.inlining = prev;\n                 true\n             }\n@@ -267,7 +275,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             }\n             _ => false,\n         };\n-        self.view_item_stack.remove(&res_hir_id);\n+        self.view_item_stack.remove(&res_did);\n         ret\n     }\n \n@@ -276,7 +284,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         item: &'tcx hir::Item<'_>,\n         renamed: Option<Symbol>,\n         om: &mut Module<'tcx>,\n-        parent_id: Option<hir::HirId>,\n+        parent_id: Option<LocalDefId>,\n     ) {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n@@ -321,7 +329,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                         let is_glob = kind == hir::UseKind::Glob;\n                         let ident = if is_glob { None } else { Some(name) };\n                         if self.maybe_inline_local(\n-                            item.hir_id(),\n+                            item.owner_id.def_id,\n                             res,\n                             ident,\n                             is_glob,\n@@ -356,7 +364,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             hir::ItemKind::Mod(ref m) => {\n-                om.mods.push(self.visit_mod_contents(item.hir_id(), m, name, parent_id));\n+                om.mods.push(self.visit_mod_contents(item.owner_id.def_id, m, name, parent_id));\n             }\n             hir::ItemKind::Fn(..)\n             | hir::ItemKind::ExternCrate(..)"}]}