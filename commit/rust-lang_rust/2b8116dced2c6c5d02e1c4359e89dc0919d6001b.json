{"sha": "2b8116dced2c6c5d02e1c4359e89dc0919d6001b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiODExNmRjZWQyYzZjNWQwMmUxYzQzNTllODlkYzA5MTlkNjAwMWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T16:49:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-09-08T16:49:39Z"}, "message": "Auto merge of #63994 - Centril:refactor-qualify-consts, r=spastorino,oli-obk\n\nRefactor the `MirPass for QualifyAndPromoteConstants`\n\nThis is an accumulation of drive-by commits while working on `Vec::new` as a stable `const fn`.\nThe PR is probably easiest read commit-by-commit.\n\nr? @oli-obk\n\ncc @eddyb @ecstatic-morse -- your two PRs https://github.com/rust-lang/rust/pull/63812 and https://github.com/rust-lang/rust/pull/63860 respectively will conflict with this a tiny bit but it should be trivial to reintegrate your changes atop of this.", "tree": {"sha": "21427057eeb3a6284f111671edb44e6fc18da9ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/21427057eeb3a6284f111671edb44e6fc18da9ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b8116dced2c6c5d02e1c4359e89dc0919d6001b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8116dced2c6c5d02e1c4359e89dc0919d6001b", "html_url": "https://github.com/rust-lang/rust/commit/2b8116dced2c6c5d02e1c4359e89dc0919d6001b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b8116dced2c6c5d02e1c4359e89dc0919d6001b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c0931e168671d7536b58563dc3664c948a8dcd3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c0931e168671d7536b58563dc3664c948a8dcd3", "html_url": "https://github.com/rust-lang/rust/commit/2c0931e168671d7536b58563dc3664c948a8dcd3"}, {"sha": "0a8a3dd88a1216e7487b8e39179fbac16d07bafe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a8a3dd88a1216e7487b8e39179fbac16d07bafe", "html_url": "https://github.com/rust-lang/rust/commit/0a8a3dd88a1216e7487b8e39179fbac16d07bafe"}], "stats": {"total": 239, "additions": 113, "deletions": 126}, "files": [{"sha": "32b49ee942300290d29b3a6b2830cc918f74b2f4", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 113, "deletions": 126, "changes": 239, "blob_url": "https://github.com/rust-lang/rust/blob/2b8116dced2c6c5d02e1c4359e89dc0919d6001b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b8116dced2c6c5d02e1c4359e89dc0919d6001b/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=2b8116dced2c6c5d02e1c4359e89dc0919d6001b", "patch": "@@ -25,11 +25,13 @@ use syntax::feature_gate::{emit_feature_err, GateIssue};\n use syntax::symbol::sym;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::borrow::Cow;\n use std::cell::Cell;\n use std::fmt;\n use std::ops::{Deref, Index, IndexMut};\n use std::usize;\n \n+use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n \n@@ -1596,51 +1598,24 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n         }\n \n         let def_id = src.def_id();\n-        let id = tcx.hir().as_local_hir_id(def_id).unwrap();\n-        let mut const_promoted_temps = None;\n-        let mode = match tcx.hir().body_owner_kind(id) {\n-            hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n-            hir::BodyOwnerKind::Fn => {\n-                if tcx.is_const_fn(def_id) {\n-                    Mode::ConstFn\n-                } else {\n-                    Mode::NonConstFn\n-                }\n-            }\n-            hir::BodyOwnerKind::Const => {\n-                const_promoted_temps = Some(tcx.mir_const_qualif(def_id).1);\n-                Mode::Const\n-            }\n-            hir::BodyOwnerKind::Static(hir::MutImmutable) => Mode::Static,\n-            hir::BodyOwnerKind::Static(hir::MutMutable) => Mode::StaticMut,\n-        };\n+        let hir_id = tcx.hir().as_local_hir_id(def_id).unwrap();\n+\n+        let mode = determine_mode(tcx, hir_id, def_id);\n \n         debug!(\"run_pass: mode={:?}\", mode);\n-        if mode == Mode::NonConstFn || mode == Mode::ConstFn {\n+        if let Mode::NonConstFn | Mode::ConstFn = mode {\n             // This is ugly because Checker holds onto mir,\n             // which can't be mutated until its scope ends.\n             let (temps, candidates) = {\n                 let mut checker = Checker::new(tcx, def_id, body, mode);\n-                if mode == Mode::ConstFn {\n+                if let Mode::ConstFn = mode {\n                     if tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n                         checker.check_const();\n                     } else if tcx.is_min_const_fn(def_id) {\n-                        // enforce `min_const_fn` for stable const fns\n+                        // Enforce `min_const_fn` for stable `const fn`s.\n                         use super::qualify_min_const_fn::is_min_const_fn;\n                         if let Err((span, err)) = is_min_const_fn(tcx, def_id, body) {\n-                            let mut diag = struct_span_err!(\n-                                tcx.sess,\n-                                span,\n-                                E0723,\n-                                \"{}\",\n-                                err,\n-                            );\n-                            diag.note(\"for more information, see issue \\\n-                                       https://github.com/rust-lang/rust/issues/57563\");\n-                            diag.help(\n-                                \"add `#![feature(const_fn)]` to the crate attributes to enable\",\n-                            );\n-                            diag.emit();\n+                            error_min_const_fn_violation(tcx, span, err);\n                         } else {\n                             // this should not produce any errors, but better safe than sorry\n                             // FIXME(#53819)\n@@ -1664,107 +1639,119 @@ impl<'tcx> MirPass<'tcx> for QualifyAndPromoteConstants<'tcx> {\n                 promote_consts::promote_candidates(def_id, body, tcx, temps, candidates)\n             );\n         } else {\n-            if !body.control_flow_destroyed.is_empty() {\n-                let mut locals = body.vars_iter();\n-                if let Some(local) = locals.next() {\n-                    let span = body.local_decls[local].source_info.span;\n-                    let mut error = tcx.sess.struct_span_err(\n-                        span,\n-                        &format!(\n-                            \"new features like let bindings are not permitted in {}s \\\n-                            which also use short circuiting operators\",\n-                            mode,\n-                        ),\n-                    );\n-                    for (span, kind) in body.control_flow_destroyed.iter() {\n-                        error.span_note(\n-                            *span,\n-                            &format!(\"use of {} here does not actually short circuit due to \\\n-                            the const evaluator presently not being able to do control flow. \\\n-                            See https://github.com/rust-lang/rust/issues/49146 for more \\\n-                            information.\", kind),\n-                        );\n-                    }\n-                    for local in locals {\n-                        let span = body.local_decls[local].source_info.span;\n-                        error.span_note(\n-                            span,\n-                            \"more locals defined here\",\n-                        );\n-                    }\n-                    error.emit();\n-                }\n-            }\n-            let promoted_temps = if mode == Mode::Const {\n-                // Already computed by `mir_const_qualif`.\n-                const_promoted_temps.unwrap()\n-            } else {\n-                Checker::new(tcx, def_id, body, mode).check_const().1\n+            check_short_circuiting_in_const_local(tcx, body, mode);\n+\n+            let promoted_temps = match mode {\n+                Mode::Const => tcx.mir_const_qualif(def_id).1,\n+                _ => Checker::new(tcx, def_id, body, mode).check_const().1,\n             };\n+            remove_drop_and_storage_dead_on_promoted_locals(body, promoted_temps);\n+        }\n \n-            // In `const` and `static` everything without `StorageDead`\n-            // is `'static`, we don't have to create promoted MIR fragments,\n-            // just remove `Drop` and `StorageDead` on \"promoted\" locals.\n-            debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n-            for block in body.basic_blocks_mut() {\n-                block.statements.retain(|statement| {\n-                    match statement.kind {\n-                        StatementKind::StorageDead(index) => {\n-                            !promoted_temps.contains(index)\n-                        }\n-                        _ => true\n-                    }\n-                });\n-                let terminator = block.terminator_mut();\n-                match terminator.kind {\n-                    TerminatorKind::Drop {\n-                        location: Place {\n-                            base: PlaceBase::Local(index),\n-                            projection: None,\n-                        },\n-                        target,\n-                        ..\n-                    } => {\n-                        if promoted_temps.contains(index) {\n-                            terminator.kind = TerminatorKind::Goto {\n-                                target,\n-                            };\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n+        if mode == Mode::Static && !tcx.has_attr(def_id, sym::thread_local) {\n+            // `static`s (not `static mut`s) which are not `#[thread_local]` must be `Sync`.\n+            check_static_is_sync(tcx, body, hir_id);\n         }\n+    }\n+}\n \n-        // Statics must be Sync.\n-        if mode == Mode::Static {\n-            // `#[thread_local]` statics don't have to be `Sync`.\n-            for attr in &tcx.get_attrs(def_id)[..] {\n-                if attr.check_name(sym::thread_local) {\n-                    return;\n-                }\n+fn determine_mode(tcx: TyCtxt<'_>, hir_id: HirId, def_id: DefId) -> Mode {\n+    match tcx.hir().body_owner_kind(hir_id) {\n+        hir::BodyOwnerKind::Closure => Mode::NonConstFn,\n+        hir::BodyOwnerKind::Fn if tcx.is_const_fn(def_id) => Mode::ConstFn,\n+        hir::BodyOwnerKind::Fn => Mode::NonConstFn,\n+        hir::BodyOwnerKind::Const => Mode::Const,\n+        hir::BodyOwnerKind::Static(hir::MutImmutable) => Mode::Static,\n+        hir::BodyOwnerKind::Static(hir::MutMutable) => Mode::StaticMut,\n+    }\n+}\n+\n+fn error_min_const_fn_violation(tcx: TyCtxt<'_>, span: Span, msg: Cow<'_, str>) {\n+    struct_span_err!(tcx.sess, span, E0723, \"{}\", msg)\n+        .note(\"for more information, see issue https://github.com/rust-lang/rust/issues/57563\")\n+        .help(\"add `#![feature(const_fn)]` to the crate attributes to enable\")\n+        .emit();\n+}\n+\n+fn check_short_circuiting_in_const_local(tcx: TyCtxt<'_>, body: &mut Body<'tcx>, mode: Mode) {\n+    if body.control_flow_destroyed.is_empty() {\n+        return;\n+    }\n+\n+    let mut locals = body.vars_iter();\n+    if let Some(local) = locals.next() {\n+        let span = body.local_decls[local].source_info.span;\n+        let mut error = tcx.sess.struct_span_err(\n+            span,\n+            &format!(\n+                \"new features like let bindings are not permitted in {}s \\\n+                which also use short circuiting operators\",\n+                mode,\n+            ),\n+        );\n+        for (span, kind) in body.control_flow_destroyed.iter() {\n+            error.span_note(\n+                *span,\n+                &format!(\"use of {} here does not actually short circuit due to \\\n+                the const evaluator presently not being able to do control flow. \\\n+                See https://github.com/rust-lang/rust/issues/49146 for more \\\n+                information.\", kind),\n+            );\n+        }\n+        for local in locals {\n+            let span = body.local_decls[local].source_info.span;\n+            error.span_note(span, \"more locals defined here\");\n+        }\n+        error.emit();\n+    }\n+}\n+\n+/// In `const` and `static` everything without `StorageDead`\n+/// is `'static`, we don't have to create promoted MIR fragments,\n+/// just remove `Drop` and `StorageDead` on \"promoted\" locals.\n+fn remove_drop_and_storage_dead_on_promoted_locals(\n+    body: &mut Body<'tcx>,\n+    promoted_temps: &BitSet<Local>,\n+) {\n+    debug!(\"run_pass: promoted_temps={:?}\", promoted_temps);\n+\n+    for block in body.basic_blocks_mut() {\n+        block.statements.retain(|statement| {\n+            match statement.kind {\n+                StatementKind::StorageDead(index) => !promoted_temps.contains(index),\n+                _ => true\n             }\n-            let ty = body.return_ty();\n-            tcx.infer_ctxt().enter(|infcx| {\n-                let param_env = ty::ParamEnv::empty();\n-                let cause = traits::ObligationCause::new(body.span, id, traits::SharedStatic);\n-                let mut fulfillment_cx = traits::FulfillmentContext::new();\n-                fulfillment_cx.register_bound(&infcx,\n-                                              param_env,\n-                                              ty,\n-                                              tcx.require_lang_item(\n-                                                  lang_items::SyncTraitLangItem,\n-                                                  Some(body.span)\n-                                              ),\n-                                              cause);\n-                if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n-                    infcx.report_fulfillment_errors(&err, None, false);\n-                }\n-            });\n+        });\n+        let terminator = block.terminator_mut();\n+        match terminator.kind {\n+            TerminatorKind::Drop {\n+                location: Place {\n+                    base: PlaceBase::Local(index),\n+                    projection: None,\n+                },\n+                target,\n+                ..\n+            } if promoted_temps.contains(index) => {\n+                terminator.kind = TerminatorKind::Goto { target };\n+            }\n+            _ => {}\n         }\n     }\n }\n \n+fn check_static_is_sync(tcx: TyCtxt<'tcx>, body: &mut Body<'tcx>, hir_id: HirId) {\n+    let ty = body.return_ty();\n+    tcx.infer_ctxt().enter(|infcx| {\n+        let cause = traits::ObligationCause::new(body.span, hir_id, traits::SharedStatic);\n+        let mut fulfillment_cx = traits::FulfillmentContext::new();\n+        let sync_def_id = tcx.require_lang_item(lang_items::SyncTraitLangItem, Some(body.span));\n+        fulfillment_cx.register_bound(&infcx, ty::ParamEnv::empty(), ty, sync_def_id, cause);\n+        if let Err(err) = fulfillment_cx.select_all_or_error(&infcx) {\n+            infcx.report_fulfillment_errors(&err, None, false);\n+        }\n+    });\n+}\n+\n fn args_required_const(tcx: TyCtxt<'_>, def_id: DefId) -> Option<FxHashSet<usize>> {\n     let attrs = tcx.get_attrs(def_id);\n     let attr = attrs.iter().find(|a| a.check_name(sym::rustc_args_required_const))?;"}]}