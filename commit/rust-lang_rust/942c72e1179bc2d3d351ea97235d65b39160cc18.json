{"sha": "942c72e1179bc2d3d351ea97235d65b39160cc18", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MmM3MmUxMTc5YmMyZDNkMzUxZWE5NzIzNWQ2NWIzOTE2MGNjMTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T22:06:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-09T22:06:27Z"}, "message": "auto merge of #15550 : alexcrichton/rust/install-script, r=brson\n\nThis adds detection of the relevant LD_LIBRARY_PATH-like environment variable\r\nand appropriately sets it when testing whether binaries can run or not.\r\nAdditionally, the installation prints a recommended value if one is necessary.\r\n\r\nCloses #15545", "tree": {"sha": "e8326084d8931aff1deabc4c6167ad695f7dfb9c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8326084d8931aff1deabc4c6167ad695f7dfb9c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/942c72e1179bc2d3d351ea97235d65b39160cc18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/942c72e1179bc2d3d351ea97235d65b39160cc18", "html_url": "https://github.com/rust-lang/rust/commit/942c72e1179bc2d3d351ea97235d65b39160cc18", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/942c72e1179bc2d3d351ea97235d65b39160cc18/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e1f11ef482d90f2ea3bd284b07cd825315fadd", "url": "https://api.github.com/repos/rust-lang/rust/commits/66e1f11ef482d90f2ea3bd284b07cd825315fadd", "html_url": "https://github.com/rust-lang/rust/commit/66e1f11ef482d90f2ea3bd284b07cd825315fadd"}, {"sha": "6f8b6c8c3650e8d73be07f119b6a435cad6db438", "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8b6c8c3650e8d73be07f119b6a435cad6db438", "html_url": "https://github.com/rust-lang/rust/commit/6f8b6c8c3650e8d73be07f119b6a435cad6db438"}], "stats": {"total": 141, "additions": 85, "deletions": 56}, "files": [{"sha": "a89b616edf031f076e1c01ad1da6dfa4540e6319", "filename": "src/etc/install.sh", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/942c72e1179bc2d3d351ea97235d65b39160cc18/src%2Fetc%2Finstall.sh", "raw_url": "https://github.com/rust-lang/rust/raw/942c72e1179bc2d3d351ea97235d65b39160cc18/src%2Fetc%2Finstall.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Finstall.sh?ref=942c72e1179bc2d3d351ea97235d65b39160cc18", "patch": "@@ -285,6 +285,19 @@ then\n     CFG_LIBDIR_RELATIVE=bin\n fi\n \n+if [ \"$CFG_OSTYPE\" = \"pc-mingw32\" ] || [ \"$CFG_OSTYPE\" = \"w64-mingw32\" ]\n+then\n+    CFG_LD_PATH_VAR=PATH\n+    CFG_OLD_LD_PATH_VAR=$PATH\n+elif [ \"$CFG_OSTYPE\" = \"Darwin\" ]\n+then\n+    CFG_LD_PATH_VAR=DYLD_LIBRARY_PATH\n+    CFG_OLD_LD_PATH_VAR=$DYLD_LIBRARY_PATH\n+else\n+    CFG_LD_PATH_VAR=LD_LIBRARY_PATH\n+    CFG_OLD_LD_PATH_VAR=$LD_LIBRARY_PATH\n+fi\n+\n flag uninstall \"only uninstall from the installation prefix\"\n opt verify 1 \"verify that the installed binaries run correctly\"\n valopt prefix \"/usr/local\" \"set installation prefix\"\n@@ -312,11 +325,13 @@ then\n     if [ -z \"${CFG_UNINSTALL}\" ]\n     then\n         msg \"verifying platform can run binaries\"\n+        export $CFG_LD_PATH_VAR=\"${CFG_SRC_DIR}/lib\":$CFG_OLD_LD_PATH_VAR\n         \"${CFG_SRC_DIR}/bin/rustc\" --version > /dev/null\n         if [ $? -ne 0 ]\n         then\n             err \"can't execute rustc binary on this platform\"\n         fi\n+        export $CFG_LD_PATH_VAR=$CFG_OLD_LD_PATH_VAR\n     fi\n fi\n \n@@ -452,17 +467,31 @@ while read p; do\n done < \"${CFG_SRC_DIR}/${CFG_LIBDIR_RELATIVE}/rustlib/manifest.in\"\n \n # Sanity check: can we run the installed binaries?\n+#\n+# As with the verification above, make sure the right LD_LIBRARY_PATH-equivalent\n+# is in place. Try first without this variable, and if that fails try again with\n+# the variable. If the second time tries, print a hopefully helpful message to\n+# add something to the appropriate environment variable.\n if [ -z \"${CFG_DISABLE_VERIFY}\" ]\n then\n     msg \"verifying installed binaries are executable\"\n-    \"${CFG_PREFIX}/bin/rustc\" --version > /dev/null\n+    \"${CFG_PREFIX}/bin/rustc\" --version 2> /dev/null 1> /dev/null\n     if [ $? -ne 0 ]\n     then\n-        ERR=\"can't execute installed rustc binary. \"\n-        ERR=\"${ERR}installation may be broken. \"\n-        ERR=\"${ERR}if this is expected then rerun install.sh with \\`--disable-verify\\` \"\n-        ERR=\"${ERR}or \\`make install\\` with \\`--disable-verify-install\\`\"\n-        err \"${ERR}\"\n+        export $CFG_LD_PATH_VAR=\"${CFG_PREFIX}/lib\":$CFG_OLD_LD_PATH_VAR\n+        \"${CFG_PREFIX}/bin/rustc\" --version > /dev/null\n+        if [ $? -ne 0 ]\n+        then\n+            ERR=\"can't execute installed rustc binary. \"\n+            ERR=\"${ERR}installation may be broken. \"\n+            ERR=\"${ERR}if this is expected then rerun install.sh with \\`--disable-verify\\` \"\n+            ERR=\"${ERR}or \\`make install\\` with \\`--disable-verify-install\\`\"\n+            err \"${ERR}\"\n+        else\n+            echo\n+            echo \"    please ensure '${CFG_PREFIX}/lib' is added to ${CFG_LD_PATH_VAR}\"\n+            echo\n+        fi\n     fi\n fi\n "}, {"sha": "778f77ac7a8181383aae92d48cf0e41226e0848b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 50, "deletions": 50, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/942c72e1179bc2d3d351ea97235d65b39160cc18/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/942c72e1179bc2d3d351ea97235d65b39160cc18/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=942c72e1179bc2d3d351ea97235d65b39160cc18", "patch": "@@ -561,56 +561,56 @@ pub enum TokenTree {\n     TTNonterminal(Span, Ident)\n }\n \n-/// Matchers are nodes defined-by and recognized-by the main rust parser and\n-/// language, but they're only ever found inside syntax-extension invocations;\n-/// indeed, the only thing that ever _activates_ the rules in the rust parser\n-/// for parsing a matcher is a matcher looking for the 'matchers' nonterminal\n-/// itself. Matchers represent a small sub-language for pattern-matching\n-/// token-trees, and are thus primarily used by the macro-defining extension\n-/// itself.\n-///\n-/// MatchTok\n-/// --------\n-///\n-///     A matcher that matches a single token, denoted by the token itself. So\n-///     long as there's no $ involved.\n-///\n-///\n-/// MatchSeq\n-/// --------\n-///\n-///     A matcher that matches a sequence of sub-matchers, denoted various\n-///     possible ways:\n-///\n-///             $(M)*       zero or more Ms\n-///             $(M)+       one or more Ms\n-///             $(M),+      one or more comma-separated Ms\n-///             $(A B C);*  zero or more semi-separated 'A B C' seqs\n-///\n-///\n-/// MatchNonterminal\n-/// -----------------\n-///\n-///     A matcher that matches one of a few interesting named rust\n-///     nonterminals, such as types, expressions, items, or raw token-trees. A\n-///     black-box matcher on expr, for example, binds an expr to a given ident,\n-///     and that ident can re-occur as an interpolation in the RHS of a\n-///     macro-by-example rule. For example:\n-///\n-///        $foo:expr   =>     1 + $foo    // interpolate an expr\n-///        $foo:tt     =>     $foo        // interpolate a token-tree\n-///        $foo:tt     =>     bar! $foo   // only other valid interpolation\n-///                                       // is in arg position for another\n-///                                       // macro\n-///\n-/// As a final, horrifying aside, note that macro-by-example's input is\n-/// also matched by one of these matchers. Holy self-referential! It is matched\n-/// by a MatchSeq, specifically this one:\n-///\n-///                   $( $lhs:matchers => $rhs:tt );+\n-///\n-/// If you understand that, you have closed the loop and understand the whole\n-/// macro system. Congratulations.\n+// Matchers are nodes defined-by and recognized-by the main rust parser and\n+// language, but they're only ever found inside syntax-extension invocations;\n+// indeed, the only thing that ever _activates_ the rules in the rust parser\n+// for parsing a matcher is a matcher looking for the 'matchers' nonterminal\n+// itself. Matchers represent a small sub-language for pattern-matching\n+// token-trees, and are thus primarily used by the macro-defining extension\n+// itself.\n+//\n+// MatchTok\n+// --------\n+//\n+//     A matcher that matches a single token, denoted by the token itself. So\n+//     long as there's no $ involved.\n+//\n+//\n+// MatchSeq\n+// --------\n+//\n+//     A matcher that matches a sequence of sub-matchers, denoted various\n+//     possible ways:\n+//\n+//             $(M)*       zero or more Ms\n+//             $(M)+       one or more Ms\n+//             $(M),+      one or more comma-separated Ms\n+//             $(A B C);*  zero or more semi-separated 'A B C' seqs\n+//\n+//\n+// MatchNonterminal\n+// -----------------\n+//\n+//     A matcher that matches one of a few interesting named rust\n+//     nonterminals, such as types, expressions, items, or raw token-trees. A\n+//     black-box matcher on expr, for example, binds an expr to a given ident,\n+//     and that ident can re-occur as an interpolation in the RHS of a\n+//     macro-by-example rule. For example:\n+//\n+//        $foo:expr   =>     1 + $foo    // interpolate an expr\n+//        $foo:tt     =>     $foo        // interpolate a token-tree\n+//        $foo:tt     =>     bar! $foo   // only other valid interpolation\n+//                                       // is in arg position for another\n+//                                       // macro\n+//\n+// As a final, horrifying aside, note that macro-by-example's input is\n+// also matched by one of these matchers. Holy self-referential! It is matched\n+// by a MatchSeq, specifically this one:\n+//\n+//                   $( $lhs:matchers => $rhs:tt );+\n+//\n+// If you understand that, you have closed the loop and understand the whole\n+// macro system. Congratulations.\n pub type Matcher = Spanned<Matcher_>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]"}]}