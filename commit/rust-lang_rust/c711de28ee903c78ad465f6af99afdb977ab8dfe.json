{"sha": "c711de28ee903c78ad465f6af99afdb977ab8dfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3MTFkZTI4ZWU5MDNjNzhhZDQ2NWY2YWY5OWFmZGI5NzdhYjhkZmU=", "commit": {"author": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-06T13:26:29Z"}, "committer": {"name": "Takayuki Maeda", "email": "takoyaki0316@gmail.com", "date": "2021-03-11T10:40:50Z"}, "message": "move expect_fun_call to its own module", "tree": {"sha": "14e412ab0b5192c5e3f8c5ebf6f8e020b4999ad9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14e412ab0b5192c5e3f8c5ebf6f8e020b4999ad9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c711de28ee903c78ad465f6af99afdb977ab8dfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c711de28ee903c78ad465f6af99afdb977ab8dfe", "html_url": "https://github.com/rust-lang/rust/commit/c711de28ee903c78ad465f6af99afdb977ab8dfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c711de28ee903c78ad465f6af99afdb977ab8dfe/comments", "author": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TaKO8Ki", "id": 41065217, "node_id": "MDQ6VXNlcjQxMDY1MjE3", "avatar_url": "https://avatars.githubusercontent.com/u/41065217?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TaKO8Ki", "html_url": "https://github.com/TaKO8Ki", "followers_url": "https://api.github.com/users/TaKO8Ki/followers", "following_url": "https://api.github.com/users/TaKO8Ki/following{/other_user}", "gists_url": "https://api.github.com/users/TaKO8Ki/gists{/gist_id}", "starred_url": "https://api.github.com/users/TaKO8Ki/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TaKO8Ki/subscriptions", "organizations_url": "https://api.github.com/users/TaKO8Ki/orgs", "repos_url": "https://api.github.com/users/TaKO8Ki/repos", "events_url": "https://api.github.com/users/TaKO8Ki/events{/privacy}", "received_events_url": "https://api.github.com/users/TaKO8Ki/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f49349bf333001166e3a215b7b2eb5b5cb1c9989", "url": "https://api.github.com/repos/rust-lang/rust/commits/f49349bf333001166e3a215b7b2eb5b5cb1c9989", "html_url": "https://github.com/rust-lang/rust/commit/f49349bf333001166e3a215b7b2eb5b5cb1c9989"}], "stats": {"total": 405, "additions": 204, "deletions": 201}, "files": [{"sha": "6866e9c652ab37d9c5202f0f95a2e7a62dc0ff38", "filename": "clippy_lints/src/methods/expect_fun_call.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/c711de28ee903c78ad465f6af99afdb977ab8dfe/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c711de28ee903c78ad465f6af99afdb977ab8dfe/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fexpect_fun_call.rs?ref=c711de28ee903c78ad465f6af99afdb977ab8dfe", "patch": "@@ -0,0 +1,199 @@\n+use crate::utils::{is_expn_of, is_type_diagnostic_item, snippet, snippet_with_applicability, span_lint_and_sugg};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir as hir;\n+use rustc_lint::LateContext;\n+use rustc_middle::ty;\n+use rustc_span::source_map::Span;\n+use rustc_span::symbol::sym;\n+use std::borrow::Cow;\n+\n+use super::EXPECT_FUN_CALL;\n+\n+/// Checks for the `EXPECT_FUN_CALL` lint.\n+#[allow(clippy::too_many_lines)]\n+pub(super) fn check(cx: &LateContext<'_>, expr: &hir::Expr<'_>, method_span: Span, name: &str, args: &[hir::Expr<'_>]) {\n+    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n+    // `&str`\n+    fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n+        let mut arg_root = arg;\n+        loop {\n+            arg_root = match &arg_root.kind {\n+                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n+                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n+                    if call_args.len() == 1\n+                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n+                        && {\n+                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n+                            let base_type = arg_type.peel_refs();\n+                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n+                        }\n+                    {\n+                        &call_args[0]\n+                    } else {\n+                        break;\n+                    }\n+                },\n+                _ => break,\n+            };\n+        }\n+        arg_root\n+    }\n+\n+    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n+    // converted to string.\n+    fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        let arg_ty = cx.typeck_results().expr_ty(arg);\n+        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n+            return false;\n+        }\n+        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n+            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n+                return false;\n+            }\n+        };\n+        true\n+    }\n+\n+    // Check if an expression could have type `&'static str`, knowing that it\n+    // has type `&str` for some lifetime.\n+    fn can_be_static_str(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n+        match arg.kind {\n+            hir::ExprKind::Lit(_) => true,\n+            hir::ExprKind::Call(fun, _) => {\n+                if let hir::ExprKind::Path(ref p) = fun.kind {\n+                    match cx.qpath_res(p, fun.hir_id) {\n+                        hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n+                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        ),\n+                        _ => false,\n+                    }\n+                } else {\n+                    false\n+                }\n+            },\n+            hir::ExprKind::MethodCall(..) => {\n+                cx.typeck_results()\n+                    .type_dependent_def_id(arg.hir_id)\n+                    .map_or(false, |method_id| {\n+                        matches!(\n+                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n+                            ty::Ref(ty::ReStatic, ..)\n+                        )\n+                    })\n+            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n+            _ => false,\n+        }\n+    }\n+\n+    fn generate_format_arg_snippet(\n+        cx: &LateContext<'_>,\n+        a: &hir::Expr<'_>,\n+        applicability: &mut Applicability,\n+    ) -> Vec<String> {\n+        if_chain! {\n+            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n+            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n+            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n+\n+            then {\n+                format_arg_expr_tup\n+                    .iter()\n+                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n+                    .collect()\n+            } else {\n+                unreachable!()\n+            }\n+        }\n+    }\n+\n+    fn is_call(node: &hir::ExprKind<'_>) -> bool {\n+        match node {\n+            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n+                is_call(&expr.kind)\n+            },\n+            hir::ExprKind::Call(..)\n+            | hir::ExprKind::MethodCall(..)\n+            // These variants are debatable or require further examination\n+            | hir::ExprKind::If(..)\n+            | hir::ExprKind::Match(..)\n+            | hir::ExprKind::Block{ .. } => true,\n+            _ => false,\n+        }\n+    }\n+\n+    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n+        return;\n+    }\n+\n+    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n+    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n+        \"||\"\n+    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n+        \"|_|\"\n+    } else {\n+        return;\n+    };\n+\n+    let arg_root = get_arg_root(cx, &args[1]);\n+\n+    let span_replace_word = method_span.with_hi(expr.span.hi());\n+\n+    let mut applicability = Applicability::MachineApplicable;\n+\n+    //Special handling for `format!` as arg_root\n+    if_chain! {\n+        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n+        if block.stmts.len() == 1;\n+        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n+        if let Some(arg_root) = &local.init;\n+        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n+        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n+        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n+        then {\n+            let fmt_spec = &format_args[0];\n+            let fmt_args = &format_args[1];\n+\n+            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n+\n+            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n+\n+            let sugg = args.join(\", \");\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPECT_FUN_CALL,\n+                span_replace_word,\n+                &format!(\"use of `{}` followed by a function call\", name),\n+                \"try this\",\n+                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n+                applicability,\n+            );\n+\n+            return;\n+        }\n+    }\n+\n+    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n+    if requires_to_string(cx, arg_root) {\n+        arg_root_snippet.to_mut().push_str(\".to_string()\");\n+    }\n+\n+    span_lint_and_sugg(\n+        cx,\n+        EXPECT_FUN_CALL,\n+        span_replace_word,\n+        &format!(\"use of `{}` followed by a function call\", name),\n+        \"try this\",\n+        format!(\n+            \"unwrap_or_else({} {{ panic!(\\\"{{}}\\\", {}) }})\",\n+            closure_args, arg_root_snippet\n+        ),\n+        applicability,\n+    );\n+}"}, {"sha": "180620e860a5f411c5cc4f6632953af3fe2456aa", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 201, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/c711de28ee903c78ad465f6af99afdb977ab8dfe/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c711de28ee903c78ad465f6af99afdb977ab8dfe/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=c711de28ee903c78ad465f6af99afdb977ab8dfe", "patch": "@@ -2,6 +2,7 @@ mod bind_instead_of_map;\n mod bytes_nth;\n mod clone_on_copy;\n mod clone_on_ref_ptr;\n+mod expect_fun_call;\n mod expect_used;\n mod filetype_is_file;\n mod filter_flat_map;\n@@ -50,8 +51,6 @@ mod useless_asref;\n mod wrong_self_convention;\n mod zst_offset;\n \n-use std::borrow::Cow;\n-\n use bind_instead_of_map::BindInsteadOfMap;\n use if_chain::if_chain;\n use rustc_ast::ast;\n@@ -68,10 +67,9 @@ use rustc_span::symbol::{sym, Symbol, SymbolStr};\n use rustc_typeck::hir_ty_to_ty;\n \n use crate::utils::{\n-    contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_expn_of,\n-    is_type_diagnostic_item, iter_input_pats, match_def_path, match_qpath, method_calls, method_chain_args, paths,\n-    return_ty, single_segment_path, snippet, snippet_with_applicability, span_lint, span_lint_and_help,\n-    span_lint_and_sugg, SpanlessEq,\n+    contains_return, contains_ty, get_trait_def_id, implements_trait, in_macro, is_copy, is_type_diagnostic_item,\n+    iter_input_pats, match_def_path, match_qpath, method_calls, method_chain_args, paths, return_ty,\n+    single_segment_path, snippet_with_applicability, span_lint, span_lint_and_help, span_lint_and_sugg, SpanlessEq,\n };\n \n declare_clippy_lint! {\n@@ -1779,7 +1777,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             },\n             hir::ExprKind::MethodCall(ref method_call, ref method_span, ref args, _) => {\n                 or_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n-                lint_expect_fun_call(cx, expr, *method_span, &method_call.ident.as_str(), args);\n+                expect_fun_call::check(cx, expr, *method_span, &method_call.ident.as_str(), args);\n \n                 let self_ty = cx.typeck_results().expr_ty_adjusted(&args[0]);\n                 if args.len() == 1 && method_call.ident.name == sym::clone {\n@@ -1973,200 +1971,6 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n     extract_msrv_attr!(LateContext);\n }\n \n-/// Checks for the `EXPECT_FUN_CALL` lint.\n-#[allow(clippy::too_many_lines)]\n-fn lint_expect_fun_call(\n-    cx: &LateContext<'_>,\n-    expr: &hir::Expr<'_>,\n-    method_span: Span,\n-    name: &str,\n-    args: &[hir::Expr<'_>],\n-) {\n-    // Strip `&`, `as_ref()` and `as_str()` off `arg` until we're left with either a `String` or\n-    // `&str`\n-    fn get_arg_root<'a>(cx: &LateContext<'_>, arg: &'a hir::Expr<'a>) -> &'a hir::Expr<'a> {\n-        let mut arg_root = arg;\n-        loop {\n-            arg_root = match &arg_root.kind {\n-                hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => expr,\n-                hir::ExprKind::MethodCall(method_name, _, call_args, _) => {\n-                    if call_args.len() == 1\n-                        && (method_name.ident.name == sym::as_str || method_name.ident.name == sym!(as_ref))\n-                        && {\n-                            let arg_type = cx.typeck_results().expr_ty(&call_args[0]);\n-                            let base_type = arg_type.peel_refs();\n-                            *base_type.kind() == ty::Str || is_type_diagnostic_item(cx, base_type, sym::string_type)\n-                        }\n-                    {\n-                        &call_args[0]\n-                    } else {\n-                        break;\n-                    }\n-                },\n-                _ => break,\n-            };\n-        }\n-        arg_root\n-    }\n-\n-    // Only `&'static str` or `String` can be used directly in the `panic!`. Other types should be\n-    // converted to string.\n-    fn requires_to_string(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n-        let arg_ty = cx.typeck_results().expr_ty(arg);\n-        if is_type_diagnostic_item(cx, arg_ty, sym::string_type) {\n-            return false;\n-        }\n-        if let ty::Ref(_, ty, ..) = arg_ty.kind() {\n-            if *ty.kind() == ty::Str && can_be_static_str(cx, arg) {\n-                return false;\n-            }\n-        };\n-        true\n-    }\n-\n-    // Check if an expression could have type `&'static str`, knowing that it\n-    // has type `&str` for some lifetime.\n-    fn can_be_static_str(cx: &LateContext<'_>, arg: &hir::Expr<'_>) -> bool {\n-        match arg.kind {\n-            hir::ExprKind::Lit(_) => true,\n-            hir::ExprKind::Call(fun, _) => {\n-                if let hir::ExprKind::Path(ref p) = fun.kind {\n-                    match cx.qpath_res(p, fun.hir_id) {\n-                        hir::def::Res::Def(hir::def::DefKind::Fn | hir::def::DefKind::AssocFn, def_id) => matches!(\n-                            cx.tcx.fn_sig(def_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n-                        ),\n-                        _ => false,\n-                    }\n-                } else {\n-                    false\n-                }\n-            },\n-            hir::ExprKind::MethodCall(..) => {\n-                cx.typeck_results()\n-                    .type_dependent_def_id(arg.hir_id)\n-                    .map_or(false, |method_id| {\n-                        matches!(\n-                            cx.tcx.fn_sig(method_id).output().skip_binder().kind(),\n-                            ty::Ref(ty::ReStatic, ..)\n-                        )\n-                    })\n-            },\n-            hir::ExprKind::Path(ref p) => matches!(\n-                cx.qpath_res(p, arg.hir_id),\n-                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n-            ),\n-            _ => false,\n-        }\n-    }\n-\n-    fn generate_format_arg_snippet(\n-        cx: &LateContext<'_>,\n-        a: &hir::Expr<'_>,\n-        applicability: &mut Applicability,\n-    ) -> Vec<String> {\n-        if_chain! {\n-            if let hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, ref format_arg) = a.kind;\n-            if let hir::ExprKind::Match(ref format_arg_expr, _, _) = format_arg.kind;\n-            if let hir::ExprKind::Tup(ref format_arg_expr_tup) = format_arg_expr.kind;\n-\n-            then {\n-                format_arg_expr_tup\n-                    .iter()\n-                    .map(|a| snippet_with_applicability(cx, a.span, \"..\", applicability).into_owned())\n-                    .collect()\n-            } else {\n-                unreachable!()\n-            }\n-        }\n-    }\n-\n-    fn is_call(node: &hir::ExprKind<'_>) -> bool {\n-        match node {\n-            hir::ExprKind::AddrOf(hir::BorrowKind::Ref, _, expr) => {\n-                is_call(&expr.kind)\n-            },\n-            hir::ExprKind::Call(..)\n-            | hir::ExprKind::MethodCall(..)\n-            // These variants are debatable or require further examination\n-            | hir::ExprKind::If(..)\n-            | hir::ExprKind::Match(..)\n-            | hir::ExprKind::Block{ .. } => true,\n-            _ => false,\n-        }\n-    }\n-\n-    if args.len() != 2 || name != \"expect\" || !is_call(&args[1].kind) {\n-        return;\n-    }\n-\n-    let receiver_type = cx.typeck_results().expr_ty_adjusted(&args[0]);\n-    let closure_args = if is_type_diagnostic_item(cx, receiver_type, sym::option_type) {\n-        \"||\"\n-    } else if is_type_diagnostic_item(cx, receiver_type, sym::result_type) {\n-        \"|_|\"\n-    } else {\n-        return;\n-    };\n-\n-    let arg_root = get_arg_root(cx, &args[1]);\n-\n-    let span_replace_word = method_span.with_hi(expr.span.hi());\n-\n-    let mut applicability = Applicability::MachineApplicable;\n-\n-    //Special handling for `format!` as arg_root\n-    if_chain! {\n-        if let hir::ExprKind::Block(block, None) = &arg_root.kind;\n-        if block.stmts.len() == 1;\n-        if let hir::StmtKind::Local(local) = &block.stmts[0].kind;\n-        if let Some(arg_root) = &local.init;\n-        if let hir::ExprKind::Call(ref inner_fun, ref inner_args) = arg_root.kind;\n-        if is_expn_of(inner_fun.span, \"format\").is_some() && inner_args.len() == 1;\n-        if let hir::ExprKind::Call(_, format_args) = &inner_args[0].kind;\n-        then {\n-            let fmt_spec = &format_args[0];\n-            let fmt_args = &format_args[1];\n-\n-            let mut args = vec![snippet(cx, fmt_spec.span, \"..\").into_owned()];\n-\n-            args.extend(generate_format_arg_snippet(cx, fmt_args, &mut applicability));\n-\n-            let sugg = args.join(\", \");\n-\n-            span_lint_and_sugg(\n-                cx,\n-                EXPECT_FUN_CALL,\n-                span_replace_word,\n-                &format!(\"use of `{}` followed by a function call\", name),\n-                \"try this\",\n-                format!(\"unwrap_or_else({} panic!({}))\", closure_args, sugg),\n-                applicability,\n-            );\n-\n-            return;\n-        }\n-    }\n-\n-    let mut arg_root_snippet: Cow<'_, _> = snippet_with_applicability(cx, arg_root.span, \"..\", &mut applicability);\n-    if requires_to_string(cx, arg_root) {\n-        arg_root_snippet.to_mut().push_str(\".to_string()\");\n-    }\n-\n-    span_lint_and_sugg(\n-        cx,\n-        EXPECT_FUN_CALL,\n-        span_replace_word,\n-        &format!(\"use of `{}` followed by a function call\", name),\n-        \"try this\",\n-        format!(\n-            \"unwrap_or_else({} {{ panic!(\\\"{{}}\\\", {}) }})\",\n-            closure_args, arg_root_snippet\n-        ),\n-        applicability,\n-    );\n-}\n-\n fn derefs_to_slice<'tcx>(\n     cx: &LateContext<'tcx>,\n     expr: &'tcx hir::Expr<'tcx>,"}]}