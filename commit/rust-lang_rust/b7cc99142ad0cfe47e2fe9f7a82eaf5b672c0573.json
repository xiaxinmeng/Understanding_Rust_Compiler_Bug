{"sha": "b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "node_id": "C_kwDOAAsO6NoAKGI3Y2M5OTE0MmFkMGNmZTQ3ZTJmZTlmN2E4MmVhZjViNjcyYzA1NzM", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2021-10-07T09:29:01Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.de", "date": "2021-10-07T18:03:00Z"}, "message": "Turn tcx.vtable_allocation() into a query.", "tree": {"sha": "9a855bc4022a32a3498651a8fbc138dd595b40ea", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a855bc4022a32a3498651a8fbc138dd595b40ea"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "html_url": "https://github.com/rust-lang/rust/commit/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a1e2c0f0ad9e787b5ff2844112fc2324511adf34", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1e2c0f0ad9e787b5ff2844112fc2324511adf34", "html_url": "https://github.com/rust-lang/rust/commit/a1e2c0f0ad9e787b5ff2844112fc2324511adf34"}], "stats": {"total": 167, "additions": 98, "deletions": 69}, "files": [{"sha": "36b3725ef42bce5ad62f38288b64dad9b5c62be1", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -68,7 +68,7 @@ pub(crate) fn get_vtable<'tcx>(\n     ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let alloc_id = fx.tcx.vtable_allocation(ty, trait_ref);\n+    let alloc_id = fx.tcx.vtable_allocation((ty, trait_ref));\n     let data_id =\n         data_id_for_alloc_id(&mut fx.constants_cx, &mut *fx.module, alloc_id, Mutability::Not);\n     let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);"}, {"sha": "3267d3206f73f45bb55e5f4f8e87b5293091d3fb", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -72,7 +72,7 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         return val;\n     }\n \n-    let vtable_alloc_id = tcx.vtable_allocation(ty, trait_ref);\n+    let vtable_alloc_id = tcx.vtable_allocation((ty, trait_ref));\n     let vtable_allocation = tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n     let vtable_const = cx.const_data_from_alloc(vtable_allocation);\n     let align = cx.data_layout().pointer_align.abi;"}, {"sha": "131674decc96109087069099fa4c2df6ada2e10c", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -30,7 +30,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        let vtable_allocation = self.tcx.vtable_allocation(ty, poly_trait_ref);\n+        let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n \n         let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n "}, {"sha": "40d049eb72c035f1f7c2b61717dd2b3db411af18", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -1012,6 +1012,13 @@ rustc_queries! {\n             key.1, key.0 }\n     }\n \n+    query vtable_allocation(key: (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>)) -> mir::interpret::AllocId {\n+        desc { |tcx| \"vtable const allocation for <{} as {}>\",\n+            key.0,\n+            key.1.map(|trait_ref| format!(\"{}\", trait_ref)).unwrap_or(\"_\".to_owned())\n+        }\n+    }\n+\n     query codegen_fulfill_obligation(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n     ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {"}, {"sha": "5e8630eb966f3401d5678747285792875278f6c8", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -2050,6 +2050,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         trait_impls_of: trait_def::trait_impls_of_provider,\n         type_uninhabited_from: inhabitedness::type_uninhabited_from,\n         const_param_default: consts::const_param_default,\n+        vtable_allocation: vtable::vtable_allocation_provider,\n         ..*providers\n     };\n }"}, {"sha": "c60c76c471057ac07c72306d2c9a712d5a0bb12b", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -2192,6 +2192,7 @@ forward_display_to_print! {\n     // because `for<'tcx>` isn't possible yet.\n     ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>,\n     ty::Binder<'tcx, ty::TraitRef<'tcx>>,\n+    ty::Binder<'tcx, ty::ExistentialTraitRef<'tcx>>,\n     ty::Binder<'tcx, TraitRefPrintOnlyTraitPath<'tcx>>,\n     ty::Binder<'tcx, ty::FnSig<'tcx>>,\n     ty::Binder<'tcx, ty::TraitPredicate<'tcx>>,"}, {"sha": "f766cad2b3d2181d6a09794cb39d3dacdf68d4b0", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "modified", "additions": 60, "deletions": 65, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -43,77 +43,72 @@ pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;\n \n-impl<'tcx> TyCtxt<'tcx> {\n-    /// Retrieves an allocation that represents the contents of a vtable.\n-    /// There's a cache within `TyCtxt` so it will be deduplicated.\n-    pub fn vtable_allocation(\n-        self,\n-        ty: Ty<'tcx>,\n-        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-    ) -> AllocId {\n-        let tcx = self;\n+/// Retrieves an allocation that represents the contents of a vtable.\n+/// Since this is a query, allocations are cached and not duplicated.\n+pub(super) fn vtable_allocation_provider<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    key: (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>),\n+) -> AllocId {\n+    let (ty, poly_trait_ref) = key;\n \n-        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n-            let trait_ref = tcx.erase_regions(trait_ref);\n+    let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n+        let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n+        let trait_ref = tcx.erase_regions(trait_ref);\n \n-            tcx.vtable_entries(trait_ref)\n-        } else {\n-            COMMON_VTABLE_ENTRIES\n-        };\n-\n-        let layout = tcx\n-            .layout_of(ty::ParamEnv::reveal_all().and(ty))\n-            .expect(\"failed to build vtable representation\");\n-        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi.bytes();\n+        tcx.vtable_entries(trait_ref)\n+    } else {\n+        COMMON_VTABLE_ENTRIES\n+    };\n \n-        let ptr_size = tcx.data_layout.pointer_size;\n-        let ptr_align = tcx.data_layout.pointer_align.abi;\n+    let layout = tcx\n+        .layout_of(ty::ParamEnv::reveal_all().and(ty))\n+        .expect(\"failed to build vtable representation\");\n+    assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+    let size = layout.size.bytes();\n+    let align = layout.align.abi.bytes();\n \n-        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-        let mut vtable =\n-            Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n+    let ptr_size = tcx.data_layout.pointer_size;\n+    let ptr_align = tcx.data_layout.pointer_align.abi;\n \n-        // No need to do any alignment checks on the memory accesses below, because we know the\n-        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n-        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+    let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n+    let mut vtable = Allocation::uninit(vtable_size, ptr_align, /* panic_on_fail */ true).unwrap();\n \n-        for (idx, entry) in vtable_entries.iter().enumerate() {\n-            let idx: u64 = u64::try_from(idx).unwrap();\n-            let scalar = match entry {\n-                VtblEntry::MetadataDropInPlace => {\n-                    let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n-                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                    let fn_ptr = Pointer::from(fn_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n-                }\n-                VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n-                VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n-                VtblEntry::Vacant => continue,\n-                VtblEntry::Method(instance) => {\n-                    // Prepare the fn ptr we write into the vtable.\n-                    let instance = instance.polymorphize(tcx);\n-                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                    let fn_ptr = Pointer::from(fn_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n-                }\n-                VtblEntry::TraitVPtr(trait_ref) => {\n-                    let super_trait_ref = trait_ref.map_bound(|trait_ref| {\n-                        ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref)\n-                    });\n-                    let supertrait_alloc_id = self.vtable_allocation(ty, Some(super_trait_ref));\n-                    let vptr = Pointer::from(supertrait_alloc_id);\n-                    ScalarMaybeUninit::from_pointer(vptr, &tcx)\n-                }\n-            };\n-            vtable\n-                .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n-                .expect(\"failed to build vtable representation\");\n-        }\n+    // No need to do any alignment checks on the memory accesses below, because we know the\n+    // allocation is correctly aligned as we created it above. Also we're only offsetting by\n+    // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n \n-        vtable.mutability = Mutability::Not;\n-        tcx.create_memory_alloc(tcx.intern_const_alloc(vtable))\n+    for (idx, entry) in vtable_entries.iter().enumerate() {\n+        let idx: u64 = u64::try_from(idx).unwrap();\n+        let scalar = match entry {\n+            VtblEntry::MetadataDropInPlace => {\n+                let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n+                let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                let fn_ptr = Pointer::from(fn_alloc_id);\n+                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+            }\n+            VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n+            VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+            VtblEntry::Vacant => continue,\n+            VtblEntry::Method(instance) => {\n+                // Prepare the fn ptr we write into the vtable.\n+                let instance = instance.polymorphize(tcx);\n+                let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                let fn_ptr = Pointer::from(fn_alloc_id);\n+                ScalarMaybeUninit::from_pointer(fn_ptr, &tcx)\n+            }\n+            VtblEntry::TraitVPtr(trait_ref) => {\n+                let super_trait_ref = trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+                let supertrait_alloc_id = tcx.vtable_allocation((ty, Some(super_trait_ref)));\n+                let vptr = Pointer::from(supertrait_alloc_id);\n+                ScalarMaybeUninit::from_pointer(vptr, &tcx)\n+            }\n+        };\n+        vtable\n+            .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n+            .expect(\"failed to build vtable representation\");\n     }\n+\n+    vtable.mutability = Mutability::Not;\n+    tcx.create_memory_alloc(tcx.intern_const_alloc(vtable))\n }"}, {"sha": "344892875961aa36d6239d2f0f7c9e2b1645f36d", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -72,6 +72,17 @@ impl<'tcx> Key for mir::interpret::GlobalId<'tcx> {\n     }\n }\n \n+impl<'tcx> Key for (Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>) {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, _: TyCtxt<'_>) -> Span {\n+        DUMMY_SP\n+    }\n+}\n+\n impl<'tcx> Key for mir::interpret::LitToConstInput<'tcx> {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {"}, {"sha": "8dacba63351ef36e31ca82a15cc7bac3ab81f468", "filename": "src/test/incremental/reorder_vtable.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/src%2Ftest%2Fincremental%2Freorder_vtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573/src%2Ftest%2Fincremental%2Freorder_vtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Freorder_vtable.rs?ref=b7cc99142ad0cfe47e2fe9f7a82eaf5b672c0573", "patch": "@@ -1,5 +1,10 @@\n // revisions:rpass1 rpass2\n \n+// This test case makes sure re-order the methods in a vtable will\n+// trigger recompilation of codegen units that instantiate it.\n+//\n+// See https://github.com/rust-lang/rust/issues/89598\n+\n trait Foo {\n     #[cfg(rpass1)]\n     fn method1(&self) -> u32;\n@@ -16,12 +21,21 @@ impl Foo for u32 {\n }\n \n fn main() {\n+    // Before #89598 was fixed, the vtable allocation would be cached during\n+    // a MIR optimization pass and then the codegen pass for the main object\n+    // file would not register a dependency on it (because of the missing\n+    // dep-tracking).\n+    //\n+    // In the rpass2 session, the main object file would not be re-compiled,\n+    // thus the mod1::foo(x) call would pass in an outdated vtable, while the\n+    // mod1 object would expect the new, re-ordered vtable, resulting in a\n+    // call to the wrong method.\n     let x: &dyn Foo = &0u32;\n     assert_eq!(mod1::foo(x), 17);\n }\n \n mod mod1 {\n-    pub fn foo(x: &dyn super::Foo) -> u32 {\n+    pub(super) fn foo(x: &dyn super::Foo) -> u32 {\n         x.method1()\n     }\n }"}]}