{"sha": "30425bfe54318049e07d97602742b7ee6c745b3a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNDI1YmZlNTQzMTgwNDllMDdkOTc2MDI3NDJiN2VlNmM3NDViM2E=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T19:18:37Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-04-14T20:50:03Z"}, "message": "Test fixes and rebase conflicts", "tree": {"sha": "a4d6d17d9db493c0ba7e6e9a563a4f48bf26fd47", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a4d6d17d9db493c0ba7e6e9a563a4f48bf26fd47"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30425bfe54318049e07d97602742b7ee6c745b3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30425bfe54318049e07d97602742b7ee6c745b3a", "html_url": "https://github.com/rust-lang/rust/commit/30425bfe54318049e07d97602742b7ee6c745b3a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30425bfe54318049e07d97602742b7ee6c745b3a/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "html_url": "https://github.com/rust-lang/rust/commit/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073"}], "stats": {"total": 388, "additions": 4, "deletions": 384}, "files": [{"sha": "e7c25d82150933e72d92401659e76304abb7151c", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=30425bfe54318049e07d97602742b7ee6c745b3a", "patch": "@@ -96,7 +96,8 @@ impl<'a> Annotator<'a> {\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"deprecated\" {\n                     attr::mark_used(attr);\n                     self.sess.span_warn(attr.span(),\n-                                        \"stability attributes are deprecated and will soon become errors\");\n+                                        \"stability attributes are deprecated \\\n+                                         and will soon become errors\");\n                 }\n             }\n             f(self);"}, {"sha": "b7160df6c925dcb3b516e6cd94ba58eee76bd7a1", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=30425bfe54318049e07d97602742b7ee6c745b3a", "patch": "@@ -1570,7 +1570,7 @@ impl Path {\n     /// # Examples\n     ///\n     /// ```\n-    /// use std::path::Path;\n+    /// use std::path::{Path, PathBuf};\n     ///\n     /// let path = Path::new(\"/tmp/foo.rs\");\n     ///"}, {"sha": "3f883fb11725bc0f43eab3e1db2f8b71955e09db", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30425bfe54318049e07d97602742b7ee6c745b3a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=30425bfe54318049e07d97602742b7ee6c745b3a", "patch": "@@ -352,7 +352,7 @@ pub fn stmt_to_string(stmt: &ast::Stmt) -> String {\n     $to_string(|s| s.print_stmt(stmt))\n }\n \n-pub fn attr_to_string(attr: &ast::Attr) -> String {\n+pub fn attr_to_string(attr: &ast::Attribute) -> String {\n     $to_string(|s| s.print_attribute(attr))\n }\n "}, {"sha": "3347287748e1db56b2e946d8b6770f1cf1a79226", "filename": "src/test/run-pass/tcp-accept-stress.rs", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-accept-stress.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-macos osx really doesn't like cycling through large numbers of\n-//              sockets as calls to connect() will start returning EADDRNOTAVAIL\n-//              quite quickly and it takes a few seconds for the sockets to get\n-//              recycled.\n-\n-#![feature(old_io, io, std_misc)]\n-\n-use std::old_io::{TcpListener, Listener, Acceptor, EndOfFile, TcpStream};\n-use std::sync::Arc;\n-use std::sync::atomic::{AtomicUsize, Ordering};\n-use std::sync::mpsc::channel;\n-use std::thread;\n-\n-static N: usize = 8;\n-static M: usize = 20;\n-\n-fn main() {\n-    test();\n-}\n-\n-fn test() {\n-    let mut l = TcpListener::bind(\"127.0.0.1:0\").unwrap();\n-    let addr = l.socket_name().unwrap();\n-    let mut a = l.listen().unwrap();\n-    let cnt = Arc::new(AtomicUsize::new(0));\n-\n-    let (srv_tx, srv_rx) = channel();\n-    let (cli_tx, cli_rx) = channel();\n-    let ts1 = (0..N).map(|_| {\n-        let a = a.clone();\n-        let cnt = cnt.clone();\n-        let srv_tx = srv_tx.clone();\n-        thread::spawn(move|| {\n-            let mut a = a;\n-            loop {\n-                match a.accept() {\n-                    Ok(..) => {\n-                        if cnt.fetch_add(1, Ordering::SeqCst) == N * M - 1 {\n-                            break\n-                        }\n-                    }\n-                    Err(ref e) if e.kind == EndOfFile => break,\n-                    Err(e) => panic!(\"{}\", e),\n-                }\n-            }\n-            srv_tx.send(());\n-        })\n-    }).collect::<Vec<_>>();\n-\n-    let ts2 = (0..N).map(|_| {\n-        let cli_tx = cli_tx.clone();\n-        thread::scoped(move|| {\n-            for _ in 0..M {\n-                let _s = TcpStream::connect(addr).unwrap();\n-            }\n-            cli_tx.send(());\n-        })\n-    }).collect::<Vec<_>>();\n-    drop((cli_tx, srv_tx));\n-\n-    // wait for senders\n-    if cli_rx.iter().take(N).count() != N {\n-        a.close_accept().unwrap();\n-        panic!(\"clients panicked\");\n-    }\n-\n-    // wait for one acceptor to die\n-    let _ = srv_rx.recv();\n-\n-    // Notify other receivers should die\n-    a.close_accept().unwrap();\n-\n-    // wait for receivers\n-    assert_eq!(srv_rx.iter().take(N - 1).count(), N - 1);\n-\n-    // Everything should have been accepted.\n-    assert_eq!(cnt.load(Ordering::SeqCst), N * M);\n-\n-    for t in ts1 { t.join() }\n-    for t in ts2 { t.join() }\n-}"}, {"sha": "c31400a832c749fdfbfdf41d6df06ce23bde699b", "filename": "src/test/run-pass/tcp-connect-timeouts.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftcp-connect-timeouts.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -1,77 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-pretty\n-// compile-flags:--test\n-// exec-env:RUST_TEST_THREADS=1\n-\n-// Tests for the connect_timeout() function on a TcpStream. This runs with only\n-// one test task to ensure that errors are timeouts, not file descriptor\n-// exhaustion.\n-\n-#![reexport_test_harness_main = \"test_main\"]\n-\n-#![allow(unused_imports)]\n-#![feature(old_io, std_misc, io)]\n-\n-use std::old_io::*;\n-use std::old_io::test::*;\n-use std::old_io;\n-use std::time::Duration;\n-use std::sync::mpsc::channel;\n-use std::thread;\n-\n-#[cfg_attr(target_os = \"freebsd\", ignore)]\n-fn eventual_timeout() {\n-    let addr = next_test_ip4();\n-\n-    let (tx1, rx1) = channel();\n-    let (_tx2, rx2) = channel::<()>();\n-    let t = thread::spawn(move|| {\n-        let _l = TcpListener::bind(addr).unwrap().listen();\n-        tx1.send(()).unwrap();\n-        let _ = rx2.recv();\n-    });\n-    rx1.recv().unwrap();\n-\n-    let mut v = Vec::new();\n-    for _ in 0_usize..10000 {\n-        match TcpStream::connect_timeout(addr, Duration::milliseconds(100)) {\n-            Ok(e) => v.push(e),\n-            Err(ref e) if e.kind == old_io::TimedOut => return,\n-            Err(e) => panic!(\"other error: {}\", e),\n-        }\n-    }\n-    panic!(\"never timed out!\");\n-    t.join();\n-}\n-\n-fn timeout_success() {\n-    let addr = next_test_ip4();\n-    let _l = TcpListener::bind(addr).unwrap().listen();\n-\n-    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_ok());\n-}\n-\n-fn timeout_error() {\n-    let addr = next_test_ip4();\n-\n-    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(1000)).is_err());\n-}\n-\n-fn connect_timeout_zero() {\n-    let addr = next_test_ip4();\n-    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(0)).is_err());\n-}\n-\n-fn connect_timeout_negative() {\n-    let addr = next_test_ip4();\n-    assert!(TcpStream::connect_timeout(addr, Duration::milliseconds(-1)).is_err());\n-}"}, {"sha": "3f99c338c0e33537d08fb7e16aa5727b424ec1a2", "filename": "src/test/run-pass/tempfile.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073/src%2Ftest%2Frun-pass%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftempfile.rs?ref=b9d9a376ea8843f46ccf9f043dbffa5ac2d1c073", "patch": "@@ -1,213 +0,0 @@\n-// Copyright 2013-2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// ignore-windows TempDir may cause IoError on windows: #10463\n-\n-// These tests are here to exercise the functionality of the `tempfile` module.\n-// One might expect these tests to be located in that module, but sadly they\n-// cannot. The tests need to invoke `os::change_dir` which cannot be done in the\n-// normal test infrastructure. If the tests change the current working\n-// directory, then *all* tests which require relative paths suddenly break b/c\n-// they're in a different location than before. Hence, these tests are all run\n-// serially here.\n-\n-#![feature(old_io, old_path, os, old_fs)]\n-\n-use std::old_path::{Path, GenericPath};\n-use std::old_io::fs::PathExtensions;\n-use std::old_io::{fs, TempDir};\n-use std::old_io;\n-use std::env;\n-use std::sync::mpsc::channel;\n-use std::thread;\n-\n-fn test_tempdir() {\n-    let path = {\n-        let p = TempDir::new_in(&Path::new(\".\"), \"foobar\").unwrap();\n-        let p = p.path();\n-        assert!(p.as_str().unwrap().contains(\"foobar\"));\n-        p.clone()\n-    };\n-    assert!(!path.exists());\n-}\n-\n-fn test_rm_tempdir() {\n-    let (tx, rx) = channel();\n-    let f = move|| -> () {\n-        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        tx.send(tmp.path().clone()).unwrap();\n-        panic!(\"panic to unwind past `tmp`\");\n-    };\n-    thread::spawn(f).join();\n-    let path = rx.recv().unwrap();\n-    assert!(!path.exists());\n-\n-    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-    let path = tmp.path().clone();\n-    let f = move|| -> () {\n-        let _tmp = tmp;\n-        panic!(\"panic to unwind past `tmp`\");\n-    };\n-    thread::spawn(f).join();\n-    assert!(!path.exists());\n-\n-    let path;\n-    {\n-        let f = move || {\n-            TempDir::new(\"test_rm_tempdir\").unwrap()\n-        };\n-        // FIXME(#16640) `: TempDir` annotation shouldn't be necessary\n-        let tmp: TempDir = thread::spawn(f).join().unwrap();\n-        path = tmp.path().clone();\n-        assert!(path.exists());\n-    }\n-    assert!(!path.exists());\n-\n-    let path;\n-    {\n-        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        path = tmp.into_inner();\n-    }\n-    assert!(path.exists());\n-    fs::rmdir_recursive(&path);\n-    assert!(!path.exists());\n-}\n-\n-fn test_rm_tempdir_close() {\n-    let (tx, rx) = channel();\n-    let f = move|| -> () {\n-        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        tx.send(tmp.path().clone()).unwrap();\n-        tmp.close();\n-        panic!(\"panic when unwinding past `tmp`\");\n-    };\n-    thread::spawn(f).join();\n-    let path = rx.recv().unwrap();\n-    assert!(!path.exists());\n-\n-    let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-    let path = tmp.path().clone();\n-    let f = move|| -> () {\n-        let tmp = tmp;\n-        tmp.close();\n-        panic!(\"panic when unwinding past `tmp`\");\n-    };\n-    thread::spawn(f).join();\n-    assert!(!path.exists());\n-\n-    let path;\n-    {\n-        let f = move || {\n-            TempDir::new(\"test_rm_tempdir\").unwrap()\n-        };\n-        // FIXME(#16640) `: TempDir` annotation shouldn't be necessary\n-        let tmp: TempDir = thread::spawn(f).join().unwrap();\n-        path = tmp.path().clone();\n-        assert!(path.exists());\n-        tmp.close();\n-    }\n-    assert!(!path.exists());\n-\n-    let path;\n-    {\n-        let tmp = TempDir::new(\"test_rm_tempdir\").unwrap();\n-        path = tmp.into_inner();\n-    }\n-    assert!(path.exists());\n-    fs::rmdir_recursive(&path);\n-    assert!(!path.exists());\n-}\n-\n-// Ideally these would be in std::os but then core would need\n-// to depend on std\n-fn recursive_mkdir_rel() {\n-    let path = Path::new(\"frob\");\n-    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n-    println!(\"recursive_mkdir_rel: Making: {} in cwd {} [{}]\", path.display(),\n-           cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, old_io::USER_RWX);\n-    assert!(path.is_dir());\n-    fs::mkdir_recursive(&path, old_io::USER_RWX);\n-    assert!(path.is_dir());\n-}\n-\n-fn recursive_mkdir_dot() {\n-    let dot = Path::new(\".\");\n-    fs::mkdir_recursive(&dot, old_io::USER_RWX);\n-    let dotdot = Path::new(\"..\");\n-    fs::mkdir_recursive(&dotdot, old_io::USER_RWX);\n-}\n-\n-fn recursive_mkdir_rel_2() {\n-    let path = Path::new(\"./frob/baz\");\n-    let cwd = Path::new(env::current_dir().unwrap().to_str().unwrap());\n-    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {} [{}]\", path.display(),\n-           cwd.display(), path.exists());\n-    fs::mkdir_recursive(&path, old_io::USER_RWX);\n-    assert!(path.is_dir());\n-    assert!(path.dir_path().is_dir());\n-    let path2 = Path::new(\"quux/blat\");\n-    println!(\"recursive_mkdir_rel_2: Making: {} in cwd {}\", path2.display(),\n-           cwd.display());\n-    fs::mkdir_recursive(&path2, old_io::USER_RWX);\n-    assert!(path2.is_dir());\n-    assert!(path2.dir_path().is_dir());\n-}\n-\n-// Ideally this would be in core, but needs TempFile\n-pub fn test_rmdir_recursive_ok() {\n-    let rwx = old_io::USER_RWX;\n-\n-    let tmpdir = TempDir::new(\"test\").ok().expect(\"test_rmdir_recursive_ok: \\\n-                                                   couldn't create temp dir\");\n-    let tmpdir = tmpdir.path();\n-    let root = tmpdir.join(\"foo\");\n-\n-    println!(\"making {}\", root.display());\n-    fs::mkdir(&root, rwx);\n-    fs::mkdir(&root.join(\"foo\"), rwx);\n-    fs::mkdir(&root.join(\"foo\").join(\"bar\"), rwx);\n-    fs::mkdir(&root.join(\"foo\").join(\"bar\").join(\"blat\"), rwx);\n-    fs::rmdir_recursive(&root);\n-    assert!(!root.exists());\n-    assert!(!root.join(\"bar\").exists());\n-    assert!(!root.join(\"bar\").join(\"blat\").exists());\n-}\n-\n-pub fn dont_double_panic() {\n-    let r: Result<(), _> = thread::spawn(move|| {\n-        let tmpdir = TempDir::new(\"test\").unwrap();\n-        // Remove the temporary directory so that TempDir sees\n-        // an error on drop\n-        fs::rmdir(tmpdir.path());\n-        // Panic. If TempDir panics *again* due to the rmdir\n-        // error then the process will abort.\n-        panic!();\n-    }).join();\n-    assert!(r.is_err());\n-}\n-\n-fn in_tmpdir<F>(f: F) where F: FnOnce() {\n-    let tmpdir = TempDir::new(\"test\").ok().expect(\"can't make tmpdir\");\n-    assert!(env::set_current_dir(tmpdir.path().as_str().unwrap()).is_ok());\n-\n-    f();\n-}\n-\n-pub fn main() {\n-    in_tmpdir(test_tempdir);\n-    in_tmpdir(test_rm_tempdir);\n-    in_tmpdir(test_rm_tempdir_close);\n-    in_tmpdir(recursive_mkdir_rel);\n-    in_tmpdir(recursive_mkdir_dot);\n-    in_tmpdir(recursive_mkdir_rel_2);\n-    in_tmpdir(test_rmdir_recursive_ok);\n-    in_tmpdir(dont_double_panic);\n-}"}]}