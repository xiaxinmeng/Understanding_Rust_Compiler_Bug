{"sha": "c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMyYmMzNDRlYjIzZDhjMWQxOGU4MDNiM2YxZTYzMWNmOTk5MjZmYmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-22T03:45:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-09-22T03:45:30Z"}, "message": "Auto merge of #77039 - ecstatic-morse:rollup-qv3jj4a, r=ecstatic-morse\n\nRollup of 13 pull requests\n\nSuccessful merges:\n\n - #72734 (Reduce duplicate in liballoc reserve error handling)\n - #76131 (Don't use `zip` to compare iterators during pretty-print hack)\n - #76150 (Don't recommend ManuallyDrop to customize drop order)\n - #76275 (Implementation of Write for some immutable ref structs)\n - #76489 (Add explanation for E0756)\n - #76581 (do not ICE on bound variables, return `TooGeneric` instead)\n - #76655 (Make some methods of `Pin` unstable const)\n - #76783 (Only get ImplKind::Impl once)\n - #76807 (Use const-checking to forbid use of unstable features in const-stable functions)\n - #76888 (use if let instead of single match arm expressions)\n - #76914 (extend `Ty` and `TyCtxt` lints to self types)\n - #77022 (Reduce boilerplate for BytePos and CharPos)\n - #77032 (lint missing docs for extern items)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "da0955a36edabba33d09d4125996970b629efab7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da0955a36edabba33d09d4125996970b629efab7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "html_url": "https://github.com/rust-lang/rust/commit/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "45198456be60a6906d24abdc3c67a31b9206188e", "url": "https://api.github.com/repos/rust-lang/rust/commits/45198456be60a6906d24abdc3c67a31b9206188e", "html_url": "https://github.com/rust-lang/rust/commit/45198456be60a6906d24abdc3c67a31b9206188e"}, {"sha": "0863f9a965445c8bd9c98092bc93e8494907c00e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0863f9a965445c8bd9c98092bc93e8494907c00e", "html_url": "https://github.com/rust-lang/rust/commit/0863f9a965445c8bd9c98092bc93e8494907c00e"}], "stats": {"total": 1084, "additions": 762, "deletions": 322}, "files": [{"sha": "a202736ea6cbeab90db5310ff1d0777264bb5af7", "filename": "compiler/rustc_error_codes/src/error_codes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -441,6 +441,7 @@ E0752: include_str!(\"./error_codes/E0752.md\"),\n E0753: include_str!(\"./error_codes/E0753.md\"),\n E0754: include_str!(\"./error_codes/E0754.md\"),\n E0755: include_str!(\"./error_codes/E0755.md\"),\n+E0756: include_str!(\"./error_codes/E0756.md\"),\n E0758: include_str!(\"./error_codes/E0758.md\"),\n E0759: include_str!(\"./error_codes/E0759.md\"),\n E0760: include_str!(\"./error_codes/E0760.md\"),\n@@ -633,7 +634,6 @@ E0774: include_str!(\"./error_codes/E0774.md\"),\n     E0722, // Malformed `#[optimize]` attribute\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n //  E0738, // Removed; errored on `#[track_caller] fn`s in `extern \"Rust\" { ... }`.\n-    E0756, // `#[ffi_const]` is only allowed on foreign functions\n     E0757, // `#[ffi_const]` functions cannot be `#[ffi_pure]`\n     E0772, // `'static' obligation coming from `impl dyn Trait {}` or `impl Foo for dyn Bar {}`.\n }"}, {"sha": "ffdc421aab58408f40ad0ff76109a7e1ebf18f89", "filename": "compiler/rustc_error_codes/src/error_codes/E0756.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_codes%2Fsrc%2Ferror_codes%2FE0756.md?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,29 @@\n+The `ffi_const` attribute was used on something other than a foreign function\n+declaration.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0756\n+#![feature(ffi_const)]\n+\n+#[ffi_const] // error!\n+pub fn foo() {}\n+# fn main() {}\n+```\n+\n+The `ffi_const` attribute can only be used on foreign function declarations\n+which have no side effects except for their return value:\n+\n+```\n+#![feature(ffi_const)]\n+\n+extern \"C\" {\n+    #[ffi_const] // ok!\n+    pub fn strlen(s: *const i8) -> i32;\n+}\n+# fn main() {}\n+```\n+\n+You can get more information about it in the [unstable Rust Book].\n+\n+[unstable Rust Book]: https://doc.rust-lang.org/nightly/unstable-book/language-features/ffi-const.html"}, {"sha": "441cfeea20a48d3a78894264e7d0eaff76dd3d7c", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -488,18 +488,16 @@ impl<'tcx> Visitor<'tcx> for HirTraitObjectVisitor {\n     }\n \n     fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        match t.kind {\n-            TyKind::TraitObject(\n-                poly_trait_refs,\n-                Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n-            ) => {\n-                for ptr in poly_trait_refs {\n-                    if Some(self.1) == ptr.trait_ref.trait_def_id() {\n-                        self.0.push(ptr.span);\n-                    }\n+        if let TyKind::TraitObject(\n+            poly_trait_refs,\n+            Lifetime { name: LifetimeName::ImplicitObjectLifetimeDefault, .. },\n+        ) = t.kind\n+        {\n+            for ptr in poly_trait_refs {\n+                if Some(self.1) == ptr.trait_ref.trait_def_id() {\n+                    self.0.push(ptr.span);\n                 }\n             }\n-            _ => {}\n         }\n         walk_ty(self, t);\n     }"}, {"sha": "abd899e8db4d33b6d9447bc7078dd15d296281b1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -613,6 +613,19 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n         );\n     }\n \n+    fn check_foreign_item(&mut self, cx: &LateContext<'_>, foreign_item: &hir::ForeignItem<'_>) {\n+        let def_id = cx.tcx.hir().local_def_id(foreign_item.hir_id);\n+        let (article, desc) = cx.tcx.article_and_description(def_id.to_def_id());\n+        self.check_missing_docs_attrs(\n+            cx,\n+            Some(foreign_item.hir_id),\n+            &foreign_item.attrs,\n+            foreign_item.span,\n+            article,\n+            desc,\n+        );\n+    }\n+\n     fn check_struct_field(&mut self, cx: &LateContext<'_>, sf: &hir::StructField<'_>) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs("}, {"sha": "c2d98b8e4ad378fa5bc308a30cd39dd18bbc0d27", "filename": "compiler/rustc_lint/src/internal.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_lint%2Fsrc%2Finternal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Finternal.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -5,7 +5,9 @@ use crate::{EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext}\n use rustc_ast::{Item, ItemKind};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n+use rustc_hir::def::Res;\n use rustc_hir::{GenericArg, HirId, MutTy, Mutability, Path, PathSegment, QPath, Ty, TyKind};\n+use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint, impl_lint_pass};\n use rustc_span::hygiene::{ExpnKind, MacroKind};\n use rustc_span::symbol::{sym, Ident, Symbol};\n@@ -177,11 +179,31 @@ fn lint_ty_kind_usage(cx: &LateContext<'_>, segment: &PathSegment<'_>) -> bool {\n fn is_ty_or_ty_ctxt(cx: &LateContext<'_>, ty: &Ty<'_>) -> Option<String> {\n     if let TyKind::Path(qpath) = &ty.kind {\n         if let QPath::Resolved(_, path) = qpath {\n-            let did = path.res.opt_def_id()?;\n-            if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n-                return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n-            } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n-                return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+            match path.res {\n+                Res::Def(_, did) => {\n+                    if cx.tcx.is_diagnostic_item(sym::Ty, did) {\n+                        return Some(format!(\"Ty{}\", gen_args(path.segments.last().unwrap())));\n+                    } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, did) {\n+                        return Some(format!(\"TyCtxt{}\", gen_args(path.segments.last().unwrap())));\n+                    }\n+                }\n+                // Only lint on `&Ty` and `&TyCtxt` if it is used outside of a trait.\n+                Res::SelfTy(None, Some((did, _))) => {\n+                    if let ty::Adt(adt, substs) = cx.tcx.type_of(did).kind() {\n+                        if cx.tcx.is_diagnostic_item(sym::Ty, adt.did) {\n+                            // NOTE: This path is currently unreachable as `Ty<'tcx>` is\n+                            // defined as a type alias meaning that `impl<'tcx> Ty<'tcx>`\n+                            // is not actually allowed.\n+                            //\n+                            // I(@lcnr) still kept this branch in so we don't miss this\n+                            // if we ever change it in the future.\n+                            return Some(format!(\"Ty<{}>\", substs[0]));\n+                        } else if cx.tcx.is_diagnostic_item(sym::TyCtxt, adt.did) {\n+                            return Some(format!(\"TyCtxt<{}>\", substs[0]));\n+                        }\n+                    }\n+                }\n+                _ => (),\n             }\n         }\n     }"}, {"sha": "ccc8ffd9a9c6e553eaa20f01312f08127a712448", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -1179,7 +1179,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         self.mk_const(ty::Const { val: ty::ConstKind::Error(DelaySpanBugEmitted(())), ty })\n     }\n \n-    pub fn consider_optimizing<T: Fn() -> String>(&self, msg: T) -> bool {\n+    pub fn consider_optimizing<T: Fn() -> String>(self, msg: T) -> bool {\n         let cname = self.crate_name(LOCAL_CRATE).as_str();\n         self.sess.consider_optimizing(&cname, msg)\n     }"}, {"sha": "342a37cadbac4375385e5c481850c694b3e3ef8c", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -834,14 +834,11 @@ fn foo(&self) -> Self::T { String::new() }\n                 kind: hir::ItemKind::Impl { items, .. }, ..\n             })) => {\n                 for item in &items[..] {\n-                    match item.kind {\n-                        hir::AssocItemKind::Type => {\n-                            if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n-                                db.span_label(item.span, \"expected this associated type\");\n-                                return true;\n-                            }\n+                    if let hir::AssocItemKind::Type = item.kind {\n+                        if self.type_of(self.hir().local_def_id(item.id.hir_id)) == found {\n+                            db.span_label(item.span, \"expected this associated type\");\n+                            return true;\n                         }\n-                        _ => {}\n                     }\n                 }\n             }\n@@ -853,7 +850,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// Given a slice of `hir::GenericBound`s, if any of them corresponds to the `trait_ref`\n     /// requirement, provide a strucuted suggestion to constrain it to a given type `ty`.\n     fn constrain_generic_bound_associated_type_structured_suggestion(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::TraitRef<'tcx>,\n         bounds: hir::GenericBounds<'_>,\n@@ -877,7 +874,7 @@ fn foo(&self) -> Self::T { String::new() }\n     /// Given a span corresponding to a bound, provide a structured suggestion to set an\n     /// associated type to a given type `ty`.\n     fn constrain_associated_type_structured_suggestion(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         span: Span,\n         assoc: &ty::AssocItem,"}, {"sha": "cb79b089d94a0156fd230f5234a59de330e764f0", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -1259,11 +1259,11 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                 tcx.layout_raw(param_env.and(normalized))?\n             }\n \n-            ty::Bound(..) | ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n+            ty::Placeholder(..) | ty::GeneratorWitness(..) | ty::Infer(_) => {\n                 bug!(\"Layout::compute: unexpected type `{}`\", ty)\n             }\n \n-            ty::Param(_) | ty::Error(_) => {\n+            ty::Bound(..) | ty::Param(_) | ty::Error(_) => {\n                 return Err(LayoutError::Unknown(ty));\n             }\n         })"}, {"sha": "c9cc9bfc9fa263ad80a49b996cae750bbf8d9e5c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -2125,17 +2125,10 @@ fn for_each_def(tcx: TyCtxt<'_>, mut collect_fn: impl for<'b> FnMut(&'b Ident, N\n     // Iterate all local crate items no matter where they are defined.\n     let hir = tcx.hir();\n     for item in hir.krate().items.values() {\n-        if item.ident.name.as_str().is_empty() {\n+        if item.ident.name.as_str().is_empty() || matches!(item.kind, ItemKind::Use(_, _)) {\n             continue;\n         }\n \n-        match item.kind {\n-            ItemKind::Use(_, _) => {\n-                continue;\n-            }\n-            _ => {}\n-        }\n-\n         if let Some(local_def_id) = hir.definitions().opt_hir_id_to_local_def_id(item.hir_id) {\n             let def_id = local_def_id.to_def_id();\n             let ns = tcx.def_kind(def_id).ns().unwrap_or(Namespace::TypeNS);"}, {"sha": "735f890a33bdc495eadff14f607780900b216877", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -549,15 +549,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // Early-return cases.\n         let val_val = match val.val {\n-            ty::ConstKind::Param(_) => throw_inval!(TooGeneric),\n+            ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(_) => throw_inval!(TypeckError(ErrorReported)),\n             ty::ConstKind::Unevaluated(def, substs, promoted) => {\n                 let instance = self.resolve(def, substs)?;\n                 return Ok(self.eval_to_allocation(GlobalId { instance, promoted })?.into());\n             }\n-            ty::ConstKind::Infer(..)\n-            | ty::ConstKind::Bound(..)\n-            | ty::ConstKind::Placeholder(..) => {\n+            ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", val)\n             }\n             ty::ConstKind::Value(val_val) => val_val,"}, {"sha": "c1b4cb5f1a8d54f7ab4ec4be441e3c5c8414a577", "filename": "compiler/rustc_mir/src/transform/check_consts/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fmod.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -4,10 +4,12 @@\n //! has interior mutability or needs to be dropped, as well as the visitor that emits errors when\n //! it finds operations that are invalid in a certain context.\n \n+use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::mir;\n use rustc_middle::ty::{self, TyCtxt};\n+use rustc_span::Symbol;\n \n pub use self::qualifs::Qualif;\n \n@@ -55,3 +57,9 @@ impl ConstCx<'mir, 'tcx> {\n pub fn is_lang_panic_fn(tcx: TyCtxt<'tcx>, def_id: DefId) -> bool {\n     Some(def_id) == tcx.lang_items().panic_fn() || Some(def_id) == tcx.lang_items().begin_panic_fn()\n }\n+\n+pub fn allow_internal_unstable(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bool {\n+    let attrs = tcx.get_attrs(def_id);\n+    attr::allow_internal_unstable(&tcx.sess, attrs)\n+        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+}"}, {"sha": "032cbc23a3f52d8c552224d289443ca767011854", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 88, "deletions": 54, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -1,6 +1,6 @@\n //! Concrete error types for all operations which may be invalid in a certain const context.\n \n-use rustc_errors::struct_span_err;\n+use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_session::config::nightly_options;\n@@ -14,35 +14,54 @@ use super::ConstCx;\n pub fn non_const<O: NonConstOp>(ccx: &ConstCx<'_, '_>, op: O, span: Span) {\n     debug!(\"illegal_op: op={:?}\", op);\n \n-    if op.is_allowed_in_item(ccx) {\n-        return;\n-    }\n+    let gate = match op.status_in_item(ccx) {\n+        Status::Allowed => return,\n+\n+        Status::Unstable(gate) if ccx.tcx.features().enabled(gate) => {\n+            let unstable_in_stable = ccx.const_kind() == hir::ConstContext::ConstFn\n+                && ccx.tcx.features().enabled(sym::staged_api)\n+                && !ccx.tcx.has_attr(ccx.def_id.to_def_id(), sym::rustc_const_unstable)\n+                && !super::allow_internal_unstable(ccx.tcx, ccx.def_id.to_def_id(), gate);\n+\n+            if unstable_in_stable {\n+                ccx.tcx.sess\n+                    .struct_span_err(span, &format!(\"`#[feature({})]` cannot be depended on in a const-stable function\", gate.as_str()))\n+                    .span_suggestion(\n+                        ccx.body.span,\n+                        \"if it is not part of the public API, make this function unstably const\",\n+                        concat!(r#\"#[rustc_const_unstable(feature = \"...\", issue = \"...\")]\"#, '\\n').to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    )\n+                    .help(\"otherwise `#[allow_internal_unstable]` can be used to bypass stability checks\")\n+                    .emit();\n+            }\n+\n+            return;\n+        }\n+\n+        Status::Unstable(gate) => Some(gate),\n+        Status::Forbidden => None,\n+    };\n \n     if ccx.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-        ccx.tcx.sess.miri_unleashed_feature(span, O::feature_gate());\n+        ccx.tcx.sess.miri_unleashed_feature(span, gate);\n         return;\n     }\n \n     op.emit_error(ccx, span);\n }\n \n+pub enum Status {\n+    Allowed,\n+    Unstable(Symbol),\n+    Forbidden,\n+}\n+\n /// An operation that is not *always* allowed in a const context.\n pub trait NonConstOp: std::fmt::Debug {\n-    /// Returns the `Symbol` corresponding to the feature gate that would enable this operation,\n-    /// or `None` if such a feature gate does not exist.\n-    fn feature_gate() -> Option<Symbol> {\n-        None\n-    }\n-\n-    /// Returns `true` if this operation is allowed in the given item.\n-    ///\n-    /// This check should assume that we are not in a non-const `fn`, where all operations are\n-    /// legal.\n-    ///\n-    /// By default, it returns `true` if and only if this operation has a corresponding feature\n-    /// gate and that gate is enabled.\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        Self::feature_gate().map_or(false, |gate| ccx.tcx.features().enabled(gate))\n+    /// Returns an enum indicating whether this operation is allowed within the given item.\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+        Status::Forbidden\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -53,9 +72,13 @@ pub trait NonConstOp: std::fmt::Debug {\n             \"{} contains unimplemented expression type\",\n             ccx.const_kind()\n         );\n-        if let Some(feat) = Self::feature_gate() {\n-            err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", feat));\n+\n+        if let Status::Unstable(gate) = self.status_in_item(ccx) {\n+            if !ccx.tcx.features().enabled(gate) && nightly_options::is_nightly_build() {\n+                err.help(&format!(\"add `#![feature({})]` to the crate attributes to enable\", gate));\n+            }\n         }\n+\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"A function call isn't allowed in the const's initialization expression \\\n@@ -147,7 +170,9 @@ pub struct InlineAsm;\n impl NonConstOp for InlineAsm {}\n \n #[derive(Debug)]\n-pub struct LiveDrop(pub Option<Span>);\n+pub struct LiveDrop {\n+    pub dropped_at: Option<Span>,\n+}\n impl NonConstOp for LiveDrop {\n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n         let mut diagnostic = struct_span_err!(\n@@ -157,7 +182,7 @@ impl NonConstOp for LiveDrop {\n             \"destructors cannot be evaluated at compile-time\"\n         );\n         diagnostic.span_label(span, format!(\"{}s cannot evaluate destructors\", ccx.const_kind()));\n-        if let Some(span) = self.0 {\n+        if let Some(span) = self.dropped_at {\n             diagnostic.span_label(span, \"value is dropped here\");\n         }\n         diagnostic.emit();\n@@ -182,14 +207,13 @@ impl NonConstOp for CellBorrow {\n #[derive(Debug)]\n pub struct MutBorrow;\n impl NonConstOp for MutBorrow {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        // Forbid everywhere except in const fn\n-        ccx.const_kind() == hir::ConstContext::ConstFn\n-            && ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n-    }\n-\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        // Forbid everywhere except in const fn with a feature gate\n+        if ccx.const_kind() == hir::ConstContext::ConstFn {\n+            Status::Unstable(sym::const_mut_refs)\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -201,15 +225,16 @@ impl NonConstOp for MutBorrow {\n                 &format!(\"mutable references are not allowed in {}s\", ccx.const_kind()),\n             )\n         } else {\n-            struct_span_err!(\n+            let mut err = struct_span_err!(\n                 ccx.tcx.sess,\n                 span,\n                 E0764,\n                 \"mutable references are not allowed in {}s\",\n                 ccx.const_kind(),\n-            )\n+            );\n+            err.span_label(span, format!(\"`&mut` is only allowed in `const fn`\"));\n+            err\n         };\n-        err.span_label(span, \"`&mut` is only allowed in `const fn`\".to_string());\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n@@ -226,11 +251,17 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n+// FIXME(ecstaticmorse): Unify this with `MutBorrow`. It has basically the same issues.\n #[derive(Debug)]\n pub struct MutAddressOf;\n impl NonConstOp for MutAddressOf {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        // Forbid everywhere except in const fn with a feature gate\n+        if ccx.const_kind() == hir::ConstContext::ConstFn {\n+            Status::Unstable(sym::const_mut_refs)\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -247,16 +278,16 @@ impl NonConstOp for MutAddressOf {\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_mut_refs)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_mut_refs)\n     }\n }\n \n #[derive(Debug)]\n pub struct Panic;\n impl NonConstOp for Panic {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_panic)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_panic)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -289,8 +320,8 @@ impl NonConstOp for RawPtrComparison {\n #[derive(Debug)]\n pub struct RawPtrDeref;\n impl NonConstOp for RawPtrDeref {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_raw_ptr_deref)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_raw_ptr_deref)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -307,8 +338,8 @@ impl NonConstOp for RawPtrDeref {\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n impl NonConstOp for RawPtrToIntCast {\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_raw_ptr_to_usize_cast)\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_raw_ptr_to_usize_cast)\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -326,8 +357,12 @@ impl NonConstOp for RawPtrToIntCast {\n #[derive(Debug)]\n pub struct StaticAccess;\n impl NonConstOp for StaticAccess {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n-        matches!(ccx.const_kind(), hir::ConstContext::Static(_))\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        if let hir::ConstContext::Static(_) = ccx.const_kind() {\n+            Status::Allowed\n+        } else {\n+            Status::Forbidden\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {\n@@ -371,14 +406,13 @@ impl NonConstOp for ThreadLocalAccess {\n #[derive(Debug)]\n pub struct UnionAccess;\n impl NonConstOp for UnionAccess {\n-    fn is_allowed_in_item(&self, ccx: &ConstCx<'_, '_>) -> bool {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n         // Union accesses are stable in all contexts except `const fn`.\n-        ccx.const_kind() != hir::ConstContext::ConstFn\n-            || ccx.tcx.features().enabled(Self::feature_gate().unwrap())\n-    }\n-\n-    fn feature_gate() -> Option<Symbol> {\n-        Some(sym::const_fn_union)\n+        if ccx.const_kind() != hir::ConstContext::ConstFn {\n+            Status::Allowed\n+        } else {\n+            Status::Unstable(sym::const_fn_union)\n+        }\n     }\n \n     fn emit_error(&self, ccx: &ConstCx<'_, '_>, span: Span) {"}, {"sha": "0228f2d7de023f87f7eb440e4b8bc597344ac230", "filename": "compiler/rustc_mir/src/transform/check_consts/post_drop_elaboration.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fpost_drop_elaboration.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -2,7 +2,7 @@ use rustc_hir::def_id::LocalDefId;\n use rustc_middle::mir::visit::Visitor;\n use rustc_middle::mir::{self, BasicBlock, Location};\n use rustc_middle::ty::TyCtxt;\n-use rustc_span::Span;\n+use rustc_span::{sym, Span};\n \n use super::ops;\n use super::qualifs::{NeedsDrop, Qualif};\n@@ -11,7 +11,12 @@ use super::ConstCx;\n \n /// Returns `true` if we should use the more precise live drop checker that runs after drop\n /// elaboration.\n-pub fn checking_enabled(tcx: TyCtxt<'tcx>) -> bool {\n+pub fn checking_enabled(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> bool {\n+    // Const-stable functions must always use the stable live drop checker.\n+    if tcx.features().staged_api && !tcx.has_attr(def_id.to_def_id(), sym::rustc_const_unstable) {\n+        return false;\n+    }\n+\n     tcx.features().const_precise_live_drops\n }\n \n@@ -25,7 +30,7 @@ pub fn check_live_drops(tcx: TyCtxt<'tcx>, def_id: LocalDefId, body: &mir::Body<\n         return;\n     }\n \n-    if !checking_enabled(tcx) {\n+    if !checking_enabled(tcx, def_id) {\n         return;\n     }\n \n@@ -52,7 +57,7 @@ impl std::ops::Deref for CheckLiveDrops<'mir, 'tcx> {\n \n impl CheckLiveDrops<'mir, 'tcx> {\n     fn check_live_drop(&self, span: Span) {\n-        ops::non_const(self.ccx, ops::LiveDrop(None), span);\n+        ops::non_const(self.ccx, ops::LiveDrop { dropped_at: None }, span);\n     }\n }\n "}, {"sha": "0501302b7610a089c0552f389b0f54895b1fd52b", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -551,7 +551,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n             | TerminatorKind::DropAndReplace { place: dropped_place, .. } => {\n                 // If we are checking live drops after drop-elaboration, don't emit duplicate\n                 // errors here.\n-                if super::post_drop_elaboration::checking_enabled(self.tcx) {\n+                if super::post_drop_elaboration::checking_enabled(self.tcx, self.def_id) {\n                     return;\n                 }\n \n@@ -576,7 +576,7 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                 if needs_drop {\n                     self.check_op_spanned(\n-                        ops::LiveDrop(Some(terminator.source_info.span)),\n+                        ops::LiveDrop { dropped_at: Some(terminator.source_info.span) },\n                         err_span,\n                     );\n                 }"}, {"sha": "cd361e430fa6108e0eb22ab7345698d739176c05", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -242,11 +242,8 @@ impl<'tcx> Visitor<'tcx> for Collector<'_, 'tcx> {\n             }\n             TerminatorKind::InlineAsm { ref operands, .. } => {\n                 for (index, op) in operands.iter().enumerate() {\n-                    match op {\n-                        InlineAsmOperand::Const { .. } => {\n-                            self.candidates.push(Candidate::InlineAsm { bb: location.block, index })\n-                        }\n-                        _ => {}\n+                    if let InlineAsmOperand::Const { .. } = op {\n+                        self.candidates.push(Candidate::InlineAsm { bb: location.block, index })\n                     }\n                 }\n             }\n@@ -612,12 +609,9 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 let operand_ty = operand.ty(self.body, self.tcx);\n                 let cast_in = CastTy::from_ty(operand_ty).expect(\"bad input type for cast\");\n                 let cast_out = CastTy::from_ty(cast_ty).expect(\"bad output type for cast\");\n-                match (cast_in, cast_out) {\n-                    (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) => {\n-                        // ptr-to-int casts are not possible in consts and thus not promotable\n-                        return Err(Unpromotable);\n-                    }\n-                    _ => {}\n+                if let (CastTy::Ptr(_) | CastTy::FnPtr, CastTy::Int(_)) = (cast_in, cast_out) {\n+                    // ptr-to-int casts are not possible in consts and thus not promotable\n+                    return Err(Unpromotable);\n                 }\n             }\n "}, {"sha": "f15a7f7c2c889c545b2808fe9e1793953377e32e", "filename": "compiler/rustc_mir/src/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fqualify_min_const_fn.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -1,4 +1,3 @@\n-use rustc_attr as attr;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::*;\n@@ -344,8 +343,7 @@ fn feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbol) -> bo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n }\n \n /// Returns `true` if the given library feature gate is allowed within the function with the given `DefId`.\n@@ -364,8 +362,7 @@ pub fn lib_feature_allowed(tcx: TyCtxt<'tcx>, def_id: DefId, feature_gate: Symbo\n \n     // However, we cannot allow stable `const fn`s to use unstable features without an explicit\n     // opt-in via `allow_internal_unstable`.\n-    attr::allow_internal_unstable(&tcx.sess, &tcx.get_attrs(def_id))\n-        .map_or(false, |mut features| features.any(|name| name == feature_gate))\n+    super::check_consts::allow_internal_unstable(tcx, def_id, feature_gate)\n }\n \n fn check_terminator("}, {"sha": "6233549dc8579782ade27903fb81e0c783e199aa", "filename": "compiler/rustc_parse/src/lexer/tokentrees.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flexer%2Ftokentrees.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -149,12 +149,9 @@ impl<'a> TokenTreesReader<'a> {\n                             }\n                         }\n \n-                        match (open_brace, delim) {\n-                            //only add braces\n-                            (DelimToken::Brace, DelimToken::Brace) => {\n-                                self.matching_block_spans.push((open_brace_span, close_brace_span));\n-                            }\n-                            _ => {}\n+                        //only add braces\n+                        if let (DelimToken::Brace, DelimToken::Brace) = (open_brace, delim) {\n+                            self.matching_block_spans.push((open_brace_span, close_brace_span));\n                         }\n \n                         if self.open_braces.is_empty() {"}, {"sha": "21bbdc9ba8dce05b14bd56770c88dfe7a4bd68a4", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -3,6 +3,7 @@\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n #![feature(bindings_after_at)]\n+#![feature(iter_order_by)]\n #![feature(or_patterns)]\n \n use rustc_ast as ast;\n@@ -459,14 +460,10 @@ pub fn tokenstream_probably_equal_for_proc_macro(\n \n     // Break tokens after we expand any nonterminals, so that we break tokens\n     // that are produced as a result of nonterminal expansion.\n-    let mut t1 = first.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n-    let mut t2 = other.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n-    for (t1, t2) in t1.by_ref().zip(t2.by_ref()) {\n-        if !tokentree_probably_equal_for_proc_macro(&t1, &t2, sess) {\n-            return false;\n-        }\n-    }\n-    t1.next().is_none() && t2.next().is_none()\n+    let t1 = first.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n+    let t2 = other.trees().filter(semantic_tree).flat_map(expand_nt).flat_map(break_tokens);\n+\n+    t1.eq_by(t2, |t1, t2| tokentree_probably_equal_for_proc_macro(&t1, &t2, sess))\n }\n \n // See comments in `Nonterminal::to_tokenstream` for why we care about"}, {"sha": "cef632b1d8f03180ced3f5017e0c833301acda04", "filename": "compiler/rustc_parse_format/src/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse_format%2Fsrc%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -525,12 +525,9 @@ impl<'a> Parser<'a> {\n \n         // fill character\n         if let Some(&(_, c)) = self.cur.peek() {\n-            match self.cur.clone().nth(1) {\n-                Some((_, '>' | '<' | '^')) => {\n-                    spec.fill = Some(c);\n-                    self.cur.next();\n-                }\n-                _ => {}\n+            if let Some((_, '>' | '<' | '^')) = self.cur.clone().nth(1) {\n+                spec.fill = Some(c);\n+                self.cur.next();\n             }\n         }\n         // Alignment"}, {"sha": "677cf27cde71cbd353f523530413dd49546b70e4", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -534,11 +534,8 @@ impl<'a> ModuleData<'a> {\n                 if ns != TypeNS {\n                     return;\n                 }\n-                match binding.res() {\n-                    Res::Def(DefKind::Trait | DefKind::TraitAlias, _) => {\n-                        collected_traits.push((name, binding))\n-                    }\n-                    _ => (),\n+                if let Res::Def(DefKind::Trait | DefKind::TraitAlias, _) = binding.res() {\n+                    collected_traits.push((name, binding))\n                 }\n             });\n             *traits = Some(collected_traits.into_boxed_slice());"}, {"sha": "4b02a2d4076d7749c0cb28a078bd0c129fb6ff71", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 55, "deletions": 82, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -1558,58 +1558,71 @@ pub trait Pos {\n     fn to_u32(&self) -> u32;\n }\n \n-/// A byte offset. Keep this small (currently 32-bits), as AST contains\n-/// a lot of them.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n-pub struct BytePos(pub u32);\n-\n-/// A character offset. Because of multibyte UTF-8 characters, a byte offset\n-/// is not equivalent to a character offset. The `SourceMap` will convert `BytePos`\n-/// values to `CharPos` values as necessary.\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]\n-pub struct CharPos(pub usize);\n+macro_rules! impl_pos {\n+    (\n+        $(\n+            $(#[$attr:meta])*\n+            $vis:vis struct $ident:ident($inner_vis:vis $inner_ty:ty);\n+        )*\n+    ) => {\n+        $(\n+            $(#[$attr])*\n+            $vis struct $ident($inner_vis $inner_ty);\n+\n+            impl Pos for $ident {\n+                #[inline(always)]\n+                fn from_usize(n: usize) -> $ident {\n+                    $ident(n as $inner_ty)\n+                }\n \n-// FIXME: lots of boilerplate in these impls, but so far my attempts to fix\n-// have been unsuccessful.\n+                #[inline(always)]\n+                fn to_usize(&self) -> usize {\n+                    self.0 as usize\n+                }\n \n-impl Pos for BytePos {\n-    #[inline(always)]\n-    fn from_usize(n: usize) -> BytePos {\n-        BytePos(n as u32)\n-    }\n+                #[inline(always)]\n+                fn from_u32(n: u32) -> $ident {\n+                    $ident(n as $inner_ty)\n+                }\n \n-    #[inline(always)]\n-    fn to_usize(&self) -> usize {\n-        self.0 as usize\n-    }\n+                #[inline(always)]\n+                fn to_u32(&self) -> u32 {\n+                    self.0 as u32\n+                }\n+            }\n \n-    #[inline(always)]\n-    fn from_u32(n: u32) -> BytePos {\n-        BytePos(n)\n-    }\n+            impl Add for $ident {\n+                type Output = $ident;\n \n-    #[inline(always)]\n-    fn to_u32(&self) -> u32 {\n-        self.0\n-    }\n-}\n+                #[inline(always)]\n+                fn add(self, rhs: $ident) -> $ident {\n+                    $ident(self.0 + rhs.0)\n+                }\n+            }\n \n-impl Add for BytePos {\n-    type Output = BytePos;\n+            impl Sub for $ident {\n+                type Output = $ident;\n \n-    #[inline(always)]\n-    fn add(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_usize() + rhs.to_usize()) as u32)\n-    }\n+                #[inline(always)]\n+                fn sub(self, rhs: $ident) -> $ident {\n+                    $ident(self.0 - rhs.0)\n+                }\n+            }\n+        )*\n+    };\n }\n \n-impl Sub for BytePos {\n-    type Output = BytePos;\n+impl_pos! {\n+    /// A byte offset. Keep this small (currently 32-bits), as AST contains\n+    /// a lot of them.\n+    #[derive(Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord, Debug)]\n+    pub struct BytePos(pub u32);\n \n-    #[inline(always)]\n-    fn sub(self, rhs: BytePos) -> BytePos {\n-        BytePos((self.to_usize() - rhs.to_usize()) as u32)\n-    }\n+    /// A character offset. Because of multibyte UTF-8 characters, a byte offset\n+    /// is not equivalent to a character offset. The `SourceMap` will convert `BytePos`\n+    /// values to `CharPos` values as necessary.\n+    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug)]\n+    pub struct CharPos(pub usize);\n }\n \n impl<S: rustc_serialize::Encoder> Encodable<S> for BytePos {\n@@ -1624,46 +1637,6 @@ impl<D: rustc_serialize::Decoder> Decodable<D> for BytePos {\n     }\n }\n \n-impl Pos for CharPos {\n-    #[inline(always)]\n-    fn from_usize(n: usize) -> CharPos {\n-        CharPos(n)\n-    }\n-\n-    #[inline(always)]\n-    fn to_usize(&self) -> usize {\n-        self.0\n-    }\n-\n-    #[inline(always)]\n-    fn from_u32(n: u32) -> CharPos {\n-        CharPos(n as usize)\n-    }\n-\n-    #[inline(always)]\n-    fn to_u32(&self) -> u32 {\n-        self.0 as u32\n-    }\n-}\n-\n-impl Add for CharPos {\n-    type Output = CharPos;\n-\n-    #[inline(always)]\n-    fn add(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_usize() + rhs.to_usize())\n-    }\n-}\n-\n-impl Sub for CharPos {\n-    type Output = CharPos;\n-\n-    #[inline(always)]\n-    fn sub(self, rhs: CharPos) -> CharPos {\n-        CharPos(self.to_usize() - rhs.to_usize())\n-    }\n-}\n-\n // _____________________________________________________________________________\n // Loc, SourceFileAndLine, SourceFileAndBytePos\n //"}, {"sha": "091d488138e464528c69fe9fb36b08d6153ff3d4", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -152,11 +152,8 @@ impl SymbolMangler<'tcx> {\n         let _ = write!(self.out, \"{}\", ident.len());\n \n         // Write a separating `_` if necessary (leading digit or `_`).\n-        match ident.chars().next() {\n-            Some('_' | '0'..='9') => {\n-                self.push(\"_\");\n-            }\n-            _ => {}\n+        if let Some('_' | '0'..='9') = ident.chars().next() {\n+            self.push(\"_\");\n         }\n \n         self.push(ident);"}, {"sha": "e33dddc4f984183730d669885632f07828704c0d", "filename": "library/alloc/src/raw_vec.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Falloc%2Fsrc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Falloc%2Fsrc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fraw_vec.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -306,11 +306,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     /// # }\n     /// ```\n     pub fn reserve(&mut self, len: usize, additional: usize) {\n-        match self.try_reserve(len, additional) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n+        handle_reserve(self.try_reserve(len, additional));\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n@@ -340,11 +336,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn reserve_exact(&mut self, len: usize, additional: usize) {\n-        match self.try_reserve_exact(len, additional) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n+        handle_reserve(self.try_reserve_exact(len, additional));\n     }\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n@@ -367,11 +359,7 @@ impl<T, A: AllocRef> RawVec<T, A> {\n     ///\n     /// Aborts on OOM.\n     pub fn shrink_to_fit(&mut self, amount: usize) {\n-        match self.shrink(amount) {\n-            Err(CapacityOverflow) => capacity_overflow(),\n-            Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n-            Ok(()) => { /* yay */ }\n-        }\n+        handle_reserve(self.shrink(amount));\n     }\n }\n \n@@ -517,6 +505,16 @@ unsafe impl<#[may_dangle] T, A: AllocRef> Drop for RawVec<T, A> {\n     }\n }\n \n+// Central function for reserve error handling.\n+#[inline]\n+fn handle_reserve(result: Result<(), TryReserveError>) {\n+    match result {\n+        Err(CapacityOverflow) => capacity_overflow(),\n+        Err(AllocError { layout, .. }) => handle_alloc_error(layout),\n+        Ok(()) => { /* yay */ }\n+    }\n+}\n+\n // We need to guarantee the following:\n // * We don't ever allocate `> isize::MAX` byte-size objects.\n // * We don't overflow `usize::MAX` and actually allocate too little."}, {"sha": "9de0f76cbdd2cdb565add1abd273b7263d7a4e68", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -78,6 +78,7 @@\n #![feature(const_int_pow)]\n #![feature(constctlz)]\n #![feature(const_panic)]\n+#![feature(const_pin)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n #![feature(const_option)]"}, {"sha": "d86939454be5b0c4432dec7fe6c97a90da0c5e48", "filename": "library/core/src/mem/manually_drop.rs", "status": "modified", "additions": 19, "deletions": 36, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmem%2Fmanually_drop.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -15,50 +15,33 @@ use crate::ptr;\n /// be exposed through a public safe API.\n /// Correspondingly, `ManuallyDrop::drop` is unsafe.\n ///\n-/// # Examples\n+/// # `ManuallyDrop` and drop order.\n ///\n-/// This wrapper can be used to enforce a particular drop order on fields, regardless\n-/// of how they are defined in the struct:\n+/// Rust has a well-defined [drop order] of values. To make sure that fields or\n+/// locals are dropped in a specific order, reorder the declarations such that\n+/// the implicit drop order is the correct one.\n ///\n-/// ```rust\n-/// use std::mem::ManuallyDrop;\n-/// struct Peach;\n-/// struct Banana;\n-/// struct Melon;\n-/// struct FruitBox {\n-///     // Immediately clear there\u2019s something non-trivial going on with these fields.\n-///     peach: ManuallyDrop<Peach>,\n-///     melon: Melon, // Field that\u2019s independent of the other two.\n-///     banana: ManuallyDrop<Banana>,\n-/// }\n+/// It is possible to use `ManuallyDrop` to control the drop order, but this\n+/// requires unsafe code and is hard to do correctly in the presence of\n+/// unwinding.\n ///\n-/// impl Drop for FruitBox {\n-///     fn drop(&mut self) {\n-///         unsafe {\n-///             // Explicit ordering in which field destructors are run specified in the intuitive\n-///             // location \u2013 the destructor of the structure containing the fields.\n-///             // Moreover, one can now reorder fields within the struct however much they want.\n-///             ManuallyDrop::drop(&mut self.peach);\n-///             ManuallyDrop::drop(&mut self.banana);\n-///         }\n-///         // After destructor for `FruitBox` runs (this function), the destructor for Melon gets\n-///         // invoked in the usual manner, as it is not wrapped in `ManuallyDrop`.\n-///     }\n-/// }\n-/// ```\n+/// For example, if you want to make sure that a specific field is dropped after\n+/// the others, make it the last field of a struct:\n ///\n-/// However, care should be taken when using this pattern as it can lead to *leak amplification*.\n-/// In this example, if the `Drop` implementation for `Peach` were to panic, the `banana` field\n-/// would also be leaked.\n+/// ```\n+/// struct Context;\n ///\n-/// In contrast, the automatically-generated compiler drop implementation would have ensured\n-/// that all fields are dropped even in the presence of panics. This is especially important when\n-/// working with [pinned] data, where reusing the memory without calling the destructor could lead\n-/// to Undefined Behaviour.\n+/// struct Widget {\n+///     children: Vec<Widget>,\n+///     // `context` will be dropped after `children`.\n+///     // Rust guarantees that fields are dropped in the order of declaration.\n+///     context: Context,\n+/// }\n+/// ```\n ///\n+/// [drop order]: https://doc.rust-lang.org/reference/destructors.html\n /// [`mem::zeroed`]: crate::mem::zeroed\n /// [`MaybeUninit<T>`]: crate::mem::MaybeUninit\n-/// [pinned]: crate::pin\n #[stable(feature = \"manually_drop\", since = \"1.20.0\")]\n #[lang = \"manually_drop\"]\n #[derive(Copy, Clone, Debug, Default, PartialEq, Eq, PartialOrd, Ord, Hash)]"}, {"sha": "9f0284d5d95425e0fd6a3d68ac1a23fd63dd47c5", "filename": "library/core/src/pin.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Fsrc%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fpin.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -471,9 +471,10 @@ impl<P: Deref<Target: Unpin>> Pin<P> {\n     ///\n     /// Unlike `Pin::new_unchecked`, this method is safe because the pointer\n     /// `P` dereferences to an [`Unpin`] type, which cancels the pinning guarantees.\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn new(pointer: P) -> Pin<P> {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub const fn new(pointer: P) -> Pin<P> {\n         // SAFETY: the value pointed to is `Unpin`, and so has no requirements\n         // around pinning.\n         unsafe { Pin::new_unchecked(pointer) }\n@@ -483,9 +484,10 @@ impl<P: Deref<Target: Unpin>> Pin<P> {\n     ///\n     /// This requires that the data inside this `Pin` is [`Unpin`] so that we\n     /// can ignore the pinning invariants when unwrapping it.\n-    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n-    pub fn into_inner(pin: Pin<P>) -> P {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n+    pub const fn into_inner(pin: Pin<P>) -> P {\n         pin.pointer\n     }\n }\n@@ -556,9 +558,10 @@ impl<P: Deref> Pin<P> {\n     ///\n     /// [`mem::swap`]: crate::mem::swap\n     #[lang = \"new_unchecked\"]\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub const unsafe fn new_unchecked(pointer: P) -> Pin<P> {\n         Pin { pointer }\n     }\n \n@@ -589,9 +592,10 @@ impl<P: Deref> Pin<P> {\n     ///\n     /// If the underlying data is [`Unpin`], [`Pin::into_inner`] should be used\n     /// instead.\n-    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n     #[inline(always)]\n-    pub unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin_into_inner\", since = \"1.39.0\")]\n+    pub const unsafe fn into_inner_unchecked(pin: Pin<P>) -> P {\n         pin.pointer\n     }\n }\n@@ -693,18 +697,20 @@ impl<'a, T: ?Sized> Pin<&'a T> {\n     /// with the same lifetime as the original `Pin`.\n     ///\n     /// [\"pinning projections\"]: self#projections-and-structural-pinning\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_ref(self) -> &'a T {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub const fn get_ref(self) -> &'a T {\n         self.pointer\n     }\n }\n \n impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// Converts this `Pin<&mut T>` into a `Pin<&T>` with the same lifetime.\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn into_ref(self) -> Pin<&'a T> {\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    pub const fn into_ref(self) -> Pin<&'a T> {\n         Pin { pointer: self.pointer }\n     }\n \n@@ -717,9 +723,10 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     /// that lives for as long as the borrow of the `Pin`, not the lifetime of\n     /// the `Pin` itself. This method allows turning the `Pin` into a reference\n     /// with the same lifetime as the original `Pin`.\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub fn get_mut(self) -> &'a mut T\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    pub const fn get_mut(self) -> &'a mut T\n     where\n         T: Unpin,\n     {\n@@ -736,9 +743,10 @@ impl<'a, T: ?Sized> Pin<&'a mut T> {\n     ///\n     /// If the underlying data is `Unpin`, `Pin::get_mut` should be used\n     /// instead.\n-    #[stable(feature = \"pin\", since = \"1.33.0\")]\n     #[inline(always)]\n-    pub unsafe fn get_unchecked_mut(self) -> &'a mut T {\n+    #[stable(feature = \"pin\", since = \"1.33.0\")]\n+    #[rustc_const_unstable(feature = \"const_pin\", issue = \"76654\")]\n+    pub const unsafe fn get_unchecked_mut(self) -> &'a mut T {\n         self.pointer\n     }\n "}, {"sha": "7e75c7cf47bf6b251cfc29ecb309b07c7acb0131", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -43,6 +43,8 @@\n #![feature(iter_order_by)]\n #![feature(cmp_min_max_by)]\n #![feature(iter_map_while)]\n+#![feature(const_mut_refs)]\n+#![feature(const_pin)]\n #![feature(const_slice_from_raw_parts)]\n #![feature(const_raw_ptr_deref)]\n #![feature(never_type)]\n@@ -79,6 +81,7 @@ mod num;\n mod ops;\n mod option;\n mod pattern;\n+mod pin;\n mod ptr;\n mod result;\n mod slice;"}, {"sha": "6f617c8d0c2970b54d87a3038d07e1d837b85123", "filename": "library/core/tests/pin.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Ftests%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fcore%2Ftests%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fpin.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,31 @@\n+use core::pin::Pin;\n+\n+#[test]\n+fn pin_const() {\n+    // test that the methods of `Pin` are usable in a const context\n+\n+    const POINTER: &'static usize = &2;\n+\n+    const PINNED: Pin<&'static usize> = Pin::new(POINTER);\n+    const PINNED_UNCHECKED: Pin<&'static usize> = unsafe { Pin::new_unchecked(POINTER) };\n+    assert_eq!(PINNED_UNCHECKED, PINNED);\n+\n+    const INNER: &'static usize = Pin::into_inner(PINNED);\n+    assert_eq!(INNER, POINTER);\n+\n+    const INNER_UNCHECKED: &'static usize = unsafe { Pin::into_inner_unchecked(PINNED) };\n+    assert_eq!(INNER_UNCHECKED, POINTER);\n+\n+    const REF: &'static usize = PINNED.get_ref();\n+    assert_eq!(REF, POINTER);\n+\n+    // Note: `pin_mut_const` tests that the methods of `Pin<&mut T>` are usable in a const context.\n+    // A const fn is used because `&mut` is not (yet) usable in constants.\n+    const fn pin_mut_const() {\n+        let _ = Pin::new(&mut 2).into_ref();\n+        let _ = Pin::new(&mut 2).get_mut();\n+        let _ = unsafe { Pin::new(&mut 2).get_unchecked_mut() };\n+    }\n+\n+    pin_mut_const();\n+}"}, {"sha": "71ed2d84cad0d5fbcb630e359c7048071cf44fdd", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -586,6 +586,32 @@ impl fmt::Debug for Stdout {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stdout {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (&*self).write(buf)\n+    }\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        (&*self).write_vectored(bufs)\n+    }\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        io::Write::is_write_vectored(&&*self)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        (&*self).write_all(buf)\n+    }\n+    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n+        (&*self).write_all_vectored(bufs)\n+    }\n+    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n+        (&*self).write_fmt(args)\n+    }\n+}\n+\n+#[stable(feature = \"write_mt\", since = \"1.48.0\")]\n+impl Write for &Stdout {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.lock().write(buf)\n     }\n@@ -609,6 +635,7 @@ impl Write for Stdout {\n         self.lock().write_fmt(args)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for StdoutLock<'_> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n@@ -762,6 +789,32 @@ impl fmt::Debug for Stderr {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for Stderr {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (&*self).write(buf)\n+    }\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        (&*self).write_vectored(bufs)\n+    }\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        io::Write::is_write_vectored(&&*self)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+    fn write_all(&mut self, buf: &[u8]) -> io::Result<()> {\n+        (&*self).write_all(buf)\n+    }\n+    fn write_all_vectored(&mut self, bufs: &mut [IoSlice<'_>]) -> io::Result<()> {\n+        (&*self).write_all_vectored(bufs)\n+    }\n+    fn write_fmt(&mut self, args: fmt::Arguments<'_>) -> io::Result<()> {\n+        (&*self).write_fmt(args)\n+    }\n+}\n+\n+#[stable(feature = \"write_mt\", since = \"1.48.0\")]\n+impl Write for &Stderr {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.lock().write(buf)\n     }\n@@ -785,6 +838,7 @@ impl Write for Stderr {\n         self.lock().write_fmt(args)\n     }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl Write for StderrLock<'_> {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {"}, {"sha": "dc05b9648fd6be2bf5a351fecbfdaecafdf7f396", "filename": "library/std/src/io/util.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Futil.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -254,6 +254,30 @@ impl Write for Sink {\n     }\n }\n \n+#[stable(feature = \"write_mt\", since = \"1.48.0\")]\n+impl Write for &Sink {\n+    #[inline]\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        Ok(buf.len())\n+    }\n+\n+    #[inline]\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        let total_len = bufs.iter().map(|b| b.len()).sum();\n+        Ok(total_len)\n+    }\n+\n+    #[inline]\n+    fn is_write_vectored(&self) -> bool {\n+        true\n+    }\n+\n+    #[inline]\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n #[stable(feature = \"std_debug\", since = \"1.16.0\")]\n impl fmt::Debug for Sink {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {"}, {"sha": "9f3796e11ed1aa6a8c8c0c06a28cc926382f95a8", "filename": "library/std/src/process.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/library%2Fstd%2Fsrc%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fprocess.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -249,6 +249,25 @@ pub struct ChildStdin {\n \n #[stable(feature = \"process\", since = \"1.0.0\")]\n impl Write for ChildStdin {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        (&*self).write(buf)\n+    }\n+\n+    fn write_vectored(&mut self, bufs: &[IoSlice<'_>]) -> io::Result<usize> {\n+        (&*self).write_vectored(bufs)\n+    }\n+\n+    fn is_write_vectored(&self) -> bool {\n+        io::Write::is_write_vectored(&&*self)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        (&*self).flush()\n+    }\n+}\n+\n+#[stable(feature = \"write_mt\", since = \"1.48.0\")]\n+impl Write for &ChildStdin {\n     fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n         self.inner.write(buf)\n     }"}, {"sha": "31e8c32f062ab4adefcc451d395f154db7e3ef83", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 22, "deletions": 19, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -352,14 +352,22 @@ pub fn build_impl(\n         }\n     }\n \n-    let for_ = if let Some(did) = did.as_local() {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n-        match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n-            _ => panic!(\"did given to build_impl was not an impl\"),\n+    let impl_item = match did.as_local() {\n+        Some(did) => {\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n+            match tcx.hir().expect_item(hir_id).kind {\n+                hir::ItemKind::Impl { self_ty, ref generics, ref items, .. } => {\n+                    Some((self_ty, generics, items))\n+                }\n+                _ => panic!(\"`DefID` passed to `build_impl` is not an `impl\"),\n+            }\n         }\n-    } else {\n-        tcx.type_of(did).clean(cx)\n+        None => None,\n+    };\n+\n+    let for_ = match impl_item {\n+        Some((self_ty, _, _)) => self_ty.clean(cx),\n+        None => tcx.type_of(did).clean(cx),\n     };\n \n     // Only inline impl if the implementing type is\n@@ -379,17 +387,12 @@ pub fn build_impl(\n     }\n \n     let predicates = tcx.explicit_predicates_of(did);\n-    let (trait_items, generics) = if let Some(did) = did.as_local() {\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n-        match tcx.hir().expect_item(hir_id).kind {\n-            hir::ItemKind::Impl { ref generics, ref items, .. } => (\n-                items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n-                generics.clean(cx),\n-            ),\n-            _ => panic!(\"did given to build_impl was not an impl\"),\n-        }\n-    } else {\n-        (\n+    let (trait_items, generics) = match impl_item {\n+        Some((_, generics, items)) => (\n+            items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n+            generics.clean(cx),\n+        ),\n+        None => (\n             tcx.associated_items(did)\n                 .in_definition_order()\n                 .filter_map(|item| {\n@@ -401,7 +404,7 @@ pub fn build_impl(\n                 })\n                 .collect::<Vec<_>>(),\n             clean::enter_impl_trait(cx, || (tcx.generics_of(did), predicates).clean(cx)),\n-        )\n+        ),\n     };\n     let polarity = tcx.impl_polarity(did);\n     let trait_ = associated_trait.clean(cx).map(|bound| match bound {"}, {"sha": "f58446d55922239f1f5285ed5bda281f60237554", "filename": "src/test/ui-fulldeps/internal-lints/pass_ty_by_ref_self.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,33 @@\n+// NOTE: This test doesn't actually require `fulldeps`\n+// so we could instead use it as an `ui` test.\n+//\n+// Considering that all other `internal-lints` are tested here\n+// this seems like the cleaner solution though.\n+#![feature(rustc_attrs)]\n+#![deny(rustc::ty_pass_by_reference)]\n+#![allow(unused)]\n+\n+#[rustc_diagnostic_item = \"TyCtxt\"]\n+struct TyCtxt<'tcx> {\n+    inner: &'tcx (),\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    fn by_value(self) {} // OK\n+    fn by_ref(&self) {} //~ ERROR passing `TyCtxt<'tcx>` by reference\n+}\n+\n+\n+struct TyS<'tcx> {\n+    inner: &'tcx (),\n+}\n+\n+#[rustc_diagnostic_item = \"Ty\"]\n+type Ty<'tcx> = &'tcx TyS<'tcx>;\n+\n+impl<'tcx> TyS<'tcx> {\n+    fn by_value(self: Ty<'tcx>) {}\n+    fn by_ref(self: &Ty<'tcx>) {} //~ ERROR passing `Ty<'tcx>` by reference\n+}\n+\n+fn main() {}"}, {"sha": "b846b30f4ed3794b039570814fe29fc70ba56240", "filename": "src/test/ui-fulldeps/internal-lints/pass_ty_by_ref_self.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fpass_ty_by_ref_self.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,20 @@\n+error: passing `TyCtxt<'tcx>` by reference\n+  --> $DIR/pass_ty_by_ref_self.rs:17:15\n+   |\n+LL |     fn by_ref(&self) {}\n+   |               ^^^^^ help: try passing by value: `TyCtxt<'tcx>`\n+   |\n+note: the lint level is defined here\n+  --> $DIR/pass_ty_by_ref_self.rs:7:9\n+   |\n+LL | #![deny(rustc::ty_pass_by_reference)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: passing `Ty<'tcx>` by reference\n+  --> $DIR/pass_ty_by_ref_self.rs:30:21\n+   |\n+LL |     fn by_ref(self: &Ty<'tcx>) {}\n+   |                     ^^^^^^^^^ help: try passing by value: `Ty<'tcx>`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "351d6849af5db26a3214e8fc605a6721b53d9537", "filename": "src/test/ui/const-generics/issues/issue-73260.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -Zsave-analysis\n+\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+struct Arr<const N: usize>\n+where Assert::<{N < usize::max_value() / 2}>: IsTrue, //~ ERROR constant expression\n+{\n+}\n+\n+enum Assert<const CHECK: bool> {}\n+\n+trait IsTrue {}\n+\n+impl IsTrue for Assert<true> {}\n+\n+fn main() {\n+    let x: Arr<{usize::max_value()}> = Arr {};\n+    //~^ ERROR mismatched types\n+    //~| ERROR mismatched types\n+}"}, {"sha": "e22612ed5ea63ee9be0a6e2e029d9d03a0a65efa", "filename": "src/test/ui/const-generics/issues/issue-73260.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-73260.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,29 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-73260.rs:6:47\n+   |\n+LL | where Assert::<{N < usize::max_value() / 2}>: IsTrue,\n+   |                                               ^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-73260.rs:17:12\n+   |\n+LL |     let x: Arr<{usize::max_value()}> = Arr {};\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `false`, found `true`\n+   |\n+   = note: expected type `false`\n+              found type `true`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/issue-73260.rs:17:40\n+   |\n+LL |     let x: Arr<{usize::max_value()}> = Arr {};\n+   |                                        ^^^ expected `false`, found `true`\n+   |\n+   = note: expected type `false`\n+              found type `true`\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "0f23fa92c367967655b73ee5567d8b8d1044df50", "filename": "src/test/ui/const-generics/issues/issue-74634.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,27 @@\n+#![feature(const_generics)]\n+#![allow(incomplete_features)]\n+\n+trait If<const COND: bool> {}\n+impl If<true> for () {}\n+\n+trait IsZero<const N: u8> {\n+    type Answer;\n+}\n+\n+struct True;\n+struct False;\n+\n+impl<const N: u8> IsZero<N> for ()\n+where (): If<{N == 0}> { //~ERROR constant expression\n+    type Answer = True;\n+}\n+\n+trait Foobar<const N: u8> {}\n+\n+impl<const N: u8> Foobar<N> for ()\n+where (): IsZero<N, Answer = True> {}\n+\n+impl<const N: u8> Foobar<N> for ()\n+where (): IsZero<N, Answer = False> {}\n+\n+fn main() {}"}, {"sha": "091a1ac7b9981bd804bfa6b221ffd5c8e497c937", "filename": "src/test/ui/const-generics/issues/issue-74634.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-74634.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,10 @@\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-74634.rs:15:11\n+   |\n+LL | where (): If<{N == 0}> {\n+   |           ^^^^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to previous error\n+"}, {"sha": "0a16ca181f557ea3f90f988c620e8f500aed1d67", "filename": "src/test/ui/const-generics/issues/issue-76595.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,18 @@\n+#![feature(const_generics, const_evaluatable_checked)]\n+#![allow(incomplete_features)]\n+\n+struct Bool<const B: bool>;\n+\n+trait True {}\n+\n+impl True for Bool<true> {}\n+\n+fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n+    todo!()\n+}\n+\n+fn main() {\n+    test::<2>();\n+    //~^ ERROR wrong number of type\n+    //~| ERROR constant expression depends\n+}"}, {"sha": "2e457595393ca6e65d79cc5520836ce4ffe093ea", "filename": "src/test/ui/const-generics/issues/issue-76595.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-76595.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,20 @@\n+error[E0107]: wrong number of type arguments: expected 1, found 0\n+  --> $DIR/issue-76595.rs:15:5\n+   |\n+LL |     test::<2>();\n+   |     ^^^^^^^^^ expected 1 type argument\n+\n+error: constant expression depends on a generic parameter\n+  --> $DIR/issue-76595.rs:15:5\n+   |\n+LL | fn test<T, const P: usize>() where Bool<{core::mem::size_of::<T>() > 4}>: True {\n+   |                                                                           ---- required by this bound in `test`\n+...\n+LL |     test::<2>();\n+   |     ^^^^^^^^^\n+   |\n+   = note: this may fail depending on what value the parameter takes\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0107`."}, {"sha": "66ea9d5924dfb6157740e1aa7386534e36226f48", "filename": "src/test/ui/consts/miri_unleashed/box.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fbox.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -21,7 +21,7 @@ help: skipping check for `const_mut_refs` feature\n    |\n LL |     &mut *(box 0)\n    |     ^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/box.rs:10:5\n    |\n LL |     &mut *(box 0)"}, {"sha": "c6180c1e0041c97bf9b5a77bf958fd5376ad5da1", "filename": "src/test/ui/consts/miri_unleashed/mutable_references.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -6,17 +6,17 @@ LL |     *OH_YES = 99;\n \n warning: skipping const checks\n    |\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:9:26\n    |\n LL | static FOO: &&mut u32 = &&mut 42;\n    |                          ^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:13:23\n    |\n LL | static BAR: &mut () = &mut ();\n    |                       ^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:18:28\n    |\n LL | static BOO: &mut Foo<()> = &mut Foo(());\n@@ -26,7 +26,7 @@ help: skipping check that does not even have a feature gate\n    |\n LL |     x: &UnsafeCell::new(42),\n    |        ^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references.rs:30:27\n    |\n LL | static OH_YES: &mut i32 = &mut 42;"}, {"sha": "7647a9ff4f6e4c69271047dc8a53b8157dad24c8", "filename": "src/test/ui/consts/miri_unleashed/mutable_references_err.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fmutable_references_err.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -30,7 +30,7 @@ help: skipping check that does not even have a feature gate\n    |\n LL | const SNEAKY: &dyn Sync = &Synced { x: UnsafeCell::new(42) };\n    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check for `const_mut_refs` feature\n+help: skipping check that does not even have a feature gate\n   --> $DIR/mutable_references_err.rs:30:25\n    |\n LL | const BLUNT: &mut i32 = &mut 42;"}, {"sha": "651462d7ef19c4476e10e5b34f7d1dc2f9e2b630", "filename": "src/test/ui/consts/stable-precise-live-drops-in-libcore.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,22 @@\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+#![feature(staged_api)]\n+#![feature(const_precise_live_drops, const_fn)]\n+\n+enum Either<T, S> {\n+    Left(T),\n+    Right(S),\n+}\n+\n+impl<T> Either<T, T> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_stable(feature = \"foo\", since = \"1.0.0\")]\n+    pub const fn unwrap(self) -> T {\n+        //~^ ERROR destructors cannot be evaluated at compile-time\n+        match self {\n+            Self::Left(t) => t,\n+            Self::Right(t) => t,\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "a3f513541dd6a6ebd2b73c49458c7537326a4afd", "filename": "src/test/ui/consts/stable-precise-live-drops-in-libcore.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstable-precise-live-drops-in-libcore.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,12 @@\n+error[E0493]: destructors cannot be evaluated at compile-time\n+  --> $DIR/stable-precise-live-drops-in-libcore.rs:13:25\n+   |\n+LL |     pub const fn unwrap(self) -> T {\n+   |                         ^^^^ constant functions cannot evaluate destructors\n+...\n+LL |     }\n+   |     - value is dropped here\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0493`."}, {"sha": "619084eaa517a1895a5d286b93a996840c77557c", "filename": "src/test/ui/consts/unstable-precise-live-drops-in-libcore.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-precise-live-drops-in-libcore.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -0,0 +1,23 @@\n+// check-pass\n+\n+#![stable(feature = \"core\", since = \"1.6.0\")]\n+#![feature(staged_api)]\n+#![feature(const_precise_live_drops)]\n+\n+enum Either<T, S> {\n+    Left(T),\n+    Right(S),\n+}\n+\n+impl<T> Either<T, T> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_const_unstable(feature = \"foo\", issue = \"none\")]\n+    pub const fn unwrap(self) -> T {\n+        match self {\n+            Self::Left(t) => t,\n+            Self::Right(t) => t,\n+        }\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "bc3c12eaf981b96f663a1d2b662f7d69b2e2139d", "filename": "src/test/ui/ffi_const.stderr", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fffi_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Fffi_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fffi_const.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -6,3 +6,4 @@ LL | #[ffi_const]\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0756`."}, {"sha": "2297257919ee14cbb52fe5e1d42a2a14240bda41", "filename": "src/test/ui/lint/lint-missing-doc.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.rs?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -2,7 +2,7 @@\n // injected intrinsics by the compiler.\n #![deny(missing_docs)]\n #![allow(dead_code)]\n-#![feature(associated_type_defaults)]\n+#![feature(associated_type_defaults, extern_types)]\n \n //! Some garbage docs for the crate here\n #![doc=\"More garbage\"]\n@@ -183,4 +183,21 @@ pub mod public_interface {\n     pub use internal_impl::globbed::*;\n }\n \n+extern \"C\" {\n+    /// dox\n+    pub fn extern_fn_documented(f: f32) -> f32;\n+    pub fn extern_fn_undocumented(f: f32) -> f32;\n+    //~^ ERROR: missing documentation for a function\n+\n+    /// dox\n+    pub static EXTERN_STATIC_DOCUMENTED: u8;\n+    pub static EXTERN_STATIC_UNDOCUMENTED: u8;\n+    //~^ ERROR: missing documentation for a static\n+\n+    /// dox\n+    pub type ExternTyDocumented;\n+    pub type ExternTyUndocumented;\n+    //~^ ERROR: missing documentation for a foreign type\n+}\n+\n fn main() {}"}, {"sha": "56f8fc10e862320f3e55d899aa4cb7b912c98427", "filename": "src/test/ui/lint/lint-missing-doc.stderr", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c2bc344eb23d8c1d18e803b3f1e631cf99926fbb/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Flint-missing-doc.stderr?ref=c2bc344eb23d8c1d18e803b3f1e631cf99926fbb", "patch": "@@ -118,5 +118,23 @@ error: missing documentation for a function\n LL |         pub fn also_undocumented1() {}\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 19 previous errors\n+error: missing documentation for a function\n+  --> $DIR/lint-missing-doc.rs:189:5\n+   |\n+LL |     pub fn extern_fn_undocumented(f: f32) -> f32;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing documentation for a static\n+  --> $DIR/lint-missing-doc.rs:194:5\n+   |\n+LL |     pub static EXTERN_STATIC_UNDOCUMENTED: u8;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: missing documentation for a foreign type\n+  --> $DIR/lint-missing-doc.rs:199:5\n+   |\n+LL |     pub type ExternTyUndocumented;\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 22 previous errors\n "}]}