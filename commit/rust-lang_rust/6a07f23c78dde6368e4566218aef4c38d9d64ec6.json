{"sha": "6a07f23c78dde6368e4566218aef4c38d9d64ec6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhMDdmMjNjNzhkZGU2MzY4ZTQ1NjYyMThhZWY0YzM4ZDlkNjRlYzY=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2018-12-07T04:42:31Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-07T04:42:31Z"}, "message": "Rollup merge of #56434 - Zoxc:par-tests, r=michaelwoerister\n\nImprove query cycle errors for parallel queries\n\nr? @michaelwoerister", "tree": {"sha": "846562e26eb40a049c0f5ee7671522d0dcc84a08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/846562e26eb40a049c0f5ee7671522d0dcc84a08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a07f23c78dde6368e4566218aef4c38d9d64ec6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcCfo3CRBK7hj4Ov3rIwAAdHIIAJDrIvtaw+vC19IEsUOVOHAt\n9s9TNXZaOzsGgq9jWEcskLjTqyBbwOOrQrV1ZN4jJXDc5EFNY1EZYgHCZYqQOYCV\nwT6E1q4FBf23NtIGUTVc70m3ylqJYk/xu6pHrHtPFEeBOrUL5WaFo9ss2HEvTh7k\nDbmOHwhYvZvY2ii1nyFd4fvvkhZsla6/hqeb/UDiNuKxaY9/v1gvM7j/jcuuoUMy\nvX7Uuv/HzYHOndaFSSJIPo+pC/6GWllP/HgvxhvNi6wMXu2FXLbZxdUrHrXNG1Kf\njI6JQj3HFSFr++/35kuNcNU/74TqY1BohbEUEPTH3Jem+WFFZ9eYLuLTnYij56I=\n=Uv82\n-----END PGP SIGNATURE-----\n", "payload": "tree 846562e26eb40a049c0f5ee7671522d0dcc84a08\nparent 6d3501ebe3b2395456c90d7c6147ce5a8244979d\nparent 813b484d1e8185b746ab67b067fe3ca331b9b07d\nauthor kennytm <kennytm@gmail.com> 1544157751 +0800\ncommitter GitHub <noreply@github.com> 1544157751 +0800\n\nRollup merge of #56434 - Zoxc:par-tests, r=michaelwoerister\n\nImprove query cycle errors for parallel queries\n\nr? @michaelwoerister\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a07f23c78dde6368e4566218aef4c38d9d64ec6", "html_url": "https://github.com/rust-lang/rust/commit/6a07f23c78dde6368e4566218aef4c38d9d64ec6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a07f23c78dde6368e4566218aef4c38d9d64ec6/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6d3501ebe3b2395456c90d7c6147ce5a8244979d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6d3501ebe3b2395456c90d7c6147ce5a8244979d", "html_url": "https://github.com/rust-lang/rust/commit/6d3501ebe3b2395456c90d7c6147ce5a8244979d"}, {"sha": "813b484d1e8185b746ab67b067fe3ca331b9b07d", "url": "https://api.github.com/repos/rust-lang/rust/commits/813b484d1e8185b746ab67b067fe3ca331b9b07d", "html_url": "https://github.com/rust-lang/rust/commit/813b484d1e8185b746ab67b067fe3ca331b9b07d"}], "stats": {"total": 110, "additions": 74, "deletions": 36}, "files": [{"sha": "bd8b3e678d851630b3c60f8fdf4935c00c5b15fc", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=6a07f23c78dde6368e4566218aef4c38d9d64ec6", "patch": "@@ -1942,8 +1942,12 @@ pub mod tls {\n     /// This is a callback from libsyntax as it cannot access the implicit state\n     /// in librustc otherwise\n     fn span_debug(span: syntax_pos::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        with(|tcx| {\n-            write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+        with_opt(|tcx| {\n+            if let Some(tcx) = tcx {\n+                write!(f, \"{}\", tcx.sess.source_map().span_to_string(span))\n+            } else {\n+                syntax_pos::default_span_debug(span, f)\n+            }\n         })\n     }\n "}, {"sha": "1439e41bb31fd9ba5924683d19947288f657be9a", "filename": "src/librustc/ty/query/job.rs", "status": "modified", "additions": 66, "deletions": 32, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fjob.rs?ref=6a07f23c78dde6368e4566218aef4c38d9d64ec6", "patch": "@@ -103,8 +103,11 @@ impl<'tcx> QueryJob<'tcx> {\n                     condvar: Condvar::new(),\n                 });\n                 self.latch.await(&waiter);\n-\n-                match Lrc::get_mut(&mut waiter).unwrap().cycle.get_mut().take() {\n+                // FIXME: Get rid of this lock. We have ownership of the QueryWaiter\n+                // although another thread may still have a Lrc reference so we cannot\n+                // use Lrc::get_mut\n+                let mut cycle = waiter.cycle.lock();\n+                match cycle.take() {\n                     None => Ok(()),\n                     Some(cycle) => Err(cycle)\n                 }\n@@ -326,19 +329,17 @@ fn connected_to_root<'tcx>(\n     query: Lrc<QueryJob<'tcx>>,\n     visited: &mut FxHashSet<*const QueryJob<'tcx>>\n ) -> bool {\n-    // This query is connected to the root (it has no query parent), return true\n-    if query.parent.is_none() {\n-        return true;\n-    }\n-\n     // We already visited this or we're deliberately ignoring it\n     if visited.contains(&query.as_ptr()) {\n         return false;\n     }\n \n-    visited.insert(query.as_ptr());\n+    // This query is connected to the root (it has no query parent), return true\n+    if query.parent.is_none() {\n+        return true;\n+    }\n \n-    let mut connected = false;\n+    visited.insert(query.as_ptr());\n \n     visit_waiters(query, |_, successor| {\n         if connected_to_root(successor, visited) {\n@@ -349,6 +350,28 @@ fn connected_to_root<'tcx>(\n     }).is_some()\n }\n \n+// Deterministically pick an query from a list\n+#[cfg(parallel_queries)]\n+fn pick_query<'a, 'tcx, T, F: Fn(&T) -> (Span, Lrc<QueryJob<'tcx>>)>(\n+    tcx: TyCtxt<'_, 'tcx, '_>,\n+    queries: &'a [T],\n+    f: F\n+) -> &'a T {\n+    // Deterministically pick an entry point\n+    // FIXME: Sort this instead\n+    let mut hcx = tcx.create_stable_hashing_context();\n+    queries.iter().min_by_key(|v| {\n+        let (span, query) = f(v);\n+        let mut stable_hasher = StableHasher::<u64>::new();\n+        query.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n+        // Prefer entry points which have valid spans for nicer error messages\n+        // We add an integer to the tuple ensuring that entry points\n+        // with valid spans are picked first\n+        let span_cmp = if span == DUMMY_SP { 1 } else { 0 };\n+        (span_cmp, stable_hasher.finish())\n+    }).unwrap()\n+}\n+\n /// Looks for query cycles starting from the last query in `jobs`.\n /// If a cycle is found, all queries in the cycle is removed from `jobs` and\n /// the function return true.\n@@ -388,41 +411,52 @@ fn remove_cycle<'tcx>(\n \n         // Find the queries in the cycle which are\n         // connected to queries outside the cycle\n-        let entry_points = stack.iter().filter_map(|query| {\n-            // Mark all the other queries in the cycle as already visited\n-            let mut visited = FxHashSet::from_iter(stack.iter().filter_map(|q| {\n-                if q.1.as_ptr() != query.1.as_ptr() {\n-                    Some(q.1.as_ptr())\n-                } else {\n+        let entry_points: Vec<_> = stack.iter().filter_map(|(span, query)| {\n+            if query.parent.is_none() {\n+                // This query is connected to the root (it has no query parent)\n+                Some((*span, query.clone(), None))\n+            } else {\n+                let mut waiters = Vec::new();\n+                // Find all the direct waiters who lead to the root\n+                visit_waiters(query.clone(), |span, waiter| {\n+                    // Mark all the other queries in the cycle as already visited\n+                    let mut visited = FxHashSet::from_iter(stack.iter().map(|q| q.1.as_ptr()));\n+\n+                    if connected_to_root(waiter.clone(), &mut visited) {\n+                        waiters.push((span, waiter));\n+                    }\n+\n+                    None\n+                });\n+                if waiters.is_empty() {\n                     None\n+                } else {\n+                    // Deterministically pick one of the waiters to show to the user\n+                    let waiter = pick_query(tcx, &waiters, |s| s.clone()).clone();\n+                    Some((*span, query.clone(), Some(waiter)))\n                 }\n-            }));\n-\n-            if connected_to_root(query.1.clone(), &mut visited) {\n-                Some(query.1.clone())\n-            } else {\n-                None\n             }\n-        });\n+        }).collect();\n+\n+        let entry_points: Vec<(Span, Lrc<QueryJob<'tcx>>, Option<(Span, Lrc<QueryJob<'tcx>>)>)>\n+         = entry_points;\n \n         // Deterministically pick an entry point\n-        // FIXME: Sort this instead\n-        let mut hcx = tcx.create_stable_hashing_context();\n-        let entry_point = entry_points.min_by_key(|q| {\n-            let mut stable_hasher = StableHasher::<u64>::new();\n-            q.info.query.hash_stable(&mut hcx, &mut stable_hasher);\n-            stable_hasher.finish()\n-        }).unwrap().as_ptr();\n+        let (_, entry_point, usage) = pick_query(tcx, &entry_points, |e| (e.0, e.1.clone()));\n \n         // Shift the stack so that our entry point is first\n-        let entry_point_pos = stack.iter().position(|(_, query)| query.as_ptr() == entry_point);\n+        let entry_point_pos = stack.iter().position(|(_, query)| {\n+            query.as_ptr() == entry_point.as_ptr()\n+        });\n         if let Some(pos) = entry_point_pos {\n-            stack.rotate_right(pos);\n+            stack.rotate_left(pos);\n         }\n \n+        let usage = usage.as_ref().map(|(span, query)| (*span, query.info.query.clone()));\n+\n         // Create the cycle error\n         let mut error = CycleError {\n-            usage: None,\n+            usage,\n             cycle: stack.iter().map(|&(s, ref q)| QueryInfo {\n                 span: s,\n                 query: q.info.query.clone(),"}, {"sha": "2b6bb34b146cb32d8abf25ef68a04a35e8e28342", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=6a07f23c78dde6368e4566218aef4c38d9d64ec6", "patch": "@@ -98,7 +98,7 @@ fn errors(msgs: &[&str]) -> (Box<dyn Emitter + sync::Send>, usize) {\n \n fn test_env<F>(source_string: &str, args: (Box<dyn Emitter + sync::Send>, usize), body: F)\n where\n-    F: FnOnce(Env),\n+    F: FnOnce(Env) + sync::Send,\n {\n     syntax::with_globals(|| {\n         let mut options = config::Options::default();"}, {"sha": "4e3d1e89a72194b1a72fa0f0f91a6f055293e19b", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a07f23c78dde6368e4566218aef4c38d9d64ec6/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=6a07f23c78dde6368e4566218aef4c38d9d64ec6", "patch": "@@ -611,7 +611,7 @@ impl serialize::UseSpecializedDecodable for Span {\n     }\n }\n \n-fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n+pub fn default_span_debug(span: Span, f: &mut fmt::Formatter) -> fmt::Result {\n     f.debug_struct(\"Span\")\n         .field(\"lo\", &span.lo())\n         .field(\"hi\", &span.hi())"}]}