{"sha": "ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmODVkMWMyZDI4ZTE5Nzk3YjlkOWFhNjdiYmRmYWY5MmUwMTVjNTc=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-07T23:39:02Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-08-10T10:16:06Z"}, "message": "resolve: Move late resolution visitor into a separate file", "tree": {"sha": "befe455069eef2c4ec04ed2049d9b0145d9dcb71", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/befe455069eef2c4ec04ed2049d9b0145d9dcb71"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "html_url": "https://github.com/rust-lang/rust/commit/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e8746acc1d4fd236552a59f54b732680b4524e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e8746acc1d4fd236552a59f54b732680b4524e", "html_url": "https://github.com/rust-lang/rust/commit/e2e8746acc1d4fd236552a59f54b732680b4524e"}], "stats": {"total": 5377, "additions": 2703, "deletions": 2674}, "files": [{"sha": "f56954e32aef4eff085637026505251edbc9f517", "filename": "src/librustc_resolve/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 674, "changes": 688, "blob_url": "https://github.com/rust-lang/rust/blob/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fdiagnostics.rs?ref=ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "patch": "@@ -1,56 +1,48 @@\n use std::cmp::Reverse;\n \n-use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use errors::{Applicability, DiagnosticBuilder};\n use log::debug;\n-use rustc::hir::def::{self, DefKind, CtorKind, NonMacroAttrKind};\n+use rustc::hir::def::{self, DefKind, NonMacroAttrKind};\n use rustc::hir::def::Namespace::{self, *};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::hir::PrimTy;\n-use rustc::session::{Session, config::nightly_options};\n+use rustc::session::Session;\n use rustc::ty::{self, DefIdTree};\n use rustc::util::nodemap::FxHashSet;\n-use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n+use syntax::ast::{self, Ident, Path};\n use syntax::ext::base::MacroKind;\n use syntax::feature_gate::BUILTIN_ATTRIBUTES;\n use syntax::symbol::{Symbol, kw};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{BytePos, Span};\n \n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n-use crate::{is_self_type, is_self_value, path_names_to_string, KNOWN_TOOLS};\n-use crate::{CrateLint, LateResolutionVisitor, LegacyScope, Module, ModuleKind, ModuleOrUniformRoot};\n-use crate::{PathResult, PathSource, ParentScope, Resolver, RibKind, Scope, ScopeSet, Segment};\n+use crate::{path_names_to_string, KNOWN_TOOLS};\n+use crate::{CrateLint, LegacyScope, Module, ModuleOrUniformRoot};\n+use crate::{PathResult, ParentScope, Resolver, Scope, ScopeSet, Segment};\n \n type Res = def::Res<ast::NodeId>;\n \n /// A vector of spans and replacements, a message and applicability.\n crate type Suggestion = (Vec<(Span, String)>, String, Applicability);\n \n-/// A field or associated item from self type suggested in case of resolution failure.\n-enum AssocSuggestion {\n-    Field,\n-    MethodWithSelf,\n-    AssocItem,\n-}\n-\n-struct TypoSuggestion {\n-    candidate: Symbol,\n-    res: Res,\n+crate struct TypoSuggestion {\n+    pub candidate: Symbol,\n+    pub res: Res,\n }\n \n impl TypoSuggestion {\n-    fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n+    crate fn from_res(candidate: Symbol, res: Res) -> TypoSuggestion {\n         TypoSuggestion { candidate, res }\n     }\n }\n \n /// A free importable items suggested in case of resolution failure.\n crate struct ImportSuggestion {\n-    did: Option<DefId>,\n+    pub did: Option<DefId>,\n     pub path: Path,\n }\n \n-fn add_typo_suggestion(\n+crate fn add_typo_suggestion(\n     err: &mut DiagnosticBuilder<'_>, suggestion: Option<TypoSuggestion>, span: Span\n ) -> bool {\n     if let Some(suggestion) = suggestion {\n@@ -65,7 +57,7 @@ fn add_typo_suggestion(\n     false\n }\n \n-fn add_module_candidates(\n+crate fn add_module_candidates(\n     module: Module<'_>, names: &mut Vec<TypoSuggestion>, filter_fn: &impl Fn(Res) -> bool\n ) {\n     for (&(ident, _), resolution) in module.resolutions.borrow().iter() {\n@@ -78,488 +70,6 @@ fn add_module_candidates(\n     }\n }\n \n-impl<'a> LateResolutionVisitor<'a, '_> {\n-    /// Handles error reporting for `smart_resolve_path_fragment` function.\n-    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n-    pub(crate) fn smart_resolve_report_errors(\n-        &mut self,\n-        path: &[Segment],\n-        span: Span,\n-        source: PathSource<'_>,\n-        res: Option<Res>,\n-    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n-        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-        let is_enum_variant = &|res| {\n-            if let Res::Def(DefKind::Variant, _) = res { true } else { false }\n-        };\n-\n-        // Make the base error.\n-        let expected = source.descr_expected();\n-        let path_str = Segment::names_to_string(path);\n-        let item_str = path.last().unwrap().ident;\n-        let code = source.error_code(res.is_some());\n-        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n-            (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n-                format!(\"not a {}\", expected),\n-                span)\n-        } else {\n-            let item_span = path.last().unwrap().ident.span;\n-            let (mod_prefix, mod_str) = if path.len() == 1 {\n-                (String::new(), \"this scope\".to_string())\n-            } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n-                (String::new(), \"the crate root\".to_string())\n-            } else {\n-                let mod_path = &path[..path.len() - 1];\n-                let mod_prefix = match self.resolve_path(\n-                    mod_path, Some(TypeNS), false, span, CrateLint::No\n-                ) {\n-                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.def_kind(),\n-                    _ => None,\n-                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n-                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n-            };\n-            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n-                format!(\"not found in {}\", mod_str),\n-                item_span)\n-        };\n-\n-        let code = DiagnosticId::Error(code.into());\n-        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n-\n-        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n-        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n-            && self.self_value_is_available(path[0].ident.span, span) {\n-            err.span_suggestion(\n-                span,\n-                \"did you mean\",\n-                \"self\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        }\n-\n-        // Emit special messages for unresolved `Self` and `self`.\n-        if is_self_type(path, ns) {\n-            __diagnostic_used!(E0411);\n-            err.code(DiagnosticId::Error(\"E0411\".into()));\n-            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n-                                          and type definitions\"));\n-            return (err, Vec::new());\n-        }\n-        if is_self_value(path, ns) {\n-            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n-\n-            __diagnostic_used!(E0424);\n-            err.code(DiagnosticId::Error(\"E0424\".into()));\n-            err.span_label(span, match source {\n-                PathSource::Pat => {\n-                    format!(\"`self` value is a keyword \\\n-                             and may not be bound to \\\n-                             variables or shadowed\")\n-                }\n-                _ => {\n-                    format!(\"`self` value is a keyword \\\n-                             only available in methods \\\n-                             with `self` parameter\")\n-                }\n-            });\n-            return (err, Vec::new());\n-        }\n-\n-        // Try to lookup name in more relaxed fashion for better error reporting.\n-        let ident = path.last().unwrap().ident;\n-        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n-            .drain(..)\n-            .filter(|ImportSuggestion { did, .. }| {\n-                match (did, res.and_then(|res| res.opt_def_id())) {\n-                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n-                    _ => true,\n-                }\n-            })\n-            .collect::<Vec<_>>();\n-        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n-        if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n-            let enum_candidates =\n-                self.lookup_import_candidates(ident, ns, is_enum_variant);\n-            let mut enum_candidates = enum_candidates.iter()\n-                .map(|suggestion| {\n-                    import_candidate_to_enum_paths(&suggestion)\n-                }).collect::<Vec<_>>();\n-            enum_candidates.sort();\n-\n-            if !enum_candidates.is_empty() {\n-                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n-                // (that it's a variant) for E0573 \"expected type, found variant\".\n-                let preamble = if res.is_none() {\n-                    let others = match enum_candidates.len() {\n-                        1 => String::new(),\n-                        2 => \" and 1 other\".to_owned(),\n-                        n => format!(\" and {} others\", n)\n-                    };\n-                    format!(\"there is an enum variant `{}`{}; \",\n-                            enum_candidates[0].0, others)\n-                } else {\n-                    String::new()\n-                };\n-                let msg = format!(\"{}try using the variant's enum\", preamble);\n-\n-                err.span_suggestions(\n-                    span,\n-                    &msg,\n-                    enum_candidates.into_iter()\n-                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n-                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n-                        // type name!\n-                        // FIXME: is there a more principled way to do this that\n-                        // would work for other re-exports?\n-                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n-                        // Also write `Option` rather than `std::prelude::v1::Option`.\n-                        .map(|enum_ty_path| {\n-                            // FIXME #56861: DRY-er prelude filtering.\n-                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n-                        }),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-        }\n-        if path.len() == 1 && self.self_type_is_available(span) {\n-            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n-                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n-                match candidate {\n-                    AssocSuggestion::Field => {\n-                        if self_is_available {\n-                            err.span_suggestion(\n-                                span,\n-                                \"you might have meant to use the available field\",\n-                                format!(\"self.{}\", path_str),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            err.span_label(\n-                                span,\n-                                \"a field by this name exists in `Self`\",\n-                            );\n-                        }\n-                    }\n-                    AssocSuggestion::MethodWithSelf if self_is_available => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"self.{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n-                        err.span_suggestion(\n-                            span,\n-                            \"try\",\n-                            format!(\"Self::{}\", path_str),\n-                            Applicability::MachineApplicable,\n-                        );\n-                    }\n-                }\n-                return (err, candidates);\n-            }\n-        }\n-\n-        // Try Levenshtein algorithm.\n-        let levenshtein_worked = add_typo_suggestion(\n-            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n-        );\n-\n-        // Try context-dependent help if relaxed lookup didn't work.\n-        if let Some(res) = res {\n-            if self.smart_resolve_context_dependent_help(&mut err,\n-                                                         span,\n-                                                         source,\n-                                                         res,\n-                                                         &path_str,\n-                                                         &fallback_label) {\n-                return (err, candidates);\n-            }\n-        }\n-\n-        // Fallback label.\n-        if !levenshtein_worked {\n-            err.span_label(base_span, fallback_label);\n-            self.type_ascription_suggestion(&mut err, base_span);\n-        }\n-        (err, candidates)\n-    }\n-}\n-\n-impl<'a> Resolver<'a> {\n-    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n-        // HACK(estebank): find a better way to figure out that this was a\n-        // parser issue where a struct literal is being used on an expression\n-        // where a brace being opened means a block is being started. Look\n-        // ahead for the next text to see if `span` is followed by a `{`.\n-        let sm = self.session.source_map();\n-        let mut sp = span;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-        }\n-        let followed_by_brace = match sm.span_to_snippet(sp) {\n-            Ok(ref snippet) if snippet == \"{\" => true,\n-            _ => false,\n-        };\n-        // In case this could be a struct literal that needs to be surrounded\n-        // by parenthesis, find the appropriate span.\n-        let mut i = 0;\n-        let mut closing_brace = None;\n-        loop {\n-            sp = sm.next_point(sp);\n-            match sm.span_to_snippet(sp) {\n-                Ok(ref snippet) => {\n-                    if snippet == \"}\" {\n-                        let sp = span.to(sp);\n-                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n-                            closing_brace = Some((sp, snippet));\n-                        }\n-                        break;\n-                    }\n-                }\n-                _ => break,\n-            }\n-            i += 1;\n-            // The bigger the span, the more likely we're incorrect --\n-            // bound it to 100 chars long.\n-            if i > 100 {\n-                break;\n-            }\n-        }\n-        return (followed_by_brace, closing_brace)\n-    }\n-}\n-\n-impl<'a> LateResolutionVisitor<'a, '_> {\n-    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n-    /// function.\n-    /// Returns `true` if able to provide context-dependent help.\n-    fn smart_resolve_context_dependent_help(\n-        &mut self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        span: Span,\n-        source: PathSource<'_>,\n-        res: Res,\n-        path_str: &str,\n-        fallback_label: &str,\n-    ) -> bool {\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-\n-        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n-            ExprKind::Field(_, ident) => {\n-                err.span_suggestion(\n-                    expr.span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                true\n-            }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                let span = expr.span.with_hi(segment.ident.span.hi());\n-                err.span_suggestion(\n-                    span,\n-                    \"use the path separator to refer to an item\",\n-                    format!(\"{}::{}\", path_str, segment.ident),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                true\n-            }\n-            _ => false,\n-        };\n-\n-        let mut bad_struct_syntax_suggestion = || {\n-            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n-            let mut suggested = false;\n-            match source {\n-                PathSource::Expr(Some(parent)) => {\n-                    suggested = path_sep(err, &parent);\n-                }\n-                PathSource::Expr(None) if followed_by_brace == true => {\n-                    if let Some((sp, snippet)) = closing_brace {\n-                        err.span_suggestion(\n-                            sp,\n-                            \"surround the struct literal with parenthesis\",\n-                            format!(\"({})\", snippet),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    } else {\n-                        err.span_label(\n-                            span,  // Note the parenthesis surrounding the suggestion below\n-                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n-                        );\n-                    }\n-                    suggested = true;\n-                },\n-                _ => {}\n-            }\n-            if !suggested {\n-                err.span_label(\n-                    span,\n-                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n-                );\n-            }\n-        };\n-\n-        match (res, source) {\n-            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n-                err.span_suggestion(\n-                    span,\n-                    \"use `!` to invoke the macro\",\n-                    format!(\"{}!\", path_str),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                if path_str == \"try\" && span.rust_2015() {\n-                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n-                }\n-            }\n-            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n-                err.span_label(span, \"type aliases cannot be used as traits\");\n-                if nightly_options::is_nightly_build() {\n-                    err.note(\"did you mean to use a trait alias?\");\n-                }\n-            }\n-            (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n-                if !path_sep(err, &parent) {\n-                    return false;\n-                }\n-            }\n-            (Res::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n-                | (Res::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n-                if let Some(variants) = self.collect_enum_variants(def_id) {\n-                    if !variants.is_empty() {\n-                        let msg = if variants.len() == 1 {\n-                            \"try using the enum's variant\"\n-                        } else {\n-                            \"try using one of the enum's variants\"\n-                        };\n-\n-                        err.span_suggestions(\n-                            span,\n-                            msg,\n-                            variants.iter().map(path_names_to_string),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n-                } else {\n-                    err.note(\"did you mean to use one of the enum's variants?\");\n-                }\n-            },\n-            (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n-                if let Some((ctor_def, ctor_vis))\n-                        = self.struct_constructors.get(&def_id).cloned() {\n-                    let accessible_ctor = self.is_accessible_from(ctor_vis, self.current_module);\n-                    if is_expected(ctor_def) && !accessible_ctor {\n-                        err.span_label(\n-                            span,\n-                            format!(\"constructor is not visible here due to private fields\"),\n-                        );\n-                    }\n-                } else {\n-                    bad_struct_syntax_suggestion();\n-                }\n-            }\n-            (Res::Def(DefKind::Union, _), _) |\n-            (Res::Def(DefKind::Variant, _), _) |\n-            (Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n-                bad_struct_syntax_suggestion();\n-            }\n-            (Res::SelfTy(..), _) if ns == ValueNS => {\n-                err.span_label(span, fallback_label);\n-                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n-            }\n-            (Res::Def(DefKind::TyAlias, _), _)\n-            | (Res::Def(DefKind::AssocTy, _), _) if ns == ValueNS => {\n-                err.note(\"can't use a type alias as a constructor\");\n-            }\n-            _ => return false,\n-        }\n-        true\n-    }\n-\n-    fn lookup_assoc_candidate<FilterFn>(&mut self,\n-                                        ident: Ident,\n-                                        ns: Namespace,\n-                                        filter_fn: FilterFn)\n-                                        -> Option<AssocSuggestion>\n-        where FilterFn: Fn(Res) -> bool\n-    {\n-        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n-            match t.node {\n-                TyKind::Path(None, _) => Some(t.id),\n-                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n-                // This doesn't handle the remaining `Ty` variants as they are not\n-                // that commonly the self_type, it might be interesting to provide\n-                // support for those in future.\n-                _ => None,\n-            }\n-        }\n-\n-        // Fields are generally expected in the same contexts as locals.\n-        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n-            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n-                // Look for a field with the same name in the current self_type.\n-                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n-                    match resolution.base_res() {\n-                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n-                                if resolution.unresolved_segments() == 0 => {\n-                            if let Some(field_names) = self.field_names.get(&did) {\n-                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n-                                    return Some(AssocSuggestion::Field);\n-                                }\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-\n-        for assoc_type_ident in &self.current_trait_assoc_types {\n-            if *assoc_type_ident == ident {\n-                return Some(AssocSuggestion::AssocItem);\n-            }\n-        }\n-\n-        // Look for associated items in the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if let Ok(binding) = self.resolve_ident_in_module(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    false,\n-                    module.span,\n-                ) {\n-                let res = binding.res();\n-                if filter_fn(res) {\n-                    return Some(if self.has_self.contains(&res.def_id()) {\n-                        AssocSuggestion::MethodWithSelf\n-                    } else {\n-                        AssocSuggestion::AssocItem\n-                    });\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-}\n-\n impl<'a> Resolver<'a> {\n     /// Lookup typo candidate in scope for a macro or import.\n     fn early_lookup_typo_candidate(\n@@ -690,103 +200,7 @@ impl<'a> Resolver<'a> {\n             _ => None,\n         }\n     }\n-}\n-\n-impl<'a> LateResolutionVisitor<'a, '_> {\n-    fn lookup_typo_candidate(\n-        &mut self,\n-        path: &[Segment],\n-        ns: Namespace,\n-        filter_fn: &impl Fn(Res) -> bool,\n-        span: Span,\n-    ) -> Option<TypoSuggestion> {\n-        let mut names = Vec::new();\n-        if path.len() == 1 {\n-            // Search in lexical scope.\n-            // Walk backwards up the ribs in scope and collect candidates.\n-            for rib in self.ribs[ns].iter().rev() {\n-                // Locals and type parameters\n-                for (ident, &res) in &rib.bindings {\n-                    if filter_fn(res) {\n-                        names.push(TypoSuggestion::from_res(ident.name, res));\n-                    }\n-                }\n-                // Items in scope\n-                if let RibKind::ModuleRibKind(module) = rib.kind {\n-                    // Items from this module\n-                    add_module_candidates(module, &mut names, &filter_fn);\n-\n-                    if let ModuleKind::Block(..) = module.kind {\n-                        // We can see through blocks\n-                    } else {\n-                        // Items from the prelude\n-                        if !module.no_implicit_prelude {\n-                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n-                                self.crate_loader\n-                                    .maybe_process_path_extern(ident.name, ident.span)\n-                                    .and_then(|crate_id| {\n-                                        let crate_mod = Res::Def(\n-                                            DefKind::Mod,\n-                                            DefId {\n-                                                krate: crate_id,\n-                                                index: CRATE_DEF_INDEX,\n-                                            },\n-                                        );\n-\n-                                        if filter_fn(crate_mod) {\n-                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n-                                        } else {\n-                                            None\n-                                        }\n-                                    })\n-                            }));\n-\n-                            if let Some(prelude) = self.prelude {\n-                                add_module_candidates(prelude, &mut names, &filter_fn);\n-                            }\n-                        }\n-                        break;\n-                    }\n-                }\n-            }\n-            // Add primitive types to the mix\n-            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n-                names.extend(\n-                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n-                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n-                    })\n-                )\n-            }\n-        } else {\n-            // Search in module.\n-            let mod_path = &path[..path.len() - 1];\n-            if let PathResult::Module(module) = self.resolve_path(\n-                mod_path, Some(TypeNS), false, span, CrateLint::No\n-            ) {\n-                if let ModuleOrUniformRoot::Module(module) = module {\n-                    add_module_candidates(module, &mut names, &filter_fn);\n-                }\n-            }\n-        }\n-\n-        let name = path[path.len() - 1].ident.name;\n-        // Make sure error reporting is deterministic.\n-        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n-\n-        match find_best_match_for_name(\n-            names.iter().map(|suggestion| &suggestion.candidate),\n-            &name.as_str(),\n-            None,\n-        ) {\n-            Some(found) if found != name => names\n-                .into_iter()\n-                .find(|suggestion| suggestion.candidate == found),\n-            _ => None,\n-        }\n-    }\n-}\n \n-impl<'a> Resolver<'a> {\n     fn lookup_import_candidates_from_module<FilterFn>(&mut self,\n                                           lookup_ident: Ident,\n                                           namespace: Namespace,\n@@ -913,65 +327,6 @@ impl<'a> Resolver<'a> {\n         suggestions\n     }\n \n-    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n-        let mut result = None;\n-        let mut seen_modules = FxHashSet::default();\n-        let mut worklist = vec![(self.graph_root, Vec::new())];\n-\n-        while let Some((in_module, path_segments)) = worklist.pop() {\n-            // abort if the module is already found\n-            if result.is_some() { break; }\n-\n-            self.populate_module_if_necessary(in_module);\n-\n-            in_module.for_each_child_stable(|ident, _, name_binding| {\n-                // abort if the module is already found or if name_binding is private external\n-                if result.is_some() || !name_binding.vis.is_visible_locally() {\n-                    return\n-                }\n-                if let Some(module) = name_binding.module() {\n-                    // form the path\n-                    let mut path_segments = path_segments.clone();\n-                    path_segments.push(ast::PathSegment::from_ident(ident));\n-                    let module_def_id = module.def_id().unwrap();\n-                    if module_def_id == def_id {\n-                        let path = Path {\n-                            span: name_binding.span,\n-                            segments: path_segments,\n-                        };\n-                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n-                    } else {\n-                        // add the module to the lookup\n-                        if seen_modules.insert(module_def_id) {\n-                            worklist.push((module, path_segments));\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-\n-        result\n-    }\n-\n-    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n-        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n-            self.populate_module_if_necessary(enum_module);\n-\n-            let mut variants = Vec::new();\n-            enum_module.for_each_child_stable(|ident, _, name_binding| {\n-                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n-                    let mut segms = enum_import_suggestion.path.segments.clone();\n-                    segms.push(ast::PathSegment::from_ident(ident));\n-                    variants.push(Path {\n-                        span: name_binding.span,\n-                        segments: segms,\n-                    });\n-                }\n-            });\n-            variants\n-        })\n-    }\n-\n     crate fn unresolved_macro_suggestions(\n         &mut self,\n         err: &mut DiagnosticBuilder<'a>,\n@@ -1427,21 +782,6 @@ fn find_span_immediately_after_crate_name(\n     (next_left_bracket == after_second_colon, from_second_colon)\n }\n \n-/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n-fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n-    let variant_path = &suggestion.path;\n-    let variant_path_string = path_names_to_string(variant_path);\n-\n-    let path_len = suggestion.path.segments.len();\n-    let enum_path = ast::Path {\n-        span: suggestion.path.span,\n-        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n-    };\n-    let enum_path_string = path_names_to_string(&enum_path);\n-\n-    (variant_path_string, enum_path_string)\n-}\n-\n /// When an entity with a given name is not available in scope, we search for\n /// entities with that name in all crates. This method allows outputting the\n /// results of this search in a programmer-friendly way"}, {"sha": "e688857d038574094e338fe3911484675add6dc0", "filename": "src/librustc_resolve/late.rs", "status": "added", "additions": 1806, "deletions": 0, "changes": 1806, "blob_url": "https://github.com/rust-lang/rust/blob/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate.rs?ref=ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "patch": "@@ -0,0 +1,1806 @@\n+use GenericParameters::*;\n+\n+use crate::{path_names_to_string, resolve_error};\n+use crate::{AliasPossibility, BindingError, CrateLint, LexicalScopeBinding, Module};\n+use crate::{ModuleOrUniformRoot, NameBinding, NameBindingKind, ParentScope, PathResult};\n+use crate::{PathSource, ResolutionError, Resolver, Rib, RibKind, Segment, UseError};\n+use crate::RibKind::*;\n+\n+use log::debug;\n+use rustc::{bug, lint, span_bug};\n+use rustc::hir::def::{self, PartialRes, DefKind, CtorKind, PerNS};\n+use rustc::hir::def::Namespace::{self, *};\n+use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::hir::TraitCandidate;\n+use rustc::util::nodemap::FxHashMap;\n+use smallvec::{smallvec, SmallVec};\n+use syntax::{unwrap_or, walk_list};\n+use syntax::ast::*;\n+use syntax::ptr::P;\n+use syntax::symbol::{kw, sym};\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax::visit::{self, Visitor, FnKind};\n+use syntax_pos::Span;\n+\n+use std::collections::BTreeSet;\n+use std::mem::replace;\n+use std::ops::{Deref, DerefMut};\n+\n+mod diagnostics;\n+\n+type Res = def::Res<NodeId>;\n+\n+/// Map from the name in a pattern to its binding mode.\n+type BindingMap = FxHashMap<Ident, BindingInfo>;\n+\n+#[derive(Copy, Clone, Debug)]\n+struct BindingInfo {\n+    span: Span,\n+    binding_mode: BindingMode,\n+}\n+\n+#[derive(Copy, Clone)]\n+enum GenericParameters<'a, 'b> {\n+    NoGenericParams,\n+    HasGenericParams(// Type parameters.\n+                      &'b Generics,\n+\n+                      // The kind of the rib used for type parameters.\n+                      RibKind<'a>),\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n+enum PatternSource {\n+    Match,\n+    Let,\n+    For,\n+    FnParam,\n+}\n+\n+impl PatternSource {\n+    fn descr(self) -> &'static str {\n+        match self {\n+            PatternSource::Match => \"match binding\",\n+            PatternSource::Let => \"let binding\",\n+            PatternSource::For => \"for binding\",\n+            PatternSource::FnParam => \"function parameter\",\n+        }\n+    }\n+}\n+\n+struct LateResolutionVisitor<'a, 'b> {\n+    resolver: &'b mut Resolver<'a>,\n+\n+    /// The module that represents the current item scope.\n+    current_module: Module<'a>,\n+\n+    /// The current set of local scopes for types and values.\n+    /// FIXME #4948: Reuse ribs to avoid allocation.\n+    ribs: PerNS<Vec<Rib<'a>>>,\n+\n+    /// The current set of local scopes, for labels.\n+    label_ribs: Vec<Rib<'a, NodeId>>,\n+\n+    /// The trait that the current context can refer to.\n+    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n+\n+    /// The current trait's associated types' ident, used for diagnostic suggestions.\n+    current_trait_assoc_types: Vec<Ident>,\n+\n+    /// The current self type if inside an impl (used for better errors).\n+    current_self_type: Option<Ty>,\n+\n+    /// The current self item if inside an ADT (used for better errors).\n+    current_self_item: Option<NodeId>,\n+\n+    /// A list of labels as of yet unused. Labels will be removed from this map when\n+    /// they are used (in a `break` or `continue` statement)\n+    unused_labels: FxHashMap<NodeId, Span>,\n+\n+    /// Only used for better errors on `fn(): fn()`.\n+    current_type_ascription: Vec<Span>,\n+}\n+\n+impl<'a> Deref for LateResolutionVisitor<'a, '_> {\n+    type Target = Resolver<'a>;\n+    fn deref(&self) -> &Self::Target {\n+        self.resolver\n+    }\n+}\n+\n+impl<'a> DerefMut for LateResolutionVisitor<'a, '_> {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        self.resolver\n+    }\n+}\n+\n+/// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n+impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n+    fn visit_item(&mut self, item: &'tcx Item) {\n+        self.resolve_item(item);\n+    }\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n+        self.resolve_arm(arm);\n+    }\n+    fn visit_block(&mut self, block: &'tcx Block) {\n+        self.resolve_block(block);\n+    }\n+    fn visit_anon_const(&mut self, constant: &'tcx AnonConst) {\n+        debug!(\"visit_anon_const {:?}\", constant);\n+        self.with_constant_rib(|this| {\n+            visit::walk_anon_const(this, constant);\n+        });\n+    }\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        self.resolve_expr(expr, None);\n+    }\n+    fn visit_local(&mut self, local: &'tcx Local) {\n+        self.resolve_local(local);\n+    }\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n+        match ty.node {\n+            TyKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n+            }\n+            TyKind::ImplicitSelf => {\n+                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n+                let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n+                              .map_or(Res::Err, |d| d.res());\n+                self.record_partial_res(ty.id, PartialRes::new(res));\n+            }\n+            _ => (),\n+        }\n+        visit::walk_ty(self, ty);\n+    }\n+    fn visit_poly_trait_ref(&mut self,\n+                            tref: &'tcx PolyTraitRef,\n+                            m: &'tcx TraitBoundModifier) {\n+        self.smart_resolve_path(tref.trait_ref.ref_id, None,\n+                                &tref.trait_ref.path, PathSource::Trait(AliasPossibility::Maybe));\n+        visit::walk_poly_trait_ref(self, tref, m);\n+    }\n+    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n+        let generic_params = match foreign_item.node {\n+            ForeignItemKind::Fn(_, ref generics) => {\n+                HasGenericParams(generics, ItemRibKind)\n+            }\n+            ForeignItemKind::Static(..) => NoGenericParams,\n+            ForeignItemKind::Ty => NoGenericParams,\n+            ForeignItemKind::Macro(..) => NoGenericParams,\n+        };\n+        self.with_generic_param_rib(generic_params, |this| {\n+            visit::walk_foreign_item(this, foreign_item);\n+        });\n+    }\n+    fn visit_fn(&mut self,\n+                function_kind: FnKind<'tcx>,\n+                declaration: &'tcx FnDecl,\n+                _: Span,\n+                _: NodeId)\n+    {\n+        debug!(\"(resolving function) entering function\");\n+        let rib_kind = match function_kind {\n+            FnKind::ItemFn(..) => FnItemRibKind,\n+            FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n+        };\n+\n+        // Create a value rib for the function.\n+        self.ribs[ValueNS].push(Rib::new(rib_kind));\n+\n+        // Create a label rib for the function.\n+        self.label_ribs.push(Rib::new(rib_kind));\n+\n+        // Add each argument to the rib.\n+        let mut bindings_list = FxHashMap::default();\n+        for argument in &declaration.inputs {\n+            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+\n+            self.visit_ty(&argument.ty);\n+\n+            debug!(\"(resolving function) recorded argument\");\n+        }\n+        visit::walk_fn_ret_ty(self, &declaration.output);\n+\n+        // Resolve the function body, potentially inside the body of an async closure\n+        match function_kind {\n+            FnKind::ItemFn(.., body) |\n+            FnKind::Method(.., body) => {\n+                self.visit_block(body);\n+            }\n+            FnKind::Closure(body) => {\n+                self.visit_expr(body);\n+            }\n+        };\n+\n+        debug!(\"(resolving function) leaving function\");\n+\n+        self.label_ribs.pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn visit_generics(&mut self, generics: &'tcx Generics) {\n+        // For type parameter defaults, we have to ban access\n+        // to following type parameters, as the InternalSubsts can only\n+        // provide previous type parameters as they're built. We\n+        // put all the parameters on the ban list and then remove\n+        // them one by one as they are processed and become available.\n+        let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n+        let mut found_default = false;\n+        default_ban_rib.bindings.extend(generics.params.iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Const { .. } |\n+                GenericParamKind::Lifetime { .. } => None,\n+                GenericParamKind::Type { ref default, .. } => {\n+                    found_default |= default.is_some();\n+                    if found_default {\n+                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n+                    } else {\n+                        None\n+                    }\n+                }\n+            }));\n+\n+        // We also ban access to type parameters for use as the types of const parameters.\n+        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n+        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n+            .filter(|param| {\n+                if let GenericParamKind::Type { .. } = param.kind {\n+                    true\n+                } else {\n+                    false\n+                }\n+            })\n+            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n+\n+        for param in &generics.params {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n+                GenericParamKind::Type { ref default, .. } => {\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n+                    }\n+\n+                    if let Some(ref ty) = default {\n+                        self.ribs[TypeNS].push(default_ban_rib);\n+                        self.visit_ty(ty);\n+                        default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                    }\n+\n+                    // Allow all following defaults to refer to this type parameter.\n+                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n+                }\n+                GenericParamKind::Const { ref ty } => {\n+                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n+\n+                    for bound in &param.bounds {\n+                        self.visit_param_bound(bound);\n+                    }\n+\n+                    self.visit_ty(ty);\n+\n+                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n+                }\n+            }\n+        }\n+        for p in &generics.where_clause.predicates {\n+            self.visit_where_predicate(p);\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n+    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n+        let graph_root = resolver.graph_root;\n+        LateResolutionVisitor {\n+            resolver,\n+            current_module: graph_root,\n+            ribs: PerNS {\n+                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n+            },\n+            label_ribs: Vec::new(),\n+            current_trait_ref: None,\n+            current_trait_assoc_types: Vec::new(),\n+            current_self_type: None,\n+            current_self_item: None,\n+            unused_labels: Default::default(),\n+            current_type_ascription: Vec::new(),\n+        }\n+    }\n+\n+    fn parent_scope(&self) -> ParentScope<'a> {\n+        ParentScope { module: self.current_module, ..self.dummy_parent_scope() }\n+    }\n+\n+    fn resolve_ident_in_lexical_scope(&mut self,\n+                                      ident: Ident,\n+                                      ns: Namespace,\n+                                      record_used_id: Option<NodeId>,\n+                                      path_span: Span)\n+                                      -> Option<LexicalScopeBinding<'a>> {\n+        self.resolver.resolve_ident_in_lexical_scope(\n+            ident, ns, &self.parent_scope(), record_used_id, path_span, &self.ribs[ns]\n+        )\n+    }\n+\n+    fn resolve_path(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n+    ) -> PathResult<'a> {\n+        self.resolver.resolve_path_with_ribs(\n+            path, opt_ns, &self.parent_scope(), record_used, path_span, crate_lint, &self.ribs\n+        )\n+    }\n+\n+    // AST resolution\n+    //\n+    // We maintain a list of value ribs and type ribs.\n+    //\n+    // Simultaneously, we keep track of the current position in the module\n+    // graph in the `current_module` pointer. When we go to resolve a name in\n+    // the value or type namespaces, we first look through all the ribs and\n+    // then query the module graph. When we resolve a name in the module\n+    // namespace, we can skip all the ribs (since nested modules are not\n+    // allowed within blocks in Rust) and jump straight to the current module\n+    // graph node.\n+    //\n+    // Named implementations are handled separately. When we find a method\n+    // call, we consult the module node to find all of the implementations in\n+    // scope. This information is lazily cached in the module node. We then\n+    // generate a fake \"implementation scope\" containing all the\n+    // implementations thus found, for compatibility with old resolve pass.\n+\n+    fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let id = self.definitions.local_def_id(id);\n+        let module = self.module_map.get(&id).cloned(); // clones a reference\n+        if let Some(module) = module {\n+            // Move down in the graph.\n+            let orig_module = replace(&mut self.current_module, module);\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n+\n+            self.finalize_current_module_macro_resolutions(module);\n+            let ret = f(self);\n+\n+            self.current_module = orig_module;\n+            self.ribs[ValueNS].pop();\n+            self.ribs[TypeNS].pop();\n+            ret\n+        } else {\n+            f(self)\n+        }\n+    }\n+\n+    /// Searches the current set of local scopes for labels. Returns the first non-`None` label that\n+    /// is returned by the given predicate function\n+    ///\n+    /// Stops after meeting a closure.\n+    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n+        where P: Fn(&Rib<'_, NodeId>, Ident) -> Option<R>\n+    {\n+        for rib in self.label_ribs.iter().rev() {\n+            match rib.kind {\n+                NormalRibKind => {}\n+                // If an invocation of this macro created `ident`, give up on `ident`\n+                // and switch to `ident`'s source from the macro definition.\n+                MacroDefinition(def) => {\n+                    if def == self.macro_def(ident.span.ctxt()) {\n+                        ident.span.remove_mark();\n+                    }\n+                }\n+                _ => {\n+                    // Do not resolve labels across function boundary\n+                    return None;\n+                }\n+            }\n+            let r = pred(rib, ident);\n+            if r.is_some() {\n+                return r;\n+            }\n+        }\n+        None\n+    }\n+\n+    fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n+        debug!(\"resolve_adt\");\n+        self.with_current_self_item(item, |this| {\n+            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                let item_def_id = this.definitions.local_def_id(item.id);\n+                this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n+                    visit::walk_item(this, item);\n+                });\n+            });\n+        });\n+    }\n+\n+    fn future_proof_import(&mut self, use_tree: &UseTree) {\n+        let segments = &use_tree.prefix.segments;\n+        if !segments.is_empty() {\n+            let ident = segments[0].ident;\n+            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n+                return;\n+            }\n+\n+            let nss = match use_tree.kind {\n+                UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n+                _ => &[TypeNS],\n+            };\n+            let report_error = |this: &Self, ns| {\n+                let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n+                this.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n+            };\n+\n+            for &ns in nss {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                    Some(LexicalScopeBinding::Res(..)) => {\n+                        report_error(self, ns);\n+                    }\n+                    Some(LexicalScopeBinding::Item(binding)) => {\n+                        let orig_blacklisted_binding =\n+                            replace(&mut self.blacklisted_binding, Some(binding));\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n+                                self.resolve_ident_in_lexical_scope(ident, ns, None,\n+                                                                    use_tree.prefix.span) {\n+                            report_error(self, ns);\n+                        }\n+                        self.blacklisted_binding = orig_blacklisted_binding;\n+                    }\n+                    None => {}\n+                }\n+            }\n+        } else if let UseTreeKind::Nested(use_trees) = &use_tree.kind {\n+            for (use_tree, _) in use_trees {\n+                self.future_proof_import(use_tree);\n+            }\n+        }\n+    }\n+\n+    fn resolve_item(&mut self, item: &Item) {\n+        let name = item.ident.name;\n+        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n+\n+        match item.node {\n+            ItemKind::TyAlias(_, ref generics) |\n+            ItemKind::OpaqueTy(_, ref generics) |\n+            ItemKind::Fn(_, _, ref generics, _) => {\n+                self.with_generic_param_rib(\n+                    HasGenericParams(generics, ItemRibKind),\n+                    |this| visit::walk_item(this, item)\n+                );\n+            }\n+\n+            ItemKind::Enum(_, ref generics) |\n+            ItemKind::Struct(_, ref generics) |\n+            ItemKind::Union(_, ref generics) => {\n+                self.resolve_adt(item, generics);\n+            }\n+\n+            ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n+                self.resolve_implementation(generics,\n+                                            opt_trait_ref,\n+                                            &self_type,\n+                                            item.id,\n+                                            impl_items),\n+\n+            ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n+                // Create a new rib for the trait-wide type parameters.\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                    let local_def_id = this.definitions.local_def_id(item.id);\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n+                        this.visit_generics(generics);\n+                        walk_list!(this, visit_param_bound, bounds);\n+\n+                        for trait_item in trait_items {\n+                            this.with_trait_items(trait_items, |this| {\n+                                let generic_params = HasGenericParams(\n+                                    &trait_item.generics,\n+                                    AssocItemRibKind,\n+                                );\n+                                this.with_generic_param_rib(generic_params, |this| {\n+                                    match trait_item.node {\n+                                        TraitItemKind::Const(ref ty, ref default) => {\n+                                            this.visit_ty(ty);\n+\n+                                            // Only impose the restrictions of\n+                                            // ConstRibKind for an actual constant\n+                                            // expression in a provided default.\n+                                            if let Some(ref expr) = *default{\n+                                                this.with_constant_rib(|this| {\n+                                                    this.visit_expr(expr);\n+                                                });\n+                                            }\n+                                        }\n+                                        TraitItemKind::Method(_, _) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Type(..) => {\n+                                            visit::walk_trait_item(this, trait_item)\n+                                        }\n+                                        TraitItemKind::Macro(_) => {\n+                                            panic!(\"unexpanded macro in resolve!\")\n+                                        }\n+                                    };\n+                                });\n+                            });\n+                        }\n+                    });\n+                });\n+            }\n+\n+            ItemKind::TraitAlias(ref generics, ref bounds) => {\n+                // Create a new rib for the trait-wide type parameters.\n+                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+                    let local_def_id = this.definitions.local_def_id(item.id);\n+                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n+                        this.visit_generics(generics);\n+                        walk_list!(this, visit_param_bound, bounds);\n+                    });\n+                });\n+            }\n+\n+            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n+                self.with_scope(item.id, |this| {\n+                    visit::walk_item(this, item);\n+                });\n+            }\n+\n+            ItemKind::Static(ref ty, _, ref expr) |\n+            ItemKind::Const(ref ty, ref expr) => {\n+                debug!(\"resolve_item ItemKind::Const\");\n+                self.with_item_rib(|this| {\n+                    this.visit_ty(ty);\n+                    this.with_constant_rib(|this| {\n+                        this.visit_expr(expr);\n+                    });\n+                });\n+            }\n+\n+            ItemKind::Use(ref use_tree) => {\n+                self.future_proof_import(use_tree);\n+            }\n+\n+            ItemKind::ExternCrate(..) |\n+            ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n+                // do nothing, these are just around to be encoded\n+            }\n+\n+            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n+        }\n+    }\n+\n+    fn with_generic_param_rib<'c, F>(&'c mut self, generic_params: GenericParameters<'a, 'c>, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        debug!(\"with_generic_param_rib\");\n+        match generic_params {\n+            HasGenericParams(generics, rib_kind) => {\n+                let mut function_type_rib = Rib::new(rib_kind);\n+                let mut function_value_rib = Rib::new(rib_kind);\n+                let mut seen_bindings = FxHashMap::default();\n+                for param in &generics.params {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {}\n+                        GenericParamKind::Type { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                                    ident.name,\n+                                    *span,\n+                                );\n+                                resolve_error(self, param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                            // Plain insert (no renaming).\n+                            let res = Res::Def(\n+                                DefKind::TyParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n+                            function_type_rib.bindings.insert(ident, res);\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n+                        }\n+                        GenericParamKind::Const { .. } => {\n+                            let ident = param.ident.modern();\n+                            debug!(\"with_generic_param_rib: {}\", param.id);\n+\n+                            if seen_bindings.contains_key(&ident) {\n+                                let span = seen_bindings.get(&ident).unwrap();\n+                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n+                                    ident.name,\n+                                    *span,\n+                                );\n+                                resolve_error(self, param.ident.span, err);\n+                            }\n+                            seen_bindings.entry(ident).or_insert(param.ident.span);\n+\n+                            let res = Res::Def(\n+                                DefKind::ConstParam,\n+                                self.definitions.local_def_id(param.id),\n+                            );\n+                            function_value_rib.bindings.insert(ident, res);\n+                            self.record_partial_res(param.id, PartialRes::new(res));\n+                        }\n+                    }\n+                }\n+                self.ribs[ValueNS].push(function_value_rib);\n+                self.ribs[TypeNS].push(function_type_rib);\n+            }\n+\n+            NoGenericParams => {\n+                // Nothing to do.\n+            }\n+        }\n+\n+        f(self);\n+\n+        if let HasGenericParams(..) = generic_params {\n+            self.ribs[TypeNS].pop();\n+            self.ribs[ValueNS].pop();\n+        }\n+    }\n+\n+    fn with_label_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        self.label_ribs.push(Rib::new(NormalRibKind));\n+        f(self);\n+        self.label_ribs.pop();\n+    }\n+\n+    fn with_item_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n+        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n+        f(self);\n+        self.ribs[TypeNS].pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn with_constant_rib<F>(&mut self, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        debug!(\"with_constant_rib\");\n+        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n+        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n+        f(self);\n+        self.label_ribs.pop();\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        // Handle nested impls (inside fn bodies)\n+        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n+        let result = f(self);\n+        self.current_self_type = previous_value;\n+        result\n+    }\n+\n+    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n+        let result = f(self);\n+        self.current_self_item = previous_value;\n+        result\n+    }\n+\n+    /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n+    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n+    {\n+        let trait_assoc_types = replace(\n+            &mut self.current_trait_assoc_types,\n+            trait_items.iter().filter_map(|item| match &item.node {\n+                TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n+                _ => None,\n+            }).collect(),\n+        );\n+        let result = f(self);\n+        self.current_trait_assoc_types = trait_assoc_types;\n+        result\n+    }\n+\n+    /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n+    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n+    {\n+        let mut new_val = None;\n+        let mut new_id = None;\n+        if let Some(trait_ref) = opt_trait_ref {\n+            let path: Vec<_> = Segment::from_path(&trait_ref.path);\n+            let res = self.smart_resolve_path_fragment(\n+                trait_ref.ref_id,\n+                None,\n+                &path,\n+                trait_ref.path.span,\n+                PathSource::Trait(AliasPossibility::No),\n+                CrateLint::SimplePath(trait_ref.ref_id),\n+            ).base_res();\n+            if res != Res::Err {\n+                new_id = Some(res.def_id());\n+                let span = trait_ref.path.span;\n+                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n+                    self.resolve_path(\n+                        &path,\n+                        Some(TypeNS),\n+                        false,\n+                        span,\n+                        CrateLint::SimplePath(trait_ref.ref_id),\n+                    )\n+                {\n+                    new_val = Some((module, trait_ref.clone()));\n+                }\n+            }\n+        }\n+        let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n+        let result = f(self, new_id);\n+        self.current_trait_ref = original_trait_ref;\n+        result\n+    }\n+\n+    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        let mut self_type_rib = Rib::new(NormalRibKind);\n+\n+        // Plain insert (no renaming, since types are not currently hygienic)\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self.ribs[TypeNS].push(self_type_rib);\n+        f(self);\n+        self.ribs[TypeNS].pop();\n+    }\n+\n+    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        let self_res = Res::SelfCtor(impl_id);\n+        let mut self_type_rib = Rib::new(NormalRibKind);\n+        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n+        self.ribs[ValueNS].push(self_type_rib);\n+        f(self);\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    fn resolve_implementation(&mut self,\n+                              generics: &Generics,\n+                              opt_trait_reference: &Option<TraitRef>,\n+                              self_type: &Ty,\n+                              item_id: NodeId,\n+                              impl_items: &[ImplItem]) {\n+        debug!(\"resolve_implementation\");\n+        // If applicable, create a rib for the type parameters.\n+        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n+            // Dummy self type for better errors if `Self` is used in the trait path.\n+            this.with_self_rib(Res::SelfTy(None, None), |this| {\n+                // Resolve the trait reference, if necessary.\n+                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n+                    let item_def_id = this.definitions.local_def_id(item_id);\n+                    this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n+                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n+                            // Resolve type arguments in the trait path.\n+                            visit::walk_trait_ref(this, trait_ref);\n+                        }\n+                        // Resolve the self type.\n+                        this.visit_ty(self_type);\n+                        // Resolve the generic parameters.\n+                        this.visit_generics(generics);\n+                        // Resolve the items within the impl.\n+                        this.with_current_self_type(self_type, |this| {\n+                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n+                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n+                                for impl_item in impl_items {\n+                                    this.resolver.resolve_visibility(\n+                                        &impl_item.vis, &this.parent_scope()\n+                                    );\n+                                    // We also need a new scope for the impl item type parameters.\n+                                    let generic_params = HasGenericParams(&impl_item.generics,\n+                                                                          AssocItemRibKind);\n+                                    this.with_generic_param_rib(generic_params, |this| {\n+                                        use crate::ResolutionError::*;\n+                                        match impl_item.node {\n+                                            ImplItemKind::Const(..) => {\n+                                                debug!(\n+                                                    \"resolve_implementation ImplItemKind::Const\",\n+                                                );\n+                                                // If this is a trait impl, ensure the const\n+                                                // exists in trait\n+                                                this.check_trait_item(\n+                                                    impl_item.ident,\n+                                                    ValueNS,\n+                                                    impl_item.span,\n+                                                    |n, s| ConstNotMemberOfTrait(n, s),\n+                                                );\n+\n+                                                this.with_constant_rib(|this| {\n+                                                    visit::walk_impl_item(this, impl_item)\n+                                                });\n+                                            }\n+                                            ImplItemKind::Method(..) => {\n+                                                // If this is a trait impl, ensure the method\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      ValueNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| MethodNotMemberOfTrait(n, s));\n+\n+                                                visit::walk_impl_item(this, impl_item);\n+                                            }\n+                                            ImplItemKind::TyAlias(ref ty) => {\n+                                                // If this is a trait impl, ensure the type\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      TypeNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| TypeNotMemberOfTrait(n, s));\n+\n+                                                this.visit_ty(ty);\n+                                            }\n+                                            ImplItemKind::OpaqueTy(ref bounds) => {\n+                                                // If this is a trait impl, ensure the type\n+                                                // exists in trait\n+                                                this.check_trait_item(impl_item.ident,\n+                                                                      TypeNS,\n+                                                                      impl_item.span,\n+                                                    |n, s| TypeNotMemberOfTrait(n, s));\n+\n+                                                for bound in bounds {\n+                                                    this.visit_param_bound(bound);\n+                                                }\n+                                            }\n+                                            ImplItemKind::Macro(_) =>\n+                                                panic!(\"unexpanded macro in resolve!\"),\n+                                        }\n+                                    });\n+                                }\n+                            });\n+                        });\n+                    });\n+                });\n+            });\n+        });\n+    }\n+\n+    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n+        where F: FnOnce(Name, &str) -> ResolutionError<'_>\n+    {\n+        // If there is a TraitRef in scope for an impl, then the method must be in the\n+        // trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                parent_scope,\n+                false,\n+                span,\n+            ).is_err() {\n+                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n+                resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n+            }\n+        }\n+    }\n+\n+    fn resolve_local(&mut self, local: &Local) {\n+        // Resolve the type.\n+        walk_list!(self, visit_ty, &local.ty);\n+\n+        // Resolve the initializer.\n+        walk_list!(self, visit_expr, &local.init);\n+\n+        // Resolve the pattern.\n+        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n+    }\n+\n+    // build a map from pattern identifiers to binding-info's.\n+    // this is done hygienically. This could arise for a macro\n+    // that expands into an or-pattern where one 'x' was from the\n+    // user and one 'x' came from the macro.\n+    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n+        let mut binding_map = FxHashMap::default();\n+\n+        pat.walk(&mut |pat| {\n+            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n+                if sub_pat.is_some() || match self.partial_res_map.get(&pat.id)\n+                                                                  .map(|res| res.base_res()) {\n+                    Some(Res::Local(..)) => true,\n+                    _ => false,\n+                } {\n+                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n+                    binding_map.insert(ident, binding_info);\n+                }\n+            }\n+            true\n+        });\n+\n+        binding_map\n+    }\n+\n+    // Checks that all of the arms in an or-pattern have exactly the\n+    // same set of bindings, with the same binding modes for each.\n+    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n+        if pats.is_empty() {\n+            return;\n+        }\n+\n+        let mut missing_vars = FxHashMap::default();\n+        let mut inconsistent_vars = FxHashMap::default();\n+        for (i, p) in pats.iter().enumerate() {\n+            let map_i = self.binding_mode_map(&p);\n+\n+            for (j, q) in pats.iter().enumerate() {\n+                if i == j {\n+                    continue;\n+                }\n+\n+                let map_j = self.binding_mode_map(&q);\n+                for (&key, &binding_i) in &map_i {\n+                    if map_j.is_empty() {                   // Account for missing bindings when\n+                        let binding_error = missing_vars    // `map_j` has none.\n+                            .entry(key.name)\n+                            .or_insert(BindingError {\n+                                name: key.name,\n+                                origin: BTreeSet::new(),\n+                                target: BTreeSet::new(),\n+                            });\n+                        binding_error.origin.insert(binding_i.span);\n+                        binding_error.target.insert(q.span);\n+                    }\n+                    for (&key_j, &binding_j) in &map_j {\n+                        match map_i.get(&key_j) {\n+                            None => {  // missing binding\n+                                let binding_error = missing_vars\n+                                    .entry(key_j.name)\n+                                    .or_insert(BindingError {\n+                                        name: key_j.name,\n+                                        origin: BTreeSet::new(),\n+                                        target: BTreeSet::new(),\n+                                    });\n+                                binding_error.origin.insert(binding_j.span);\n+                                binding_error.target.insert(p.span);\n+                            }\n+                            Some(binding_i) => {  // check consistent binding\n+                                if binding_i.binding_mode != binding_j.binding_mode {\n+                                    inconsistent_vars\n+                                        .entry(key.name)\n+                                        .or_insert((binding_j.span, binding_i.span));\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+        missing_vars.sort();\n+        for (_, v) in missing_vars {\n+            resolve_error(self,\n+                          *v.origin.iter().next().unwrap(),\n+                          ResolutionError::VariableNotBoundInPattern(v));\n+        }\n+        let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n+        inconsistent_vars.sort();\n+        for (name, v) in inconsistent_vars {\n+            resolve_error(self, v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n+        }\n+    }\n+\n+    fn resolve_arm(&mut self, arm: &Arm) {\n+        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+\n+        self.resolve_pats(&arm.pats, PatternSource::Match);\n+\n+        if let Some(ref expr) = arm.guard {\n+            self.visit_expr(expr)\n+        }\n+        self.visit_expr(&arm.body);\n+\n+        self.ribs[ValueNS].pop();\n+    }\n+\n+    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n+    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n+        let mut bindings_list = FxHashMap::default();\n+        for pat in pats {\n+            self.resolve_pattern(pat, source, &mut bindings_list);\n+        }\n+        // This has to happen *after* we determine which pat_idents are variants\n+        self.check_consistent_bindings(pats);\n+    }\n+\n+    fn resolve_block(&mut self, block: &Block) {\n+        debug!(\"(resolving block) entering block\");\n+        // Move down in the graph, if there's an anonymous module rooted here.\n+        let orig_module = self.current_module;\n+        let anonymous_module = self.block_map.get(&block.id).cloned(); // clones a reference\n+\n+        let mut num_macro_definition_ribs = 0;\n+        if let Some(anonymous_module) = anonymous_module {\n+            debug!(\"(resolving block) found anonymous module, moving down\");\n+            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n+            self.current_module = anonymous_module;\n+            self.finalize_current_module_macro_resolutions(anonymous_module);\n+        } else {\n+            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+        }\n+\n+        // Descend into the block.\n+        for stmt in &block.stmts {\n+            if let StmtKind::Item(ref item) = stmt.node {\n+                if let ItemKind::MacroDef(..) = item.node {\n+                    num_macro_definition_ribs += 1;\n+                    let res = self.definitions.local_def_id(item.id);\n+                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n+                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n+                }\n+            }\n+\n+            self.visit_stmt(stmt);\n+        }\n+\n+        // Move back up.\n+        self.current_module = orig_module;\n+        for _ in 0 .. num_macro_definition_ribs {\n+            self.ribs[ValueNS].pop();\n+            self.label_ribs.pop();\n+        }\n+        self.ribs[ValueNS].pop();\n+        if anonymous_module.is_some() {\n+            self.ribs[TypeNS].pop();\n+        }\n+        debug!(\"(resolving block) leaving block\");\n+    }\n+\n+    fn fresh_binding(&mut self,\n+                     ident: Ident,\n+                     pat_id: NodeId,\n+                     outer_pat_id: NodeId,\n+                     pat_src: PatternSource,\n+                     bindings: &mut FxHashMap<Ident, NodeId>)\n+                     -> Res {\n+        // Add the binding to the local ribs, if it\n+        // doesn't already exist in the bindings map. (We\n+        // must not add it if it's in the bindings map\n+        // because that breaks the assumptions later\n+        // passes make about or-patterns.)\n+        let ident = ident.modern_and_legacy();\n+        let mut res = Res::Local(pat_id);\n+        match bindings.get(&ident).cloned() {\n+            Some(id) if id == outer_pat_id => {\n+                // `Variant(a, a)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n+                        &ident.as_str())\n+                );\n+            }\n+            Some(..) if pat_src == PatternSource::FnParam => {\n+                // `fn f(a: u8, a: u8)`, error\n+                resolve_error(\n+                    self,\n+                    ident.span,\n+                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n+                        &ident.as_str())\n+                );\n+            }\n+            Some(..) if pat_src == PatternSource::Match ||\n+                        pat_src == PatternSource::Let => {\n+                // `Variant1(a) | Variant2(a)`, ok\n+                // Reuse definition from the first `a`.\n+                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n+            }\n+            Some(..) => {\n+                span_bug!(ident.span, \"two bindings with the same name from \\\n+                                       unexpected pattern source {:?}\", pat_src);\n+            }\n+            None => {\n+                // A completely fresh binding, add to the lists if it's valid.\n+                if ident.name != kw::Invalid {\n+                    bindings.insert(ident, outer_pat_id);\n+                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n+                }\n+            }\n+        }\n+\n+        res\n+    }\n+\n+    fn resolve_pattern(&mut self,\n+                       pat: &Pat,\n+                       pat_src: PatternSource,\n+                       // Maps idents to the node ID for the\n+                       // outermost pattern that binds them.\n+                       bindings: &mut FxHashMap<Ident, NodeId>) {\n+        // Visit all direct subpatterns of this pattern.\n+        let outer_pat_id = pat.id;\n+        pat.walk(&mut |pat| {\n+            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n+            match pat.node {\n+                PatKind::Ident(bmode, ident, ref opt_pat) => {\n+                    // First try to resolve the identifier as some existing\n+                    // entity, then fall back to a fresh binding.\n+                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n+                                                                      None, pat.span)\n+                                      .and_then(LexicalScopeBinding::item);\n+                    let res = binding.map(NameBinding::res).and_then(|res| {\n+                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n+                            bmode == BindingMode::ByValue(Mutability::Immutable);\n+                        match res {\n+                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n+                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n+                                // Disambiguate in favor of a unit struct/variant\n+                                // or constant pattern.\n+                                self.record_use(ident, ValueNS, binding.unwrap(), false);\n+                                Some(res)\n+                            }\n+                            Res::Def(DefKind::Ctor(..), _)\n+                            | Res::Def(DefKind::Const, _)\n+                            | Res::Def(DefKind::Static, _) => {\n+                                // This is unambiguously a fresh binding, either syntactically\n+                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n+                                // to something unusable as a pattern (e.g., constructor function),\n+                                // but we still conservatively report an error, see\n+                                // issues/33118#issuecomment-233962221 for one reason why.\n+                                resolve_error(\n+                                    self,\n+                                    ident.span,\n+                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n+                                        pat_src.descr(), ident.name, binding.unwrap())\n+                                );\n+                                None\n+                            }\n+                            Res::Def(DefKind::Fn, _) | Res::Err => {\n+                                // These entities are explicitly allowed\n+                                // to be shadowed by fresh bindings.\n+                                None\n+                            }\n+                            res => {\n+                                span_bug!(ident.span, \"unexpected resolution for an \\\n+                                                       identifier in pattern: {:?}\", res);\n+                            }\n+                        }\n+                    }).unwrap_or_else(|| {\n+                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n+                    });\n+\n+                    self.record_partial_res(pat.id, PartialRes::new(res));\n+                }\n+\n+                PatKind::TupleStruct(ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n+                }\n+\n+                PatKind::Path(ref qself, ref path) => {\n+                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n+                }\n+\n+                PatKind::Struct(ref path, ..) => {\n+                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n+                }\n+\n+                _ => {}\n+            }\n+            true\n+        });\n+\n+        visit::walk_pat(self, pat);\n+    }\n+\n+    // High-level and context dependent path resolution routine.\n+    // Resolves the path and records the resolution into definition map.\n+    // If resolution fails tries several techniques to find likely\n+    // resolution candidates, suggest imports or other help, and report\n+    // errors in user friendly way.\n+    fn smart_resolve_path(&mut self,\n+                          id: NodeId,\n+                          qself: Option<&QSelf>,\n+                          path: &Path,\n+                          source: PathSource<'_>) {\n+        self.smart_resolve_path_fragment(\n+            id,\n+            qself,\n+            &Segment::from_path(path),\n+            path.span,\n+            source,\n+            CrateLint::SimplePath(id),\n+        );\n+    }\n+\n+    fn smart_resolve_path_fragment(&mut self,\n+                                   id: NodeId,\n+                                   qself: Option<&QSelf>,\n+                                   path: &[Segment],\n+                                   span: Span,\n+                                   source: PathSource<'_>,\n+                                   crate_lint: CrateLint)\n+                                   -> PartialRes {\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+\n+        let report_errors = |this: &mut Self, res: Option<Res>| {\n+            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+            let def_id = this.current_module.normal_ancestor_id;\n+            let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n+            let better = res.is_some();\n+            this.use_injections.push(UseError { err, candidates, node_id, better });\n+            PartialRes::new(Res::Err)\n+        };\n+\n+        let partial_res = match self.resolve_qpath_anywhere(\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+            source.defer_to_typeck(),\n+            crate_lint,\n+        ) {\n+            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n+                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n+                    partial_res\n+                } else {\n+                    // Add a temporary hack to smooth the transition to new struct ctor\n+                    // visibility rules. See #38932 for more details.\n+                    let mut res = None;\n+                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n+                        if let Some((ctor_res, ctor_vis))\n+                                = self.struct_constructors.get(&def_id).cloned() {\n+                            if is_expected(ctor_res) &&\n+                               self.is_accessible_from(ctor_vis, self.current_module) {\n+                                let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n+                                self.session.buffer_lint(lint, id, span,\n+                                    \"private struct constructors are not usable through \\\n+                                     re-exports in outer modules\",\n+                                );\n+                                res = Some(PartialRes::new(ctor_res));\n+                            }\n+                        }\n+                    }\n+\n+                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n+                }\n+            }\n+            Some(partial_res) if source.defer_to_typeck() => {\n+                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n+                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n+                // it needs to be added to the trait map.\n+                if ns == ValueNS {\n+                    let item_name = path.last().unwrap().ident;\n+                    let traits = self.get_traits_containing_item(item_name, ns);\n+                    self.trait_map.insert(id, traits);\n+                }\n+\n+                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n+                std_path.extend(path);\n+                if self.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n+                    let cl = CrateLint::No;\n+                    let ns = Some(ns);\n+                    if let PathResult::Module(_) | PathResult::NonModule(_) =\n+                            self.resolve_path(&std_path, ns, false, span, cl) {\n+                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n+                        let item_span = path.iter().last().map(|segment| segment.ident.span)\n+                            .unwrap_or(span);\n+                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n+                        let mut hm = self.session.confused_type_with_std_module.borrow_mut();\n+                        hm.insert(item_span, span);\n+                        // In some places (E0223) we only have access to the full path\n+                        hm.insert(span, span);\n+                    }\n+                }\n+                partial_res\n+            }\n+            _ => report_errors(self, None)\n+        };\n+\n+        if let PathSource::TraitItem(..) = source {} else {\n+            // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n+            self.record_partial_res(id, partial_res);\n+        }\n+        partial_res\n+    }\n+\n+    fn self_type_is_available(&mut self, span: Span) -> bool {\n+        let binding = self.resolve_ident_in_lexical_scope(\n+            Ident::with_empty_ctxt(kw::SelfUpper),\n+            TypeNS,\n+            None,\n+            span,\n+        );\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+    }\n+\n+    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+        let ident = Ident::new(kw::SelfLower, self_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n+        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n+    }\n+\n+    // Resolve in alternative namespaces if resolution in the primary namespace fails.\n+    fn resolve_qpath_anywhere(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        primary_ns: Namespace,\n+        span: Span,\n+        defer_to_typeck: bool,\n+        crate_lint: CrateLint,\n+    ) -> Option<PartialRes> {\n+        let mut fin_res = None;\n+        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n+            if i == 0 || ns != primary_ns {\n+                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n+                    // If defer_to_typeck, then resolution > no resolution,\n+                    // otherwise full resolution > partial resolution > no resolution.\n+                    Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n+                                         defer_to_typeck =>\n+                        return Some(partial_res),\n+                    partial_res => if fin_res.is_none() { fin_res = partial_res },\n+                }\n+            }\n+        }\n+\n+        // `MacroNS`\n+        assert!(primary_ns != MacroNS);\n+        if qself.is_none() {\n+            let path_seg = |seg: &Segment| PathSegment::from_ident(seg.ident);\n+            let path = Path { segments: path.iter().map(path_seg).collect(), span };\n+            let parent_scope = &self.parent_scope();\n+            if let Ok((_, res)) =\n+                    self.resolve_macro_path(&path, None, parent_scope, false, false) {\n+                return Some(PartialRes::new(res));\n+            }\n+        }\n+\n+        fin_res\n+    }\n+\n+    /// Handles paths that may refer to associated items.\n+    fn resolve_qpath(\n+        &mut self,\n+        id: NodeId,\n+        qself: Option<&QSelf>,\n+        path: &[Segment],\n+        ns: Namespace,\n+        span: Span,\n+        crate_lint: CrateLint,\n+    ) -> Option<PartialRes> {\n+        debug!(\n+            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n+            id,\n+            qself,\n+            path,\n+            ns,\n+            span,\n+        );\n+\n+        if let Some(qself) = qself {\n+            if qself.position == 0 {\n+                // This is a case like `<T>::B`, where there is no\n+                // trait to resolve.  In that case, we leave the `B`\n+                // segment to be resolved by type-check.\n+                return Some(PartialRes::with_unresolved_segments(\n+                    Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n+                ));\n+            }\n+\n+            // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n+            //\n+            // Currently, `path` names the full item (`A::B::C`, in\n+            // our example).  so we extract the prefix of that that is\n+            // the trait (the slice upto and including\n+            // `qself.position`). And then we recursively resolve that,\n+            // but with `qself` set to `None`.\n+            //\n+            // However, setting `qself` to none (but not changing the\n+            // span) loses the information about where this path\n+            // *actually* appears, so for the purposes of the crate\n+            // lint we pass along information that this is the trait\n+            // name from a fully qualified path, and this also\n+            // contains the full span (the `CrateLint::QPathTrait`).\n+            let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n+            let partial_res = self.smart_resolve_path_fragment(\n+                id,\n+                None,\n+                &path[..=qself.position],\n+                span,\n+                PathSource::TraitItem(ns),\n+                CrateLint::QPathTrait {\n+                    qpath_id: id,\n+                    qpath_span: qself.path_span,\n+                },\n+            );\n+\n+            // The remaining segments (the `C` in our example) will\n+            // have to be resolved by type-check, since that requires doing\n+            // trait resolution.\n+            return Some(PartialRes::with_unresolved_segments(\n+                partial_res.base_res(),\n+                partial_res.unresolved_segments() + path.len() - qself.position - 1,\n+            ));\n+        }\n+\n+        let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n+            PathResult::NonModule(path_res) => path_res,\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n+                PartialRes::new(module.res().unwrap())\n+            }\n+            // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n+            // don't report an error right away, but try to fallback to a primitive type.\n+            // So, we are still able to successfully resolve something like\n+            //\n+            // use std::u8; // bring module u8 in scope\n+            // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n+            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n+            //                     // not to non-existent std::u8::max_value\n+            // }\n+            //\n+            // Such behavior is required for backward compatibility.\n+            // The same fallback is used when `a` resolves to nothing.\n+            PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n+            PathResult::Failed { .. }\n+                    if (ns == TypeNS || path.len() > 1) &&\n+                       self.primitive_type_table.primitive_types\n+                           .contains_key(&path[0].ident.name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n+                PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n+            }\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                PartialRes::new(module.res().unwrap()),\n+            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n+                resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n+                PartialRes::new(Res::Err)\n+            }\n+            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n+            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n+        };\n+\n+        if path.len() > 1 && result.base_res() != Res::Err &&\n+           path[0].ident.name != kw::PathRoot &&\n+           path[0].ident.name != kw::DollarCrate {\n+            let unqualified_result = {\n+                match self.resolve_path(\n+                    &[*path.last().unwrap()],\n+                    Some(ns),\n+                    false,\n+                    span,\n+                    CrateLint::No,\n+                ) {\n+                    PathResult::NonModule(path_res) => path_res.base_res(),\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.res().unwrap(),\n+                    _ => return Some(result),\n+                }\n+            };\n+            if result.base_res() == unqualified_result {\n+                let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n+                self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+            }\n+        }\n+\n+        Some(result)\n+    }\n+\n+    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n+        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n+    {\n+        if let Some(label) = label {\n+            self.unused_labels.insert(id, label.ident.span);\n+            self.with_label_rib(|this| {\n+                let ident = label.ident.modern_and_legacy();\n+                this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n+                f(this);\n+            });\n+        } else {\n+            f(self);\n+        }\n+    }\n+\n+    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n+        self.with_resolved_label(label, id, |this| this.visit_block(block));\n+    }\n+\n+    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n+        // First, record candidate traits for this expression if it could\n+        // result in the invocation of a method call.\n+\n+        self.record_candidate_traits_for_expr_if_necessary(expr);\n+\n+        // Next, resolve the node.\n+        match expr.node {\n+            ExprKind::Path(ref qself, ref path) => {\n+                self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Struct(ref path, ..) => {\n+                self.smart_resolve_path(expr.id, None, path, PathSource::Struct);\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n+                let node_id = self.search_label(label.ident, |rib, ident| {\n+                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n+                });\n+                match node_id {\n+                    None => {\n+                        // Search again for close matches...\n+                        // Picks the first label that is \"close enough\", which is not necessarily\n+                        // the closest match\n+                        let close_match = self.search_label(label.ident, |rib, ident| {\n+                            let names = rib.bindings.iter().filter_map(|(id, _)| {\n+                                if id.span.ctxt() == label.ident.span.ctxt() {\n+                                    Some(&id.name)\n+                                } else {\n+                                    None\n+                                }\n+                            });\n+                            find_best_match_for_name(names, &*ident.as_str(), None)\n+                        });\n+                        self.record_partial_res(expr.id, PartialRes::new(Res::Err));\n+                        resolve_error(self,\n+                                      label.ident.span,\n+                                      ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n+                                                                       close_match));\n+                    }\n+                    Some(node_id) => {\n+                        // Since this res is a label, it is never read.\n+                        self.label_res_map.insert(expr.id, node_id);\n+                        self.unused_labels.remove(&node_id);\n+                    }\n+                }\n+\n+                // visit `break` argument if any\n+                visit::walk_expr(self, expr);\n+            }\n+\n+            ExprKind::Let(ref pats, ref scrutinee) => {\n+                self.visit_expr(scrutinee);\n+                self.resolve_pats(pats, PatternSource::Let);\n+            }\n+\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                self.visit_expr(cond);\n+                self.visit_block(then);\n+                self.ribs[ValueNS].pop();\n+\n+                opt_else.as_ref().map(|expr| self.visit_expr(expr));\n+            }\n+\n+            ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n+\n+            ExprKind::While(ref subexpression, ref block, label) => {\n+                self.with_resolved_label(label, expr.id, |this| {\n+                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                    this.visit_expr(subexpression);\n+                    this.visit_block(block);\n+                    this.ribs[ValueNS].pop();\n+                });\n+            }\n+\n+            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n+                self.visit_expr(subexpression);\n+                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n+                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n+\n+                self.resolve_labeled_block(label, expr.id, block);\n+\n+                self.ribs[ValueNS].pop();\n+            }\n+\n+            ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n+\n+            // Equivalent to `visit::walk_expr` + passing some context to children.\n+            ExprKind::Field(ref subexpression, _) => {\n+                self.resolve_expr(subexpression, Some(expr));\n+            }\n+            ExprKind::MethodCall(ref segment, ref arguments) => {\n+                let mut arguments = arguments.iter();\n+                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+                self.visit_path_segment(expr.span, segment);\n+            }\n+\n+            ExprKind::Call(ref callee, ref arguments) => {\n+                self.resolve_expr(callee, Some(expr));\n+                for argument in arguments {\n+                    self.resolve_expr(argument, None);\n+                }\n+            }\n+            ExprKind::Type(ref type_expr, _) => {\n+                self.current_type_ascription.push(type_expr.span);\n+                visit::walk_expr(self, expr);\n+                self.current_type_ascription.pop();\n+            }\n+            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n+            // resolve the arguments within the proper scopes so that usages of them inside the\n+            // closure are detected as upvars rather than normal closure arg usages.\n+            ExprKind::Closure(\n+                _, IsAsync::Async { .. }, _,\n+                ref fn_decl, ref body, _span,\n+            ) => {\n+                let rib_kind = NormalRibKind;\n+                self.ribs[ValueNS].push(Rib::new(rib_kind));\n+                // Resolve arguments:\n+                let mut bindings_list = FxHashMap::default();\n+                for argument in &fn_decl.inputs {\n+                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n+                    self.visit_ty(&argument.ty);\n+                }\n+                // No need to resolve return type-- the outer closure return type is\n+                // FunctionRetTy::Default\n+\n+                // Now resolve the inner closure\n+                {\n+                    // No need to resolve arguments: the inner closure has none.\n+                    // Resolve the return type:\n+                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n+                    // Resolve the body\n+                    self.visit_expr(body);\n+                }\n+                self.ribs[ValueNS].pop();\n+            }\n+            _ => {\n+                visit::walk_expr(self, expr);\n+            }\n+        }\n+    }\n+\n+    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n+        match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                // FIXME(#6890): Even though you can't treat a method like a\n+                // field, we need to add any trait methods we find that match\n+                // the field name so that we can do some nice error reporting\n+                // later on in typeck.\n+                let traits = self.get_traits_containing_item(ident, ValueNS);\n+                self.trait_map.insert(expr.id, traits);\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                debug!(\"(recording candidate traits for expr) recording traits for {}\",\n+                       expr.id);\n+                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n+                self.trait_map.insert(expr.id, traits);\n+            }\n+            _ => {\n+                // Nothing to do.\n+            }\n+        }\n+    }\n+\n+    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)\n+                                  -> Vec<TraitCandidate> {\n+        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n+\n+        let mut found_traits = Vec::new();\n+        // Look for the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n+            if self.resolve_ident_in_module(\n+                ModuleOrUniformRoot::Module(module),\n+                ident,\n+                ns,\n+                parent_scope,\n+                false,\n+                module.span,\n+            ).is_ok() {\n+                let def_id = module.def_id().unwrap();\n+                found_traits.push(TraitCandidate { def_id: def_id, import_ids: smallvec![] });\n+            }\n+        }\n+\n+        ident.span = ident.span.modern();\n+        let mut search_module = self.current_module;\n+        loop {\n+            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n+            search_module = unwrap_or!(\n+                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n+            );\n+        }\n+\n+        if let Some(prelude) = self.prelude {\n+            if !search_module.no_implicit_prelude {\n+                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n+            }\n+        }\n+\n+        found_traits\n+    }\n+\n+    fn get_traits_in_module_containing_item(&mut self,\n+                                            ident: Ident,\n+                                            ns: Namespace,\n+                                            module: Module<'a>,\n+                                            found_traits: &mut Vec<TraitCandidate>) {\n+        assert!(ns == TypeNS || ns == ValueNS);\n+        let mut traits = module.traits.borrow_mut();\n+        if traits.is_none() {\n+            let mut collected_traits = Vec::new();\n+            module.for_each_child(|name, ns, binding| {\n+                if ns != TypeNS { return }\n+                match binding.res() {\n+                    Res::Def(DefKind::Trait, _) |\n+                    Res::Def(DefKind::TraitAlias, _) => collected_traits.push((name, binding)),\n+                    _ => (),\n+                }\n+            });\n+            *traits = Some(collected_traits.into_boxed_slice());\n+        }\n+\n+        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n+            // Traits have pseudo-modules that can be used to search for the given ident.\n+            if let Some(module) = binding.module() {\n+                let mut ident = ident;\n+                if ident.span.glob_adjust(\n+                    module.expansion,\n+                    binding.span,\n+                ).is_none() {\n+                    continue\n+                }\n+                let parent_scope = &self.parent_scope();\n+                if self.resolve_ident_in_module_unadjusted(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    parent_scope,\n+                    false,\n+                    module.span,\n+                ).is_ok() {\n+                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                    let trait_def_id = module.def_id().unwrap();\n+                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+                }\n+            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n+                // For now, just treat all trait aliases as possible candidates, since we don't\n+                // know if the ident is somewhere in the transitive bounds.\n+                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n+                let trait_def_id = binding.res().def_id();\n+                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n+            } else {\n+                bug!(\"candidate is not trait or trait alias?\")\n+            }\n+        }\n+    }\n+\n+    fn find_transitive_imports(&mut self, mut kind: &NameBindingKind<'_>,\n+                               trait_name: Ident) -> SmallVec<[NodeId; 1]> {\n+        let mut import_ids = smallvec![];\n+        while let NameBindingKind::Import { directive, binding, .. } = kind {\n+            self.maybe_unused_trait_imports.insert(directive.id);\n+            self.add_to_glob_map(&directive, trait_name);\n+            import_ids.push(directive.id);\n+            kind = &binding.kind;\n+        };\n+        import_ids\n+    }\n+}\n+\n+impl<'a> Resolver<'a> {\n+    pub(crate) fn late_resolve_crate(&mut self, krate: &Crate) {\n+        let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n+        let module = late_resolution_visitor.current_module;\n+        late_resolution_visitor.finalize_current_module_macro_resolutions(module);\n+        visit::walk_crate(&mut late_resolution_visitor, krate);\n+        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n+            self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n+        }\n+    }\n+}"}, {"sha": "ed76111bd58168d2eeb5d1658a36ea81b39ef12f", "filename": "src/librustc_resolve/late/diagnostics.rs", "status": "added", "additions": 769, "deletions": 0, "changes": 769, "blob_url": "https://github.com/rust-lang/rust/blob/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Fdiagnostics.rs?ref=ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "patch": "@@ -0,0 +1,769 @@\n+use crate::{CrateLint, Module, ModuleKind, ModuleOrUniformRoot};\n+use crate::{PathResult, PathSource, RibKind, Segment};\n+use crate::path_names_to_string;\n+use crate::diagnostics::{add_typo_suggestion, add_module_candidates};\n+use crate::diagnostics::{ImportSuggestion, TypoSuggestion};\n+use crate::late::LateResolutionVisitor;\n+\n+use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n+use log::debug;\n+use rustc::hir::def::{self, DefKind, CtorKind};\n+use rustc::hir::def::Namespace::{self, *};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::PrimTy;\n+use rustc::session::config::nightly_options;\n+use rustc::util::nodemap::FxHashSet;\n+use syntax::ast::{self, Expr, ExprKind, Ident, NodeId, Path, Ty, TyKind};\n+use syntax::ext::base::MacroKind;\n+use syntax::symbol::kw;\n+use syntax::util::lev_distance::find_best_match_for_name;\n+use syntax_pos::Span;\n+\n+type Res = def::Res<ast::NodeId>;\n+\n+/// A field or associated item from self type suggested in case of resolution failure.\n+enum AssocSuggestion {\n+    Field,\n+    MethodWithSelf,\n+    AssocItem,\n+}\n+\n+fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n+}\n+\n+fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n+    namespace == ValueNS && path.len() == 1 && path[0].ident.name == kw::SelfLower\n+}\n+\n+/// Gets the stringified path for an enum from an `ImportSuggestion` for an enum variant.\n+fn import_candidate_to_enum_paths(suggestion: &ImportSuggestion) -> (String, String) {\n+    let variant_path = &suggestion.path;\n+    let variant_path_string = path_names_to_string(variant_path);\n+\n+    let path_len = suggestion.path.segments.len();\n+    let enum_path = ast::Path {\n+        span: suggestion.path.span,\n+        segments: suggestion.path.segments[0..path_len - 1].to_vec(),\n+    };\n+    let enum_path_string = path_names_to_string(&enum_path);\n+\n+    (variant_path_string, enum_path_string)\n+}\n+\n+impl<'a> LateResolutionVisitor<'a, '_> {\n+    /// Handles error reporting for `smart_resolve_path_fragment` function.\n+    /// Creates base error and amends it with one short label and possibly some longer helps/notes.\n+    pub(crate) fn smart_resolve_report_errors(\n+        &mut self,\n+        path: &[Segment],\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Option<Res>,\n+    ) -> (DiagnosticBuilder<'a>, Vec<ImportSuggestion>) {\n+        let ident_span = path.last().map_or(span, |ident| ident.ident.span);\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+        let is_enum_variant = &|res| {\n+            if let Res::Def(DefKind::Variant, _) = res { true } else { false }\n+        };\n+\n+        // Make the base error.\n+        let expected = source.descr_expected();\n+        let path_str = Segment::names_to_string(path);\n+        let item_str = path.last().unwrap().ident;\n+        let code = source.error_code(res.is_some());\n+        let (base_msg, fallback_label, base_span) = if let Some(res) = res {\n+            (format!(\"expected {}, found {} `{}`\", expected, res.descr(), path_str),\n+                format!(\"not a {}\", expected),\n+                span)\n+        } else {\n+            let item_span = path.last().unwrap().ident.span;\n+            let (mod_prefix, mod_str) = if path.len() == 1 {\n+                (String::new(), \"this scope\".to_string())\n+            } else if path.len() == 2 && path[0].ident.name == kw::PathRoot {\n+                (String::new(), \"the crate root\".to_string())\n+            } else {\n+                let mod_path = &path[..path.len() - 1];\n+                let mod_prefix = match self.resolve_path(\n+                    mod_path, Some(TypeNS), false, span, CrateLint::No\n+                ) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                        module.def_kind(),\n+                    _ => None,\n+                }.map_or(String::new(), |kind| format!(\"{} \", kind.descr()));\n+                (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n+            };\n+            (format!(\"cannot find {} `{}` in {}{}\", expected, item_str, mod_prefix, mod_str),\n+                format!(\"not found in {}\", mod_str),\n+                item_span)\n+        };\n+\n+        let code = DiagnosticId::Error(code.into());\n+        let mut err = self.session.struct_span_err_with_code(base_span, &base_msg, code);\n+\n+        // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n+        if [\"this\", \"my\"].contains(&&*item_str.as_str())\n+            && self.self_value_is_available(path[0].ident.span, span) {\n+            err.span_suggestion(\n+                span,\n+                \"did you mean\",\n+                \"self\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+\n+        // Emit special messages for unresolved `Self` and `self`.\n+        if is_self_type(path, ns) {\n+            __diagnostic_used!(E0411);\n+            err.code(DiagnosticId::Error(\"E0411\".into()));\n+            err.span_label(span, format!(\"`Self` is only available in impls, traits, \\\n+                                          and type definitions\"));\n+            return (err, Vec::new());\n+        }\n+        if is_self_value(path, ns) {\n+            debug!(\"smart_resolve_path_fragment: E0424, source={:?}\", source);\n+\n+            __diagnostic_used!(E0424);\n+            err.code(DiagnosticId::Error(\"E0424\".into()));\n+            err.span_label(span, match source {\n+                PathSource::Pat => {\n+                    format!(\"`self` value is a keyword \\\n+                             and may not be bound to \\\n+                             variables or shadowed\")\n+                }\n+                _ => {\n+                    format!(\"`self` value is a keyword \\\n+                             only available in methods \\\n+                             with `self` parameter\")\n+                }\n+            });\n+            return (err, Vec::new());\n+        }\n+\n+        // Try to lookup name in more relaxed fashion for better error reporting.\n+        let ident = path.last().unwrap().ident;\n+        let candidates = self.lookup_import_candidates(ident, ns, is_expected)\n+            .drain(..)\n+            .filter(|ImportSuggestion { did, .. }| {\n+                match (did, res.and_then(|res| res.opt_def_id())) {\n+                    (Some(suggestion_did), Some(actual_did)) => *suggestion_did != actual_did,\n+                    _ => true,\n+                }\n+            })\n+            .collect::<Vec<_>>();\n+        let crate_def_id = DefId::local(CRATE_DEF_INDEX);\n+        if candidates.is_empty() && is_expected(Res::Def(DefKind::Enum, crate_def_id)) {\n+            let enum_candidates =\n+                self.lookup_import_candidates(ident, ns, is_enum_variant);\n+            let mut enum_candidates = enum_candidates.iter()\n+                .map(|suggestion| {\n+                    import_candidate_to_enum_paths(&suggestion)\n+                }).collect::<Vec<_>>();\n+            enum_candidates.sort();\n+\n+            if !enum_candidates.is_empty() {\n+                // Contextualize for E0412 \"cannot find type\", but don't belabor the point\n+                // (that it's a variant) for E0573 \"expected type, found variant\".\n+                let preamble = if res.is_none() {\n+                    let others = match enum_candidates.len() {\n+                        1 => String::new(),\n+                        2 => \" and 1 other\".to_owned(),\n+                        n => format!(\" and {} others\", n)\n+                    };\n+                    format!(\"there is an enum variant `{}`{}; \",\n+                            enum_candidates[0].0, others)\n+                } else {\n+                    String::new()\n+                };\n+                let msg = format!(\"{}try using the variant's enum\", preamble);\n+\n+                err.span_suggestions(\n+                    span,\n+                    &msg,\n+                    enum_candidates.into_iter()\n+                        .map(|(_variant_path, enum_ty_path)| enum_ty_path)\n+                        // Variants re-exported in prelude doesn't mean `prelude::v1` is the\n+                        // type name!\n+                        // FIXME: is there a more principled way to do this that\n+                        // would work for other re-exports?\n+                        .filter(|enum_ty_path| enum_ty_path != \"std::prelude::v1\")\n+                        // Also write `Option` rather than `std::prelude::v1::Option`.\n+                        .map(|enum_ty_path| {\n+                            // FIXME #56861: DRY-er prelude filtering.\n+                            enum_ty_path.trim_start_matches(\"std::prelude::v1::\").to_owned()\n+                        }),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        if path.len() == 1 && self.self_type_is_available(span) {\n+            if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n+                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                match candidate {\n+                    AssocSuggestion::Field => {\n+                        if self_is_available {\n+                            err.span_suggestion(\n+                                span,\n+                                \"you might have meant to use the available field\",\n+                                format!(\"self.{}\", path_str),\n+                                Applicability::MachineApplicable,\n+                            );\n+                        } else {\n+                            err.span_label(\n+                                span,\n+                                \"a field by this name exists in `Self`\",\n+                            );\n+                        }\n+                    }\n+                    AssocSuggestion::MethodWithSelf if self_is_available => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"self.{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                    AssocSuggestion::MethodWithSelf | AssocSuggestion::AssocItem => {\n+                        err.span_suggestion(\n+                            span,\n+                            \"try\",\n+                            format!(\"Self::{}\", path_str),\n+                            Applicability::MachineApplicable,\n+                        );\n+                    }\n+                }\n+                return (err, candidates);\n+            }\n+        }\n+\n+        // Try Levenshtein algorithm.\n+        let levenshtein_worked = add_typo_suggestion(\n+            &mut err, self.lookup_typo_candidate(path, ns, is_expected, span), ident_span\n+        );\n+\n+        // Try context-dependent help if relaxed lookup didn't work.\n+        if let Some(res) = res {\n+            if self.smart_resolve_context_dependent_help(&mut err,\n+                                                         span,\n+                                                         source,\n+                                                         res,\n+                                                         &path_str,\n+                                                         &fallback_label) {\n+                return (err, candidates);\n+            }\n+        }\n+\n+        // Fallback label.\n+        if !levenshtein_worked {\n+            err.span_label(base_span, fallback_label);\n+            self.type_ascription_suggestion(&mut err, base_span);\n+        }\n+        (err, candidates)\n+    }\n+\n+    fn followed_by_brace(&self, span: Span) -> (bool, Option<(Span, String)>) {\n+        // HACK(estebank): find a better way to figure out that this was a\n+        // parser issue where a struct literal is being used on an expression\n+        // where a brace being opened means a block is being started. Look\n+        // ahead for the next text to see if `span` is followed by a `{`.\n+        let sm = self.session.source_map();\n+        let mut sp = span;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet.chars().any(|c| { !c.is_whitespace() }) {\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+        }\n+        let followed_by_brace = match sm.span_to_snippet(sp) {\n+            Ok(ref snippet) if snippet == \"{\" => true,\n+            _ => false,\n+        };\n+        // In case this could be a struct literal that needs to be surrounded\n+        // by parenthesis, find the appropriate span.\n+        let mut i = 0;\n+        let mut closing_brace = None;\n+        loop {\n+            sp = sm.next_point(sp);\n+            match sm.span_to_snippet(sp) {\n+                Ok(ref snippet) => {\n+                    if snippet == \"}\" {\n+                        let sp = span.to(sp);\n+                        if let Ok(snippet) = sm.span_to_snippet(sp) {\n+                            closing_brace = Some((sp, snippet));\n+                        }\n+                        break;\n+                    }\n+                }\n+                _ => break,\n+            }\n+            i += 1;\n+            // The bigger the span, the more likely we're incorrect --\n+            // bound it to 100 chars long.\n+            if i > 100 {\n+                break;\n+            }\n+        }\n+        return (followed_by_brace, closing_brace)\n+    }\n+\n+    /// Provides context-dependent help for errors reported by the `smart_resolve_path_fragment`\n+    /// function.\n+    /// Returns `true` if able to provide context-dependent help.\n+    fn smart_resolve_context_dependent_help(\n+        &mut self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        span: Span,\n+        source: PathSource<'_>,\n+        res: Res,\n+        path_str: &str,\n+        fallback_label: &str,\n+    ) -> bool {\n+        let ns = source.namespace();\n+        let is_expected = &|res| source.is_expected(res);\n+\n+        let path_sep = |err: &mut DiagnosticBuilder<'_>, expr: &Expr| match expr.node {\n+            ExprKind::Field(_, ident) => {\n+                err.span_suggestion(\n+                    expr.span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            ExprKind::MethodCall(ref segment, ..) => {\n+                let span = expr.span.with_hi(segment.ident.span.hi());\n+                err.span_suggestion(\n+                    span,\n+                    \"use the path separator to refer to an item\",\n+                    format!(\"{}::{}\", path_str, segment.ident),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                true\n+            }\n+            _ => false,\n+        };\n+\n+        let mut bad_struct_syntax_suggestion = || {\n+            let (followed_by_brace, closing_brace) = self.followed_by_brace(span);\n+            let mut suggested = false;\n+            match source {\n+                PathSource::Expr(Some(parent)) => {\n+                    suggested = path_sep(err, &parent);\n+                }\n+                PathSource::Expr(None) if followed_by_brace == true => {\n+                    if let Some((sp, snippet)) = closing_brace {\n+                        err.span_suggestion(\n+                            sp,\n+                            \"surround the struct literal with parenthesis\",\n+                            format!(\"({})\", snippet),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    } else {\n+                        err.span_label(\n+                            span,  // Note the parenthesis surrounding the suggestion below\n+                            format!(\"did you mean `({} {{ /* fields */ }})`?\", path_str),\n+                        );\n+                    }\n+                    suggested = true;\n+                },\n+                _ => {}\n+            }\n+            if !suggested {\n+                err.span_label(\n+                    span,\n+                    format!(\"did you mean `{} {{ /* fields */ }}`?\", path_str),\n+                );\n+            }\n+        };\n+\n+        match (res, source) {\n+            (Res::Def(DefKind::Macro(MacroKind::Bang), _), _) => {\n+                err.span_suggestion(\n+                    span,\n+                    \"use `!` to invoke the macro\",\n+                    format!(\"{}!\", path_str),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                if path_str == \"try\" && span.rust_2015() {\n+                    err.note(\"if you want the `try` keyword, you need to be in the 2018 edition\");\n+                }\n+            }\n+            (Res::Def(DefKind::TyAlias, _), PathSource::Trait(_)) => {\n+                err.span_label(span, \"type aliases cannot be used as traits\");\n+                if nightly_options::is_nightly_build() {\n+                    err.note(\"did you mean to use a trait alias?\");\n+                }\n+            }\n+            (Res::Def(DefKind::Mod, _), PathSource::Expr(Some(parent))) => {\n+                if !path_sep(err, &parent) {\n+                    return false;\n+                }\n+            }\n+            (Res::Def(DefKind::Enum, def_id), PathSource::TupleStruct)\n+                | (Res::Def(DefKind::Enum, def_id), PathSource::Expr(..))  => {\n+                if let Some(variants) = self.collect_enum_variants(def_id) {\n+                    if !variants.is_empty() {\n+                        let msg = if variants.len() == 1 {\n+                            \"try using the enum's variant\"\n+                        } else {\n+                            \"try using one of the enum's variants\"\n+                        };\n+\n+                        err.span_suggestions(\n+                            span,\n+                            msg,\n+                            variants.iter().map(path_names_to_string),\n+                            Applicability::MaybeIncorrect,\n+                        );\n+                    }\n+                } else {\n+                    err.note(\"did you mean to use one of the enum's variants?\");\n+                }\n+            },\n+            (Res::Def(DefKind::Struct, def_id), _) if ns == ValueNS => {\n+                if let Some((ctor_def, ctor_vis))\n+                        = self.struct_constructors.get(&def_id).cloned() {\n+                    let accessible_ctor = self.is_accessible_from(ctor_vis, self.current_module);\n+                    if is_expected(ctor_def) && !accessible_ctor {\n+                        err.span_label(\n+                            span,\n+                            format!(\"constructor is not visible here due to private fields\"),\n+                        );\n+                    }\n+                } else {\n+                    bad_struct_syntax_suggestion();\n+                }\n+            }\n+            (Res::Def(DefKind::Union, _), _) |\n+            (Res::Def(DefKind::Variant, _), _) |\n+            (Res::Def(DefKind::Ctor(_, CtorKind::Fictive), _), _) if ns == ValueNS => {\n+                bad_struct_syntax_suggestion();\n+            }\n+            (Res::SelfTy(..), _) if ns == ValueNS => {\n+                err.span_label(span, fallback_label);\n+                err.note(\"can't use `Self` as a constructor, you must use the implemented struct\");\n+            }\n+            (Res::Def(DefKind::TyAlias, _), _)\n+            | (Res::Def(DefKind::AssocTy, _), _) if ns == ValueNS => {\n+                err.note(\"can't use a type alias as a constructor\");\n+            }\n+            _ => return false,\n+        }\n+        true\n+    }\n+\n+    fn lookup_assoc_candidate<FilterFn>(&mut self,\n+                                        ident: Ident,\n+                                        ns: Namespace,\n+                                        filter_fn: FilterFn)\n+                                        -> Option<AssocSuggestion>\n+        where FilterFn: Fn(Res) -> bool\n+    {\n+        fn extract_node_id(t: &Ty) -> Option<NodeId> {\n+            match t.node {\n+                TyKind::Path(None, _) => Some(t.id),\n+                TyKind::Rptr(_, ref mut_ty) => extract_node_id(&mut_ty.ty),\n+                // This doesn't handle the remaining `Ty` variants as they are not\n+                // that commonly the self_type, it might be interesting to provide\n+                // support for those in future.\n+                _ => None,\n+            }\n+        }\n+\n+        // Fields are generally expected in the same contexts as locals.\n+        if filter_fn(Res::Local(ast::DUMMY_NODE_ID)) {\n+            if let Some(node_id) = self.current_self_type.as_ref().and_then(extract_node_id) {\n+                // Look for a field with the same name in the current self_type.\n+                if let Some(resolution) = self.partial_res_map.get(&node_id) {\n+                    match resolution.base_res() {\n+                        Res::Def(DefKind::Struct, did) | Res::Def(DefKind::Union, did)\n+                                if resolution.unresolved_segments() == 0 => {\n+                            if let Some(field_names) = self.field_names.get(&did) {\n+                                if field_names.iter().any(|&field_name| ident.name == field_name) {\n+                                    return Some(AssocSuggestion::Field);\n+                                }\n+                            }\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n+        }\n+\n+        for assoc_type_ident in &self.current_trait_assoc_types {\n+            if *assoc_type_ident == ident {\n+                return Some(AssocSuggestion::AssocItem);\n+            }\n+        }\n+\n+        // Look for associated items in the current trait.\n+        if let Some((module, _)) = self.current_trait_ref {\n+            let parent_scope = &self.parent_scope();\n+            if let Ok(binding) = self.resolve_ident_in_module(\n+                    ModuleOrUniformRoot::Module(module),\n+                    ident,\n+                    ns,\n+                    parent_scope,\n+                    false,\n+                    module.span,\n+                ) {\n+                let res = binding.res();\n+                if filter_fn(res) {\n+                    return Some(if self.has_self.contains(&res.def_id()) {\n+                        AssocSuggestion::MethodWithSelf\n+                    } else {\n+                        AssocSuggestion::AssocItem\n+                    });\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    fn lookup_typo_candidate(\n+        &mut self,\n+        path: &[Segment],\n+        ns: Namespace,\n+        filter_fn: &impl Fn(Res) -> bool,\n+        span: Span,\n+    ) -> Option<TypoSuggestion> {\n+        let mut names = Vec::new();\n+        if path.len() == 1 {\n+            // Search in lexical scope.\n+            // Walk backwards up the ribs in scope and collect candidates.\n+            for rib in self.ribs[ns].iter().rev() {\n+                // Locals and type parameters\n+                for (ident, &res) in &rib.bindings {\n+                    if filter_fn(res) {\n+                        names.push(TypoSuggestion::from_res(ident.name, res));\n+                    }\n+                }\n+                // Items in scope\n+                if let RibKind::ModuleRibKind(module) = rib.kind {\n+                    // Items from this module\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+\n+                    if let ModuleKind::Block(..) = module.kind {\n+                        // We can see through blocks\n+                    } else {\n+                        // Items from the prelude\n+                        if !module.no_implicit_prelude {\n+                            names.extend(self.extern_prelude.clone().iter().flat_map(|(ident, _)| {\n+                                self.crate_loader\n+                                    .maybe_process_path_extern(ident.name, ident.span)\n+                                    .and_then(|crate_id| {\n+                                        let crate_mod = Res::Def(\n+                                            DefKind::Mod,\n+                                            DefId {\n+                                                krate: crate_id,\n+                                                index: CRATE_DEF_INDEX,\n+                                            },\n+                                        );\n+\n+                                        if filter_fn(crate_mod) {\n+                                            Some(TypoSuggestion::from_res(ident.name, crate_mod))\n+                                        } else {\n+                                            None\n+                                        }\n+                                    })\n+                            }));\n+\n+                            if let Some(prelude) = self.prelude {\n+                                add_module_candidates(prelude, &mut names, &filter_fn);\n+                            }\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+            // Add primitive types to the mix\n+            if filter_fn(Res::PrimTy(PrimTy::Bool)) {\n+                names.extend(\n+                    self.primitive_type_table.primitive_types.iter().map(|(name, prim_ty)| {\n+                        TypoSuggestion::from_res(*name, Res::PrimTy(*prim_ty))\n+                    })\n+                )\n+            }\n+        } else {\n+            // Search in module.\n+            let mod_path = &path[..path.len() - 1];\n+            if let PathResult::Module(module) = self.resolve_path(\n+                mod_path, Some(TypeNS), false, span, CrateLint::No\n+            ) {\n+                if let ModuleOrUniformRoot::Module(module) = module {\n+                    add_module_candidates(module, &mut names, &filter_fn);\n+                }\n+            }\n+        }\n+\n+        let name = path[path.len() - 1].ident.name;\n+        // Make sure error reporting is deterministic.\n+        names.sort_by_cached_key(|suggestion| suggestion.candidate.as_str());\n+\n+        match find_best_match_for_name(\n+            names.iter().map(|suggestion| &suggestion.candidate),\n+            &name.as_str(),\n+            None,\n+        ) {\n+            Some(found) if found != name => names\n+                .into_iter()\n+                .find(|suggestion| suggestion.candidate == found),\n+            _ => None,\n+        }\n+    }\n+\n+    /// Only used in a specific case of type ascription suggestions\n+    fn get_colon_suggestion_span(&self, start: Span) -> Span {\n+        let cm = self.session.source_map();\n+        start.to(cm.next_point(start))\n+    }\n+\n+    fn type_ascription_suggestion(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        base_span: Span,\n+    ) {\n+        debug!(\"type_ascription_suggetion {:?}\", base_span);\n+        let cm = self.session.source_map();\n+        let base_snippet = cm.span_to_snippet(base_span);\n+        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n+        if let Some(sp) = self.current_type_ascription.last() {\n+            let mut sp = *sp;\n+            loop {\n+                // Try to find the `:`; bail on first non-':' / non-whitespace.\n+                sp = cm.next_point(sp);\n+                if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n+                    let line_sp = cm.lookup_char_pos(sp.hi()).line;\n+                    let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n+                    if snippet == \":\" {\n+                        let mut show_label = true;\n+                        if line_sp != line_base_sp {\n+                            err.span_suggestion_short(\n+                                sp,\n+                                \"did you mean to use `;` here instead?\",\n+                                \";\".to_string(),\n+                                Applicability::MaybeIncorrect,\n+                            );\n+                        } else {\n+                            let colon_sp = self.get_colon_suggestion_span(sp);\n+                            let after_colon_sp = self.get_colon_suggestion_span(\n+                                colon_sp.shrink_to_hi(),\n+                            );\n+                            if !cm.span_to_snippet(after_colon_sp).map(|s| s == \" \")\n+                                .unwrap_or(false)\n+                            {\n+                                err.span_suggestion(\n+                                    colon_sp,\n+                                    \"maybe you meant to write a path separator here\",\n+                                    \"::\".to_string(),\n+                                    Applicability::MaybeIncorrect,\n+                                );\n+                                show_label = false;\n+                            }\n+                            if let Ok(base_snippet) = base_snippet {\n+                                let mut sp = after_colon_sp;\n+                                for _ in 0..100 {\n+                                    // Try to find an assignment\n+                                    sp = cm.next_point(sp);\n+                                    let snippet = cm.span_to_snippet(sp.to(cm.next_point(sp)));\n+                                    match snippet {\n+                                        Ok(ref x) if x.as_str() == \"=\" => {\n+                                            err.span_suggestion(\n+                                                base_span,\n+                                                \"maybe you meant to write an assignment here\",\n+                                                format!(\"let {}\", base_snippet),\n+                                                Applicability::MaybeIncorrect,\n+                                            );\n+                                            show_label = false;\n+                                            break;\n+                                        }\n+                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n+                                        Err(_) => break,\n+                                        Ok(_) => {}\n+                                    }\n+                                }\n+                            }\n+                        }\n+                        if show_label {\n+                            err.span_label(base_span,\n+                                           \"expecting a type here because of type ascription\");\n+                        }\n+                        break;\n+                    } else if !snippet.trim().is_empty() {\n+                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n+                        break;\n+                    }\n+                } else {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+\n+    fn find_module(&mut self, def_id: DefId) -> Option<(Module<'a>, ImportSuggestion)> {\n+        let mut result = None;\n+        let mut seen_modules = FxHashSet::default();\n+        let mut worklist = vec![(self.graph_root, Vec::new())];\n+\n+        while let Some((in_module, path_segments)) = worklist.pop() {\n+            // abort if the module is already found\n+            if result.is_some() { break; }\n+\n+            self.populate_module_if_necessary(in_module);\n+\n+            in_module.for_each_child_stable(|ident, _, name_binding| {\n+                // abort if the module is already found or if name_binding is private external\n+                if result.is_some() || !name_binding.vis.is_visible_locally() {\n+                    return\n+                }\n+                if let Some(module) = name_binding.module() {\n+                    // form the path\n+                    let mut path_segments = path_segments.clone();\n+                    path_segments.push(ast::PathSegment::from_ident(ident));\n+                    let module_def_id = module.def_id().unwrap();\n+                    if module_def_id == def_id {\n+                        let path = Path {\n+                            span: name_binding.span,\n+                            segments: path_segments,\n+                        };\n+                        result = Some((module, ImportSuggestion { did: Some(def_id), path }));\n+                    } else {\n+                        // add the module to the lookup\n+                        if seen_modules.insert(module_def_id) {\n+                            worklist.push((module, path_segments));\n+                        }\n+                    }\n+                }\n+            });\n+        }\n+\n+        result\n+    }\n+\n+    fn collect_enum_variants(&mut self, def_id: DefId) -> Option<Vec<Path>> {\n+        self.find_module(def_id).map(|(enum_module, enum_import_suggestion)| {\n+            self.populate_module_if_necessary(enum_module);\n+\n+            let mut variants = Vec::new();\n+            enum_module.for_each_child_stable(|ident, _, name_binding| {\n+                if let Res::Def(DefKind::Variant, _) = name_binding.res() {\n+                    let mut segms = enum_import_suggestion.path.segments.clone();\n+                    segms.push(ast::PathSegment::from_ident(ident));\n+                    variants.push(Path {\n+                        span: name_binding.span,\n+                        segments: segms,\n+                    });\n+                }\n+            });\n+            variants\n+        })\n+    }\n+}"}, {"sha": "8c099e4532cd8d7dcc90faf2d0012497e0f8df32", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 114, "deletions": 2000, "changes": 2114, "blob_url": "https://github.com/rust-lang/rust/blob/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ff85d1c2d28e19797b9d9aa67bbdfaf92e015c57", "patch": "@@ -13,9 +13,7 @@\n pub use rustc::hir::def::{Namespace, PerNS};\n \n use Determinacy::*;\n-use GenericParameters::*;\n use RibKind::*;\n-use smallvec::smallvec;\n \n use rustc::hir::map::Definitions;\n use rustc::hir::{self, PrimTy, Bool, Char, Float, Int, Uint, Str};\n@@ -27,7 +25,7 @@ use rustc::hir::def::{\n };\n use rustc::hir::def::Namespace::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, DefId};\n-use rustc::hir::{TraitCandidate, TraitMap, GlobMap};\n+use rustc::hir::{TraitMap, GlobMap};\n use rustc::ty;\n use rustc::util::nodemap::{NodeMap, NodeSet, FxHashMap, FxHashSet, DefIdMap};\n use rustc::{bug, span_bug};\n@@ -40,31 +38,23 @@ use syntax::ext::hygiene::{ExpnId, Transparency, SyntaxContext};\n use syntax::ast::{self, Name, NodeId, Ident, FloatTy, IntTy, UintTy};\n use syntax::ext::base::{SyntaxExtension, MacroKind, SpecialDerives};\n use syntax::symbol::{Symbol, kw, sym};\n-use syntax::util::lev_distance::find_best_match_for_name;\n \n-use syntax::visit::{self, FnKind, Visitor};\n+use syntax::visit::{self, Visitor};\n use syntax::attr;\n-use syntax::ast::{CRATE_NODE_ID, Arm, IsAsync, BindingMode, Block, Crate, Expr, ExprKind};\n-use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, GenericParamKind, Generics};\n-use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n-use syntax::ast::{Label, Local, Mutability, Pat, PatKind, Path};\n-use syntax::ast::{QSelf, TraitItem, TraitItemKind, TraitRef, Ty, TyKind};\n-use syntax::ptr::P;\n-use syntax::{struct_span_err, unwrap_or, walk_list};\n+use syntax::ast::{CRATE_NODE_ID, Crate, Expr, ExprKind};\n+use syntax::ast::{ItemKind, Path};\n+use syntax::{span_err, struct_span_err, unwrap_or};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use log::debug;\n \n use std::cell::{Cell, RefCell};\n-use std::{cmp, fmt, iter, mem, ptr};\n-use std::ops::{Deref, DerefMut};\n+use std::{cmp, fmt, iter, ptr};\n use std::collections::BTreeSet;\n-use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n-use smallvec::SmallVec;\n \n use diagnostics::{Suggestion, ImportSuggestion};\n use diagnostics::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n@@ -77,6 +67,7 @@ type Res = def::Res<NodeId>;\n // registered before they are used.\n mod error_codes;\n mod diagnostics;\n+mod late;\n mod macros;\n mod check_unused;\n mod build_reduced_graph;\n@@ -488,34 +479,6 @@ fn reduce_impl_span_to_impl_keyword(cm: &SourceMap, impl_span: Span) -> Span {\n     impl_span\n }\n \n-#[derive(Copy, Clone, Debug)]\n-struct BindingInfo {\n-    span: Span,\n-    binding_mode: BindingMode,\n-}\n-\n-/// Map from the name in a pattern to its binding mode.\n-type BindingMap = FxHashMap<Ident, BindingInfo>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum PatternSource {\n-    Match,\n-    Let,\n-    For,\n-    FnParam,\n-}\n-\n-impl PatternSource {\n-    fn descr(self) -> &'static str {\n-        match self {\n-            PatternSource::Match => \"match binding\",\n-            PatternSource::Let => \"let binding\",\n-            PatternSource::For => \"for binding\",\n-            PatternSource::FnParam => \"function parameter\",\n-        }\n-    }\n-}\n-\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum AliasPossibility {\n     No,\n@@ -780,262 +743,6 @@ impl<'tcx> Visitor<'tcx> for UsePlacementFinder {\n     }\n }\n \n-struct LateResolutionVisitor<'a, 'b> {\n-    resolver: &'b mut Resolver<'a>,\n-\n-    /// The module that represents the current item scope.\n-    current_module: Module<'a>,\n-\n-    /// The current set of local scopes for types and values.\n-    /// FIXME #4948: Reuse ribs to avoid allocation.\n-    ribs: PerNS<Vec<Rib<'a>>>,\n-\n-    /// The current set of local scopes, for labels.\n-    label_ribs: Vec<Rib<'a, NodeId>>,\n-\n-    /// The trait that the current context can refer to.\n-    current_trait_ref: Option<(Module<'a>, TraitRef)>,\n-\n-    /// The current trait's associated types' ident, used for diagnostic suggestions.\n-    current_trait_assoc_types: Vec<Ident>,\n-\n-    /// The current self type if inside an impl (used for better errors).\n-    current_self_type: Option<Ty>,\n-\n-    /// The current self item if inside an ADT (used for better errors).\n-    current_self_item: Option<NodeId>,\n-\n-    /// A list of labels as of yet unused. Labels will be removed from this map when\n-    /// they are used (in a `break` or `continue` statement)\n-    unused_labels: FxHashMap<NodeId, Span>,\n-\n-    /// Only used for better errors on `fn(): fn()`.\n-    current_type_ascription: Vec<Span>,\n-}\n-\n-impl<'a, 'b> LateResolutionVisitor<'a, '_> {\n-    fn new(resolver: &'b mut Resolver<'a>) -> LateResolutionVisitor<'a, 'b> {\n-        let graph_root = resolver.graph_root;\n-        LateResolutionVisitor {\n-            resolver,\n-            current_module: graph_root,\n-            ribs: PerNS {\n-                value_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                type_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-                macro_ns: vec![Rib::new(ModuleRibKind(graph_root))],\n-            },\n-            label_ribs: Vec::new(),\n-            current_trait_ref: None,\n-            current_trait_assoc_types: Vec::new(),\n-            current_self_type: None,\n-            current_self_item: None,\n-            unused_labels: Default::default(),\n-            current_type_ascription: Vec::new(),\n-        }\n-    }\n-\n-    fn parent_scope(&self) -> ParentScope<'a> {\n-        ParentScope { module: self.current_module, ..self.dummy_parent_scope() }\n-    }\n-}\n-\n-impl<'a> Deref for LateResolutionVisitor<'a, '_> {\n-    type Target = Resolver<'a>;\n-    fn deref(&self) -> &Self::Target {\n-        self.resolver\n-    }\n-}\n-\n-impl<'a> DerefMut for LateResolutionVisitor<'a, '_> {\n-    fn deref_mut(&mut self) -> &mut Self::Target {\n-        self.resolver\n-    }\n-}\n-\n-/// Walks the whole crate in DFS order, visiting each item, resolving names as it goes.\n-impl<'a, 'tcx> Visitor<'tcx> for LateResolutionVisitor<'a, '_> {\n-    fn visit_item(&mut self, item: &'tcx Item) {\n-        self.resolve_item(item);\n-    }\n-    fn visit_arm(&mut self, arm: &'tcx Arm) {\n-        self.resolve_arm(arm);\n-    }\n-    fn visit_block(&mut self, block: &'tcx Block) {\n-        self.resolve_block(block);\n-    }\n-    fn visit_anon_const(&mut self, constant: &'tcx ast::AnonConst) {\n-        debug!(\"visit_anon_const {:?}\", constant);\n-        self.with_constant_rib(|this| {\n-            visit::walk_anon_const(this, constant);\n-        });\n-    }\n-    fn visit_expr(&mut self, expr: &'tcx Expr) {\n-        self.resolve_expr(expr, None);\n-    }\n-    fn visit_local(&mut self, local: &'tcx Local) {\n-        self.resolve_local(local);\n-    }\n-    fn visit_ty(&mut self, ty: &'tcx Ty) {\n-        match ty.node {\n-            TyKind::Path(ref qself, ref path) => {\n-                self.smart_resolve_path(ty.id, qself.as_ref(), path, PathSource::Type);\n-            }\n-            TyKind::ImplicitSelf => {\n-                let self_ty = Ident::with_empty_ctxt(kw::SelfUpper);\n-                let res = self.resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n-                              .map_or(Res::Err, |d| d.res());\n-                self.record_partial_res(ty.id, PartialRes::new(res));\n-            }\n-            _ => (),\n-        }\n-        visit::walk_ty(self, ty);\n-    }\n-    fn visit_poly_trait_ref(&mut self,\n-                            tref: &'tcx ast::PolyTraitRef,\n-                            m: &'tcx ast::TraitBoundModifier) {\n-        self.smart_resolve_path(tref.trait_ref.ref_id, None,\n-                                &tref.trait_ref.path, PathSource::Trait(AliasPossibility::Maybe));\n-        visit::walk_poly_trait_ref(self, tref, m);\n-    }\n-    fn visit_foreign_item(&mut self, foreign_item: &'tcx ForeignItem) {\n-        let generic_params = match foreign_item.node {\n-            ForeignItemKind::Fn(_, ref generics) => {\n-                HasGenericParams(generics, ItemRibKind)\n-            }\n-            ForeignItemKind::Static(..) => NoGenericParams,\n-            ForeignItemKind::Ty => NoGenericParams,\n-            ForeignItemKind::Macro(..) => NoGenericParams,\n-        };\n-        self.with_generic_param_rib(generic_params, |this| {\n-            visit::walk_foreign_item(this, foreign_item);\n-        });\n-    }\n-    fn visit_fn(&mut self,\n-                function_kind: FnKind<'tcx>,\n-                declaration: &'tcx FnDecl,\n-                _: Span,\n-                _: NodeId)\n-    {\n-        debug!(\"(resolving function) entering function\");\n-        let rib_kind = match function_kind {\n-            FnKind::ItemFn(..) => FnItemRibKind,\n-            FnKind::Method(..) | FnKind::Closure(_) => NormalRibKind,\n-        };\n-\n-        // Create a value rib for the function.\n-        self.ribs[ValueNS].push(Rib::new(rib_kind));\n-\n-        // Create a label rib for the function.\n-        self.label_ribs.push(Rib::new(rib_kind));\n-\n-        // Add each argument to the rib.\n-        let mut bindings_list = FxHashMap::default();\n-        for argument in &declaration.inputs {\n-            self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-\n-            self.visit_ty(&argument.ty);\n-\n-            debug!(\"(resolving function) recorded argument\");\n-        }\n-        visit::walk_fn_ret_ty(self, &declaration.output);\n-\n-        // Resolve the function body, potentially inside the body of an async closure\n-        match function_kind {\n-            FnKind::ItemFn(.., body) |\n-            FnKind::Method(.., body) => {\n-                self.visit_block(body);\n-            }\n-            FnKind::Closure(body) => {\n-                self.visit_expr(body);\n-            }\n-        };\n-\n-        debug!(\"(resolving function) leaving function\");\n-\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n-    }\n-\n-    fn visit_generics(&mut self, generics: &'tcx Generics) {\n-        // For type parameter defaults, we have to ban access\n-        // to following type parameters, as the InternalSubsts can only\n-        // provide previous type parameters as they're built. We\n-        // put all the parameters on the ban list and then remove\n-        // them one by one as they are processed and become available.\n-        let mut default_ban_rib = Rib::new(ForwardTyParamBanRibKind);\n-        let mut found_default = false;\n-        default_ban_rib.bindings.extend(generics.params.iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Const { .. } |\n-                GenericParamKind::Lifetime { .. } => None,\n-                GenericParamKind::Type { ref default, .. } => {\n-                    found_default |= default.is_some();\n-                    if found_default {\n-                        Some((Ident::with_empty_ctxt(param.ident.name), Res::Err))\n-                    } else {\n-                        None\n-                    }\n-                }\n-            }));\n-\n-        // We also ban access to type parameters for use as the types of const parameters.\n-        let mut const_ty_param_ban_rib = Rib::new(TyParamAsConstParamTy);\n-        const_ty_param_ban_rib.bindings.extend(generics.params.iter()\n-            .filter(|param| {\n-                if let GenericParamKind::Type { .. } = param.kind {\n-                    true\n-                } else {\n-                    false\n-                }\n-            })\n-            .map(|param| (Ident::with_empty_ctxt(param.ident.name), Res::Err)));\n-\n-        for param in &generics.params {\n-            match param.kind {\n-                GenericParamKind::Lifetime { .. } => self.visit_generic_param(param),\n-                GenericParamKind::Type { ref default, .. } => {\n-                    for bound in &param.bounds {\n-                        self.visit_param_bound(bound);\n-                    }\n-\n-                    if let Some(ref ty) = default {\n-                        self.ribs[TypeNS].push(default_ban_rib);\n-                        self.visit_ty(ty);\n-                        default_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                    }\n-\n-                    // Allow all following defaults to refer to this type parameter.\n-                    default_ban_rib.bindings.remove(&Ident::with_empty_ctxt(param.ident.name));\n-                }\n-                GenericParamKind::Const { ref ty } => {\n-                    self.ribs[TypeNS].push(const_ty_param_ban_rib);\n-\n-                    for bound in &param.bounds {\n-                        self.visit_param_bound(bound);\n-                    }\n-\n-                    self.visit_ty(ty);\n-\n-                    const_ty_param_ban_rib = self.ribs[TypeNS].pop().unwrap();\n-                }\n-            }\n-        }\n-        for p in &generics.where_clause.predicates {\n-            self.visit_where_predicate(p);\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-enum GenericParameters<'a, 'b> {\n-    NoGenericParams,\n-    HasGenericParams(// Type parameters.\n-                      &'b Generics,\n-\n-                      // The kind of the rib used for type parameters.\n-                      RibKind<'a>),\n-}\n-\n /// The rib kind restricts certain accesses,\n /// e.g. to a `Res::Local` of an outer item.\n #[derive(Copy, Clone, Debug)]\n@@ -1853,76 +1560,6 @@ impl<'a> hir::lowering::Resolver for Resolver<'a> {\n     }\n }\n \n-impl<'a> Resolver<'a> {\n-    /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n-    /// isn't something that can be returned because it can't be made to live that long,\n-    /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n-    /// just that an error occurred.\n-    pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n-        -> Result<(ast::Path, Res), ()> {\n-        let path = if path_str.starts_with(\"::\") {\n-            ast::Path {\n-                span,\n-                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n-                    .chain({\n-                        path_str.split(\"::\").skip(1).map(Ident::from_str)\n-                    })\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-            }\n-        } else {\n-            ast::Path {\n-                span,\n-                segments: path_str\n-                    .split(\"::\")\n-                    .map(Ident::from_str)\n-                    .map(|i| self.new_ast_path_segment(i))\n-                    .collect(),\n-            }\n-        };\n-        let res = self.resolve_ast_path_inner(&path, is_value).map_err(|_| ())?;\n-        Ok((path, res))\n-    }\n-\n-    /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n-    fn resolve_ast_path_inner(\n-        &mut self,\n-        path: &ast::Path,\n-        is_value: bool,\n-    ) -> Result<Res, (Span, ResolutionError<'a>)> {\n-        let namespace = if is_value { ValueNS } else { TypeNS };\n-        let span = path.span;\n-        let path = Segment::from_path(&path);\n-        // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n-        let parent_scope = &self.dummy_parent_scope();\n-        match self.resolve_path(&path, Some(namespace), parent_scope, true, span, CrateLint::No) {\n-            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                Ok(module.res().unwrap()),\n-            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n-                Ok(path_res.base_res()),\n-            PathResult::NonModule(..) => {\n-                Err((span, ResolutionError::FailedToResolve {\n-                    label: String::from(\"type-relative paths are not supported in this context\"),\n-                    suggestion: None,\n-                }))\n-            }\n-            PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n-            PathResult::Failed { span, label, suggestion, .. } => {\n-                Err((span, ResolutionError::FailedToResolve {\n-                    label,\n-                    suggestion,\n-                }))\n-            }\n-        }\n-    }\n-\n-    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n-        let mut seg = ast::PathSegment::from_ident(ident);\n-        seg.id = self.session.next_node_id();\n-        seg\n-    }\n-}\n-\n impl<'a> Resolver<'a> {\n     pub fn new(session: &'a Session,\n                cstore: &'a CStore,\n@@ -2097,12 +1734,7 @@ impl<'a> Resolver<'a> {\n     pub fn resolve_crate(&mut self, krate: &Crate) {\n         ImportResolver { resolver: self }.finalize_imports();\n \n-        self.finalize_current_module_macro_resolutions(self.graph_root);\n-        let mut late_resolution_visitor = LateResolutionVisitor::new(self);\n-        visit::walk_crate(&mut late_resolution_visitor, krate);\n-        for (id, span) in late_resolution_visitor.unused_labels.iter() {\n-            self.session.buffer_lint(lint::builtin::UNUSED_LABELS, *id, *span, \"unused label\");\n-        }\n+        self.late_resolve_crate(krate);\n \n         check_unused::check_crate(self, krate);\n         self.report_errors(krate);\n@@ -2297,9 +1929,7 @@ impl<'a> Resolver<'a> {\n \n         None\n     }\n-}\n \n-impl<'a> Resolver<'a> {\n     /// This resolves the identifier `ident` in the namespace `ns` in the current lexical scope.\n     /// More specifically, we proceed up the hierarchy of scopes and return the binding for\n     /// `ident` in the first scope that defines it (or None if no scopes define it).\n@@ -2605,1341 +2235,65 @@ impl<'a> Resolver<'a> {\n         }\n         module\n     }\n-}\n-\n-impl<'a> LateResolutionVisitor<'a, '_> {\n-    // AST resolution\n-    //\n-    // We maintain a list of value ribs and type ribs.\n-    //\n-    // Simultaneously, we keep track of the current position in the module\n-    // graph in the `current_module` pointer. When we go to resolve a name in\n-    // the value or type namespaces, we first look through all the ribs and\n-    // then query the module graph. When we resolve a name in the module\n-    // namespace, we can skip all the ribs (since nested modules are not\n-    // allowed within blocks in Rust) and jump straight to the current module\n-    // graph node.\n-    //\n-    // Named implementations are handled separately. When we find a method\n-    // call, we consult the module node to find all of the implementations in\n-    // scope. This information is lazily cached in the module node. We then\n-    // generate a fake \"implementation scope\" containing all the\n-    // implementations thus found, for compatibility with old resolve pass.\n-\n-    fn resolve_ident_in_lexical_scope(&mut self,\n-                                      ident: Ident,\n-                                      ns: Namespace,\n-                                      record_used_id: Option<NodeId>,\n-                                      path_span: Span)\n-                                      -> Option<LexicalScopeBinding<'a>> {\n-        self.resolver.resolve_ident_in_lexical_scope(\n-            ident, ns, &self.parent_scope(), record_used_id, path_span, &self.ribs[ns]\n-        )\n-    }\n \n     fn resolve_path(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n         record_used: bool,\n         path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolver.resolve_path_with_ribs(\n-            path, opt_ns, &self.parent_scope(), record_used, path_span, crate_lint, &self.ribs\n+        self.resolve_path_with_ribs(\n+            path, opt_ns, parent_scope, record_used, path_span, crate_lint, &Default::default()\n         )\n     }\n \n-    pub fn with_scope<F, T>(&mut self, id: NodeId, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n-        let id = self.definitions.local_def_id(id);\n-        let module = self.module_map.get(&id).cloned(); // clones a reference\n-        if let Some(module) = module {\n-            // Move down in the graph.\n-            let orig_module = replace(&mut self.current_module, module);\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(module)));\n-\n-            self.resolver.finalize_current_module_macro_resolutions(self.current_module);\n-            let ret = f(self);\n-\n-            self.current_module = orig_module;\n-            self.ribs[ValueNS].pop();\n-            self.ribs[TypeNS].pop();\n-            ret\n-        } else {\n-            f(self)\n-        }\n-    }\n-\n-    /// Searches the current set of local scopes for labels. Returns the first non-`None` label that\n-    /// is returned by the given predicate function\n-    ///\n-    /// Stops after meeting a closure.\n-    fn search_label<P, R>(&self, mut ident: Ident, pred: P) -> Option<R>\n-        where P: Fn(&Rib<'_, NodeId>, Ident) -> Option<R>\n-    {\n-        for rib in self.label_ribs.iter().rev() {\n-            match rib.kind {\n-                NormalRibKind => {}\n-                // If an invocation of this macro created `ident`, give up on `ident`\n-                // and switch to `ident`'s source from the macro definition.\n-                MacroDefinition(def) => {\n-                    if def == self.macro_def(ident.span.ctxt()) {\n-                        ident.span.remove_mark();\n-                    }\n-                }\n-                _ => {\n-                    // Do not resolve labels across function boundary\n-                    return None;\n-                }\n-            }\n-            let r = pred(rib, ident);\n-            if r.is_some() {\n-                return r;\n-            }\n-        }\n-        None\n-    }\n-\n-    fn resolve_adt(&mut self, item: &Item, generics: &Generics) {\n-        debug!(\"resolve_adt\");\n-        self.with_current_self_item(item, |this| {\n-            this.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                let item_def_id = this.definitions.local_def_id(item.id);\n-                this.with_self_rib(Res::SelfTy(None, Some(item_def_id)), |this| {\n-                    visit::walk_item(this, item);\n-                });\n-            });\n-        });\n-    }\n-\n-    fn future_proof_import(&mut self, use_tree: &ast::UseTree) {\n-        let segments = &use_tree.prefix.segments;\n-        if !segments.is_empty() {\n-            let ident = segments[0].ident;\n-            if ident.is_path_segment_keyword() || ident.span.rust_2015() {\n-                return;\n-            }\n+    fn resolve_path_with_ribs(\n+        &mut self,\n+        path: &[Segment],\n+        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n+        parent_scope: &ParentScope<'a>,\n+        record_used: bool,\n+        path_span: Span,\n+        crate_lint: CrateLint,\n+        ribs: &PerNS<Vec<Rib<'a>>>,\n+    ) -> PathResult<'a> {\n+        let mut module = None;\n+        let mut allow_super = true;\n+        let mut second_binding = None;\n \n-            let nss = match use_tree.kind {\n-                ast::UseTreeKind::Simple(..) if segments.len() == 1 => &[TypeNS, ValueNS][..],\n-                _ => &[TypeNS],\n-            };\n-            let report_error = |this: &Self, ns| {\n-                let what = if ns == TypeNS { \"type parameters\" } else { \"local variables\" };\n-                this.session.span_err(ident.span, &format!(\"imports cannot refer to {}\", what));\n-            };\n+        debug!(\n+            \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n+             path_span={:?}, crate_lint={:?})\",\n+            path,\n+            opt_ns,\n+            record_used,\n+            path_span,\n+            crate_lint,\n+        );\n \n-            for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n-                    Some(LexicalScopeBinding::Res(..)) => {\n-                        report_error(self, ns);\n-                    }\n-                    Some(LexicalScopeBinding::Item(binding)) => {\n-                        let orig_blacklisted_binding =\n-                            mem::replace(&mut self.blacklisted_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) =\n-                                self.resolve_ident_in_lexical_scope(ident, ns, None,\n-                                                                    use_tree.prefix.span) {\n-                            report_error(self, ns);\n+        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n+            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n+            let record_segment_res = |this: &mut Self, res| {\n+                if record_used {\n+                    if let Some(id) = id {\n+                        if !this.partial_res_map.contains_key(&id) {\n+                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n+                            this.record_partial_res(id, PartialRes::new(res));\n                         }\n-                        self.blacklisted_binding = orig_blacklisted_binding;\n                     }\n-                    None => {}\n                 }\n-            }\n-        } else if let ast::UseTreeKind::Nested(use_trees) = &use_tree.kind {\n-            for (use_tree, _) in use_trees {\n-                self.future_proof_import(use_tree);\n-            }\n-        }\n-    }\n-\n-    fn resolve_item(&mut self, item: &Item) {\n-        let name = item.ident.name;\n-        debug!(\"(resolving item) resolving {} ({:?})\", name, item.node);\n-\n-        match item.node {\n-            ItemKind::TyAlias(_, ref generics) |\n-            ItemKind::OpaqueTy(_, ref generics) |\n-            ItemKind::Fn(_, _, ref generics, _) => {\n-                self.with_generic_param_rib(\n-                    HasGenericParams(generics, ItemRibKind),\n-                    |this| visit::walk_item(this, item)\n-                );\n-            }\n-\n-            ItemKind::Enum(_, ref generics) |\n-            ItemKind::Struct(_, ref generics) |\n-            ItemKind::Union(_, ref generics) => {\n-                self.resolve_adt(item, generics);\n-            }\n-\n-            ItemKind::Impl(.., ref generics, ref opt_trait_ref, ref self_type, ref impl_items) =>\n-                self.resolve_implementation(generics,\n-                                            opt_trait_ref,\n-                                            &self_type,\n-                                            item.id,\n-                                            impl_items),\n-\n-            ItemKind::Trait(.., ref generics, ref bounds, ref trait_items) => {\n-                // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                    let local_def_id = this.definitions.local_def_id(item.id);\n-                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-\n-                        for trait_item in trait_items {\n-                            this.with_trait_items(trait_items, |this| {\n-                                let generic_params = HasGenericParams(\n-                                    &trait_item.generics,\n-                                    AssocItemRibKind,\n-                                );\n-                                this.with_generic_param_rib(generic_params, |this| {\n-                                    match trait_item.node {\n-                                        TraitItemKind::Const(ref ty, ref default) => {\n-                                            this.visit_ty(ty);\n-\n-                                            // Only impose the restrictions of\n-                                            // ConstRibKind for an actual constant\n-                                            // expression in a provided default.\n-                                            if let Some(ref expr) = *default{\n-                                                this.with_constant_rib(|this| {\n-                                                    this.visit_expr(expr);\n-                                                });\n-                                            }\n-                                        }\n-                                        TraitItemKind::Method(_, _) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Type(..) => {\n-                                            visit::walk_trait_item(this, trait_item)\n-                                        }\n-                                        TraitItemKind::Macro(_) => {\n-                                            panic!(\"unexpanded macro in resolve!\")\n-                                        }\n-                                    };\n-                                });\n-                            });\n-                        }\n-                    });\n-                });\n-            }\n+            };\n \n-            ItemKind::TraitAlias(ref generics, ref bounds) => {\n-                // Create a new rib for the trait-wide type parameters.\n-                self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-                    let local_def_id = this.definitions.local_def_id(item.id);\n-                    this.with_self_rib(Res::SelfTy(Some(local_def_id), None), |this| {\n-                        this.visit_generics(generics);\n-                        walk_list!(this, visit_param_bound, bounds);\n-                    });\n-                });\n-            }\n+            let is_last = i == path.len() - 1;\n+            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n+            let name = ident.name;\n \n-            ItemKind::Mod(_) | ItemKind::ForeignMod(_) => {\n-                self.with_scope(item.id, |this| {\n-                    visit::walk_item(this, item);\n-                });\n-            }\n-\n-            ItemKind::Static(ref ty, _, ref expr) |\n-            ItemKind::Const(ref ty, ref expr) => {\n-                debug!(\"resolve_item ItemKind::Const\");\n-                self.with_item_rib(|this| {\n-                    this.visit_ty(ty);\n-                    this.with_constant_rib(|this| {\n-                        this.visit_expr(expr);\n-                    });\n-                });\n-            }\n-\n-            ItemKind::Use(ref use_tree) => {\n-                self.future_proof_import(use_tree);\n-            }\n-\n-            ItemKind::ExternCrate(..) |\n-            ItemKind::MacroDef(..) | ItemKind::GlobalAsm(..) => {\n-                // do nothing, these are just around to be encoded\n-            }\n-\n-            ItemKind::Mac(_) => panic!(\"unexpanded macro in resolve!\"),\n-        }\n-    }\n-\n-    fn with_generic_param_rib<'b, F>(&'b mut self, generic_params: GenericParameters<'a, 'b>, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        debug!(\"with_generic_param_rib\");\n-        match generic_params {\n-            HasGenericParams(generics, rib_kind) => {\n-                let mut function_type_rib = Rib::new(rib_kind);\n-                let mut function_value_rib = Rib::new(rib_kind);\n-                let mut seen_bindings = FxHashMap::default();\n-                for param in &generics.params {\n-                    match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {}\n-                        GenericParamKind::Type { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                resolve_error(self, param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            // Plain insert (no renaming).\n-                            let res = Res::Def(\n-                                DefKind::TyParam,\n-                                self.definitions.local_def_id(param.id),\n-                            );\n-                            function_type_rib.bindings.insert(ident, res);\n-                            self.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                        GenericParamKind::Const { .. } => {\n-                            let ident = param.ident.modern();\n-                            debug!(\"with_generic_param_rib: {}\", param.id);\n-\n-                            if seen_bindings.contains_key(&ident) {\n-                                let span = seen_bindings.get(&ident).unwrap();\n-                                let err = ResolutionError::NameAlreadyUsedInParameterList(\n-                                    ident.name,\n-                                    *span,\n-                                );\n-                                resolve_error(self, param.ident.span, err);\n-                            }\n-                            seen_bindings.entry(ident).or_insert(param.ident.span);\n-\n-                            let res = Res::Def(\n-                                DefKind::ConstParam,\n-                                self.definitions.local_def_id(param.id),\n-                            );\n-                            function_value_rib.bindings.insert(ident, res);\n-                            self.record_partial_res(param.id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-                self.ribs[ValueNS].push(function_value_rib);\n-                self.ribs[TypeNS].push(function_type_rib);\n-            }\n-\n-            NoGenericParams => {\n-                // Nothing to do.\n-            }\n-        }\n-\n-        f(self);\n-\n-        if let HasGenericParams(..) = generic_params {\n-            self.ribs[TypeNS].pop();\n-            self.ribs[ValueNS].pop();\n-        }\n-    }\n-\n-    fn with_label_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.label_ribs.push(Rib::new(NormalRibKind));\n-        f(self);\n-        self.label_ribs.pop();\n-    }\n-\n-    fn with_item_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        self.ribs[ValueNS].push(Rib::new(ItemRibKind));\n-        self.ribs[TypeNS].push(Rib::new(ItemRibKind));\n-        f(self);\n-        self.ribs[TypeNS].pop();\n-        self.ribs[ValueNS].pop();\n-    }\n-\n-    fn with_constant_rib<F>(&mut self, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        debug!(\"with_constant_rib\");\n-        self.ribs[ValueNS].push(Rib::new(ConstantItemRibKind));\n-        self.label_ribs.push(Rib::new(ConstantItemRibKind));\n-        f(self);\n-        self.label_ribs.pop();\n-        self.ribs[ValueNS].pop();\n-    }\n-\n-    fn with_current_self_type<T, F>(&mut self, self_type: &Ty, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n-        // Handle nested impls (inside fn bodies)\n-        let previous_value = replace(&mut self.current_self_type, Some(self_type.clone()));\n-        let result = f(self);\n-        self.current_self_type = previous_value;\n-        result\n-    }\n-\n-    fn with_current_self_item<T, F>(&mut self, self_item: &Item, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n-        let previous_value = replace(&mut self.current_self_item, Some(self_item.id));\n-        let result = f(self);\n-        self.current_self_item = previous_value;\n-        result\n-    }\n-\n-    /// When evaluating a `trait` use its associated types' idents for suggestionsa in E0412.\n-    fn with_trait_items<T, F>(&mut self, trait_items: &Vec<TraitItem>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>) -> T\n-    {\n-        let trait_assoc_types = replace(\n-            &mut self.current_trait_assoc_types,\n-            trait_items.iter().filter_map(|item| match &item.node {\n-                TraitItemKind::Type(bounds, _) if bounds.len() == 0 => Some(item.ident),\n-                _ => None,\n-            }).collect(),\n-        );\n-        let result = f(self);\n-        self.current_trait_assoc_types = trait_assoc_types;\n-        result\n-    }\n-\n-    /// This is called to resolve a trait reference from an `impl` (i.e., `impl Trait for Foo`).\n-    fn with_optional_trait_ref<T, F>(&mut self, opt_trait_ref: Option<&TraitRef>, f: F) -> T\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>, Option<DefId>) -> T\n-    {\n-        let mut new_val = None;\n-        let mut new_id = None;\n-        if let Some(trait_ref) = opt_trait_ref {\n-            let path: Vec<_> = Segment::from_path(&trait_ref.path);\n-            let res = self.smart_resolve_path_fragment(\n-                trait_ref.ref_id,\n-                None,\n-                &path,\n-                trait_ref.path.span,\n-                PathSource::Trait(AliasPossibility::No),\n-                CrateLint::SimplePath(trait_ref.ref_id),\n-            ).base_res();\n-            if res != Res::Err {\n-                new_id = Some(res.def_id());\n-                let span = trait_ref.path.span;\n-                if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                    self.resolve_path(\n-                        &path,\n-                        Some(TypeNS),\n-                        false,\n-                        span,\n-                        CrateLint::SimplePath(trait_ref.ref_id),\n-                    )\n-                {\n-                    new_val = Some((module, trait_ref.clone()));\n-                }\n-            }\n-        }\n-        let original_trait_ref = replace(&mut self.current_trait_ref, new_val);\n-        let result = f(self, new_id);\n-        self.current_trait_ref = original_trait_ref;\n-        result\n-    }\n-\n-    fn with_self_rib<F>(&mut self, self_res: Res, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        let mut self_type_rib = Rib::new(NormalRibKind);\n-\n-        // Plain insert (no renaming, since types are not currently hygienic)\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n-        self.ribs[TypeNS].push(self_type_rib);\n-        f(self);\n-        self.ribs[TypeNS].pop();\n-    }\n-\n-    fn with_self_struct_ctor_rib<F>(&mut self, impl_id: DefId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        let self_res = Res::SelfCtor(impl_id);\n-        let mut self_type_rib = Rib::new(NormalRibKind);\n-        self_type_rib.bindings.insert(Ident::with_empty_ctxt(kw::SelfUpper), self_res);\n-        self.ribs[ValueNS].push(self_type_rib);\n-        f(self);\n-        self.ribs[ValueNS].pop();\n-    }\n-\n-    fn resolve_implementation(&mut self,\n-                              generics: &Generics,\n-                              opt_trait_reference: &Option<TraitRef>,\n-                              self_type: &Ty,\n-                              item_id: NodeId,\n-                              impl_items: &[ImplItem]) {\n-        debug!(\"resolve_implementation\");\n-        // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(HasGenericParams(generics, ItemRibKind), |this| {\n-            // Dummy self type for better errors if `Self` is used in the trait path.\n-            this.with_self_rib(Res::SelfTy(None, None), |this| {\n-                // Resolve the trait reference, if necessary.\n-                this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n-                    let item_def_id = this.definitions.local_def_id(item_id);\n-                    this.with_self_rib(Res::SelfTy(trait_id, Some(item_def_id)), |this| {\n-                        if let Some(trait_ref) = opt_trait_reference.as_ref() {\n-                            // Resolve type arguments in the trait path.\n-                            visit::walk_trait_ref(this, trait_ref);\n-                        }\n-                        // Resolve the self type.\n-                        this.visit_ty(self_type);\n-                        // Resolve the generic parameters.\n-                        this.visit_generics(generics);\n-                        // Resolve the items within the impl.\n-                        this.with_current_self_type(self_type, |this| {\n-                            this.with_self_struct_ctor_rib(item_def_id, |this| {\n-                                debug!(\"resolve_implementation with_self_struct_ctor_rib\");\n-                                for impl_item in impl_items {\n-                                    this.resolver.resolve_visibility(\n-                                        &impl_item.vis, &this.parent_scope()\n-                                    );\n-                                    // We also need a new scope for the impl item type parameters.\n-                                    let generic_params = HasGenericParams(&impl_item.generics,\n-                                                                          AssocItemRibKind);\n-                                    this.with_generic_param_rib(generic_params, |this| {\n-                                        use self::ResolutionError::*;\n-                                        match impl_item.node {\n-                                            ImplItemKind::Const(..) => {\n-                                                debug!(\n-                                                    \"resolve_implementation ImplItemKind::Const\",\n-                                                );\n-                                                // If this is a trait impl, ensure the const\n-                                                // exists in trait\n-                                                this.check_trait_item(\n-                                                    impl_item.ident,\n-                                                    ValueNS,\n-                                                    impl_item.span,\n-                                                    |n, s| ConstNotMemberOfTrait(n, s),\n-                                                );\n-\n-                                                this.with_constant_rib(|this| {\n-                                                    visit::walk_impl_item(this, impl_item)\n-                                                });\n-                                            }\n-                                            ImplItemKind::Method(..) => {\n-                                                // If this is a trait impl, ensure the method\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      ValueNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| MethodNotMemberOfTrait(n, s));\n-\n-                                                visit::walk_impl_item(this, impl_item);\n-                                            }\n-                                            ImplItemKind::TyAlias(ref ty) => {\n-                                                // If this is a trait impl, ensure the type\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      TypeNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| TypeNotMemberOfTrait(n, s));\n-\n-                                                this.visit_ty(ty);\n-                                            }\n-                                            ImplItemKind::OpaqueTy(ref bounds) => {\n-                                                // If this is a trait impl, ensure the type\n-                                                // exists in trait\n-                                                this.check_trait_item(impl_item.ident,\n-                                                                      TypeNS,\n-                                                                      impl_item.span,\n-                                                    |n, s| TypeNotMemberOfTrait(n, s));\n-\n-                                                for bound in bounds {\n-                                                    this.visit_param_bound(bound);\n-                                                }\n-                                            }\n-                                            ImplItemKind::Macro(_) =>\n-                                                panic!(\"unexpanded macro in resolve!\"),\n-                                        }\n-                                    });\n-                                }\n-                            });\n-                        });\n-                    });\n-                });\n-            });\n-        });\n-    }\n-\n-    fn check_trait_item<F>(&mut self, ident: Ident, ns: Namespace, span: Span, err: F)\n-        where F: FnOnce(Name, &str) -> ResolutionError<'_>\n-    {\n-        // If there is a TraitRef in scope for an impl, then the method must be in the\n-        // trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if self.resolve_ident_in_module(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                false,\n-                span,\n-            ).is_err() {\n-                let path = &self.current_trait_ref.as_ref().unwrap().1.path;\n-                resolve_error(self, span, err(ident.name, &path_names_to_string(path)));\n-            }\n-        }\n-    }\n-\n-    fn resolve_local(&mut self, local: &Local) {\n-        // Resolve the type.\n-        walk_list!(self, visit_ty, &local.ty);\n-\n-        // Resolve the initializer.\n-        walk_list!(self, visit_expr, &local.init);\n-\n-        // Resolve the pattern.\n-        self.resolve_pattern(&local.pat, PatternSource::Let, &mut FxHashMap::default());\n-    }\n-\n-    // build a map from pattern identifiers to binding-info's.\n-    // this is done hygienically. This could arise for a macro\n-    // that expands into an or-pattern where one 'x' was from the\n-    // user and one 'x' came from the macro.\n-    fn binding_mode_map(&mut self, pat: &Pat) -> BindingMap {\n-        let mut binding_map = FxHashMap::default();\n-\n-        pat.walk(&mut |pat| {\n-            if let PatKind::Ident(binding_mode, ident, ref sub_pat) = pat.node {\n-                if sub_pat.is_some() || match self.partial_res_map.get(&pat.id)\n-                                                                  .map(|res| res.base_res()) {\n-                    Some(Res::Local(..)) => true,\n-                    _ => false,\n-                } {\n-                    let binding_info = BindingInfo { span: ident.span, binding_mode: binding_mode };\n-                    binding_map.insert(ident, binding_info);\n-                }\n-            }\n-            true\n-        });\n-\n-        binding_map\n-    }\n-\n-    // Checks that all of the arms in an or-pattern have exactly the\n-    // same set of bindings, with the same binding modes for each.\n-    fn check_consistent_bindings(&mut self, pats: &[P<Pat>]) {\n-        if pats.is_empty() {\n-            return;\n-        }\n-\n-        let mut missing_vars = FxHashMap::default();\n-        let mut inconsistent_vars = FxHashMap::default();\n-        for (i, p) in pats.iter().enumerate() {\n-            let map_i = self.binding_mode_map(&p);\n-\n-            for (j, q) in pats.iter().enumerate() {\n-                if i == j {\n-                    continue;\n-                }\n-\n-                let map_j = self.binding_mode_map(&q);\n-                for (&key, &binding_i) in &map_i {\n-                    if map_j.is_empty() {                   // Account for missing bindings when\n-                        let binding_error = missing_vars    // `map_j` has none.\n-                            .entry(key.name)\n-                            .or_insert(BindingError {\n-                                name: key.name,\n-                                origin: BTreeSet::new(),\n-                                target: BTreeSet::new(),\n-                            });\n-                        binding_error.origin.insert(binding_i.span);\n-                        binding_error.target.insert(q.span);\n-                    }\n-                    for (&key_j, &binding_j) in &map_j {\n-                        match map_i.get(&key_j) {\n-                            None => {  // missing binding\n-                                let binding_error = missing_vars\n-                                    .entry(key_j.name)\n-                                    .or_insert(BindingError {\n-                                        name: key_j.name,\n-                                        origin: BTreeSet::new(),\n-                                        target: BTreeSet::new(),\n-                                    });\n-                                binding_error.origin.insert(binding_j.span);\n-                                binding_error.target.insert(p.span);\n-                            }\n-                            Some(binding_i) => {  // check consistent binding\n-                                if binding_i.binding_mode != binding_j.binding_mode {\n-                                    inconsistent_vars\n-                                        .entry(key.name)\n-                                        .or_insert((binding_j.span, binding_i.span));\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n-        missing_vars.sort();\n-        for (_, v) in missing_vars {\n-            resolve_error(self,\n-                          *v.origin.iter().next().unwrap(),\n-                          ResolutionError::VariableNotBoundInPattern(v));\n-        }\n-        let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n-        inconsistent_vars.sort();\n-        for (name, v) in inconsistent_vars {\n-            resolve_error(self, v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n-        }\n-    }\n-\n-    fn resolve_arm(&mut self, arm: &Arm) {\n-        self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-\n-        self.resolve_pats(&arm.pats, PatternSource::Match);\n-\n-        if let Some(ref expr) = arm.guard {\n-            self.visit_expr(expr)\n-        }\n-        self.visit_expr(&arm.body);\n-\n-        self.ribs[ValueNS].pop();\n-    }\n-\n-    /// Arising from `source`, resolve a sequence of patterns (top level or-patterns).\n-    fn resolve_pats(&mut self, pats: &[P<Pat>], source: PatternSource) {\n-        let mut bindings_list = FxHashMap::default();\n-        for pat in pats {\n-            self.resolve_pattern(pat, source, &mut bindings_list);\n-        }\n-        // This has to happen *after* we determine which pat_idents are variants\n-        self.check_consistent_bindings(pats);\n-    }\n-\n-    fn resolve_block(&mut self, block: &Block) {\n-        debug!(\"(resolving block) entering block\");\n-        // Move down in the graph, if there's an anonymous module rooted here.\n-        let orig_module = self.current_module;\n-        let anonymous_module = self.block_map.get(&block.id).cloned(); // clones a reference\n-\n-        let mut num_macro_definition_ribs = 0;\n-        if let Some(anonymous_module) = anonymous_module {\n-            debug!(\"(resolving block) found anonymous module, moving down\");\n-            self.ribs[ValueNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.ribs[TypeNS].push(Rib::new(ModuleRibKind(anonymous_module)));\n-            self.current_module = anonymous_module;\n-            self.resolver.finalize_current_module_macro_resolutions(self.current_module);\n-        } else {\n-            self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-        }\n-\n-        // Descend into the block.\n-        for stmt in &block.stmts {\n-            if let ast::StmtKind::Item(ref item) = stmt.node {\n-                if let ast::ItemKind::MacroDef(..) = item.node {\n-                    num_macro_definition_ribs += 1;\n-                    let res = self.definitions.local_def_id(item.id);\n-                    self.ribs[ValueNS].push(Rib::new(MacroDefinition(res)));\n-                    self.label_ribs.push(Rib::new(MacroDefinition(res)));\n-                }\n-            }\n-\n-            self.visit_stmt(stmt);\n-        }\n-\n-        // Move back up.\n-        self.current_module = orig_module;\n-        for _ in 0 .. num_macro_definition_ribs {\n-            self.ribs[ValueNS].pop();\n-            self.label_ribs.pop();\n-        }\n-        self.ribs[ValueNS].pop();\n-        if anonymous_module.is_some() {\n-            self.ribs[TypeNS].pop();\n-        }\n-        debug!(\"(resolving block) leaving block\");\n-    }\n-\n-    fn fresh_binding(&mut self,\n-                     ident: Ident,\n-                     pat_id: NodeId,\n-                     outer_pat_id: NodeId,\n-                     pat_src: PatternSource,\n-                     bindings: &mut FxHashMap<Ident, NodeId>)\n-                     -> Res {\n-        // Add the binding to the local ribs, if it\n-        // doesn't already exist in the bindings map. (We\n-        // must not add it if it's in the bindings map\n-        // because that breaks the assumptions later\n-        // passes make about or-patterns.)\n-        let ident = ident.modern_and_legacy();\n-        let mut res = Res::Local(pat_id);\n-        match bindings.get(&ident).cloned() {\n-            Some(id) if id == outer_pat_id => {\n-                // `Variant(a, a)`, error\n-                resolve_error(\n-                    self,\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInSamePattern(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::FnParam => {\n-                // `fn f(a: u8, a: u8)`, error\n-                resolve_error(\n-                    self,\n-                    ident.span,\n-                    ResolutionError::IdentifierBoundMoreThanOnceInParameterList(\n-                        &ident.as_str())\n-                );\n-            }\n-            Some(..) if pat_src == PatternSource::Match ||\n-                        pat_src == PatternSource::Let => {\n-                // `Variant1(a) | Variant2(a)`, ok\n-                // Reuse definition from the first `a`.\n-                res = self.ribs[ValueNS].last_mut().unwrap().bindings[&ident];\n-            }\n-            Some(..) => {\n-                span_bug!(ident.span, \"two bindings with the same name from \\\n-                                       unexpected pattern source {:?}\", pat_src);\n-            }\n-            None => {\n-                // A completely fresh binding, add to the lists if it's valid.\n-                if ident.name != kw::Invalid {\n-                    bindings.insert(ident, outer_pat_id);\n-                    self.ribs[ValueNS].last_mut().unwrap().bindings.insert(ident, res);\n-                }\n-            }\n-        }\n-\n-        res\n-    }\n-\n-    fn resolve_pattern(&mut self,\n-                       pat: &Pat,\n-                       pat_src: PatternSource,\n-                       // Maps idents to the node ID for the\n-                       // outermost pattern that binds them.\n-                       bindings: &mut FxHashMap<Ident, NodeId>) {\n-        // Visit all direct subpatterns of this pattern.\n-        let outer_pat_id = pat.id;\n-        pat.walk(&mut |pat| {\n-            debug!(\"resolve_pattern pat={:?} node={:?}\", pat, pat.node);\n-            match pat.node {\n-                PatKind::Ident(bmode, ident, ref opt_pat) => {\n-                    // First try to resolve the identifier as some existing\n-                    // entity, then fall back to a fresh binding.\n-                    let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS,\n-                                                                      None, pat.span)\n-                                      .and_then(LexicalScopeBinding::item);\n-                    let res = binding.map(NameBinding::res).and_then(|res| {\n-                        let is_syntactic_ambiguity = opt_pat.is_none() &&\n-                            bmode == BindingMode::ByValue(Mutability::Immutable);\n-                        match res {\n-                            Res::Def(DefKind::Ctor(_, CtorKind::Const), _) |\n-                            Res::Def(DefKind::Const, _) if is_syntactic_ambiguity => {\n-                                // Disambiguate in favor of a unit struct/variant\n-                                // or constant pattern.\n-                                self.record_use(ident, ValueNS, binding.unwrap(), false);\n-                                Some(res)\n-                            }\n-                            Res::Def(DefKind::Ctor(..), _)\n-                            | Res::Def(DefKind::Const, _)\n-                            | Res::Def(DefKind::Static, _) => {\n-                                // This is unambiguously a fresh binding, either syntactically\n-                                // (e.g., `IDENT @ PAT` or `ref IDENT`) or because `IDENT` resolves\n-                                // to something unusable as a pattern (e.g., constructor function),\n-                                // but we still conservatively report an error, see\n-                                // issues/33118#issuecomment-233962221 for one reason why.\n-                                resolve_error(\n-                                    self,\n-                                    ident.span,\n-                                    ResolutionError::BindingShadowsSomethingUnacceptable(\n-                                        pat_src.descr(), ident.name, binding.unwrap())\n-                                );\n-                                None\n-                            }\n-                            Res::Def(DefKind::Fn, _) | Res::Err => {\n-                                // These entities are explicitly allowed\n-                                // to be shadowed by fresh bindings.\n-                                None\n-                            }\n-                            res => {\n-                                span_bug!(ident.span, \"unexpected resolution for an \\\n-                                                       identifier in pattern: {:?}\", res);\n-                            }\n-                        }\n-                    }).unwrap_or_else(|| {\n-                        self.fresh_binding(ident, pat.id, outer_pat_id, pat_src, bindings)\n-                    });\n-\n-                    self.record_partial_res(pat.id, PartialRes::new(res));\n-                }\n-\n-                PatKind::TupleStruct(ref path, ..) => {\n-                    self.smart_resolve_path(pat.id, None, path, PathSource::TupleStruct);\n-                }\n-\n-                PatKind::Path(ref qself, ref path) => {\n-                    self.smart_resolve_path(pat.id, qself.as_ref(), path, PathSource::Pat);\n-                }\n-\n-                PatKind::Struct(ref path, ..) => {\n-                    self.smart_resolve_path(pat.id, None, path, PathSource::Struct);\n-                }\n-\n-                _ => {}\n-            }\n-            true\n-        });\n-\n-        visit::walk_pat(self, pat);\n-    }\n-\n-    // High-level and context dependent path resolution routine.\n-    // Resolves the path and records the resolution into definition map.\n-    // If resolution fails tries several techniques to find likely\n-    // resolution candidates, suggest imports or other help, and report\n-    // errors in user friendly way.\n-    fn smart_resolve_path(&mut self,\n-                          id: NodeId,\n-                          qself: Option<&QSelf>,\n-                          path: &Path,\n-                          source: PathSource<'_>) {\n-        self.smart_resolve_path_fragment(\n-            id,\n-            qself,\n-            &Segment::from_path(path),\n-            path.span,\n-            source,\n-            CrateLint::SimplePath(id),\n-        );\n-    }\n-\n-    fn smart_resolve_path_fragment(&mut self,\n-                                   id: NodeId,\n-                                   qself: Option<&QSelf>,\n-                                   path: &[Segment],\n-                                   span: Span,\n-                                   source: PathSource<'_>,\n-                                   crate_lint: CrateLint)\n-                                   -> PartialRes {\n-        let ns = source.namespace();\n-        let is_expected = &|res| source.is_expected(res);\n-\n-        let report_errors = |this: &mut Self, res: Option<Res>| {\n-            let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n-            let def_id = this.current_module.normal_ancestor_id;\n-            let node_id = this.definitions.as_local_node_id(def_id).unwrap();\n-            let better = res.is_some();\n-            this.use_injections.push(UseError { err, candidates, node_id, better });\n-            PartialRes::new(Res::Err)\n-        };\n-\n-        let partial_res = match self.resolve_qpath_anywhere(\n-            id,\n-            qself,\n-            path,\n-            ns,\n-            span,\n-            source.defer_to_typeck(),\n-            crate_lint,\n-        ) {\n-            Some(partial_res) if partial_res.unresolved_segments() == 0 => {\n-                if is_expected(partial_res.base_res()) || partial_res.base_res() == Res::Err {\n-                    partial_res\n-                } else {\n-                    // Add a temporary hack to smooth the transition to new struct ctor\n-                    // visibility rules. See #38932 for more details.\n-                    let mut res = None;\n-                    if let Res::Def(DefKind::Struct, def_id) = partial_res.base_res() {\n-                        if let Some((ctor_res, ctor_vis))\n-                                = self.struct_constructors.get(&def_id).cloned() {\n-                            if is_expected(ctor_res) &&\n-                               self.is_accessible_from(ctor_vis, self.current_module) {\n-                                let lint = lint::builtin::LEGACY_CONSTRUCTOR_VISIBILITY;\n-                                self.session.buffer_lint(lint, id, span,\n-                                    \"private struct constructors are not usable through \\\n-                                     re-exports in outer modules\",\n-                                );\n-                                res = Some(PartialRes::new(ctor_res));\n-                            }\n-                        }\n-                    }\n-\n-                    res.unwrap_or_else(|| report_errors(self, Some(partial_res.base_res())))\n-                }\n-            }\n-            Some(partial_res) if source.defer_to_typeck() => {\n-                // Not fully resolved associated item `T::A::B` or `<T as Tr>::A::B`\n-                // or `<T>::A::B`. If `B` should be resolved in value namespace then\n-                // it needs to be added to the trait map.\n-                if ns == ValueNS {\n-                    let item_name = path.last().unwrap().ident;\n-                    let traits = self.get_traits_containing_item(item_name, ns);\n-                    self.trait_map.insert(id, traits);\n-                }\n-\n-                let mut std_path = vec![Segment::from_ident(Ident::with_empty_ctxt(sym::std))];\n-                std_path.extend(path);\n-                if self.primitive_type_table.primitive_types.contains_key(&path[0].ident.name) {\n-                    let cl = CrateLint::No;\n-                    let ns = Some(ns);\n-                    if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                            self.resolve_path(&std_path, ns, false, span, cl) {\n-                        // check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n-                        let item_span = path.iter().last().map(|segment| segment.ident.span)\n-                            .unwrap_or(span);\n-                        debug!(\"accessed item from `std` submodule as a bare type {:?}\", std_path);\n-                        let mut hm = self.session.confused_type_with_std_module.borrow_mut();\n-                        hm.insert(item_span, span);\n-                        // In some places (E0223) we only have access to the full path\n-                        hm.insert(span, span);\n-                    }\n-                }\n-                partial_res\n-            }\n-            _ => report_errors(self, None)\n-        };\n-\n-        if let PathSource::TraitItem(..) = source {} else {\n-            // Avoid recording definition of `A::B` in `<T as A>::B::C`.\n-            self.record_partial_res(id, partial_res);\n-        }\n-        partial_res\n-    }\n-\n-    /// Only used in a specific case of type ascription suggestions\n-    #[doc(hidden)]\n-    fn get_colon_suggestion_span(&self, start: Span) -> Span {\n-        let cm = self.session.source_map();\n-        start.to(cm.next_point(start))\n-    }\n-\n-    fn type_ascription_suggestion(\n-        &self,\n-        err: &mut DiagnosticBuilder<'_>,\n-        base_span: Span,\n-    ) {\n-        debug!(\"type_ascription_suggetion {:?}\", base_span);\n-        let cm = self.session.source_map();\n-        let base_snippet = cm.span_to_snippet(base_span);\n-        debug!(\"self.current_type_ascription {:?}\", self.current_type_ascription);\n-        if let Some(sp) = self.current_type_ascription.last() {\n-            let mut sp = *sp;\n-            loop {\n-                // Try to find the `:`; bail on first non-':' / non-whitespace.\n-                sp = cm.next_point(sp);\n-                if let Ok(snippet) = cm.span_to_snippet(sp.to(cm.next_point(sp))) {\n-                    let line_sp = cm.lookup_char_pos(sp.hi()).line;\n-                    let line_base_sp = cm.lookup_char_pos(base_span.lo()).line;\n-                    if snippet == \":\" {\n-                        let mut show_label = true;\n-                        if line_sp != line_base_sp {\n-                            err.span_suggestion_short(\n-                                sp,\n-                                \"did you mean to use `;` here instead?\",\n-                                \";\".to_string(),\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        } else {\n-                            let colon_sp = self.get_colon_suggestion_span(sp);\n-                            let after_colon_sp = self.get_colon_suggestion_span(\n-                                colon_sp.shrink_to_hi(),\n-                            );\n-                            if !cm.span_to_snippet(after_colon_sp).map(|s| s == \" \")\n-                                .unwrap_or(false)\n-                            {\n-                                err.span_suggestion(\n-                                    colon_sp,\n-                                    \"maybe you meant to write a path separator here\",\n-                                    \"::\".to_string(),\n-                                    Applicability::MaybeIncorrect,\n-                                );\n-                                show_label = false;\n-                            }\n-                            if let Ok(base_snippet) = base_snippet {\n-                                let mut sp = after_colon_sp;\n-                                for _ in 0..100 {\n-                                    // Try to find an assignment\n-                                    sp = cm.next_point(sp);\n-                                    let snippet = cm.span_to_snippet(sp.to(cm.next_point(sp)));\n-                                    match snippet {\n-                                        Ok(ref x) if x.as_str() == \"=\" => {\n-                                            err.span_suggestion(\n-                                                base_span,\n-                                                \"maybe you meant to write an assignment here\",\n-                                                format!(\"let {}\", base_snippet),\n-                                                Applicability::MaybeIncorrect,\n-                                            );\n-                                            show_label = false;\n-                                            break;\n-                                        }\n-                                        Ok(ref x) if x.as_str() == \"\\n\" => break,\n-                                        Err(_) => break,\n-                                        Ok(_) => {}\n-                                    }\n-                                }\n-                            }\n-                        }\n-                        if show_label {\n-                            err.span_label(base_span,\n-                                           \"expecting a type here because of type ascription\");\n-                        }\n-                        break;\n-                    } else if !snippet.trim().is_empty() {\n-                        debug!(\"tried to find type ascription `:` token, couldn't find it\");\n-                        break;\n-                    }\n-                } else {\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-\n-    fn self_type_is_available(&mut self, span: Span) -> bool {\n-        let binding = self.resolve_ident_in_lexical_scope(\n-            Ident::with_empty_ctxt(kw::SelfUpper),\n-            TypeNS,\n-            None,\n-            span,\n-        );\n-        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n-    }\n-\n-    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n-        let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n-        if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n-    }\n-\n-    // Resolve in alternative namespaces if resolution in the primary namespace fails.\n-    fn resolve_qpath_anywhere(\n-        &mut self,\n-        id: NodeId,\n-        qself: Option<&QSelf>,\n-        path: &[Segment],\n-        primary_ns: Namespace,\n-        span: Span,\n-        defer_to_typeck: bool,\n-        crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n-        let mut fin_res = None;\n-        for (i, ns) in [primary_ns, TypeNS, ValueNS].iter().cloned().enumerate() {\n-            if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, crate_lint) {\n-                    // If defer_to_typeck, then resolution > no resolution,\n-                    // otherwise full resolution > partial resolution > no resolution.\n-                    Some(partial_res) if partial_res.unresolved_segments() == 0 ||\n-                                         defer_to_typeck =>\n-                        return Some(partial_res),\n-                    partial_res => if fin_res.is_none() { fin_res = partial_res },\n-                }\n-            }\n-        }\n-\n-        // `MacroNS`\n-        assert!(primary_ns != MacroNS);\n-        if qself.is_none() {\n-            let path_seg = |seg: &Segment| ast::PathSegment::from_ident(seg.ident);\n-            let path = Path { segments: path.iter().map(path_seg).collect(), span };\n-            let parent_scope = &self.parent_scope();\n-            if let Ok((_, res)) =\n-                    self.resolve_macro_path(&path, None, parent_scope, false, false) {\n-                return Some(PartialRes::new(res));\n-            }\n-        }\n-\n-        fin_res\n-    }\n-\n-    /// Handles paths that may refer to associated items.\n-    fn resolve_qpath(\n-        &mut self,\n-        id: NodeId,\n-        qself: Option<&QSelf>,\n-        path: &[Segment],\n-        ns: Namespace,\n-        span: Span,\n-        crate_lint: CrateLint,\n-    ) -> Option<PartialRes> {\n-        debug!(\n-            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n-            id,\n-            qself,\n-            path,\n-            ns,\n-            span,\n-        );\n-\n-        if let Some(qself) = qself {\n-            if qself.position == 0 {\n-                // This is a case like `<T>::B`, where there is no\n-                // trait to resolve.  In that case, we leave the `B`\n-                // segment to be resolved by type-check.\n-                return Some(PartialRes::with_unresolved_segments(\n-                    Res::Def(DefKind::Mod, DefId::local(CRATE_DEF_INDEX)), path.len()\n-                ));\n-            }\n-\n-            // Make sure `A::B` in `<T as A::B>::C` is a trait item.\n-            //\n-            // Currently, `path` names the full item (`A::B::C`, in\n-            // our example).  so we extract the prefix of that that is\n-            // the trait (the slice upto and including\n-            // `qself.position`). And then we recursively resolve that,\n-            // but with `qself` set to `None`.\n-            //\n-            // However, setting `qself` to none (but not changing the\n-            // span) loses the information about where this path\n-            // *actually* appears, so for the purposes of the crate\n-            // lint we pass along information that this is the trait\n-            // name from a fully qualified path, and this also\n-            // contains the full span (the `CrateLint::QPathTrait`).\n-            let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n-            let partial_res = self.smart_resolve_path_fragment(\n-                id,\n-                None,\n-                &path[..=qself.position],\n-                span,\n-                PathSource::TraitItem(ns),\n-                CrateLint::QPathTrait {\n-                    qpath_id: id,\n-                    qpath_span: qself.path_span,\n-                },\n-            );\n-\n-            // The remaining segments (the `C` in our example) will\n-            // have to be resolved by type-check, since that requires doing\n-            // trait resolution.\n-            return Some(PartialRes::with_unresolved_segments(\n-                partial_res.base_res(),\n-                partial_res.unresolved_segments() + path.len() - qself.position - 1,\n-            ));\n-        }\n-\n-        let result = match self.resolve_path(&path, Some(ns), true, span, crate_lint) {\n-            PathResult::NonModule(path_res) => path_res,\n-            PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n-                PartialRes::new(module.res().unwrap())\n-            }\n-            // In `a(::assoc_item)*` `a` cannot be a module. If `a` does resolve to a module we\n-            // don't report an error right away, but try to fallback to a primitive type.\n-            // So, we are still able to successfully resolve something like\n-            //\n-            // use std::u8; // bring module u8 in scope\n-            // fn f() -> u8 { // OK, resolves to primitive u8, not to std::u8\n-            //     u8::max_value() // OK, resolves to associated function <u8>::max_value,\n-            //                     // not to non-existent std::u8::max_value\n-            // }\n-            //\n-            // Such behavior is required for backward compatibility.\n-            // The same fallback is used when `a` resolves to nothing.\n-            PathResult::Module(ModuleOrUniformRoot::Module(_)) |\n-            PathResult::Failed { .. }\n-                    if (ns == TypeNS || path.len() > 1) &&\n-                       self.primitive_type_table.primitive_types\n-                           .contains_key(&path[0].ident.name) => {\n-                let prim = self.primitive_type_table.primitive_types[&path[0].ident.name];\n-                PartialRes::with_unresolved_segments(Res::PrimTy(prim), path.len() - 1)\n-            }\n-            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                PartialRes::new(module.res().unwrap()),\n-            PathResult::Failed { is_error_from_last_segment: false, span, label, suggestion } => {\n-                resolve_error(self, span, ResolutionError::FailedToResolve { label, suggestion });\n-                PartialRes::new(Res::Err)\n-            }\n-            PathResult::Module(..) | PathResult::Failed { .. } => return None,\n-            PathResult::Indeterminate => bug!(\"indetermined path result in resolve_qpath\"),\n-        };\n-\n-        if path.len() > 1 && result.base_res() != Res::Err &&\n-           path[0].ident.name != kw::PathRoot &&\n-           path[0].ident.name != kw::DollarCrate {\n-            let unqualified_result = {\n-                match self.resolve_path(\n-                    &[*path.last().unwrap()],\n-                    Some(ns),\n-                    false,\n-                    span,\n-                    CrateLint::No,\n-                ) {\n-                    PathResult::NonModule(path_res) => path_res.base_res(),\n-                    PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n-                        module.res().unwrap(),\n-                    _ => return Some(result),\n-                }\n-            };\n-            if result.base_res() == unqualified_result {\n-                let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.session.buffer_lint(lint, id, span, \"unnecessary qualification\")\n-            }\n-        }\n-\n-        Some(result)\n-    }\n-}\n-\n-impl<'a> Resolver<'a> {\n-    fn resolve_path(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n-        crate_lint: CrateLint,\n-    ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(\n-            path, opt_ns, parent_scope, record_used, path_span, crate_lint, &Default::default()\n-        )\n-    }\n-\n-    fn resolve_path_with_ribs(\n-        &mut self,\n-        path: &[Segment],\n-        opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n-        crate_lint: CrateLint,\n-        ribs: &PerNS<Vec<Rib<'a>>>,\n-    ) -> PathResult<'a> {\n-        let mut module = None;\n-        let mut allow_super = true;\n-        let mut second_binding = None;\n-\n-        debug!(\n-            \"resolve_path(path={:?}, opt_ns={:?}, record_used={:?}, \\\n-             path_span={:?}, crate_lint={:?})\",\n-            path,\n-            opt_ns,\n-            record_used,\n-            path_span,\n-            crate_lint,\n-        );\n-\n-        for (i, &Segment { ident, id }) in path.iter().enumerate() {\n-            debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n-            let record_segment_res = |this: &mut Self, res| {\n-                if record_used {\n-                    if let Some(id) = id {\n-                        if !this.partial_res_map.contains_key(&id) {\n-                            assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n-                            this.record_partial_res(id, PartialRes::new(res));\n-                        }\n-                    }\n-                }\n-            };\n-\n-            let is_last = i == path.len() - 1;\n-            let ns = if is_last { opt_ns.unwrap_or(TypeNS) } else { TypeNS };\n-            let name = ident.name;\n-\n-            allow_super &= ns == TypeNS &&\n-                (name == kw::SelfLower ||\n-                 name == kw::Super);\n+            allow_super &= ns == TypeNS &&\n+                (name == kw::SelfLower ||\n+                 name == kw::Super);\n \n             if ns == TypeNS {\n                 if allow_super && name == kw::Super {\n@@ -4327,307 +2681,7 @@ impl<'a> Resolver<'a> {\n         }\n         res\n     }\n-}\n-\n-impl<'a> LateResolutionVisitor<'a, '_> {\n-    fn with_resolved_label<F>(&mut self, label: Option<Label>, id: NodeId, f: F)\n-        where F: FnOnce(&mut LateResolutionVisitor<'_, '_>)\n-    {\n-        if let Some(label) = label {\n-            self.unused_labels.insert(id, label.ident.span);\n-            self.with_label_rib(|this| {\n-                let ident = label.ident.modern_and_legacy();\n-                this.label_ribs.last_mut().unwrap().bindings.insert(ident, id);\n-                f(this);\n-            });\n-        } else {\n-            f(self);\n-        }\n-    }\n-\n-    fn resolve_labeled_block(&mut self, label: Option<Label>, id: NodeId, block: &Block) {\n-        self.with_resolved_label(label, id, |this| this.visit_block(block));\n-    }\n-\n-    fn resolve_expr(&mut self, expr: &Expr, parent: Option<&Expr>) {\n-        // First, record candidate traits for this expression if it could\n-        // result in the invocation of a method call.\n-\n-        self.record_candidate_traits_for_expr_if_necessary(expr);\n-\n-        // Next, resolve the node.\n-        match expr.node {\n-            ExprKind::Path(ref qself, ref path) => {\n-                self.smart_resolve_path(expr.id, qself.as_ref(), path, PathSource::Expr(parent));\n-                visit::walk_expr(self, expr);\n-            }\n-\n-            ExprKind::Struct(ref path, ..) => {\n-                self.smart_resolve_path(expr.id, None, path, PathSource::Struct);\n-                visit::walk_expr(self, expr);\n-            }\n-\n-            ExprKind::Break(Some(label), _) | ExprKind::Continue(Some(label)) => {\n-                let node_id = self.search_label(label.ident, |rib, ident| {\n-                    rib.bindings.get(&ident.modern_and_legacy()).cloned()\n-                });\n-                match node_id {\n-                    None => {\n-                        // Search again for close matches...\n-                        // Picks the first label that is \"close enough\", which is not necessarily\n-                        // the closest match\n-                        let close_match = self.search_label(label.ident, |rib, ident| {\n-                            let names = rib.bindings.iter().filter_map(|(id, _)| {\n-                                if id.span.ctxt() == label.ident.span.ctxt() {\n-                                    Some(&id.name)\n-                                } else {\n-                                    None\n-                                }\n-                            });\n-                            find_best_match_for_name(names, &*ident.as_str(), None)\n-                        });\n-                        self.record_partial_res(expr.id, PartialRes::new(Res::Err));\n-                        resolve_error(self,\n-                                      label.ident.span,\n-                                      ResolutionError::UndeclaredLabel(&label.ident.as_str(),\n-                                                                       close_match));\n-                    }\n-                    Some(node_id) => {\n-                        // Since this res is a label, it is never read.\n-                        self.label_res_map.insert(expr.id, node_id);\n-                        self.unused_labels.remove(&node_id);\n-                    }\n-                }\n-\n-                // visit `break` argument if any\n-                visit::walk_expr(self, expr);\n-            }\n-\n-            ExprKind::Let(ref pats, ref scrutinee) => {\n-                self.visit_expr(scrutinee);\n-                self.resolve_pats(pats, PatternSource::Let);\n-            }\n-\n-            ExprKind::If(ref cond, ref then, ref opt_else) => {\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.visit_expr(cond);\n-                self.visit_block(then);\n-                self.ribs[ValueNS].pop();\n-\n-                opt_else.as_ref().map(|expr| self.visit_expr(expr));\n-            }\n-\n-            ExprKind::Loop(ref block, label) => self.resolve_labeled_block(label, expr.id, &block),\n-\n-            ExprKind::While(ref subexpression, ref block, label) => {\n-                self.with_resolved_label(label, expr.id, |this| {\n-                    this.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                    this.visit_expr(subexpression);\n-                    this.visit_block(block);\n-                    this.ribs[ValueNS].pop();\n-                });\n-            }\n-\n-            ExprKind::ForLoop(ref pattern, ref subexpression, ref block, label) => {\n-                self.visit_expr(subexpression);\n-                self.ribs[ValueNS].push(Rib::new(NormalRibKind));\n-                self.resolve_pattern(pattern, PatternSource::For, &mut FxHashMap::default());\n-\n-                self.resolve_labeled_block(label, expr.id, block);\n-\n-                self.ribs[ValueNS].pop();\n-            }\n-\n-            ExprKind::Block(ref block, label) => self.resolve_labeled_block(label, block.id, block),\n-\n-            // Equivalent to `visit::walk_expr` + passing some context to children.\n-            ExprKind::Field(ref subexpression, _) => {\n-                self.resolve_expr(subexpression, Some(expr));\n-            }\n-            ExprKind::MethodCall(ref segment, ref arguments) => {\n-                let mut arguments = arguments.iter();\n-                self.resolve_expr(arguments.next().unwrap(), Some(expr));\n-                for argument in arguments {\n-                    self.resolve_expr(argument, None);\n-                }\n-                self.visit_path_segment(expr.span, segment);\n-            }\n-\n-            ExprKind::Call(ref callee, ref arguments) => {\n-                self.resolve_expr(callee, Some(expr));\n-                for argument in arguments {\n-                    self.resolve_expr(argument, None);\n-                }\n-            }\n-            ExprKind::Type(ref type_expr, _) => {\n-                self.current_type_ascription.push(type_expr.span);\n-                visit::walk_expr(self, expr);\n-                self.current_type_ascription.pop();\n-            }\n-            // `async |x| ...` gets desugared to `|x| future_from_generator(|| ...)`, so we need to\n-            // resolve the arguments within the proper scopes so that usages of them inside the\n-            // closure are detected as upvars rather than normal closure arg usages.\n-            ExprKind::Closure(\n-                _, IsAsync::Async { .. }, _,\n-                ref fn_decl, ref body, _span,\n-            ) => {\n-                let rib_kind = NormalRibKind;\n-                self.ribs[ValueNS].push(Rib::new(rib_kind));\n-                // Resolve arguments:\n-                let mut bindings_list = FxHashMap::default();\n-                for argument in &fn_decl.inputs {\n-                    self.resolve_pattern(&argument.pat, PatternSource::FnParam, &mut bindings_list);\n-                    self.visit_ty(&argument.ty);\n-                }\n-                // No need to resolve return type-- the outer closure return type is\n-                // FunctionRetTy::Default\n-\n-                // Now resolve the inner closure\n-                {\n-                    // No need to resolve arguments: the inner closure has none.\n-                    // Resolve the return type:\n-                    visit::walk_fn_ret_ty(self, &fn_decl.output);\n-                    // Resolve the body\n-                    self.visit_expr(body);\n-                }\n-                self.ribs[ValueNS].pop();\n-            }\n-            _ => {\n-                visit::walk_expr(self, expr);\n-            }\n-        }\n-    }\n-\n-    fn record_candidate_traits_for_expr_if_necessary(&mut self, expr: &Expr) {\n-        match expr.node {\n-            ExprKind::Field(_, ident) => {\n-                // FIXME(#6890): Even though you can't treat a method like a\n-                // field, we need to add any trait methods we find that match\n-                // the field name so that we can do some nice error reporting\n-                // later on in typeck.\n-                let traits = self.get_traits_containing_item(ident, ValueNS);\n-                self.trait_map.insert(expr.id, traits);\n-            }\n-            ExprKind::MethodCall(ref segment, ..) => {\n-                debug!(\"(recording candidate traits for expr) recording traits for {}\",\n-                       expr.id);\n-                let traits = self.get_traits_containing_item(segment.ident, ValueNS);\n-                self.trait_map.insert(expr.id, traits);\n-            }\n-            _ => {\n-                // Nothing to do.\n-            }\n-        }\n-    }\n-\n-    fn get_traits_containing_item(&mut self, mut ident: Ident, ns: Namespace)\n-                                  -> Vec<TraitCandidate> {\n-        debug!(\"(getting traits containing item) looking for '{}'\", ident.name);\n \n-        let mut found_traits = Vec::new();\n-        // Look for the current trait.\n-        if let Some((module, _)) = self.current_trait_ref {\n-            let parent_scope = &self.parent_scope();\n-            if self.resolve_ident_in_module(\n-                ModuleOrUniformRoot::Module(module),\n-                ident,\n-                ns,\n-                parent_scope,\n-                false,\n-                module.span,\n-            ).is_ok() {\n-                let def_id = module.def_id().unwrap();\n-                found_traits.push(TraitCandidate { def_id: def_id, import_ids: smallvec![] });\n-            }\n-        }\n-\n-        ident.span = ident.span.modern();\n-        let mut search_module = self.current_module;\n-        loop {\n-            self.get_traits_in_module_containing_item(ident, ns, search_module, &mut found_traits);\n-            search_module = unwrap_or!(\n-                self.hygienic_lexical_parent(search_module, &mut ident.span), break\n-            );\n-        }\n-\n-        if let Some(prelude) = self.prelude {\n-            if !search_module.no_implicit_prelude {\n-                self.get_traits_in_module_containing_item(ident, ns, prelude, &mut found_traits);\n-            }\n-        }\n-\n-        found_traits\n-    }\n-\n-    fn get_traits_in_module_containing_item(&mut self,\n-                                            ident: Ident,\n-                                            ns: Namespace,\n-                                            module: Module<'a>,\n-                                            found_traits: &mut Vec<TraitCandidate>) {\n-        assert!(ns == TypeNS || ns == ValueNS);\n-        let mut traits = module.traits.borrow_mut();\n-        if traits.is_none() {\n-            let mut collected_traits = Vec::new();\n-            module.for_each_child(|name, ns, binding| {\n-                if ns != TypeNS { return }\n-                match binding.res() {\n-                    Res::Def(DefKind::Trait, _) |\n-                    Res::Def(DefKind::TraitAlias, _) => collected_traits.push((name, binding)),\n-                    _ => (),\n-                }\n-            });\n-            *traits = Some(collected_traits.into_boxed_slice());\n-        }\n-\n-        for &(trait_name, binding) in traits.as_ref().unwrap().iter() {\n-            // Traits have pseudo-modules that can be used to search for the given ident.\n-            if let Some(module) = binding.module() {\n-                let mut ident = ident;\n-                if ident.span.glob_adjust(\n-                    module.expansion,\n-                    binding.span,\n-                ).is_none() {\n-                    continue\n-                }\n-                let parent_scope = &self.parent_scope();\n-                if self.resolve_ident_in_module_unadjusted(\n-                    ModuleOrUniformRoot::Module(module),\n-                    ident,\n-                    ns,\n-                    parent_scope,\n-                    false,\n-                    module.span,\n-                ).is_ok() {\n-                    let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                    let trait_def_id = module.def_id().unwrap();\n-                    found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-                }\n-            } else if let Res::Def(DefKind::TraitAlias, _) = binding.res() {\n-                // For now, just treat all trait aliases as possible candidates, since we don't\n-                // know if the ident is somewhere in the transitive bounds.\n-                let import_ids = self.find_transitive_imports(&binding.kind, trait_name);\n-                let trait_def_id = binding.res().def_id();\n-                found_traits.push(TraitCandidate { def_id: trait_def_id, import_ids });\n-            } else {\n-                bug!(\"candidate is not trait or trait alias?\")\n-            }\n-        }\n-    }\n-\n-    fn find_transitive_imports(&mut self, mut kind: &NameBindingKind<'_>,\n-                               trait_name: Ident) -> SmallVec<[NodeId; 1]> {\n-        let mut import_ids = smallvec![];\n-        while let NameBindingKind::Import { directive, binding, .. } = kind {\n-            self.maybe_unused_trait_imports.insert(directive.id);\n-            self.add_to_glob_map(&directive, trait_name);\n-            import_ids.push(directive.id);\n-            kind = &binding.kind;\n-        };\n-        import_ids\n-    }\n-}\n-\n-impl<'a> Resolver<'a> {\n     fn record_partial_res(&mut self, node_id: NodeId, resolution: PartialRes) {\n         debug!(\"(recording res) recording {:?} for {}\", resolution, node_id);\n         if let Some(prev_res) = self.partial_res_map.insert(node_id, resolution) {\n@@ -5190,14 +3244,74 @@ impl<'a> Resolver<'a> {\n             }\n         })\n     }\n-}\n \n-fn is_self_type(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == TypeNS && path.len() == 1 && path[0].ident.name == kw::SelfUpper\n-}\n+    /// Rustdoc uses this to resolve things in a recoverable way. `ResolutionError<'a>`\n+    /// isn't something that can be returned because it can't be made to live that long,\n+    /// and also it's a private type. Fortunately rustdoc doesn't need to know the error,\n+    /// just that an error occurred.\n+    pub fn resolve_str_path_error(&mut self, span: Span, path_str: &str, is_value: bool)\n+        -> Result<(ast::Path, Res), ()> {\n+        let path = if path_str.starts_with(\"::\") {\n+            ast::Path {\n+                span,\n+                segments: iter::once(Ident::with_empty_ctxt(kw::PathRoot))\n+                    .chain({\n+                        path_str.split(\"::\").skip(1).map(Ident::from_str)\n+                    })\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n+            }\n+        } else {\n+            ast::Path {\n+                span,\n+                segments: path_str\n+                    .split(\"::\")\n+                    .map(Ident::from_str)\n+                    .map(|i| self.new_ast_path_segment(i))\n+                    .collect(),\n+            }\n+        };\n+        let res = self.resolve_ast_path_inner(&path, is_value).map_err(|_| ())?;\n+        Ok((path, res))\n+    }\n \n-fn is_self_value(path: &[Segment], namespace: Namespace) -> bool {\n-    namespace == ValueNS && path.len() == 1 && path[0].ident.name == kw::SelfLower\n+    /// Like `resolve_ast_path`, but takes a callback in case there was an error.\n+    fn resolve_ast_path_inner(\n+        &mut self,\n+        path: &ast::Path,\n+        is_value: bool,\n+    ) -> Result<Res, (Span, ResolutionError<'a>)> {\n+        let namespace = if is_value { ValueNS } else { TypeNS };\n+        let span = path.span;\n+        let path = Segment::from_path(&path);\n+        // FIXME(Manishearth): intra-doc links won't get warned of epoch changes.\n+        let parent_scope = &self.dummy_parent_scope();\n+        match self.resolve_path(&path, Some(namespace), parent_scope, true, span, CrateLint::No) {\n+            PathResult::Module(ModuleOrUniformRoot::Module(module)) =>\n+                Ok(module.res().unwrap()),\n+            PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 =>\n+                Ok(path_res.base_res()),\n+            PathResult::NonModule(..) => {\n+                Err((span, ResolutionError::FailedToResolve {\n+                    label: String::from(\"type-relative paths are not supported in this context\"),\n+                    suggestion: None,\n+                }))\n+            }\n+            PathResult::Module(..) | PathResult::Indeterminate => unreachable!(),\n+            PathResult::Failed { span, label, suggestion, .. } => {\n+                Err((span, ResolutionError::FailedToResolve {\n+                    label,\n+                    suggestion,\n+                }))\n+            }\n+        }\n+    }\n+\n+    fn new_ast_path_segment(&self, ident: Ident) -> ast::PathSegment {\n+        let mut seg = ast::PathSegment::from_ident(ident);\n+        seg.id = self.session.next_node_id();\n+        seg\n+    }\n }\n \n fn names_to_string(idents: &[Ident]) -> String {"}]}