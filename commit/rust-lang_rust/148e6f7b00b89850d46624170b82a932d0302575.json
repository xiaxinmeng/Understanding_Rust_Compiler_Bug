{"sha": "148e6f7b00b89850d46624170b82a932d0302575", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0OGU2ZjdiMDBiODk4NTBkNDY2MjQxNzBiODJhOTMyZDAzMDI1NzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-17T14:29:18Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-04-18T13:28:47Z"}, "message": "Make log the log level configurable per module\n\nThis overloads the meaning of RUST_LOG to also allow\n'module.submodule' or 'module.somethingelse=2' forms. The first turn\non all logging for a module (loglevel 3), the second sets its loglevel\nto 2. Log levels are:\n\n 0: Show only errors\n 1: Errors and warnings\n 2: Errors, warnings, and notes\n 3: Everything, including debug logging\n\nRight now, since we only have one 'log' operation, everything happens\nat level 1 (warning), so the only meaningful thing that can be done\nwith the new RUST_LOG support is disable logging (=0) for some\nmodules.\n\nTODOS:\n * Language support for logging at a specific level\n * Also add a log level field to tasks, query the current task as well\n   as the current module before logging (log if one of them allows it)\n * Revise the C logging API to conform to this set-up (globals for\n   per-module log level, query the task level before logging, stop\n   using a global mask)\n\nImplementation notes:\n\nCrates now contain two extra data structures. A 'module map' that\ncontains names and pointers to the module-log-level globals for each\nmodule in the crate that logs, and a 'crate map' that points at the\ncrate's module map, as well as at the crate maps of all external\ncrates it depends on. These are walked by the runtime (in\nrust_crate.cpp) to set the currect log levels based on RUST_LOG.\n\nThese module log globals are allocated as-needed whenever a log\nexpression is encountered, and their location is hard-coded into the\nlogging code, which compares the current level to the log statement's\nlevel, and skips over all logging code when it is lower.", "tree": {"sha": "c0639f08db0f51742b368a492afc931cf18f7b3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c0639f08db0f51742b368a492afc931cf18f7b3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/148e6f7b00b89850d46624170b82a932d0302575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/148e6f7b00b89850d46624170b82a932d0302575", "html_url": "https://github.com/rust-lang/rust/commit/148e6f7b00b89850d46624170b82a932d0302575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/148e6f7b00b89850d46624170b82a932d0302575/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0bf75a203e6611f0b0293c3fc08a6f2ee3a5f1ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/0bf75a203e6611f0b0293c3fc08a6f2ee3a5f1ba", "html_url": "https://github.com/rust-lang/rust/commit/0bf75a203e6611f0b0293c3fc08a6f2ee3a5f1ba"}], "stats": {"total": 235, "additions": 206, "deletions": 29}, "files": [{"sha": "ac2ceff5190bb094956d31bacc9ec88b3b41f88c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 111, "deletions": 27, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/148e6f7b00b89850d46624170b82a932d0302575/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/148e6f7b00b89850d46624170b82a932d0302575/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=148e6f7b00b89850d46624170b82a932d0302575", "patch": "@@ -108,12 +108,14 @@ state type crate_ctxt = rec(session.session sess,\n                             hashmap[ast.def_id, ValueRef] consts,\n                             hashmap[ast.def_id,()] obj_methods,\n                             hashmap[@ty.t, @tydesc_info] tydescs,\n+                            hashmap[str, ValueRef] module_data,\n                             @glue_fns glues,\n                             namegen names,\n                             vec[str] path,\n                             std.sha1.sha1 sha);\n \n type local_ctxt = rec(vec[str] path,\n+                      vec[str] module_path,\n                       vec[ast.ty_param] obj_typarams,\n                       vec[ast.obj_field] obj_fields,\n                       @crate_ctxt ccx);\n@@ -426,7 +428,8 @@ fn T_crate(type_names tn) -> TypeRef {\n                           T_int(),      // int n_rust_syms\n                           T_int(),      // int n_c_syms\n                           T_int(),      // int n_libs\n-                          T_int()       // uintptr_t abi_tag\n+                          T_int(),      // uintptr_t abi_tag\n+                          T_int()       // void* crate_map\n                           ));\n     tn.associate(s, t);\n     ret t;\n@@ -909,6 +912,11 @@ fn C_struct(vec[ValueRef] elts) -> ValueRef {\n                              False);\n }\n \n+fn C_array(TypeRef ty, vec[ValueRef] elts) -> ValueRef {\n+    ret llvm.LLVMConstArray(ty, _vec.buf[ValueRef](elts),\n+                            _vec.len[ValueRef](elts));\n+}\n+\n fn decl_fn(ModuleRef llmod, str name, uint cc, TypeRef llty) -> ValueRef {\n     let ValueRef llfn =\n         llvm.LLVMAddFunction(llmod, _str.buf(name), llty);\n@@ -4925,8 +4933,28 @@ fn load_if_immediate(@block_ctxt cx, ValueRef v, @ty.t t) -> ValueRef {\n }\n \n fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n-\n-    auto sub = trans_expr(cx, e);\n+    auto lcx = cx.fcx.lcx;\n+    auto modname = _str.connect(lcx.module_path, \".\");\n+    auto global;\n+    if (lcx.ccx.module_data.contains_key(modname)) {\n+        global = lcx.ccx.module_data.get(modname);\n+    } else {\n+        global = llvm.LLVMAddGlobal(lcx.ccx.llmod, T_int(),\n+                                    _str.buf(\"_rust_mod_log_\" + modname));\n+        llvm.LLVMSetGlobalConstant(global, False);\n+        llvm.LLVMSetInitializer(global, C_null(T_int()));\n+        llvm.LLVMSetLinkage(global, lib.llvm.LLVMInternalLinkage\n+                            as llvm.Linkage);\n+        lcx.ccx.module_data.insert(modname, global);\n+    }\n+\n+    auto log_cx = new_sub_block_ctxt(cx, \"log\");\n+    auto after_cx = new_sub_block_ctxt(cx, \"after\");\n+    auto load = cx.build.Load(global);\n+    auto test = cx.build.ICmp(lib.llvm.LLVMIntSGE, load, C_int(1));\n+    cx.build.CondBr(test, log_cx.llbb, after_cx.llbb);\n+\n+    auto sub = trans_expr(log_cx, e);\n     auto e_ty = ty.expr_ty(e);\n \n     if (ty.type_is_fp(e_ty)) {\n@@ -4945,33 +4973,34 @@ fn trans_log(@block_ctxt cx, @ast.expr e) -> result {\n             }\n         }\n         if (is32bit) {\n-            ret trans_upcall(sub.bcx,\n-                             \"upcall_log_float\",\n-                             vec(sub.val));\n+            trans_upcall(sub.bcx,\n+                         \"upcall_log_float\",\n+                         vec(sub.val)).bcx.build.Br(after_cx.llbb);\n         } else {\n             auto tmp = alloca(sub.bcx, tr);\n             sub.bcx.build.Store(sub.val, tmp);\n             auto v = vp2i(sub.bcx, tmp);\n-            ret trans_upcall(sub.bcx,\n-                             \"upcall_log_double\",\n-                             vec(v));\n+            trans_upcall(sub.bcx,\n+                         \"upcall_log_double\",\n+                         vec(v)).bcx.build.Br(after_cx.llbb);\n         }\n-    }\n-\n-    alt (e_ty.struct) {\n-        case (ty.ty_str) {\n-            auto v = vp2i(sub.bcx, sub.val);\n-            ret trans_upcall(sub.bcx,\n+    } else {\n+        alt (e_ty.struct) {\n+            case (ty.ty_str) {\n+                auto v = vp2i(sub.bcx, sub.val);\n+                trans_upcall(sub.bcx,\n                              \"upcall_log_str\",\n-                             vec(v));\n-        }\n-        case (_) {\n-            ret trans_upcall(sub.bcx,\n+                             vec(v)).bcx.build.Br(after_cx.llbb);\n+            }\n+            case (_) {\n+                trans_upcall(sub.bcx,\n                              \"upcall_log_int\",\n-                             vec(sub.val));\n+                             vec(sub.val)).bcx.build.Br(after_cx.llbb);\n+            }\n         }\n     }\n-    fail;\n+\n+    ret res(after_cx, C_nil());\n }\n \n fn trans_check_expr(@block_ctxt cx, @ast.expr e) -> result {\n@@ -6114,7 +6143,9 @@ fn trans_item(@local_ctxt cx, &ast.item item) {\n             trans_obj(sub_cx, ob, oid.ctor, tps, ann);\n         }\n         case (ast.item_mod(?name, ?m, _)) {\n-            auto sub_cx = extend_path(cx, name);\n+            auto sub_cx = @rec(path = cx.path + vec(name),\n+                               module_path = cx.module_path + vec(name)\n+                               with *cx);\n             trans_mod(sub_cx, m);\n         }\n         case (ast.item_tag(?name, ?variants, ?tps, ?tag_id, _)) {\n@@ -6593,7 +6624,8 @@ fn create_typedefs(@crate_ctxt cx) {\n     llvm.LLVMAddTypeName(cx.llmod, _str.buf(\"tydesc\"), T_tydesc(cx.tn));\n }\n \n-fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n+fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues,\n+                         ValueRef crate_map) {\n \n     let ValueRef crate_addr = p2i(crate_ptr);\n \n@@ -6608,7 +6640,7 @@ fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n \n     let ValueRef crate_val =\n         C_struct(vec(C_null(T_int()),     // ptrdiff_t image_base_off\n-                     p2i(crate_ptr),   // uintptr_t self_addr\n+                     p2i(crate_ptr),      // uintptr_t self_addr\n                      C_null(T_int()),     // ptrdiff_t debug_abbrev_off\n                      C_null(T_int()),     // size_t debug_abbrev_sz\n                      C_null(T_int()),     // ptrdiff_t debug_info_off\n@@ -6621,7 +6653,8 @@ fn create_crate_constant(ValueRef crate_ptr, @glue_fns glues) {\n                      C_null(T_int()),     // int n_rust_syms\n                      C_null(T_int()),     // int n_c_syms\n                      C_null(T_int()),     // int n_libs\n-                     C_int(abi.abi_x86_rustc_fastcall) // uintptr_t abi_tag\n+                     C_int(abi.abi_x86_rustc_fastcall), // uintptr_t abi_tag\n+                     p2i(crate_map)       // void* crate_map\n                      ));\n \n     llvm.LLVMSetInitializer(crate_ptr, crate_val);\n@@ -7159,6 +7192,54 @@ fn make_common_glue(str output, bool optimize,\n     run_passes(llmod, optimize, output, ot);\n }\n \n+fn create_module_map(@crate_ctxt ccx) -> ValueRef {\n+    auto elttype = T_struct(vec(T_int(), T_int()));\n+    auto maptype = T_array(elttype, ccx.module_data.size() + 1u);\n+    auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype,\n+                                  _str.buf(\"_rust_mod_map\"));\n+    llvm.LLVMSetLinkage(map, lib.llvm.LLVMInternalLinkage as llvm.Linkage);\n+    let vec[ValueRef] elts = vec();\n+    for each (@tup(str, ValueRef) item in ccx.module_data.items()) {\n+        auto elt = C_struct(vec(p2i(C_cstr(ccx, item._0)), p2i(item._1)));\n+        _vec.push[ValueRef](elts, elt);\n+    }\n+    auto term = C_struct(vec(C_int(0), C_int(0)));\n+    _vec.push[ValueRef](elts, term);\n+    llvm.LLVMSetInitializer(map, C_array(elttype, elts));\n+    ret map;\n+}\n+\n+fn crate_name(@crate_ctxt ccx, str deflt) -> str {\n+    for (@ast.meta_item item in ccx.sess.get_metadata()) {\n+        if (_str.eq(item.node.name, \"name\")) {\n+            ret item.node.value;\n+        }\n+    }\n+    ret deflt;\n+}\n+\n+// FIXME use hashed metadata instead of crate names once we have that\n+fn create_crate_map(@crate_ctxt ccx) -> ValueRef {\n+    let vec[ValueRef] subcrates = vec();\n+    auto i = 1;\n+    while (ccx.sess.has_external_crate(i)) {\n+        auto name = ccx.sess.get_external_crate(i).name;\n+        auto cr = llvm.LLVMAddGlobal(ccx.llmod, T_int(),\n+                                     _str.buf(\"_rust_crate_map_\" + name));\n+        _vec.push[ValueRef](subcrates, p2i(cr));\n+        i += 1;\n+    }\n+    _vec.push[ValueRef](subcrates, C_int(0));\n+    auto sym_name = \"_rust_crate_map_\" + crate_name(ccx, \"__none__\");\n+    auto arrtype = T_array(T_int(), _vec.len[ValueRef](subcrates));\n+    auto maptype = T_struct(vec(T_int(), arrtype));\n+    auto map = llvm.LLVMAddGlobal(ccx.llmod, maptype, _str.buf(sym_name));\n+    llvm.LLVMSetLinkage(map, lib.llvm.LLVMExternalLinkage as llvm.Linkage);\n+    llvm.LLVMSetInitializer(map, C_struct(vec(p2i(create_module_map(ccx)),\n+                                              C_array(T_int(), subcrates))));\n+    ret map;\n+}\n+\n fn trans_crate(session.session sess, @ast.crate crate,\n                &ty.type_cache type_cache, str output, bool shared,\n                bool optimize, output_type ot) {\n@@ -7203,25 +7284,28 @@ fn trans_crate(session.session sess, @ast.crate crate,\n                     consts = new_def_hash[ValueRef](),\n                     obj_methods = new_def_hash[()](),\n                     tydescs = tydescs,\n+                    module_data = new_str_hash[ValueRef](),\n                     glues = glues,\n                     names = namegen(0),\n                     path = pth,\n                     sha = std.sha1.mk_sha1());\n     auto cx = @rec(path=pth,\n+                   module_path=vec(crate_name(ccx, \"main\")),\n                    obj_typarams = obj_typarams,\n                    obj_fields = obj_fields,\n                    ccx = ccx);\n \n-    create_typedefs(cx.ccx);\n+    create_typedefs(ccx);\n \n     collect_items(cx, crate);\n     collect_tag_ctors(cx, crate);\n     trans_constants(cx, crate);\n     trans_mod(cx, crate.node.module);\n     trans_vec_append_glue(cx);\n+    auto crate_map = create_crate_map(ccx);\n     if (!shared) {\n         trans_main_fn(cx, crate_ptr);\n-        create_crate_constant(crate_ptr, ccx.glues);\n+        create_crate_constant(crate_ptr, ccx.glues, crate_map);\n     }\n \n     // Translate the metadata."}, {"sha": "013705f26c268d9fa4345360f6e71d1ab185d7cf", "filename": "src/rt/rust.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust.cpp?ref=148e6f7b00b89850d46624170b82a932d0302575", "patch": "@@ -80,6 +80,7 @@ extern \"C\" CDECL int\n rust_start(uintptr_t main_fn, rust_crate const *crate, int argc,\n            char **argv) {\n \n+    crate->update_log_settings(getenv(\"RUST_LOG\"));\n     rust_srv *srv = new rust_srv();\n     rust_kernel *kernel = new rust_kernel(srv);\n     kernel->start();\n@@ -102,6 +103,7 @@ rust_start(uintptr_t main_fn, rust_crate const *crate, int argc,\n     dom->root_task->start(crate->get_exit_task_glue(),\n                           crate->abi_tag, main_fn,\n                           (uintptr_t)&main_args, sizeof(main_args));\n+\n     int ret = dom->start_main_loop();\n     delete args;\n     kernel->destroy_domain(dom);"}, {"sha": "e7ee0350468b343b7032323acdf7354f47d377cd", "filename": "src/rt/rust_crate.cpp", "status": "modified", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_crate.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_crate.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_crate.cpp?ref=148e6f7b00b89850d46624170b82a932d0302575", "patch": "@@ -65,6 +65,92 @@ rust_crate::get_debug_abbrev(rust_dom *dom) const {\n         return mem_area(dom, 0, 0);\n }\n \n+struct mod_entry {\n+    const char* name;\n+    int* state;\n+};\n+\n+struct cratemap {\n+    mod_entry* entries;\n+    cratemap* children[1];\n+};\n+\n+struct log_directive {\n+    char* name;\n+    size_t level;\n+};\n+\n+const size_t max_log_directives = 255;\n+\n+size_t parse_logging_spec(char* spec, log_directive* dirs) {\n+    size_t dir = 0;\n+    while (dir < max_log_directives && *spec) {\n+        char* start = spec;\n+        char cur;\n+        while (true) {\n+            cur = *spec;\n+            if (cur == ',' || cur == '=' || cur == '\\0') {\n+                if (start == spec) {spec++; break;}\n+                *spec = '\\0';\n+                spec++;\n+                size_t level = 3;\n+                if (cur == '=') {\n+                    level = *spec - '0';\n+                    if (level > 3) level = 1;\n+                    if (*spec) ++spec;\n+                }\n+                dirs[dir].name = start;\n+                dirs[dir++].level = level;\n+                break;\n+            }\n+            spec++;\n+        }\n+    }\n+    return dir;\n+}\n+\n+void update_crate_map(cratemap* map, log_directive* dirs, size_t n_dirs) {\n+    // First update log levels for this crate\n+    for (mod_entry* cur = map->entries; cur->name; cur++) {\n+        size_t level = 1, longest_match = 0;\n+        for (size_t d = 0; d < n_dirs; d++) {\n+            if (strstr(cur->name, dirs[d].name) == cur->name &&\n+                strlen(dirs[d].name) > longest_match) {\n+                longest_match = strlen(dirs[d].name);\n+                level = dirs[d].level;\n+            }\n+        }\n+        *cur->state = level;\n+    }\n+\n+    // Then recurse on linked crates\n+    for (size_t i = 0; map->children[i]; i++) {\n+        update_crate_map(map->children[i], dirs, n_dirs);\n+    }\n+}\n+\n+void rust_crate::update_log_settings(char* settings) const {\n+    // Only try this if the crate was generated by Rustc, not rustboot\n+    if (image_base_off) return;\n+\n+    // This is a rather ugly parser for strings in the form\n+    // \"crate1,crate2.mod3,crate3.x=2\". Log levels range 0=err, 1=warn,\n+    // 2=info, 3=debug. Default is 1. Words without an '=X' part set the log\n+    // level for that module (and submodules) to 3.\n+    char* buffer = NULL;\n+    log_directive dirs[256];\n+    size_t dir = 0;\n+    if (settings) {\n+        buffer = (char*)malloc(strlen(settings));\n+        strcpy(buffer, settings);\n+        dir = parse_logging_spec(buffer, &dirs[0]);\n+    }\n+\n+    update_crate_map((cratemap*)crate_map, &dirs[0], dir);\n+\n+    free(buffer);\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "695fc21d98e76e7ea8e75fb149cc7d4084449623", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=148e6f7b00b89850d46624170b82a932d0302575", "patch": "@@ -248,6 +248,9 @@ class rust_crate {\n     size_t n_libs;\n \n     uintptr_t abi_tag;\n+    // FIXME: not generated by rustboot, should only be accessed in crates\n+    // generated by rustc.\n+    void* crate_map;\n \n     // Crates are immutable, constructed by the compiler.\n \n@@ -259,6 +262,8 @@ class rust_crate {\n     uintptr_t get_gc_glue() const;\n     uintptr_t get_exit_task_glue() const;\n \n+    void update_log_settings(char* settings) const;\n+\n     struct mem_area\n     {\n       rust_dom *dom;"}, {"sha": "076c4b0ae7a0edba2ebc783d3c9fea0ae3a70431", "filename": "src/rt/rust_log.cpp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_log.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/148e6f7b00b89850d46624170b82a932d0302575/src%2Frt%2Frust_log.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_log.cpp?ref=148e6f7b00b89850d46624170b82a932d0302575", "patch": "@@ -9,6 +9,7 @@\n #include <stdlib.h>\n #include <string.h>\n \n+// FIXME somehow unify this with the parsing happening in rust_crate.cpp\n static uint32_t\n read_type_bit_mask() {\n     uint32_t bits = rust_log::ULOG | rust_log::ERR;\n@@ -18,14 +19,13 @@ read_type_bit_mask() {\n         str[0] = ',';\n         strcpy(str + 1, env_str);\n \n-        bits = 0;\n+        bits = rust_log::ULOG;\n         bits |= strstr(str, \",err\") ? rust_log::ERR : 0;\n         bits |= strstr(str, \",mem\") ? rust_log::MEM : 0;\n         bits |= strstr(str, \",comm\") ? rust_log::COMM : 0;\n         bits |= strstr(str, \",task\") ? rust_log::TASK : 0;\n         bits |= strstr(str, \",up\") ? rust_log::UPCALL : 0;\n         bits |= strstr(str, \",dom\") ? rust_log::DOM : 0;\n-        bits |= strstr(str, \",ulog\") ? rust_log::ULOG : 0;\n         bits |= strstr(str, \",trace\") ? rust_log::TRACE : 0;\n         bits |= strstr(str, \",dwarf\") ? rust_log::DWARF : 0;\n         bits |= strstr(str, \",cache\") ? rust_log::CACHE : 0;"}]}