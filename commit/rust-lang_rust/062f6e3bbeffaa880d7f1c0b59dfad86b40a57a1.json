{"sha": "062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2MmY2ZTNiYmVmZmFhODgwZDdmMWMwYjU5ZGZhZDg2YjQwYTU3YTE=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-24T16:03:05Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-24T16:14:33Z"}, "message": "Generalise syntax rewriting infrastructure to allow removal of nodes", "tree": {"sha": "c4839930ffb9eca35a5be17c107058c4051a6d02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c4839930ffb9eca35a5be17c107058c4051a6d02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "html_url": "https://github.com/rust-lang/rust/commit/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bd119a4c1a8fbd3000095324e84635767949afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bd119a4c1a8fbd3000095324e84635767949afb", "html_url": "https://github.com/rust-lang/rust/commit/3bd119a4c1a8fbd3000095324e84635767949afb"}], "stats": {"total": 373, "additions": 252, "deletions": 121}, "files": [{"sha": "c3e65329999c1bfe186128beed01734a1aaba1ca", "filename": "crates/ra_assists/src/assist_ctx.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassist_ctx.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -11,6 +11,7 @@ use ra_syntax::{\n use ra_text_edit::TextEditBuilder;\n \n use crate::{AssistAction, AssistId, AssistLabel, GroupLabel, ResolvedAssist};\n+use algo::SyntaxRewriter;\n \n #[derive(Clone, Debug)]\n pub(crate) struct Assist(pub(crate) Vec<AssistInfo>);\n@@ -234,6 +235,11 @@ impl ActionBuilder {\n     pub(crate) fn replace_ast<N: AstNode>(&mut self, old: N, new: N) {\n         algo::diff(old.syntax(), new.syntax()).into_text_edit(&mut self.edit)\n     }\n+    pub(crate) fn rewrite(&mut self, rewriter: SyntaxRewriter) {\n+        let node = rewriter.rewrite_root().unwrap();\n+        let new = rewriter.rewrite(&node);\n+        algo::diff(&node, &new).into_text_edit(&mut self.edit)\n+    }\n \n     fn build(self) -> AssistAction {\n         AssistAction {"}, {"sha": "52b4c82db6632bb6e55b10fb124c55c29ff3c902", "filename": "crates/ra_assists/src/ast_transform.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fast_transform.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fast_transform.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -3,7 +3,10 @@ use rustc_hash::FxHashMap;\n \n use hir::{PathResolution, SemanticsScope};\n use ra_ide_db::RootDatabase;\n-use ra_syntax::ast::{self, AstNode};\n+use ra_syntax::{\n+    algo::SyntaxRewriter,\n+    ast::{self, AstNode},\n+};\n \n pub trait AstTransform<'a> {\n     fn get_substitution(&self, node: &ra_syntax::SyntaxNode) -> Option<ra_syntax::SyntaxNode>;\n@@ -153,15 +156,14 @@ impl<'a> QualifyPaths<'a> {\n }\n \n pub fn apply<'a, N: AstNode>(transformer: &dyn AstTransform<'a>, node: N) -> N {\n-    let syntax = node.syntax();\n-    let result = ra_syntax::algo::replace_descendants(syntax, |element| match element {\n+    SyntaxRewriter::from_fn(|element| match element {\n         ra_syntax::SyntaxElement::Node(n) => {\n             let replacement = transformer.get_substitution(&n)?;\n             Some(replacement.into())\n         }\n         _ => None,\n-    });\n-    N::cast(result).unwrap()\n+    })\n+    .rewrite_ast(&node)\n }\n \n impl<'a> AstTransform<'a> for QualifyPaths<'a> {"}, {"sha": "9c57d1e309095b853bd05775761add9525fc61c0", "filename": "crates/ra_assists/src/handlers/merge_imports.rs", "status": "modified", "additions": 52, "deletions": 33, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fmerge_imports.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -1,9 +1,9 @@\n use std::iter::successors;\n \n use ra_syntax::{\n-    algo::neighbor,\n+    algo::{neighbor, SyntaxRewriter},\n     ast::{self, edit::AstNodeEdit, make},\n-    AstNode, AstToken, Direction, InsertPosition, SyntaxElement, TextRange, T,\n+    AstNode, Direction, InsertPosition, SyntaxElement, T,\n };\n \n use crate::{Assist, AssistCtx, AssistId};\n@@ -22,52 +22,39 @@ use crate::{Assist, AssistCtx, AssistId};\n // ```\n pub(crate) fn merge_imports(ctx: AssistCtx) -> Option<Assist> {\n     let tree: ast::UseTree = ctx.find_node_at_offset()?;\n-    let (new_tree, to_delete) = if let Some(use_item) =\n-        tree.syntax().parent().and_then(ast::UseItem::cast)\n-    {\n+    let mut rewriter = SyntaxRewriter::default();\n+    let mut offset = ctx.frange.range.start();\n+\n+    if let Some(use_item) = tree.syntax().parent().and_then(ast::UseItem::cast) {\n         let (merged, to_delete) = next_prev()\n             .filter_map(|dir| neighbor(&use_item, dir))\n             .filter_map(|it| Some((it.clone(), it.use_tree()?)))\n             .find_map(|(use_item, use_tree)| {\n                 Some((try_merge_trees(&tree, &use_tree)?, use_item.clone()))\n             })?;\n \n-        let mut range = to_delete.syntax().text_range();\n-        let next_ws = to_delete\n-            .syntax()\n-            .next_sibling_or_token()\n-            .and_then(|it| it.into_token())\n-            .and_then(ast::Whitespace::cast);\n-        if let Some(ws) = next_ws {\n-            range = range.extend_to(&ws.syntax().text_range())\n+        rewriter.replace_ast(&tree, &merged);\n+        rewriter += to_delete.remove();\n+\n+        if to_delete.syntax().text_range().end() < offset {\n+            offset -= to_delete.syntax().text_range().len();\n         }\n-        (merged, range)\n     } else {\n         let (merged, to_delete) = next_prev()\n             .filter_map(|dir| neighbor(&tree, dir))\n             .find_map(|use_tree| Some((try_merge_trees(&tree, &use_tree)?, use_tree.clone())))?;\n \n-        let mut range = to_delete.syntax().text_range();\n-        if let Some((dir, nb)) = next_prev().find_map(|dir| Some((dir, neighbor(&to_delete, dir)?)))\n-        {\n-            let nb_range = nb.syntax().text_range();\n-            if dir == Direction::Prev {\n-                range = TextRange::from_to(nb_range.end(), range.end());\n-            } else {\n-                range = TextRange::from_to(range.start(), nb_range.start());\n-            }\n+        rewriter.replace_ast(&tree, &merged);\n+        rewriter += to_delete.remove();\n+\n+        if to_delete.syntax().text_range().end() < offset {\n+            offset -= to_delete.syntax().text_range().len();\n         }\n-        (merged, range)\n     };\n \n-    let mut offset = ctx.frange.range.start();\n     ctx.add_assist(AssistId(\"merge_imports\"), \"Merge imports\", |edit| {\n-        edit.replace_ast(tree, new_tree);\n-        edit.delete(to_delete);\n-\n-        if to_delete.end() <= offset {\n-            offset -= to_delete.len();\n-        }\n+        edit.rewrite(rewriter);\n+        // FIXME: we only need because our diff is imprecise\n         edit.set_cursor(offset);\n     })\n }\n@@ -156,7 +143,7 @@ use std::fmt::Debug;\n use std::fmt<|>::Display;\n \",\n             r\"\n-use std::fmt<|>::{Display, Debug};\n+use std::fmt:<|>:{Display, Debug};\n \",\n         );\n     }\n@@ -178,7 +165,7 @@ use std::{fmt<|>::{Debug, Display}};\n use std::{fmt::Debug, fmt<|>::Display};\n \",\n             r\"\n-use std::{fmt<|>::{Display, Debug}};\n+use std::{fmt::<|>{Display, Debug}};\n \",\n         );\n     }\n@@ -197,6 +184,38 @@ use foo::baz;\n use foo<|>::{bar, baz};\n \n /// Doc comment\n+\",\n+        );\n+    }\n+\n+    #[test]\n+    fn works_with_trailing_comma() {\n+        check_assist(\n+            merge_imports,\n+            r\"\n+use {\n+    foo<|>::bar,\n+    foo::baz,\n+};\n+\",\n+            r\"\n+use {\n+    foo<|>::{bar, baz},\n+};\n+\",\n+        );\n+        check_assist(\n+            merge_imports,\n+            r\"\n+use {\n+    foo::baz,\n+    foo<|>::bar,\n+};\n+\",\n+            r\"\n+use {\n+    foo::{bar<|>, baz},\n+};\n \",\n         );\n     }"}, {"sha": "687d402946c79ec120f8fbcae15b7866c3e777b7", "filename": "crates/ra_hir_expand/src/eager.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_hir_expand%2Fsrc%2Feager.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Feager.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -26,8 +26,8 @@ use crate::{\n };\n \n use ra_parser::FragmentKind;\n-use ra_syntax::{algo::replace_descendants, SyntaxElement, SyntaxNode};\n-use std::{collections::HashMap, sync::Arc};\n+use ra_syntax::{algo::SyntaxRewriter, SyntaxNode};\n+use std::sync::Arc;\n \n pub fn expand_eager_macro(\n     db: &dyn AstDatabase,\n@@ -95,10 +95,10 @@ fn eager_macro_recur(\n     curr: InFile<SyntaxNode>,\n     macro_resolver: &dyn Fn(ast::Path) -> Option<MacroDefId>,\n ) -> Option<SyntaxNode> {\n-    let mut original = curr.value.clone();\n+    let original = curr.value.clone();\n \n     let children = curr.value.descendants().filter_map(ast::MacroCall::cast);\n-    let mut replaces: HashMap<SyntaxElement, SyntaxElement> = HashMap::default();\n+    let mut rewriter = SyntaxRewriter::default();\n \n     // Collect replacement\n     for child in children {\n@@ -119,12 +119,9 @@ fn eager_macro_recur(\n             }\n         };\n \n-        replaces.insert(child.syntax().clone().into(), insert.into());\n+        rewriter.replace(child.syntax(), &insert);\n     }\n \n-    if !replaces.is_empty() {\n-        original = replace_descendants(&original, |n| replaces.get(n).cloned());\n-    }\n-\n-    Some(original)\n+    let res = rewriter.rewrite(&original);\n+    Some(res)\n }"}, {"sha": "f536ba3e78656109450408623dab296450eb5454", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -3,10 +3,9 @@\n use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n-    algo::{find_node_at_offset, replace_descendants},\n-    ast, AstNode, NodeOrToken, SyntaxElement, SyntaxKind, SyntaxNode, WalkEvent, T,\n+    algo::{find_node_at_offset, SyntaxRewriter},\n+    ast, AstNode, NodeOrToken, SyntaxKind, SyntaxNode, WalkEvent, T,\n };\n-use rustc_hash::FxHashMap;\n \n use crate::FilePosition;\n \n@@ -37,7 +36,7 @@ fn expand_macro_recur(\n     let mut expanded = sema.expand(macro_call)?;\n \n     let children = expanded.descendants().filter_map(ast::MacroCall::cast);\n-    let mut replaces: FxHashMap<SyntaxElement, SyntaxElement> = FxHashMap::default();\n+    let mut rewriter = SyntaxRewriter::default();\n \n     for child in children.into_iter() {\n         if let Some(new_node) = expand_macro_recur(sema, &child) {\n@@ -47,12 +46,13 @@ fn expand_macro_recur(\n             if expanded == *child.syntax() {\n                 expanded = new_node;\n             } else {\n-                replaces.insert(child.syntax().clone().into(), new_node.into());\n+                rewriter.replace(child.syntax(), &new_node)\n             }\n         }\n     }\n \n-    Some(replace_descendants(&expanded, |n| replaces.get(n).cloned()))\n+    let res = rewriter.rewrite(&expanded);\n+    Some(res)\n }\n \n // FIXME: It would also be cool to share logic here and in the mbe tests,"}, {"sha": "4d463a3ef06903b489e740c25bb4bd989d54bff4", "filename": "crates/ra_syntax/src/algo.rs", "status": "modified", "additions": 109, "deletions": 29, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_syntax%2Fsrc%2Falgo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -1,6 +1,9 @@\n //! FIXME: write short doc here\n \n-use std::ops::RangeInclusive;\n+use std::{\n+    fmt,\n+    ops::{self, RangeInclusive},\n+};\n \n use itertools::Itertools;\n use ra_text_edit::TextEditBuilder;\n@@ -222,44 +225,121 @@ fn _replace_children(\n     with_children(parent, new_children)\n }\n \n-/// Replaces descendants in the node, according to the mapping.\n-///\n-/// This is a type-unsafe low-level editing API, if you need to use it, prefer\n-/// to create a type-safe abstraction on top of it instead.\n-pub fn replace_descendants(\n-    parent: &SyntaxNode,\n-    map: impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n-) -> SyntaxNode {\n-    _replace_descendants(parent, &map)\n+#[derive(Default)]\n+pub struct SyntaxRewriter<'a> {\n+    f: Option<Box<dyn Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a>>,\n+    //FIXME: add debug_assertions that all elements are in fact from the same file.\n+    replacements: FxHashMap<SyntaxElement, Replacement>,\n }\n \n-fn _replace_descendants(\n-    parent: &SyntaxNode,\n-    map: &dyn Fn(&SyntaxElement) -> Option<SyntaxElement>,\n-) -> SyntaxNode {\n-    //  FIXME: this could be made much faster.\n-    let new_children = parent.children_with_tokens().map(|it| go(map, it)).collect::<Vec<_>>();\n-    return with_children(parent, new_children);\n+impl fmt::Debug for SyntaxRewriter<'_> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.debug_struct(\"SyntaxRewriter\").field(\"replacements\", &self.replacements).finish()\n+    }\n+}\n \n-    fn go(\n-        map: &dyn Fn(&SyntaxElement) -> Option<SyntaxElement>,\n-        element: SyntaxElement,\n-    ) -> NodeOrToken<rowan::GreenNode, rowan::GreenToken> {\n-        if let Some(replacement) = map(&element) {\n+impl<'a> SyntaxRewriter<'a> {\n+    pub fn from_fn(f: impl Fn(&SyntaxElement) -> Option<SyntaxElement> + 'a) -> SyntaxRewriter<'a> {\n+        SyntaxRewriter { f: Some(Box::new(f)), replacements: FxHashMap::default() }\n+    }\n+    pub fn delete<T: Clone + Into<SyntaxElement>>(&mut self, what: &T) {\n+        let what = what.clone().into();\n+        let replacement = Replacement::Delete;\n+        self.replacements.insert(what, replacement);\n+    }\n+    pub fn replace<T: Clone + Into<SyntaxElement>>(&mut self, what: &T, with: &T) {\n+        let what = what.clone().into();\n+        let replacement = Replacement::Single(with.clone().into());\n+        self.replacements.insert(what, replacement);\n+    }\n+    pub fn replace_ast<T: AstNode>(&mut self, what: &T, with: &T) {\n+        self.replace(what.syntax(), with.syntax())\n+    }\n+\n+    pub fn rewrite(&self, node: &SyntaxNode) -> SyntaxNode {\n+        if self.f.is_none() && self.replacements.is_empty() {\n+            return node.clone();\n+        }\n+        self.rewrite_children(node)\n+    }\n+\n+    pub fn rewrite_ast<N: AstNode>(self, node: &N) -> N {\n+        N::cast(self.rewrite(node.syntax())).unwrap()\n+    }\n+\n+    pub fn rewrite_root(&self) -> Option<SyntaxNode> {\n+        assert!(self.f.is_none());\n+        self.replacements\n+            .keys()\n+            .map(|element| match element {\n+                SyntaxElement::Node(it) => it.clone(),\n+                SyntaxElement::Token(it) => it.parent(),\n+            })\n+            .fold1(|a, b| least_common_ancestor(&a, &b).unwrap())\n+    }\n+\n+    fn replacement(&self, element: &SyntaxElement) -> Option<Replacement> {\n+        if let Some(f) = &self.f {\n+            assert!(self.replacements.is_empty());\n+            return f(element).map(Replacement::Single);\n+        }\n+        self.replacements.get(element).cloned()\n+    }\n+\n+    fn rewrite_children(&self, node: &SyntaxNode) -> SyntaxNode {\n+        //  FIXME: this could be made much faster.\n+        let new_children =\n+            node.children_with_tokens().flat_map(|it| self.rewrite_self(&it)).collect::<Vec<_>>();\n+        with_children(node, new_children)\n+    }\n+\n+    fn rewrite_self(\n+        &self,\n+        element: &SyntaxElement,\n+    ) -> Option<NodeOrToken<rowan::GreenNode, rowan::GreenToken>> {\n+        if let Some(replacement) = self.replacement(&element) {\n             return match replacement {\n-                NodeOrToken::Node(it) => NodeOrToken::Node(it.green().clone()),\n-                NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n+                Replacement::Single(NodeOrToken::Node(it)) => {\n+                    Some(NodeOrToken::Node(it.green().clone()))\n+                }\n+                Replacement::Single(NodeOrToken::Token(it)) => {\n+                    Some(NodeOrToken::Token(it.green().clone()))\n+                }\n+                Replacement::Delete => None,\n             };\n         }\n-        match element {\n+        let res = match element {\n             NodeOrToken::Token(it) => NodeOrToken::Token(it.green().clone()),\n-            NodeOrToken::Node(it) => {\n-                NodeOrToken::Node(_replace_descendants(&it, map).green().clone())\n-            }\n-        }\n+            NodeOrToken::Node(it) => NodeOrToken::Node(self.rewrite_children(it).green().clone()),\n+        };\n+        Some(res)\n+    }\n+}\n+\n+impl<'a> ops::AddAssign for SyntaxRewriter<'_> {\n+    fn add_assign(&mut self, rhs: SyntaxRewriter) {\n+        assert!(rhs.f.is_none());\n+        self.replacements.extend(rhs.replacements)\n     }\n }\n \n+#[derive(Clone, Debug)]\n+enum Replacement {\n+    Delete,\n+    Single(SyntaxElement),\n+}\n+\n+/// Replaces descendants in the node, according to the mapping.\n+///\n+/// This is a type-unsafe low-level editing API, if you need to use it, prefer\n+/// to create a type-safe abstraction on top of it instead.\n+pub fn _replace_descendants(\n+    parent: &SyntaxNode,\n+    map: impl Fn(&SyntaxElement) -> Option<SyntaxElement>,\n+) -> SyntaxNode {\n+    SyntaxRewriter::from_fn(map).rewrite(parent)\n+}\n+\n fn with_children(\n     parent: &SyntaxNode,\n     new_children: Vec<NodeOrToken<rowan::GreenNode, rowan::GreenToken>>,"}, {"sha": "df4ffefbf27e547546be4037eae0b76297b9647a", "filename": "crates/ra_syntax/src/ast/edit.rs", "status": "modified", "additions": 65, "deletions": 38, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fedit.rs?ref=062f6e3bbeffaa880d7f1c0b59dfad86b40a57a1", "patch": "@@ -4,7 +4,6 @@\n use std::{iter, ops::RangeInclusive};\n \n use arrayvec::ArrayVec;\n-use rustc_hash::FxHashMap;\n \n use crate::{\n     algo,\n@@ -17,6 +16,7 @@ use crate::{\n     SyntaxKind::{ATTR, COMMENT, WHITESPACE},\n     SyntaxNode, SyntaxToken, T,\n };\n+use algo::{neighbor, SyntaxRewriter};\n \n impl ast::BinExpr {\n     #[must_use]\n@@ -255,6 +255,28 @@ impl ast::UseItem {\n         }\n         self.clone()\n     }\n+\n+    pub fn remove(&self) -> SyntaxRewriter<'static> {\n+        let mut res = SyntaxRewriter::default();\n+        res.delete(self.syntax());\n+        let next_ws = self\n+            .syntax()\n+            .next_sibling_or_token()\n+            .and_then(|it| it.into_token())\n+            .and_then(ast::Whitespace::cast);\n+        if let Some(next_ws) = next_ws {\n+            let ws_text = next_ws.syntax().text();\n+            if ws_text.starts_with('\\n') {\n+                let rest = &ws_text[1..];\n+                if rest.is_empty() {\n+                    res.delete(next_ws.syntax())\n+                } else {\n+                    res.replace(next_ws.syntax(), &make::tokens::whitespace(rest));\n+                }\n+            }\n+        }\n+        res\n+    }\n }\n \n impl ast::UseTree {\n@@ -293,6 +315,22 @@ impl ast::UseTree {\n             Some(res)\n         }\n     }\n+\n+    pub fn remove(&self) -> SyntaxRewriter<'static> {\n+        let mut res = SyntaxRewriter::default();\n+        res.delete(self.syntax());\n+        for &dir in [Direction::Next, Direction::Prev].iter() {\n+            if let Some(nb) = neighbor(self, dir) {\n+                self.syntax()\n+                    .siblings_with_tokens(dir)\n+                    .skip(1)\n+                    .take_while(|it| it.as_node() != Some(nb.syntax()))\n+                    .for_each(|el| res.delete(&el));\n+                return res;\n+            }\n+        }\n+        res\n+    }\n }\n \n #[must_use]\n@@ -343,56 +381,46 @@ impl IndentLevel {\n     }\n \n     fn _increase_indent(self, node: SyntaxNode) -> SyntaxNode {\n-        let replacements: FxHashMap<SyntaxElement, SyntaxElement> = node\n-            .descendants_with_tokens()\n+        let mut rewriter = SyntaxRewriter::default();\n+        node.descendants_with_tokens()\n             .filter_map(|el| el.into_token())\n             .filter_map(ast::Whitespace::cast)\n             .filter(|ws| {\n                 let text = ws.syntax().text();\n                 text.contains('\\n')\n             })\n-            .map(|ws| {\n-                (\n-                    ws.syntax().clone().into(),\n-                    make::tokens::whitespace(&format!(\n-                        \"{}{:width$}\",\n-                        ws.syntax().text(),\n-                        \"\",\n-                        width = self.0 as usize * 4\n-                    ))\n-                    .into(),\n-                )\n-            })\n-            .collect();\n-        algo::replace_descendants(&node, |n| replacements.get(n).cloned())\n+            .for_each(|ws| {\n+                let new_ws = make::tokens::whitespace(&format!(\n+                    \"{}{:width$}\",\n+                    ws.syntax().text(),\n+                    \"\",\n+                    width = self.0 as usize * 4\n+                ));\n+                rewriter.replace(ws.syntax(), &new_ws)\n+            });\n+        rewriter.rewrite(&node)\n     }\n \n     pub fn decrease_indent<N: AstNode>(self, node: N) -> N {\n         N::cast(self._decrease_indent(node.syntax().clone())).unwrap()\n     }\n \n     fn _decrease_indent(self, node: SyntaxNode) -> SyntaxNode {\n-        let replacements: FxHashMap<SyntaxElement, SyntaxElement> = node\n-            .descendants_with_tokens()\n+        let mut rewriter = SyntaxRewriter::default();\n+        node.descendants_with_tokens()\n             .filter_map(|el| el.into_token())\n             .filter_map(ast::Whitespace::cast)\n             .filter(|ws| {\n                 let text = ws.syntax().text();\n                 text.contains('\\n')\n             })\n-            .map(|ws| {\n-                (\n-                    ws.syntax().clone().into(),\n-                    make::tokens::whitespace(\n-                        &ws.syntax()\n-                            .text()\n-                            .replace(&format!(\"\\n{:1$}\", \"\", self.0 as usize * 4), \"\\n\"),\n-                    )\n-                    .into(),\n-                )\n-            })\n-            .collect();\n-        algo::replace_descendants(&node, |n| replacements.get(n).cloned())\n+            .for_each(|ws| {\n+                let new_ws = make::tokens::whitespace(\n+                    &ws.syntax().text().replace(&format!(\"\\n{:1$}\", \"\", self.0 as usize * 4), \"\\n\"),\n+                );\n+                rewriter.replace(ws.syntax(), &new_ws)\n+            });\n+        rewriter.rewrite(&node)\n     }\n }\n \n@@ -442,12 +470,11 @@ pub trait AstNodeEdit: AstNode + Sized {\n         &self,\n         replacement_map: impl IntoIterator<Item = (D, D)>,\n     ) -> Self {\n-        let map = replacement_map\n-            .into_iter()\n-            .map(|(from, to)| (from.syntax().clone().into(), to.syntax().clone().into()))\n-            .collect::<FxHashMap<SyntaxElement, _>>();\n-        let new_syntax = algo::replace_descendants(self.syntax(), |n| map.get(n).cloned());\n-        Self::cast(new_syntax).unwrap()\n+        let mut rewriter = SyntaxRewriter::default();\n+        for (from, to) in replacement_map {\n+            rewriter.replace(from.syntax(), to.syntax())\n+        }\n+        rewriter.rewrite_ast(self)\n     }\n }\n "}]}