{"sha": "bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhY2I5MzhhYjA5NmUzZTI4ODVlN2JiYjVlMmNkYmViZTUzMjkyZWE=", "commit": {"author": {"name": "Phil Ellison", "email": "phil.j.ellison@gmail.com", "date": "2019-08-11T10:40:08Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-08-25T09:55:55Z"}, "message": "Add type_mismatches to InferenceResult and use this in ok-wrapping code fix", "tree": {"sha": "8d2b95f60e06e8a57a84c3d128397433c0a99716", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8d2b95f60e06e8a57a84c3d128397433c0a99716"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "html_url": "https://github.com/rust-lang/rust/commit/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/comments", "author": {"login": "theotherphil", "id": 1974256, "node_id": "MDQ6VXNlcjE5NzQyNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1974256?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theotherphil", "html_url": "https://github.com/theotherphil", "followers_url": "https://api.github.com/users/theotherphil/followers", "following_url": "https://api.github.com/users/theotherphil/following{/other_user}", "gists_url": "https://api.github.com/users/theotherphil/gists{/gist_id}", "starred_url": "https://api.github.com/users/theotherphil/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theotherphil/subscriptions", "organizations_url": "https://api.github.com/users/theotherphil/orgs", "repos_url": "https://api.github.com/users/theotherphil/repos", "events_url": "https://api.github.com/users/theotherphil/events{/privacy}", "received_events_url": "https://api.github.com/users/theotherphil/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d00a285fa757307bbe0f8dac9e49ac247cf9dab1", "url": "https://api.github.com/repos/rust-lang/rust/commits/d00a285fa757307bbe0f8dac9e49ac247cf9dab1", "html_url": "https://github.com/rust-lang/rust/commit/d00a285fa757307bbe0f8dac9e49ac247cf9dab1"}], "stats": {"total": 35, "additions": 27, "deletions": 8}, "files": [{"sha": "0e7b08c540e068ecbe3ae319c49211e0f75ac4d2", "filename": "crates/ra_hir/src/expr/validation.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr%2Fvalidation.rs?ref=bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "patch": "@@ -102,14 +102,16 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n     }\n \n     fn validate_results_in_tail_expr(&mut self, id: ExprId, db: &impl HirDatabase) {\n-        let expr_ty = &self.infer[id];\n-        let func_ty = self.func.ty(db);\n-        let func_sig = func_ty.callable_sig(db).unwrap();\n-        let ret = func_sig.ret();\n-        let ret = match ret {\n+        let mismatch = match self.infer.type_mismatch_for_expr(id) {\n+            Some(m) => m,\n+            None => return,\n+        };\n+\n+        let ret = match &mismatch.expected {\n             Ty::Apply(t) => t,\n             _ => return,\n         };\n+\n         let ret_enum = match ret.ctor {\n             TypeCtor::Adt(AdtDef::Enum(e)) => e,\n             _ => return,\n@@ -119,7 +121,7 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             return;\n         }\n         let params = &ret.parameters;\n-        if params.len() == 2 && &params[0] == expr_ty {\n+        if params.len() == 2 && &params[0] == &mismatch.actual {\n             let source_map = self.func.body_source_map(db);\n             let file_id = self.func.source(db).file_id;\n             let parse = db.parse(file_id.original_file(db));"}, {"sha": "b54c80318522f0caf6efbdbf855b88e3eea07b32", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "patch": "@@ -516,7 +516,7 @@ impl Ty {\n         }\n     }\n \n-    pub fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n+    fn callable_sig(&self, db: &impl HirDatabase) -> Option<FnSig> {\n         match self {\n             Ty::Apply(a_ty) => match a_ty.ctor {\n                 TypeCtor::FnPtr { .. } => Some(FnSig::from_fn_ptr_substs(&a_ty.parameters)),"}, {"sha": "d94e8154b0db0d0ce02de5a9238bbe2ee11b57b5", "filename": "crates/ra_hir/src/ty/infer.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bacb938ab096e3e2885e7bbb5e2cdbebe53292ea/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Finfer.rs?ref=bacb938ab096e3e2885e7bbb5e2cdbebe53292ea", "patch": "@@ -106,6 +106,13 @@ impl Default for BindingMode {\n     }\n }\n \n+/// A mismatch between an expected and an inferred type.\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct TypeMismatch {\n+    pub expected: Ty,\n+    pub actual: Ty,\n+}\n+\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug, Default)]\n pub struct InferenceResult {\n@@ -120,6 +127,7 @@ pub struct InferenceResult {\n     diagnostics: Vec<InferenceDiagnostic>,\n     pub(super) type_of_expr: ArenaMap<ExprId, Ty>,\n     pub(super) type_of_pat: ArenaMap<PatId, Ty>,\n+    pub(super) type_mismatches: ArenaMap<ExprId, TypeMismatch>,\n }\n \n impl InferenceResult {\n@@ -141,6 +149,9 @@ impl InferenceResult {\n     pub fn assoc_resolutions_for_pat(&self, id: PatId) -> Option<ImplItem> {\n         self.assoc_resolutions.get(&id.into()).copied()\n     }\n+    pub fn type_mismatch_for_expr(&self, expr: ExprId) -> Option<&TypeMismatch> {\n+        self.type_mismatches.get(expr)\n+    }\n     pub(crate) fn add_diagnostics(\n         &self,\n         db: &impl HirDatabase,\n@@ -1345,9 +1356,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n-        self.unify(&ty, &expected.ty);\n+        let could_unify = self.unify(&ty, &expected.ty);\n         let ty = self.resolve_ty_as_possible(&mut vec![], ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n+        if !could_unify {\n+            self.result.type_mismatches.insert(\n+                tgt_expr,\n+                TypeMismatch { expected: expected.ty.clone(), actual: ty.clone() },\n+            );\n+        }\n         ty\n     }\n "}]}