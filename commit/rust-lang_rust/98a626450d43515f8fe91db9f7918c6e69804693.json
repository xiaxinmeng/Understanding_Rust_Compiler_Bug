{"sha": "98a626450d43515f8fe91db9f7918c6e69804693", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4YTYyNjQ1MGQ0MzUxNWY4ZmU5MWRiOWY3OTE4YzZlNjk4MDQ2OTM=", "commit": {"author": {"name": "Matt Hall", "email": "matthew@quickbeam.me.uk", "date": "2021-02-23T19:19:48Z"}, "committer": {"name": "Matt Hall", "email": "matthew@quickbeam.me.uk", "date": "2021-02-23T19:19:48Z"}, "message": "Address review comments\n\n* Move code to build replacement into closure\n* Look for iter/iter_mut methods on types behind reference", "tree": {"sha": "a6927dce79a76cda1be19d0adefd85a21013213a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a6927dce79a76cda1be19d0adefd85a21013213a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98a626450d43515f8fe91db9f7918c6e69804693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98a626450d43515f8fe91db9f7918c6e69804693", "html_url": "https://github.com/rust-lang/rust/commit/98a626450d43515f8fe91db9f7918c6e69804693", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98a626450d43515f8fe91db9f7918c6e69804693/comments", "author": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mattyhall", "id": 5175499, "node_id": "MDQ6VXNlcjUxNzU0OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/5175499?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mattyhall", "html_url": "https://github.com/mattyhall", "followers_url": "https://api.github.com/users/mattyhall/followers", "following_url": "https://api.github.com/users/mattyhall/following{/other_user}", "gists_url": "https://api.github.com/users/mattyhall/gists{/gist_id}", "starred_url": "https://api.github.com/users/mattyhall/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mattyhall/subscriptions", "organizations_url": "https://api.github.com/users/mattyhall/orgs", "repos_url": "https://api.github.com/users/mattyhall/repos", "events_url": "https://api.github.com/users/mattyhall/events{/privacy}", "received_events_url": "https://api.github.com/users/mattyhall/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "506293ca43f4cae7520c9e14b6b36b42b1af4ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/506293ca43f4cae7520c9e14b6b36b42b1af4ce1", "html_url": "https://github.com/rust-lang/rust/commit/506293ca43f4cae7520c9e14b6b36b42b1af4ce1"}], "stats": {"total": 158, "additions": 125, "deletions": 33}, "files": [{"sha": "f329d435f1d62cf62a446e51cc2e91828c6fded6", "filename": "crates/ide_assists/src/handlers/convert_for_to_iter_for_each.rs", "status": "modified", "additions": 125, "deletions": 33, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/98a626450d43515f8fe91db9f7918c6e69804693/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98a626450d43515f8fe91db9f7918c6e69804693/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fconvert_for_to_iter_for_each.rs?ref=98a626450d43515f8fe91db9f7918c6e69804693", "patch": "@@ -32,33 +32,68 @@ pub(crate) fn convert_for_to_iter_for_each(acc: &mut Assists, ctx: &AssistContex\n     let pat = for_loop.pat()?;\n     let body = for_loop.loop_body()?;\n \n-    let mut buf = String::new();\n+    acc.add(\n+        AssistId(\"convert_for_to_iter_for_each\", AssistKind::RefactorRewrite),\n+        \"Convert a for loop into an Iterator::for_each\",\n+        for_loop.syntax().text_range(),\n+        |builder| {\n+            let mut buf = String::new();\n \n-    if impls_core_iter(&ctx.sema, &iterable) {\n-        buf += &iterable.to_string();\n-    } else {\n-        match iterable {\n-            ast::Expr::RefExpr(r) => {\n-                if r.mut_token().is_some() {\n-                    format_to!(buf, \"{}.iter_mut()\", r.expr()?);\n+            if let Some((expr_behind_ref, method)) =\n+                is_ref_and_impls_iter_method(&ctx.sema, &iterable)\n+            {\n+                // We have either \"for x in &col\" and col implements a method called iter\n+                //             or \"for x in &mut col\" and col implements a method called iter_mut\n+                format_to!(buf, \"{}.{}()\", expr_behind_ref, method);\n+            } else if impls_core_iter(&ctx.sema, &iterable) {\n+                format_to!(buf, \"{}\", iterable);\n+            } else {\n+                if let ast::Expr::RefExpr(_) = iterable {\n+                    format_to!(buf, \"({}).into_iter()\", iterable);\n                 } else {\n-                    format_to!(buf, \"{}.iter()\", r.expr()?);\n+                    format_to!(buf, \"{}.into_iter()\", iterable);\n                 }\n             }\n-            _ => format_to!(buf, \"{}.into_iter()\", iterable),\n-        }\n-    }\n \n-    format_to!(buf, \".for_each(|{}| {});\", pat, body);\n+            format_to!(buf, \".for_each(|{}| {});\", pat, body);\n \n-    acc.add(\n-        AssistId(\"convert_for_to_iter_for_each\", AssistKind::RefactorRewrite),\n-        \"Convert a for loop into an Iterator::for_each\",\n-        for_loop.syntax().text_range(),\n-        |builder| builder.replace(for_loop.syntax().text_range(), buf),\n+            builder.replace(for_loop.syntax().text_range(), buf)\n+        },\n     )\n }\n \n+/// If iterable is a reference where the expression behind the reference implements a method\n+/// returning an Iterator called iter or iter_mut (depending on the type of reference) then return\n+/// the expression behind the reference and the method name\n+fn is_ref_and_impls_iter_method(\n+    sema: &hir::Semantics<ide_db::RootDatabase>,\n+    iterable: &ast::Expr,\n+) -> Option<(ast::Expr, &'static str)> {\n+    let ref_expr = match iterable {\n+        ast::Expr::RefExpr(r) => r,\n+        _ => return None,\n+    };\n+    let wanted_method = if ref_expr.mut_token().is_some() { \"iter_mut\" } else { \"iter\" };\n+    let expr_behind_ref = ref_expr.expr()?;\n+    let typ = sema.type_of_expr(&expr_behind_ref)?;\n+    let scope = sema.scope(iterable.syntax());\n+    let krate = scope.module()?.krate();\n+    let traits_in_scope = scope.traits_in_scope();\n+    let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n+    let has_wanted_method =\n+        typ.iterate_method_candidates(sema.db, krate, &traits_in_scope, None, |_, func| {\n+            if func.name(sema.db).to_string() != wanted_method {\n+                return None;\n+            }\n+            if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                return Some(());\n+            }\n+            None\n+        });\n+    has_wanted_method.and(Some((expr_behind_ref, wanted_method)))\n+}\n+\n+/// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n     let it_typ = if let Some(i) = sema.type_of_expr(iterable) {\n         i\n@@ -94,7 +129,10 @@ impl Iterator for EmptyIter {\n pub struct Empty;\n impl Empty {\n     pub fn iter(&self) -> EmptyIter { EmptyIter }\n+    pub fn iter_mut(&self) -> EmptyIter { EmptyIter }\n }\n+\n+pub struct NoIterMethod;\n \";\n \n     #[test]\n@@ -131,43 +169,97 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed() {\n-        check_assist(\n-            convert_for_to_iter_for_each,\n-            r\"\n+        let before = r\"\n+use empty_iter::*;\n fn main() {\n-    let x = vec![1, 2, 3];\n+    let x = Empty;\n     for $0v in &x {\n         let a = v * 2;\n     }\n-}\",\n+}\n+\";\n+        let before = &format!(\n+            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n+            before,\n+            FamousDefs::FIXTURE,\n+            EMPTY_ITER_FIXTURE\n+        );\n+        check_assist(\n+            convert_for_to_iter_for_each,\n+            before,\n             r\"\n+use empty_iter::*;\n fn main() {\n-    let x = vec![1, 2, 3];\n+    let x = Empty;\n     x.iter().for_each(|v| {\n         let a = v * 2;\n     });\n-}\",\n+}\n+\",\n         )\n     }\n \n     #[test]\n-    fn test_for_borrowed_mut() {\n+    fn test_for_borrowed_no_iter_method() {\n+        let before = r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = NoIterMethod;\n+    for $0v in &x {\n+        let a = v * 2;\n+    }\n+}\n+\";\n+        let before = &format!(\n+            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n+            before,\n+            FamousDefs::FIXTURE,\n+            EMPTY_ITER_FIXTURE\n+        );\n         check_assist(\n             convert_for_to_iter_for_each,\n+            before,\n             r\"\n+use empty_iter::*;\n fn main() {\n-    let x = vec![1, 2, 3];\n+    let x = NoIterMethod;\n+    (&x).into_iter().for_each(|v| {\n+        let a = v * 2;\n+    });\n+}\n+\",\n+        )\n+    }\n+\n+    #[test]\n+    fn test_for_borrowed_mut() {\n+        let before = r\"\n+use empty_iter::*;\n+fn main() {\n+    let x = Empty;\n     for $0v in &mut x {\n-        *v *= 2;\n+        let a = v * 2;\n     }\n-}\",\n+}\n+\";\n+        let before = &format!(\n+            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n+            before,\n+            FamousDefs::FIXTURE,\n+            EMPTY_ITER_FIXTURE\n+        );\n+        check_assist(\n+            convert_for_to_iter_for_each,\n+            before,\n             r\"\n+use empty_iter::*;\n fn main() {\n-    let x = vec![1, 2, 3];\n+    let x = Empty;\n     x.iter_mut().for_each(|v| {\n-        *v *= 2;\n+        let a = v * 2;\n     });\n-}\",\n+}\n+\",\n         )\n     }\n \n@@ -195,7 +287,7 @@ fn main() {\n     }\n \n     #[test]\n-    fn test_take() {\n+    fn test_already_impls_iterator() {\n         let before = r#\"\n use empty_iter::*;\n fn main() {"}]}