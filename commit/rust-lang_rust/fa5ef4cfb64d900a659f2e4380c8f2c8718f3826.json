{"sha": "fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhNWVmNGNmYjY0ZDkwMGE2NTlmMmU0MzgwYzhmMmM4NzE4ZjM4MjY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-07T01:36:28Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2010-10-07T01:36:28Z"}, "message": "Add the beginnings of an ast folder plus an empty module for resolve.", "tree": {"sha": "fa83697f1be4111e436a3cdd685f1aaf4b5a78a8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa83697f1be4111e436a3cdd685f1aaf4b5a78a8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "html_url": "https://github.com/rust-lang/rust/commit/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f2d35ed0853f0fb7bb72f633794b8b8da5cd713", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2d35ed0853f0fb7bb72f633794b8b8da5cd713", "html_url": "https://github.com/rust-lang/rust/commit/5f2d35ed0853f0fb7bb72f633794b8b8da5cd713"}], "stats": {"total": 533, "additions": 528, "deletions": 5}, "files": [{"sha": "422fd039b7f7bf10b3cde3cee41b741dc398148f", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -76,7 +76,7 @@ tag stmt_ {\n \n type decl = spanned[decl_];\n tag decl_ {\n-    decl_local(ident, option[@ty], ty);\n+    decl_local(ident, bool, option[@ty]);\n     decl_item(name, @item);\n }\n \n@@ -126,8 +126,9 @@ tag mode {\n }\n \n type slot = rec(@ty ty, mode mode, option[slot_id] id);\n+type input = rec(slot slot, ident ident);\n \n-type _fn = rec(vec[rec(slot slot, ident ident)] inputs,\n+type _fn = rec(vec[input] inputs,\n                slot output,\n                block body);\n "}, {"sha": "4eb303ed22989a87a0928fbbcf65846e61d6d32f", "filename": "src/comp/front/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Ffront%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Ffront%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fparser.rs?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -651,7 +651,7 @@ io fn parse_item(parser p) -> tup(ast.ident, @ast.item) {\n     fail;\n }\n \n-io fn parse_crate(parser p) -> ast.crate {\n+io fn parse_crate(parser p) -> @ast.crate {\n     auto lo = p.get_span();\n     auto hi = lo;\n     let ast._mod m = new_str_hash[@ast.item]();\n@@ -660,7 +660,7 @@ io fn parse_crate(parser p) -> ast.crate {\n         m.insert(i._0, i._1);\n         hi = i._1.span;\n     }\n-    ret spanned(lo, hi, rec(module=m));\n+    ret @spanned(lo, hi, rec(module=m));\n }\n \n //"}, {"sha": "277da2a2d2c3214369ef7d2d1df3d3dc88fa2343", "filename": "src/comp/middle/fold.rs", "status": "added", "additions": 514, "deletions": 0, "changes": 514, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ffold.rs?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -0,0 +1,514 @@\n+import std.map.hashmap;\n+import front.ast;\n+import util.common.new_str_hash;\n+import util.common.spanned;\n+import util.common.span;\n+import util.common.option;\n+import util.common.some;\n+import util.common.none;\n+import util.common.ty_mach;\n+import std._vec;\n+import std.util.operator;\n+\n+type slot[TY] = rec(TY ty, ast.mode mode, option[ast.slot_id] id);\n+type input[T] = rec(slot[T] slot, ast.ident ident);\n+type name[TY] = rec(ast.ident ident, vec[TY] types);\n+\n+type ast_fold[ENV,\n+              NAME,TY,EXPR,STMT,BLOCK,\n+              FN,MOD,DECL,ITEM,CRATE] =\n+    @rec\n+    (\n+     // Name fold.\n+     (fn(&ENV e, &span sp, &name[TY] name) -> NAME) fold_name,\n+\n+     // Type folds.\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_nil,\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_bool,\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_int,\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_uint,\n+     (fn(&ENV e, &span sp, ty_mach tm) -> TY)   fold_ty_machine,\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_char,\n+     (fn(&ENV e, &span sp) -> TY)               fold_ty_str,\n+     (fn(&ENV e, &span sp, &TY t) -> TY)        fold_ty_box,\n+     (fn(&ENV e, &span sp, &ast.path p,\n+         &option[ast.referent] r) -> TY)        fold_ty_path,\n+\n+     // Expr folds.\n+     (fn(&ENV e, &span sp,\n+         &vec[EXPR] es) -> EXPR)                      fold_expr_vec,\n+\n+     (fn(&ENV e, &span sp,\n+         &vec[EXPR] es) -> EXPR)                      fold_expr_tup,\n+\n+     (fn(&ENV e, &span sp,\n+         &vec[tup(ast.ident,EXPR)] fields) -> EXPR)   fold_expr_rec,\n+\n+     (fn(&ENV e, &span sp,\n+         &EXPR f, &vec[EXPR] args) -> EXPR)           fold_expr_call,\n+\n+     (fn(&ENV e, &span sp,\n+         ast.binop,\n+         &EXPR lhs, &EXPR rhs) -> EXPR)               fold_expr_binary,\n+\n+     (fn(&ENV e, &span sp,\n+         ast.unop, &EXPR e) -> EXPR)                  fold_expr_unary,\n+\n+     (fn(&ENV e, &span sp,\n+         @ast.lit) -> EXPR)                           fold_expr_lit,\n+\n+     (fn(&ENV e, &span sp,\n+         &NAME name,\n+         &option[ast.referent] r) -> EXPR)            fold_expr_name,\n+\n+     (fn(&ENV e, &span sp,\n+         &EXPR e, &ast.ident i) -> EXPR)              fold_expr_field,\n+\n+     (fn(&ENV e, &span sp,\n+         &EXPR e, &EXPR ix) -> EXPR)                  fold_expr_index,\n+\n+     (fn(&ENV e, &span sp,\n+         &EXPR cond, &BLOCK thn,\n+         &option[BLOCK] els) -> EXPR)                 fold_expr_if,\n+\n+     (fn(&ENV e, &span sp,\n+         &BLOCK blk) -> EXPR)                         fold_expr_block,\n+\n+\n+     // Decl folds.\n+     (fn(&ENV e, &span sp,\n+         &ast.ident ident, bool infer,\n+         &option[TY] ty) -> DECL)                 fold_decl_local,\n+\n+     (fn(&ENV e, &span sp,\n+         &NAME name, ITEM item) -> DECL)          fold_decl_item,\n+\n+\n+     // Stmt folds.\n+     (fn(&ENV e, &span sp, &DECL decl) -> STMT) fold_stmt_decl,\n+     (fn(&ENV e, &span sp, &option[EXPR] rv) -> STMT) fold_stmt_ret,\n+     (fn(&ENV e, &span sp, &EXPR e) -> STMT) fold_stmt_log,\n+     (fn(&ENV e, &span sp, &EXPR e) -> STMT) fold_stmt_expr,\n+\n+     // Item folds.\n+     (fn(&ENV e, &span sp, &FN f, ast.item_id id) -> ITEM) fold_item_fn,\n+     (fn(&ENV e, &span sp, &MOD m) -> ITEM) fold_item_mod,\n+     (fn(&ENV e, &span sp, &TY t, ast.item_id id) -> ITEM) fold_item_ty,\n+\n+     // Additional nodes.\n+     (fn(&ENV e, &span sp, &vec[STMT] stmts) -> BLOCK) fold_block,\n+     (fn(&ENV e, &vec[rec(slot[TY] slot, ast.ident ident)] inputs,\n+         &slot[TY] output, &BLOCK body) -> FN) fold_fn,\n+     (fn(&ENV e, hashmap[ast.ident,ITEM] m) -> MOD) fold_mod,\n+     (fn(&ENV e, &span sp, &MOD m) -> CRATE) fold_crate,\n+\n+     // Env updates.\n+     (fn(&ENV e, &ast.crate c) -> ENV) update_env_for_crate,\n+     (fn(&ENV e, &ast.item i) -> ENV) update_env_for_item,\n+     (fn(&ENV e, &ast.stmt s) -> ENV) update_env_for_stmt,\n+     (fn(&ENV e, &ast.expr x) -> ENV) update_env_for_expr,\n+     (fn(&ENV e, &ast.ty t) -> ENV) update_env_for_ty,\n+\n+     // Traversal control.\n+     (fn(&ENV v) -> bool) keep_going\n+      );\n+\n+\n+//// Fold drivers.\n+\n+// FIXME: Finish these.\n+\n+// FIXME: Also, little more type-inference love would help here.\n+\n+fn fold_ty[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.ty ty) -> T {\n+    fail;\n+}\n+\n+fn fold_block[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast.block blk) -> B {\n+    fail;\n+}\n+\n+fn fold_slot[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast.slot s) -> slot[T] {\n+    auto ty = fold_ty[E,N,T,X,S,B,F,M,D,I,C](env, fld, s.ty);\n+    ret rec(ty=ty, mode=s.mode, id=s.id);\n+}\n+\n+\n+fn fold_fn[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast._fn f) -> F {\n+\n+    fn fold_input[E,N,T,X,S,B,F,M,D,I,C]\n+        (&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld,\n+         &rec(ast.slot slot, ast.ident ident) i)\n+        -> input[T] {\n+        ret rec(slot=fold_slot[E,N,T,X,S,B,F,M,D,I,C](env, fld, i.slot),\n+                ident=i.ident);\n+    }\n+\n+    let operator[ast.input,input[T]] fi =\n+        bind fold_input[E,N,T,X,S,B,F,M,D,I,C](env, fld, _);\n+    auto inputs = _vec.map[ast.input, input[T]](fi, f.inputs);\n+    auto output = fold_slot[E,N,T,X,S,B,F,M,D,I,C](env, fld, f.output);\n+    auto body = fold_block[E,N,T,X,S,B,F,M,D,I,C](env, fld, f.body);\n+\n+    ret fld.fold_fn(env, inputs, output, body);\n+}\n+\n+fn fold_item[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.item item) -> I {\n+\n+    let E env_ = fld.update_env_for_item(env, *item);\n+\n+    alt (item.node) {\n+\n+        case (ast.item_fn(?ff, ?id)) {\n+            let F ff_ = fold_fn[E,N,T,X,S,B,F,M,D,I,C](env_, fld, ff);\n+            ret fld.fold_item_fn(env_, item.span, ff_, id);\n+        }\n+\n+        case (ast.item_mod(?mm)) {\n+            let M mm_ = fold_mod[E,N,T,X,S,B,F,M,D,I,C](env_, fld, mm);\n+            ret fld.fold_item_mod(env_, item.span, mm_);\n+        }\n+\n+        case (ast.item_ty(?ty, ?id)) {\n+            let T ty_ = fold_ty[E,N,T,X,S,B,F,M,D,I,C](env_, fld, ty);\n+            ret fld.fold_item_ty(env_, item.span, ty_, id);\n+        }\n+    }\n+\n+    fail;\n+}\n+\n+\n+fn fold_mod[E,N,T,X,S,B,F,M,D,I,C]\n+(&E e, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, &ast._mod m_in) -> M {\n+\n+    auto m_out = new_str_hash[I]();\n+\n+    for each (tup(ast.ident, @ast.item) pairs in m_in.items()) {\n+        auto i = fold_item[E,N,T,X,S,B,F,M,D,I,C](e, fld, pairs._1);\n+        m_out.insert(pairs._0, i);\n+    }\n+\n+    ret fld.fold_mod(e, m_out);\n+ }\n+\n+fn fold_crate[E,N,T,X,S,B,F,M,D,I,C]\n+(&E env, ast_fold[E,N,T,X,S,B,F,M,D,I,C] fld, @ast.crate c) -> C {\n+    let E env_ = fld.update_env_for_crate(env, *c);\n+    let M m = fold_mod[E,N,T,X,S,B,F,M,D,I,C](env_, fld, c.node.module);\n+    ret fld.fold_crate(env_, c.span, m);\n+}\n+\n+//// Identity folds.\n+\n+fn respan[T](&span sp, &T t) -> spanned[T] {\n+    ret rec(node=t, span=sp);\n+}\n+\n+\n+// Name identity.\n+\n+fn identity_fold_name[ENV](&ENV env, &span sp,\n+                           &ast.name_ n) -> ast.name {\n+    ret respan(sp, n);\n+}\n+\n+\n+// Type identities.\n+\n+fn identity_fold_ty_nil[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_nil);\n+}\n+\n+fn identity_fold_ty_bool[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_bool);\n+}\n+\n+fn identity_fold_ty_int[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_int);\n+}\n+\n+fn identity_fold_ty_uint[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_uint);\n+}\n+\n+fn identity_fold_ty_machine[ENV](&ENV env, &span sp,\n+                                 ty_mach tm) -> @ast.ty {\n+    ret @respan(sp, ast.ty_machine(tm));\n+}\n+\n+fn identity_fold_ty_char[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_char);\n+}\n+\n+fn identity_fold_ty_str[ENV](&ENV env, &span sp) -> @ast.ty {\n+    ret @respan(sp, ast.ty_str);\n+}\n+\n+fn identity_fold_ty_box[ENV](&ENV env, &span sp, &@ast.ty t) -> @ast.ty {\n+    ret @respan(sp, ast.ty_box(t));\n+}\n+\n+fn identity_fold_ty_path[ENV](&ENV env, &span sp, &ast.path p,\n+                        &option[ast.referent] r) -> @ast.ty {\n+    ret @respan(sp, ast.ty_path(p, r));\n+}\n+\n+\n+// Expr identities.\n+\n+fn identity_fold_expr_vec[ENV](&ENV env, &span sp,\n+                               &vec[@ast.expr] es) -> @ast.expr {\n+    ret @respan(sp, ast.expr_vec(es));\n+}\n+\n+fn identity_fold_expr_tup[ENV](&ENV env, &span sp,\n+                               &vec[@ast.expr] es) -> @ast.expr {\n+    ret @respan(sp, ast.expr_tup(es));\n+}\n+\n+fn identity_fold_expr_rec[ENV](&ENV env, &span sp,\n+                               &vec[tup(ast.ident,@ast.expr)] fields)\n+    -> @ast.expr {\n+    ret @respan(sp, ast.expr_rec(fields));\n+}\n+\n+fn identity_fold_expr_call[ENV](&ENV env, &span sp, &@ast.expr f,\n+                                &vec[@ast.expr] args) -> @ast.expr {\n+    ret @respan(sp, ast.expr_call(f, args));\n+}\n+\n+fn identity_fold_expr_binary[ENV](&ENV env, &span sp, ast.binop b,\n+                                  &@ast.expr lhs,\n+                                  &@ast.expr rhs) -> @ast.expr {\n+    ret @respan(sp, ast.expr_binary(b, lhs, rhs));\n+}\n+\n+fn identity_fold_expr_unary[ENV](&ENV env, &span sp,\n+                                 ast.unop u, &@ast.expr e) -> @ast.expr {\n+    ret @respan(sp, ast.expr_unary(u, e));\n+}\n+\n+fn identity_fold_expr_lit[ENV](&ENV env, &span sp,\n+                               @ast.lit lit) -> @ast.expr {\n+    ret @respan(sp, ast.expr_lit(lit));\n+}\n+\n+fn identity_fold_expr_name[ENV](&ENV env, &span sp, &ast.name name,\n+                          &option[ast.referent] r) -> @ast.expr {\n+    ret @respan(sp, ast.expr_name(name, r));\n+}\n+\n+fn identity_fold_expr_field[ENV](&ENV env, &span sp,\n+                                 &@ast.expr e, &ast.ident i)\n+    -> @ast.expr {\n+    ret @respan(sp, ast.expr_field(e, i));\n+}\n+\n+fn identity_fold_expr_index[ENV](&ENV env, &span sp,\n+                                 &@ast.expr e, &@ast.expr ix)\n+    -> @ast.expr {\n+    ret @respan(sp, ast.expr_index(e, ix));\n+}\n+\n+fn identity_fold_expr_if[ENV](&ENV env, &span sp,\n+                              &@ast.expr cond, &ast.block thn,\n+                              &option[ast.block] els) -> @ast.expr {\n+    ret @respan(sp, ast.expr_if(cond, thn, els));\n+}\n+\n+fn identity_fold_expr_block[ENV](&ENV env, &span sp,\n+                                 &ast.block blk) -> @ast.expr {\n+    ret @respan(sp, ast.expr_block(blk));\n+}\n+\n+\n+// Decl identities.\n+\n+fn identity_fold_decl_local[ENV](&ENV e, &span sp,\n+                                 &ast.ident ident, bool infer,\n+                                 &option[@ast.ty] ty) -> @ast.decl {\n+    ret @respan(sp, ast.decl_local(ident, infer, ty));\n+}\n+\n+fn identity_fold_decl_item[ENV](&ENV e, &span sp,\n+                                &ast.name name,\n+                                @ast.item item) -> @ast.decl {\n+    ret @respan(sp, ast.decl_item(name, item));\n+}\n+\n+\n+// Stmt identities.\n+\n+fn identity_fold_stmt_decl[ENV](&ENV env, &span sp,\n+                                &@ast.decl decl) -> @ast.stmt {\n+    ret @respan(sp, ast.stmt_decl(decl));\n+}\n+\n+fn identity_fold_stmt_ret[ENV](&ENV env, &span sp,\n+                               &option[@ast.expr] rv) -> @ast.stmt {\n+    ret @respan(sp, ast.stmt_ret(rv));\n+}\n+\n+fn identity_fold_stmt_log[ENV](&ENV e, &span sp, &@ast.expr x) -> @ast.stmt {\n+    ret @respan(sp, ast.stmt_log(x));\n+}\n+\n+fn identity_fold_stmt_expr[ENV](&ENV e, &span sp, &@ast.expr x) -> @ast.stmt {\n+    ret @respan(sp, ast.stmt_expr(x));\n+}\n+\n+\n+// Item identities.\n+\n+fn identity_fold_item_fn[ENV](&ENV e, &span sp, &ast._fn f,\n+                              ast.item_id id) -> @ast.item {\n+    ret @respan(sp, ast.item_fn(f, id));\n+}\n+\n+fn identity_fold_item_mod[ENV](&ENV e, &span sp, &ast._mod m) -> @ast.item {\n+    ret @respan(sp, ast.item_mod(m));\n+}\n+\n+fn identity_fold_item_ty[ENV](&ENV e, &span sp, &@ast.ty t,\n+                              ast.item_id id) -> @ast.item {\n+    ret @respan(sp, ast.item_ty(t, id));\n+}\n+\n+\n+// Additional identities.\n+\n+fn identity_fold_block[ENV](&ENV e, &span sp,\n+                            &vec[@ast.stmt] stmts) -> ast.block {\n+    ret respan(sp, stmts);\n+}\n+\n+fn identity_fold_fn[ENV](&ENV e,\n+                         &vec[rec(ast.slot slot, ast.ident ident)] inputs,\n+                         &ast.slot output,\n+                         &ast.block body) -> ast._fn {\n+    ret rec(inputs=inputs, output=output, body=body);\n+}\n+\n+fn identity_fold_mod[ENV](&ENV e,\n+                          hashmap[ast.ident, @ast.item] m) -> ast._mod {\n+    ret m;\n+}\n+\n+fn identity_fold_crate[ENV](&ENV e, &span sp,\n+                            &hashmap[ast.ident, @ast.item] m) -> @ast.crate {\n+    ret @respan(sp, rec(module=m));\n+}\n+\n+\n+// Env update identities.\n+\n+fn identity_update_env_for_crate[ENV](&ENV e, &ast.crate c) -> ENV {\n+    ret e;\n+}\n+\n+fn identity_update_env_for_item[ENV](&ENV e, &ast.item i) -> ENV {\n+    ret e;\n+}\n+\n+fn identity_update_env_for_stmt[ENV](&ENV e, &ast.stmt s) -> ENV {\n+    ret e;\n+}\n+\n+fn identity_update_env_for_expr[ENV](&ENV e, &ast.expr x) -> ENV {\n+    ret e;\n+}\n+\n+fn identity_update_env_for_ty[ENV](&ENV e, &ast.ty t) -> ENV {\n+    ret e;\n+}\n+\n+\n+// Always-true traversal control fn.\n+\n+fn always_keep_going[ENV](&ENV e) -> bool {\n+    ret true;\n+}\n+\n+\n+type identity_fold[ENV] = ast_fold[ENV,\n+                                   ast.name, @ast.ty, @ast.expr,\n+                                   @ast.stmt, ast.block, ast._fn,\n+                                   ast._mod, @ast.decl, @ast.item,\n+                                   @ast.crate];\n+\n+type query_fold[ENV,T] = ast_fold[ENV,\n+                                  T,T,T,T,T,\n+                                  T,T,T,T,T];\n+\n+fn new_identity_fold[ENV]() -> identity_fold[ENV] {\n+    ret @rec\n+        (\n+         fold_name       = bind identity_fold_name[ENV](_,_,_),\n+\n+         fold_ty_nil     = bind identity_fold_ty_nil[ENV](_,_),\n+         fold_ty_bool    = bind identity_fold_ty_bool[ENV](_,_),\n+         fold_ty_int     = bind identity_fold_ty_int[ENV](_,_),\n+         fold_ty_uint    = bind identity_fold_ty_uint[ENV](_,_),\n+         fold_ty_machine = bind identity_fold_ty_machine[ENV](_,_,_),\n+         fold_ty_char    = bind identity_fold_ty_char[ENV](_,_),\n+         fold_ty_str     = bind identity_fold_ty_str[ENV](_,_),\n+         fold_ty_box     = bind identity_fold_ty_box[ENV](_,_,_),\n+         fold_ty_path    = bind identity_fold_ty_path[ENV](_,_,_,_),\n+\n+         fold_expr_vec    = bind identity_fold_expr_vec[ENV](_,_,_),\n+         fold_expr_tup    = bind identity_fold_expr_tup[ENV](_,_,_),\n+         fold_expr_rec    = bind identity_fold_expr_rec[ENV](_,_,_),\n+         fold_expr_call   = bind identity_fold_expr_call[ENV](_,_,_,_),\n+         fold_expr_binary = bind identity_fold_expr_binary[ENV](_,_,_,_,_),\n+         fold_expr_unary  = bind identity_fold_expr_unary[ENV](_,_,_,_),\n+         fold_expr_lit    = bind identity_fold_expr_lit[ENV](_,_,_),\n+         fold_expr_name   = bind identity_fold_expr_name[ENV](_,_,_,_),\n+         fold_expr_field  = bind identity_fold_expr_field[ENV](_,_,_,_),\n+         fold_expr_index  = bind identity_fold_expr_index[ENV](_,_,_,_),\n+         fold_expr_if     = bind identity_fold_expr_if[ENV](_,_,_,_,_),\n+         fold_expr_block  = bind identity_fold_expr_block[ENV](_,_,_),\n+\n+         fold_decl_local  = bind identity_fold_decl_local[ENV](_,_,_,_,_),\n+         fold_decl_item   = bind identity_fold_decl_item[ENV](_,_,_,_),\n+\n+         fold_stmt_decl   = bind identity_fold_stmt_decl[ENV](_,_,_),\n+         fold_stmt_ret    = bind identity_fold_stmt_ret[ENV](_,_,_),\n+         fold_stmt_log    = bind identity_fold_stmt_log[ENV](_,_,_),\n+         fold_stmt_expr   = bind identity_fold_stmt_expr[ENV](_,_,_),\n+\n+         fold_item_fn   = bind identity_fold_item_fn[ENV](_,_,_,_),\n+         fold_item_mod  = bind identity_fold_item_mod[ENV](_,_,_),\n+         fold_item_ty   = bind identity_fold_item_ty[ENV](_,_,_,_),\n+\n+         fold_block = bind identity_fold_block[ENV](_,_,_),\n+         fold_fn = bind identity_fold_fn[ENV](_,_,_,_),\n+         fold_mod = bind identity_fold_mod[ENV](_,_),\n+         fold_crate = bind identity_fold_crate[ENV](_,_,_),\n+\n+         update_env_for_crate = bind identity_update_env_for_crate[ENV](_,_),\n+         update_env_for_item = bind identity_update_env_for_item[ENV](_,_),\n+         update_env_for_stmt = bind identity_update_env_for_stmt[ENV](_,_),\n+         update_env_for_expr = bind identity_update_env_for_expr[ENV](_,_),\n+         update_env_for_ty = bind identity_update_env_for_ty[ENV](_,_),\n+\n+         keep_going = bind always_keep_going[ENV](_)\n+         );\n+}\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C ../.. 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "fea1800c73c378381ff7f1d91651c2b5b7ebbe00", "filename": "src/comp/middle/resolve.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -0,0 +1,6 @@\n+import front.ast;\n+import driver.session;\n+\n+fn resolve_crate(session.session sess, ast.crate crate) -> ast.crate {\n+  ret crate;\n+}\n\\ No newline at end of file"}, {"sha": "c90c817b28ed075fa51bfa5f79a1111fecb71532", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -834,7 +834,7 @@ fn trans_main_fn(@trans_ctxt cx, ValueRef llcrate) {\n \n }\n \n-fn trans_crate(session.session sess, ast.crate crate) {\n+fn trans_crate(session.session sess, @ast.crate crate) {\n     auto llmod =\n         llvm.LLVMModuleCreateWithNameInContext(_str.buf(\"rust_out\"),\n                                                llvm.LLVMGetGlobalContext());"}, {"sha": "cce0d38fc37b67cdced5ba4a7d4e911185d6086e", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/fa5ef4cfb64d900a659f2e4380c8f2c8718f3826/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=fa5ef4cfb64d900a659f2e4380c8f2c8718f3826", "patch": "@@ -11,6 +11,8 @@ mod front {\n }\n \n mod middle {\n+    mod fold;\n+    mod resolve;\n     mod trans;\n }\n "}]}