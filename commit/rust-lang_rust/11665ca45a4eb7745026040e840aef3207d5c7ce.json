{"sha": "11665ca45a4eb7745026040e840aef3207d5c7ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExNjY1Y2E0NWE0ZWI3NzQ1MDI2MDQwZTg0MGFlZjMyMDdkNWM3Y2U=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-22T22:05:26Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-27T20:46:13Z"}, "message": "Remove path prefixes from NodeKind", "tree": {"sha": "737250badcf6e25eefde8e2149b23c0ab19ad63c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/737250badcf6e25eefde8e2149b23c0ab19ad63c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/11665ca45a4eb7745026040e840aef3207d5c7ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/11665ca45a4eb7745026040e840aef3207d5c7ce", "html_url": "https://github.com/rust-lang/rust/commit/11665ca45a4eb7745026040e840aef3207d5c7ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/11665ca45a4eb7745026040e840aef3207d5c7ce/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4b12f700db9da92f9f6a87de86c8927c95869454", "url": "https://api.github.com/repos/rust-lang/rust/commits/4b12f700db9da92f9f6a87de86c8927c95869454", "html_url": "https://github.com/rust-lang/rust/commit/4b12f700db9da92f9f6a87de86c8927c95869454"}], "stats": {"total": 350, "additions": 186, "deletions": 164}, "files": [{"sha": "79e93a3a4232af941d43fe1cd3f2812149502df7", "filename": "src/librustc/infer/anon_types/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fanon_types%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -10,6 +10,7 @@\n \n use hir::def_id::DefId;\n use hir;\n+use hir::map::NodeKind;\n use infer::{self, InferCtxt, InferOk, TypeVariableOrigin};\n use infer::outlives::free_region_map::FreeRegionRelations;\n use rustc_data_structures::fx::FxHashMap;\n@@ -697,7 +698,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                             parent_def_id == tcx.hir.local_def_id(anon_parent_node_id)\n                         };\n                         let in_definition_scope = match tcx.hir.find(anon_node_id) {\n-                            Some(hir::map::NodeKind::Item(item)) => match item.node {\n+                            Some(NodeKind::Item(item)) => match item.node {\n                                 // impl trait\n                                 hir::ItemKind::Existential(hir::ExistTy {\n                                     impl_trait_fn: Some(parent),\n@@ -714,7 +715,7 @@ impl<'a, 'gcx, 'tcx> Instantiator<'a, 'gcx, 'tcx> {\n                                 ),\n                                 _ => def_scope_default(),\n                             },\n-                            Some(hir::map::NodeKind::ImplItem(item)) => match item.node {\n+                            Some(NodeKind::ImplItem(item)) => match item.node {\n                                 hir::ImplItemKind::Existential(_) => may_define_existential_type(\n                                     tcx,\n                                     self.parent_def_id,"}, {"sha": "5571543758462f8286ccb433d102afb5bd698870", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -62,7 +62,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n \n use std::{cmp, fmt};\n use hir;\n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n@@ -100,8 +100,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 };\n                 let span = scope.span(self, region_scope_tree);\n                 let tag = match self.hir.find(scope.node_id(self, region_scope_tree)) {\n-                    Some(hir_map::NodeKind::Block(_)) => \"block\",\n-                    Some(hir_map::NodeKind::Expr(expr)) => match expr.node {\n+                    Some(NodeKind::Block(_)) => \"block\",\n+                    Some(NodeKind::Expr(expr)) => match expr.node {\n                         hir::ExprKind::Call(..) => \"call\",\n                         hir::ExprKind::MethodCall(..) => \"method call\",\n                         hir::ExprKind::Match(.., hir::MatchSource::IfLetDesugar { .. }) => \"if let\",\n@@ -110,10 +110,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                         hir::ExprKind::Match(..) => \"match\",\n                         _ => \"expression\",\n                     },\n-                    Some(hir_map::NodeKind::Stmt(_)) => \"statement\",\n-                    Some(hir_map::NodeKind::Item(it)) => Self::item_scope_tag(&it),\n-                    Some(hir_map::NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-                    Some(hir_map::NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n+                    Some(NodeKind::Stmt(_)) => \"statement\",\n+                    Some(NodeKind::Item(it)) => Self::item_scope_tag(&it),\n+                    Some(NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+                    Some(NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n                     Some(_) | None => {\n                         err.span_note(span, &unknown_scope());\n                         return;\n@@ -194,10 +194,10 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         let scope = region.free_region_binding_scope(self);\n         let node = self.hir.as_local_node_id(scope).unwrap_or(DUMMY_NODE_ID);\n         let tag = match self.hir.find(node) {\n-            Some(hir_map::NodeKind::Block(_)) | Some(hir_map::NodeKind::Expr(_)) => \"body\",\n-            Some(hir_map::NodeKind::Item(it)) => Self::item_scope_tag(&it),\n-            Some(hir_map::NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n-            Some(hir_map::NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n+            Some(NodeKind::Block(_)) | Some(NodeKind::Expr(_)) => \"body\",\n+            Some(NodeKind::Item(it)) => Self::item_scope_tag(&it),\n+            Some(NodeKind::TraitItem(it)) => Self::trait_item_scope_tag(&it),\n+            Some(NodeKind::ImplItem(it)) => Self::impl_item_scope_tag(&it),\n             _ => unreachable!()\n         };\n         let (prefix, span) = match *region {\n@@ -1127,7 +1127,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                             // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                             // instead we suggest `T: 'a + 'b` in that case.\n                             let mut has_bounds = false;\n-                            if let hir_map::NodeKind::GenericParam(ref param) = hir.get(id) {\n+                            if let NodeKind::GenericParam(ref param) = hir.get(id) {\n                                 has_bounds = !param.bounds.is_empty();\n                             }\n                             let sp = hir.span(id);"}, {"sha": "4d91059481d0a3a447370829289bf74cf0555c81", "filename": "src/librustc/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -10,7 +10,7 @@\n \n use hir;\n use ty::{self, Region, TyCtxt};\n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use middle::resolve_lifetime as rl;\n use hir::intravisit::{self, NestedVisitorMap, Visitor};\n use infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -40,15 +40,15 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             let def_id = anon_reg.def_id;\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let fndecl = match self.tcx.hir.get(node_id) {\n-                    hir_map::NodeKind::Item(&hir::Item {\n+                    NodeKind::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(ref fndecl, ..),\n                         ..\n                     }) => &fndecl,\n-                    hir_map::NodeKind::TraitItem(&hir::TraitItem {\n+                    NodeKind::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(ref m, ..),\n                         ..\n                     })\n-                    | hir_map::NodeKind::ImplItem(&hir::ImplItem {\n+                    | NodeKind::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(ref m, ..),\n                         ..\n                     }) => &m.decl,"}, {"sha": "91328858aa39e1a616c524fb4778536487b946af", "filename": "src/librustc/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -10,11 +10,12 @@\n \n //! Helper functions corresponding to lifetime errors due to\n //! anonymous regions.\n+\n use hir;\n use infer::error_reporting::nice_region_error::NiceRegionError;\n use ty::{self, Region, Ty};\n use hir::def_id::DefId;\n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use syntax_pos::Span;\n \n // The struct contains the information about the anonymous region\n@@ -137,8 +138,8 @@ impl<'a, 'gcx, 'tcx> NiceRegionError<'a, 'gcx, 'tcx> {\n             .as_local_node_id(suitable_region_binding_scope)\n             .unwrap();\n         let is_impl_item = match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeKind::Item(..)) | Some(hir_map::NodeKind::TraitItem(..)) => false,\n-            Some(hir_map::NodeKind::ImplItem(..)) => {\n+            Some(NodeKind::Item(..)) | Some(NodeKind::TraitItem(..)) => false,\n+            Some(NodeKind::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n             }\n             _ => return None,"}, {"sha": "df18294104d2def8aa4fe4ca1bc93bb862c1d12d", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -12,7 +12,7 @@\n // closely. The idea is that all reachable symbols are live, codes called\n // from live codes are live, and everything else is dead.\n \n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use hir::{self, PatKind};\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::itemlikevisit::ItemLikeVisitor;\n@@ -35,10 +35,10 @@ use syntax_pos;\n fn should_explore<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             node_id: ast::NodeId) -> bool {\n     match tcx.hir.find(node_id) {\n-        Some(hir_map::NodeKind::Item(..)) |\n-        Some(hir_map::NodeKind::ImplItem(..)) |\n-        Some(hir_map::NodeKind::ForeignItem(..)) |\n-        Some(hir_map::NodeKind::TraitItem(..)) =>\n+        Some(NodeKind::Item(..)) |\n+        Some(NodeKind::ImplItem(..)) |\n+        Some(NodeKind::ForeignItem(..)) |\n+        Some(NodeKind::TraitItem(..)) =>\n             true,\n         _ =>\n             false\n@@ -145,13 +145,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_node(&mut self, node: &hir_map::NodeKind<'tcx>) {\n+    fn visit_node(&mut self, node: &NodeKind<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n         match *node {\n-            hir_map::NodeKind::Item(item) => {\n+            NodeKind::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -173,13 +173,13 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                     _ => ()\n                 }\n             }\n-            hir_map::NodeKind::TraitItem(trait_item) => {\n+            NodeKind::TraitItem(trait_item) => {\n                 intravisit::walk_trait_item(self, trait_item);\n             }\n-            hir_map::NodeKind::ImplItem(impl_item) => {\n+            NodeKind::ImplItem(impl_item) => {\n                 intravisit::walk_impl_item(self, impl_item);\n             }\n-            hir_map::NodeKind::ForeignItem(foreign_item) => {\n+            NodeKind::ForeignItem(foreign_item) => {\n                 intravisit::walk_foreign_item(self, &foreign_item);\n             }\n             _ => ()"}, {"sha": "bd8de7b2e435c2cd934d23ac30b2081f100b2169", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -102,11 +102,13 @@\n //!   only dead if the end of the function's block can never be reached.\n //!   It is the responsibility of typeck to ensure that there are no\n //!   `return` expressions in a function declared as diverging.\n+\n use self::LoopKind::*;\n use self::LiveNodeKind::*;\n use self::VarKind::*;\n \n use hir::def::*;\n+use hir::map::NodeKind;\n use ty::{self, TyCtxt};\n use lint;\n use errors::Applicability;\n@@ -362,7 +364,7 @@ fn visit_fn<'a, 'tcx: 'a>(ir: &mut IrMaps<'a, 'tcx>,\n     // Don't run unused pass for #[derive()]\n     if let FnKind::Method(..) = fk {\n         let parent = ir.tcx.hir.get_parent(id);\n-        if let Some(hir::map::NodeKind::Item(i)) = ir.tcx.hir.find(parent) {\n+        if let Some(NodeKind::Item(i)) = ir.tcx.hir.find(parent) {\n             if i.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n                 return;\n             }"}, {"sha": "ad7371d6220f84a5fff7d246341e5afd06adc22d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -70,7 +70,7 @@ use self::Aliasability::*;\n \n use middle::region;\n use hir::def_id::{DefId, LocalDefId};\n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use infer::InferCtxt;\n use hir::def::{Def, CtorKind};\n use ty::adjustment;\n@@ -343,7 +343,7 @@ impl MutabilityCategory {\n \n     fn from_local(tcx: TyCtxt, tables: &ty::TypeckTables, id: ast::NodeId) -> MutabilityCategory {\n         let ret = match tcx.hir.get(id) {\n-            hir_map::NodeKind::Binding(p) => match p.node {\n+            NodeKind::Binding(p) => match p.node {\n                 PatKind::Binding(..) => {\n                     let bm = *tables.pat_binding_modes()\n                                     .get(p.hir_id)"}, {"sha": "6edbd4eafbbaecf300ca6c700c0136f50b443b4e", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -16,7 +16,7 @@\n // reachable as well.\n \n use hir::{CodegenFnAttrs, CodegenFnAttrFlags};\n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use hir::def::Def;\n use hir::def_id::{DefId, CrateNum};\n use rustc_data_structures::sync::Lrc;\n@@ -64,7 +64,7 @@ fn method_might_be_inlined<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n     if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_src) {\n         match tcx.hir.find(impl_node_id) {\n-            Some(hir_map::NodeKind::Item(item)) =>\n+            Some(NodeKind::Item(item)) =>\n                 item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n             Some(..) | None =>\n                 span_bug!(impl_item.span, \"impl did is not an item\")\n@@ -156,22 +156,22 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         };\n \n         match self.tcx.hir.find(node_id) {\n-            Some(hir_map::NodeKind::Item(item)) => {\n+            Some(NodeKind::Item(item)) => {\n                 match item.node {\n                     hir::ItemKind::Fn(..) =>\n                         item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id)),\n                     _ => false,\n                 }\n             }\n-            Some(hir_map::NodeKind::TraitItem(trait_method)) => {\n+            Some(NodeKind::TraitItem(trait_method)) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, ref default) => default.is_some(),\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Provided(_)) => true,\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) |\n                     hir::TraitItemKind::Type(..) => false,\n                 }\n             }\n-            Some(hir_map::NodeKind::ImplItem(impl_item)) => {\n+            Some(NodeKind::ImplItem(impl_item)) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(..) => true,\n                     hir::ImplItemKind::Method(..) => {\n@@ -219,12 +219,12 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n     }\n \n-    fn propagate_node(&mut self, node: &hir_map::NodeKind<'tcx>,\n+    fn propagate_node(&mut self, node: &NodeKind<'tcx>,\n                       search_item: ast::NodeId) {\n         if !self.any_library {\n             // If we are building an executable, only explicitly extern\n             // types need to be exported.\n-            if let hir_map::NodeKind::Item(item) = *node {\n+            if let NodeKind::Item(item) = *node {\n                 let reachable = if let hir::ItemKind::Fn(_, header, ..) = item.node {\n                     header.abi != Abi::Rust\n                 } else {\n@@ -248,7 +248,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         }\n \n         match *node {\n-            hir_map::NodeKind::Item(item) => {\n+            NodeKind::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Fn(.., body) => {\n                         let def_id = self.tcx.hir.local_def_id(item.id);\n@@ -285,7 +285,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ItemKind::GlobalAsm(..) => {}\n                 }\n             }\n-            hir_map::NodeKind::TraitItem(trait_method) => {\n+            NodeKind::TraitItem(trait_method) => {\n                 match trait_method.node {\n                     hir::TraitItemKind::Const(_, None) |\n                     hir::TraitItemKind::Method(_, hir::TraitMethod::Required(_)) => {\n@@ -298,7 +298,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::TraitItemKind::Type(..) => {}\n                 }\n             }\n-            hir_map::NodeKind::ImplItem(impl_item) => {\n+            NodeKind::ImplItem(impl_item) => {\n                 match impl_item.node {\n                     hir::ImplItemKind::Const(_, body) => {\n                         self.visit_nested_body(body);\n@@ -313,16 +313,16 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     hir::ImplItemKind::Type(_) => {}\n                 }\n             }\n-            hir_map::NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n+            NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Closure(.., body, _, _), .. }) => {\n                 self.visit_nested_body(body);\n             }\n             // Nothing to recurse on for these\n-            hir_map::NodeKind::ForeignItem(_) |\n-            hir_map::NodeKind::Variant(_) |\n-            hir_map::NodeKind::StructCtor(_) |\n-            hir_map::NodeKind::Field(_) |\n-            hir_map::NodeKind::Ty(_) |\n-            hir_map::NodeKind::MacroDef(_) => {}\n+            NodeKind::ForeignItem(_) |\n+            NodeKind::Variant(_) |\n+            NodeKind::StructCtor(_) |\n+            NodeKind::Field(_) |\n+            NodeKind::Ty(_) |\n+            NodeKind::MacroDef(_) => {}\n             _ => {\n                 bug!(\"found unexpected thingy in worklist: {}\",\n                      self.tcx.hir.node_to_string(search_item))"}, {"sha": "f6ab2b925b3c576b12e0a30dd05b326b26f2c302", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -30,6 +30,7 @@ use ty::TyCtxt;\n use ty::query::Providers;\n \n use hir;\n+use hir::map::NodeKind;\n use hir::def_id::DefId;\n use hir::intravisit::{self, Visitor, NestedVisitorMap};\n use hir::{Block, Arm, Pat, PatKind, Stmt, Expr, Local};\n@@ -257,7 +258,7 @@ impl Scope {\n         }\n         let span = tcx.hir.span(node_id);\n         if let ScopeData::Remainder(r) = self.data() {\n-            if let hir::map::NodeKind::Block(ref blk) = tcx.hir.get(node_id) {\n+            if let NodeKind::Block(ref blk) = tcx.hir.get(node_id) {\n                 // Want span for scope starting after the\n                 // indexed statement and ending at end of\n                 // `blk`; reuse span of `blk` and shift `lo`\n@@ -1420,8 +1421,8 @@ fn region_scope_tree<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId)\n         // record its impl/trait parent, as it can also have\n         // lifetime parameters free in this body.\n         match tcx.hir.get(id) {\n-            hir::map::NodeKind::ImplItem(_) |\n-            hir::map::NodeKind::TraitItem(_) => {\n+            NodeKind::ImplItem(_) |\n+            NodeKind::TraitItem(_) => {\n                 visitor.scope_tree.root_parent = Some(tcx.hir.get_parent(id));\n             }\n             _ => {}"}, {"sha": "d0daf6b5b184334c0ef2cec472207df1f712aed2", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -17,7 +17,7 @@\n \n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use hir::map::Map;\n+use hir::map::{NodeKind, Map};\n use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName};\n use ty::{self, TyCtxt, GenericParamDefKind};\n \n@@ -1440,10 +1440,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeKind::Lifetime(hir_lifetime) => {\n+                        NodeKind::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeKind::GenericParam(param) => {\n+                        NodeKind::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1466,10 +1466,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        hir::map::NodeKind::Lifetime(hir_lifetime) => {\n+                        NodeKind::Lifetime(hir_lifetime) => {\n                             Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n                         }\n-                        hir::map::NodeKind::GenericParam(param) => {\n+                        NodeKind::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n                         _ => None,\n@@ -1643,15 +1643,15 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             } else if let Some(body_id) = outermost_body {\n                 let fn_id = self.tcx.hir.body_owner(body_id);\n                 match self.tcx.hir.get(fn_id) {\n-                    hir::map::NodeKind::Item(&hir::Item {\n+                    NodeKind::Item(&hir::Item {\n                         node: hir::ItemKind::Fn(..),\n                         ..\n                     })\n-                    | hir::map::NodeKind::TraitItem(&hir::TraitItem {\n+                    | NodeKind::TraitItem(&hir::TraitItem {\n                         node: hir::TraitItemKind::Method(..),\n                         ..\n                     })\n-                    | hir::map::NodeKind::ImplItem(&hir::ImplItem {\n+                    | NodeKind::ImplItem(&hir::ImplItem {\n                         node: hir::ImplItemKind::Method(..),\n                         ..\n                     }) => {\n@@ -1868,12 +1868,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let parent = self.tcx.hir.get_parent_node(output.id);\n         let body = match self.tcx.hir.get(parent) {\n             // `fn` definitions and methods.\n-            hir::map::NodeKind::Item(&hir::Item {\n+            NodeKind::Item(&hir::Item {\n                 node: hir::ItemKind::Fn(.., body),\n                 ..\n             }) => Some(body),\n \n-            hir::map::NodeKind::TraitItem(&hir::TraitItem {\n+            NodeKind::TraitItem(&hir::TraitItem {\n                 node: hir::TraitItemKind::Method(_, ref m),\n                 ..\n             }) => {\n@@ -1896,7 +1896,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n \n-            hir::map::NodeKind::ImplItem(&hir::ImplItem {\n+            NodeKind::ImplItem(&hir::ImplItem {\n                 node: hir::ImplItemKind::Method(_, body),\n                 ..\n             }) => {\n@@ -1918,7 +1918,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n \n             // Foreign functions, `fn(...) -> R` and `Trait(...) -> R` (both types and bounds).\n-            hir::map::NodeKind::ForeignItem(_) | hir::map::NodeKind::Ty(_) | hir::map::NodeKind::TraitRef(_) => None,\n+            NodeKind::ForeignItem(_) | NodeKind::Ty(_) | NodeKind::TraitRef(_) => None,\n             // Everything else (only closures?) doesn't\n             // actually enjoy elision in return types.\n             _ => {"}, {"sha": "bbd02ebea5bb667d0519f45ec49336dfbe8fd8f6", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -29,6 +29,7 @@ use super::{\n \n use errors::{Applicability, DiagnosticBuilder};\n use hir;\n+use hir::map::NodeKind;\n use hir::def_id::DefId;\n use infer::{self, InferCtxt};\n use infer::type_variable::TypeVariableOrigin;\n@@ -864,7 +865,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                        err: &mut DiagnosticBuilder<'tcx>) {\n         if let &ObligationCauseCode::VariableType(node_id) = code {\n             let parent_node = self.tcx.hir.get_parent_node(node_id);\n-            if let Some(hir::map::NodeKind::Local(ref local)) = self.tcx.hir.find(parent_node) {\n+            if let Some(NodeKind::Local(ref local)) = self.tcx.hir.find(parent_node) {\n                 if let Some(ref expr) = local.init {\n                     if let hir::ExprKind::Index(_, _) = expr.node {\n                         if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(expr.span) {\n@@ -932,9 +933,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     /// returns a span and `ArgKind` information that describes the\n     /// arguments it expects. This can be supplied to\n     /// `report_arg_count_mismatch`.\n-    pub fn get_fn_like_arguments(&self, node: hir::map::NodeKind) -> (Span, Vec<ArgKind>) {\n+    pub fn get_fn_like_arguments(&self, node: NodeKind) -> (Span, Vec<ArgKind>) {\n         match node {\n-            hir::map::NodeKind::Expr(&hir::Expr {\n+            NodeKind::Expr(&hir::Expr {\n                 node: hir::ExprKind::Closure(_, ref _decl, id, span, _),\n                 ..\n             }) => {\n@@ -961,17 +962,17 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     })\n                     .collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeKind::Item(&hir::Item {\n+            NodeKind::Item(&hir::Item {\n                 span,\n                 node: hir::ItemKind::Fn(ref decl, ..),\n                 ..\n             }) |\n-            hir::map::NodeKind::ImplItem(&hir::ImplItem {\n+            NodeKind::ImplItem(&hir::ImplItem {\n                 span,\n                 node: hir::ImplItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n             }) |\n-            hir::map::NodeKind::TraitItem(&hir::TraitItem {\n+            NodeKind::TraitItem(&hir::TraitItem {\n                 span,\n                 node: hir::TraitItemKind::Method(hir::MethodSig { ref decl, .. }, _),\n                 ..\n@@ -987,7 +988,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                     _ => ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned())\n                 }).collect::<Vec<ArgKind>>())\n             }\n-            hir::map::NodeKind::Variant(&hir::Variant {\n+            NodeKind::Variant(&hir::Variant {\n                 span,\n                 node: hir::VariantKind {\n                     data: hir::VariantData::Tuple(ref fields, _),\n@@ -1000,7 +1001,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                      ArgKind::Arg(field.ident.to_string(), \"_\".to_string())\n                  }).collect::<Vec<_>>())\n             }\n-            hir::map::NodeKind::StructCtor(ref variant_data) => {\n+            NodeKind::StructCtor(ref variant_data) => {\n                 (self.tcx.sess.source_map().def_span(self.tcx.hir.span(variant_data.id())),\n                  variant_data.fields()\n                     .iter().map(|_| ArgKind::Arg(\"_\".to_owned(), \"_\".to_owned()))"}, {"sha": "45fd137c0e893d01814c89d18c1b94e3017a3e92", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -15,6 +15,7 @@ pub use self::IntVarValue::*;\n pub use self::fold::TypeFoldable;\n \n use hir::{map as hir_map, FreevarMap, TraitMap};\n+use hir::map::NodeKind;\n use hir::def::{Def, CtorKind, ExportMap};\n use hir::def_id::{CrateNum, DefId, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use hir::map::DefPathData;\n@@ -2478,7 +2479,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n     pub fn expr_span(self, id: NodeId) -> Span {\n         match self.hir.find(id) {\n-            Some(hir_map::NodeKind::Expr(e)) => {\n+            Some(NodeKind::Expr(e)) => {\n                 e.span\n             }\n             Some(f) => {\n@@ -2505,7 +2506,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     pub fn opt_associated_item(self, def_id: DefId) -> Option<AssociatedItem> {\n         let is_associated_item = if let Some(node_id) = self.hir.as_local_node_id(def_id) {\n             match self.hir.get(node_id) {\n-                hir_map::NodeKind::TraitItem(_) | hir_map::NodeKind::ImplItem(_) => true,\n+                NodeKind::TraitItem(_) | NodeKind::ImplItem(_) => true,\n                 _ => false,\n             }\n         } else {\n@@ -2895,7 +2896,7 @@ fn trait_of_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Option\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition\n pub fn is_impl_trait_defn(tcx: TyCtxt, def_id: DefId) -> Option<DefId> {\n     if let Some(node_id) = tcx.hir.as_local_node_id(def_id) {\n-        if let hir::map::NodeKind::Item(item) = tcx.hir.get(node_id) {\n+        if let NodeKind::Item(item) = tcx.hir.get(node_id) {\n             if let hir::ItemKind::Existential(ref exist_ty) = item.node {\n                 return exist_ty.impl_trait_fn;\n             }"}, {"sha": "11e2b2255651991d90fd5622ae671852bdae5e1b", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -16,6 +16,7 @@\n // 2. loans made in overlapping scopes do not conflict\n // 3. assignments do not affect things loaned out as immutable\n // 4. moves do not affect things loaned out in any way\n+\n use self::UseError::*;\n \n use borrowck::*;\n@@ -29,6 +30,7 @@ use rustc::ty::{self, TyCtxt, RegionKind};\n use syntax::ast;\n use syntax_pos::Span;\n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc_mir::util::borrowck_errors::{BorrowckErrors, Origin};\n \n use std::rc::Rc;\n@@ -201,7 +203,7 @@ pub fn check_loans<'a, 'b, 'c, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n \n     let node_id = bccx.tcx.hir.as_local_node_id(def_id).unwrap();\n     let movable_generator = !match bccx.tcx.hir.get(node_id) {\n-        hir::map::NodeKind::Expr(&hir::Expr {\n+        NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => true,"}, {"sha": "edcc2400ecf50b64ec3616592d08792ee1dbc8e9", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -21,7 +21,7 @@ pub use self::MovedValueUseKind::*;\n use self::InteriorKind::*;\n \n use rustc::hir::HirId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::map::blocks::FnLikeNode;\n use rustc::cfg;\n use rustc::middle::borrowck::{BorrowCheckResult, SignalledError};\n@@ -95,8 +95,8 @@ fn borrowck<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, owner_def_id: DefId)\n     let owner_id = tcx.hir.as_local_node_id(owner_def_id).unwrap();\n \n     match tcx.hir.get(owner_id) {\n-        hir_map::NodeKind::StructCtor(_) |\n-        hir_map::NodeKind::Variant(_) => {\n+        NodeKind::StructCtor(_) |\n+        NodeKind::Variant(_) => {\n             // We get invoked with anything that has MIR, but some of\n             // those things (notably the synthesized constructors from\n             // tuple structs/variants) do not have an associated body\n@@ -419,7 +419,7 @@ fn closure_to_block(closure_id: LocalDefId,\n                     tcx: TyCtxt) -> ast::NodeId {\n     let closure_id = tcx.hir.local_def_id_to_node_id(closure_id);\n     match tcx.hir.get(closure_id) {\n-        hir_map::NodeKind::Expr(expr) => match expr.node {\n+        NodeKind::Expr(expr) => match expr.node {\n             hir::ExprKind::Closure(.., body_id, _, _) => {\n                 body_id.node_id\n             }\n@@ -908,7 +908,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     let node =  self.tcx.hir.get(node_id);\n \n                     // This pattern probably always matches.\n-                    if let hir_map::NodeKind::Expr(\n+                    if let NodeKind::Expr(\n                         hir::Expr { node: hir::ExprKind::Index(lhs, _), ..}\n                     ) = node {\n                         let ty = self.tables.expr_ty(lhs);\n@@ -1032,7 +1032,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 if let ty::ReScope(scope) = *super_scope {\n                     let node_id = scope.node_id(self.tcx, &self.region_scope_tree);\n                     match self.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeKind::Stmt(_)) => {\n+                        Some(NodeKind::Stmt(_)) => {\n                             if *sub_scope != ty::ReStatic {\n                                 db.note(\"consider using a `let` binding to increase its lifetime\");\n                             }\n@@ -1183,7 +1183,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n     fn local_binding_mode(&self, node_id: ast::NodeId) -> ty::BindingMode {\n         let pat = match self.tcx.hir.get(node_id) {\n-            hir_map::NodeKind::Binding(pat) => pat,\n+            NodeKind::Binding(pat) => pat,\n             node => bug!(\"bad node for local: {:?}\", node)\n         };\n \n@@ -1259,7 +1259,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     None => return\n                 };\n \n-                if let hir_map::NodeKind::Field(ref field) = self.tcx.hir.get(node_id) {\n+                if let NodeKind::Field(ref field) = self.tcx.hir.get(node_id) {\n                     if let Some(msg) = self.suggest_mut_for_immutable(&field.ty, false) {\n                         db.span_label(field.ty.span, msg);\n                     }"}, {"sha": "dd687890ff1ae00c8a5275dff05c4ade6f5f8064", "filename": "src/librustc_codegen_llvm/back/symbol_export.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fsymbol_export.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -13,6 +13,7 @@ use std::sync::Arc;\n \n use monomorphize::Instance;\n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE, CRATE_DEF_INDEX};\n use rustc_data_structures::fingerprint::Fingerprint;\n@@ -94,7 +95,7 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n             match tcx.hir.get(node_id) {\n-                hir::map::NodeKind::ForeignItem(..) => {\n+                NodeKind::ForeignItem(..) => {\n                     let def_id = tcx.hir.local_def_id(node_id);\n                     if tcx.is_statically_included_foreign_item(def_id) {\n                         Some(def_id)\n@@ -104,14 +105,14 @@ fn reachable_non_generics_provider<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                 }\n \n                 // Only consider nodes that actually have exported symbols.\n-                hir::map::NodeKind::Item(&hir::Item {\n+                NodeKind::Item(&hir::Item {\n                     node: hir::ItemKind::Static(..),\n                     ..\n                 }) |\n-                hir::map::NodeKind::Item(&hir::Item {\n+                NodeKind::Item(&hir::Item {\n                     node: hir::ItemKind::Fn(..), ..\n                 }) |\n-                hir::map::NodeKind::ImplItem(&hir::ImplItem {\n+                NodeKind::ImplItem(&hir::ImplItem {\n                     node: hir::ImplItemKind::Method(..),\n                     ..\n                 }) => {"}, {"sha": "921d70e7118b2a73721a8f134f58c51235d4662f", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -11,7 +11,7 @@\n use libc::c_uint;\n use llvm::{self, SetUnnamedAddr, True};\n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use debuginfo;\n use base;\n use monomorphize::MonoItem;\n@@ -135,7 +135,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n \n         let llty = cx.layout_of(ty).llvm_type(cx);\n         let (g, attrs) = match cx.tcx.hir.get(id) {\n-            hir_map::NodeKind::Item(&hir::Item {\n+            NodeKind::Item(&hir::Item {\n                 ref attrs, span, node: hir::ItemKind::Static(..), ..\n             }) => {\n                 if declare::get_declared_value(cx, &sym[..]).is_some() {\n@@ -153,7 +153,7 @@ pub fn get_static(cx: &CodegenCx<'ll, '_>, def_id: DefId) -> &'ll Value {\n                 (g, attrs)\n             }\n \n-            hir_map::NodeKind::ForeignItem(&hir::ForeignItem {\n+            NodeKind::ForeignItem(&hir::ForeignItem {\n                 ref attrs, span, node: hir::ForeignItemKind::Static(..), ..\n             }) => {\n                 let fn_attrs = cx.tcx.codegen_fn_attrs(def_id);"}, {"sha": "de081f5f3cf1e8a02bb473b0e3a93acedec1cf9d", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -98,7 +98,7 @@\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::CodegenFnAttrFlags;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::ich::NodeIdHashingMode;\n@@ -261,7 +261,7 @@ fn compute_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance: Instance\n     // FIXME(eddyb) Precompute a custom symbol name based on attributes.\n     let is_foreign = if let Some(id) = node_id {\n         match tcx.hir.get(id) {\n-            hir_map::NodeKind::ForeignItem(_) => true,\n+            NodeKind::ForeignItem(_) => true,\n             _ => false,\n         }\n     } else {"}, {"sha": "fd02641444492eea444b4f6c42ac4f908348cfae", "filename": "src/librustc_incremental/persist/dirty_clean.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fdirty_clean.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -399,7 +399,8 @@ impl<'a, 'tcx> DirtyCleanVisitor<'a, 'tcx> {\n                     _ => self.tcx.sess.span_fatal(\n                         attr.span,\n                         &format!(\n-                            \"clean/dirty auto-assertions not yet defined for NodeKind::Item.node={:?}\",\n+                            \"clean/dirty auto-assertions not yet defined \\\n+                             for NodeKind::Item.node={:?}\",\n                             item.node\n                         )\n                     ),"}, {"sha": "9353587addeb2cd745802811709aea3ca2777645", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -34,7 +34,7 @@ use rustc::cfg;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty};\n use rustc::traits;\n-use rustc::hir::map as hir_map;\n+use hir::map::NodeKind;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n use lint::{LintPass, LateLintPass, EarlyLintPass, EarlyContext};\n@@ -427,7 +427,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                 let real_trait = trait_ref.path.def.def_id();\n                 if let Some(node_id) = cx.tcx.hir.as_local_node_id(real_trait) {\n                     match cx.tcx.hir.find(node_id) {\n-                        Some(hir_map::NodeKind::Item(item)) => {\n+                        Some(NodeKind::Item(item)) => {\n                             if let hir::VisibilityKind::Inherited = item.vis.node {\n                                 for impl_item_ref in impl_item_refs {\n                                     self.private_traits.insert(impl_item_ref.id.node_id);\n@@ -981,7 +981,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n \n         fn expr_refers_to_this_fn(cx: &LateContext, fn_id: ast::NodeId, id: ast::NodeId) -> bool {\n             match cx.tcx.hir.get(id) {\n-                hir_map::NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n+                NodeKind::Expr(&hir::Expr { node: hir::ExprKind::Call(ref callee, _), .. }) => {\n                     let def = if let hir::ExprKind::Path(ref qpath) = callee.node {\n                         cx.tables.qpath_def(qpath, callee.hir_id)\n                     } else {\n@@ -1004,7 +1004,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnconditionalRecursion {\n             use rustc::ty::adjustment::*;\n \n             // Ignore non-expressions.\n-            let expr = if let hir_map::NodeKind::Expr(e) = cx.tcx.hir.get(id) {\n+            let expr = if let NodeKind::Expr(e) = cx.tcx.hir.get(id) {\n                 e\n             } else {\n                 return false;\n@@ -1864,7 +1864,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestFunctions {\n                     if attr.name() == \"test\" {\n                         let parent = cx.tcx.hir.get_parent(it.id);\n                         match cx.tcx.hir.find(parent) {\n-                            Some(hir_map::NodeKind::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n+                            Some(NodeKind::Item(hir::Item {node: hir::ItemKind::Mod(_), ..})) |\n                             None => {}\n                             _ => {\n                                 cx.struct_span_lint("}, {"sha": "db590f424464c191afc8bd9fe0c48cab27d292fb", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -10,7 +10,7 @@\n \n #![allow(non_snake_case)]\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf};\n@@ -137,7 +137,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                         };\n                         if lit_val < min || lit_val > max {\n                             let parent_id = cx.tcx.hir.get_parent_node(e.id);\n-                            if let hir_map::NodeKind::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n+                            if let NodeKind::Expr(parent_expr) = cx.tcx.hir.get(parent_id) {\n                                 if let hir::ExprKind::Cast(..) = parent_expr.node {\n                                     if let ty::Char = cx.tables.expr_ty(parent_expr).sty {\n                                         let mut err = cx.struct_span_lint("}, {"sha": "2b21187a97459bf05fb154cca453607fd9810c5d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -12,6 +12,7 @@\n \n use borrow_check::nll::region_infer::RegionInferenceContext;\n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::definitions::DefPathData;\n use rustc::infer::InferCtxt;\n@@ -232,7 +233,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n     ));\n \n     let movable_generator = match tcx.hir.get(id) {\n-        hir::map::NodeKind::Expr(&hir::Expr {\n+        NodeKind::Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(.., Some(hir::GeneratorMovability::Static)),\n             ..\n         }) => false,"}, {"sha": "110bc9f773daa2684dfc713cccd2f3512524b96e", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc::mir::{self, BindingForm, ClearCrossCrate, Local, Location, Mir};\n use rustc::mir::{Mutability, Place, Projection, ProjectionElem, Static};\n use rustc::ty::{self, TyCtxt};\n@@ -246,7 +247,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                     .var_hir_id\n                     .assert_crate_local();\n                 let upvar_node_id = self.tcx.hir.hir_to_node_id(upvar_hir_id);\n-                if let Some(hir::map::NodeKind::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n+                if let Some(NodeKind::Binding(pat)) = self.tcx.hir.find(upvar_node_id) {\n                     if let hir::PatKind::Binding(\n                         hir::BindingAnnotation::Unannotated,\n                         _,"}, {"sha": "6535d6310b17cbca24becc775082888eac0cc082", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -14,6 +14,7 @@ use build::scope::{CachedBlock, DropKind};\n use hair::cx::Cx;\n use hair::{LintLevel, BindingMode, PatternKind};\n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::{DefId, LocalDefId};\n use rustc::middle::region;\n use rustc::mir::*;\n@@ -40,9 +41,9 @@ pub fn mir_build<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> Mir<'t\n \n     // Figure out what primary body this item has.\n     let body_id = match tcx.hir.get(id) {\n-        hir::map::NodeKind::Variant(variant) =>\n+        NodeKind::Variant(variant) =>\n             return create_constructor_shim(tcx, id, &variant.node.data),\n-        hir::map::NodeKind::StructCtor(ctor) =>\n+        NodeKind::StructCtor(ctor) =>\n             return create_constructor_shim(tcx, id, ctor),\n \n         _ => match tcx.hir.maybe_body_owned_by(id) {\n@@ -520,7 +521,7 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n                 by_ref,\n                 mutability: Mutability::Not,\n             };\n-            if let Some(hir::map::NodeKind::Binding(pat)) = tcx.hir.find(var_id) {\n+            if let Some(NodeKind::Binding(pat)) = tcx.hir.find(var_id) {\n                 if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n                     decl.debug_name = ident.name;\n "}, {"sha": "bc19b61628912520cd97580878662b5b9cfe77b3", "filename": "src/librustc_mir/hair/cx/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -19,6 +19,7 @@ use hair::*;\n use rustc_data_structures::indexed_vec::Idx;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::map::blocks::FnLikeNode;\n+use rustc::hir::map::NodeKind;\n use rustc::middle::region;\n use rustc::infer::InferCtxt;\n use rustc::ty::subst::Subst;\n@@ -202,7 +203,7 @@ impl<'a, 'gcx, 'tcx> Cx<'a, 'gcx, 'tcx> {\n     pub fn pattern_from_hir(&mut self, p: &hir::Pat) -> Pattern<'tcx> {\n         let tcx = self.tcx.global_tcx();\n         let p = match tcx.hir.get(p.id) {\n-            hir::map::NodeKind::Pat(p) | hir::map::NodeKind::Binding(p) => p,\n+            NodeKind::Pat(p) | NodeKind::Binding(p) => p,\n             node => bug!(\"pattern became {:?}\", node)\n         };\n         Pattern::from_hir(tcx,"}, {"sha": "3d5b12cd5d2f9d147ceb058348bc756029b61f8b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -191,7 +191,7 @@\n use rustc::hir::{self, CodegenFnAttrFlags};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::DefId;\n use rustc::mir::interpret::{AllocId, ConstValue, ScalarMaybeUndef};\n use rustc::middle::lang_items::{ExchangeMallocFnLangItem, StartFnLangItem};\n@@ -740,7 +740,7 @@ fn should_monomorphize_locally<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, instance:\n     };\n \n     return match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeKind::ForeignItem(..)) => {\n+        Some(NodeKind::ForeignItem(..)) => {\n             false // foreign items are linked against, not codegened.\n         }\n         Some(_) => true,"}, {"sha": "7d2a859ede68a2a33c0486ecf3f621daf60dfc56", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -15,6 +15,7 @@ use rustc_data_structures::sync::Lrc;\n use rustc::ty::query::Providers;\n use rustc::ty::{self, TyCtxt};\n use rustc::hir;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::DefId;\n use rustc::lint::builtin::{SAFE_EXTERN_STATICS, SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n use rustc::mir::*;\n@@ -407,7 +408,7 @@ fn is_enclosed(tcx: TyCtxt,\n     if parent_id != id {\n         if used_unsafe.contains(&parent_id) {\n             Some((\"block\".to_string(), parent_id))\n-        } else if let Some(hir::map::NodeKind::Item(&hir::Item {\n+        } else if let Some(NodeKind::Item(&hir::Item {\n             node: hir::ItemKind::Fn(_, header, _, _),\n             ..\n         })) = tcx.hir.find(parent_id) {"}, {"sha": "76995a4f126b8da7ea250ef950b8c805c29b917a", "filename": "src/librustc_passes/loops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_passes%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_passes%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Floops.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -11,7 +11,7 @@ use self::Context::*;\n \n use rustc::session::Session;\n \n-use rustc::hir::map::Map;\n+use rustc::hir::map::{Map, NodeKind};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n use rustc::hir::{self, Destination};\n use syntax::ast;\n@@ -115,7 +115,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 if loop_id != ast::DUMMY_NODE_ID {\n                     match self.hir_map.find(loop_id).unwrap() {\n-                        hir::map::NodeKind::Block(_) => return,\n+                        NodeKind::Block(_) => return,\n                         _=> (),\n                     }\n                 }\n@@ -158,7 +158,7 @@ impl<'a, 'hir> Visitor<'hir> for CheckLoopVisitor<'a, 'hir> {\n \n                 match label.target_id {\n                     Ok(loop_id) => {\n-                        if let hir::map::NodeKind::Block(block) = self.hir_map.find(loop_id).unwrap() {\n+                        if let NodeKind::Block(block) = self.hir_map.find(loop_id).unwrap() {\n                             struct_span_err!(self.sess, e.span, E0696,\n                                             \"`continue` pointing to a labeled block\")\n                                 .span_label(e.span,"}, {"sha": "f0a6dc966706bd3226a5bbea2ac7dfcb3cafa3ca", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -25,6 +25,7 @@ extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n use rustc::hir::{self, PatKind};\n+use hir::map::NodeKind;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, LOCAL_CRATE, CrateNum, DefId};\n use rustc::hir::intravisit::{self, Visitor, NestedVisitorMap};\n@@ -659,17 +660,17 @@ impl<'a, 'tcx> TypePrivacyVisitor<'a, 'tcx> {\n         match self.tcx.hir.as_local_node_id(did) {\n             Some(node_id) => {\n                 let vis = match self.tcx.hir.get(node_id) {\n-                    hir::map::NodeKind::Item(item) => &item.vis,\n-                    hir::map::NodeKind::ForeignItem(foreign_item) => &foreign_item.vis,\n-                    hir::map::NodeKind::ImplItem(impl_item) => &impl_item.vis,\n-                    hir::map::NodeKind::TraitItem(..) |\n-                    hir::map::NodeKind::Variant(..) => {\n+                    NodeKind::Item(item) => &item.vis,\n+                    NodeKind::ForeignItem(foreign_item) => &foreign_item.vis,\n+                    NodeKind::ImplItem(impl_item) => &impl_item.vis,\n+                    NodeKind::TraitItem(..) |\n+                    NodeKind::Variant(..) => {\n                         return self.def_id_visibility(self.tcx.hir.get_parent_did(node_id));\n                     }\n-                    hir::map::NodeKind::StructCtor(vdata) => {\n+                    NodeKind::StructCtor(vdata) => {\n                         let struct_node_id = self.tcx.hir.get_parent(node_id);\n                         let struct_vis = match self.tcx.hir.get(struct_node_id) {\n-                            hir::map::NodeKind::Item(item) => &item.vis,\n+                            NodeKind::Item(item) => &item.vis,\n                             node => bug!(\"unexpected node kind: {:?}\", node),\n                         };\n                         let mut ctor_vis\n@@ -1037,7 +1038,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n             // .. and it corresponds to a private type in the AST (this returns\n             // None for type parameters)\n             match self.tcx.hir.find(node_id) {\n-                Some(hir::map::NodeKind::Item(ref item)) => !item.vis.node.is_pub(),\n+                Some(NodeKind::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n         } else {\n@@ -1469,8 +1470,8 @@ impl<'a, 'tcx: 'a> TypeVisitor<'tcx> for SearchInterfaceForPrivateItemsVisitor<'\n             // Non-local means public (private items can't leave their crate, modulo bugs)\n             if let Some(node_id) = self.tcx.hir.as_local_node_id(def_id) {\n                 let hir_vis = match self.tcx.hir.find(node_id) {\n-                    Some(hir::map::NodeKind::Item(item)) => &item.vis,\n-                    Some(hir::map::NodeKind::ForeignItem(item)) => &item.vis,\n+                    Some(NodeKind::Item(item)) => &item.vis,\n+                    Some(NodeKind::ForeignItem(item)) => &item.vis,\n                     _ => bug!(\"expected item of foreign item\"),\n                 };\n "}, {"sha": "cfcf6afe56ae22b0997fa0d50249eb81f14d04c1", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -13,6 +13,7 @@\n \n use check::FnCtxt;\n use rustc::hir::map as hir_map;\n+use hir::map::NodeKind;\n use rustc_data_structures::sync::Lrc;\n use rustc::ty::{self, Ty, TyCtxt, ToPolyTraitRef, ToPredicate, TypeFoldable};\n use hir::def::Def;\n@@ -275,7 +276,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                         );\n \n                                         match (filename, parent_node) {\n-                                            (FileName::Real(_), hir_map::NodeKind::Local(hir::Local {\n+                                            (FileName::Real(_), NodeKind::Local(hir::Local {\n                                                 source: hir::LocalSource::Normal,\n                                                 ty,\n                                                 .."}, {"sha": "c1b4bd2ec6dba815fd60fdc186c4bd48d21258e3", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -761,7 +761,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                              -> Option<(hir::BodyId, Option<&'tcx hir::FnDecl>)>\n {\n     match tcx.hir.get(id) {\n-        hir::map::NodeKind::Item(item) => {\n+        NodeKind::Item(item) => {\n             match item.node {\n                 hir::ItemKind::Const(_, body) |\n                 hir::ItemKind::Static(_, _, body) =>\n@@ -772,7 +772,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeKind::TraitItem(item) => {\n+        NodeKind::TraitItem(item) => {\n             match item.node {\n                 hir::TraitItemKind::Const(_, Some(body)) =>\n                     Some((body, None)),\n@@ -782,7 +782,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeKind::ImplItem(item) => {\n+        NodeKind::ImplItem(item) => {\n             match item.node {\n                 hir::ImplItemKind::Const(_, body) =>\n                     Some((body, None)),\n@@ -792,7 +792,7 @@ fn primary_body_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                     None,\n             }\n         }\n-        hir::map::NodeKind::AnonConst(constant) => Some((constant.body, None)),\n+        NodeKind::AnonConst(constant) => Some((constant.body, None)),\n         _ => None,\n     }\n }"}, {"sha": "26eece11aa629cc9810d0e995ab96916d32b6025", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -23,7 +23,7 @@ use rustc::ty::util::CopyImplementationError;\n use rustc::infer;\n \n use rustc::hir::def_id::DefId;\n-use rustc::hir::map as hir_map;\n+use hir::map::NodeKind;\n use rustc::hir::{self, ItemKind};\n \n pub fn check_trait<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, trait_def_id: DefId) {\n@@ -60,7 +60,7 @@ fn visit_implementation_of_drop<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, impl_did:\n             // Destructors only work on nominal types.\n             if let Some(impl_node_id) = tcx.hir.as_local_node_id(impl_did) {\n                 match tcx.hir.find(impl_node_id) {\n-                    Some(hir_map::NodeKind::Item(item)) => {\n+                    Some(NodeKind::Item(item)) => {\n                         let span = match item.node {\n                             ItemKind::Impl(.., ref ty, _) => ty.span,\n                             _ => item.span,"}, {"sha": "b63413a74ca40d7ff3bd2bd61fd3685f12814399", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -50,10 +50,11 @@ use syntax::symbol::{keywords, Symbol};\n use syntax_pos::{Span, DUMMY_SP};\n \n use rustc::hir::def::{CtorKind, Def};\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc::hir::GenericParamKind;\n-use rustc::hir::{self, map as hir_map, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n+use rustc::hir::{self, CodegenFnAttrFlags, CodegenFnAttrs, Unsafety};\n \n ///////////////////////////////////////////////////////////////////////////\n // Main entry point\n@@ -671,7 +672,7 @@ fn super_predicates_of<'a, 'tcx>(\n     let trait_node_id = tcx.hir.as_local_node_id(trait_def_id).unwrap();\n \n     let item = match tcx.hir.get(trait_node_id) {\n-        hir_map::NodeKind::Item(item) => item,\n+        NodeKind::Item(item) => item,\n         _ => bug!(\"trait_node_id {} is not an item\", trait_node_id),\n     };\n \n@@ -740,7 +741,7 @@ fn trait_def<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> &'tcx ty::\n \n fn has_late_bound_regions<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    node: hir_map::NodeKind<'tcx>,\n+    node: NodeKind<'tcx>,\n ) -> Option<Span> {\n     struct LateBoundRegionsDetector<'a, 'tcx: 'a> {\n         tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -826,25 +827,25 @@ fn has_late_bound_regions<'a, 'tcx>(\n     }\n \n     match node {\n-        hir_map::NodeKind::TraitItem(item) => match item.node {\n+        NodeKind::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeKind::ImplItem(item) => match item.node {\n+        NodeKind::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(ref sig, _) => {\n                 has_late_bound_regions(tcx, &item.generics, &sig.decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeKind::ForeignItem(item) => match item.node {\n+        NodeKind::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(ref fn_decl, _, ref generics) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n             _ => None,\n         },\n-        hir_map::NodeKind::Item(item) => match item.node {\n+        NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Fn(ref fn_decl, .., ref generics, _) => {\n                 has_late_bound_regions(tcx, generics, fn_decl)\n             }\n@@ -1396,38 +1397,38 @@ fn find_existential_constraints<'a, 'tcx>(\n }\n \n fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig<'tcx> {\n-    use rustc::hir::map::*;\n     use rustc::hir::*;\n+    use rustc::hir::map::NodeKind::*;\n \n     let node_id = tcx.hir.as_local_node_id(def_id).unwrap();\n \n     let icx = ItemCtxt::new(tcx, def_id);\n \n     match tcx.hir.get(node_id) {\n-        NodeKind::TraitItem(hir::TraitItem {\n+        TraitItem(hir::TraitItem {\n             node: TraitItemKind::Method(sig, _),\n             ..\n         })\n-        | NodeKind::ImplItem(hir::ImplItem {\n+        | ImplItem(hir::ImplItem {\n             node: ImplItemKind::Method(sig, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, sig.header.unsafety, sig.header.abi, &sig.decl),\n \n-        NodeKind::Item(hir::Item {\n+        Item(hir::Item {\n             node: ItemKind::Fn(decl, header, _, _),\n             ..\n         }) => AstConv::ty_of_fn(&icx, header.unsafety, header.abi, decl),\n \n-        NodeKind::ForeignItem(&hir::ForeignItem {\n+        ForeignItem(&hir::ForeignItem {\n             node: ForeignItemKind::Fn(ref fn_decl, _, _),\n             ..\n         }) => {\n             let abi = tcx.hir.get_foreign_abi(node_id);\n             compute_sig_of_foreign_fn_decl(tcx, def_id, fn_decl, abi)\n         }\n \n-        NodeKind::StructCtor(&VariantData::Tuple(ref fields, _))\n-        | NodeKind::Variant(&Spanned {\n+        StructCtor(&VariantData::Tuple(ref fields, _))\n+        | Variant(&Spanned {\n             node:\n                 hir::VariantKind {\n                     data: VariantData::Tuple(ref fields, _),\n@@ -1448,7 +1449,7 @@ fn fn_sig<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::PolyFnSig\n             ))\n         }\n \n-        NodeKind::Expr(&hir::Expr {\n+        Expr(&hir::Expr {\n             node: hir::ExprKind::Closure(..),\n             ..\n         }) => {\n@@ -2027,7 +2028,7 @@ fn compute_sig_of_foreign_fn_decl<'a, 'tcx>(\n \n fn is_foreign_item<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> bool {\n     match tcx.hir.get_if_local(def_id) {\n-        Some(hir_map::NodeKind::ForeignItem(..)) => true,\n+        Some(NodeKind::ForeignItem(..)) => true,\n         Some(_) => false,\n         _ => bug!(\"is_foreign_item applied to non-local def-id {:?}\", def_id),\n     }"}, {"sha": "573b8108819020578d0f967cba23d92f07362431", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -103,7 +103,7 @@ use rustc::middle;\n use rustc::session;\n use rustc::util;\n \n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use rustc::infer::InferOk;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt};\n@@ -187,7 +187,7 @@ fn check_main_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match main_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(main_id) {\n-                Some(hir_map::NodeKind::Item(it)) => {\n+                Some(NodeKind::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;\n@@ -259,7 +259,7 @@ fn check_start_fn_ty<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match start_t.sty {\n         ty::FnDef(..) => {\n             match tcx.hir.find(start_id) {\n-                Some(hir_map::NodeKind::Item(it)) => {\n+                Some(NodeKind::Item(it)) => {\n                     match it.node {\n                         hir::ItemKind::Fn(.., ref generics, _) => {\n                             let mut error = false;"}, {"sha": "ff8a7fa73a527df1182488e4c332d9c5552e64f0", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -9,6 +9,7 @@\n // except according to those terms.\n \n use rustc::hir;\n+use hir::map::NodeKind;\n use rustc::hir::def_id::DefId;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ty::subst::{Kind, Subst, UnpackedKind};\n@@ -70,7 +71,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n             .as_local_node_id(item_did)\n             .expect(\"expected local def-id\");\n         let item = match self.tcx.hir.get(node_id) {\n-            hir::map::NodeKind::Item(item) => item,\n+            NodeKind::Item(item) => item,\n             _ => bug!(),\n         };\n "}, {"sha": "b00ae988c3f0833fa613ba877389840d2f999c1f", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use hir::map as hir_map;\n+use hir::map::NodeKind;\n use rustc::hir;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::query::Providers;\n@@ -40,7 +40,7 @@ fn inferred_outlives_of<'a, 'tcx>(\n         .expect(\"expected local def-id\");\n \n     match tcx.hir.get(id) {\n-        hir_map::NodeKind::Item(item) => match item.node {\n+        NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Struct(..) | hir::ItemKind::Enum(..) | hir::ItemKind::Union(..) => {\n                 let crate_map = tcx.inferred_outlives_crate(LOCAL_CRATE);\n "}, {"sha": "54fe784a7e1d12e2e315da67f2df40fc7f83505f", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -15,6 +15,7 @@\n \n use arena;\n use rustc::hir;\n+use hir::map::NodeKind;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::ty::{self, CrateVariancesMap, TyCtxt};\n use rustc::ty::query::Providers;\n@@ -61,7 +62,7 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n         span_bug!(tcx.hir.span(id), \"asked to compute variance for wrong kind of item\")\n     };\n     match tcx.hir.get(id) {\n-        hir::map::NodeKind::Item(item) => match item.node {\n+        NodeKind::Item(item) => match item.node {\n             hir::ItemKind::Enum(..) |\n             hir::ItemKind::Struct(..) |\n             hir::ItemKind::Union(..) |\n@@ -70,25 +71,25 @@ fn variances_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, item_def_id: DefId)\n             _ => unsupported()\n         },\n \n-        hir::map::NodeKind::TraitItem(item) => match item.node {\n+        NodeKind::TraitItem(item) => match item.node {\n             hir::TraitItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeKind::ImplItem(item) => match item.node {\n+        NodeKind::ImplItem(item) => match item.node {\n             hir::ImplItemKind::Method(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeKind::ForeignItem(item) => match item.node {\n+        NodeKind::ForeignItem(item) => match item.node {\n             hir::ForeignItemKind::Fn(..) => {}\n \n             _ => unsupported()\n         },\n \n-        hir::map::NodeKind::Variant(_) | hir::map::NodeKind::StructCtor(_) => {}\n+        NodeKind::Variant(_) | NodeKind::StructCtor(_) => {}\n \n         _ => unsupported()\n     }"}, {"sha": "324085e37e1820bb3338139652908e985fb910f7", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -18,7 +18,7 @@ use syntax::attr;\n use syntax::source_map::Spanned;\n use syntax_pos::{self, Span};\n \n-use rustc::hir::map as hir_map;\n+use rustc::hir::map::NodeKind;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::middle::privacy::AccessLevel;\n@@ -295,7 +295,7 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n         if !self.view_item_stack.insert(def_node_id) { return false }\n \n         let ret = match tcx.hir.get(def_node_id) {\n-            hir_map::NodeKind::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n+            NodeKind::Item(&hir::Item { node: hir::ItemKind::Mod(ref m), .. }) if glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 for i in &m.item_ids {\n                     let i = self.cx.tcx.hir.expect_item(i.id);\n@@ -304,13 +304,13 @@ impl<'a, 'tcx, 'rcx, 'cstore> RustdocVisitor<'a, 'tcx, 'rcx, 'cstore> {\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeKind::Item(it) if !glob => {\n+            NodeKind::Item(it) if !glob => {\n                 let prev = mem::replace(&mut self.inlining, true);\n                 self.visit_item(it, renamed, om);\n                 self.inlining = prev;\n                 true\n             }\n-            hir_map::NodeKind::ForeignItem(it) if !glob => {\n+            NodeKind::ForeignItem(it) if !glob => {\n                 // generate a fresh `extern {}` block if we want to inline a foreign item.\n                 om.foreigns.push(hir::ForeignMod {\n                     abi: tcx.hir.get_foreign_abi(it.id),"}, {"sha": "0dcd83fa3bbacd7a8a25dcbc246d02f9682c0fc4", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/issue-40001-plugin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/11665ca45a4eb7745026040e840aef3207d5c7ce/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fissue-40001-plugin.rs?ref=11665ca45a4eb7745026040e840aef3207d5c7ce", "patch": "@@ -27,6 +27,7 @@ use syntax::symbol::Symbol;\n use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::hir::map as hir_map;\n+use hir::map::NodeKind;\n use rustc::lint::{LateContext, LintPass, LintArray, LateLintPass, LintContext};\n use rustc::ty;\n use syntax::{ast, source_map};\n@@ -58,7 +59,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingWhitelistedAttrPass {\n                 id: ast::NodeId) {\n \n         let item = match cx.tcx.hir.get(id) {\n-            hir_map::NodeKind::Item(item) => item,\n+            NodeKind::Item(item) => item,\n             _ => cx.tcx.hir.expect_item(cx.tcx.hir.get_parent(id)),\n         };\n "}]}