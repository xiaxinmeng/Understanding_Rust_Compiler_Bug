{"sha": "5d5634ace087addc6f1d09b55643f97162a4f031", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNTYzNGFjZTA4N2FkZGM2ZjFkMDliNTU2NDNmOTcxNjJhNGYwMzE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T10:01:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-03-25T10:01:48Z"}, "message": "auto merge of #13083 : FlaPer87/rust/issue-13005-borrow-unsafe-static, r=nikomatsakis\n\nIt was possible to borrow unsafe static items in static initializers.\r\nThis patch implements a small `Visitor` that walks static initializer's\r\nexpressions and checks borrows aliasability.\r\n\r\nFixes #13005\r\n\r\ncc @nikomatsakis r?", "tree": {"sha": "aa844738286fa1c64872a58625a6db339104d9fc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aa844738286fa1c64872a58625a6db339104d9fc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d5634ace087addc6f1d09b55643f97162a4f031", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d5634ace087addc6f1d09b55643f97162a4f031", "html_url": "https://github.com/rust-lang/rust/commit/5d5634ace087addc6f1d09b55643f97162a4f031", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d5634ace087addc6f1d09b55643f97162a4f031/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b1091c3141f2285fa9620c9e4df3fb86d911c5f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b1091c3141f2285fa9620c9e4df3fb86d911c5f6", "html_url": "https://github.com/rust-lang/rust/commit/b1091c3141f2285fa9620c9e4df3fb86d911c5f6"}, {"sha": "9021a3f988ca134f52ca8b7d6a06952d46a38722", "url": "https://api.github.com/repos/rust-lang/rust/commits/9021a3f988ca134f52ca8b7d6a06952d46a38722", "html_url": "https://github.com/rust-lang/rust/commit/9021a3f988ca134f52ca8b7d6a06952d46a38722"}], "stats": {"total": 174, "additions": 100, "deletions": 74}, "files": [{"sha": "a6409131bed8609d34b09e3a7ea4abfc3550c726", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 93, "deletions": 74, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/5d5634ace087addc6f1d09b55643f97162a4f031/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5634ace087addc6f1d09b55643f97162a4f031/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5d5634ace087addc6f1d09b55643f97162a4f031", "patch": "@@ -161,29 +161,6 @@ fn gather_loans_in_local(this: &mut GatherLoanCtxt,\n     visit::walk_local(this, local, ());\n }\n \n-pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n-\n-    debug!(\"gather_loans_in_item(expr={})\", expr.repr(bccx.tcx));\n-\n-    let mut glcx = GatherLoanCtxt {\n-        bccx: bccx,\n-        id_range: IdRange::max(),\n-        all_loans: Vec::new(),\n-        item_ub: expr.id,\n-        repeating_ids: vec!(expr.id),\n-        move_data: MoveData::new()\n-    };\n-\n-    // FIXME #13005 This should also walk the\n-    // expression.\n-    match expr.node {\n-        ast::ExprAddrOf(..) => {\n-            glcx.visit_expr(expr, ());\n-        }\n-        _ => {}\n-    }\n-}\n-\n fn gather_loans_in_expr(this: &mut GatherLoanCtxt,\n                         ex: &ast::Expr) {\n     let bccx = this.bccx;\n@@ -326,6 +303,58 @@ fn with_assignee_loan_path(bccx: &BorrowckCtxt, expr: &ast::Expr, op: |@LoanPath\n     }\n }\n \n+\n+/// Implements the A-* rules in doc.rs.\n+fn check_aliasability(bccx: &BorrowckCtxt,\n+                      borrow_span: Span,\n+                      loan_cause: LoanCause,\n+                      cmt: mc::cmt,\n+                      req_kind: ty::BorrowKind)\n+                      -> Result<(),()> {\n+\n+    match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n+        (None, _) => {\n+            /* Uniquely accessible path -- OK for `&` and `&mut` */\n+            Ok(())\n+        }\n+        (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n+            // Borrow of an immutable static item:\n+            match safety {\n+                mc::InteriorUnsafe => {\n+                    // If the static item contains an Unsafe<T>, it has interior mutability.\n+                    // In such cases, we cannot permit it to be borrowed, because the\n+                    // static item resides in immutable memory and mutating it would\n+                    // cause segfaults.\n+                    bccx.tcx.sess.span_err(borrow_span,\n+                                           format!(\"borrow of immutable static items with \\\n+                                                    unsafe interior is not allowed\"));\n+                    Err(())\n+                }\n+                mc::InteriorSafe => {\n+                    // Immutable static can be borrowed, no problem.\n+                    Ok(())\n+                }\n+            }\n+        }\n+        (Some(mc::AliasableStaticMut(..)), _) => {\n+            // Even touching a static mut is considered unsafe. We assume the\n+            // user knows what they're doing in these cases.\n+            Ok(())\n+        }\n+        (Some(alias_cause), ty::UniqueImmBorrow) |\n+        (Some(alias_cause), ty::MutBorrow) => {\n+            bccx.report_aliasability_violation(\n+                        borrow_span,\n+                        BorrowViolation(loan_cause),\n+                        alias_cause);\n+            Err(())\n+        }\n+        (_, _) => {\n+            Ok(())\n+        }\n+    }\n+}\n+\n impl<'a> GatherLoanCtxt<'a> {\n     pub fn tcx(&self) -> &'a ty::ctxt { self.bccx.tcx }\n \n@@ -676,57 +705,6 @@ impl<'a> GatherLoanCtxt<'a> {\n                 }\n             }\n         }\n-\n-        fn check_aliasability(bccx: &BorrowckCtxt,\n-                              borrow_span: Span,\n-                              loan_cause: LoanCause,\n-                              cmt: mc::cmt,\n-                              req_kind: ty::BorrowKind)\n-                              -> Result<(),()> {\n-            //! Implements the A-* rules in doc.rs.\n-\n-            match (cmt.freely_aliasable(bccx.tcx), req_kind) {\n-                (None, _) => {\n-                    /* Uniquely accessible path -- OK for `&` and `&mut` */\n-                    Ok(())\n-                }\n-                (Some(mc::AliasableStatic(safety)), ty::ImmBorrow) => {\n-                    // Borrow of an immutable static item:\n-                    match safety {\n-                        mc::InteriorUnsafe => {\n-                            // If the static item contains an Unsafe<T>, it has interior mutability.\n-                            // In such cases, we cannot permit it to be borrowed, because the\n-                            // static item resides in immutable memory and mutating it would\n-                            // cause segfaults.\n-                            bccx.tcx.sess.span_err(borrow_span,\n-                                                   format!(\"borrow of immutable static items with \\\n-                                                            unsafe interior is not allowed\"));\n-                            Err(())\n-                        }\n-                        mc::InteriorSafe => {\n-                            // Immutable static can be borrowed, no problem.\n-                            Ok(())\n-                        }\n-                    }\n-                }\n-                (Some(mc::AliasableStaticMut(..)), _) => {\n-                    // Even touching a static mut is considered unsafe. We assume the\n-                    // user knows what they're doing in these cases.\n-                    Ok(())\n-                }\n-                (Some(alias_cause), ty::UniqueImmBorrow) |\n-                (Some(alias_cause), ty::MutBorrow) => {\n-                    bccx.report_aliasability_violation(\n-                                borrow_span,\n-                                BorrowViolation(loan_cause),\n-                                alias_cause);\n-                    Err(())\n-                }\n-                (_, _) => {\n-                    Ok(())\n-                }\n-            }\n-        }\n     }\n \n     fn restriction_set(&self, req_kind: ty::BorrowKind) -> RestrictionSet {\n@@ -948,3 +926,44 @@ impl<'a> GatherLoanCtxt<'a> {\n         pat_util::pat_is_binding(self.bccx.tcx.def_map, pat)\n     }\n }\n+\n+/// Context used while gathering loans on static initializers\n+///\n+/// This visitor walks static initializer's expressions and makes\n+/// sure the loans being taken are sound.\n+struct StaticInitializerCtxt<'a> {\n+    bccx: &'a BorrowckCtxt<'a>,\n+    id_range: IdRange,\n+    item_ub: ast::NodeId,\n+}\n+\n+impl<'a> visit::Visitor<()> for StaticInitializerCtxt<'a> {\n+    fn visit_expr(&mut self, ex: &Expr, _: ()) {\n+        match ex.node {\n+            ast::ExprAddrOf(mutbl, base) => {\n+                let base_cmt = self.bccx.cat_expr(base);\n+                let borrow_kind = ty::BorrowKind::from_mutbl(mutbl);\n+                // Check that we don't allow borrows of unsafe static items.\n+                if check_aliasability(self.bccx, ex.span, AddrOf, base_cmt, borrow_kind).is_err() {\n+                    return; // reported an error, no sense in reporting more.\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        visit::walk_expr(self, ex, ());\n+    }\n+}\n+\n+pub fn gather_loans_in_static_initializer(bccx: &mut BorrowckCtxt, expr: &ast::Expr) {\n+\n+    debug!(\"gather_loans_in_static_initializer(expr={})\", expr.repr(bccx.tcx));\n+\n+    let mut sicx = StaticInitializerCtxt {\n+        bccx: bccx,\n+        id_range: IdRange::max(),\n+        item_ub: expr.id,\n+    };\n+\n+    sicx.visit_expr(expr, ());\n+}"}, {"sha": "9939fc791907d0fb166247c34f1b86e7563d91aa", "filename": "src/test/compile-fail/borrowck-forbid-static-unsafe-interior.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5d5634ace087addc6f1d09b55643f97162a4f031/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d5634ace087addc6f1d09b55643f97162a4f031/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-forbid-static-unsafe-interior.rs?ref=5d5634ace087addc6f1d09b55643f97162a4f031", "patch": "@@ -35,6 +35,13 @@ static STATIC3: MyUnsafe<int> = MyUnsafe{value: STATIC2};\n static STATIC4: &'static Unsafe<int> = &'static STATIC2;\n //~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n+struct Wrap<T> {\n+    value: T\n+}\n+\n+static UNSAFE: Unsafe<int> = Unsafe{value: 1, marker1: marker::InvariantType};\n+static WRAPPED_UNSAFE: Wrap<&'static Unsafe<int>> = Wrap { value: &UNSAFE };\n+//~^ ERROR borrow of immutable static items with unsafe interior is not allowed\n \n fn main() {\n     let a = &STATIC1;"}]}