{"sha": "128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOGYxZjVlMmViNzE3ZmQ1ZDhjNjhiNmVjNzcyZmU0YjgwOGNkMjA=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-02-11T08:41:14Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-08T15:40:47Z"}, "message": "Move redundant_allocation to its own module", "tree": {"sha": "c950f4f6e1413775242634aeda7840eb8b2fed49", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c950f4f6e1413775242634aeda7840eb8b2fed49"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "html_url": "https://github.com/rust-lang/rust/commit/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df307c0ce73552045e81ee8237d3cb582af0e7e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/df307c0ce73552045e81ee8237d3cb582af0e7e7", "html_url": "https://github.com/rust-lang/rust/commit/df307c0ce73552045e81ee8237d3cb582af0e7e7"}], "stats": {"total": 200, "additions": 112, "deletions": 88}, "files": [{"sha": "cc6ff731ffcd38be84d7acd803a8c52e959c0555", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 10, "deletions": 88, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "patch": "@@ -1,6 +1,8 @@\n #![allow(rustc::default_hash_types)]\n \n mod box_vec;\n+mod redundant_allocation;\n+mod utils;\n \n use std::borrow::Cow;\n use std::cmp::Ordering;\n@@ -13,8 +15,8 @@ use rustc_hir as hir;\n use rustc_hir::intravisit::{walk_body, walk_expr, walk_ty, FnKind, NestedVisitorMap, Visitor};\n use rustc_hir::{\n     BinOpKind, Block, Body, Expr, ExprKind, FnDecl, FnRetTy, FnSig, GenericArg, GenericBounds, GenericParamKind, HirId,\n-    ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node,\n-    QPath, Stmt, StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n+    ImplItem, ImplItemKind, Item, ItemKind, Lifetime, Lit, Local, MatchSource, MutTy, Mutability, Node, QPath, Stmt,\n+    StmtKind, SyntheticTyParamKind, TraitFn, TraitItem, TraitItemKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::hir::map::Map;\n@@ -35,10 +37,10 @@ use crate::utils::paths;\n use crate::utils::sugg::Sugg;\n use crate::utils::{\n     clip, comparisons, differing_macro_contexts, get_qpath_generic_tys, higher, in_constant, indent_of, int_bits,\n-    is_hir_ty_cfg_dependant, is_ty_param_diagnostic_item, is_ty_param_lang_item, is_type_diagnostic_item,\n-    last_path_segment, match_def_path, match_path, meets_msrv, method_chain_args, multispan_sugg,\n-    numeric_literal::NumericLiteral, reindent_multiline, sext, snippet, snippet_opt, snippet_with_applicability,\n-    snippet_with_macro_callsite, span_lint, span_lint_and_help, span_lint_and_sugg, span_lint_and_then, unsext,\n+    is_hir_ty_cfg_dependant, is_ty_param_diagnostic_item, is_type_diagnostic_item, last_path_segment, match_def_path,\n+    match_path, meets_msrv, method_chain_args, multispan_sugg, numeric_literal::NumericLiteral, reindent_multiline,\n+    sext, snippet, snippet_opt, snippet_with_applicability, snippet_with_macro_callsite, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, span_lint_and_then, unsext,\n };\n \n declare_clippy_lint! {\n@@ -301,23 +303,6 @@ fn match_buffer_type(cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<&'static\n     }\n }\n \n-fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n-    let last = last_path_segment(qpath);\n-    if_chain! {\n-        if let Some(ref params) = last.args;\n-        if !params.parenthesized;\n-        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n-            GenericArg::Type(ty) => Some(ty),\n-            _ => None,\n-        });\n-        if let TyKind::Rptr(..) = ty.kind;\n-        then {\n-            return Some(ty.span);\n-        }\n-    }\n-    None\n-}\n-\n impl Types {\n     pub fn new(vec_box_size_threshold: u64) -> Self {\n         Self { vec_box_size_threshold }\n@@ -349,58 +334,8 @@ impl Types {\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n                     box_vec::check(cx, hir_ty, qpath, def_id);\n-                    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Box<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                    } else if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n-                        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Rc<T>>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n-                        if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n-                            let qpath = match &ty.kind {\n-                                TyKind::Path(qpath) => qpath,\n-                                _ => return,\n-                            };\n-                            let inner_span = match get_qpath_generic_tys(qpath).next() {\n-                                Some(ty) => ty.span,\n-                                None => return,\n-                            };\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<Box<T>>`\",\n-                                \"try\",\n-                                format!(\n-                                    \"Rc<{}>\",\n-                                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n-                                ),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n+                    redundant_allocation::check(cx, hir_ty, qpath, def_id);\n+                    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n                         if let Some(alternate) = match_buffer_type(cx, qpath) {\n                             span_lint_and_sugg(\n                                 cx,\n@@ -437,19 +372,6 @@ impl Types {\n                             );\n                             return; // don't recurse into the type\n                         }\n-                        if let Some(span) = match_borrows_parameter(cx, qpath) {\n-                            let mut applicability = Applicability::MachineApplicable;\n-                            span_lint_and_sugg(\n-                                cx,\n-                                REDUNDANT_ALLOCATION,\n-                                hir_ty.span,\n-                                \"usage of `Rc<&T>`\",\n-                                \"try\",\n-                                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n-                                applicability,\n-                            );\n-                            return; // don't recurse into the type\n-                        }\n                     } else if cx.tcx.is_diagnostic_item(sym::Arc, def_id) {\n                         if let Some(alternate) = match_buffer_type(cx, qpath) {\n                             span_lint_and_sugg("}, {"sha": "8280b2c5629cfbd2635129f2077d8a7affc14889", "filename": "clippy_lints/src/types/redundant_allocation.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fredundant_allocation.rs?ref=128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "patch": "@@ -0,0 +1,78 @@\n+use rustc_errors::Applicability;\n+use rustc_hir::{self as hir, def_id::DefId, LangItem, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::symbol::sym;\n+\n+use crate::utils::{\n+    get_qpath_generic_tys, is_ty_param_diagnostic_item, is_ty_param_lang_item, snippet_with_applicability,\n+    span_lint_and_sugg,\n+};\n+\n+use super::{utils, REDUNDANT_ALLOCATION};\n+\n+pub(super) fn check(cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, qpath: &QPath<'_>, def_id: DefId) {\n+    if Some(def_id) == cx.tcx.lang_items().owned_box() {\n+        if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Box<&T>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            return;\n+        }\n+    }\n+\n+    if cx.tcx.is_diagnostic_item(sym::Rc, def_id) {\n+        if let Some(ty) = is_ty_param_diagnostic_item(cx, qpath, sym::Rc) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Rc<T>>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, ty.span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+        } else if let Some(ty) = is_ty_param_lang_item(cx, qpath, LangItem::OwnedBox) {\n+            let qpath = match &ty.kind {\n+                TyKind::Path(qpath) => qpath,\n+                _ => return,\n+            };\n+            let inner_span = match get_qpath_generic_tys(qpath).next() {\n+                Some(ty) => ty.span,\n+                None => return,\n+            };\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<Box<T>>`\",\n+                \"try\",\n+                format!(\n+                    \"Rc<{}>\",\n+                    snippet_with_applicability(cx, inner_span, \"..\", &mut applicability)\n+                ),\n+                applicability,\n+            );\n+        } else if let Some(span) = utils::match_borrows_parameter(cx, qpath) {\n+            let mut applicability = Applicability::MachineApplicable;\n+            span_lint_and_sugg(\n+                cx,\n+                REDUNDANT_ALLOCATION,\n+                hir_ty.span,\n+                \"usage of `Rc<&T>`\",\n+                \"try\",\n+                snippet_with_applicability(cx, span, \"..\", &mut applicability).to_string(),\n+                applicability,\n+            );\n+            return; // don't recurse into the type\n+        }\n+    }\n+}"}, {"sha": "4d64748f998a40deac3d0d667aba6a3d69f851e8", "filename": "clippy_lints/src/types/utils.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20/clippy_lints%2Fsrc%2Ftypes%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Futils.rs?ref=128f1f5e2eb717fd5d8c68b6ec772fe4b808cd20", "patch": "@@ -0,0 +1,24 @@\n+use rustc_hir::{GenericArg, QPath, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_span::source_map::Span;\n+\n+use crate::utils::last_path_segment;\n+\n+use if_chain::if_chain;\n+\n+pub(super) fn match_borrows_parameter(_cx: &LateContext<'_>, qpath: &QPath<'_>) -> Option<Span> {\n+    let last = last_path_segment(qpath);\n+    if_chain! {\n+        if let Some(ref params) = last.args;\n+        if !params.parenthesized;\n+        if let Some(ty) = params.args.iter().find_map(|arg| match arg {\n+            GenericArg::Type(ty) => Some(ty),\n+            _ => None,\n+        });\n+        if let TyKind::Rptr(..) = ty.kind;\n+        then {\n+            return Some(ty.span);\n+        }\n+    }\n+    None\n+}"}]}