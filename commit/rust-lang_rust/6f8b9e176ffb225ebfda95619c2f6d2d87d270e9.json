{"sha": "6f8b9e176ffb225ebfda95619c2f6d2d87d270e9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmOGI5ZTE3NmZmYjIyNWViZmRhOTU2MTljMmY2ZDJkODdkMjcwZTk=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T00:28:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-19T00:28:08Z"}, "message": "Factor free paths out of drop glue, into free glue as in rustboot.", "tree": {"sha": "4458cf4423b91c7eccd4ae6a7db8fabf7cd610ec", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4458cf4423b91c7eccd4ae6a7db8fabf7cd610ec"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9", "html_url": "https://github.com/rust-lang/rust/commit/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0aee8b3bd7994ff0e113fafdcba5e008d607754b", "url": "https://api.github.com/repos/rust-lang/rust/commits/0aee8b3bd7994ff0e113fafdcba5e008d607754b", "html_url": "https://github.com/rust-lang/rust/commit/0aee8b3bd7994ff0e113fafdcba5e008d607754b"}], "stats": {"total": 306, "additions": 184, "deletions": 122}, "files": [{"sha": "a7c7b5544b682e4d5220239244dcaadc03f9118c", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 184, "deletions": 122, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6f8b9e176ffb225ebfda95619c2f6d2d87d270e9/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=6f8b9e176ffb225ebfda95619c2f6d2d87d270e9", "patch": "@@ -69,6 +69,7 @@ type tydesc_info = rec(ty::t ty,\n                        ValueRef align,\n                        mutable option::t[ValueRef] take_glue,\n                        mutable option::t[ValueRef] drop_glue,\n+                       mutable option::t[ValueRef] free_glue,\n                        mutable option::t[ValueRef] cmp_glue,\n                        vec[uint] ty_params);\n \n@@ -1805,6 +1806,8 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n                                           \"take\");\n     auto drop_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n                                           \"drop\");\n+    auto free_glue = declare_generic_glue(cx, t, T_glue_fn(cx.ccx.tn),\n+                                          \"free\");\n     auto cmp_glue = declare_generic_glue(cx, t, T_cmp_glue_fn(cx.ccx.tn),\n                                          \"cmp\");\n     auto ccx = cx.ccx;\n@@ -1839,6 +1842,7 @@ fn declare_tydesc(&@local_ctxt cx, &ty::t t,\n                      align = llalign,\n                      mutable take_glue = none[ValueRef],\n                      mutable drop_glue = none[ValueRef],\n+                     mutable free_glue = none[ValueRef],\n                      mutable cmp_glue = none[ValueRef],\n                      ty_params = ty_params);\n \n@@ -1963,6 +1967,16 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n             }\n         };\n \n+        auto free_glue = alt (ti.free_glue) {\n+            case (none[ValueRef]) {\n+                ccx.stats.n_null_glues += 1u;\n+                C_null(glue_fn_ty)\n+            }\n+            case (some[ValueRef](?v)) {\n+                ccx.stats.n_real_glues += 1u;\n+                v\n+            }\n+        };\n \n         auto cmp_glue = alt (ti.cmp_glue) {\n             case (none[ValueRef]) {\n@@ -1981,7 +1995,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n                                    ti.align,\n                                    take_glue,             // take_glue\n                                    drop_glue,             // drop_glue\n-                                   C_null(glue_fn_ty),    // free_glue\n+                                   free_glue,             // free_glue\n                                    C_null(glue_fn_ty),    // sever_glue\n                                    C_null(glue_fn_ty),    // mark_glue\n                                    C_null(glue_fn_ty),    // obj_drop_glue\n@@ -2031,154 +2045,164 @@ fn incr_refcnt_of_boxed(&@block_ctxt cx, ValueRef box_ptr) -> result {\n     ret res(next_cx, C_nil());\n }\n \n-fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n-    // NB: v0 is an *alias* of type t here, not a direct value.\n+fn make_free_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n+    // NB: v is an *alias* of type t here, not a direct value.\n     auto rslt;\n     alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+\n         case (ty::ty_str) {\n             auto v = cx.build.Load(v0);\n-            rslt = decr_refcnt_and_if_zero\n-                (cx, v, bind trans_non_gc_free(_, v),\n-                 \"free string\",\n-                 T_int(), C_int(0));\n+            rslt = trans_non_gc_free(cx, v);\n         }\n \n         case (ty::ty_vec(_)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef v,\n-                        ty::t t) -> result {\n-                auto res = iter_sequence(cx, v, t,\n-                                         bind drop_ty(_,_,_));\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(res.bcx, v);\n-            }\n             auto v = cx.build.Load(v0);\n-            rslt = decr_refcnt_and_if_zero(cx, v,\n-                                          bind hit_zero(_, v, t),\n-                                          \"free vector\",\n-                                          T_int(), C_int(0));\n+            auto res = iter_sequence(cx, v, t,\n+                                     bind drop_ty(_,_,_));\n+            // FIXME: switch gc/non-gc on layer of the type.\n+            rslt = trans_non_gc_free(res.bcx, v);\n         }\n \n         case (ty::ty_box(?body_mt)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef v,\n-                        ty::t body_ty) -> result {\n-                auto body = cx.build.GEP(v,\n-                                         [C_int(0),\n-                                             C_int(abi::box_rc_field_body)]);\n-\n-                auto body_val = load_if_immediate(cx, body, body_ty);\n-                auto res = drop_ty(cx, body_val, body_ty);\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(res.bcx, v);\n-            }\n             auto v = cx.build.Load(v0);\n-            rslt = decr_refcnt_and_if_zero(cx, v,\n-                                           bind hit_zero(_, v, body_mt.ty),\n-                                           \"free box\",\n-                                           T_int(), C_int(0));\n+            auto body = cx.build.GEP(v,\n+                                     [C_int(0),\n+                                      C_int(abi::box_rc_field_body)]);\n+            auto body_ty = body_mt.ty;\n+            auto body_val = load_if_immediate(cx, body, body_ty);\n+            auto res = drop_ty(cx, body_val, body_ty);\n+            // FIXME: switch gc/non-gc on layer of the type.\n+            rslt = trans_non_gc_free(res.bcx, v);\n         }\n \n         case (ty::ty_port(_)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n-                cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_port,\n-                    [cx.fcx.lltaskptr,\n-                        cx.build.PointerCast(v, T_opaque_port_ptr())]);\n-                ret res(cx, C_int(0));\n-            }\n             auto v = cx.build.Load(v0);\n-            rslt = decr_refcnt_and_if_zero(cx, v,\n-                                           bind hit_zero(_, v),\n-                                           \"free port\",\n-                                           T_int(), C_int(0));\n+            cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_port,\n+                          [cx.fcx.lltaskptr,\n+                           cx.build.PointerCast(v,\n+                                                T_opaque_port_ptr())]);\n+            rslt = res(cx, C_int(0));\n         }\n \n         case (ty::ty_chan(_)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n-                cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_chan,\n-                    [cx.fcx.lltaskptr,\n-                        cx.build.PointerCast(v, T_opaque_chan_ptr())]);\n-                ret res(cx, C_int(0));\n-            }\n             auto v = cx.build.Load(v0);\n-            rslt = decr_refcnt_and_if_zero(cx, v,\n-                                           bind hit_zero(_, v),\n-                                           \"free chan\",\n-                                           T_int(), C_int(0));\n+            cx.build.Call(cx.fcx.lcx.ccx.upcalls.del_chan,\n+                          [cx.fcx.lltaskptr,\n+                           cx.build.PointerCast(v,\n+                                                T_opaque_chan_ptr())]);\n+            rslt = res(cx, C_int(0));\n         }\n \n         case (ty::ty_obj(_)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef b, ValueRef o) -> result {\n-                auto body =\n-                    cx.build.GEP(b,\n-                                 [C_int(0),\n-                                     C_int(abi::box_rc_field_body)]);\n-                auto tydescptr =\n-                    cx.build.GEP(body,\n-                                 [C_int(0),\n-                                     C_int(abi::obj_body_elt_tydesc)]);\n-                auto tydesc = cx.build.Load(tydescptr);\n-\n-                auto cx_ = maybe_call_dtor(cx, o);\n-\n-                // Call through the obj's own fields-drop glue first.\n-                auto ti = none[@tydesc_info];\n-                call_tydesc_glue_full(cx_, body, tydesc,\n-                                      abi::tydesc_field_drop_glue, ti);\n-\n-                // Then free the body.\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(cx_, b);\n-            }\n+\n             auto box_cell =\n                 cx.build.GEP(v0,\n                              [C_int(0),\n                                  C_int(abi::obj_field_box)]);\n \n-            auto boxptr = cx.build.Load(box_cell);\n+            auto b = cx.build.Load(box_cell);\n+            auto body =\n+                cx.build.GEP(b,\n+                             [C_int(0),\n+                              C_int(abi::box_rc_field_body)]);\n+            auto tydescptr =\n+                cx.build.GEP(body,\n+                             [C_int(0),\n+                              C_int(abi::obj_body_elt_tydesc)]);\n+            auto tydesc = cx.build.Load(tydescptr);\n+\n+            auto cx_ = maybe_call_dtor(cx, v0);\n+\n+            // Call through the obj's own fields-drop glue first.\n+            auto ti = none[@tydesc_info];\n+            call_tydesc_glue_full(cx_, body, tydesc,\n+                                  abi::tydesc_field_drop_glue, ti);\n \n-            rslt = decr_refcnt_and_if_zero(cx, boxptr,\n-                                           bind hit_zero(_, boxptr, v0),\n-                                           \"free obj\",\n-                                           T_int(), C_int(0));\n+            // Then free the body.\n+            // FIXME: switch gc/non-gc on layer of the type.\n+            rslt = trans_non_gc_free(cx_, b);\n         }\n \n         case (ty::ty_fn(_,_,_)) {\n-            fn hit_zero(&@block_ctxt cx, ValueRef v) -> result {\n-\n-                // Call through the closure's own fields-drop glue first.\n-                auto body =\n-                    cx.build.GEP(v,\n-                                 [C_int(0),\n-                                     C_int(abi::box_rc_field_body)]);\n-                auto bindings =\n-                    cx.build.GEP(body,\n-                                 [C_int(0),\n-                                     C_int(abi::closure_elt_bindings)]);\n-\n-                auto tydescptr =\n-                    cx.build.GEP(body,\n-                                 [C_int(0),\n-                                     C_int(abi::closure_elt_tydesc)]);\n-\n-                auto ti = none[@tydesc_info];\n-                call_tydesc_glue_full(cx, bindings, cx.build.Load(tydescptr),\n-                                      abi::tydesc_field_drop_glue, ti);\n-\n-\n-                // Then free the body.\n-                // FIXME: switch gc/non-gc on layer of the type.\n-                ret trans_non_gc_free(cx, v);\n-            }\n+\n             auto box_cell =\n                 cx.build.GEP(v0,\n                              [C_int(0),\n                                  C_int(abi::fn_field_box)]);\n \n-            auto boxptr = cx.build.Load(box_cell);\n+            auto v = cx.build.Load(box_cell);\n+\n+            // Call through the closure's own fields-drop glue first.\n+            auto body =\n+                cx.build.GEP(v,\n+                             [C_int(0),\n+                              C_int(abi::box_rc_field_body)]);\n+            auto bindings =\n+                cx.build.GEP(body,\n+                             [C_int(0),\n+                              C_int(abi::closure_elt_bindings)]);\n+\n+            auto tydescptr =\n+                cx.build.GEP(body,\n+                             [C_int(0),\n+                              C_int(abi::closure_elt_tydesc)]);\n+\n+            auto ti = none[@tydesc_info];\n+            call_tydesc_glue_full(cx, bindings, cx.build.Load(tydescptr),\n+                                  abi::tydesc_field_drop_glue, ti);\n+\n+\n+            // Then free the body.\n+            // FIXME: switch gc/non-gc on layer of the type.\n+            rslt = trans_non_gc_free(cx, v);\n+        }\n+\n+        case (_) { rslt = res(cx, C_nil()); }\n+    }\n+    rslt.bcx.build.RetVoid();\n+}\n+\n+fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n+    // NB: v0 is an *alias* of type t here, not a direct value.\n+    auto rslt;\n+    alt (ty::struct(cx.fcx.lcx.ccx.tcx, t)) {\n+        case (ty::ty_str) {\n+            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+        }\n+\n+        case (ty::ty_vec(_)) {\n+            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+        }\n+\n+        case (ty::ty_box(_)) {\n+            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+        }\n+\n+        case (ty::ty_port(_)) {\n+            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+        }\n+\n+        case (ty::ty_chan(_)) {\n+            rslt = decr_refcnt_maybe_free(cx, v0, v0, t);\n+        }\n+\n+        case (ty::ty_obj(_)) {\n+            auto box_cell =\n+                cx.build.GEP(v0,\n+                             [C_int(0),\n+                                 C_int(abi::obj_field_box)]);\n+\n+            rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n+        }\n+\n+        case (ty::ty_fn(_,_,_)) {\n+\n+            auto box_cell =\n+                cx.build.GEP(v0,\n+                             [C_int(0),\n+                                 C_int(abi::fn_field_box)]);\n \n-            rslt = decr_refcnt_and_if_zero(cx, boxptr,\n-                                           bind hit_zero(_, boxptr),\n-                                           \"free fn\",\n-                                           T_int(), C_int(0));\n+            rslt = decr_refcnt_maybe_free(cx, box_cell, v0, t);\n         }\n \n         case (_) {\n@@ -2199,17 +2223,18 @@ fn make_drop_glue(&@block_ctxt cx, ValueRef v0, &ty::t t) {\n     rslt.bcx.build.RetVoid();\n }\n \n-fn decr_refcnt_and_if_zero(&@block_ctxt cx,\n-                           ValueRef box_ptr,\n-                           &fn(&@block_ctxt cx) -> result inner,\n-                           &str inner_name,\n-                           TypeRef t_else, ValueRef v_else) -> result {\n+fn decr_refcnt_maybe_free(&@block_ctxt cx,\n+                          ValueRef box_ptr_alias,\n+                          ValueRef full_alias,\n+                          &ty::t t) -> result {\n \n     auto load_rc_cx = new_sub_block_ctxt(cx, \"load rc\");\n     auto rc_adj_cx = new_sub_block_ctxt(cx, \"rc--\");\n-    auto inner_cx = new_sub_block_ctxt(cx, inner_name);\n+    auto free_cx = new_sub_block_ctxt(cx, \"free\");\n     auto next_cx = new_sub_block_ctxt(cx, \"next\");\n \n+    auto box_ptr = cx.build.Load(box_ptr_alias);\n+\n     auto null_test = cx.build.IsNull(box_ptr);\n     cx.build.CondBr(null_test, next_cx.llbb, load_rc_cx.llbb);\n \n@@ -2227,17 +2252,20 @@ fn decr_refcnt_and_if_zero(&@block_ctxt cx,\n     rc = rc_adj_cx.build.Sub(rc, C_int(1));\n     rc_adj_cx.build.Store(rc, rc_ptr);\n     auto zero_test = rc_adj_cx.build.ICmp(lib::llvm::LLVMIntEQ, C_int(0), rc);\n-    rc_adj_cx.build.CondBr(zero_test, inner_cx.llbb, next_cx.llbb);\n+    rc_adj_cx.build.CondBr(zero_test, free_cx.llbb, next_cx.llbb);\n \n-    auto inner_res = inner(inner_cx);\n-    inner_res.bcx.build.Br(next_cx.llbb);\n+    auto free_res = free_ty(free_cx,\n+                            load_if_immediate(free_cx, full_alias, t), t);\n+    free_res.bcx.build.Br(next_cx.llbb);\n \n+    auto t_else = T_nil();\n+    auto v_else = C_nil();\n     auto phi = next_cx.build.Phi(t_else,\n-                                 [v_else, v_else, v_else, inner_res.val],\n+                                 [v_else, v_else, v_else, free_res.val],\n                                  [cx.llbb,\n                                      load_rc_cx.llbb,\n                                      rc_adj_cx.llbb,\n-                                     inner_res.bcx.llbb]);\n+                                     free_res.bcx.llbb]);\n \n     ret res(next_cx, phi);\n }\n@@ -2903,6 +2931,7 @@ fn lazily_emit_all_tydesc_glue(&@block_ctxt cx,\n                                &option::t[@tydesc_info] static_ti) {\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, static_ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, static_ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_cmp_glue, static_ti);\n }\n \n@@ -2960,6 +2989,26 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                     }\n                 }\n \n+            } else if (field == abi::tydesc_field_free_glue)  {\n+                alt (ti.free_glue) {\n+                    case (some[ValueRef](_)) { }\n+                    case (none[ValueRef]) {\n+                        log #fmt(\"+++ lazily_emit_tydesc_glue FREE %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                        auto lcx = cx.fcx.lcx;\n+                        auto glue_fn =\n+                            declare_generic_glue(lcx, ti.ty,\n+                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 \"free\");\n+                        ti.free_glue = some[ValueRef](glue_fn);\n+                        auto dg = make_free_glue;\n+                        make_generic_glue(lcx, ti.ty, glue_fn,\n+                                          mgghf_single(dg), ti.ty_params);\n+                        log #fmt(\"--- lazily_emit_tydesc_glue FREE %s\",\n+                                 ty::ty_to_str(cx.fcx.lcx.ccx.tcx, ti.ty));\n+                    }\n+                }\n+\n             } else if (field == abi::tydesc_field_cmp_glue) {\n                 alt (ti.cmp_glue) {\n                     case (some[ValueRef](_)) { }\n@@ -3111,6 +3160,16 @@ fn drop_ty(&@block_ctxt cx,\n     ret res(cx, C_nil());\n }\n \n+fn free_ty(&@block_ctxt cx,\n+           ValueRef v,\n+           ty::t t) -> result {\n+\n+    if (!ty::type_is_scalar(cx.fcx.lcx.ccx.tcx, t)) {\n+        ret call_tydesc_glue(cx, v, t, false, abi::tydesc_field_free_glue);\n+    }\n+    ret res(cx, C_nil());\n+}\n+\n fn call_memmove(&@block_ctxt cx,\n                 ValueRef dst,\n                 ValueRef src,\n@@ -3419,6 +3478,7 @@ fn trans_vec_append(&@block_ctxt cx, &ty::t t,\n     auto llelt_tydesc = get_tydesc(bcx, elt_ty, false, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_take_glue, ti);\n     lazily_emit_tydesc_glue(cx, abi::tydesc_field_drop_glue, ti);\n+    lazily_emit_tydesc_glue(cx, abi::tydesc_field_free_glue, ti);\n     bcx = llelt_tydesc.bcx;\n \n     auto dst = bcx.build.PointerCast(lhs, T_ptr(T_opaque_vec_ptr()));\n@@ -4910,6 +4970,7 @@ fn trans_bind(&@block_ctxt cx, &@ast::expr f,\n             auto ti = none[@tydesc_info];\n             auto bindings_tydesc = get_tydesc(bcx, bindings_ty, true, ti);\n             lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+            lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n             bcx = bindings_tydesc.bcx;\n             bcx.build.Store(bindings_tydesc.val, bound_tydesc);\n \n@@ -6747,6 +6808,7 @@ fn trans_obj(@local_ctxt cx, &ast::_obj ob, ast::def_id oid,\n         auto ti = none[@tydesc_info];\n         auto body_td = get_tydesc(bcx, body_ty, true, ti);\n         lazily_emit_tydesc_glue(bcx, abi::tydesc_field_drop_glue, ti);\n+        lazily_emit_tydesc_glue(bcx, abi::tydesc_field_free_glue, ti);\n \n         auto dtor = C_null(T_ptr(T_glue_fn(ccx.tn)));\n         alt (ob.dtor) {"}]}