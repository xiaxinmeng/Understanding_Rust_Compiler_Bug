{"sha": "f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYxNWRkODcwZDFiZjRlNWI5MTlhZTY1NGVkNWQ5OWVkNDg1MjFmZTg=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-11-03T04:08:34Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-11-03T04:08:34Z"}, "message": "Merge pull request #1877 from topecongiro/overflowing-closure-with-loop\n\nForce to use block for closure body with a single control flow expression", "tree": {"sha": "b26ba0c3735d0573c85a335a57583bc73fa3d324", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b26ba0c3735d0573c85a335a57583bc73fa3d324"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJZ++vCCRBK7hj4Ov3rIwAAdHIIAGYP+yJt2DyuSs+NXoNMjXZz\n+0YNNfIn5QfSfkJZCm13Xl/r2hRqrU/PrnGekViF0rKgRldyqUfgKg9qdwOFXAYQ\nOHd5yaGL1qddtpOuH0OiLE4vu+/Gi5tVsi5D65OL9Gy4PSdM9o5qgmE7nZiGp6ec\n07P+7NFXIw6LjYpcD+WtZuTFgjiRhMLpC1eQ2YFV5yHKlwXnUBEbPgmt7youvgWk\nP2x3zp977jH5FW3iMNkKVF1GiqLS5qmzLdRNo5JzDurtfVANZ0ArsxhAcVePMXPk\nSXZgkZUzfU8yDAG6WCCcpA3DxD/ilfxDPUKI7cYMGIiQN1YvkZshGvpu3aVfaRQ=\n=wSVG\n-----END PGP SIGNATURE-----\n", "payload": "tree b26ba0c3735d0573c85a335a57583bc73fa3d324\nparent 175c0c6f05bd6379b22429563224d566b069bdd9\nparent bfaeac202af48a70e4a82d8ffb92fe85573af3a1\nauthor Nick Cameron <nrc@ncameron.org> 1509682114 +1300\ncommitter GitHub <noreply@github.com> 1509682114 +1300\n\nMerge pull request #1877 from topecongiro/overflowing-closure-with-loop\n\nForce to use block for closure body with a single control flow expression"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "html_url": "https://github.com/rust-lang/rust/commit/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "175c0c6f05bd6379b22429563224d566b069bdd9", "url": "https://api.github.com/repos/rust-lang/rust/commits/175c0c6f05bd6379b22429563224d566b069bdd9", "html_url": "https://github.com/rust-lang/rust/commit/175c0c6f05bd6379b22429563224d566b069bdd9"}, {"sha": "bfaeac202af48a70e4a82d8ffb92fe85573af3a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bfaeac202af48a70e4a82d8ffb92fe85573af3a1", "html_url": "https://github.com/rust-lang/rust/commit/bfaeac202af48a70e4a82d8ffb92fe85573af3a1"}], "stats": {"total": 234, "additions": 163, "deletions": 71}, "files": [{"sha": "53e697d76ac57e32442e7f64218d33d8ac3e8726", "filename": "src/bin/cargo-fmt.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fbin%2Fcargo-fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fbin%2Fcargo-fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fcargo-fmt.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -133,8 +133,10 @@ fn format_crate(\n     let files: Vec<_> = targets\n         .into_iter()\n         .filter(|t| t.kind.should_format())\n-        .inspect(|t| if verbosity == Verbosity::Verbose {\n-            println!(\"[{:?}] {:?}\", t.kind, t.path)\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{:?}] {:?}\", t.kind, t.path)\n+            }\n         })\n         .map(|t| t.path)\n         .collect();"}, {"sha": "a35648de5c273eb121261eb355dcb2d577f81f8f", "filename": "src/chains.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -297,10 +297,12 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n \n // True if the chain is only `?`s.\n fn chain_only_try(exprs: &[ast::Expr]) -> bool {\n-    exprs.iter().all(|e| if let ast::ExprKind::Try(_) = e.node {\n-        true\n-    } else {\n-        false\n+    exprs.iter().all(|e| {\n+        if let ast::ExprKind::Try(_) = e.node {\n+            true\n+        } else {\n+            false\n+        }\n     })\n }\n "}, {"sha": "713ef4922d9ace02c2a80f2f40a71a8e4c6b54ea", "filename": "src/comment.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -311,10 +311,12 @@ fn rewrite_comment_inner(\n             line\n         })\n         .map(|s| left_trim_comment_line(s, &style))\n-        .map(|line| if orig.starts_with(\"/*\") && line_breaks == 0 {\n-            line.trim_left()\n-        } else {\n-            line\n+        .map(|line| {\n+            if orig.starts_with(\"/*\") && line_breaks == 0 {\n+                line.trim_left()\n+            } else {\n+                line\n+            }\n         });\n \n     let mut result = opener.to_owned();"}, {"sha": "09b9a4e622e1914ccb1a9c7c250ba263148ba22f", "filename": "src/expr.rs", "status": "modified", "additions": 84, "deletions": 23, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -630,8 +630,7 @@ fn rewrite_closure(\n         }\n \n         // Figure out if the block is necessary.\n-        let needs_block = block.rules != ast::BlockCheckMode::Default || block.stmts.len() > 1\n-            || context.inside_macro\n+        let needs_block = is_unsafe_block(block) || block.stmts.len() > 1 || context.inside_macro\n             || block_contains_comment(block, context.codemap)\n             || prefix.contains('\\n');\n \n@@ -642,8 +641,12 @@ fn rewrite_closure(\n         };\n         if no_return_type && !needs_block {\n             // block.stmts.len() == 1\n-            if let Some(expr) = stmt_expr(&block.stmts[0]) {\n-                if let Some(rw) = rewrite_closure_expr(expr, &prefix, context, body_shape) {\n+            if let Some(ref expr) = stmt_expr(&block.stmts[0]) {\n+                if let Some(rw) = if is_block_closure_forced(expr) {\n+                    rewrite_closure_with_block(context, shape, &prefix, expr)\n+                } else {\n+                    rewrite_closure_expr(expr, &prefix, context, body_shape)\n+                } {\n                     return Some(rw);\n                 }\n             }\n@@ -1195,12 +1198,13 @@ impl<'a> ControlFlow<'a> {\n             context\n                 .codemap\n                 .span_after(mk_sp(lo, self.span.hi()), self.keyword.trim()),\n-            self.pat\n-                .map_or(cond_span.lo(), |p| if self.matcher.is_empty() {\n+            self.pat.map_or(cond_span.lo(), |p| {\n+                if self.matcher.is_empty() {\n                     p.span.lo()\n                 } else {\n                     context.codemap.span_before(self.span, self.matcher.trim())\n-                }),\n+                }\n+            }),\n         );\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n@@ -2248,7 +2252,34 @@ fn rewrite_last_closure(\n         if prefix.contains('\\n') {\n             return None;\n         }\n+        // If we are inside macro, we do not want to add or remove block from closure body.\n+        if context.inside_macro {\n+            return expr.rewrite(context, shape);\n+        }\n+\n         let body_shape = shape.offset_left(extra_offset)?;\n+\n+        // We force to use block for the body of the closure for certain kinds of expressions.\n+        if is_block_closure_forced(body) {\n+            return rewrite_closure_with_block(context, body_shape, &prefix, body).and_then(\n+                |body_str| {\n+                    // If the expression can fit in a single line, we need not force block closure.\n+                    if body_str.lines().count() <= 7 {\n+                        match rewrite_closure_expr(body, &prefix, context, shape) {\n+                            Some(ref single_line_body_str)\n+                                if !single_line_body_str.contains('\\n') =>\n+                            {\n+                                Some(single_line_body_str.clone())\n+                            }\n+                            _ => Some(body_str),\n+                        }\n+                    } else {\n+                        Some(body_str)\n+                    }\n+                },\n+            );\n+        }\n+\n         // When overflowing the closure which consists of a single control flow expression,\n         // force to use block if its condition uses multi line.\n         let is_multi_lined_cond = rewrite_cond(context, body, body_shape)\n@@ -2264,6 +2295,23 @@ fn rewrite_last_closure(\n     None\n }\n \n+fn is_block_closure_forced(expr: &ast::Expr) -> bool {\n+    match expr.node {\n+        ast::ExprKind::If(..) |\n+        ast::ExprKind::IfLet(..) |\n+        ast::ExprKind::Loop(..) |\n+        ast::ExprKind::While(..) |\n+        ast::ExprKind::WhileLet(..) |\n+        ast::ExprKind::ForLoop(..) => true,\n+        ast::ExprKind::AddrOf(_, ref expr) |\n+        ast::ExprKind::Box(ref expr) |\n+        ast::ExprKind::Try(ref expr) |\n+        ast::ExprKind::Unary(_, ref expr) |\n+        ast::ExprKind::Cast(ref expr, _) => is_block_closure_forced(expr),\n+        _ => false,\n+    }\n+}\n+\n fn rewrite_last_arg_with_overflow<'a, T>(\n     context: &RewriteContext,\n     args: &[&T],\n@@ -2281,15 +2329,7 @@ where\n             ast::ExprKind::Closure(..) => {\n                 // If the argument consists of multiple closures, we do not overflow\n                 // the last closure.\n-                if args.len() > 1\n-                    && args.iter()\n-                        .rev()\n-                        .skip(1)\n-                        .filter_map(|arg| arg.to_expr())\n-                        .any(|expr| match expr.node {\n-                            ast::ExprKind::Closure(..) => true,\n-                            _ => false,\n-                        }) {\n+                if args_have_many_closure(args) {\n                     None\n                 } else {\n                     rewrite_last_closure(context, expr, shape)\n@@ -2310,6 +2350,23 @@ where\n     }\n }\n \n+/// Returns true if the given vector of arguments has more than one `ast::ExprKind::Closure`.\n+fn args_have_many_closure<T>(args: &[&T]) -> bool\n+where\n+    T: ToExpr,\n+{\n+    args.iter()\n+        .filter(|arg| {\n+            arg.to_expr()\n+                .map(|e| match e.node {\n+                    ast::ExprKind::Closure(..) => true,\n+                    _ => false,\n+                })\n+                .unwrap_or(false)\n+        })\n+        .count() > 1\n+}\n+\n fn can_be_overflowed<'a, T>(context: &RewriteContext, args: &[&T]) -> bool\n where\n     T: Rewrite + Spanned + ToExpr + 'a,\n@@ -2698,13 +2755,17 @@ where\n     if items.len() == 1 {\n         // 3 = \"(\" + \",)\"\n         let nested_shape = shape.sub_width(3)?.visual_indent(1);\n-        return items.next().unwrap().rewrite(context, nested_shape).map(\n-            |s| if context.config.spaces_within_parens() {\n-                format!(\"( {}, )\", s)\n-            } else {\n-                format!(\"({},)\", s)\n-            },\n-        );\n+        return items\n+            .next()\n+            .unwrap()\n+            .rewrite(context, nested_shape)\n+            .map(|s| {\n+                if context.config.spaces_within_parens() {\n+                    format!(\"( {}, )\", s)\n+                } else {\n+                    format!(\"({},)\", s)\n+                }\n+            });\n     }\n \n     let list_lo = context.codemap.span_after(span, \"(\");"}, {"sha": "4bd942d21c91966aa756c4d771f76d562ed7c7c2", "filename": "src/types.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -670,10 +670,12 @@ impl Rewrite for ast::Ty {\n             ast::TyKind::Paren(ref ty) => {\n                 let budget = shape.width.checked_sub(2)?;\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_parens() {\n-                        format!(\"( {} )\", ty_str)\n-                    } else {\n-                        format!(\"({})\", ty_str)\n+                    .map(|ty_str| {\n+                        if context.config.spaces_within_parens() {\n+                            format!(\"( {} )\", ty_str)\n+                        } else {\n+                            format!(\"({})\", ty_str)\n+                        }\n                     })\n             }\n             ast::TyKind::Slice(ref ty) => {\n@@ -683,10 +685,12 @@ impl Rewrite for ast::Ty {\n                     shape.width.checked_sub(2)?\n                 };\n                 ty.rewrite(context, Shape::legacy(budget, shape.indent + 1))\n-                    .map(|ty_str| if context.config.spaces_within_square_brackets() {\n-                        format!(\"[ {} ]\", ty_str)\n-                    } else {\n-                        format!(\"[{}]\", ty_str)\n+                    .map(|ty_str| {\n+                        if context.config.spaces_within_square_brackets() {\n+                            format!(\"[ {} ]\", ty_str)\n+                        } else {\n+                            format!(\"[{}]\", ty_str)\n+                        }\n                     })\n             }\n             ast::TyKind::Tup(ref items) => rewrite_tuple("}, {"sha": "32072acfc9e6d243b809e2b345ff34d626331860", "filename": "src/vertical.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fvertical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fvertical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvertical.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -191,13 +191,13 @@ fn struct_field_prefix_max_min_width<T: AlignedItem>(\n     fields\n         .iter()\n         .map(|field| {\n-            field\n-                .rewrite_prefix(context, shape)\n-                .and_then(|field_str| if field_str.contains('\\n') {\n+            field.rewrite_prefix(context, shape).and_then(|field_str| {\n+                if field_str.contains('\\n') {\n                     None\n                 } else {\n                     Some(field_str.len())\n-                })\n+                }\n+            })\n         })\n         .fold(Some((0, ::std::usize::MAX)), |acc, len| match (acc, len) {\n             (Some((max_len, min_len)), Some(len)) => {"}, {"sha": "8a4f7302aa461bda7cd6c6d43d6f93e55bced801", "filename": "src/visitor.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -136,13 +136,15 @@ impl<'a> FmtVisitor<'a> {\n                     self.last_pos,\n                     attr_lo.unwrap_or(first_stmt.span.lo()),\n                 ));\n-                let len = CommentCodeSlices::new(&snippet).nth(0).and_then(\n-                    |(kind, _, s)| if kind == CodeCharKind::Normal {\n-                        s.rfind('\\n')\n-                    } else {\n-                        None\n-                    },\n-                );\n+                let len = CommentCodeSlices::new(&snippet)\n+                    .nth(0)\n+                    .and_then(|(kind, _, s)| {\n+                        if kind == CodeCharKind::Normal {\n+                            s.rfind('\\n')\n+                        } else {\n+                            None\n+                        }\n+                    });\n                 if let Some(len) = len {\n                     self.last_pos = self.last_pos + BytePos::from_usize(len);\n                 }"}, {"sha": "d567008c2ade299395a82b4318fbb5a09fb87c56", "filename": "tests/source/closure-block-inside-macro.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Fsource%2Fclosure-block-inside-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Fsource%2Fclosure-block-inside-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fclosure-block-inside-macro.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -0,0 +1,11 @@\n+// rustfmt-fn_call_style: Block\n+\n+// #1547\n+fuzz_target!(|data: &[u8]| if let Some(first) = data.first() {\n+    let index = *first as usize;\n+    if index >= ENCODINGS.len() {\n+        return;\n+    }\n+    let encoding = ENCODINGS[index];\n+    dispatch_test(encoding, &data[1..]);\n+});"}, {"sha": "29332881c2fda3442ade8dd5f787c439c8b185a0", "filename": "tests/system.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -446,15 +446,17 @@ struct CharsIgnoreNewlineRepr<'a>(Peekable<Chars<'a>>);\n impl<'a> Iterator for CharsIgnoreNewlineRepr<'a> {\n     type Item = char;\n     fn next(&mut self) -> Option<char> {\n-        self.0.next().map(|c| if c == '\\r' {\n-            if *self.0.peek().unwrap_or(&'\\0') == '\\n' {\n-                self.0.next();\n-                '\\n'\n+        self.0.next().map(|c| {\n+            if c == '\\r' {\n+                if *self.0.peek().unwrap_or(&'\\0') == '\\n' {\n+                    self.0.next();\n+                    '\\n'\n+                } else {\n+                    '\\r'\n+                }\n             } else {\n-                '\\r'\n+                c\n             }\n-        } else {\n-            c\n         })\n     }\n }"}, {"sha": "c0fd18b44de87b16c406fc693fd2b0b82e8f7743", "filename": "tests/target/chains-visual.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fchains-visual.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fchains-visual.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-visual.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -21,10 +21,12 @@ fn main() {\n         false => (),\n     });\n \n-    loong_func().quux(move || if true {\n-        1\n-    } else {\n-        2\n+    loong_func().quux(move || {\n+        if true {\n+            1\n+        } else {\n+            2\n+        }\n     });\n \n     some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {"}, {"sha": "573570704abf739d14e07961df01efe522c1f4fa", "filename": "tests/target/chains.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -23,10 +23,12 @@ fn main() {\n         false => (),\n     });\n \n-    loong_func().quux(move || if true {\n-        1\n-    } else {\n-        2\n+    loong_func().quux(move || {\n+        if true {\n+            1\n+        } else {\n+            2\n+        }\n     });\n \n     some_fuuuuuuuuunction().method_call_a(aaaaa, bbbbb, |c| {"}, {"sha": "eb61fcfdbf43b6bad6f85f76bd1c481e62ed6461", "filename": "tests/target/hard-tabs.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fhard-tabs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f15dd870d1bf4e5b919ae654ed5d99ed48521fe8/tests%2Ftarget%2Fhard-tabs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fhard-tabs.rs?ref=f15dd870d1bf4e5b919ae654ed5d99ed48521fe8", "patch": "@@ -74,10 +74,12 @@ fn main() {\n \t\targ(a, b, c, d, e)\n \t}\n \n-\tloong_func().quux(move || if true {\n-\t\t1\n-\t} else {\n-\t\t2\n+\tloong_func().quux(move || {\n+\t\tif true {\n+\t\t\t1\n+\t\t} else {\n+\t\t\t2\n+\t\t}\n \t});\n \n \tfffffffffffffffffffffffffffffffffff(a, {"}]}