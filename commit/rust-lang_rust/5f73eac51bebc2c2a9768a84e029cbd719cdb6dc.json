{"sha": "5f73eac51bebc2c2a9768a84e029cbd719cdb6dc", "node_id": "C_kwDOAAsO6NoAKDVmNzNlYWM1MWJlYmMyYzJhOTc2OGE4NGUwMjljYmQ3MTljZGI2ZGM", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-10-27T19:59:09Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-02T20:05:09Z"}, "message": "Retry matching with tracking for diagnostics\n\nFor now, we only collect the small info for the `best_failure`, but\nusing this tracker, we can easily extend it in the future to track\nthings with more performance overhead.\n\nWe cannot retry cases where the macro failed with a parser error that\nwas emitted already, as that would cause us to emit the same error to\nthe user twice.", "tree": {"sha": "444edd9e2c2e489c6bf57b656253fa076f39c77a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/444edd9e2c2e489c6bf57b656253fa076f39c77a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN SSH SIGNATURE-----\nU1NIU0lHAAAAAQAAADMAAAALc3NoLWVkMjU1MTkAAAAgbSfWKRQb2tiqhuHtakDJeupmrF\nChDbM0msU+PXaBOk8AAAADZ2l0AAAAAAAAAAZzaGE1MTIAAABTAAAAC3NzaC1lZDI1NTE5\nAAAAQCAaPj/oHwoeOfSIWriPE8m7KxKPaY8OQ3bRSWBiJ8TBberL0km7ZRn8HmWLl+cZPk\npVxnmIesnTFiR6UN0g/go=\n-----END SSH SIGNATURE-----", "payload": "tree 444edd9e2c2e489c6bf57b656253fa076f39c77a\nparent 39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2\nauthor Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1666900749 +0200\ncommitter Nilstrieb <48135649+Nilstrieb@users.noreply.github.com> 1667419509 +0100\n\nRetry matching with tracking for diagnostics\n\nFor now, we only collect the small info for the `best_failure`, but\nusing this tracker, we can easily extend it in the future to track\nthings with more performance overhead.\n\nWe cannot retry cases where the macro failed with a parser error that\nwas emitted already, as that would cause us to emit the same error to\nthe user twice.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc", "html_url": "https://github.com/rust-lang/rust/commit/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2", "html_url": "https://github.com/rust-lang/rust/commit/39584b153b5f0b86a7efda9bba0a7d2cbe9b56e2"}], "stats": {"total": 118, "additions": 109, "deletions": 9}, "files": [{"sha": "b1214543e5db7b37348ac4d39a5917d354d25e10", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 109, "deletions": 9, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f73eac51bebc2c2a9768a84e029cbd719cdb6dc/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=5f73eac51bebc2c2a9768a84e029cbd719cdb6dc", "patch": "@@ -316,16 +316,116 @@ fn expand_macro<'cx>(\n                 is_local,\n             });\n         }\n-        Err(()) => {\n-            todo!(\"Retry macro invocation while tracking diagnostics info and emit error\");\n-\n+        Err(CanRetry::No(_)) => {\n+            debug!(\"Will not retry matching as an error was emitted already\");\n             return DummyResult::any(sp);\n         }\n+        Err(CanRetry::Yes) => {\n+            // Retry and emit a better error below.\n+        }\n+    }\n+\n+    // An error occured, try the expansion again, tracking the expansion closely for better diagnostics\n+    let mut tracker = CollectTrackerAndEmitter::new(cx, sp);\n+\n+    let try_success_result = try_match_macro(sess, name, &arg, lhses, &mut tracker);\n+    assert!(try_success_result.is_err(), \"Macro matching returned a success on the second try\");\n+\n+    if let Some(result) = tracker.result {\n+        // An irrecoverable error occured and has been emitted.\n+        return result;\n+    }\n+\n+    let Some((token, label)) = tracker.best_failure else {\n+        return tracker.result.expect(\"must have encountered Error or ErrorReported\");\n+    };\n+\n+    let span = token.span.substitute_dummy(sp);\n+\n+    let mut err = cx.struct_span_err(span, &parse_failure_msg(&token));\n+    err.span_label(span, label);\n+    if !def_span.is_dummy() && !cx.source_map().is_imported(def_span) {\n+        err.span_label(cx.source_map().guess_head_span(def_span), \"when calling this macro\");\n     }\n \n+    annotate_doc_comment(&mut err, sess.source_map(), span);\n+\n+    // Check whether there's a missing comma in this macro call, like `println!(\"{}\" a);`\n+    if let Some((arg, comma_span)) = arg.add_comma() {\n+        for lhs in lhses {\n+            let parser = parser_from_cx(sess, arg.clone());\n+            let mut tt_parser = TtParser::new(name);\n+\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs, &mut NoopTracker)\n+            {\n+                if comma_span.is_dummy() {\n+                    err.note(\"you might be missing a comma\");\n+                } else {\n+                    err.span_suggestion_short(\n+                        comma_span,\n+                        \"missing comma here\",\n+                        \", \",\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+    err.emit();\n+    cx.trace_macros_diag();\n     DummyResult::any(sp)\n }\n \n+/// The tracker used for the slow error path that collects useful info for diagnostics\n+struct CollectTrackerAndEmitter<'a, 'cx> {\n+    cx: &'a mut ExtCtxt<'cx>,\n+    /// Which arm's failure should we report? (the one furthest along)\n+    best_failure: Option<(Token, &'static str)>,\n+    root_span: Span,\n+    result: Option<Box<dyn MacResult + 'cx>>,\n+}\n+\n+impl<'a, 'cx, 'matcher> Tracker<'matcher> for CollectTrackerAndEmitter<'a, 'cx> {\n+    fn before_match_loc(&mut self, _parser: &TtParser, _matcher: &'matcher MatcherLoc) {\n+        // Empty for now.\n+    }\n+\n+    fn after_arm(&mut self, result: &NamedParseResult) {\n+        match result {\n+            Success(_) => {\n+                unreachable!(\"should not collect detailed info for successful macro match\");\n+            }\n+            Failure(token, msg) => match self.best_failure {\n+                Some((ref best_token, _)) if best_token.span.lo() >= token.span.lo() => {}\n+                _ => self.best_failure = Some((token.clone(), msg)),\n+            },\n+            Error(err_sp, msg) => {\n+                let span = err_sp.substitute_dummy(self.root_span);\n+                self.cx.struct_span_err(span, msg).emit();\n+                self.result = Some(DummyResult::any(span));\n+            }\n+            ErrorReported(_) => self.result = Some(DummyResult::any(self.root_span)),\n+        }\n+    }\n+\n+    fn description() -> &'static str {\n+        \"detailed\"\n+    }\n+}\n+\n+impl<'a, 'cx> CollectTrackerAndEmitter<'a, 'cx> {\n+    fn new(cx: &'a mut ExtCtxt<'cx>, root_span: Span) -> Self {\n+        Self { cx, best_failure: None, root_span, result: None }\n+    }\n+}\n+\n+enum CanRetry {\n+    Yes,\n+    /// We are not allowed to retry macro expansion as a fatal error has been emitted already.\n+    No(ErrorGuaranteed),\n+}\n+\n /// Try expanding the macro. Returns the index of the sucessful arm and its named_matches if it was successful,\n /// and nothing if it failed. On failure, it's the callers job to use `track` accordingly to record all errors\n /// correctly.\n@@ -335,7 +435,7 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n     arg: &TokenStream,\n     lhses: &'matcher [Vec<MatcherLoc>],\n     track: &mut T,\n-) -> Result<(usize, NamedMatches), ()> {\n+) -> Result<(usize, NamedMatches), CanRetry> {\n     // We create a base parser that can be used for the \"black box\" parts.\n     // Every iteration needs a fresh copy of that parser. However, the parser\n     // is not mutated on many of the iterations, particularly when dealing with\n@@ -383,10 +483,10 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n             }\n             Error(_, _) => {\n                 // We haven't emitted an error yet\n-                return Err(());\n+                return Err(CanRetry::Yes);\n             }\n-            ErrorReported(_) => {\n-                return Err(());\n+            ErrorReported(guarantee) => {\n+                return Err(CanRetry::No(guarantee));\n             }\n         }\n \n@@ -395,7 +495,7 @@ fn try_match_macro<'matcher, T: Tracker<'matcher>>(\n         mem::swap(&mut gated_spans_snapshot, &mut sess.gated_spans.spans.borrow_mut());\n     }\n \n-    Err(())\n+    Err(CanRetry::Yes)\n }\n \n // Note that macro-by-example's input is also matched against a token tree:\n@@ -478,7 +578,7 @@ pub fn compile_declarative_macro(\n     let mut tt_parser =\n         TtParser::new(Ident::with_dummy_span(if macro_rules { kw::MacroRules } else { kw::Macro }));\n     let argument_map =\n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, &mut NoopTracker) {\n+        match tt_parser.parse_tt(&mut Cow::Owned(parser), &argument_gram, &mut NoopTracker) {\n             Success(m) => m,\n             Failure(token, msg) => {\n                 let s = parse_failure_msg(&token);"}]}