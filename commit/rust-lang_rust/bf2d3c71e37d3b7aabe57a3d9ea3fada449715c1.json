{"sha": "bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMmQzYzcxZTM3ZDNiN2FhYmU1N2EzZDllYTNmYWRhNDQ5NzE1YzE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T18:25:15Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-05-04T18:25:15Z"}, "message": "improve DEBUG_BORROW printouts", "tree": {"sha": "794207f2a04a438f4d504ef053ddb3e0f270d404", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/794207f2a04a438f4d504ef053ddb3e0f270d404"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "html_url": "https://github.com/rust-lang/rust/commit/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0ff8200671c38e0068ba40267d02f99737e77cab", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ff8200671c38e0068ba40267d02f99737e77cab", "html_url": "https://github.com/rust-lang/rust/commit/0ff8200671c38e0068ba40267d02f99737e77cab"}], "stats": {"total": 161, "additions": 109, "deletions": 52}, "files": [{"sha": "3f7366c6c452bbc151dc9a393aff1d53cd8c7d1f", "filename": "src/libcore/cleanup.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcleanup.rs?ref=bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "patch": "@@ -167,7 +167,8 @@ fn debug_mem() -> bool {\n #[cfg(notest)]\n #[lang=\"annihilate\"]\n pub unsafe fn annihilate() {\n-    use unstable::lang::{local_free, debug_ptr};\n+    use unstable::lang::{local_free};\n+    use unstable::lang;\n     use io::WriterUtil;\n     use io;\n     use libc;\n@@ -191,10 +192,10 @@ pub unsafe fn annihilate() {\n     for each_live_alloc(true) |box, uniq| {\n         stats.n_total_boxes += 1;\n         if uniq {\n-            debug_ptr(\"Managed-uniq: \", &*box);\n+            lang::debug_mem(\"Managed-uniq: \", &*box);\n             stats.n_unique_boxes += 1;\n         } else {\n-            debug_ptr(\"Immortalizing: \", &*box);\n+            lang::debug_mem(\"Immortalizing: \", &*box);\n             (*box).header.ref_count = managed::raw::RC_IMMORTAL;\n         }\n     }\n@@ -206,13 +207,13 @@ pub unsafe fn annihilate() {\n     // callback, as the original value may have been freed.\n     for each_live_alloc(false) |box, uniq| {\n         if !uniq {\n-            debug_ptr(\"Invoking tydesc/glue on: \", &*box);\n+            lang::debug_mem(\"Invoking tydesc/glue on: \", &*box);\n             let tydesc: *TypeDesc = transmute(copy (*box).header.type_desc);\n             let drop_glue: DropGlue = transmute(((*tydesc).drop_glue, 0));\n-            debug_ptr(\"Box data: \", &(*box).data);\n-            debug_ptr(\"Type descriptor: \", tydesc);\n+            lang::debug_mem(\"Box data: \", &(*box).data);\n+            lang::debug_mem(\"Type descriptor: \", tydesc);\n             drop_glue(to_unsafe_ptr(&tydesc), transmute(&(*box).data));\n-            debug_ptr(\"Dropped \", &*box);\n+            lang::debug_mem(\"Dropped \", &*box);\n         }\n     }\n \n@@ -224,7 +225,7 @@ pub unsafe fn annihilate() {\n     // not be valid after.\n     for each_live_alloc(true) |box, uniq| {\n         if !uniq {\n-            debug_ptr(\"About to free: \", &*box);\n+            lang::debug_mem(\"About to free: \", &*box);\n             stats.n_bytes_freed +=\n                 (*((*box).header.type_desc)).size\n                 + sys::size_of::<BoxRepr>();"}, {"sha": "1d7ff17314901bf50093e8cdeecef254c22a3017", "filename": "src/libcore/rt/env.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Frt%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Frt%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Frt%2Fenv.rs?ref=bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "patch": "@@ -33,6 +33,8 @@ pub struct Environment {\n     argv: **c_char,\n     /// Print GC debugging info (true if env var RUST_DEBUG_MEM is set)\n     debug_mem: bool,\n+    /// Print GC debugging info (true if env var RUST_DEBUG_BORROW is set)\n+    debug_borrow: bool,\n }\n \n /// Get the global environment settings"}, {"sha": "5a65a5c24bb575ba536ab6dbf5935d123636f791", "filename": "src/libcore/unstable/lang.rs", "status": "modified", "additions": 95, "deletions": 44, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Flibcore%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funstable%2Flang.rs?ref=bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "patch": "@@ -20,6 +20,7 @@ use unstable::exchange_alloc;\n use cast::transmute;\n use task::rt::rust_get_task;\n use option::{Option, Some, None};\n+use io;\n \n #[allow(non_camel_case_types)]\n pub type rust_task = c_void;\n@@ -109,8 +110,8 @@ pub unsafe fn clear_task_borrow_list() {\n     let _ = try_take_task_borrow_list();\n }\n \n-fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n-    debug_ptr(\"fail_borrowed: \", box);\n+unsafe fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n+    debug_borrow(\"fail_borrowed: \", box, 0, 0, file, line);\n \n     match try_take_task_borrow_list() {\n         None => { // not recording borrows\n@@ -145,42 +146,95 @@ fn fail_borrowed(box: *mut BoxRepr, file: *c_char, line: size_t) {\n #[inline(always)]\n pub unsafe fn exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let result = transmute(exchange_alloc::malloc(transmute(td), transmute(size)));\n-    debug_ptr(\"exchange_malloc: \", result);\n+    debug_mem(\"exchange_malloc: \", result);\n     return result;\n }\n \n /// Because this code is so perf. sensitive, use a static constant so that\n /// debug printouts are compiled out most of the time.\n-static ENABLE_DEBUG_PTR: bool = true;\n+static ENABLE_DEBUG: bool = true;\n \n #[inline]\n-pub fn debug_ptr<T>(tag: &'static str, p: *const T) {\n+pub fn debug_mem<T>(tag: &'static str, p: *const T) {\n     //! A useful debugging function that prints a pointer + tag + newline\n     //! without allocating memory.\n \n-    if ENABLE_DEBUG_PTR && ::rt::env::get().debug_mem {\n-        debug_ptr_slow(tag, p);\n+    if ENABLE_DEBUG && ::rt::env::get().debug_mem {\n+        debug_mem_slow(tag, p);\n     }\n \n-    fn debug_ptr_slow<T>(tag: &'static str, p: *const T) {\n-        use io;\n+    fn debug_mem_slow<T>(tag: &'static str, p: *const T) {\n         let dbg = STDERR_FILENO as io::fd_t;\n-        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n         dbg.write_str(tag);\n+        dbg.write_hex(p as uint);\n+        dbg.write_str(\"\\n\");\n+    }\n+}\n+\n+#[inline]\n+unsafe fn debug_borrow<T>(tag: &'static str,\n+                          p: *const T,\n+                          old_bits: uint,\n+                          new_bits: uint,\n+                          filename: *c_char,\n+                          line: size_t) {\n+    //! A useful debugging function that prints a pointer + tag + newline\n+    //! without allocating memory.\n+\n+    if ENABLE_DEBUG && ::rt::env::get().debug_borrow {\n+        debug_borrow_slow(tag, p, old_bits, new_bits, filename, line);\n+    }\n+\n+    unsafe fn debug_borrow_slow<T>(tag: &'static str,\n+                                   p: *const T,\n+                                   old_bits: uint,\n+                                   new_bits: uint,\n+                                   filename: *c_char,\n+                                   line: size_t) {\n+        let dbg = STDERR_FILENO as io::fd_t;\n+        dbg.write_str(tag);\n+        dbg.write_hex(p as uint);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(old_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_hex(new_bits);\n+        dbg.write_str(\" \");\n+        dbg.write_cstr(filename);\n+        dbg.write_str(\":\");\n+        dbg.write_hex(line as uint);\n+        dbg.write_str(\"\\n\");\n+    }\n+}\n+\n+trait DebugPrints {\n+    fn write_hex(&self, val: uint);\n+    unsafe fn write_cstr(&self, str: *c_char);\n+}\n \n+impl DebugPrints for io::fd_t {\n+    fn write_hex(&self, mut i: uint) {\n+        let letters = ['0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                       '9', 'a', 'b', 'c', 'd', 'e', 'f'];\n         static uint_nibbles: uint = ::uint::bytes << 1;\n         let mut buffer = [0_u8, ..uint_nibbles+1];\n-        let mut i = p as uint;\n         let mut c = uint_nibbles;\n         while c > 0 {\n             c -= 1;\n             buffer[c] = letters[i & 0xF] as u8;\n             i >>= 4;\n         }\n-        dbg.write(buffer.slice(0, uint_nibbles));\n+        self.write(buffer.slice(0, uint_nibbles));\n+    }\n \n-        dbg.write_str(\"\\n\");\n+    unsafe fn write_cstr(&self, p: *c_char) {\n+        use libc::strlen;\n+        use vec;\n+\n+        let len = strlen(p);\n+        let p: *u8 = transmute(p);\n+        do vec::raw::buf_as_slice(p, len as uint) |s| {\n+            self.write(s);\n+        }\n     }\n }\n \n@@ -190,15 +244,15 @@ pub fn debug_ptr<T>(tag: &'static str, p: *const T) {\n #[lang=\"exchange_free\"]\n #[inline(always)]\n pub unsafe fn exchange_free(ptr: *c_char) {\n-    debug_ptr(\"exchange_free: \", ptr);\n+    debug_mem(\"exchange_free: \", ptr);\n     exchange_alloc::free(transmute(ptr))\n }\n \n #[lang=\"malloc\"]\n #[inline(always)]\n pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let result = rustrt::rust_upcall_malloc_noswitch(td, size);\n-    debug_ptr(\"local_malloc: \", result);\n+    debug_mem(\"local_malloc: \", result);\n     return result;\n }\n \n@@ -208,7 +262,7 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n #[lang=\"free\"]\n #[inline(always)]\n pub unsafe fn local_free(ptr: *c_char) {\n-    debug_ptr(\"local_free: \", ptr);\n+    debug_mem(\"local_free: \", ptr);\n     rustrt::rust_upcall_free_noswitch(ptr);\n }\n \n@@ -225,38 +279,37 @@ pub unsafe fn borrow_as_imm(a: *u8) {\n #[inline(always)]\n pub unsafe fn borrow_as_imm(a: *u8, file: *c_char, line: size_t) -> uint {\n     let a: *mut BoxRepr = transmute(a);\n-    let ref_count = (*a).header.ref_count;\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | FROZEN_BIT;\n \n-    debug_ptr(\"borrow_as_imm (ptr) :\", a);\n-    debug_ptr(\"              (ref) :\", ref_count as *());\n-    debug_ptr(\"              (line): \", line as *());\n+    debug_borrow(\"borrow_as_imm:\", a, old_ref_count, new_ref_count, file, line);\n \n-    if (ref_count & MUT_BIT) != 0 {\n+    if (old_ref_count & MUT_BIT) != 0 {\n         fail_borrowed(a, file, line);\n     }\n \n-    (*a).header.ref_count = ref_count | FROZEN_BIT;\n+    (*a).header.ref_count = new_ref_count;\n \n-    ref_count\n+    old_ref_count\n }\n \n #[cfg(not(stage0))]\n #[lang=\"borrow_as_mut\"]\n #[inline(always)]\n pub unsafe fn borrow_as_mut(a: *u8, file: *c_char, line: size_t) -> uint {\n     let a: *mut BoxRepr = transmute(a);\n+    let old_ref_count = (*a).header.ref_count;\n+    let new_ref_count = old_ref_count | MUT_BIT | FROZEN_BIT;\n \n-    debug_ptr(\"borrow_as_mut (ptr): \", a);\n-    debug_ptr(\"              (line): \", line as *());\n+    debug_borrow(\"borrow_as_mut:\", a, old_ref_count, new_ref_count, file, line);\n \n-    let ref_count = (*a).header.ref_count;\n-    if (ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n+    if (old_ref_count & (MUT_BIT|FROZEN_BIT)) != 0 {\n         fail_borrowed(a, file, line);\n     }\n \n-    (*a).header.ref_count = ref_count | MUT_BIT | FROZEN_BIT;\n+    (*a).header.ref_count = new_ref_count;\n \n-    ref_count\n+    old_ref_count\n }\n \n \n@@ -267,6 +320,7 @@ pub unsafe fn record_borrow(a: *u8, old_ref_count: uint,\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before\n         let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"record_borrow:\", a, old_ref_count, 0, file, line);\n         do swap_task_borrow_list |borrow_list| {\n             let mut borrow_list = borrow_list;\n             borrow_list.push(BorrowRecord {box: a, file: file, line: line});\n@@ -282,6 +336,7 @@ pub unsafe fn unrecord_borrow(a: *u8, old_ref_count: uint,\n     if (old_ref_count & ALL_BITS) == 0 {\n         // was not borrowed before\n         let a: *mut BoxRepr = transmute(a);\n+        debug_borrow(\"unrecord_borrow:\", a, old_ref_count, 0, file, line);\n         do swap_task_borrow_list |borrow_list| {\n             let mut borrow_list = borrow_list;\n             let br = BorrowRecord {box: a, file: file, line: line};\n@@ -317,21 +372,20 @@ pub unsafe fn return_to_mut(a: *u8) {\n #[cfg(not(stage0))]\n #[lang=\"return_to_mut\"]\n #[inline(always)]\n-pub unsafe fn return_to_mut(a: *u8, old_ref_count: uint,\n+pub unsafe fn return_to_mut(a: *u8, orig_ref_count: uint,\n                             file: *c_char, line: size_t) {\n     // Sometimes the box is null, if it is conditionally frozen.\n     // See e.g. #4904.\n     if !a.is_null() {\n         let a: *mut BoxRepr = transmute(a);\n-        let ref_count = (*a).header.ref_count;\n-        let combined = (ref_count & !ALL_BITS) | (old_ref_count & ALL_BITS);\n-        (*a).header.ref_count = combined;\n-\n-        debug_ptr(\"return_to_mut (ptr) : \", a);\n-        debug_ptr(\"              (line): \", line as *());\n-        debug_ptr(\"              (old) : \", old_ref_count as *());\n-        debug_ptr(\"              (new) : \", ref_count as *());\n-        debug_ptr(\"              (comb): \", combined as *());\n+        let old_ref_count = (*a).header.ref_count;\n+        let new_ref_count =\n+            (old_ref_count & !ALL_BITS) | (orig_ref_count & ALL_BITS);\n+\n+        debug_borrow(\"return_to_mut:\",\n+                     a, old_ref_count, new_ref_count, file, line);\n+\n+        (*a).header.ref_count = new_ref_count;\n     }\n }\n \n@@ -355,10 +409,7 @@ pub unsafe fn check_not_borrowed(a: *u8,\n                                  line: size_t) {\n     let a: *mut BoxRepr = transmute(a);\n     let ref_count = (*a).header.ref_count;\n-    debug_ptr(\"check_not_borrowed (ptr) : \", a);\n-    debug_ptr(\"                   (line): \", line as *());\n-    debug_ptr(\"                   (rc)  : \", ref_count as *());\n-\n+    debug_borrow(\"check_not_borrowed:\", a, ref_count, 0, file, line);\n     if (ref_count & FROZEN_BIT) != 0 {\n         fail_borrowed(a, file, line);\n     }"}, {"sha": "360d611492853814a7abcb982835240015891874", "filename": "src/rt/rust_env.cpp", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Frt%2Frust_env.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Frt%2Frust_env.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.cpp?ref=bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "patch": "@@ -24,6 +24,7 @@\n #define RUST_SEED \"RUST_SEED\"\n #define RUST_POISON_ON_FREE \"RUST_POISON_ON_FREE\"\n #define RUST_DEBUG_MEM \"RUST_DEBUG_MEM\"\n+#define RUST_DEBUG_BORROW \"RUST_DEBUG_BORROW\"\n \n #if defined(__WIN32__)\n static int\n@@ -130,6 +131,7 @@ load_env(int argc, char **argv) {\n     env->argc = argc;\n     env->argv = argv;\n     env->debug_mem = getenv(RUST_DEBUG_MEM) != NULL;\n+    env->debug_borrow = getenv(RUST_DEBUG_BORROW) != NULL;\n     return env;\n }\n "}, {"sha": "b897f0c09a90b7f625667d2a1b753ccf5fc5a981", "filename": "src/rt/rust_env.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Frt%2Frust_env.h", "raw_url": "https://github.com/rust-lang/rust/raw/bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1/src%2Frt%2Frust_env.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_env.h?ref=bf2d3c71e37d3b7aabe57a3d9ea3fada449715c1", "patch": "@@ -28,6 +28,7 @@ struct rust_env {\n     int argc;\n     char **argv;\n     rust_bool debug_mem;\n+    rust_bool debug_borrow;\n };\n \n rust_env* load_env(int argc, char **argv);"}]}