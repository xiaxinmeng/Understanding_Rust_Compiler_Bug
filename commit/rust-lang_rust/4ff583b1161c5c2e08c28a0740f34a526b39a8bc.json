{"sha": "4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmZjU4M2IxMTYxYzVjMmUwOGMyOGEwNzQwZjM0YTUyNmIzOWE4YmM=", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-04-04T16:31:38Z"}, "committer": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2017-05-05T03:54:54Z"}, "message": "fallout from NonZero/Unique/Shared changes", "tree": {"sha": "87c20810517afc4920da1ab90e78f7585790d284", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/87c20810517afc4920da1ab90e78f7585790d284"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "html_url": "https://github.com/rust-lang/rust/commit/4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6", "html_url": "https://github.com/rust-lang/rust/commit/6e2efe3aa477bdc8d7ccdb904523ad18d612bbb6"}], "stats": {"total": 243, "additions": 123, "deletions": 120}, "files": [{"sha": "921db3c6959b8b0d2b935f28164d036f2eff00fd", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 13, "deletions": 18, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -277,8 +277,7 @@ impl<T> Arc<T> {\n         atomic::fence(Acquire);\n \n         unsafe {\n-            let ptr = *this.ptr;\n-            let elem = ptr::read(&(*ptr).data);\n+            let elem = ptr::read(&this.ptr.as_ref().data);\n \n             // Make a weak pointer to clean up the implicit strong-weak reference\n             let _weak = Weak { ptr: this.ptr };\n@@ -306,7 +305,7 @@ impl<T> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &(**this.ptr).data as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -345,7 +344,7 @@ impl<T> Arc<T> {\n         // `data` field from the pointer.\n         let ptr = (ptr as *const u8).offset(-offset_of!(ArcInner<T>, data));\n         Arc {\n-            ptr: Shared::new(ptr as *const _),\n+            ptr: Shared::new(ptr as *mut u8 as *mut _),\n         }\n     }\n }\n@@ -452,17 +451,17 @@ impl<T: ?Sized> Arc<T> {\n         // `ArcInner` structure itself is `Sync` because the inner data is\n         // `Sync` as well, so we're ok loaning out an immutable pointer to these\n         // contents.\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n \n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_mut_ptr();\n+        let ptr = self.ptr.as_ptr();\n \n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n-        ptr::drop_in_place(&mut (*ptr).data);\n+        ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n@@ -488,9 +487,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert!(!Arc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const ArcInner<T> = *this.ptr;\n-        let other_ptr: *const ArcInner<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -621,7 +618,7 @@ impl<T: Clone> Arc<T> {\n                 // here (due to zeroing) because data is no longer accessed by\n                 // other threads (due to there being no more strong refs at this\n                 // point).\n-                let mut swap = Arc::new(ptr::read(&(**weak.ptr).data));\n+                let mut swap = Arc::new(ptr::read(&weak.ptr.as_ref().data));\n                 mem::swap(this, &mut swap);\n                 mem::forget(swap);\n             }\n@@ -634,8 +631,7 @@ impl<T: Clone> Arc<T> {\n         // As with `get_mut()`, the unsafety is ok because our reference was\n         // either unique to begin with, or became one upon cloning the contents.\n         unsafe {\n-            let inner = &mut *this.ptr.as_mut_ptr();\n-            &mut inner.data\n+            &mut this.ptr.as_mut().data\n         }\n     }\n }\n@@ -677,8 +673,7 @@ impl<T: ?Sized> Arc<T> {\n             // the Arc itself to be `mut`, so we're returning the only possible\n             // reference to the inner data.\n             unsafe {\n-                let inner = &mut *this.ptr.as_mut_ptr();\n-                Some(&mut inner.data)\n+                Some(&mut this.ptr.as_mut().data)\n             }\n         } else {\n             None\n@@ -867,7 +862,7 @@ impl<T: ?Sized> Weak<T> {\n     #[inline]\n     fn inner(&self) -> &ArcInner<T> {\n         // See comments above for why this is \"safe\"\n-        unsafe { &**self.ptr }\n+        unsafe { self.ptr.as_ref() }\n     }\n }\n \n@@ -951,7 +946,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.as_ptr();\n \n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n@@ -1132,7 +1127,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Arc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Arc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n "}, {"sha": "1f6f5ba17ede91296337e4ce126f2b8241163ec1", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -151,7 +151,7 @@ impl<T> RawVec<T> {\n     /// heap::EMPTY if `cap = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n-        *self.ptr\n+        self.ptr.ptr()\n     }\n \n     /// Gets the capacity of the allocation.\n@@ -563,7 +563,7 @@ unsafe impl<#[may_dangle] T> Drop for RawVec<T> {\n \n             let num_bytes = elem_size * self.cap;\n             unsafe {\n-                heap::deallocate(*self.ptr as *mut _, num_bytes, align);\n+                heap::deallocate(self.ptr() as *mut u8, num_bytes, align);\n             }\n         }\n     }"}, {"sha": "d6dbf77bfac770466ff3dfb8de43e83397d217fd", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -230,7 +230,7 @@ use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n-use core::intrinsics::{abort, assume};\n+use core::intrinsics::abort;\n use core::marker;\n use core::marker::Unsize;\n use core::mem::{self, align_of_val, forget, size_of, size_of_val, uninitialized};\n@@ -358,7 +358,7 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n-        let ptr = unsafe { &mut (*this.ptr.as_mut_ptr()).value as *const _ };\n+        let ptr: *const T = &*this;\n         mem::forget(this);\n         ptr\n     }\n@@ -395,7 +395,11 @@ impl<T> Rc<T> {\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         // To find the corresponding pointer to the `RcBox` we need to subtract the offset of the\n         // `value` field from the pointer.\n-        Rc { ptr: Shared::new((ptr as *const u8).offset(-offset_of!(RcBox<T>, value)) as *const _) }\n+\n+        let ptr = (ptr as *const u8).offset(-offset_of!(RcBox<T>, value));\n+        Rc {\n+            ptr: Shared::new(ptr as *mut u8 as *mut _)\n+        }\n     }\n }\n \n@@ -451,7 +455,7 @@ impl<T> Rc<[T]> {\n             // Free the original allocation without freeing its (moved) contents.\n             box_free(Box::into_raw(value));\n \n-            Rc { ptr: Shared::new(ptr as *const _) }\n+            Rc { ptr: Shared::new(ptr as *mut _) }\n         }\n     }\n }\n@@ -553,8 +557,9 @@ impl<T: ?Sized> Rc<T> {\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn get_mut(this: &mut Self) -> Option<&mut T> {\n         if Rc::is_unique(this) {\n-            let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-            Some(&mut inner.value)\n+            unsafe {\n+                Some(&mut this.ptr.as_mut().value)\n+            }\n         } else {\n             None\n         }\n@@ -578,9 +583,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert!(!Rc::ptr_eq(&five, &other_five));\n     /// ```\n     pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        let this_ptr: *const RcBox<T> = *this.ptr;\n-        let other_ptr: *const RcBox<T> = *other.ptr;\n-        this_ptr == other_ptr\n+        this.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -623,7 +626,7 @@ impl<T: Clone> Rc<T> {\n         } else if Rc::weak_count(this) != 0 {\n             // Can just steal the data, all that's left is Weaks\n             unsafe {\n-                let mut swap = Rc::new(ptr::read(&(**this.ptr).value));\n+                let mut swap = Rc::new(ptr::read(&this.ptr.as_ref().value));\n                 mem::swap(this, &mut swap);\n                 swap.dec_strong();\n                 // Remove implicit strong-weak ref (no need to craft a fake\n@@ -637,8 +640,9 @@ impl<T: Clone> Rc<T> {\n         // reference count is guaranteed to be 1 at this point, and we required\n         // the `Rc<T>` itself to be `mut`, so we're returning the only possible\n         // reference to the inner value.\n-        let inner = unsafe { &mut *this.ptr.as_mut_ptr() };\n-        &mut inner.value\n+        unsafe {\n+            &mut this.ptr.as_mut().value\n+        }\n     }\n }\n \n@@ -683,12 +687,12 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_mut_ptr();\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n-                ptr::drop_in_place(&mut (*ptr).value);\n+                ptr::drop_in_place(self.ptr.as_mut());\n \n                 // remove the implicit \"strong weak\" pointer now that we've\n                 // destroyed the contents.\n@@ -925,7 +929,7 @@ impl<T: ?Sized + fmt::Debug> fmt::Debug for Rc<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> fmt::Pointer for Rc<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::Pointer::fmt(&*self.ptr, f)\n+        fmt::Pointer::fmt(&self.ptr, f)\n     }\n }\n \n@@ -1067,7 +1071,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = *self.ptr;\n+            let ptr = self.ptr.as_ptr();\n \n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n@@ -1175,12 +1179,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }\n@@ -1189,12 +1188,7 @@ impl<T: ?Sized> RcBoxPtr<T> for Weak<T> {\n     #[inline(always)]\n     fn inner(&self) -> &RcBox<T> {\n         unsafe {\n-            // Safe to assume this here, as if it weren't true, we'd be breaking\n-            // the contract anyway.\n-            // This allows the null check to be elided in the destructor if we\n-            // manipulated the reference count in the same function.\n-            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-            &(**self.ptr)\n+            self.ptr.as_ref()\n         }\n     }\n }"}, {"sha": "52cdd39d8f963c0666bcc26ba71765ad977c6917", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -152,12 +152,12 @@ impl<K, V> BoxedNode<K, V> {\n     }\n \n     unsafe fn from_ptr(ptr: NonZero<*const LeafNode<K, V>>) -> Self {\n-        BoxedNode { ptr: Unique::new(*ptr as *mut LeafNode<K, V>) }\n+        BoxedNode { ptr: Unique::new(ptr.get() as *mut LeafNode<K, V>) }\n     }\n \n     fn as_ptr(&self) -> NonZero<*const LeafNode<K, V>> {\n         unsafe {\n-            NonZero::new(*self.ptr as *const LeafNode<K, V>)\n+            NonZero::new(self.ptr.as_ptr())\n         }\n     }\n }\n@@ -241,7 +241,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = *self.node.ptr as *mut u8;\n+        let top = self.node.ptr.as_ptr() as *mut u8;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -308,15 +308,15 @@ unsafe impl<K: Send, V: Send, Type> Send\n impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::Internal> {\n     fn as_internal(&self) -> &InternalNode<K, V> {\n         unsafe {\n-            &*(*self.node as *const InternalNode<K, V>)\n+            &*(self.node.get() as *const InternalNode<K, V>)\n         }\n     }\n }\n \n impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n     fn as_internal_mut(&mut self) -> &mut InternalNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut InternalNode<K, V>)\n+            &mut *(self.node.get() as *mut InternalNode<K, V>)\n         }\n     }\n }\n@@ -358,7 +358,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n \n     fn as_leaf(&self) -> &LeafNode<K, V> {\n         unsafe {\n-            &**self.node\n+            &*self.node.get()\n         }\n     }\n \n@@ -510,7 +510,7 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n \n     fn as_leaf_mut(&mut self) -> &mut LeafNode<K, V> {\n         unsafe {\n-            &mut *(*self.node as *mut LeafNode<K, V>)\n+            &mut *(self.node.get() as *mut LeafNode<K, V>)\n         }\n     }\n \n@@ -1253,13 +1253,13 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<InternalNode<K, V>>(),\n                     mem::align_of::<InternalNode<K, V>>()\n                 );\n             } else {\n                 heap::deallocate(\n-                    *right_node.node as *mut u8,\n+                    right_node.node.get() as *mut u8,\n                     mem::size_of::<LeafNode<K, V>>(),\n                     mem::align_of::<LeafNode<K, V>>()\n                 );"}, {"sha": "ae258083546f4fddcb52cbeb22920527de8f66a9", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 43, "deletions": 29, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -161,7 +161,7 @@ impl<T> LinkedList<T> {\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(head) => (*head.as_mut_ptr()).prev = node,\n+                Some(mut head) => head.as_mut().prev = node,\n             }\n \n             self.head = node;\n@@ -173,12 +173,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n         self.head.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(head) => (*head.as_mut_ptr()).prev = None,\n+                Some(mut head) => head.as_mut().prev = None,\n             }\n \n             self.len -= 1;\n@@ -196,7 +196,7 @@ impl<T> LinkedList<T> {\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(tail) => (*tail.as_mut_ptr()).next = node,\n+                Some(mut tail) => tail.as_mut().next = node,\n             }\n \n             self.tail = node;\n@@ -208,12 +208,12 @@ impl<T> LinkedList<T> {\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n         self.tail.map(|node| unsafe {\n-            let node = Box::from_raw(node.as_mut_ptr());\n+            let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(tail) => (*tail.as_mut_ptr()).next = None,\n+                Some(mut tail) => tail.as_mut().next = None,\n             }\n \n             self.len -= 1;\n@@ -285,11 +285,11 @@ impl<T> LinkedList<T> {\n     pub fn append(&mut self, other: &mut Self) {\n         match self.tail {\n             None => mem::swap(self, other),\n-            Some(tail) => {\n-                if let Some(other_head) = other.head.take() {\n+            Some(mut tail) => {\n+                if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n-                        (*tail.as_mut_ptr()).next = Some(other_head);\n-                        (*other_head.as_mut_ptr()).prev = Some(tail);\n+                        tail.as_mut().next = Some(other_head);\n+                        other_head.as_mut().prev = Some(tail);\n                     }\n \n                     self.tail = other.tail.take();\n@@ -477,7 +477,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front(&self) -> Option<&T> {\n-        self.head.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.head.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the front element, or `None` if the list\n@@ -503,7 +505,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn front_mut(&mut self) -> Option<&mut T> {\n-        self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.head.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Provides a reference to the back element, or `None` if the list is\n@@ -523,7 +527,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back(&self) -> Option<&T> {\n-        self.tail.map(|node| unsafe { &(**node).element })\n+        unsafe {\n+            self.tail.as_ref().map(|node| &node.as_ref().element)\n+        }\n     }\n \n     /// Provides a mutable reference to the back element, or `None` if the list\n@@ -549,7 +555,9 @@ impl<T> LinkedList<T> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn back_mut(&mut self) -> Option<&mut T> {\n-        self.tail.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+        unsafe {\n+            self.tail.as_mut().map(|node| &mut node.as_mut().element)\n+        }\n     }\n \n     /// Adds an element first in the list.\n@@ -694,9 +702,9 @@ impl<T> LinkedList<T> {\n         let second_part_head;\n \n         unsafe {\n-            second_part_head = (*split_node.unwrap().as_mut_ptr()).next.take();\n-            if let Some(head) = second_part_head {\n-                (*head.as_mut_ptr()).prev = None;\n+            second_part_head = split_node.unwrap().as_mut().next.take();\n+            if let Some(mut head) = second_part_head {\n+                head.as_mut().prev = None;\n             }\n         }\n \n@@ -788,7 +796,8 @@ impl<'a, T> Iterator for Iter<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &node.element\n@@ -810,7 +819,8 @@ impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &**node;\n+                // Need an unbound lifetime to get 'a\n+                let node = &*node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &node.element\n@@ -835,7 +845,8 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n             None\n         } else {\n             self.head.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.head = node.next;\n                 &mut node.element\n@@ -857,7 +868,8 @@ impl<'a, T> DoubleEndedIterator for IterMut<'a, T> {\n             None\n         } else {\n             self.tail.map(|node| unsafe {\n-                let node = &mut *node.as_mut_ptr();\n+                // Need an unbound lifetime to get 'a\n+                let node = &mut *node.as_ptr();\n                 self.len -= 1;\n                 self.tail = node.prev;\n                 &mut node.element\n@@ -903,8 +915,8 @@ impl<'a, T> IterMut<'a, T> {\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n             None => self.list.push_back(element),\n-            Some(head) => unsafe {\n-                let prev = match (**head).prev {\n+            Some(mut head) => unsafe {\n+                let mut prev = match head.as_ref().prev {\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -915,8 +927,8 @@ impl<'a, T> IterMut<'a, T> {\n                     element: element,\n                 })));\n \n-                (*prev.as_mut_ptr()).next = node;\n-                (*head.as_mut_ptr()).prev = node;\n+                prev.as_mut().next = node;\n+                head.as_mut().prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -948,7 +960,9 @@ impl<'a, T> IterMut<'a, T> {\n         if self.len == 0 {\n             None\n         } else {\n-            self.head.map(|node| unsafe { &mut (*node.as_mut_ptr()).element })\n+            unsafe {\n+                self.head.as_mut().map(|node| &mut node.as_mut().element)\n+            }\n         }\n     }\n }\n@@ -1276,21 +1290,21 @@ mod tests {\n                     assert_eq!(0, list.len);\n                     return;\n                 }\n-                Some(node) => node_ptr = &**node,\n+                Some(node) => node_ptr = &*node.as_ptr(),\n             }\n             loop {\n                 match (last_ptr, node_ptr.prev) {\n                     (None, None) => {}\n                     (None, _) => panic!(\"prev link for head\"),\n                     (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, *pptr as *const Node<T>);\n+                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n                     }\n                     _ => panic!(\"prev link is none, not good\"),\n                 }\n                 match node_ptr.next {\n                     Some(next) => {\n                         last_ptr = Some(node_ptr);\n-                        node_ptr = &**next;\n+                        node_ptr = &*next.as_ptr();\n                         len += 1;\n                     }\n                     None => {"}, {"sha": "02ad0a67bdac3e8cb94c93b544c2db7af67850e1", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -1776,9 +1776,9 @@ impl<T> SpecExtend<T, IntoIter<T>> for Vec<T> {\n         // A common case is passing a vector into a function which immediately\n         // re-collects into a vector. We can short circuit this if the IntoIter\n         // has not been advanced at all.\n-        if *iterator.buf == iterator.ptr as *mut T {\n+        if iterator.buf.as_ptr() as *const _ == iterator.ptr {\n             unsafe {\n-                let vec = Vec::from_raw_parts(*iterator.buf as *mut T,\n+                let vec = Vec::from_raw_parts(iterator.buf.as_ptr(),\n                                               iterator.len(),\n                                               iterator.cap);\n                 mem::forget(iterator);\n@@ -2269,7 +2269,7 @@ unsafe impl<#[may_dangle] T> Drop for IntoIter<T> {\n         for _x in self.by_ref() {}\n \n         // RawVec handles deallocation\n-        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_mut_ptr(), self.cap) };\n+        let _ = unsafe { RawVec::from_raw_parts(self.buf.as_ptr(), self.cap) };\n     }\n }\n \n@@ -2334,7 +2334,7 @@ impl<'a, T> Drop for Drain<'a, T> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_vec = &mut *self.vec.as_mut_ptr();\n+                let source_vec = self.vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_vec.len();\n                 let tail = self.tail_start;\n@@ -2456,8 +2456,7 @@ impl<'a, I: Iterator> Drop for Splice<'a, I> {\n \n         unsafe {\n             if self.drain.tail_len == 0 {\n-                let vec = &mut *self.drain.vec.as_mut_ptr();\n-                vec.extend(self.replace_with.by_ref());\n+                self.drain.vec.as_mut().extend(self.replace_with.by_ref());\n                 return\n             }\n \n@@ -2498,7 +2497,7 @@ impl<'a, T> Drain<'a, T> {\n     /// Fill that range as much as possible with new elements from the `replace_with` iterator.\n     /// Return whether we filled the entire range. (`replace_with.next()` didn\u2019t return `None`.)\n     unsafe fn fill<I: Iterator<Item=T>>(&mut self, replace_with: &mut I) -> bool {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let range_start = vec.len;\n         let range_end = self.tail_start;\n         let range_slice = slice::from_raw_parts_mut(\n@@ -2518,7 +2517,7 @@ impl<'a, T> Drain<'a, T> {\n \n     /// Make room for inserting more elements before the tail.\n     unsafe fn move_tail(&mut self, extra_capacity: usize) {\n-        let vec = &mut *self.vec.as_mut_ptr();\n+        let vec = self.vec.as_mut();\n         let used_capacity = self.tail_start + self.tail_len;\n         vec.buf.reserve(used_capacity, extra_capacity);\n "}, {"sha": "e826c9432b516133663c57c94a5624d7bd41fb0f", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -2160,7 +2160,7 @@ impl<'a, T: 'a> Drop for Drain<'a, T> {\n     fn drop(&mut self) {\n         for _ in self.by_ref() {}\n \n-        let source_deque = unsafe { &mut *self.deque.as_mut_ptr() };\n+        let source_deque = unsafe { self.deque.as_mut() };\n \n         // T = source_deque_tail; H = source_deque_head; t = drain_tail; h = drain_head\n         //"}, {"sha": "7886f90b66e85b64baa56590c174d0ba199fb8f0", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -132,7 +132,6 @@\n //! use std::cell::Cell;\n //! use std::ptr::Shared;\n //! use std::intrinsics::abort;\n-//! use std::intrinsics::assume;\n //!\n //! struct Rc<T: ?Sized> {\n //!     ptr: Shared<RcBox<T>>\n@@ -171,8 +170,7 @@\n //! impl<T: ?Sized> RcBoxPtr<T> for Rc<T> {\n //!    fn inner(&self) -> &RcBox<T> {\n //!        unsafe {\n-//!            assume(!(*(&self.ptr as *const _ as *const *const ())).is_null());\n-//!            &(**self.ptr)\n+//!            self.ptr.as_ref()\n //!        }\n //!    }\n //! }"}, {"sha": "588fffda35fca3dc20158d2b48dff128fcd21d2a", "filename": "src/libcore/tests/nonzero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Ftests%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Ftests%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fnonzero.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -31,12 +31,12 @@ fn test_match_on_nonzero_option() {\n         NonZero::new(42)\n     });\n     match a {\n-        Some(val) => assert_eq!(*val, 42),\n+        Some(val) => assert_eq!(val.get(), 42),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n \n     match unsafe { Some(NonZero::new(43)) } {\n-        Some(val) => assert_eq!(*val, 43),\n+        Some(val) => assert_eq!(val.get(), 43),\n         None => panic!(\"unexpected None while matching on Some(NonZero(_))\")\n     }\n }"}, {"sha": "e28dc6a6881fde06acd2fc3a3b97269643b0b020", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -166,10 +166,10 @@ fn test_set_memory() {\n \n #[test]\n fn test_unsized_unique() {\n-    let xs: &mut [i32] = &mut [1, 2, 3];\n-    let ptr = unsafe { Unique::new(xs as *mut [i32]) };\n-    let ys = unsafe { &mut **ptr };\n-    let zs: &mut [i32] = &mut [1, 2, 3];\n+    let xs: &[i32] = &[1, 2, 3];\n+    let ptr = unsafe { Unique::new(xs as *const [i32] as *mut [i32]) };\n+    let ys = unsafe { ptr.as_ref() };\n+    let zs: &[i32] = &[1, 2, 3];\n     assert!(ys == zs);\n }\n "}, {"sha": "3619be82829cade3559577dd57a0f9fe71da2d52", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -62,14 +62,14 @@ pub struct Bytes {\n impl Deref for Bytes {\n     type Target = [u8];\n     fn deref(&self) -> &[u8] {\n-        unsafe { slice::from_raw_parts(*self.ptr, self.len) }\n+        unsafe { slice::from_raw_parts(self.ptr.as_ptr(), self.len) }\n     }\n }\n \n impl Drop for Bytes {\n     fn drop(&mut self) {\n         unsafe {\n-            libc::free(*self.ptr as *mut _);\n+            libc::free(self.ptr.as_ptr() as *mut _);\n         }\n     }\n }"}, {"sha": "c9ffcee51c20ad1e346b54109a98949c174d8112", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -72,7 +72,7 @@ impl<'tcx> From<ty::Region<'tcx>> for Kind<'tcx> {\n impl<'tcx> Kind<'tcx> {\n     #[inline]\n     unsafe fn downcast<T>(self, tag: usize) -> Option<&'tcx T> {\n-        let ptr = *self.ptr;\n+        let ptr = self.ptr.get();\n         if ptr & TAG_MASK == tag {\n             Some(&*((ptr & !TAG_MASK) as *const _))\n         } else {\n@@ -102,7 +102,7 @@ impl<'tcx> fmt::Debug for Kind<'tcx> {\n         } else if let Some(r) = self.as_region() {\n             write!(f, \"{:?}\", r)\n         } else {\n-            write!(f, \"<unknwon @ {:p}>\", *self.ptr as *const ())\n+            write!(f, \"<unknwon @ {:p}>\", self.ptr.get() as *const ())\n         }\n     }\n }"}, {"sha": "ed5e539f245f10fb2280d4821e8bf39f38166796", "filename": "src/librustc_borrowck/borrowck/mir/gather_moves.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmir%2Fgather_moves.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -43,7 +43,7 @@ mod indexes {\n                     unsafe { $Index(NonZero::new(idx + 1)) }\n                 }\n                 fn index(self) -> usize {\n-                    *self.0 - 1\n+                    self.0.get() - 1\n                 }\n             }\n "}, {"sha": "078bb801751d0b2bf4bd54d43a2c4f8944888ed1", "filename": "src/librustc_data_structures/array_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_data_structures%2Farray_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_data_structures%2Farray_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Farray_vec.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -255,7 +255,7 @@ impl<'a, A: Array> Drop for Drain<'a, A> {\n \n         if self.tail_len > 0 {\n             unsafe {\n-                let source_array_vec = &mut *self.array_vec.as_mut_ptr();\n+                let source_array_vec = self.array_vec.as_mut();\n                 // memmove back untouched tail, update to new length\n                 let start = source_array_vec.len();\n                 let tail = self.tail_start;"}, {"sha": "023c56ca59be8fcfd97e4b9fd31d9e4dcb07401e", "filename": "src/librustc_data_structures/obligation_forest/node_index.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fobligation_forest%2Fnode_index.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -23,6 +23,6 @@ impl NodeIndex {\n     }\n \n     pub fn get(self) -> usize {\n-        (*self.index - 1) as usize\n+        (self.index.get() - 1) as usize\n     }\n }"}, {"sha": "0a488dfd53a009f0a3f9c55bed773a4a9975e771", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ff583b1161c5c2e08c28a0740f34a526b39a8bc/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=4ff583b1161c5c2e08c28a0740f34a526b39a8bc", "patch": "@@ -49,24 +49,25 @@ impl TaggedHashUintPtr {\n \n     #[inline]\n     fn set_tag(&mut self, value: bool) {\n-        let usize_ptr = &*self.0 as *const *mut HashUint as *mut usize;\n+        let mut usize_ptr = self.0.as_ptr() as usize;\n         unsafe {\n             if value {\n-                *usize_ptr |= 1;\n+                usize_ptr |= 1;\n             } else {\n-                *usize_ptr &= !1;\n+                usize_ptr &= !1;\n             }\n+            self.0 = Unique::new(usize_ptr as *mut HashUint)\n         }\n     }\n \n     #[inline]\n     fn tag(&self) -> bool {\n-        (*self.0 as usize) & 1 == 1\n+        (self.0.as_ptr() as usize) & 1 == 1\n     }\n \n     #[inline]\n     fn ptr(&self) -> *mut HashUint {\n-        (*self.0 as usize & !1) as *mut HashUint\n+        (self.0.as_ptr() as usize & !1) as *mut HashUint\n     }\n }\n \n@@ -1112,10 +1113,12 @@ impl<'a, K, V> Iterator for Drain<'a, K, V> {\n \n     #[inline]\n     fn next(&mut self) -> Option<(SafeHash, K, V)> {\n-        self.iter.next().map(|raw| unsafe {\n-            (*self.table.as_mut_ptr()).size -= 1;\n-            let (k, v) = ptr::read(raw.pair());\n-            (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+        self.iter.next().map(|raw| {\n+            unsafe {\n+                self.table.as_mut().size -= 1;\n+                let (k, v) = ptr::read(raw.pair());\n+                (SafeHash { hash: ptr::replace(&mut *raw.hash(), EMPTY_BUCKET) }, k, v)\n+            }\n         })\n     }\n "}]}