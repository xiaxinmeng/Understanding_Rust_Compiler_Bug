{"sha": "8e5b318d99d3d215ab0ae84b1a80e8034975002d", "node_id": "C_kwDOAAsO6NoAKDhlNWIzMThkOTlkM2QyMTVhYjBhZTg0YjFhODBlODAzNDk3NTAwMmQ", "commit": {"author": {"name": "Christofer Nolander", "email": "christofer.nolander@gmail.com", "date": "2022-05-28T09:27:28Z"}, "committer": {"name": "Christofer Nolander", "email": "christofer.nolander@gmail.com", "date": "2022-05-28T09:32:07Z"}, "message": "Cleanup auto-import ordering\n\nAddresses issues raised by @Veykril in #12333", "tree": {"sha": "b1e5583d41498632e201f2102d421beeb4cde373", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b1e5583d41498632e201f2102d421beeb4cde373"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e5b318d99d3d215ab0ae84b1a80e8034975002d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e5b318d99d3d215ab0ae84b1a80e8034975002d", "html_url": "https://github.com/rust-lang/rust/commit/8e5b318d99d3d215ab0ae84b1a80e8034975002d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e5b318d99d3d215ab0ae84b1a80e8034975002d/comments", "author": {"login": "nolanderc", "id": 16593746, "node_id": "MDQ6VXNlcjE2NTkzNzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16593746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nolanderc", "html_url": "https://github.com/nolanderc", "followers_url": "https://api.github.com/users/nolanderc/followers", "following_url": "https://api.github.com/users/nolanderc/following{/other_user}", "gists_url": "https://api.github.com/users/nolanderc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nolanderc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nolanderc/subscriptions", "organizations_url": "https://api.github.com/users/nolanderc/orgs", "repos_url": "https://api.github.com/users/nolanderc/repos", "events_url": "https://api.github.com/users/nolanderc/events{/privacy}", "received_events_url": "https://api.github.com/users/nolanderc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nolanderc", "id": 16593746, "node_id": "MDQ6VXNlcjE2NTkzNzQ2", "avatar_url": "https://avatars.githubusercontent.com/u/16593746?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nolanderc", "html_url": "https://github.com/nolanderc", "followers_url": "https://api.github.com/users/nolanderc/followers", "following_url": "https://api.github.com/users/nolanderc/following{/other_user}", "gists_url": "https://api.github.com/users/nolanderc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nolanderc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nolanderc/subscriptions", "organizations_url": "https://api.github.com/users/nolanderc/orgs", "repos_url": "https://api.github.com/users/nolanderc/repos", "events_url": "https://api.github.com/users/nolanderc/events{/privacy}", "received_events_url": "https://api.github.com/users/nolanderc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "068b138c87ba1e0c28624b1ff3aa7edaeed8473d", "url": "https://api.github.com/repos/rust-lang/rust/commits/068b138c87ba1e0c28624b1ff3aa7edaeed8473d", "html_url": "https://github.com/rust-lang/rust/commit/068b138c87ba1e0c28624b1ff3aa7edaeed8473d"}], "stats": {"total": 102, "additions": 51, "deletions": 51}, "files": [{"sha": "1ec24d8fcc336c267a0afdb1723b2c65823c8b6a", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 51, "deletions": 51, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8e5b318d99d3d215ab0ae84b1a80e8034975002d/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e5b318d99d3d215ab0ae84b1a80e8034975002d/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=8e5b318d99d3d215ab0ae84b1a80e8034975002d", "patch": "@@ -111,8 +111,17 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext) -> Option<()>\n     // we aren't interested in different namespaces\n     proposed_imports.dedup_by(|a, b| a.import_path == b.import_path);\n \n+    let current_node = match ctx.covering_element() {\n+        NodeOrToken::Node(node) => Some(node),\n+        NodeOrToken::Token(token) => token.parent(),\n+    };\n+\n+    let current_module =\n+        current_node.as_ref().and_then(|node| ctx.sema.scope(node)).map(|scope| scope.module());\n+\n     // prioritize more relevant imports\n-    proposed_imports.sort_by_key(|import| Reverse(relevance_score(ctx, import)));\n+    proposed_imports\n+        .sort_by_key(|import| Reverse(relevance_score(ctx, import, current_module.as_ref())));\n \n     for import in proposed_imports {\n         acc.add_group(\n@@ -167,7 +176,11 @@ fn group_label(import_candidate: &ImportCandidate) -> GroupLabel {\n \n /// Determine how relevant a given import is in the current context. Higher scores are more\n /// relevant.\n-fn relevance_score(ctx: &AssistContext, import: &LocatedImport) -> i32 {\n+fn relevance_score(\n+    ctx: &AssistContext,\n+    import: &LocatedImport,\n+    current_module: Option<&Module>,\n+) -> i32 {\n     let mut score = 0;\n \n     let db = ctx.db();\n@@ -177,25 +190,11 @@ fn relevance_score(ctx: &AssistContext, import: &LocatedImport) -> i32 {\n         hir::ItemInNs::Macros(makro) => Some(makro.module(db)),\n     };\n \n-    let current_node = match ctx.covering_element() {\n-        NodeOrToken::Node(node) => Some(node),\n-        NodeOrToken::Token(token) => token.parent(),\n-    };\n-\n-    if let Some(module) = item_module.as_ref() {\n-        if module.krate().is_builtin(db) {\n-            // prefer items builtin to the language\n-            score += 5;\n-        }\n-    }\n-\n-    let current_scope = current_node.as_ref().and_then(|node| ctx.sema.scope(node));\n-\n-    match item_module.zip(current_scope) {\n-        // get the distance between the modules (prefer items that are more local)\n-        Some((item_module, current_scope)) => {\n-            let current_module = current_scope.module();\n-            score -= module_distance_hueristic(&current_module, &item_module, db) as i32;\n+    match item_module.zip(current_module) {\n+        // get the distance between the imported path and the current module\n+        // (prefer items that are more local)\n+        Some((item_module, current_module)) => {\n+            score -= module_distance_hueristic(db, &current_module, &item_module) as i32;\n         }\n \n         // could not find relevant modules, so just use the length of the path as an estimate\n@@ -206,30 +205,31 @@ fn relevance_score(ctx: &AssistContext, import: &LocatedImport) -> i32 {\n }\n \n /// A heuristic that gives a higher score to modules that are more separated.\n-fn module_distance_hueristic(current: &Module, item: &Module, db: &dyn HirDatabase) -> usize {\n+fn module_distance_hueristic(db: &dyn HirDatabase, current: &Module, item: &Module) -> usize {\n+    // get the path starting from the item to the respective crate roots\n     let mut current_path = current.path_to_root(db);\n     let mut item_path = item.path_to_root(db);\n \n+    // we want paths going from the root to the item\n     current_path.reverse();\n     item_path.reverse();\n \n-    let mut i = 0;\n-    while i < current_path.len() && i < item_path.len() {\n-        if current_path[i] == item_path[i] {\n-            i += 1\n-        } else {\n-            break;\n-        }\n-    }\n+    // length of the common prefix of the two paths\n+    let prefix_length = current_path.iter().zip(&item_path).take_while(|(a, b)| a == b).count();\n \n-    let distinct_distance = current_path.len() + item_path.len();\n-    let common_prefix = 2 * i;\n+    // how many modules differ between the two paths (all modules, removing any duplicates)\n+    let distinct_length = current_path.len() + item_path.len() - 2 * prefix_length;\n \n-    // prefer builtin crates and items within the same crate\n-    let crate_boundary_cost =\n-        if item.krate().is_builtin(db) || current.krate() == item.krate() { 0 } else { 4 };\n+    // cost of importing from another crate\n+    let crate_boundary_cost = if current.krate() == item.krate() {\n+        0\n+    } else if item.krate().is_builtin(db) {\n+        2\n+    } else {\n+        4\n+    };\n \n-    distinct_distance - common_prefix + crate_boundary_cost\n+    distinct_length + crate_boundary_cost\n }\n \n #[cfg(test)]\n@@ -266,14 +266,14 @@ mod tests {\n     #[test]\n     fn prefer_shorter_paths() {\n         let before = r\"\n-            //- /main.rs crate:main deps:foo,bar\n-            HashMap$0::new();\n+//- /main.rs crate:main deps:foo,bar\n+HashMap$0::new();\n \n-            //- /lib.rs crate:foo\n-            pub mod collections { pub struct HashMap; }\n+//- /lib.rs crate:foo\n+pub mod collections { pub struct HashMap; }\n \n-            //- /lib.rs crate:bar\n-            pub mod collections { pub mod hash_map { pub struct HashMap; } }\n+//- /lib.rs crate:bar\n+pub mod collections { pub mod hash_map { pub struct HashMap; } }\n         \";\n \n         check_auto_import_order(\n@@ -285,17 +285,17 @@ mod tests {\n     #[test]\n     fn prefer_same_crate() {\n         let before = r\"\n-            //- /main.rs crate:main deps:foo\n-            HashMap$0::new();\n+//- /main.rs crate:main deps:foo\n+HashMap$0::new();\n \n-            mod collections {\n-                pub mod hash_map {\n-                    pub struct HashMap;\n-                }\n-            }\n+mod collections {\n+    pub mod hash_map {\n+        pub struct HashMap;\n+    }\n+}\n \n-            //- /lib.rs crate:foo\n-            pub struct HashMap;\n+//- /lib.rs crate:foo\n+pub struct HashMap;\n         \";\n \n         check_auto_import_order("}]}