{"sha": "1c819792a7a5252989024592ea8a17c4da42056c", "node_id": "C_kwDOAAsO6NoAKDFjODE5NzkyYTdhNTI1Mjk4OTAyNDU5MmVhOGExN2M0ZGE0MjA1NmM", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-11-02T20:16:08Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2022-11-18T01:01:05Z"}, "message": "Introduce PlaceBuilder::resolve_upvar by ref", "tree": {"sha": "d82ec0f11e2ea12589363d42846d3546ed99cb68", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d82ec0f11e2ea12589363d42846d3546ed99cb68"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c819792a7a5252989024592ea8a17c4da42056c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c819792a7a5252989024592ea8a17c4da42056c", "html_url": "https://github.com/rust-lang/rust/commit/1c819792a7a5252989024592ea8a17c4da42056c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c819792a7a5252989024592ea8a17c4da42056c/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83356b78c4ff3e7d84e977aa6143793545967301", "url": "https://api.github.com/repos/rust-lang/rust/commits/83356b78c4ff3e7d84e977aa6143793545967301", "html_url": "https://github.com/rust-lang/rust/commit/83356b78c4ff3e7d84e977aa6143793545967301"}], "stats": {"total": 135, "additions": 72, "deletions": 63}, "files": [{"sha": "fd6ade42b4f30d2522bf71d9c5e0b9b070c6a359", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 72, "deletions": 63, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/1c819792a7a5252989024592ea8a17c4da42056c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c819792a7a5252989024592ea8a17c4da42056c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=1c819792a7a5252989024592ea8a17c4da42056c", "patch": "@@ -167,59 +167,54 @@ fn find_capture_matching_projections<'a, 'tcx>(\n     })\n }\n \n-/// Takes a PlaceBuilder and resolves the upvar (if any) within it, so that the\n-/// `PlaceBuilder` now starts from `PlaceBase::Local`.\n-///\n-/// Returns a Result with the error being the PlaceBuilder (`from_builder`) that was not found.\n+/// Takes an upvar place and tries to resolve it into a `PlaceBuilder`\n+/// with `PlaceBase::Local`\n #[instrument(level = \"trace\", skip(cx), ret)]\n fn to_upvars_resolved_place_builder<'tcx>(\n-    from_builder: PlaceBuilder<'tcx>,\n     cx: &Builder<'_, 'tcx>,\n-) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-    match from_builder.base {\n-        PlaceBase::Local(_) => Ok(from_builder),\n-        PlaceBase::Upvar { var_hir_id, closure_def_id } => {\n-            let Some((capture_index, capture)) =\n-                find_capture_matching_projections(\n-                    &cx.upvars,\n-                    var_hir_id,\n-                    &from_builder.projection,\n-                ) else {\n-                let closure_span = cx.tcx.def_span(closure_def_id);\n-                if !enable_precise_capture(cx.tcx, closure_span) {\n-                    bug!(\n-                        \"No associated capture found for {:?}[{:#?}] even though \\\n-                            capture_disjoint_fields isn't enabled\",\n-                        var_hir_id,\n-                        from_builder.projection\n-                    )\n-                } else {\n-                    debug!(\n-                        \"No associated capture found for {:?}[{:#?}]\",\n-                        var_hir_id, from_builder.projection,\n-                    );\n-                }\n-                return Err(from_builder);\n-            };\n+    var_hir_id: LocalVarId,\n+    closure_def_id: LocalDefId,\n+    projection: &[PlaceElem<'tcx>],\n+) -> Option<PlaceBuilder<'tcx>> {\n+    let Some((capture_index, capture)) =\n+        find_capture_matching_projections(\n+            &cx.upvars,\n+            var_hir_id,\n+            &projection,\n+        ) else {\n+        let closure_span = cx.tcx.def_span(closure_def_id);\n+        if !enable_precise_capture(cx.tcx, closure_span) {\n+            bug!(\n+                \"No associated capture found for {:?}[{:#?}] even though \\\n+                    capture_disjoint_fields isn't enabled\",\n+                var_hir_id,\n+                projection\n+            )\n+        } else {\n+            debug!(\n+                \"No associated capture found for {:?}[{:#?}]\",\n+                var_hir_id, projection,\n+            );\n+        }\n+        return None;\n+    };\n \n-            // Access the capture by accessing the field within the Closure struct.\n-            let capture_info = &cx.upvars[capture_index];\n+    // Access the capture by accessing the field within the Closure struct.\n+    let capture_info = &cx.upvars[capture_index];\n \n-            let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n+    let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n \n-            // We used some of the projections to build the capture itself,\n-            // now we apply the remaining to the upvar resolved place.\n-            trace!(?capture.captured_place, ?from_builder.projection);\n-            let remaining_projections = strip_prefix(\n-                capture.captured_place.place.base_ty,\n-                from_builder.projection,\n-                &capture.captured_place.place.projections,\n-            );\n-            upvar_resolved_place_builder.projection.extend(remaining_projections);\n+    // We used some of the projections to build the capture itself,\n+    // now we apply the remaining to the upvar resolved place.\n+    trace!(?capture.captured_place, ?projection);\n+    let remaining_projections = strip_prefix(\n+        capture.captured_place.place.base_ty,\n+        projection,\n+        &capture.captured_place.place.projections,\n+    );\n+    upvar_resolved_place_builder.projection.extend(remaining_projections);\n \n-            Ok(upvar_resolved_place_builder)\n-        }\n-    }\n+    Some(upvar_resolved_place_builder)\n }\n \n /// Returns projections remaining after stripping an initial prefix of HIR\n@@ -228,13 +223,14 @@ fn to_upvars_resolved_place_builder<'tcx>(\n /// Supports only HIR projection kinds that represent a path that might be\n /// captured by a closure or a generator, i.e., an `Index` or a `Subslice`\n /// projection kinds are unsupported.\n-fn strip_prefix<'tcx>(\n+fn strip_prefix<'a, 'tcx>(\n     mut base_ty: Ty<'tcx>,\n-    projections: Vec<PlaceElem<'tcx>>,\n+    projections: &'a [PlaceElem<'tcx>],\n     prefix_projections: &[HirProjection<'tcx>],\n-) -> impl Iterator<Item = PlaceElem<'tcx>> {\n+) -> impl Iterator<Item = PlaceElem<'tcx>> + 'a {\n     let mut iter = projections\n-        .into_iter()\n+        .iter()\n+        .copied()\n         // Filter out opaque casts, they are unnecessary in the prefix.\n         .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n     for projection in prefix_projections {\n@@ -258,21 +254,31 @@ fn strip_prefix<'tcx>(\n }\n \n impl<'tcx> PlaceBuilder<'tcx> {\n-    pub(in crate::build) fn into_place(self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n-        if let PlaceBase::Local(local) = self.base {\n-            Place { local, projection: cx.tcx.intern_place_elems(&self.projection) }\n-        } else {\n-            self.expect_upvars_resolved(cx).into_place(cx)\n-        }\n+    pub(in crate::build) fn into_place(mut self, cx: &Builder<'_, 'tcx>) -> Place<'tcx> {\n+        self = self.resolve_upvar(cx).unwrap_or(self);\n+        let PlaceBase::Local(local) = self.base else { panic!(\"expected local\") };\n+        Place { local, projection: cx.tcx.intern_place_elems(&self.projection) }\n     }\n \n     fn expect_upvars_resolved(self, cx: &Builder<'_, 'tcx>) -> PlaceBuilder<'tcx> {\n-        to_upvars_resolved_place_builder(self, cx).unwrap()\n+        match self.base {\n+            PlaceBase::Local(_) => self,\n+            PlaceBase::Upvar {..} => self.resolve_upvar(cx).unwrap(),\n+        }\n+    }\n+\n+    pub(in crate::build) fn try_upvars_resolved(\n+        self,\n+        cx: &Builder<'_, 'tcx>,\n+    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n+        match self.base {\n+            PlaceBase::Local(_) => Ok(self),\n+            PlaceBase::Upvar { .. } => self.resolve_upvar(cx).ok_or(self),\n+        }\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n-    /// On success, it will return the resolved `PlaceBuilder`.\n-    /// On failure, it will return itself.\n+    /// Returns `None` if this is not an upvar.\n     ///\n     /// Upvars resolve may fail for a `PlaceBuilder` when attempting to\n     /// resolve a disjoint field whose root variable is not captured\n@@ -281,11 +287,14 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     /// not captured. This can happen because the final mir that will be\n     /// generated doesn't require a read for this place. Failures will only\n     /// happen inside closures.\n-    pub(in crate::build) fn try_upvars_resolved(\n-        self,\n+    pub(in crate::build) fn resolve_upvar(\n+        &self,\n         cx: &Builder<'_, 'tcx>,\n-    ) -> Result<PlaceBuilder<'tcx>, PlaceBuilder<'tcx>> {\n-        to_upvars_resolved_place_builder(self, cx)\n+    ) -> Option<PlaceBuilder<'tcx>> {\n+        let PlaceBase::Upvar { var_hir_id, closure_def_id } = self.base else {\n+            return None;\n+        };\n+        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &self.projection)\n     }\n \n     pub(crate) fn base(&self) -> PlaceBase {"}]}