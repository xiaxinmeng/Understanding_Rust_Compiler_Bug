{"sha": "e53db0b5c90fc43c9a708aaf9cb170305880d35b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1M2RiMGI1YzkwZmM0M2M5YTcwOGFhZjljYjE3MDMwNTg4MGQzNWI=", "commit": {"author": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-16T15:09:24Z"}, "committer": {"name": "Jonas Hietala", "email": "tradet.h@gmail.com", "date": "2014-09-17T10:34:19Z"}, "message": "doc: Methods for result::Result.", "tree": {"sha": "1b9e0ce70d8c66ed2ca2da17532d3b6c816533a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b9e0ce70d8c66ed2ca2da17532d3b6c816533a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e53db0b5c90fc43c9a708aaf9cb170305880d35b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e53db0b5c90fc43c9a708aaf9cb170305880d35b", "html_url": "https://github.com/rust-lang/rust/commit/e53db0b5c90fc43c9a708aaf9cb170305880d35b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e53db0b5c90fc43c9a708aaf9cb170305880d35b/comments", "author": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "committer": {"login": "treeman", "id": 162027, "node_id": "MDQ6VXNlcjE2MjAyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/162027?v=4", "gravatar_id": "", "url": "https://api.github.com/users/treeman", "html_url": "https://github.com/treeman", "followers_url": "https://api.github.com/users/treeman/followers", "following_url": "https://api.github.com/users/treeman/following{/other_user}", "gists_url": "https://api.github.com/users/treeman/gists{/gist_id}", "starred_url": "https://api.github.com/users/treeman/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/treeman/subscriptions", "organizations_url": "https://api.github.com/users/treeman/orgs", "repos_url": "https://api.github.com/users/treeman/repos", "events_url": "https://api.github.com/users/treeman/events{/privacy}", "received_events_url": "https://api.github.com/users/treeman/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b49ad238db64f66d66a1a6e9c26198abe56cc53", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b49ad238db64f66d66a1a6e9c26198abe56cc53", "html_url": "https://github.com/rust-lang/rust/commit/9b49ad238db64f66d66a1a6e9c26198abe56cc53"}], "stats": {"total": 256, "additions": 228, "deletions": 28}, "files": [{"sha": "9f347aacedc026c74a9603b8e2c91e0cf110ad6c", "filename": "src/libcore/result.rs", "status": "modified", "additions": 228, "deletions": 28, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/e53db0b5c90fc43c9a708aaf9cb170305880d35b/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e53db0b5c90fc43c9a708aaf9cb170305880d35b/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=e53db0b5c90fc43c9a708aaf9cb170305880d35b", "patch": "@@ -311,14 +311,13 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Write};\n-    ///\n-    /// # fn do_not_run_example() { // creates a file\n-    /// let mut file = File::open_mode(&Path::new(\"secret.txt\"), Open, Write);\n-    /// assert!(file.write_line(\"it's cold in here\").is_ok());\n-    /// # }\n-    /// ~~~\n+    /// ```\n+    /// let x: Result<int, &str> = Ok(-3);\n+    /// assert_eq!(x.is_ok(), true);\n+    ///\n+    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.is_ok(), false);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_ok(&self) -> bool {\n@@ -332,14 +331,13 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~\n-    /// use std::io::{File, Open, Read};\n+    /// ```\n+    /// let x: Result<int, &str> = Ok(-3);\n+    /// assert_eq!(x.is_err(), false);\n     ///\n-    /// // When opening with `Read` access, if the file does not exist\n-    /// // then `open_mode` returns an error.\n-    /// let bogus = File::open_mode(&Path::new(\"not_a_file.txt\"), Open, Read);\n-    /// assert!(bogus.is_err());\n-    /// ~~~\n+    /// let x: Result<int, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.is_err(), true);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn is_err(&self) -> bool {\n@@ -356,18 +354,15 @@ impl<T, E> Result<T, E> {\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the error, if any.\n     ///\n-    /// To convert to an `Option` without discarding the error value,\n-    /// use `as_ref` to first convert the `Result<T, E>` into a\n-    /// `Result<&T, &E>`.\n-    ///\n-    /// # Examples\n+    /// # Example\n     ///\n-    /// ~~~{.should_fail}\n-    /// use std::io::{File, IoResult};\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.ok(), Some(2));\n     ///\n-    /// let bdays: IoResult<File> = File::open(&Path::new(\"important_birthdays.txt\"));\n-    /// let bdays: File = bdays.ok().expect(\"unable to open birthday file\");\n-    /// ~~~\n+    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// assert_eq!(x.ok(), None);\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn ok(self) -> Option<T> {\n@@ -381,6 +376,16 @@ impl<T, E> Result<T, E> {\n     ///\n     /// Converts `self` into an `Option<T>`, consuming `self`,\n     /// and discarding the value, if any.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.err(), None);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"Nothing here\");\n+    /// assert_eq!(x.err(), Some(\"Nothing here\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn err(self) -> Option<E> {\n@@ -398,6 +403,14 @@ impl<T, E> Result<T, E> {\n     ///\n     /// Produces a new `Result`, containing a reference\n     /// into the original, leaving the original in place.\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.as_ref(), Ok(&2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"Error\");\n+    /// assert_eq!(x.as_ref(), Err(&\"Error\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn as_ref<'r>(&'r self) -> Result<&'r T, &'r E> {\n@@ -408,6 +421,23 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Convert from `Result<T, E>` to `Result<&mut T, &mut E>`\n+    ///\n+    /// ```\n+    /// fn mutate(r: &mut Result<int, int>) {\n+    ///     match r.as_mut() {\n+    ///         Ok(&ref mut v) => *v = 42,\n+    ///         Err(&ref mut e) => *e = 0,\n+    ///     }\n+    /// }\n+    ///\n+    /// let mut x: Result<int, int> = Ok(2);\n+    /// mutate(&mut x);\n+    /// assert_eq!(x.unwrap(), 42);\n+    ///\n+    /// let mut x: Result<int, int> = Err(13);\n+    /// mutate(&mut x);\n+    /// assert_eq!(x.unwrap_err(), 0);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut<'r>(&'r mut self) -> Result<&'r mut T, &'r mut E> {\n@@ -418,6 +448,20 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Convert from `Result<T, E>` to `&mut [T]` (without copying)\n+    ///\n+    /// ```\n+    /// let mut x: Result<&str, uint> = Ok(\"Gold\");\n+    /// {\n+    ///     let v = x.as_mut_slice();\n+    ///     assert!(v == [\"Gold\"]);\n+    ///     v[0] = \"Silver\";\n+    ///     assert!(v == [\"Silver\"]);\n+    /// }\n+    /// assert_eq!(x, Ok(\"Silver\"));\n+    ///\n+    /// let mut x: Result<&str, uint> = Err(45);\n+    /// assert!(x.as_mut_slice() == []);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for mut conventions\"]\n     pub fn as_mut_slice<'r>(&'r mut self) -> &'r mut [T] {\n@@ -479,6 +523,18 @@ impl<T, E> Result<T, E> {\n     ///\n     /// This function can be used to pass through a successful result while handling\n     /// an error.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn stringify(x: uint) -> String { format!(\"error code: {}\", x) }\n+    ///\n+    /// let x: Result<uint, uint> = Ok(2u);\n+    /// assert_eq!(x.map_err(stringify), Ok(2u));\n+    ///\n+    /// let x: Result<uint, uint> = Err(13);\n+    /// assert_eq!(x.map_err(stringify), Err(\"error code: 13\".to_string()));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn map_err<F>(self, op: |E| -> F) -> Result<T,F> {\n@@ -494,6 +550,16 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns an iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(7);\n+    /// assert_eq!(x.iter().next(), Some(&7));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// assert_eq!(x.iter().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter<'r>(&'r self) -> Item<&'r T> {\n@@ -507,6 +573,20 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns a mutable iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let mut x: Result<uint, &str> = Ok(7);\n+    /// match x.iter_mut().next() {\n+    ///     Some(&ref mut x) => *x = 40,\n+    ///     None => {},\n+    /// }\n+    /// assert_eq!(x, Ok(40));\n+    ///\n+    /// let mut x: Result<uint, &str> = Err(\"nothing!\");\n+    /// assert_eq!(x.iter_mut().next(), None);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn iter_mut<'r>(&'r mut self) -> Item<&'r mut T> {\n@@ -520,6 +600,18 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns a consuming iterator over the possibly contained value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(5);\n+    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![5u]);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"nothing!\");\n+    /// let v: Vec<uint> = x.into_iter().collect();\n+    /// assert_eq!(v, vec![]);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for iterator conventions\"]\n     pub fn into_iter(self) -> Item<T> {\n@@ -531,6 +623,26 @@ impl<T, E> Result<T, E> {\n     /////////////////////////////////////////////////////////////////////////\n \n     /// Returns `res` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let y: Result<&str, &str> = Ok(\"foo\");\n+    /// assert_eq!(x.and(y), Err(\"early error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let y: Result<&str, &str> = Err(\"late error\");\n+    /// assert_eq!(x.and(y), Err(\"not a 2\"));\n+    ///\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<&str, &str> = Ok(\"different result type\");\n+    /// assert_eq!(x.and(y), Ok(\"different result type\"));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn and<U>(self, res: Result<U, E>) -> Result<U, E> {\n@@ -542,7 +654,19 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Ok`, otherwise returns the `Err` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values\n+    /// This function can be used for control flow based on result values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n+    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n+    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n+    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n+    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn and_then<U>(self, op: |T| -> Result<U, E>) -> Result<U, E> {\n@@ -553,6 +677,26 @@ impl<T, E> Result<T, E> {\n     }\n \n     /// Returns `res` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"early error\");\n+    /// let y: Result<uint, &str> = Ok(2);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"not a 2\");\n+    /// let y: Result<uint, &str> = Err(\"late error\");\n+    /// assert_eq!(x.or(y), Err(\"late error\"));\n+    ///\n+    /// let x: Result<uint, &str> = Ok(2);\n+    /// let y: Result<uint, &str> = Ok(100);\n+    /// assert_eq!(x.or(y), Ok(2));\n+    /// ```\n     #[inline]\n     #[stable]\n     pub fn or(self, res: Result<T, E>) -> Result<T, E> {\n@@ -564,7 +708,19 @@ impl<T, E> Result<T, E> {\n \n     /// Calls `op` if the result is `Err`, otherwise returns the `Ok` value of `self`.\n     ///\n-    /// This function can be used for control flow based on result values\n+    /// This function can be used for control flow based on result values.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn sq(x: uint) -> Result<uint, uint> { Ok(x * x) }\n+    /// fn err(x: uint) -> Result<uint, uint> { Err(x) }\n+    ///\n+    /// assert_eq!(Ok(2).or_else(sq).or_else(sq), Ok(2));\n+    /// assert_eq!(Ok(2).or_else(err).or_else(sq), Ok(2));\n+    /// assert_eq!(Err(3).or_else(sq).or_else(err), Ok(9));\n+    /// assert_eq!(Err(3).or_else(err).or_else(err), Err(3));\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for unboxed closures\"]\n     pub fn or_else<F>(self, op: |E| -> Result<T, F>) -> Result<T, F> {\n@@ -576,6 +732,17 @@ impl<T, E> Result<T, E> {\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// Else it returns `optb`.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let optb = 2u;\n+    /// let x: Result<uint, &str> = Ok(9u);\n+    /// assert_eq!(x.unwrap_or(optb), 9u);\n+    ///\n+    /// let x: Result<uint, &str> = Err(\"error\");\n+    /// assert_eq!(x.unwrap_or(optb), optb);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or(self, optb: T) -> T {\n@@ -587,6 +754,15 @@ impl<T, E> Result<T, E> {\n \n     /// Unwraps a result, yielding the content of an `Ok`.\n     /// If the value is an `Err` then it calls `op` with its value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// fn count(x: &str) -> uint { x.len() }\n+    ///\n+    /// assert_eq!(Ok(2u).unwrap_or_else(count), 2u);\n+    /// assert_eq!(Err(\"foo\").unwrap_or_else(count), 3u);\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_or_else(self, op: |E| -> T) -> T {\n@@ -611,6 +787,18 @@ impl<T, E: Show> Result<T, E> {\n     ///\n     /// Fails if the value is an `Err`, with a custom failure message provided\n     /// by the `Err`'s value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Ok(2u);\n+    /// assert_eq!(x.unwrap(), 2u);\n+    /// ```\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// x.unwrap(); // fails with `emergency failure`\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap(self) -> T {\n@@ -629,6 +817,18 @@ impl<T: Show, E> Result<T, E> {\n     ///\n     /// Fails if the value is an `Ok`, with a custom failure message provided\n     /// by the `Ok`'s value.\n+    ///\n+    /// # Example\n+    ///\n+    /// ```{.should_fail}\n+    /// let x: Result<uint, &str> = Ok(2u);\n+    /// x.unwrap_err(); // fails with `2`\n+    /// ```\n+    ///\n+    /// ```\n+    /// let x: Result<uint, &str> = Err(\"emergency failure\");\n+    /// assert_eq!(x.unwrap_err(), \"emergency failure\");\n+    /// ```\n     #[inline]\n     #[unstable = \"waiting for conventions\"]\n     pub fn unwrap_err(self) -> E {\n@@ -666,7 +866,7 @@ impl<T, E> Slice<T> for Result<T, E> {\n \n /// A `Result` iterator that yields either one or zero elements\n ///\n-/// The `Item` iterator is returned by the `iter`, `mut_iter` and `move_iter`\n+/// The `Item` iterator is returned by the `iter`, `iter_mut` and `into_iter`\n /// methods on `Result`.\n #[deriving(Clone)]\n #[unstable = \"waiting for iterator conventions\"]"}]}