{"sha": "7584260b9a222658e3e38f1d2506da95e6106283", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ODQyNjBiOWEyMjI2NThlM2UzOGYxZDI1MDZkYTk1ZTYxMDYyODM=", "commit": {"author": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-02-20T22:14:27Z"}, "committer": {"name": "Kirill Bulatov", "email": "mail4score@gmail.com", "date": "2021-03-08T21:58:33Z"}, "message": "Find the code to change", "tree": {"sha": "198af48dab750d233a8ad50ad4b3b8eb03e312d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/198af48dab750d233a8ad50ad4b3b8eb03e312d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7584260b9a222658e3e38f1d2506da95e6106283", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7584260b9a222658e3e38f1d2506da95e6106283", "html_url": "https://github.com/rust-lang/rust/commit/7584260b9a222658e3e38f1d2506da95e6106283", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7584260b9a222658e3e38f1d2506da95e6106283/comments", "author": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SomeoneToIgnore", "id": 2690773, "node_id": "MDQ6VXNlcjI2OTA3NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/2690773?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SomeoneToIgnore", "html_url": "https://github.com/SomeoneToIgnore", "followers_url": "https://api.github.com/users/SomeoneToIgnore/followers", "following_url": "https://api.github.com/users/SomeoneToIgnore/following{/other_user}", "gists_url": "https://api.github.com/users/SomeoneToIgnore/gists{/gist_id}", "starred_url": "https://api.github.com/users/SomeoneToIgnore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SomeoneToIgnore/subscriptions", "organizations_url": "https://api.github.com/users/SomeoneToIgnore/orgs", "repos_url": "https://api.github.com/users/SomeoneToIgnore/repos", "events_url": "https://api.github.com/users/SomeoneToIgnore/events{/privacy}", "received_events_url": "https://api.github.com/users/SomeoneToIgnore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "005bc49d744f6a7c2ef38a4abd3327b0804709d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/005bc49d744f6a7c2ef38a4abd3327b0804709d1", "html_url": "https://github.com/rust-lang/rust/commit/005bc49d744f6a7c2ef38a4abd3327b0804709d1"}], "stats": {"total": 185, "additions": 130, "deletions": 55}, "files": [{"sha": "0da4bdd0ed10c7d7f85dd4c9c71d94c42eaecfec", "filename": "crates/ide_db/src/helpers/import_assets.rs", "status": "modified", "additions": 130, "deletions": 55, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/7584260b9a222658e3e38f1d2506da95e6106283/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7584260b9a222658e3e38f1d2506da95e6106283/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fhelpers%2Fimport_assets.rs?ref=7584260b9a222658e3e38f1d2506da95e6106283", "patch": "@@ -1,6 +1,9 @@\n //! Look up accessible paths for items.\n use either::Either;\n-use hir::{AsAssocItem, AssocItem, Crate, MacroDef, Module, ModuleDef, PrefixKind, Semantics};\n+use hir::{\n+    AsAssocItem, AssocItem, Crate, ItemInNs, MacroDef, ModPath, Module, ModuleDef, PathResolution,\n+    PrefixKind, Semantics,\n+};\n use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n@@ -145,7 +148,6 @@ impl ImportAssets {\n         prefixed: Option<hir::PrefixKind>,\n     ) -> Vec<(hir::ModPath, hir::ItemInNs)> {\n         let current_crate = self.module_with_candidate.krate();\n-        let import_candidate = &self.import_candidate;\n \n         let imports_for_candidate_name = match self.name_to_import() {\n             NameToImport::Exact(exact_name) => {\n@@ -157,7 +159,7 @@ impl ImportAssets {\n             // and https://rust-lang.zulipchat.com/#narrow/stream/185405-t-compiler.2Fwg-rls-2.2E0/topic/Blanket.20trait.20impls.20lookup\n             // for the details\n             NameToImport::Fuzzy(fuzzy_name) => {\n-                let (assoc_item_search, limit) = if import_candidate.is_trait_candidate() {\n+                let (assoc_item_search, limit) = if self.import_candidate.is_trait_candidate() {\n                     (AssocItemSearch::AssocItemsOnly, None)\n                 } else {\n                     (AssocItemSearch::Exclude, Some(DEFAULT_QUERY_SEARCH_LIMIT))\n@@ -172,59 +174,108 @@ impl ImportAssets {\n             }\n         };\n \n-        let db = sema.db;\n-        let mut res =\n-            applicable_defs(import_candidate, current_crate, db, imports_for_candidate_name)\n-                .filter_map(|candidate| {\n-                    let item: hir::ItemInNs = candidate.clone().either(Into::into, Into::into);\n-\n-                    let item_to_search = if import_candidate.is_trait_candidate() {\n-                        let canidate_trait = match candidate {\n-                            Either::Left(module_def) => {\n-                                module_def.as_assoc_item(db)?.containing_trait(db)\n-                            }\n-                            _ => None,\n-                        }?;\n-                        ModuleDef::from(canidate_trait).into()\n-                    } else {\n-                        item\n-                    };\n-                    let mod_path = if let Some(prefix_kind) = prefixed {\n-                        self.module_with_candidate.find_use_path_prefixed(\n-                            db,\n-                            item_to_search,\n-                            prefix_kind,\n-                        )\n-                    } else {\n-                        self.module_with_candidate.find_use_path(db, item_to_search)\n-                    };\n-\n-                    mod_path.zip(Some(item))\n-                })\n-                .filter(|(use_path, _)| use_path.len() > 1)\n-                .collect::<Vec<_>>();\n+        let mut res = self\n+            .applicable_defs(sema, prefixed, imports_for_candidate_name)\n+            .filter(|(use_path, _)| use_path.len() > 1)\n+            .collect::<Vec<_>>();\n         res.sort_by_cached_key(|(path, _)| path.clone());\n         res\n     }\n+\n+    fn applicable_defs<'a>(\n+        &self,\n+        sema: &'a Semantics<RootDatabase>,\n+        prefixed: Option<hir::PrefixKind>,\n+        unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+    ) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n+        let current_crate = self.module_with_candidate.krate();\n+        let db = sema.db;\n+\n+        match &self.import_candidate {\n+            ImportCandidate::Path(path_candidate) => path_applicable_defs(\n+                sema,\n+                path_candidate,\n+                unfiltered_imports,\n+                self.module_with_candidate,\n+                prefixed,\n+            ),\n+            ImportCandidate::TraitAssocItem(trait_candidate) => trait_applicable_defs(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                true,\n+                unfiltered_imports,\n+                self.module_with_candidate,\n+                prefixed,\n+            ),\n+            ImportCandidate::TraitMethod(trait_candidate) => trait_applicable_defs(\n+                db,\n+                current_crate,\n+                trait_candidate,\n+                false,\n+                unfiltered_imports,\n+                self.module_with_candidate,\n+                prefixed,\n+            ),\n+        }\n+    }\n }\n \n-fn applicable_defs<'a>(\n-    import_candidate: &ImportCandidate,\n-    current_crate: Crate,\n-    db: &RootDatabase,\n-    unfiltered_imports: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n-) -> Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a> {\n-    // TODO kb this needs to consider various path prefixes, etc.\n-    let receiver_ty = match import_candidate {\n-        ImportCandidate::Path(_) => return unfiltered_imports,\n-        ImportCandidate::TraitAssocItem(candidate) | ImportCandidate::TraitMethod(candidate) => {\n-            &candidate.receiver_ty\n+fn path_applicable_defs<'a>(\n+    sema: &'a Semantics<RootDatabase>,\n+    path_candidate: &PathImportCandidate,\n+    unfiltered_defs: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+    module_with_candidate: Module,\n+    prefixed: Option<hir::PrefixKind>,\n+) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n+    let applicable_defs = unfiltered_defs\n+        .map(|candidate| candidate.either(ItemInNs::from, ItemInNs::from))\n+        .filter_map(move |item_to_search| {\n+            get_mod_path(sema.db, item_to_search, &module_with_candidate, prefixed)\n+                .zip(Some(item_to_search))\n+        });\n+\n+    let unresolved_qualifier = match &path_candidate.unresolved_qualifier {\n+        Some(qualifier) => qualifier,\n+        None => {\n+            // TODO kb too many boxes tossed around\n+            return Box::new(applicable_defs);\n         }\n     };\n \n+    // TODO kb filter out items: found path should end with `qualifier::Name` or `qualifier::Something` for fuzzy search case.\n+\n+    // TODO kb find a way to turn a qualifier into the corresponding ModuleDef. Maybe through the unfiltered data?\n+    if let Some(qualifier_start_resolution) = resolve_qualifier_start(sema, unresolved_qualifier) {\n+        // TODO kb ascend until an unresolved segment part appears\n+    } else {\n+        // first segment is already unresolved, need to turn it into ModuleDef somehow\n+    }\n+\n+    return Box::new(applicable_defs);\n+}\n+\n+fn resolve_qualifier_start(\n+    sema: &Semantics<RootDatabase>,\n+    qualifier: &ast::Path,\n+) -> Option<PathResolution> {\n+    let qualifier_start = qualifier.syntax().descendants().find_map(ast::NameRef::cast)?;\n+    let qualifier_start_path = qualifier_start.syntax().ancestors().find_map(ast::Path::cast)?;\n+    sema.resolve_path(&qualifier_start_path)\n+}\n+\n+fn trait_applicable_defs<'a>(\n+    db: &'a RootDatabase,\n+    current_crate: Crate,\n+    trait_candidate: &TraitImportCandidate,\n+    trait_assoc_item: bool,\n+    unfiltered_defs: Box<dyn Iterator<Item = Either<ModuleDef, MacroDef>> + 'a>,\n+    module_with_candidate: Module,\n+    prefixed: Option<hir::PrefixKind>,\n+) -> Box<dyn Iterator<Item = (ModPath, ItemInNs)> + 'a> {\n     let mut required_assoc_items = FxHashSet::default();\n \n-    let trait_candidates = unfiltered_imports\n+    let trait_candidates = unfiltered_defs\n         .filter_map(|input| match input {\n             Either::Left(module_def) => module_def.as_assoc_item(db),\n             _ => None,\n@@ -238,9 +289,8 @@ fn applicable_defs<'a>(\n \n     let mut applicable_defs = FxHashSet::default();\n \n-    match import_candidate {\n-        ImportCandidate::Path(_) => unreachable!(),\n-        ImportCandidate::TraitAssocItem(_) => receiver_ty.iterate_path_candidates(\n+    if trait_assoc_item {\n+        trait_candidate.receiver_ty.iterate_path_candidates(\n             db,\n             current_crate,\n             &trait_candidates,\n@@ -252,27 +302,52 @@ fn applicable_defs<'a>(\n                             return None;\n                         }\n                     }\n-                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                    applicable_defs.insert(assoc_to_module_def(assoc));\n                 }\n                 None::<()>\n             },\n-        ),\n-        ImportCandidate::TraitMethod(_) => receiver_ty.iterate_method_candidates(\n+        )\n+    } else {\n+        trait_candidate.receiver_ty.iterate_method_candidates(\n             db,\n             current_crate,\n             &trait_candidates,\n             None,\n             |_, function| {\n                 let assoc = function.as_assoc_item(db)?;\n                 if required_assoc_items.contains(&assoc) {\n-                    applicable_defs.insert(Either::Left(assoc_to_module_def(assoc)));\n+                    applicable_defs.insert(assoc_to_module_def(assoc));\n                 }\n                 None::<()>\n             },\n-        ),\n+        )\n     };\n \n-    Box::new(applicable_defs.into_iter())\n+    Box::new(\n+        applicable_defs\n+            .into_iter()\n+            .filter_map(move |candidate| {\n+                let canidate_trait = candidate.as_assoc_item(db)?.containing_trait(db)?;\n+                Some(ItemInNs::from(ModuleDef::from(canidate_trait)))\n+            })\n+            .filter_map(move |item_to_search| {\n+                get_mod_path(db, item_to_search, &module_with_candidate, prefixed)\n+                    .zip(Some(item_to_search))\n+            }),\n+    )\n+}\n+\n+fn get_mod_path(\n+    db: &RootDatabase,\n+    item_to_search: ItemInNs,\n+    module_with_candidate: &Module,\n+    prefixed: Option<hir::PrefixKind>,\n+) -> Option<ModPath> {\n+    if let Some(prefix_kind) = prefixed {\n+        module_with_candidate.find_use_path_prefixed(db, item_to_search, prefix_kind)\n+    } else {\n+        module_with_candidate.find_use_path(db, item_to_search)\n+    }\n }\n \n fn assoc_to_module_def(assoc: AssocItem) -> ModuleDef {"}]}