{"sha": "abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiZWQ0NWZmOWZhM2U2OGYyYTMyY2ExMmUwMTJmOTViOTE1M2Y0ZGY=", "commit": {"author": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-02-17T21:36:01Z"}, "committer": {"name": "Amanieu d'Antras", "email": "amanieu@gmail.com", "date": "2020-05-18T13:41:32Z"}, "message": "Implement asm! codegen", "tree": {"sha": "1e40b0230c7ede2ccb29e1ffd42142d6c076a054", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e40b0230c7ede2ccb29e1ffd42142d6c076a054"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "html_url": "https://github.com/rust-lang/rust/commit/abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/comments", "author": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Amanieu", "id": 278509, "node_id": "MDQ6VXNlcjI3ODUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/278509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Amanieu", "html_url": "https://github.com/Amanieu", "followers_url": "https://api.github.com/users/Amanieu/followers", "following_url": "https://api.github.com/users/Amanieu/following{/other_user}", "gists_url": "https://api.github.com/users/Amanieu/gists{/gist_id}", "starred_url": "https://api.github.com/users/Amanieu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Amanieu/subscriptions", "organizations_url": "https://api.github.com/users/Amanieu/orgs", "repos_url": "https://api.github.com/users/Amanieu/repos", "events_url": "https://api.github.com/users/Amanieu/events{/privacy}", "received_events_url": "https://api.github.com/users/Amanieu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "342a64caef773f142c347441877d0be064d5cdc7", "url": "https://api.github.com/repos/rust-lang/rust/commits/342a64caef773f142c347441877d0be064d5cdc7", "html_url": "https://github.com/rust-lang/rust/commit/342a64caef773f142c347441877d0be064d5cdc7"}], "stats": {"total": 625, "additions": 608, "deletions": 17}, "files": [{"sha": "21322511c99b25ad05b310ada36839f2042c5dc6", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 463, "deletions": 15, "changes": 478, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -1,14 +1,21 @@\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n use crate::llvm;\n+use crate::type_::Type;\n use crate::type_of::LayoutLlvmExt;\n use crate::value::Value;\n \n+use rustc_ast::ast::LlvmAsmDialect;\n use rustc_codegen_ssa::mir::operand::OperandValue;\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::*;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_hir as hir;\n+use rustc_middle::span_bug;\n+use rustc_middle::ty::layout::TyAndLayout;\n use rustc_span::Span;\n+use rustc_target::abi::*;\n+use rustc_target::asm::*;\n \n use libc::{c_char, c_uint};\n use log::debug;\n@@ -40,7 +47,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     indirect_outputs.push(operand.immediate());\n                 }\n             } else {\n-                output_types.push(place.layout.llvm_type(self.cx()));\n+                output_types.push(place.layout.llvm_type(self.cx));\n             }\n         }\n         if !indirect_outputs.is_empty() {\n@@ -89,6 +96,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             ia.volatile,\n             ia.alignstack,\n             ia.dialect,\n+            span,\n         );\n         if r.is_none() {\n             return false;\n@@ -102,22 +110,210 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             OperandValue::Immediate(v).store(self, place);\n         }\n \n-        // Store mark in a metadata node so we can map LLVM errors\n-        // back to source locations.  See #17552.\n-        unsafe {\n-            let key = \"srcloc\";\n-            let kind = llvm::LLVMGetMDKindIDInContext(\n-                self.llcx,\n-                key.as_ptr() as *const c_char,\n-                key.len() as c_uint,\n-            );\n+        true\n+    }\n+\n+    fn codegen_inline_asm(\n+        &mut self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[InlineAsmOperandRef<'tcx, Self>],\n+        options: InlineAsmOptions,\n+        span: Span,\n+    ) {\n+        let asm_arch = self.tcx.sess.asm_arch.unwrap();\n \n-            let val: &'ll Value = self.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n+        // Collect the types of output operands\n+        let mut constraints = vec![];\n+        let mut output_types = vec![];\n+        let mut op_idx = FxHashMap::default();\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::Out { reg, late, place } => {\n+                    let ty = if let Some(place) = place {\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &place.layout)\n+                    } else {\n+                        // If the output is discarded, we don't really care what\n+                        // type is used. We're just using this to tell LLVM to\n+                        // reserve the register.\n+                        dummy_output_type(self.cx, reg.reg_class())\n+                    };\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg)));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late, in_value, out_place } => {\n+                    let ty = if let Some(ref out_place) = out_place {\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &out_place.layout)\n+                    } else {\n+                        // LLVM required tied operands to have the same type,\n+                        // so we just use the type of the input.\n+                        llvm_fixup_output_type(self.cx, reg.reg_class(), &in_value.layout)\n+                    };\n+                    output_types.push(ty);\n+                    op_idx.insert(idx, constraints.len());\n+                    let prefix = if late { \"=\" } else { \"=&\" };\n+                    constraints.push(format!(\"{}{}\", prefix, reg_to_llvm(reg)));\n+                }\n+                _ => {}\n+            }\n+        }\n \n-            llvm::LLVMSetMetadata(r, kind, llvm::LLVMMDNodeInContext(self.llcx, &val, 1));\n+        // Collect input operands\n+        let mut inputs = vec![];\n+        for (idx, op) in operands.iter().enumerate() {\n+            match *op {\n+                InlineAsmOperandRef::In { reg, value } => {\n+                    let value =\n+                        llvm_fixup_input(self, value.immediate(), reg.reg_class(), &value.layout);\n+                    inputs.push(value);\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(reg_to_llvm(reg));\n+                }\n+                InlineAsmOperandRef::InOut { reg, late: _, in_value, out_place: _ } => {\n+                    let value = llvm_fixup_input(\n+                        self,\n+                        in_value.immediate(),\n+                        reg.reg_class(),\n+                        &in_value.layout,\n+                    );\n+                    inputs.push(value);\n+                    constraints.push(format!(\"{}\", op_idx[&idx]));\n+                }\n+                InlineAsmOperandRef::SymFn { instance } => {\n+                    inputs.push(self.cx.get_fn(instance));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                InlineAsmOperandRef::SymStatic { def_id } => {\n+                    inputs.push(self.cx.get_static(def_id));\n+                    op_idx.insert(idx, constraints.len());\n+                    constraints.push(\"s\".to_string());\n+                }\n+                _ => {}\n+            }\n         }\n \n-        true\n+        // Build the template string\n+        let mut template_str = String::new();\n+        for piece in template {\n+            match *piece {\n+                InlineAsmTemplatePiece::String(ref s) => {\n+                    if s.contains('$') {\n+                        for c in s.chars() {\n+                            if c == '$' {\n+                                template_str.push_str(\"$$\");\n+                            } else {\n+                                template_str.push(c);\n+                            }\n+                        }\n+                    } else {\n+                        template_str.push_str(s)\n+                    }\n+                }\n+                InlineAsmTemplatePiece::Placeholder { operand_idx, modifier, span: _ } => {\n+                    match operands[operand_idx] {\n+                        InlineAsmOperandRef::In { reg, .. }\n+                        | InlineAsmOperandRef::Out { reg, .. }\n+                        | InlineAsmOperandRef::InOut { reg, .. } => {\n+                            let modifier = modifier_to_llvm(asm_arch, reg.reg_class(), modifier);\n+                            if let Some(modifier) = modifier {\n+                                template_str.push_str(&format!(\n+                                    \"${{{}:{}}}\",\n+                                    op_idx[&operand_idx], modifier\n+                                ));\n+                            } else {\n+                                template_str.push_str(&format!(\"${{{}}}\", op_idx[&operand_idx]));\n+                            }\n+                        }\n+                        InlineAsmOperandRef::Const { ref string } => {\n+                            // Const operands get injected directly into the template\n+                            template_str.push_str(string);\n+                        }\n+                        InlineAsmOperandRef::SymFn { .. }\n+                        | InlineAsmOperandRef::SymStatic { .. } => {\n+                            // Only emit the raw symbol name\n+                            template_str.push_str(&format!(\"${{{}:c}}\", op_idx[&operand_idx]));\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if !options.contains(InlineAsmOptions::PRESERVES_FLAGS) {\n+            match asm_arch {\n+                InlineAsmArch::AArch64 | InlineAsmArch::Arm => {\n+                    constraints.push(\"~{cc}\".to_string());\n+                }\n+                InlineAsmArch::X86 | InlineAsmArch::X86_64 => {\n+                    constraints.extend_from_slice(&[\n+                        \"~{dirflag}\".to_string(),\n+                        \"~{fpsr}\".to_string(),\n+                        \"~{flags}\".to_string(),\n+                    ]);\n+                }\n+                InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+            }\n+        }\n+        if !options.contains(InlineAsmOptions::NOMEM) {\n+            // This is actually ignored by LLVM, but it's probably best to keep\n+            // it just in case. LLVM instead uses the ReadOnly/ReadNone\n+            // attributes on the call instruction to optimize.\n+            constraints.push(\"~{memory}\".to_string());\n+        }\n+        let volatile = !options.contains(InlineAsmOptions::PURE);\n+        let alignstack = !options.contains(InlineAsmOptions::NOSTACK);\n+        let output_type = match &output_types[..] {\n+            [] => self.type_void(),\n+            [ty] => ty,\n+            tys => self.type_struct(&tys, false),\n+        };\n+        let dialect = match asm_arch {\n+            InlineAsmArch::X86 | InlineAsmArch::X86_64 => LlvmAsmDialect::Intel,\n+            _ => LlvmAsmDialect::Att,\n+        };\n+        let result = inline_asm_call(\n+            self,\n+            &template_str,\n+            &constraints.join(\",\"),\n+            &inputs,\n+            output_type,\n+            volatile,\n+            alignstack,\n+            dialect,\n+            span,\n+        )\n+        .unwrap_or_else(|| span_bug!(span, \"LLVM asm constraint validation failed\"));\n+\n+        if options.contains(InlineAsmOptions::PURE) {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::ReadNone.apply_callsite(llvm::AttributePlace::Function, result);\n+            } else if options.contains(InlineAsmOptions::READONLY) {\n+                llvm::Attribute::ReadOnly.apply_callsite(llvm::AttributePlace::Function, result);\n+            }\n+        } else {\n+            if options.contains(InlineAsmOptions::NOMEM) {\n+                llvm::Attribute::InaccessibleMemOnly\n+                    .apply_callsite(llvm::AttributePlace::Function, result);\n+            } else {\n+                // LLVM doesn't have an attribute to represent ReadOnly + SideEffect\n+            }\n+        }\n+\n+        // Write results to outputs\n+        for (idx, op) in operands.iter().enumerate() {\n+            if let InlineAsmOperandRef::Out { reg, place: Some(place), .. }\n+            | InlineAsmOperandRef::InOut { reg, out_place: Some(place), .. } = *op\n+            {\n+                let value = if output_types.len() == 1 {\n+                    result\n+                } else {\n+                    self.extract_value(result, op_idx[&idx] as u64)\n+                };\n+                let value = llvm_fixup_output(self, value, reg.reg_class(), &place.layout);\n+                OperandValue::Immediate(value).store(self, place);\n+            }\n+        }\n     }\n }\n \n@@ -138,7 +334,8 @@ fn inline_asm_call(\n     output: &'ll llvm::Type,\n     volatile: bool,\n     alignstack: bool,\n-    dia: ::rustc_ast::ast::LlvmAsmDialect,\n+    dia: LlvmAsmDialect,\n+    span: Span,\n ) -> Option<&'ll Value> {\n     let volatile = if volatile { llvm::True } else { llvm::False };\n     let alignstack = if alignstack { llvm::True } else { llvm::False };\n@@ -168,10 +365,261 @@ fn inline_asm_call(\n                 alignstack,\n                 llvm::AsmDialect::from_generic(dia),\n             );\n-            Some(bx.call(v, inputs, None))\n+            let call = bx.call(v, inputs, None);\n+\n+            // Store mark in a metadata node so we can map LLVM errors\n+            // back to source locations.  See #17552.\n+            let key = \"srcloc\";\n+            let kind = llvm::LLVMGetMDKindIDInContext(\n+                bx.llcx,\n+                key.as_ptr() as *const c_char,\n+                key.len() as c_uint,\n+            );\n+\n+            let val: &'ll Value = bx.const_i32(span.ctxt().outer_expn().as_u32() as i32);\n+            llvm::LLVMSetMetadata(call, kind, llvm::LLVMMDNodeInContext(bx.llcx, &val, 1));\n+\n+            Some(call)\n         } else {\n             // LLVM has detected an issue with our constraints, bail out\n             None\n         }\n     }\n }\n+\n+/// Converts a register class to an LLVM constraint code.\n+fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n+    match reg {\n+        InlineAsmRegOrRegClass::Reg(reg) => format!(\"{{{}}}\", reg.name()),\n+        InlineAsmRegOrRegClass::RegClass(reg) => match reg {\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg) => \"w\",\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => \"l\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8) => \"t\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n+            InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+            | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => \"Q\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+            | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg) => \"x\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => \"v\",\n+            InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => \"^Yk\",\n+        }\n+        .to_string(),\n+    }\n+}\n+\n+/// Converts a modifier into LLVM's equivalent modifier.\n+fn modifier_to_llvm(\n+    arch: InlineAsmArch,\n+    reg: InlineAsmRegClass,\n+    modifier: Option<char>,\n+) -> Option<char> {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => modifier,\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            if modifier == Some('v') { None } else { modifier }\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => None,\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => Some('P'),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            if modifier.is_none() {\n+                Some('q')\n+            } else {\n+                modifier\n+            }\n+        }\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => match modifier {\n+            None if arch == InlineAsmArch::X86_64 => Some('q'),\n+            None => Some('k'),\n+            Some('l') => Some('b'),\n+            Some('h') => Some('h'),\n+            Some('x') => Some('w'),\n+            Some('e') => Some('k'),\n+            Some('r') => Some('q'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(reg @ X86InlineAsmRegClass::zmm_reg) => match (reg, modifier) {\n+            (X86InlineAsmRegClass::xmm_reg, None) => Some('x'),\n+            (X86InlineAsmRegClass::ymm_reg, None) => Some('t'),\n+            (X86InlineAsmRegClass::zmm_reg, None) => Some('g'),\n+            (_, Some('x')) => Some('x'),\n+            (_, Some('y')) => Some('t'),\n+            (_, Some('z')) => Some('g'),\n+            _ => unreachable!(),\n+        },\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => None,\n+    }\n+}\n+\n+/// Type to use for outputs that are discarded. It doesn't really matter what\n+/// the type is, as long as it is valid for the constraint code.\n+fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll Type {\n+    match reg {\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg)\n+        | InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::reg_thumb) => cx.type_i32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::sreg_low16) => cx.type_f32(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low16)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg_low8) => cx.type_f64(),\n+        InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low8)\n+        | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n+            cx.type_vector(cx.type_i64(), 2)\n+        }\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n+        InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::reg_abcd) => cx.type_i32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::xmm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::ymm_reg)\n+        | InlineAsmRegClass::X86(X86InlineAsmRegClass::zmm_reg) => cx.type_f32(),\n+        InlineAsmRegClass::X86(X86InlineAsmRegClass::kreg) => cx.type_i16(),\n+    }\n+}\n+\n+/// Helper function to get the LLVM type for a Scalar. Pointers are returned as\n+/// the equivalent integer type.\n+fn llvm_asm_scalar_type(cx: &CodegenCx<'ll, 'tcx>, scalar: &Scalar) -> &'ll Type {\n+    match scalar.value {\n+        Primitive::Int(Integer::I8, _) => cx.type_i8(),\n+        Primitive::Int(Integer::I16, _) => cx.type_i16(),\n+        Primitive::Int(Integer::I32, _) => cx.type_i32(),\n+        Primitive::Int(Integer::I64, _) => cx.type_i64(),\n+        Primitive::F32 => cx.type_f32(),\n+        Primitive::F64 => cx.type_f64(),\n+        Primitive::Pointer => cx.type_isize(),\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Fix up an input value to work around LLVM bugs.\n+fn llvm_fixup_input(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                let vec_ty = bx.cx.type_vector(bx.cx.type_i8(), 8);\n+                bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, s);\n+            let count = 16 / layout.size.bytes();\n+            let vec_ty = bx.cx.type_vector(elem_ty, count);\n+            if let Primitive::Pointer = s.value {\n+                value = bx.ptrtoint(value, bx.cx.type_isize());\n+            }\n+            bx.insert_element(bx.const_undef(vec_ty), value, bx.const_i32(0))\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count);\n+            let indices: Vec<_> = (0..count * 2).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Fix up an output value to work around LLVM bugs.\n+fn llvm_fixup_output(\n+    bx: &mut Builder<'a, 'll, 'tcx>,\n+    mut value: &'ll Value,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Value {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                bx.extract_element(value, bx.const_i32(0))\n+            } else {\n+                value\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            value = bx.extract_element(value, bx.const_i32(0));\n+            if let Primitive::Pointer = s.value {\n+                value = bx.inttoptr(value, layout.llvm_type(bx.cx));\n+            }\n+            value\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(bx.cx, element);\n+            let vec_ty = bx.cx.type_vector(elem_ty, *count * 2);\n+            let indices: Vec<_> = (0..*count).map(|x| bx.const_i32(x as i32)).collect();\n+            bx.shuffle_vector(value, bx.const_undef(vec_ty), bx.const_vector(&indices))\n+        }\n+        _ => value,\n+    }\n+}\n+\n+/// Output type to use for llvm_fixup_output.\n+fn llvm_fixup_output_type(\n+    cx: &CodegenCx<'ll, 'tcx>,\n+    reg: InlineAsmRegClass,\n+    layout: &TyAndLayout<'tcx>,\n+) -> &'ll Type {\n+    match (reg, &layout.abi) {\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg), Abi::Scalar(s)) => {\n+            if let Primitive::Int(Integer::I8, _) = s.value {\n+                cx.type_vector(cx.type_i8(), 8)\n+            } else {\n+                layout.llvm_type(cx)\n+            }\n+        }\n+        (InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16), Abi::Scalar(s)) => {\n+            let elem_ty = llvm_asm_scalar_type(cx, s);\n+            let count = 16 / layout.size.bytes();\n+            cx.type_vector(elem_ty, count)\n+        }\n+        (\n+            InlineAsmRegClass::AArch64(AArch64InlineAsmRegClass::vreg_low16),\n+            Abi::Vector { element, count },\n+        ) if layout.size.bytes() == 8 => {\n+            let elem_ty = llvm_asm_scalar_type(cx, element);\n+            cx.type_vector(elem_ty, count * 2)\n+        }\n+        _ => layout.llvm_type(cx),\n+    }\n+}"}, {"sha": "9cb0f0e0c2e677d1340951cd487c693e27b9d0c7", "filename": "src/librustc_codegen_llvm/llvm/ffi.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fllvm%2Fffi.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -124,6 +124,8 @@ pub enum Attribute {\n     NonLazyBind = 23,\n     OptimizeNone = 24,\n     ReturnsTwice = 25,\n+    ReadNone = 26,\n+    InaccessibleMemOnly = 27,\n }\n \n /// LLVMIntPredicate"}, {"sha": "5e3a37e20bd4f1beb6f0d7513ffcebf39caea1ce", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -358,7 +358,8 @@ pub fn cleanup_kinds(mir: &mir::Body<'_>) -> IndexVec<mir::BasicBlock, CleanupKi\n                 | TerminatorKind::SwitchInt { .. }\n                 | TerminatorKind::Yield { .. }\n                 | TerminatorKind::FalseEdges { .. }\n-                | TerminatorKind::FalseUnwind { .. } => { /* nothing to do */ }\n+                | TerminatorKind::FalseUnwind { .. }\n+                | TerminatorKind::InlineAsm { .. } => { /* nothing to do */ }\n                 TerminatorKind::Call { cleanup: unwind, .. }\n                 | TerminatorKind::Assert { cleanup: unwind, .. }\n                 | TerminatorKind::DropAndReplace { unwind, .. }"}, {"sha": "f8c5caa440cc11b394bb4f72b381077ce28e3148", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -9,6 +9,7 @@ use crate::meth;\n use crate::traits::*;\n use crate::MemFlags;\n \n+use rustc_ast::ast;\n use rustc_hir::lang_items;\n use rustc_index::vec::Idx;\n use rustc_middle::mir;\n@@ -914,6 +915,98 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             mir::TerminatorKind::FalseEdges { .. } | mir::TerminatorKind::FalseUnwind { .. } => {\n                 bug!(\"borrowck false edges in codegen\")\n             }\n+\n+            mir::TerminatorKind::InlineAsm { template, ref operands, options, ref destination } => {\n+                let span = terminator.source_info.span;\n+\n+                let operands: Vec<_> = operands\n+                    .iter()\n+                    .map(|op| match *op {\n+                        mir::InlineAsmOperand::In { reg, ref value } => {\n+                            let value = self.codegen_operand(&mut bx, value);\n+                            InlineAsmOperandRef::In { reg, value }\n+                        }\n+                        mir::InlineAsmOperand::Out { reg, late, ref place } => {\n+                            let place =\n+                                place.map(|place| self.codegen_place(&mut bx, place.as_ref()));\n+                            InlineAsmOperandRef::Out { reg, late, place }\n+                        }\n+                        mir::InlineAsmOperand::InOut { reg, late, ref in_value, ref out_place } => {\n+                            let in_value = self.codegen_operand(&mut bx, in_value);\n+                            let out_place = out_place\n+                                .map(|out_place| self.codegen_place(&mut bx, out_place.as_ref()));\n+                            InlineAsmOperandRef::InOut { reg, late, in_value, out_place }\n+                        }\n+                        mir::InlineAsmOperand::Const { ref value } => {\n+                            if let mir::Operand::Constant(constant) = value {\n+                                let const_value =\n+                                    self.eval_mir_constant(constant).unwrap_or_else(|_| {\n+                                        span_bug!(span, \"asm const cannot be resolved\")\n+                                    });\n+                                let ty = constant.literal.ty;\n+                                let value = const_value\n+                                    .try_to_bits_for_ty(bx.tcx(), ty::ParamEnv::reveal_all(), ty)\n+                                    .unwrap_or_else(|| {\n+                                        span_bug!(span, \"asm const has non-scalar value\")\n+                                    });\n+                                let string = match ty.kind {\n+                                    ty::Uint(_) => value.to_string(),\n+                                    ty::Int(int_ty) => {\n+                                        match int_ty.normalize(bx.tcx().sess.target.ptr_width) {\n+                                            ast::IntTy::I8 => (value as i8).to_string(),\n+                                            ast::IntTy::I16 => (value as i16).to_string(),\n+                                            ast::IntTy::I32 => (value as i32).to_string(),\n+                                            ast::IntTy::I64 => (value as i64).to_string(),\n+                                            ast::IntTy::I128 => (value as i128).to_string(),\n+                                            ast::IntTy::Isize => unreachable!(),\n+                                        }\n+                                    }\n+                                    ty::Float(ast::FloatTy::F32) => {\n+                                        f32::from_bits(value as u32).to_string()\n+                                    }\n+                                    ty::Float(ast::FloatTy::F64) => {\n+                                        f64::from_bits(value as u64).to_string()\n+                                    }\n+                                    _ => span_bug!(span, \"asm const has bad type {}\", ty),\n+                                };\n+                                InlineAsmOperandRef::Const { string }\n+                            } else {\n+                                span_bug!(span, \"asm const is not a constant\");\n+                            }\n+                        }\n+                        mir::InlineAsmOperand::SymFn { ref value } => {\n+                            if let ty::FnDef(def_id, substs) = value.literal.ty.kind {\n+                                let instance = ty::Instance::resolve(\n+                                    bx.tcx(),\n+                                    ty::ParamEnv::reveal_all(),\n+                                    def_id,\n+                                    substs,\n+                                )\n+                                .unwrap()\n+                                .unwrap();\n+                                InlineAsmOperandRef::SymFn { instance }\n+                            } else {\n+                                span_bug!(span, \"invalid type for asm sym (fn)\");\n+                            }\n+                        }\n+                        mir::InlineAsmOperand::SymStatic { ref value } => {\n+                            if let Some(def_id) = value.check_static_ptr(bx.tcx()) {\n+                                InlineAsmOperandRef::SymStatic { def_id }\n+                            } else {\n+                                span_bug!(span, \"invalid type for asm sym (static)\");\n+                            }\n+                        }\n+                    })\n+                    .collect();\n+\n+                bx.codegen_inline_asm(template, &operands, options, span);\n+\n+                if let Some(target) = destination {\n+                    helper.funclet_br(self, &mut bx, *target);\n+                } else {\n+                    bx.unreachable();\n+                }\n+            }\n         }\n     }\n "}, {"sha": "cb2b3545c4cd1ea926575bbf7f335d29d949dbdb", "filename": "src/librustc_codegen_ssa/traits/asm.rs", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fasm.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -1,7 +1,39 @@\n use super::BackendTypes;\n+use crate::mir::operand::OperandRef;\n use crate::mir::place::PlaceRef;\n+use rustc_hir::def_id::DefId;\n use rustc_hir::{GlobalAsm, LlvmInlineAsmInner};\n+use rustc_middle::ty::Instance;\n use rustc_span::Span;\n+use rustc_target::asm::{InlineAsmOptions, InlineAsmRegOrRegClass, InlineAsmTemplatePiece};\n+\n+#[derive(Debug)]\n+pub enum InlineAsmOperandRef<'tcx, B: BackendTypes + ?Sized> {\n+    In {\n+        reg: InlineAsmRegOrRegClass,\n+        value: OperandRef<'tcx, B::Value>,\n+    },\n+    Out {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        place: Option<PlaceRef<'tcx, B::Value>>,\n+    },\n+    InOut {\n+        reg: InlineAsmRegOrRegClass,\n+        late: bool,\n+        in_value: OperandRef<'tcx, B::Value>,\n+        out_place: Option<PlaceRef<'tcx, B::Value>>,\n+    },\n+    Const {\n+        string: String,\n+    },\n+    SymFn {\n+        instance: Instance<'tcx>,\n+    },\n+    SymStatic {\n+        def_id: DefId,\n+    },\n+}\n \n pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n     /// Take an inline assembly expression and splat it out via LLVM\n@@ -12,6 +44,15 @@ pub trait AsmBuilderMethods<'tcx>: BackendTypes {\n         inputs: Vec<Self::Value>,\n         span: Span,\n     ) -> bool;\n+\n+    /// Take an inline assembly expression and splat it out via LLVM\n+    fn codegen_inline_asm(\n+        &mut self,\n+        template: &[InlineAsmTemplatePiece],\n+        operands: &[InlineAsmOperandRef<'tcx, Self>],\n+        options: InlineAsmOptions,\n+        span: Span,\n+    );\n }\n \n pub trait AsmMethods {"}, {"sha": "6b782731d535c2191c8db5fb528ed6099d269516", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -28,7 +28,7 @@ mod type_;\n mod write;\n \n pub use self::abi::AbiBuilderMethods;\n-pub use self::asm::{AsmBuilderMethods, AsmMethods};\n+pub use self::asm::{AsmBuilderMethods, AsmMethods, InlineAsmOperandRef};\n pub use self::backend::{Backend, BackendTypes, CodegenBackend, ExtraBackendMethods};\n pub use self::builder::{BuilderMethods, OverflowOp};\n pub use self::consts::ConstMethods;"}, {"sha": "b988d06871bf6c8d64f2b7d0af349fb32c5c0fe5", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -203,6 +203,10 @@ static Attribute::AttrKind fromRust(LLVMRustAttribute Kind) {\n     return Attribute::OptimizeNone;\n   case ReturnsTwice:\n     return Attribute::ReturnsTwice;\n+  case ReadNone:\n+    return Attribute::ReadNone;\n+  case InaccessibleMemOnly:\n+    return Attribute::InaccessibleMemOnly;\n   }\n   report_fatal_error(\"bad AttributeKind\");\n }"}, {"sha": "da48048113bc218f6fb7464e9bd190be589aa1fc", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/abed45ff9fa3e68f2a32ca12e012f95b9153f4df/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=abed45ff9fa3e68f2a32ca12e012f95b9153f4df", "patch": "@@ -82,6 +82,8 @@ enum LLVMRustAttribute {\n   NonLazyBind = 23,\n   OptimizeNone = 24,\n   ReturnsTwice = 25,\n+  ReadNone = 26,\n+  InaccessibleMemOnly = 27,\n };\n \n typedef struct OpaqueRustString *RustStringRef;"}]}