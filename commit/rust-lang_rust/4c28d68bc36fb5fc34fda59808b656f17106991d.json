{"sha": "4c28d68bc36fb5fc34fda59808b656f17106991d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRjMjhkNjhiYzM2ZmI1ZmMzNGZkYTU5ODA4YjY1NmYxNzEwNjk5MWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T00:42:14Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-21T21:18:57Z"}, "message": "move move stuff into declare_arena!", "tree": {"sha": "17238842390f2c542a74b795a54bec896a7ceb46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/17238842390f2c542a74b795a54bec896a7ceb46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4c28d68bc36fb5fc34fda59808b656f17106991d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4c28d68bc36fb5fc34fda59808b656f17106991d", "html_url": "https://github.com/rust-lang/rust/commit/4c28d68bc36fb5fc34fda59808b656f17106991d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4c28d68bc36fb5fc34fda59808b656f17106991d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e60205fe523df786b2c4f7c1fbaf7fa2c053621f", "url": "https://api.github.com/repos/rust-lang/rust/commits/e60205fe523df786b2c4f7c1fbaf7fa2c053621f", "html_url": "https://github.com/rust-lang/rust/commit/e60205fe523df786b2c4f7c1fbaf7fa2c053621f"}], "stats": {"total": 203, "additions": 101, "deletions": 102}, "files": [{"sha": "18200af8b66e7d6fb42069491b3b7648b3d6ea1f", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/4c28d68bc36fb5fc34fda59808b656f17106991d/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c28d68bc36fb5fc34fda59808b656f17106991d/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=4c28d68bc36fb5fc34fda59808b656f17106991d", "patch": "@@ -569,5 +569,105 @@ impl DropArena {\n     }\n }\n \n+#[macro_export]\n+macro_rules! arena_for_type {\n+    ([][$ty:ty]) => {\n+        $crate::TypedArena<$ty>\n+    };\n+    ([few $(, $attrs:ident)*][$ty:ty]) => {\n+        ::std::marker::PhantomData<$ty>\n+    };\n+    ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n+        $crate::arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! which_arena_for_type {\n+    ([][$arena:expr]) => {\n+        ::std::option::Option::Some($arena)\n+    };\n+    ([few$(, $attrs:ident)*][$arena:expr]) => {\n+        ::std::option::Option::None\n+    };\n+    ([$ignore:ident$(, $attrs:ident)*]$args:tt) => {\n+        $crate::which_arena_for_type!([$($attrs),*]$args)\n+    };\n+}\n+\n+#[macro_export]\n+macro_rules! declare_arena {\n+    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n+        #[derive(Default)]\n+        pub struct Arena<$tcx> {\n+            pub dropless: $crate::DroplessArena,\n+            drop: $crate::DropArena,\n+            $($name: $crate::arena_for_type!($a[$ty]),)*\n+        }\n+\n+        #[marker]\n+        pub trait ArenaAllocatable {}\n+\n+        impl<T: Copy> ArenaAllocatable for T {}\n+\n+        unsafe trait ArenaField<'tcx>: Sized {\n+            /// Returns a specific arena to allocate from.\n+            /// If `None` is returned, the `DropArena` will be used.\n+            fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>>;\n+        }\n+\n+        unsafe impl<'tcx, T> ArenaField<'tcx> for T {\n+            #[inline]\n+            default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n+                panic!()\n+            }\n+        }\n+\n+        $(\n+            impl ArenaAllocatable for $ty {}\n+            unsafe impl<$tcx> ArenaField<$tcx> for $ty {\n+                #[inline]\n+                fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a $crate::TypedArena<Self>> {\n+                    $crate::which_arena_for_type!($a[&_arena.$name])\n+                }\n+            }\n+        )*\n+\n+        impl<'tcx> Arena<'tcx> {\n+            #[inline]\n+            pub fn alloc<T: ArenaAllocatable>(&self, value: T) -> &mut T {\n+                if !::std::mem::needs_drop::<T>() {\n+                    return self.dropless.alloc(value);\n+                }\n+                match <T as ArenaField<'tcx>>::arena(self) {\n+                    ::std::option::Option::Some(arena) => arena.alloc(value),\n+                    ::std::option::Option::None => unsafe { self.drop.alloc(value) },\n+                }\n+            }\n+\n+            #[inline]\n+            pub fn alloc_slice<T: ::std::marker::Copy>(&self, value: &[T]) -> &mut [T] {\n+                if value.is_empty() {\n+                    return &mut [];\n+                }\n+                self.dropless.alloc_slice(value)\n+            }\n+\n+            pub fn alloc_from_iter<T: ArenaAllocatable>(\n+                &'a self,\n+                iter: impl ::std::iter::IntoIterator<Item = T>,\n+            ) -> &'a mut [T] {\n+                if !::std::mem::needs_drop::<T>() {\n+                    return self.dropless.alloc_from_iter(iter);\n+                }\n+                match <T as ArenaField<'tcx>>::arena(self) {\n+                    ::std::option::Option::Some(arena) => arena.alloc_from_iter(iter),\n+                    ::std::option::Option::None => unsafe { self.drop.alloc_from_iter(iter) },\n+                }\n+            }\n+        }\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}, {"sha": "5644a65c42bb22bb81078a839938d7b02e7011f4", "filename": "src/librustc/arena.rs", "status": "modified", "additions": 1, "deletions": 102, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/4c28d68bc36fb5fc34fda59808b656f17106991d/src%2Flibrustc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4c28d68bc36fb5fc34fda59808b656f17106991d/src%2Flibrustc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Farena.rs?ref=4c28d68bc36fb5fc34fda59808b656f17106991d", "patch": "@@ -1,7 +1,3 @@\n-use arena::{DropArena, DroplessArena, TypedArena};\n-use std::marker::PhantomData;\n-use std::mem;\n-\n /// This declares a list of types which can be allocated by `Arena`.\n ///\n /// The `few` modifier will cause allocation to use the shared arena and recording the destructor.\n@@ -167,101 +163,4 @@ macro_rules! arena_types {\n     )\n }\n \n-macro_rules! arena_for_type {\n-    ([][$ty:ty]) => {\n-        TypedArena<$ty>\n-    };\n-    ([few $(, $attrs:ident)*][$ty:ty]) => {\n-        PhantomData<$ty>\n-    };\n-    ([$ignore:ident $(, $attrs:ident)*]$args:tt) => {\n-        arena_for_type!([$($attrs),*]$args)\n-    };\n-}\n-\n-macro_rules! which_arena_for_type {\n-    ([][$arena:expr]) => {\n-        Some($arena)\n-    };\n-    ([few$(, $attrs:ident)*][$arena:expr]) => {\n-        None\n-    };\n-    ([$ignore:ident$(, $attrs:ident)*]$args:tt) => {\n-        which_arena_for_type!([$($attrs),*]$args)\n-    };\n-}\n-\n-macro_rules! declare_arena {\n-    ([], [$($a:tt $name:ident: $ty:ty,)*], $tcx:lifetime) => {\n-        #[derive(Default)]\n-        pub struct Arena<$tcx> {\n-            pub dropless: DroplessArena,\n-            drop: DropArena,\n-            $($name: arena_for_type!($a[$ty]),)*\n-        }\n-\n-        #[marker]\n-        pub trait ArenaAllocatable {}\n-\n-        impl<T: Copy> ArenaAllocatable for T {}\n-\n-        unsafe trait ArenaField<'tcx>: Sized {\n-            /// Returns a specific arena to allocate from.\n-            /// If `None` is returned, the `DropArena` will be used.\n-            fn arena<'a>(arena: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>>;\n-        }\n-\n-        unsafe impl<'tcx, T> ArenaField<'tcx> for T {\n-            #[inline]\n-            default fn arena<'a>(_: &'a Arena<'tcx>) -> Option<&'a TypedArena<Self>> {\n-                panic!()\n-            }\n-        }\n-\n-        $(\n-            impl ArenaAllocatable for $ty {}\n-            unsafe impl<$tcx> ArenaField<$tcx> for $ty {\n-                #[inline]\n-                fn arena<'a>(_arena: &'a Arena<$tcx>) -> Option<&'a TypedArena<Self>> {\n-                    which_arena_for_type!($a[&_arena.$name])\n-                }\n-            }\n-        )*\n-\n-        impl<'tcx> Arena<'tcx> {\n-            #[inline]\n-            pub fn alloc<T: ArenaAllocatable>(&self, value: T) -> &mut T {\n-                if !mem::needs_drop::<T>() {\n-                    return self.dropless.alloc(value);\n-                }\n-                match <T as ArenaField<'tcx>>::arena(self) {\n-                    Some(arena) => arena.alloc(value),\n-                    None => unsafe { self.drop.alloc(value) },\n-                }\n-            }\n-\n-            #[inline]\n-            pub fn alloc_slice<T: Copy>(&self, value: &[T]) -> &mut [T] {\n-                if value.is_empty() {\n-                    return &mut [];\n-                }\n-                self.dropless.alloc_slice(value)\n-            }\n-\n-            pub fn alloc_from_iter<T: ArenaAllocatable, I: IntoIterator<Item = T>>(\n-                &'a self,\n-                iter: I,\n-            ) -> &'a mut [T] {\n-                if !mem::needs_drop::<T>() {\n-                    return self.dropless.alloc_from_iter(iter);\n-                }\n-                match <T as ArenaField<'tcx>>::arena(self) {\n-                    Some(arena) => arena.alloc_from_iter(iter),\n-                    None => unsafe { self.drop.alloc_from_iter(iter) },\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-arena_types!(declare_arena, [], 'tcx);\n+arena_types!(arena::declare_arena, [], 'tcx);"}]}