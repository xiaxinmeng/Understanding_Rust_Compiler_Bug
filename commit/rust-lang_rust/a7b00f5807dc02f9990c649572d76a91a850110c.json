{"sha": "a7b00f5807dc02f9990c649572d76a91a850110c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE3YjAwZjU4MDdkYzAyZjk5OTBjNjQ5NTcyZDc2YTkxYTg1MDExMGM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-15T14:02:51Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-06-22T23:29:29Z"}, "message": "let_chains: Handle disallowing of let chains in places lowering won't support.", "tree": {"sha": "c95d0772cf17a2038e0a2ed9b8d32b5b94479ff5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c95d0772cf17a2038e0a2ed9b8d32b5b94479ff5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a7b00f5807dc02f9990c649572d76a91a850110c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a7b00f5807dc02f9990c649572d76a91a850110c", "html_url": "https://github.com/rust-lang/rust/commit/a7b00f5807dc02f9990c649572d76a91a850110c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a7b00f5807dc02f9990c649572d76a91a850110c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fcffac5eea664834b5b869032761aa0501e6b63b", "url": "https://api.github.com/repos/rust-lang/rust/commits/fcffac5eea664834b5b869032761aa0501e6b63b", "html_url": "https://github.com/rust-lang/rust/commit/fcffac5eea664834b5b869032761aa0501e6b63b"}], "stats": {"total": 125, "additions": 67, "deletions": 58}, "files": [{"sha": "96f7c9853795e28195499df08f14e9e452220979", "filename": "src/librustc_passes/ast_validation.rs", "status": "modified", "additions": 66, "deletions": 58, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/a7b00f5807dc02f9990c649572d76a91a850110c/src%2Flibrustc_passes%2Fast_validation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b00f5807dc02f9990c649572d76a91a850110c/src%2Flibrustc_passes%2Fast_validation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fast_validation.rs?ref=a7b00f5807dc02f9990c649572d76a91a850110c", "patch": "@@ -17,13 +17,11 @@ use syntax::attr;\n use syntax::feature_gate::is_builtin_attr;\n use syntax::source_map::Spanned;\n use syntax::symbol::{kw, sym};\n-use syntax::ptr::P;\n use syntax::visit::{self, Visitor};\n use syntax::{span_err, struct_span_err, walk_list};\n use syntax_ext::proc_macro_decls::is_proc_macro_attr;\n use syntax_pos::{Span, MultiSpan};\n use errors::{Applicability, FatalError};\n-use log::debug;\n \n #[derive(Copy, Clone, Debug)]\n struct OuterImplTrait {\n@@ -76,20 +74,34 @@ struct AstValidator<'a> {\n     /// these booleans.\n     warning_period_57979_didnt_record_next_impl_trait: bool,\n     warning_period_57979_impl_trait_in_proj: bool,\n+\n+    /// Used to ban `let` expressions in inappropriate places.\n+    is_let_allowed: bool,\n+}\n+\n+/// With the `new` value in `store`,\n+/// runs and returns the `scoped` computation,\n+/// resetting the old value of `store` after,\n+/// and returning the result of `scoped`.\n+fn with<C, T, S>(\n+    this: &mut C,\n+    new: S,\n+    store: impl Fn(&mut C) -> &mut S,\n+    scoped: impl FnOnce(&mut C) -> T\n+) -> T {\n+    let old = mem::replace(store(this), new);\n+    let ret = scoped(this);\n+    *store(this) = old;\n+    ret\n }\n \n impl<'a> AstValidator<'a> {\n     fn with_impl_trait_in_proj_warning<T>(&mut self, v: bool, f: impl FnOnce(&mut Self) -> T) -> T {\n-        let old = mem::replace(&mut self.warning_period_57979_impl_trait_in_proj, v);\n-        let ret = f(self);\n-        self.warning_period_57979_impl_trait_in_proj = old;\n-        ret\n+        with(self, v, |this| &mut this.warning_period_57979_impl_trait_in_proj, f)\n     }\n \n     fn with_banned_impl_trait(&mut self, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.is_impl_trait_banned, true);\n-        f(self);\n-        self.is_impl_trait_banned = old;\n+        with(self, true, |this| &mut this.is_impl_trait_banned, f)\n     }\n \n     fn with_banned_assoc_ty_bound(&mut self, f: impl FnOnce(&mut Self)) {\n@@ -99,9 +111,11 @@ impl<'a> AstValidator<'a> {\n     }\n \n     fn with_impl_trait(&mut self, outer: Option<OuterImplTrait>, f: impl FnOnce(&mut Self)) {\n-        let old = mem::replace(&mut self.outer_impl_trait, outer);\n-        f(self);\n-        self.outer_impl_trait = old;\n+        with(self, outer, |this| &mut this.outer_impl_trait, f)\n+    }\n+\n+    fn with_let_allowed(&mut self, v: bool, f: impl FnOnce(&mut Self)) {\n+        with(self, v, |this| &mut this.is_let_allowed, f)\n     }\n \n     fn visit_assoc_ty_constraint_from_generic_args(&mut self, constraint: &'a AssocTyConstraint) {\n@@ -319,52 +333,36 @@ impl<'a> AstValidator<'a> {\n         }\n     }\n \n-    /// With eRFC 2497, we need to check whether an expression is ambiguous and warn or error\n-    /// depending on the edition, this function handles that.\n-    fn while_if_let_ambiguity(&self, expr: &P<Expr>) {\n-        if let Some((span, op_kind)) = self.while_if_let_expr_ambiguity(&expr) {\n-            let mut err = self.err_handler().struct_span_err(\n-                span, &format!(\"ambiguous use of `{}`\", op_kind.to_string())\n-            );\n-\n-            err.note(\n-                \"this will be a error until the `let_chains` feature is stabilized\"\n-            );\n-            err.note(\n-                \"see rust-lang/rust#53668 for more information\"\n-            );\n-\n-            if let Ok(snippet) = self.session.source_map().span_to_snippet(span) {\n-                err.span_suggestion(\n-                    span, \"consider adding parentheses\", format!(\"({})\", snippet),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n-\n-            err.emit();\n-        }\n-    }\n-\n-    /// With eRFC 2497 adding if-let chains, there is a requirement that the parsing of\n-    /// `&&` and `||` in a if-let statement be unambiguous. This function returns a span and\n-    /// a `BinOpKind` (either `&&` or `||` depending on what was ambiguous) if it is determined\n-    /// that the current expression parsed is ambiguous and will break in future.\n-    fn while_if_let_expr_ambiguity(&self, expr: &P<Expr>) -> Option<(Span, BinOpKind)> {\n-        debug!(\"while_if_let_expr_ambiguity: expr.node: {:?}\", expr.node);\n+    /// Visits the `expr` and adjusts whether `let $pat = $expr` is allowed in decendants.\n+    /// Returns whether we walked into `expr` or not.\n+    /// If we did, walking should not happen again.\n+    fn visit_expr_with_let_maybe_allowed(&mut self, expr: &'a Expr) -> bool {\n         match &expr.node {\n-            ExprKind::Binary(op, _, _) if op.node == BinOpKind::And || op.node == BinOpKind::Or => {\n-                Some((expr.span, op.node))\n-            },\n-            ExprKind::Range(ref lhs, ref rhs, _) => {\n-                let lhs_ambiguous = lhs.as_ref()\n-                    .and_then(|lhs| self.while_if_let_expr_ambiguity(lhs));\n-                let rhs_ambiguous = rhs.as_ref()\n-                    .and_then(|rhs| self.while_if_let_expr_ambiguity(rhs));\n-\n-                lhs_ambiguous.or(rhs_ambiguous)\n+            // Assuming the context permits, `($expr)` does not impose additional constraints.\n+            ExprKind::Paren(_) => visit::walk_expr(self, expr),\n+            // Assuming the context permits,\n+            // l && r` allows decendants in `l` and `r` to be `let` expressions.\n+            ExprKind::Binary(op, ..) if op.node == BinOpKind::And => visit::walk_expr(self, expr),\n+            // However, we do allow it in the condition of the `if` expression.\n+            // We do not allow `let` in `then` and `opt_else` directly.\n+            ExprKind::If(ref cond, ref then, ref opt_else) => {\n+                self.with_let_allowed(false, |this| {\n+                    this.visit_block(then);\n+                    walk_list!(this, visit_expr, opt_else);\n+                });\n+                self.with_let_allowed(true, |this| this.visit_expr(cond));\n             }\n-            _ => None,\n+            // The same logic applies to `While`.\n+            ExprKind::While(ref cond, ref then, ref opt_label) => {\n+                walk_list!(self, visit_label, opt_label);\n+                self.with_let_allowed(false, |this| this.visit_block(then));\n+                self.with_let_allowed(true, |this| this.visit_expr(cond));\n+            }\n+            // Don't walk into `expr` and defer further checks to the caller.\n+            _ => return false,\n         }\n+\n+        true\n     }\n \n     fn check_fn_decl(&self, fn_decl: &FnDecl) {\n@@ -494,18 +492,27 @@ fn validate_generics_order<'a>(\n impl<'a> Visitor<'a> for AstValidator<'a> {\n     fn visit_expr(&mut self, expr: &'a Expr) {\n         match expr.node {\n+            ExprKind::Let(_, _) if !self.is_let_allowed => {\n+                self.err_handler()\n+                    .struct_span_err(expr.span, \"`let` expressions are not supported here\")\n+                    .note(\"only supported directly in conditions of `if`- and `while`-expressions\")\n+                    .note(\"as well as when nested within `&&` and parenthesis in those conditions\")\n+                    .emit();\n+            }\n+            _ if self.visit_expr_with_let_maybe_allowed(&expr) => {\n+                // Prevent `walk_expr` to happen since we've already done that.\n+                return;\n+            }\n             ExprKind::Closure(_, _, _, ref fn_decl, _, _) => {\n                 self.check_fn_decl(fn_decl);\n             }\n-            ExprKind::IfLet(_, ref expr, _, _) | ExprKind::WhileLet(_, ref expr, _, _) =>\n-                self.while_if_let_ambiguity(&expr),\n             ExprKind::InlineAsm(..) if !self.session.target.target.options.allow_asm => {\n                 span_err!(self.session, expr.span, E0472, \"asm! is unsupported on this target\");\n             }\n             _ => {}\n         }\n \n-        visit::walk_expr(self, expr)\n+        self.with_let_allowed(false, |this| visit::walk_expr(this, expr));\n     }\n \n     fn visit_ty(&mut self, ty: &'a Ty) {\n@@ -917,6 +924,7 @@ pub fn check_crate(session: &Session, krate: &Crate) -> (bool, bool) {\n         is_assoc_ty_bound_banned: false,\n         warning_period_57979_didnt_record_next_impl_trait: false,\n         warning_period_57979_impl_trait_in_proj: false,\n+        is_let_allowed: false,\n     };\n     visit::walk_crate(&mut validator, krate);\n "}, {"sha": "5f3d7159be6ce88fc8bc5c9707842bb19007de53", "filename": "src/librustc_passes/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a7b00f5807dc02f9990c649572d76a91a850110c/src%2Flibrustc_passes%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a7b00f5807dc02f9990c649572d76a91a850110c/src%2Flibrustc_passes%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Flib.rs?ref=a7b00f5807dc02f9990c649572d76a91a850110c", "patch": "@@ -8,6 +8,7 @@\n \n #![feature(in_band_lifetimes)]\n #![feature(nll)]\n+#![feature(bind_by_move_pattern_guards)]\n #![feature(rustc_diagnostic_macros)]\n \n #![recursion_limit=\"256\"]"}]}