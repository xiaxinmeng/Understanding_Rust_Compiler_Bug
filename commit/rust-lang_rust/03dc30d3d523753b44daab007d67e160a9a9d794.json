{"sha": "03dc30d3d523753b44daab007d67e160a9a9d794", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzZGMzMGQzZDUyMzc1M2I0NGRhYWIwMDdkNjdlMTYwYTlhOWQ3OTQ=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-23T19:41:10Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-05-24T16:31:11Z"}, "message": "Make sanitize_place iterate instead of recurse", "tree": {"sha": "8f9fe9aa0b7d0406f68d93478b670b8ebbb1d32e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f9fe9aa0b7d0406f68d93478b670b8ebbb1d32e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03dc30d3d523753b44daab007d67e160a9a9d794", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03dc30d3d523753b44daab007d67e160a9a9d794", "html_url": "https://github.com/rust-lang/rust/commit/03dc30d3d523753b44daab007d67e160a9a9d794", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03dc30d3d523753b44daab007d67e160a9a9d794/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "27cc0db7a248308fc2634ac68d7608a20b4a1c09", "url": "https://api.github.com/repos/rust-lang/rust/commits/27cc0db7a248308fc2634ac68d7608a20b4a1c09", "html_url": "https://github.com/rust-lang/rust/commit/27cc0db7a248308fc2634ac68d7608a20b4a1c09"}], "stats": {"total": 153, "additions": 78, "deletions": 75}, "files": [{"sha": "52c8f15c44bb983500d9a1d42435be4322be92d0", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 78, "deletions": 75, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/03dc30d3d523753b44daab007d67e160a9a9d794/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03dc30d3d523753b44daab007d67e160a9a9d794/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=03dc30d3d523753b44daab007d67e160a9a9d794", "patch": "@@ -29,7 +29,7 @@ use rustc::infer::{InferCtxt, InferOk, LateBoundRegionConversionTime, NLLRegionV\n use rustc::infer::type_variable::TypeVariableOrigin;\n use rustc::mir::interpret::{InterpError::BoundsCheck, ConstValue};\n use rustc::mir::tcx::PlaceTy;\n-use rustc::mir::visit::{PlaceContext, Visitor, MutatingUseContext, NonMutatingUseContext};\n+use rustc::mir::visit::{PlaceContext, Visitor, NonMutatingUseContext};\n use rustc::mir::*;\n use rustc::traits::query::type_op;\n use rustc::traits::query::type_op::custom::CustomTypeOp;\n@@ -447,92 +447,95 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n         context: PlaceContext,\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n-        let place_ty = match place {\n-            Place::Base(PlaceBase::Local(index)) =>\n-                PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n-            Place::Base(PlaceBase::Static(box Static { kind, ty: sty })) => {\n-                let sty = self.sanitize_type(place, sty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n-                     place: &Place<'tcx>,\n-                     ty,\n-                     sty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            sty,\n-                            ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n-                            span_mirbug!(\n-                            verifier,\n-                            place,\n-                            \"bad promoted type ({:?}: {:?}): {:?}\",\n-                            ty,\n-                            sty,\n-                            terr\n-                        );\n+\n+        place.iterate(|place_base, place_projection| {\n+            let mut place_ty = match place_base {\n+                PlaceBase::Local(index) =>\n+                    PlaceTy::from_ty(self.mir.local_decls[*index].ty),\n+                PlaceBase::Static(box Static { kind, ty: sty }) => {\n+                    let sty = self.sanitize_type(place, sty);\n+                    let check_err =\n+                        |verifier: &mut TypeVerifier<'a, 'b, 'gcx, 'tcx>,\n+                         place: &Place<'tcx>,\n+                         ty,\n+                         sty| {\n+                            if let Err(terr) = verifier.cx.eq_types(\n+                                sty,\n+                                ty,\n+                                location.to_locations(),\n+                                ConstraintCategory::Boring,\n+                            ) {\n+                                span_mirbug!(\n+                                verifier,\n+                                place,\n+                                \"bad promoted type ({:?}: {:?}): {:?}\",\n+                                ty,\n+                                sty,\n+                                terr\n+                            );\n+                            };\n                         };\n-                    };\n-                match kind {\n-                    StaticKind::Promoted(promoted) => {\n-                        if !self.errors_reported {\n-                            let promoted_mir = &self.mir.promoted[*promoted];\n-                            self.sanitize_promoted(promoted_mir, location);\n-\n-                            let promoted_ty = promoted_mir.return_ty();\n-                            check_err(self, place, promoted_ty, sty);\n+                    match kind {\n+                        StaticKind::Promoted(promoted) => {\n+                            if !self.errors_reported {\n+                                let promoted_mir = &self.mir.promoted[*promoted];\n+                                self.sanitize_promoted(promoted_mir, location);\n+\n+                                let promoted_ty = promoted_mir.return_ty();\n+                                check_err(self, place, promoted_ty, sty);\n+                            }\n                         }\n-                    }\n-                    StaticKind::Static(def_id) => {\n-                        let ty = self.tcx().type_of(*def_id);\n-                        let ty = self.cx.normalize(ty, location);\n+                        StaticKind::Static(def_id) => {\n+                            let ty = self.tcx().type_of(*def_id);\n+                            let ty = self.cx.normalize(ty, location);\n \n-                        check_err(self, place, ty, sty);\n+                            check_err(self, place, ty, sty);\n+                        }\n                     }\n+                    PlaceTy::from_ty(sty)\n+                }\n+            };\n+\n+            // FIXME use place_projection.is_empty() when is available\n+            if let Place::Base(_) = place {\n+                if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n+                    let tcx = self.tcx();\n+                    let trait_ref = ty::TraitRef {\n+                        def_id: tcx.lang_items().copy_trait().unwrap(),\n+                        substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n+                    };\n+\n+                    // In order to have a Copy operand, the type T of the\n+                    // value must be Copy. Note that we prove that T: Copy,\n+                    // rather than using the `is_copy_modulo_regions`\n+                    // test. This is important because\n+                    // `is_copy_modulo_regions` ignores the resulting region\n+                    // obligations and assumes they pass. This can result in\n+                    // bounds from Copy impls being unsoundly ignored (e.g.,\n+                    // #29149). Note that we decide to use Copy before knowing\n+                    // whether the bounds fully apply: in effect, the rule is\n+                    // that if a value of some type could implement Copy, then\n+                    // it must.\n+                    self.cx.prove_trait_ref(\n+                        trait_ref,\n+                        location.to_locations(),\n+                        ConstraintCategory::CopyBound,\n+                    );\n                 }\n-                PlaceTy::from_ty(sty)\n             }\n-            Place::Projection(ref proj) => {\n-                let base_context = if context.is_mutating_use() {\n-                    PlaceContext::MutatingUse(MutatingUseContext::Projection)\n-                } else {\n-                    PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection)\n-                };\n-                let base_ty = self.sanitize_place(&proj.base, location, base_context);\n-                if base_ty.variant_index.is_none() {\n-                    if base_ty.ty.references_error() {\n+\n+            for proj in place_projection {\n+                if place_ty.variant_index.is_none() {\n+                    if place_ty.ty.references_error() {\n                         assert!(self.errors_reported);\n                         return PlaceTy::from_ty(self.tcx().types.err);\n                     }\n                 }\n-                self.sanitize_projection(base_ty, &proj.elem, place, location)\n+                place_ty = self.sanitize_projection(place_ty, &proj.elem, place, location)\n             }\n-        };\n-        if let PlaceContext::NonMutatingUse(NonMutatingUseContext::Copy) = context {\n-            let tcx = self.tcx();\n-            let trait_ref = ty::TraitRef {\n-                def_id: tcx.lang_items().copy_trait().unwrap(),\n-                substs: tcx.mk_substs_trait(place_ty.ty, &[]),\n-            };\n \n-            // In order to have a Copy operand, the type T of the\n-            // value must be Copy. Note that we prove that T: Copy,\n-            // rather than using the `is_copy_modulo_regions`\n-            // test. This is important because\n-            // `is_copy_modulo_regions` ignores the resulting region\n-            // obligations and assumes they pass. This can result in\n-            // bounds from Copy impls being unsoundly ignored (e.g.,\n-            // #29149). Note that we decide to use Copy before knowing\n-            // whether the bounds fully apply: in effect, the rule is\n-            // that if a value of some type could implement Copy, then\n-            // it must.\n-            self.cx.prove_trait_ref(\n-                trait_ref,\n-                location.to_locations(),\n-                ConstraintCategory::CopyBound,\n-            );\n-        }\n-        place_ty\n+            place_ty\n+        })\n     }\n \n     fn sanitize_promoted(&mut self, promoted_mir: &'b Mir<'tcx>, location: Location) {"}]}