{"sha": "25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZTI3MmUzODg2ZWNkYzkxZjNlNDI0MzZjZWRiZTVhNmZjNmZmMjk=", "commit": {"author": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-10-20T21:08:19Z"}, "committer": {"name": "Nadrieril", "email": "nadrieril+git@gmail.com", "date": "2020-11-05T22:02:35Z"}, "message": "Fix unreachable sub-branch detection\n\nThis fixes https://github.com/rust-lang/rust/issues/76836", "tree": {"sha": "c7d0dcb47ab1214bd89fc64063ac339233d1e417", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d0dcb47ab1214bd89fc64063ac339233d1e417"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "html_url": "https://github.com/rust-lang/rust/commit/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/comments", "author": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nadrieril", "id": 6783654, "node_id": "MDQ6VXNlcjY3ODM2NTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6783654?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nadrieril", "html_url": "https://github.com/Nadrieril", "followers_url": "https://api.github.com/users/Nadrieril/followers", "following_url": "https://api.github.com/users/Nadrieril/following{/other_user}", "gists_url": "https://api.github.com/users/Nadrieril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nadrieril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nadrieril/subscriptions", "organizations_url": "https://api.github.com/users/Nadrieril/orgs", "repos_url": "https://api.github.com/users/Nadrieril/repos", "events_url": "https://api.github.com/users/Nadrieril/events{/privacy}", "received_events_url": "https://api.github.com/users/Nadrieril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "03f0ca0cf4bf427516f9d87a959b7c97c9ff9447", "url": "https://api.github.com/repos/rust-lang/rust/commits/03f0ca0cf4bf427516f9d87a959b7c97c9ff9447", "html_url": "https://github.com/rust-lang/rust/commit/03f0ca0cf4bf427516f9d87a959b7c97c9ff9447"}], "stats": {"total": 146, "additions": 105, "deletions": 41}, "files": [{"sha": "d72a679dd5d3e0b4026a361424b66e7840a500eb", "filename": "compiler/rustc_mir_build/src/thir/pattern/_match.rs", "status": "modified", "additions": 88, "deletions": 32, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2F_match.rs?ref=25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "patch": "@@ -1,5 +1,11 @@\n-//! Note: most of the tests relevant to this file can be found (at the time of writing) in\n-//! src/tests/ui/pattern/usefulness.\n+//! Note: tests specific to this file can be found in:\n+//!     - ui/pattern/usefulness\n+//!     - ui/or-patterns\n+//!     - ui/consts/const_in_pattern\n+//!     - ui/rfc-2008-non-exhaustive\n+//!     - probably many others\n+//! I (Nadrieril) prefer to put new tests in `ui/pattern/usefulness` unless there's a specific\n+//! reason not to, for example if they depend on a particular feature like or_patterns.\n //!\n //! This file includes the logic for exhaustiveness and usefulness checking for\n //! pattern-matching. Specifically, given a list of patterns for a type, we can\n@@ -1361,8 +1367,9 @@ impl<'p, 'tcx> Fields<'p, 'tcx> {\n \n #[derive(Clone, Debug)]\n crate enum Usefulness<'tcx> {\n-    /// Carries a list of unreachable subpatterns. Used only in the presence of or-patterns.\n-    Useful(Vec<Span>),\n+    /// Carries, for each column in the matrix, a set of sub-branches that have been found to be\n+    /// unreachable. Used only in the presence of or-patterns, otherwise it stays empty.\n+    Useful(Vec<FxHashSet<Span>>),\n     /// Carries a list of witnesses of non-exhaustiveness.\n     UsefulWithWitness(Vec<Witness<'tcx>>),\n     NotUseful,\n@@ -1410,6 +1417,23 @@ impl<'tcx> Usefulness<'tcx> {\n                 };\n                 UsefulWithWitness(new_witnesses)\n             }\n+            Useful(mut unreachables) => {\n+                if !unreachables.is_empty() {\n+                    // When we apply a constructor, there are `arity` columns of the matrix that\n+                    // corresponded to its arguments. All the unreachables found in these columns\n+                    // will, after `apply`, come from the first column. So we take the union of all\n+                    // the corresponding sets and put them in the first column.\n+                    // Note that `arity` may be 0, in which case we just push a new empty set.\n+                    let len = unreachables.len();\n+                    let arity = ctor_wild_subpatterns.len();\n+                    let mut unioned = FxHashSet::default();\n+                    for set in unreachables.drain((len - arity)..) {\n+                        unioned.extend(set)\n+                    }\n+                    unreachables.push(unioned);\n+                }\n+                Useful(unreachables)\n+            }\n             x => x,\n         }\n     }\n@@ -2091,55 +2115,87 @@ crate fn is_useful<'p, 'tcx>(\n \n     // If the first pattern is an or-pattern, expand it.\n     if let Some(vs) = v.expand_or_pat() {\n-        // We need to push the already-seen patterns into the matrix in order to detect redundant\n-        // branches like `Some(_) | Some(0)`. We also keep track of the unreachable subpatterns.\n-        let mut matrix = matrix.clone();\n-        // `Vec` of all the unreachable branches of the current or-pattern.\n-        let mut unreachable_branches = Vec::new();\n-        // Subpatterns that are unreachable from all branches. E.g. in the following case, the last\n-        // `true` is unreachable only from one branch, so it is overall reachable.\n+        // We expand the or pattern, trying each of its branches in turn and keeping careful track\n+        // of possible unreachable sub-branches.\n+        //\n+        // If two branches have detected some unreachable sub-branches, we need to be careful. If\n+        // they were detected in columns that are not the current one, we want to keep only the\n+        // sub-branches that were unreachable in _all_ branches. Eg. in the following, the last\n+        // `true` is unreachable in the second branch of the first or-pattern, but not otherwise.\n+        // Therefore we don't want to lint that it is unreachable.\n         //\n         // ```\n         // match (true, true) {\n         //     (true, true) => {}\n         //     (false | true, false | true) => {}\n         // }\n         // ```\n-        let mut unreachable_subpats = FxHashSet::default();\n-        // Whether any branch at all is useful.\n+        // If however the sub-branches come from the current column, they come from the inside of\n+        // the current or-pattern, and we want to keep them all. Eg. in the following, we _do_ want\n+        // to lint that the last `false` is unreachable.\n+        // ```\n+        // match None {\n+        //     Some(false) => {}\n+        //     None | Some(true | false) => {}\n+        // }\n+        // ```\n+\n+        let mut matrix = matrix.clone();\n+        // We keep track of sub-branches separately depending on whether they come from this column\n+        // or from others.\n+        let mut unreachables_this_column: FxHashSet<Span> = FxHashSet::default();\n+        let mut unreachables_other_columns: Vec<FxHashSet<Span>> = Vec::default();\n+        // Whether at least one branch is reachable.\n         let mut any_is_useful = false;\n \n         for v in vs {\n             let res = is_useful(cx, &matrix, &v, witness_preference, hir_id, is_under_guard, false);\n             match res {\n-                Useful(pats) => {\n-                    if !any_is_useful {\n-                        any_is_useful = true;\n-                        // Initialize with the first set of unreachable subpatterns encountered.\n-                        unreachable_subpats = pats.into_iter().collect();\n-                    } else {\n-                        // Keep the patterns unreachable from both this and previous branches.\n-                        unreachable_subpats =\n-                            pats.into_iter().filter(|p| unreachable_subpats.contains(p)).collect();\n+                Useful(unreachables) => {\n+                    if let Some((this_column, other_columns)) = unreachables.split_last() {\n+                        // We keep the union of unreachables found in the first column.\n+                        unreachables_this_column.extend(this_column);\n+                        // We keep the intersection of unreachables found in other columns.\n+                        if unreachables_other_columns.is_empty() {\n+                            unreachables_other_columns = other_columns.to_vec();\n+                        } else {\n+                            unreachables_other_columns = unreachables_other_columns\n+                                .into_iter()\n+                                .zip(other_columns)\n+                                .map(|(x, y)| x.intersection(&y).copied().collect())\n+                                .collect();\n+                        }\n                     }\n+                    any_is_useful = true;\n                 }\n-                NotUseful => unreachable_branches.push(v.head().span),\n-                UsefulWithWitness(_) => {\n-                    bug!(\"Encountered or-pat in `v` during exhaustiveness checking\")\n+                NotUseful => {\n+                    unreachables_this_column.insert(v.head().span);\n                 }\n+                UsefulWithWitness(_) => bug!(\n+                    \"encountered or-pat in the expansion of `_` during exhaustiveness checking\"\n+                ),\n             }\n-            // If pattern has a guard don't add it to the matrix\n+\n+            // If pattern has a guard don't add it to the matrix.\n             if !is_under_guard {\n+                // We push the already-seen patterns into the matrix in order to detect redundant\n+                // branches like `Some(_) | Some(0)`.\n                 matrix.push(v);\n             }\n         }\n-        if any_is_useful {\n-            // Collect all the unreachable patterns.\n-            unreachable_branches.extend(unreachable_subpats);\n-            return Useful(unreachable_branches);\n+\n+        return if any_is_useful {\n+            let mut unreachables = if unreachables_other_columns.is_empty() {\n+                let n_columns = v.len();\n+                (0..n_columns - 1).map(|_| FxHashSet::default()).collect()\n+            } else {\n+                unreachables_other_columns\n+            };\n+            unreachables.push(unreachables_this_column);\n+            Useful(unreachables)\n         } else {\n-            return NotUseful;\n-        }\n+            NotUseful\n+        };\n     }\n \n     // FIXME(Nadrieril): Hack to work around type normalization issues (see #72476)."}, {"sha": "317b8dc205eaef02c270e2559065a41b261052ac", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "patch": "@@ -389,9 +389,11 @@ fn check_arms<'p, 'tcx>(\n                     hir::MatchSource::AwaitDesugar | hir::MatchSource::TryDesugar => {}\n                 }\n             }\n-            Useful(unreachable_subpatterns) => {\n-                for span in unreachable_subpatterns {\n-                    unreachable_pattern(cx.tcx, span, id, None);\n+            Useful(unreachables) => {\n+                for set in unreachables {\n+                    for span in set {\n+                        unreachable_pattern(cx.tcx, span, id, None);\n+                    }\n                 }\n             }\n             UsefulWithWitness(_) => bug!(),"}, {"sha": "512f1e283cb462a0cff4ace899421714bd4c4d4d", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.rs?ref=25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "patch": "@@ -85,7 +85,7 @@ fn main() {\n     match None {\n         Some(false) => {}\n         None | Some(true\n-                | false) => {} // expected unreachable warning here\n+                | false) => {} //~ ERROR unreachable\n     }\n \n     // A subpattern that is unreachable in all branches is overall unreachable."}, {"sha": "3956a42c536b93c331a0965b948a4bd086a8cf51", "filename": "src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.stderr", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/25e272e3886ecdc91f3e42436cedbe5a6fc6ff29/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2For-patterns%2Fexhaustiveness-unreachable-pattern.stderr?ref=25e272e3886ecdc91f3e42436cedbe5a6fc6ff29", "patch": "@@ -77,15 +77,15 @@ LL |         (1 | 1,) => {}\n    |              ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:53:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:55:15\n    |\n-LL |             | 0\n+LL |             | 0] => {}\n    |               ^\n \n error: unreachable pattern\n-  --> $DIR/exhaustiveness-unreachable-pattern.rs:55:15\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:53:15\n    |\n-LL |             | 0] => {}\n+LL |             | 0\n    |               ^\n \n error: unreachable pattern\n@@ -100,6 +100,12 @@ error: unreachable pattern\n LL |         Some(0\n    |              ^\n \n+error: unreachable pattern\n+  --> $DIR/exhaustiveness-unreachable-pattern.rs:88:19\n+   |\n+LL |                 | false) => {}\n+   |                   ^^^^^\n+\n error: unreachable pattern\n   --> $DIR/exhaustiveness-unreachable-pattern.rs:96:15\n    |\n@@ -112,5 +118,5 @@ error: unreachable pattern\n LL |             | true,\n    |               ^^^^\n \n-error: aborting due to 18 previous errors\n+error: aborting due to 19 previous errors\n "}]}