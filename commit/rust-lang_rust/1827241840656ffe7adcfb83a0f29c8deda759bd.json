{"sha": "1827241840656ffe7adcfb83a0f29c8deda759bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjcyNDE4NDA2NTZmZmU3YWRjZmI4M2EwZjI5YzhkZWRhNzU5YmQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T00:55:30Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-06-04T01:49:14Z"}, "message": "rustdoc: Put primitives in respective modules\n\nThe logical location for the documentation of a primitive is in the module that\ndeclared it was a module for that primitive.", "tree": {"sha": "159c6065378107c7406109d37bc4eebc8e32ec51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/159c6065378107c7406109d37bc4eebc8e32ec51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1827241840656ffe7adcfb83a0f29c8deda759bd", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1827241840656ffe7adcfb83a0f29c8deda759bd", "html_url": "https://github.com/rust-lang/rust/commit/1827241840656ffe7adcfb83a0f29c8deda759bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1827241840656ffe7adcfb83a0f29c8deda759bd/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f02f739a825219a4bb5d12df2f646ea67c434a33", "url": "https://api.github.com/repos/rust-lang/rust/commits/f02f739a825219a4bb5d12df2f646ea67c434a33", "html_url": "https://github.com/rust-lang/rust/commit/f02f739a825219a4bb5d12df2f646ea67c434a33"}], "stats": {"total": 63, "additions": 40, "deletions": 23}, "files": [{"sha": "1992c102e474e5f748a47942adbaedc85c9e1f6d", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1827241840656ffe7adcfb83a0f29c8deda759bd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1827241840656ffe7adcfb83a0f29c8deda759bd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1827241840656ffe7adcfb83a0f29c8deda759bd", "patch": "@@ -93,6 +93,7 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean()));\n         });\n+        externs.sort_by(|&(a, _), &(b, _)| a.cmp(&b));\n \n         // Figure out the name of this crate\n         let input = driver::FileInput(cx.src.clone());\n@@ -132,24 +133,33 @@ impl<'a> Clean<Crate> for visit_ast::RustdocVisitor<'a> {\n                 _ => unreachable!(),\n             };\n             let mut tmp = Vec::new();\n-            for child in m.items.iter() {\n-                match child.inner {\n-                    ModuleItem(..) => {},\n+            for child in m.items.mut_iter() {\n+                let inner = match child.inner {\n+                    ModuleItem(ref mut m) => m,\n                     _ => continue,\n-                }\n+                };\n                 let prim = match Primitive::find(child.attrs.as_slice()) {\n                     Some(prim) => prim,\n                     None => continue,\n                 };\n                 primitives.push(prim);\n-                tmp.push(Item {\n+                let mut i = Item {\n                     source: Span::empty(),\n                     name: Some(prim.to_url_str().to_string()),\n-                    attrs: child.attrs.clone(),\n-                    visibility: Some(ast::Public),\n+                    attrs: Vec::new(),\n+                    visibility: None,\n                     def_id: ast_util::local_def(prim.to_node_id()),\n                     inner: PrimitiveItem(prim),\n-                });\n+                };\n+                // Push one copy to get indexed for the whole crate, and push a\n+                // another copy in the proper location which will actually get\n+                // documented. The first copy will also serve as a redirect to\n+                // the other copy.\n+                tmp.push(i.clone());\n+                i.visibility = Some(ast::Public);\n+                i.attrs = child.attrs.clone();\n+                inner.items.push(i);\n+\n             }\n             m.items.extend(tmp.move_iter());\n         }\n@@ -1027,7 +1037,7 @@ pub enum Type {\n     // region, raw, other boxes, mutable\n }\n \n-#[deriving(Clone, Encodable, Decodable, PartialEq, TotalEq, Hash)]\n+#[deriving(Clone, Encodable, Decodable, PartialEq, Eq, Hash)]\n pub enum Primitive {\n     Int, I8, I16, I32, I64,\n     Uint, U8, U16, U32, U64,"}, {"sha": "86a883bbff679a8fdc9df95f81b43701e166fa89", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1827241840656ffe7adcfb83a0f29c8deda759bd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1827241840656ffe7adcfb83a0f29c8deda759bd/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1827241840656ffe7adcfb83a0f29c8deda759bd", "patch": "@@ -867,6 +867,12 @@ impl DocFolder for Cache {\n                 stack.pop();\n                 self.paths.insert(item.def_id, (stack, item_type::Enum));\n             }\n+\n+            clean::PrimitiveItem(..) if item.visibility.is_some() => {\n+                self.paths.insert(item.def_id, (self.stack.clone(),\n+                                                shortty(&item)));\n+            }\n+\n             _ => {}\n         }\n \n@@ -1082,21 +1088,21 @@ impl Context {\n             writer.flush()\n         }\n \n+        // Private modules may survive the strip-private pass if they\n+        // contain impls for public types. These modules can also\n+        // contain items such as publicly reexported structures.\n+        //\n+        // External crates will provide links to these structures, so\n+        // these modules are recursed into, but not rendered normally (a\n+        // flag on the context).\n+        if !self.render_redirect_pages {\n+            self.render_redirect_pages = ignore_private_item(&item);\n+        }\n+\n         match item.inner {\n             // modules are special because they add a namespace. We also need to\n             // recurse into the items of the module as well.\n             clean::ModuleItem(..) => {\n-                // Private modules may survive the strip-private pass if they\n-                // contain impls for public types. These modules can also\n-                // contain items such as publicly reexported structures.\n-                //\n-                // External crates will provide links to these structures, so\n-                // these modules are recursed into, but not rendered normally (a\n-                // flag on the context).\n-                if !self.render_redirect_pages {\n-                    self.render_redirect_pages = ignore_private_module(&item);\n-                }\n-\n                 let name = item.name.get_ref().to_string();\n                 let mut item = Some(item);\n                 self.recurse(name, |this| {\n@@ -1330,7 +1336,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) -> fmt::Result {\n     try!(document(w, item));\n     let mut indices = range(0, items.len()).filter(|i| {\n-        !ignore_private_module(&items[*i])\n+        !ignore_private_item(&items[*i])\n     }).collect::<Vec<uint>>();\n \n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> Ordering {\n@@ -2016,7 +2022,7 @@ impl<'a> fmt::Show for Sidebar<'a> {\n fn build_sidebar(m: &clean::Module) -> HashMap<String, Vec<String>> {\n     let mut map = HashMap::new();\n     for item in m.items.iter() {\n-        if ignore_private_module(item) { continue }\n+        if ignore_private_item(item) { continue }\n \n         let short = shortty(item).to_static_str();\n         let myname = match item.name {\n@@ -2066,12 +2072,13 @@ fn item_primitive(w: &mut fmt::Formatter,\n     render_methods(w, it)\n }\n \n-fn ignore_private_module(it: &clean::Item) -> bool {\n+fn ignore_private_item(it: &clean::Item) -> bool {\n     match it.inner {\n         clean::ModuleItem(ref m) => {\n             (m.items.len() == 0 && it.doc_value().is_none()) ||\n                it.visibility != Some(ast::Public)\n         }\n+        clean::PrimitiveItem(..) => it.visibility != Some(ast::Public),\n         _ => false,\n     }\n }"}]}