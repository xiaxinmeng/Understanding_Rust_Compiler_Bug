{"sha": "af49d81e04f46f93d6393868a7871e645b68c761", "node_id": "C_kwDOAAsO6NoAKGFmNDlkODFlMDRmNDZmOTNkNjM5Mzg2OGE3ODcxZTY0NWI2OGM3NjE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-04T20:23:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-04T20:23:10Z"}, "message": "Rollup merge of #92530 - dtolnay:contains, r=yaahc\n\nMove `contains` method of Option and Result lower in docs\n\nFollow-up to #92444 trying to get the `Option` and `Result` rustdocs in better shape.\n\nThis addresses the request in https://github.com/rust-lang/rust/issues/62358#issuecomment-645676285. The `contains` methods are previously too high up in the docs on both `Option` and `Result` &mdash; stuff like `ok` and `map` and `and_then` should all be featured higher than `contains`. All of those are more ubiquitously useful than `contains`.", "tree": {"sha": "8dfd0d6be113279e3b7b88ae860711c29fc9b630", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8dfd0d6be113279e3b7b88ae860711c29fc9b630"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af49d81e04f46f93d6393868a7871e645b68c761", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1KyuCRBK7hj4Ov3rIwAA9IcIAIIGk5OualKUy76dSUG5GTbm\nnytslByqfxfblvSwBV2741uHwRm3B6EzRsd7pGzAMiU4wFuQhc5TZKqOafEk2H0W\njFHUdIPmBmK7Ne4NKODojo1Nq0ShELiLyV3vhbch11inujLGT9Zp20nMgH4+XE1b\n8qF159Gvjat8/n6W1389mqO4B61o1W4cVGaHFcVoOfBexqCi5BoZr0FNA72d6Aqp\nJ3YXM8ehaKP/tudnNKJKbESCiMq0U8FmZyc6dc4IZh4X3cB74pEZxM4fmtYSVZv+\nQHzmQBOTDwqFx8YxcdRocC6DGHK4PSKKMJqXFIu6c+LE23boDK0LIbcVLDyoGhU=\n=yItt\n-----END PGP SIGNATURE-----\n", "payload": "tree 8dfd0d6be113279e3b7b88ae860711c29fc9b630\nparent e1a7743971077e96733e051396c3afab751f4b79\nparent 7dec41a2367b995f3067e2e5cb644cff5ba99cfc\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1641327790 +0100\ncommitter GitHub <noreply@github.com> 1641327790 +0100\n\nRollup merge of #92530 - dtolnay:contains, r=yaahc\n\nMove `contains` method of Option and Result lower in docs\n\nFollow-up to #92444 trying to get the `Option` and `Result` rustdocs in better shape.\n\nThis addresses the request in https://github.com/rust-lang/rust/issues/62358#issuecomment-645676285. The `contains` methods are previously too high up in the docs on both `Option` and `Result` &mdash; stuff like `ok` and `map` and `and_then` should all be featured higher than `contains`. All of those are more ubiquitously useful than `contains`.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af49d81e04f46f93d6393868a7871e645b68c761", "html_url": "https://github.com/rust-lang/rust/commit/af49d81e04f46f93d6393868a7871e645b68c761", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af49d81e04f46f93d6393868a7871e645b68c761/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1a7743971077e96733e051396c3afab751f4b79", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1a7743971077e96733e051396c3afab751f4b79", "html_url": "https://github.com/rust-lang/rust/commit/e1a7743971077e96733e051396c3afab751f4b79"}, {"sha": "7dec41a2367b995f3067e2e5cb644cff5ba99cfc", "url": "https://api.github.com/repos/rust-lang/rust/commits/7dec41a2367b995f3067e2e5cb644cff5ba99cfc", "html_url": "https://github.com/rust-lang/rust/commit/7dec41a2367b995f3067e2e5cb644cff5ba99cfc"}], "stats": {"total": 180, "additions": 92, "deletions": 88}, "files": [{"sha": "1ec119a71e42c84cbc356e1cf4b6f82d24887d1a", "filename": "library/core/src/option.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/af49d81e04f46f93d6393868a7871e645b68c761/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af49d81e04f46f93d6393868a7871e645b68c761/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=af49d81e04f46f93d6393868a7871e645b68c761", "patch": "@@ -571,36 +571,6 @@ impl<T> Option<T> {\n         !self.is_some()\n     }\n \n-    /// Returns `true` if the option is a [`Some`] value containing the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(option_result_contains)]\n-    ///\n-    /// let x: Option<u32> = Some(2);\n-    /// assert_eq!(x.contains(&2), true);\n-    ///\n-    /// let x: Option<u32> = Some(3);\n-    /// assert_eq!(x.contains(&2), false);\n-    ///\n-    /// let x: Option<u32> = None;\n-    /// assert_eq!(x.contains(&2), false);\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n-    pub const fn contains<U>(&self, x: &U) -> bool\n-    where\n-        U: ~const PartialEq<T>,\n-    {\n-        match self {\n-            Some(y) => x.eq(y),\n-            None => false,\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Adapter for working with references\n     /////////////////////////////////////////////////////////////////////////\n@@ -1573,6 +1543,36 @@ impl<T> Option<T> {\n         mem::replace(self, Some(value))\n     }\n \n+    /// Returns `true` if the option is a [`Some`] value containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_result_contains)]\n+    ///\n+    /// let x: Option<u32> = Some(2);\n+    /// assert_eq!(x.contains(&2), true);\n+    ///\n+    /// let x: Option<u32> = Some(3);\n+    /// assert_eq!(x.contains(&2), false);\n+    ///\n+    /// let x: Option<u32> = None;\n+    /// assert_eq!(x.contains(&2), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n+    #[rustc_const_unstable(feature = \"const_option_ext\", issue = \"91930\")]\n+    pub const fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: ~const PartialEq<T>,\n+    {\n+        match self {\n+            Some(y) => x.eq(y),\n+            None => false,\n+        }\n+    }\n+\n     /// Zips `self` with another `Option`.\n     ///\n     /// If `self` is `Some(s)` and `other` is `Some(o)`, this method returns `Some((s, o))`."}, {"sha": "504a01813ac845d2b2deac2daff106606892afcc", "filename": "library/core/src/result.rs", "status": "modified", "additions": 62, "deletions": 58, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/af49d81e04f46f93d6393868a7871e645b68c761/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af49d81e04f46f93d6393868a7871e645b68c761/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=af49d81e04f46f93d6393868a7871e645b68c761", "patch": "@@ -563,64 +563,6 @@ impl<T, E> Result<T, E> {\n         !self.is_ok()\n     }\n \n-    /// Returns `true` if the result is an [`Ok`] value containing the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(option_result_contains)]\n-    ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.contains(&2), true);\n-    ///\n-    /// let x: Result<u32, &str> = Ok(3);\n-    /// assert_eq!(x.contains(&2), false);\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"Some error message\");\n-    /// assert_eq!(x.contains(&2), false);\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n-    pub fn contains<U>(&self, x: &U) -> bool\n-    where\n-        U: PartialEq<T>,\n-    {\n-        match self {\n-            Ok(y) => x == y,\n-            Err(_) => false,\n-        }\n-    }\n-\n-    /// Returns `true` if the result is an [`Err`] value containing the given value.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(result_contains_err)]\n-    ///\n-    /// let x: Result<u32, &str> = Ok(2);\n-    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"Some error message\");\n-    /// assert_eq!(x.contains_err(&\"Some error message\"), true);\n-    ///\n-    /// let x: Result<u32, &str> = Err(\"Some other error message\");\n-    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n-    /// ```\n-    #[must_use]\n-    #[inline]\n-    #[unstable(feature = \"result_contains_err\", issue = \"62358\")]\n-    pub fn contains_err<F>(&self, f: &F) -> bool\n-    where\n-        F: PartialEq<E>,\n-    {\n-        match self {\n-            Ok(_) => false,\n-            Err(e) => f == e,\n-        }\n-    }\n-\n     /////////////////////////////////////////////////////////////////////////\n     // Adapter for each variant\n     /////////////////////////////////////////////////////////////////////////\n@@ -1491,6 +1433,68 @@ impl<T, E> Result<T, E> {\n             Err(e) => e,\n         }\n     }\n+\n+    /////////////////////////////////////////////////////////////////////////\n+    // Misc or niche\n+    /////////////////////////////////////////////////////////////////////////\n+\n+    /// Returns `true` if the result is an [`Ok`] value containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(option_result_contains)]\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.contains(&2), true);\n+    ///\n+    /// let x: Result<u32, &str> = Ok(3);\n+    /// assert_eq!(x.contains(&2), false);\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.contains(&2), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"option_result_contains\", issue = \"62358\")]\n+    pub fn contains<U>(&self, x: &U) -> bool\n+    where\n+        U: PartialEq<T>,\n+    {\n+        match self {\n+            Ok(y) => x == y,\n+            Err(_) => false,\n+        }\n+    }\n+\n+    /// Returns `true` if the result is an [`Err`] value containing the given value.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(result_contains_err)]\n+    ///\n+    /// let x: Result<u32, &str> = Ok(2);\n+    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"Some error message\");\n+    /// assert_eq!(x.contains_err(&\"Some error message\"), true);\n+    ///\n+    /// let x: Result<u32, &str> = Err(\"Some other error message\");\n+    /// assert_eq!(x.contains_err(&\"Some error message\"), false);\n+    /// ```\n+    #[must_use]\n+    #[inline]\n+    #[unstable(feature = \"result_contains_err\", issue = \"62358\")]\n+    pub fn contains_err<F>(&self, f: &F) -> bool\n+    where\n+        F: PartialEq<E>,\n+    {\n+        match self {\n+            Ok(_) => false,\n+            Err(e) => f == e,\n+        }\n+    }\n }\n \n impl<T, E> Result<&T, E> {"}]}