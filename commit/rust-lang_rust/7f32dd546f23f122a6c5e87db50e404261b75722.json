{"sha": "7f32dd546f23f122a6c5e87db50e404261b75722", "node_id": "C_kwDOAAsO6NoAKDdmMzJkZDU0NmYyM2YxMjJhNmM1ZTg3ZGI1MGU0MDQyNjFiNzU3MjI", "commit": {"author": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-09-28T13:19:11Z"}, "committer": {"name": "Antoni Boucher", "email": "bouanto@zoho.com", "date": "2021-09-28T13:19:11Z"}, "message": "Merge commit '9809f5d21990d9e24b3e9876ea7da756fd4e9def' into libgccjit-codegen", "tree": {"sha": "615d2a69a0c7a6209f32bbfe7a36248b68578a17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/615d2a69a0c7a6209f32bbfe7a36248b68578a17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f32dd546f23f122a6c5e87db50e404261b75722", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f32dd546f23f122a6c5e87db50e404261b75722", "html_url": "https://github.com/rust-lang/rust/commit/7f32dd546f23f122a6c5e87db50e404261b75722", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f32dd546f23f122a6c5e87db50e404261b75722/comments", "author": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "committer": {"login": "antoyo", "id": 584972, "node_id": "MDQ6VXNlcjU4NDk3Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/584972?v=4", "gravatar_id": "", "url": "https://api.github.com/users/antoyo", "html_url": "https://github.com/antoyo", "followers_url": "https://api.github.com/users/antoyo/followers", "following_url": "https://api.github.com/users/antoyo/following{/other_user}", "gists_url": "https://api.github.com/users/antoyo/gists{/gist_id}", "starred_url": "https://api.github.com/users/antoyo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/antoyo/subscriptions", "organizations_url": "https://api.github.com/users/antoyo/orgs", "repos_url": "https://api.github.com/users/antoyo/repos", "events_url": "https://api.github.com/users/antoyo/events{/privacy}", "received_events_url": "https://api.github.com/users/antoyo/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df487317d08eb1bf194e87aa7c193bb738ed7546", "url": "https://api.github.com/repos/rust-lang/rust/commits/df487317d08eb1bf194e87aa7c193bb738ed7546", "html_url": "https://github.com/rust-lang/rust/commit/df487317d08eb1bf194e87aa7c193bb738ed7546"}, {"sha": "9809f5d21990d9e24b3e9876ea7da756fd4e9def", "url": "https://api.github.com/repos/rust-lang/rust/commits/9809f5d21990d9e24b3e9876ea7da756fd4e9def", "html_url": "https://github.com/rust-lang/rust/commit/9809f5d21990d9e24b3e9876ea7da756fd4e9def"}], "stats": {"total": 1118, "additions": 559, "deletions": 559}, "files": [{"sha": "60a2101c689cc2d1d6102a682956e61190f370cd", "filename": "compiler/rustc_codegen_gcc/Cargo.lock", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FCargo.lock?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -25,9 +25,9 @@ checksum = \"cdb031dd78e28731d87d56cc8ffef4a8f36ca26c38fe2de700543e627f8a464a\"\n \n [[package]]\n name = \"bitflags\"\n-version = \"1.2.1\"\n+version = \"1.3.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693\"\n+checksum = \"bef38d45163c2f1dde094a7dfd33ccf595c92905c8f8f4fdc18d06fb1037718a\"\n \n [[package]]\n name = \"cfg-if\"\n@@ -56,15 +56,15 @@ dependencies = [\n [[package]]\n name = \"gccjit\"\n version = \"1.0.0\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n dependencies = [\n  \"gccjit_sys\",\n ]\n \n [[package]]\n name = \"gccjit_sys\"\n version = \"0.0.1\"\n-source = \"git+https://github.com/antoyo/gccjit.rs#54be27e41fff7b6ab532e2e21a82df50a12b9ad3\"\n+source = \"git+https://github.com/antoyo/gccjit.rs#2d4fea7319f80531b2e5d264fca9f1c498a3a62e\"\n dependencies = [\n  \"libc 0.1.12\",\n ]\n@@ -85,7 +85,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"7fcd999463524c52659517fe2cea98493cfe485d10565e7b0fb07dbba7ad2753\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"wasi\",\n ]\n \n@@ -101,7 +101,7 @@ version = \"0.1.19\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"62b467343b94ba476dcb2500d242dadbb39557df889310ac77c5d99100aaac33\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]\n@@ -122,7 +122,7 @@ checksum = \"96bd995a092cac79868250589869b5a5d656b02a02bd74c8ebdc566dc7203090\"\n dependencies = [\n  \"fm\",\n  \"getopts\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"num_cpus\",\n  \"termcolor\",\n  \"threadpool\",\n@@ -138,15 +138,15 @@ checksum = \"e32a70cf75e5846d53a673923498228bbec6a8624708a9ea5645f075d6276122\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.98\"\n+version = \"0.2.102\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"320cfe77175da3a483efed4bc0adc1968ca050b098ce4f2f1c13a56626128790\"\n+checksum = \"a2a5ac8f984bfcf3a823267e5fde638acc3325f6496633a5da6bb6eb2171e103\"\n \n [[package]]\n name = \"memchr\"\n-version = \"2.4.0\"\n+version = \"2.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"b16bd47d9e329435e309c58469fe0791c2d0d1ba96ec0954152a5ae2b04387dc\"\n+checksum = \"308cc39be01b73d0d18f82a0e7b2a3df85245f84af96fdddc5d202d27e47b86a\"\n \n [[package]]\n name = \"num_cpus\"\n@@ -155,7 +155,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"05499f3756671c15885fee9034446956fff3f243d6077b91e5767df161f766b3\"\n dependencies = [\n  \"hermit-abi\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]\n@@ -181,7 +181,7 @@ version = \"0.8.4\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"2e7573632e6454cf6b99d7aac4ccca54be06da05aca2ef7423d22d27d4d4bcd8\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"rand_chacha\",\n  \"rand_core\",\n  \"rand_hc\",\n@@ -217,9 +217,9 @@ dependencies = [\n \n [[package]]\n name = \"redox_syscall\"\n-version = \"0.2.9\"\n+version = \"0.2.10\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"5ab49abadf3f9e1c4bc499e8845e152ad87d2ad2d30371841171169e9d75feee\"\n+checksum = \"8383f39639269cde97d255a32bdb68c047337295414940c68bdd30c2e13203ff\"\n dependencies = [\n  \"bitflags\",\n ]\n@@ -284,7 +284,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"dac1c663cfc93810f88aed9b8941d48cabf856a1b111c29a40439018d870eb22\"\n dependencies = [\n  \"cfg-if\",\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n  \"rand\",\n  \"redox_syscall\",\n  \"remove_dir_all\",\n@@ -311,17 +311,17 @@ dependencies = [\n \n [[package]]\n name = \"unicode-width\"\n-version = \"0.1.8\"\n+version = \"0.1.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"9337591893a19b88d8d87f2cec1e73fad5cdfd10e5a6f349f498ad6ea2ffb1e3\"\n+checksum = \"3ed742d4ea2bd1176e236172c8429aaf54486e7ac098db29ffe6529e0ce50973\"\n \n [[package]]\n name = \"wait-timeout\"\n version = \"0.2.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"9f200f5b12eb75f8c1ed65abd4b2db8a6e1b138a20de009dacee265a2498f3f6\"\n dependencies = [\n- \"libc 0.2.98\",\n+ \"libc 0.2.102\",\n ]\n \n [[package]]"}, {"sha": "709d93c6edb054f384fd2c9a4823597e827753e9", "filename": "compiler/rustc_codegen_gcc/Readme.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2FReadme.md", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2FReadme.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2FReadme.md?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -115,3 +115,21 @@ p loc->m_line\n \n  * Build the stage2 compiler (`rustup toolchain link debug-current build/x86_64-unknown-linux-gnu/stage2`).\n  * Clean and rebuild the codegen with `debug-current` in the file `rust-toolchain`.\n+\n+### How to build a cross-compiling libgccjit\n+\n+#### Building libgccjit\n+\n+ * Follow these instructions: https://preshing.com/20141119/how-to-build-a-gcc-cross-compiler/ with the following changes:\n+ * Configure gcc with `../gcc/configure --enable-host-shared --disable-multilib --enable-languages=c,jit,c++ --disable-bootstrap --enable-checking=release --prefix=/opt/m68k-gcc/ --target=m68k-linux --without-headers`.\n+ * Some shells, like fish, don't define the environment variable `$MACHTYPE`.\n+ * Add `CFLAGS=\"-Wno-error=attributes -g -O2\"` at the end of the configure command for building glibc (`CFLAGS=\"-Wno-error=attributes -Wno-error=array-parameter -Wno-error=stringop-overflow -Wno-error=array-bounds -g -O2\"` for glibc 2.31, which is useful for Debian).\n+\n+#### Configuring rustc_codegen_gcc\n+\n+ * Set `TARGET_TRIPLE=\"m68k-unknown-linux-gnu\"` in config.sh.\n+ * Since rustc doesn't support this architecture yet, set it back to `TARGET_TRIPLE=\"mips-unknown-linux-gnu\"` (or another target having the same attributes). Alternatively, create a [target specification file](https://book.avr-rust.com/005.1-the-target-specification-json-file.html) (note that the `arch` specified in this file must be supported by the rust compiler).\n+ * Set `linker='-Clinker=m68k-linux-gcc'`.\n+ * Set the path to the cross-compiling libgccjit in `gcc_path`.\n+ * Disable the 128-bit integer types if the target doesn't support them by using `let i128_type = context.new_type::<i64>();` in `context.rs` (same for u128_type).\n+ * (might not be necessary) Disable the compilation of libstd.so (and possibly libcore.so?)."}, {"sha": "87df2f2102bcd42dd3ede437a72a30552ff147e3", "filename": "compiler/rustc_codegen_gcc/config.sh", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fconfig.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fconfig.sh?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -21,12 +21,15 @@ fi\n \n HOST_TRIPLE=$(rustc -vV | grep host | cut -d: -f2 | tr -d \" \")\n TARGET_TRIPLE=$HOST_TRIPLE\n-#TARGET_TRIPLE=\"aarch64-unknown-linux-gnu\"\n+#TARGET_TRIPLE=\"m68k-unknown-linux-gnu\"\n \n linker=''\n RUN_WRAPPER=''\n if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n-   if [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n+   if [[ \"$TARGET_TRIPLE\" == \"m68k-unknown-linux-gnu\" ]]; then\n+       TARGET_TRIPLE=\"mips-unknown-linux-gnu\"\n+       linker='-Clinker=m68k-linux-gcc'\n+   elif [[ \"$TARGET_TRIPLE\" == \"aarch64-unknown-linux-gnu\" ]]; then\n       # We are cross-compiling for aarch64. Use the correct linker and run tests in qemu.\n       linker='-Clinker=aarch64-linux-gnu-gcc'\n       RUN_WRAPPER='qemu-aarch64 -L /usr/aarch64-linux-gnu'\n@@ -35,7 +38,7 @@ if [[ \"$HOST_TRIPLE\" != \"$TARGET_TRIPLE\" ]]; then\n    fi\n fi\n \n-export RUSTFLAGS=\"$linker -Cpanic=abort -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n+export RUSTFLAGS=\"$linker -Cpanic=abort -Zsymbol-mangling-version=v0 -Cdebuginfo=2 -Clto=off -Zpanic-abort-tests -Zcodegen-backend=$(pwd)/target/${CHANNEL:-debug}/librustc_codegen_gcc.$dylib_ext --sysroot $(pwd)/build_sysroot/sysroot\"\n \n # FIXME(antoyo): remove once the atomic shim is gone\n if [[ `uname` == 'Darwin' ]]; then"}, {"sha": "d311a33f807b7e238422d21f43fdc22e2998c7df", "filename": "compiler/rustc_codegen_gcc/rust-toolchain", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Frust-toolchain", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Frust-toolchain?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1 +1 @@\n-nightly-2021-09-17\n+nightly-2021-09-28"}, {"sha": "3b77097e9ad00230b058ab0ef63762cb9eabbc96", "filename": "compiler/rustc_codegen_gcc/src/asm.rs", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fasm.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -6,7 +6,7 @@ use rustc_codegen_ssa::traits::{AsmBuilderMethods, AsmMethods, BaseTypeMethods,\n \n use rustc_hir::LlvmInlineAsmInner;\n use rustc_middle::{bug, ty::Instance};\n-use rustc_span::Span;\n+use rustc_span::{Span, Symbol};\n use rustc_target::asm::*;\n \n use std::borrow::Cow;\n@@ -173,7 +173,20 @@ impl<'a, 'gcc, 'tcx> AsmBuilderMethods<'tcx> for Builder<'a, 'gcc, 'tcx> {\n                             continue\n                         },\n                         (Register(reg_name), None) => {\n-                            clobbers.push(reg_name);\n+                            // `clobber_abi` can add lots of clobbers that are not supported by the target,\n+                            // such as AVX-512 registers, so we just ignore unsupported registers\n+                            let is_target_supported = reg.reg_class().supported_types(asm_arch).iter()\n+                                .any(|&(_, feature)| {\n+                                    if let Some(feature) = feature {\n+                                        self.tcx.sess.target_features.contains(&Symbol::intern(feature))\n+                                    } else {\n+                                        true // Register class is unconditionally supported\n+                                    }\n+                                });\n+\n+                            if is_target_supported && !clobbers.contains(&reg_name) {\n+                                clobbers.push(reg_name);\n+                            }\n                             continue\n                         }\n                     };\n@@ -526,16 +539,20 @@ fn reg_to_gcc(reg: InlineAsmRegOrRegClass) -> ConstraintOrRegister {\n     let constraint = match reg {\n         // For vector registers LLVM wants the register name to match the type size.\n         InlineAsmRegOrRegClass::Reg(reg) => {\n-            // TODO(antoyo): add support for vector register.\n-            match reg.name() {\n-                \"ax\" => \"a\",\n-                \"bx\" => \"b\",\n-                \"cx\" => \"c\",\n-                \"dx\" => \"d\",\n-                \"si\" => \"S\",\n-                \"di\" => \"D\",\n-                // For registers like r11, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n-                name => return ConstraintOrRegister::Register(name), \n+            match reg {\n+                InlineAsmReg::X86(_) => {\n+                    // TODO(antoyo): add support for vector register.\n+                    //\n+                    // // For explicit registers, we have to create a register variable: https://stackoverflow.com/a/31774784/389119\n+                    return ConstraintOrRegister::Register(match reg.name() {\n+                        // Some of registers' names does not map 1-1 from rust to gcc\n+                        \"st(0)\" => \"st\",\n+\n+                        name => name,\n+                    });\n+                }\n+\n+                _ => unimplemented!(),\n             }\n         },\n         InlineAsmRegOrRegClass::RegClass(reg) => match reg {"}, {"sha": "9fd043607fc7e25bb9a81c11823b106af686c7db", "filename": "compiler/rustc_codegen_gcc/src/base.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbase.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1,13 +1,11 @@\n use std::env;\n-use std::sync::Once;\n use std::time::Instant;\n \n use gccjit::{\n     Context,\n     FunctionType,\n     GlobalKind,\n };\n-use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::dep_graph;\n use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::middle::exported_symbols;\n@@ -20,7 +18,7 @@ use rustc_codegen_ssa::traits::DebugInfoMethods;\n use rustc_session::config::DebugInfo;\n use rustc_span::Symbol;\n \n-use crate::{GccContext, create_function_calling_initializers};\n+use crate::GccContext;\n use crate::builder::Builder;\n use crate::context::CodegenCx;\n \n@@ -97,15 +95,6 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n         {\n             let cx = CodegenCx::new(&context, cgu, tcx);\n \n-            static START: Once = Once::new();\n-            START.call_once(|| {\n-                let initializer_name = format!(\"__gccGlobalCrateInit{}\", tcx.crate_name(LOCAL_CRATE));\n-                let func = context.new_function(None, FunctionType::Exported, context.new_type::<()>(), &[], initializer_name, false);\n-                let block = func.new_block(\"initial\");\n-                create_function_calling_initializers(tcx, &context, block);\n-                block.end_with_void_return(None);\n-            });\n-\n             let mono_items = cgu.items_in_deterministic_order(tcx);\n             for &(mono_item, (linkage, visibility)) in &mono_items {\n                 mono_item.predefine::<Builder<'_, '_, '_>>(&cx, linkage, visibility);\n@@ -124,8 +113,6 @@ pub fn compile_codegen_unit<'tcx>(tcx: TyCtxt<'tcx>, cgu_name: Symbol) -> (Modul\n             if cx.sess().opts.debuginfo != DebugInfo::None {\n                 cx.debuginfo_finalize();\n             }\n-\n-            cx.global_init_block.end_with_void_return(None);\n         }\n \n         ModuleCodegen {"}, {"sha": "ac908418ee4bf6fcf160a070090705e157c5793c", "filename": "compiler/rustc_codegen_gcc/src/builder.rs", "status": "modified", "additions": 39, "deletions": 7, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fbuilder.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -31,11 +31,12 @@ use rustc_codegen_ssa::traits::{\n     StaticBuilderMethods,\n };\n use rustc_middle::ty::{ParamEnv, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, LayoutOfHelpers, TyAndLayout};\n use rustc_span::Span;\n use rustc_span::def_id::DefId;\n use rustc_target::abi::{\n     self,\n+    call::FnAbi,\n     Align,\n     HasDataLayout,\n     Size,\n@@ -347,6 +348,20 @@ impl<'tcx> LayoutOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n     }\n }\n \n+impl<'tcx> FnAbiOfHelpers<'tcx> for Builder<'_, '_, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        self.cx.handle_fn_abi_err(err, span, fn_abi_request)\n+    }\n+}\n+\n impl<'gcc, 'tcx> Deref for Builder<'_, 'gcc, 'tcx> {\n     type Target = CodegenCx<'gcc, 'tcx>;\n \n@@ -505,7 +520,6 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n         // FIXME(antoyo): rustc_codegen_ssa::mir::intrinsic uses different types for a and b but they\n         // should be the same.\n         let typ = a.get_type().to_signed(self);\n-        let a = self.context.new_cast(None, a, typ);\n         let b = self.context.new_cast(None, b, typ);\n         a / b\n     }\n@@ -1052,11 +1066,18 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     /* Comparisons */\n-    fn icmp(&mut self, op: IntPredicate, lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n-        if lhs.get_type() != rhs.get_type() {\n+    fn icmp(&mut self, op: IntPredicate, mut lhs: RValue<'gcc>, mut rhs: RValue<'gcc>) -> RValue<'gcc> {\n+        let left_type = lhs.get_type();\n+        let right_type = rhs.get_type();\n+        if left_type != right_type {\n+            // NOTE: because libgccjit cannot compare function pointers.\n+            if left_type.is_function_ptr_type().is_some() && right_type.is_function_ptr_type().is_some() {\n+                lhs = self.context.new_cast(None, lhs, self.usize_type.make_pointer());\n+                rhs = self.context.new_cast(None, rhs, self.usize_type.make_pointer());\n+            }\n             // NOTE: hack because we try to cast a vector type to the same vector type.\n-            if format!(\"{:?}\", lhs.get_type()) != format!(\"{:?}\", rhs.get_type()) {\n-                rhs = self.context.new_cast(None, rhs, lhs.get_type());\n+            else if format!(\"{:?}\", left_type) != format!(\"{:?}\", right_type) {\n+                rhs = self.context.new_cast(None, rhs, left_type);\n             }\n         }\n         self.context.new_comparison(None, op.to_gcc_comparison(), lhs, rhs)\n@@ -1210,6 +1231,17 @@ impl<'a, 'gcc, 'tcx> BuilderMethods<'a, 'tcx> for Builder<'a, 'gcc, 'tcx> {\n             else {\n                 panic!(\"Unexpected type {:?}\", value_type);\n             };\n+\n+        let lvalue_type = lvalue.to_rvalue().get_type();\n+        let value =\n+            // NOTE: sometimes, rustc will create a value with the wrong type.\n+            if lvalue_type != value.get_type() {\n+                self.context.new_cast(None, value, lvalue_type)\n+            }\n+            else {\n+                value\n+            };\n+\n         self.llbb().add_assignment(None, lvalue, value);\n \n         aggregate_value\n@@ -1413,7 +1445,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n impl<'a, 'gcc, 'tcx> StaticBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     fn get_static(&mut self, def_id: DefId) -> RValue<'gcc> {\n         // Forward to the `get_static` method of `CodegenCx`\n-        self.cx().get_static(def_id)\n+        self.cx().get_static(def_id).get_address(None)\n     }\n }\n "}, {"sha": "76419b103d049e3c2b50c0831b3c1e4c3ff28959", "filename": "compiler/rustc_codegen_gcc/src/callee.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcallee.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1,8 +1,7 @@\n use gccjit::{FunctionType, RValue};\n use rustc_codegen_ssa::traits::BaseTypeMethods;\n-use rustc_middle::ty::{Instance, TypeFoldable};\n-use rustc_middle::ty::layout::{FnAbiExt, HasTyCtxt};\n-use rustc_target::abi::call::FnAbi;\n+use rustc_middle::ty::{self, Instance, TypeFoldable};\n+use rustc_middle::ty::layout::{FnAbiOf, HasTyCtxt};\n \n use crate::abi::FnAbiGccExt;\n use crate::context::CodegenCx;\n@@ -20,13 +19,13 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n     assert!(!instance.substs.needs_infer());\n     assert!(!instance.substs.has_escaping_bound_vars());\n \n-    if let Some(&func) = cx.instances.borrow().get(&instance) {\n+    if let Some(&func) = cx.function_instances.borrow().get(&instance) {\n         return func;\n     }\n \n     let sym = tcx.symbol_name(instance).name;\n \n-    let fn_abi = FnAbi::of_instance(cx, instance, &[]);\n+    let fn_abi = cx.fn_abi_of_instance(instance, ty::List::empty());\n \n     let func =\n         if let Some(func) = cx.get_declared_value(&sym) {\n@@ -72,7 +71,7 @@ pub fn get_fn<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, instance: Instance<'tcx>)\n             func\n         };\n \n-    cx.instances.borrow_mut().insert(instance, func);\n+    cx.function_instances.borrow_mut().insert(instance, func);\n \n     func\n }"}, {"sha": "bda08b653f05929fc35a58d273a80fdc20c728ae", "filename": "compiler/rustc_codegen_gcc/src/common.rs", "status": "modified", "additions": 42, "deletions": 28, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcommon.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1,6 +1,7 @@\n use std::convert::TryFrom;\n use std::convert::TryInto;\n \n+use gccjit::LValue;\n use gccjit::{Block, CType, RValue, Type, ToRValue};\n use rustc_codegen_ssa::mir::place::PlaceRef;\n use rustc_codegen_ssa::traits::{\n@@ -10,7 +11,6 @@ use rustc_codegen_ssa::traits::{\n     MiscMethods,\n     StaticMethods,\n };\n-use rustc_middle::bug;\n use rustc_middle::mir::Mutability;\n use rustc_middle::ty::ScalarInt;\n use rustc_middle::ty::layout::{TyAndLayout, LayoutOf};\n@@ -27,28 +27,25 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         bytes_in_context(self, bytes)\n     }\n \n-    fn const_cstr(&self, symbol: Symbol, _null_terminated: bool) -> RValue<'gcc> {\n+    fn const_cstr(&self, symbol: Symbol, _null_terminated: bool) -> LValue<'gcc> {\n         // TODO(antoyo): handle null_terminated.\n         if let Some(&value) = self.const_cstr_cache.borrow().get(&symbol) {\n-            return value.to_rvalue();\n+            return value;\n         }\n \n         let global = self.global_string(&*symbol.as_str());\n \n-        self.const_cstr_cache.borrow_mut().insert(symbol, global.dereference(None));\n+        self.const_cstr_cache.borrow_mut().insert(symbol, global);\n         global\n     }\n \n-    fn global_string(&self, string: &str) -> RValue<'gcc> {\n+    fn global_string(&self, string: &str) -> LValue<'gcc> {\n         // TODO(antoyo): handle non-null-terminated strings.\n         let string = self.context.new_string_literal(&*string);\n         let sym = self.generate_local_symbol_name(\"str\");\n-        // NOTE: TLS is always off for a string litteral.\n-        // NOTE: string litterals do not have a link section.\n-        let global = self.define_global(&sym, self.val_ty(string), false, None)\n-            .unwrap_or_else(|| bug!(\"symbol `{}` is already defined\", sym));\n-        self.global_init_block.add_assignment(None, global.dereference(None), string);\n-        global.to_rvalue()\n+        let global = self.declare_private_global(&sym, self.val_ty(string));\n+        global.global_set_initializer_value(string);\n+        global\n         // TODO(antoyo): set linkage.\n     }\n \n@@ -76,10 +73,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n \n pub fn bytes_in_context<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, bytes: &[u8]) -> RValue<'gcc> {\n     let context = &cx.context;\n-    let typ = context.new_array_type(None, context.new_type::<u8>(), bytes.len() as i32);\n-    let global = cx.declare_unnamed_global(typ);\n-    global.global_set_initializer(bytes);\n-    global.to_rvalue()\n+    let byte_type = context.new_type::<u8>();\n+    let typ = context.new_array_type(None, byte_type, bytes.len() as i32);\n+    let elements: Vec<_> =\n+        bytes.iter()\n+        .map(|&byte| context.new_rvalue_from_int(byte_type, byte as i32))\n+        .collect();\n+    context.new_rvalue_from_array(None, typ, &elements)\n }\n \n pub fn type_is_pointer<'gcc>(typ: Type<'gcc>) -> bool {\n@@ -180,7 +180,7 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n \n     fn const_str(&self, s: Symbol) -> (RValue<'gcc>, RValue<'gcc>) {\n         let len = s.as_str().len();\n-        let cs = self.const_ptrcast(self.const_cstr(s, false),\n+        let cs = self.const_ptrcast(self.const_cstr(s, false).get_address(None),\n             self.type_ptr_to(self.layout_of(self.tcx.types.str_).gcc_type(self, true)),\n         );\n         (cs, self.const_usize(len as u64))\n@@ -191,16 +191,9 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n             .map(|value| value.get_type())\n             .collect();\n         // TODO(antoyo): cache the type? It's anonymous, so probably not.\n-        let name = fields.iter().map(|typ| format!(\"{:?}\", typ)).collect::<Vec<_>>().join(\"_\");\n         let typ = self.type_struct(&fields, packed);\n-        let structure = self.global_init_func.new_local(None, typ, &name);\n         let struct_type = typ.is_struct().expect(\"struct type\");\n-        for (index, value) in values.iter().enumerate() {\n-            let field = struct_type.get_field(index as i32);\n-            let field_lvalue = structure.access_field(None, field);\n-            self.global_init_block.add_assignment(None, field_lvalue, *value);\n-        }\n-        self.lvalue_to_rvalue(structure)\n+        self.context.new_rvalue_from_struct(None, struct_type, values)\n     }\n \n     fn const_to_opt_uint(&self, _v: RValue<'gcc>) -> Option<u64> {\n@@ -260,19 +253,18 @@ impl<'gcc, 'tcx> ConstMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n                         },\n                         GlobalAlloc::Static(def_id) => {\n                             assert!(self.tcx.is_static(def_id));\n-                            self.get_static(def_id)\n+                            self.get_static(def_id).get_address(None)\n                         },\n                     };\n                 let ptr_type = base_addr.get_type();\n                 let base_addr = self.const_bitcast(base_addr, self.usize_type);\n                 let offset = self.context.new_rvalue_from_long(self.usize_type, offset.bytes() as i64);\n                 let ptr = self.const_bitcast(base_addr + offset, ptr_type);\n-                let value = ptr.dereference(None);\n                 if layout.value != Pointer {\n-                    self.const_bitcast(value.to_rvalue(), ty)\n+                    self.const_bitcast(ptr.dereference(None).to_rvalue(), ty)\n                 }\n                 else {\n-                    self.const_bitcast(value.get_address(None), ty)\n+                    self.const_bitcast(ptr, ty)\n                 }\n             }\n         }\n@@ -310,6 +302,7 @@ pub trait SignType<'gcc, 'tcx> {\n     fn is_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn is_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> bool;\n     fn to_signed(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc>;\n }\n \n impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n@@ -341,6 +334,27 @@ impl<'gcc, 'tcx> SignType<'gcc, 'tcx> for Type<'gcc> {\n             self.clone()\n         }\n     }\n+\n+    fn to_unsigned(&self, cx: &CodegenCx<'gcc, 'tcx>) -> Type<'gcc> {\n+        if self.is_i8(cx) {\n+            cx.u8_type\n+        }\n+        else if self.is_i16(cx) {\n+            cx.u16_type\n+        }\n+        else if self.is_i32(cx) {\n+            cx.u32_type\n+        }\n+        else if self.is_i64(cx) {\n+            cx.u64_type\n+        }\n+        else if self.is_i128(cx) {\n+            cx.u128_type\n+        }\n+        else {\n+            self.clone()\n+        }\n+    }\n }\n \n pub trait TypeReflection<'gcc, 'tcx>  {"}, {"sha": "205498acc3187beb9260e194db2e3de1c06d5426", "filename": "compiler/rustc_codegen_gcc/src/consts.rs", "status": "modified", "additions": 22, "deletions": 67, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fconsts.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1,4 +1,4 @@\n-use gccjit::{RValue, Type};\n+use gccjit::{LValue, RValue, ToRValue, Type};\n use rustc_codegen_ssa::traits::{BaseTypeMethods, ConstMethods, DerivedTypeMethods, StaticMethods};\n use rustc_hir as hir;\n use rustc_hir::Node;\n@@ -14,7 +14,6 @@ use rustc_target::abi::{self, Align, HasDataLayout, Primitive, Size, WrappingRan\n \n use crate::base;\n use crate::context::CodegenCx;\n-use crate::mangled_std_symbols::{ARGC, ARGV, ARGV_INIT_ARRAY};\n use crate::type_of::LayoutGccExt;\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -45,17 +44,13 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n     fn codegen_static(&self, def_id: DefId, is_mutable: bool) {\n         let attrs = self.tcx.codegen_fn_attrs(def_id);\n \n-        let instance = Instance::mono(self.tcx, def_id);\n-        let name = &*self.tcx.symbol_name(instance).name;\n-\n-        let (value, alloc) =\n+        let value =\n             match codegen_static_initializer(&self, def_id) {\n-                Ok(value) => value,\n+                Ok((value, _)) => value,\n                 // Error has already been reported\n                 Err(_) => return,\n             };\n \n-        let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n         let global = self.get_static(def_id);\n \n         // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -73,45 +68,16 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         let ty = instance.ty(self.tcx, ty::ParamEnv::reveal_all());\n         let gcc_type = self.layout_of(ty).gcc_type(self, true);\n \n-        let global =\n-            if val_llty == gcc_type {\n-                global\n+        // TODO(antoyo): set alignment.\n+\n+        let value =\n+            if value.get_type() != gcc_type {\n+                self.context.new_bitcast(None, value, gcc_type)\n             }\n             else {\n-                // If we created the global with the wrong type,\n-                // correct the type.\n-                // TODO(antoyo): set value name, linkage and visibility.\n-\n-                let new_global = self.get_or_insert_global(&name, val_llty, is_tls, attrs.link_section);\n-\n-                // To avoid breaking any invariants, we leave around the old\n-                // global for the moment; we'll replace all references to it\n-                // with the new global later. (See base::codegen_backend.)\n-                //self.statics_to_rauw.borrow_mut().push((global, new_global));\n-                new_global\n+                value\n             };\n-        // TODO(antoyo): set alignment and initializer.\n-        let value = self.rvalue_as_lvalue(value);\n-        let value = value.get_address(None);\n-        let dest_typ = global.get_type();\n-        let value = self.context.new_cast(None, value, dest_typ);\n-\n-        // NOTE: do not init the variables related to argc/argv because it seems we cannot\n-        // overwrite those variables.\n-        // FIXME(antoyo): correctly support global variable initialization.\n-        let skip_init = [\n-            ARGV_INIT_ARRAY,\n-            ARGC,\n-            ARGV,\n-        ];\n-        if !skip_init.iter().any(|symbol_name| name.starts_with(symbol_name)) {\n-            // TODO(antoyo): switch to set_initializer when libgccjit supports that.\n-            let memcpy = self.context.get_builtin_function(\"memcpy\");\n-            let dst = self.context.new_cast(None, global, self.type_i8p());\n-            let src = self.context.new_cast(None, value, self.type_ptr_to(self.type_void()));\n-            let size = self.context.new_rvalue_from_long(self.sizet_type, alloc.size().bytes() as i64);\n-            self.global_init_block.add_eval(None, self.context.new_call(None, memcpy, &[dst, src, size]));\n-        }\n+        global.global_set_initializer_value(value);\n \n         // As an optimization, all shared statics which do not have interior\n         // mutability are placed into read-only memory.\n@@ -175,7 +141,7 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n         }\n \n         if attrs.flags.contains(CodegenFnAttrFlags::USED) {\n-            self.add_used_global(global);\n+            self.add_used_global(global.to_rvalue());\n         }\n     }\n \n@@ -191,38 +157,31 @@ impl<'gcc, 'tcx> StaticMethods for CodegenCx<'gcc, 'tcx> {\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     pub fn static_addr_of_mut(&self, cv: RValue<'gcc>, align: Align, kind: Option<&str>) -> RValue<'gcc> {\n-        let (name, gv) =\n+        let global =\n             match kind {\n                 Some(kind) if !self.tcx.sess.fewer_names() => {\n                     let name = self.generate_local_symbol_name(kind);\n                     // TODO(antoyo): check if it's okay that TLS is off here.\n                     // TODO(antoyo): check if it's okay that link_section is None here.\n                     // TODO(antoyo): set alignment here as well.\n-                    let gv = self.define_global(&name[..], self.val_ty(cv), false, None).unwrap_or_else(|| {\n-                        bug!(\"symbol `{}` is already defined\", name);\n-                    });\n+                    let global = self.define_global(&name[..], self.val_ty(cv), false, None);\n                     // TODO(antoyo): set linkage.\n-                    (name, gv)\n+                    global\n                 }\n                 _ => {\n-                    let index = self.global_gen_sym_counter.get();\n-                    let name = format!(\"global_{}_{}\", index, self.codegen_unit.name());\n                     let typ = self.val_ty(cv).get_aligned(align.bytes());\n-                    let global = self.define_private_global(typ);\n-                    (name, global)\n+                    let global = self.declare_unnamed_global(typ);\n+                    global\n                 },\n             };\n         // FIXME(antoyo): I think the name coming from generate_local_symbol_name() above cannot be used\n         // globally.\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(cv, name);\n-        self.global_init_block.add_assignment(None, gv.dereference(None), cv);\n+        global.global_set_initializer_value(cv);\n         // TODO(antoyo): set unnamed address.\n-        gv\n+        global.get_address(None)\n     }\n \n-    pub fn get_static(&self, def_id: DefId) -> RValue<'gcc> {\n+    pub fn get_static(&self, def_id: DefId) -> LValue<'gcc> {\n         let instance = Instance::mono(self.tcx, def_id);\n         let fn_attrs = self.tcx.codegen_fn_attrs(def_id);\n         if let Some(&global) = self.instances.borrow().get(&instance) {\n@@ -380,7 +339,7 @@ pub fn codegen_static_initializer<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, def_id\n     Ok((const_alloc_to_gcc(cx, alloc), alloc))\n }\n \n-fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> RValue<'gcc> {\n+fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &CodegenFnAttrs, ty: Ty<'tcx>, sym: &str, span: Span) -> LValue<'gcc> {\n     let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n     let llty = cx.layout_of(ty).gcc_type(cx, true);\n     if let Some(linkage) = attrs.linkage {\n@@ -410,13 +369,9 @@ fn check_and_apply_linkage<'gcc, 'tcx>(cx: &CodegenCx<'gcc, 'tcx>, attrs: &Codeg\n         // zero.\n         let mut real_name = \"_rust_extern_with_linkage_\".to_string();\n         real_name.push_str(&sym);\n-        let global2 =\n-            cx.define_global(&real_name, llty, is_tls, attrs.link_section).unwrap_or_else(|| {\n-                cx.sess().span_fatal(span, &format!(\"symbol `{}` is already defined\", &sym))\n-            });\n+        let global2 = cx.define_global(&real_name, llty, is_tls, attrs.link_section);\n         // TODO(antoyo): set linkage.\n-        let lvalue = global2.dereference(None);\n-        cx.global_init_block.add_assignment(None, lvalue, global1);\n+        global2.global_set_initializer_value(global1.get_address(None));\n         // TODO(antoyo): use global_set_initializer() when it will work.\n         global2\n     }"}, {"sha": "7677ade7314e52d1ce8af86ad1fbc54d3b45c39b", "filename": "compiler/rustc_codegen_gcc/src/context.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fcontext.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -21,10 +21,10 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::span_bug;\n use rustc_middle::mir::mono::CodegenUnit;\n use rustc_middle::ty::{self, Instance, ParamEnv, PolyExistentialTraitRef, Ty, TyCtxt};\n-use rustc_middle::ty::layout::{HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n+use rustc_middle::ty::layout::{FnAbiError, FnAbiOfHelpers, FnAbiRequest, HasParamEnv, HasTyCtxt, LayoutError, TyAndLayout, LayoutOfHelpers};\n use rustc_session::Session;\n use rustc_span::{Span, Symbol};\n-use rustc_target::abi::{HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n+use rustc_target::abi::{call::FnAbi, HasDataLayout, PointeeInfo, Size, TargetDataLayout, VariantIdx};\n use rustc_target::spec::{HasTargetSpec, Target, TlsModel};\n \n use crate::callee::get_fn;\n@@ -46,10 +46,6 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub current_func: RefCell<Option<Function<'gcc>>>,\n     pub normal_function_addresses: RefCell<FxHashSet<RValue<'gcc>>>,\n \n-    /// The function where globals are initialized.\n-    pub global_init_func: Function<'gcc>,\n-    pub global_init_block: Block<'gcc>,\n-\n     pub functions: RefCell<FxHashMap<String, Function<'gcc>>>,\n \n     pub tls_model: gccjit::TlsModel,\n@@ -89,23 +85,20 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     pub types_with_fields_to_set: RefCell<FxHashMap<Type<'gcc>, (Struct<'gcc>, TyAndLayout<'tcx>)>>,\n \n     /// Cache instances of monomorphic and polymorphic items\n-    pub instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n+    pub instances: RefCell<FxHashMap<Instance<'tcx>, LValue<'gcc>>>,\n+    /// Cache function instances of monomorphic and polymorphic items\n+    pub function_instances: RefCell<FxHashMap<Instance<'tcx>, RValue<'gcc>>>,\n     /// Cache generated vtables\n     pub vtables: RefCell<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), RValue<'gcc>>>,\n \n     /// Cache of emitted const globals (value -> global)\n     pub const_globals: RefCell<FxHashMap<RValue<'gcc>, RValue<'gcc>>>,\n \n-    pub init_argv_var: RefCell<String>,\n-    pub argv_initialized: Cell<bool>,\n-\n     /// Cache of constant strings,\n     pub const_cstr_cache: RefCell<FxHashMap<Symbol, LValue<'gcc>>>,\n \n     /// Cache of globals.\n     pub globals: RefCell<FxHashMap<String, RValue<'gcc>>>,\n-    // TODO(antoyo): remove global_names.\n-    pub global_names: RefCell<FxHashMap<RValue<'gcc>, String>>,\n \n     /// A counter that is used for generating local symbol names\n     local_gen_sym_counter: Cell<usize>,\n@@ -118,16 +111,9 @@ pub struct CodegenCx<'gcc, 'tcx> {\n     /// NOTE: a hack is used because the rustc API is not suitable to libgccjit and as such,\n     /// `const_undef()` returns struct as pointer so that they can later be assigned a value.\n     /// As such, this set remembers which of these pointers were returned by this function so that\n-    /// they can be derefered later.\n+    /// they can be deferenced later.\n     /// FIXME(antoyo): fix the rustc API to avoid having this hack.\n     pub structs_as_pointer: RefCell<FxHashSet<RValue<'gcc>>>,\n-\n-    /// Store the pointer of different types for safety.\n-    /// When casting the values back to their original types, check that they are indeed that type\n-    /// with these sets.\n-    /// FIXME(antoyo): remove when the API supports more types.\n-    #[cfg(debug_assertions)]\n-    lvalues: RefCell<FxHashSet<LValue<'gcc>>>,\n }\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n@@ -180,10 +166,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             functions.insert(builtin.to_string(), context.get_builtin_function(builtin));\n         }\n \n-        let global_init_func = context.new_function(None, FunctionType::Exported, context.new_type::<()>(), &[],\n-            &format!(\"__gccGlobalInit{}\", unit_name(&codegen_unit)), false);\n-        let global_init_block = global_init_func.new_block(\"initial\");\n-\n         Self {\n             check_overflow,\n             codegen_unit,\n@@ -192,8 +174,6 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             current_func: RefCell::new(None),\n             normal_function_addresses: Default::default(),\n             functions: RefCell::new(functions),\n-            global_init_func,\n-            global_init_block,\n \n             tls_model,\n \n@@ -221,15 +201,11 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             double_type,\n \n             linkage: Cell::new(FunctionType::Internal),\n-            #[cfg(debug_assertions)]\n-            lvalues: Default::default(),\n             instances: Default::default(),\n+            function_instances: Default::default(),\n             vtables: Default::default(),\n             const_globals: Default::default(),\n-            init_argv_var: RefCell::new(String::new()),\n-            argv_initialized: Cell::new(false),\n             const_cstr_cache: Default::default(),\n-            global_names: Default::default(),\n             globals: Default::default(),\n             scalar_types: Default::default(),\n             types: Default::default(),\n@@ -244,24 +220,13 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         }\n     }\n \n-    pub fn lvalue_to_rvalue(&self, value: LValue<'gcc>) -> RValue<'gcc> {\n-        #[cfg(debug_assertions)]\n-        self.lvalues.borrow_mut().insert(value);\n-        unsafe { std::mem::transmute(value) }\n-    }\n-\n     pub fn rvalue_as_function(&self, value: RValue<'gcc>) -> Function<'gcc> {\n         let function: Function<'gcc> = unsafe { std::mem::transmute(value) };\n         debug_assert!(self.functions.borrow().values().find(|value| **value == function).is_some(),\n             \"{:?} ({:?}) is not a function\", value, value.get_type());\n         function\n     }\n \n-    pub fn rvalue_as_lvalue(&self, value: RValue<'gcc>) -> LValue<'gcc> {\n-        let lvalue: LValue<'gcc> = unsafe { std::mem::transmute(value) };\n-        lvalue\n-    }\n-\n     pub fn sess(&self) -> &Session {\n         &self.tcx.sess\n     }\n@@ -436,6 +401,43 @@ impl<'gcc, 'tcx> LayoutOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n     }\n }\n \n+impl<'gcc, 'tcx> FnAbiOfHelpers<'tcx> for CodegenCx<'gcc, 'tcx> {\n+    type FnAbiOfResult = &'tcx FnAbi<'tcx, Ty<'tcx>>;\n+\n+    #[inline]\n+    fn handle_fn_abi_err(\n+        &self,\n+        err: FnAbiError<'tcx>,\n+        span: Span,\n+        fn_abi_request: FnAbiRequest<'tcx>,\n+    ) -> ! {\n+        if let FnAbiError::Layout(LayoutError::SizeOverflow(_)) = err {\n+            self.sess().span_fatal(span, &err.to_string())\n+        } else {\n+            match fn_abi_request {\n+                FnAbiRequest::OfFnPtr { sig, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_fn_ptr({}, {:?})` failed: {}\",\n+                        sig,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+                FnAbiRequest::OfInstance { instance, extra_args } => {\n+                    span_bug!(\n+                        span,\n+                        \"`fn_abi_of_instance({}, {:?})` failed: {}\",\n+                        instance,\n+                        extra_args,\n+                        err\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx, 'gcc> HasParamEnv<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn param_env(&self) -> ParamEnv<'tcx> {\n         ParamEnv::reveal_all()"}, {"sha": "4d3b4f04badec86dd9149a9421036a3c81e52518", "filename": "compiler/rustc_codegen_gcc/src/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 23, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdebuginfo.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -1,11 +1,9 @@\n-use gccjit::{FunctionType, RValue};\n+use gccjit::RValue;\n use rustc_codegen_ssa::mir::debuginfo::{FunctionDebugContext, VariableKind};\n-use rustc_codegen_ssa::traits::{BuilderMethods, DebugInfoBuilderMethods, DebugInfoMethods};\n-use rustc_middle::middle::cstore::CrateDepKind;\n+use rustc_codegen_ssa::traits::{DebugInfoBuilderMethods, DebugInfoMethods};\n use rustc_middle::mir;\n use rustc_middle::ty::{Instance, Ty};\n use rustc_span::{SourceFile, Span, Symbol};\n-use rustc_span::def_id::LOCAL_CRATE;\n use rustc_target::abi::Size;\n use rustc_target::abi::call::FnAbi;\n \n@@ -20,25 +18,6 @@ impl<'a, 'gcc, 'tcx> DebugInfoBuilderMethods for Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn insert_reference_to_gdb_debug_scripts_section_global(&mut self) {\n-        // TODO(antoyo): replace with gcc_jit_context_new_global_with_initializer() if it's added:\n-        // https://gcc.gnu.org/pipermail/jit/2020q3/001225.html\n-        //\n-        // Call the function to initialize global values here.\n-        // We assume this is only called for the main function.\n-        use std::iter;\n-\n-        for crate_num in self.cx.tcx.crates(()).iter().copied().chain(iter::once(LOCAL_CRATE)) {\n-            // FIXME(antoyo): better way to find if a crate is of proc-macro type?\n-            if crate_num == LOCAL_CRATE || self.cx.tcx.dep_kind(crate_num) != CrateDepKind::MacrosOnly {\n-                // NOTE: proc-macro crates are not included in the executable, so don't call their\n-                // initialization routine.\n-                let initializer_name = format!(\"__gccGlobalCrateInit{}\", self.cx.tcx.crate_name(crate_num));\n-                let codegen_init_func = self.context.new_function(None, FunctionType::Extern, self.context.new_type::<()>(), &[],\n-                initializer_name, false);\n-                self.llbb().add_eval(None, self.context.new_call(None, codegen_init_func, &[]));\n-            }\n-        }\n-\n         // TODO(antoyo): insert reference to gdb debug scripts section global.\n     }\n "}, {"sha": "b43f68f878d7a3207885cbe4eecb9c1e21caeaa7", "filename": "compiler/rustc_codegen_gcc/src/declare.rs", "status": "modified", "additions": 18, "deletions": 67, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fdeclare.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -7,10 +7,9 @@ use rustc_target::abi::call::FnAbi;\n use crate::abi::FnAbiGccExt;\n use crate::context::{CodegenCx, unit_name};\n use crate::intrinsic::llvm;\n-use crate::mangled_std_symbols::{ARGV_INIT_ARRAY, ARGV_INIT_WRAPPER};\n \n impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n-    pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> RValue<'gcc> {\n+    pub fn get_or_insert_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         if self.globals.borrow().contains_key(name) {\n             let typ = self.globals.borrow().get(name).expect(\"global\").get_type();\n             let global = self.context.new_global(None, GlobalKind::Imported, typ, name);\n@@ -20,7 +19,7 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n             if let Some(link_section) = link_section {\n                 global.set_link_section(&link_section.as_str());\n             }\n-            global.get_address(None)\n+            global\n         }\n         else {\n             self.declare_global(name, ty, is_tls, link_section)\n@@ -34,13 +33,10 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         self.context.new_global(None, GlobalKind::Exported, ty, &name)\n     }\n \n-    pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> RValue<'gcc> {\n-        let global = self.context.new_global(None, linkage, ty, name)\n-            .get_address(None);\n-        self.globals.borrow_mut().insert(name.to_string(), global);\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(global, name.to_string());\n+    pub fn declare_global_with_linkage(&self, name: &str, ty: Type<'gcc>, linkage: GlobalKind) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, linkage, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n         global\n     }\n \n@@ -51,31 +47,23 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> RValue<'gcc> {\n-        // FIXME(antoyo): correctly support global variable initialization.\n-        if name.starts_with(ARGV_INIT_ARRAY) {\n-            // NOTE: hack to avoid having to update the names in mangled_std_symbols: we save the\n-            // name of the variable now to actually declare it later.\n-            *self.init_argv_var.borrow_mut() = name.to_string();\n-\n-            let global = self.context.new_global(None, GlobalKind::Imported, ty, name);\n-            if let Some(link_section) = link_section {\n-                global.set_link_section(&link_section.as_str());\n-            }\n-            return global.get_address(None);\n-        }\n+    pub fn declare_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n         let global = self.context.new_global(None, GlobalKind::Exported, ty, name);\n         if is_tls {\n             global.set_tls_model(self.tls_model);\n         }\n         if let Some(link_section) = link_section {\n             global.set_link_section(&link_section.as_str());\n         }\n-        let global = global.get_address(None);\n-        self.globals.borrow_mut().insert(name.to_string(), global);\n-        // NOTE: global seems to only be global in a module. So save the name instead of the value\n-        // to import it later.\n-        self.global_names.borrow_mut().insert(global, name.to_string());\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n+        global\n+    }\n+\n+    pub fn declare_private_global(&self, name: &str, ty: Type<'gcc>) -> LValue<'gcc> {\n+        let global = self.context.new_global(None, GlobalKind::Internal, ty, name);\n+        let global_address = global.get_address(None);\n+        self.globals.borrow_mut().insert(name.to_string(), global_address);\n         global\n     }\n \n@@ -94,51 +82,14 @@ impl<'gcc, 'tcx> CodegenCx<'gcc, 'tcx> {\n     }\n \n     pub fn declare_fn(&self, name: &str, fn_abi: &FnAbi<'tcx, Ty<'tcx>>) -> RValue<'gcc> {\n-        // NOTE: hack to avoid having to update the names in mangled_std_symbols: we found the name\n-        // of the variable earlier, so we declare it now.\n-        // Since we don't correctly support initializers yet, we initialize this variable manually\n-        // for now.\n-        if name.starts_with(ARGV_INIT_WRAPPER) && !self.argv_initialized.get() {\n-            let global_name = &*self.init_argv_var.borrow();\n-            let return_type = self.type_void();\n-            let params = [\n-                self.context.new_parameter(None, self.int_type, \"argc\"),\n-                self.context.new_parameter(None, self.u8_type.make_pointer().make_pointer(), \"argv\"),\n-                self.context.new_parameter(None, self.u8_type.make_pointer().make_pointer(), \"envp\"),\n-            ];\n-            let function = self.context.new_function(None, FunctionType::Extern, return_type, &params, name, false);\n-            let initializer = function.get_address(None);\n-\n-            let param_types = [\n-                self.int_type,\n-                self.u8_type.make_pointer().make_pointer(),\n-                self.u8_type.make_pointer().make_pointer(),\n-            ];\n-            let ty = self.context.new_function_pointer_type(None, return_type, &param_types, false);\n-\n-            let global = self.context.new_global(None, GlobalKind::Exported, ty, global_name);\n-            global.set_link_section(\".init_array.00099\");\n-            global.global_set_initializer_value(initializer);\n-            let global = global.get_address(None);\n-            self.globals.borrow_mut().insert(global_name.to_string(), global);\n-            // NOTE: global seems to only be global in a module. So save the name instead of the value\n-            // to import it later.\n-            self.global_names.borrow_mut().insert(global, global_name.to_string());\n-            self.argv_initialized.set(true);\n-        }\n         let (return_type, params, variadic) = fn_abi.gcc_type(self);\n         let func = declare_raw_fn(self, name, () /*fn_abi.llvm_cconv()*/, return_type, &params, variadic);\n         // FIXME(antoyo): this is a wrong cast. That requires changing the compiler API.\n         unsafe { std::mem::transmute(func) }\n     }\n \n-    pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> Option<RValue<'gcc>> {\n-        Some(self.get_or_insert_global(name, ty, is_tls, link_section))\n-    }\n-\n-    pub fn define_private_global(&self, ty: Type<'gcc>) -> RValue<'gcc> {\n-        let global = self.declare_unnamed_global(ty);\n-        global.get_address(None)\n+    pub fn define_global(&self, name: &str, ty: Type<'gcc>, is_tls: bool, link_section: Option<Symbol>) -> LValue<'gcc> {\n+        self.get_or_insert_global(name, ty, is_tls, link_section)\n     }\n \n     pub fn get_declared_value(&self, name: &str) -> Option<RValue<'gcc>> {"}, {"sha": "45978e1409023ebd08435c0acbc099cc0bd44dd3", "filename": "compiler/rustc_codegen_gcc/src/intrinsic/mod.rs", "status": "modified", "additions": 194, "deletions": 162, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fintrinsic%2Fmod.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -18,7 +18,7 @@ use rustc_target::spec::PanicStrategy;\n \n use crate::abi::GccType;\n use crate::builder::Builder;\n-use crate::common::TypeReflection;\n+use crate::common::{SignType, TypeReflection};\n use crate::context::CodegenCx;\n use crate::type_of::LayoutGccExt;\n use crate::intrinsic::simd::generic_simd_intrinsic;\n@@ -520,163 +520,176 @@ fn int_type_width_signed<'gcc, 'tcx>(ty: Ty<'tcx>, cx: &CodegenCx<'gcc, 'tcx>) -\n \n impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     fn bit_reverse(&mut self, width: u64, value: RValue<'gcc>) -> RValue<'gcc> {\n-        let typ = value.get_type();\n+        let result_type = value.get_type();\n+        let typ = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, typ)\n+            }\n+            else {\n+                value\n+            };\n+\n         let context = &self.cx.context;\n-        match width {\n-            8 => {\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_int(typ, 0xF0));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 4));\n-                let right = self.and(value, context.new_rvalue_from_int(typ, 0x0F));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 4));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_int(typ, 0xCC));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_int(typ, 0x33));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_int(typ, 0xAA));\n-                let left = self.lshr(left, context.new_rvalue_from_int(typ, 1));\n-                let right = self.and(step2, context.new_rvalue_from_int(typ, 0x55));\n-                let right = self.shl(right, context.new_rvalue_from_int(typ, 1));\n-                let step3 = self.or(left, right);\n-\n-                step3\n-            },\n-            16 => {\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_int(typ, 0x5555));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 1));\n-                let right = self.and(value, context.new_rvalue_from_int(typ, 0xAAAA));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 1));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_int(typ, 0x3333));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_int(typ, 0xCCCC));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_int(typ, 0x0F0F));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 4));\n-                let right = self.and(step2, context.new_rvalue_from_int(typ, 0xF0F0));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 4));\n-                let step3 = self.or(left, right);\n-\n-                // Fourth step.\n-                let left = self.and(step3, context.new_rvalue_from_int(typ, 0x00FF));\n-                let left = self.shl(left, context.new_rvalue_from_int(typ, 8));\n-                let right = self.and(step3, context.new_rvalue_from_int(typ, 0xFF00));\n-                let right = self.lshr(right, context.new_rvalue_from_int(typ, 8));\n-                let step4 = self.or(left, right);\n-\n-                step4\n-            },\n-            32 => {\n-                // TODO(antoyo): Refactor with other implementations.\n-                // First step.\n-                let left = self.and(value, context.new_rvalue_from_long(typ, 0x55555555));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 1));\n-                let right = self.and(value, context.new_rvalue_from_long(typ, 0xAAAAAAAA));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 1));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_long(typ, 0x33333333));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 2));\n-                let right = self.and(step1, context.new_rvalue_from_long(typ, 0xCCCCCCCC));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 2));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.and(step2, context.new_rvalue_from_long(typ, 0x0F0F0F0F));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 4));\n-                let right = self.and(step2, context.new_rvalue_from_long(typ, 0xF0F0F0F0));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 4));\n-                let step3 = self.or(left, right);\n-\n-                // Fourth step.\n-                let left = self.and(step3, context.new_rvalue_from_long(typ, 0x00FF00FF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 8));\n-                let right = self.and(step3, context.new_rvalue_from_long(typ, 0xFF00FF00));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 8));\n-                let step4 = self.or(left, right);\n-\n-                // Fifth step.\n-                let left = self.and(step4, context.new_rvalue_from_long(typ, 0x0000FFFF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 16));\n-                let right = self.and(step4, context.new_rvalue_from_long(typ, 0xFFFF0000));\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 16));\n-                let step5 = self.or(left, right);\n-\n-                step5\n-            },\n-            64 => {\n-                // First step.\n-                let left = self.shl(value, context.new_rvalue_from_long(typ, 32));\n-                let right = self.lshr(value, context.new_rvalue_from_long(typ, 32));\n-                let step1 = self.or(left, right);\n-\n-                // Second step.\n-                let left = self.and(step1, context.new_rvalue_from_long(typ, 0x0001FFFF0001FFFF));\n-                let left = self.shl(left, context.new_rvalue_from_long(typ, 15));\n-                let right = self.and(step1, context.new_rvalue_from_long(typ, 0xFFFE0000FFFE0000u64 as i64)); // TODO(antoyo): transmute the number instead?\n-                let right = self.lshr(right, context.new_rvalue_from_long(typ, 17));\n-                let step2 = self.or(left, right);\n-\n-                // Third step.\n-                let left = self.lshr(step2, context.new_rvalue_from_long(typ, 10));\n-                let left = self.xor(step2, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x003F801F003F801F));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 10));\n-                let left = self.or(temp, left);\n-                let step3 = self.xor(left, step2);\n-\n-                // Fourth step.\n-                let left = self.lshr(step3, context.new_rvalue_from_long(typ, 4));\n-                let left = self.xor(step3, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x0E0384210E038421));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 4));\n-                let left = self.or(temp, left);\n-                let step4 = self.xor(left, step3);\n-\n-                // Fifth step.\n-                let left = self.lshr(step4, context.new_rvalue_from_long(typ, 2));\n-                let left = self.xor(step4, left);\n-                let temp = self.and(left, context.new_rvalue_from_long(typ, 0x2248884222488842));\n-\n-                let left = self.shl(temp, context.new_rvalue_from_long(typ, 2));\n-                let left = self.or(temp, left);\n-                let step5 = self.xor(left, step4);\n-\n-                step5\n-            },\n-            128 => {\n-                // TODO(antoyo): find a more efficient implementation?\n-                let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n-                let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n-                let low = self.context.new_cast(None, value, self.u64_type);\n+        let result =\n+            match width {\n+                8 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0xF0));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0x0F));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 4));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0xCC));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0x33));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0xAA));\n+                    let left = self.lshr(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0x55));\n+                    let right = self.shl(right, context.new_rvalue_from_int(typ, 1));\n+                    let step3 = self.or(left, right);\n+\n+                    step3\n+                },\n+                16 => {\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_int(typ, 0x5555));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_int(typ, 0xAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_int(typ, 0x3333));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_int(typ, 0xCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_int(typ, 0x0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_int(typ, 0xF0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_int(typ, 0x00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_int(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_int(typ, 0xFF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_int(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    step4\n+                },\n+                32 => {\n+                    // TODO(antoyo): Refactor with other implementations.\n+                    // First step.\n+                    let left = self.and(value, context.new_rvalue_from_long(typ, 0x55555555));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 1));\n+                    let right = self.and(value, context.new_rvalue_from_long(typ, 0xAAAAAAAA));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 1));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x33333333));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 2));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xCCCCCCCC));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 2));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.and(step2, context.new_rvalue_from_long(typ, 0x0F0F0F0F));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 4));\n+                    let right = self.and(step2, context.new_rvalue_from_long(typ, 0xF0F0F0F0));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 4));\n+                    let step3 = self.or(left, right);\n+\n+                    // Fourth step.\n+                    let left = self.and(step3, context.new_rvalue_from_long(typ, 0x00FF00FF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 8));\n+                    let right = self.and(step3, context.new_rvalue_from_long(typ, 0xFF00FF00));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 8));\n+                    let step4 = self.or(left, right);\n+\n+                    // Fifth step.\n+                    let left = self.and(step4, context.new_rvalue_from_long(typ, 0x0000FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 16));\n+                    let right = self.and(step4, context.new_rvalue_from_long(typ, 0xFFFF0000));\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 16));\n+                    let step5 = self.or(left, right);\n+\n+                    step5\n+                },\n+                64 => {\n+                    // First step.\n+                    let left = self.shl(value, context.new_rvalue_from_long(typ, 32));\n+                    let right = self.lshr(value, context.new_rvalue_from_long(typ, 32));\n+                    let step1 = self.or(left, right);\n+\n+                    // Second step.\n+                    let left = self.and(step1, context.new_rvalue_from_long(typ, 0x0001FFFF0001FFFF));\n+                    let left = self.shl(left, context.new_rvalue_from_long(typ, 15));\n+                    let right = self.and(step1, context.new_rvalue_from_long(typ, 0xFFFE0000FFFE0000u64 as i64)); // TODO(antoyo): transmute the number instead?\n+                    let right = self.lshr(right, context.new_rvalue_from_long(typ, 17));\n+                    let step2 = self.or(left, right);\n+\n+                    // Third step.\n+                    let left = self.lshr(step2, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.xor(step2, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x003F801F003F801F));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 10));\n+                    let left = self.or(temp, left);\n+                    let step3 = self.xor(left, step2);\n+\n+                    // Fourth step.\n+                    let left = self.lshr(step3, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.xor(step3, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x0E0384210E038421));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 4));\n+                    let left = self.or(temp, left);\n+                    let step4 = self.xor(left, step3);\n+\n+                    // Fifth step.\n+                    let left = self.lshr(step4, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.xor(step4, left);\n+                    let temp = self.and(left, context.new_rvalue_from_long(typ, 0x2248884222488842));\n+\n+                    let left = self.shl(temp, context.new_rvalue_from_long(typ, 2));\n+                    let left = self.or(temp, left);\n+                    let step5 = self.xor(left, step4);\n+\n+                    step5\n+                },\n+                128 => {\n+                    // TODO(antoyo): find a more efficient implementation?\n+                    let sixty_four = self.context.new_rvalue_from_long(typ, 64);\n+                    let high = self.context.new_cast(None, value >> sixty_four, self.u64_type);\n+                    let low = self.context.new_cast(None, value, self.u64_type);\n \n-                let reversed_high = self.bit_reverse(64, high);\n-                let reversed_low = self.bit_reverse(64, low);\n+                    let reversed_high = self.bit_reverse(64, high);\n+                    let reversed_low = self.bit_reverse(64, low);\n \n-                let new_low = self.context.new_cast(None, reversed_high, typ);\n-                let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n+                    let new_low = self.context.new_cast(None, reversed_high, typ);\n+                    let new_high = self.context.new_cast(None, reversed_low, typ) << sixty_four;\n \n-                new_low | new_high\n-            },\n-            _ => {\n-                panic!(\"cannot bit reverse with width = {}\", width);\n-            },\n-        }\n+                    new_low | new_high\n+                },\n+                _ => {\n+                    panic!(\"cannot bit reverse with width = {}\", width);\n+                },\n+            };\n+\n+        self.context.new_bitcast(None, result, result_type)\n     }\n \n     fn count_leading_zeroes(&self, width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n@@ -746,6 +759,15 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n     }\n \n     fn count_trailing_zeroes(&self, _width: u64, arg: RValue<'gcc>) -> RValue<'gcc> {\n+        let result_type = arg.get_type();\n+        let arg =\n+            if result_type.is_signed(self.cx) {\n+                let new_type = result_type.to_unsigned(self.cx);\n+                self.context.new_bitcast(None, arg, new_type)\n+            }\n+            else {\n+                arg\n+            };\n         let arg_type = arg.get_type();\n         let (count_trailing_zeroes, expected_type) =\n             if arg_type.is_uchar(&self.cx) || arg_type.is_ushort(&self.cx) || arg_type.is_uint(&self.cx) {\n@@ -796,7 +818,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n                 let res = self.context.new_array_access(None, result, index);\n \n-                return self.context.new_cast(None, res, arg_type);\n+                return self.context.new_bitcast(None, res, result_type);\n             }\n             else {\n                 unimplemented!(\"count_trailing_zeroes for {:?}\", arg_type);\n@@ -810,7 +832,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n                 arg\n             };\n         let res = self.context.new_call(None, count_trailing_zeroes, &[arg]);\n-        self.context.new_cast(None, res, arg_type)\n+        self.context.new_bitcast(None, res, result_type)\n     }\n \n     fn int_width(&self, typ: Type<'gcc>) -> i64 {\n@@ -819,7 +841,16 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n \n     fn pop_count(&self, value: RValue<'gcc>) -> RValue<'gcc> {\n         // TODO(antoyo): use the optimized version with fewer operations.\n-        let value_type = value.get_type();\n+        let result_type = value.get_type();\n+        let value_type = result_type.to_unsigned(self.cx);\n+\n+        let value =\n+            if result_type.is_signed(self.cx) {\n+                self.context.new_bitcast(None, value, value_type)\n+            }\n+            else {\n+                value\n+            };\n \n         if value_type.is_u128(&self.cx) {\n             // TODO(antoyo): implement in the normal algorithm below to have a more efficient\n@@ -830,7 +861,8 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n             let high = self.context.new_call(None, popcount, &[high]);\n             let low = self.context.new_cast(None, value, self.cx.ulonglong_type);\n             let low = self.context.new_call(None, popcount, &[low]);\n-            return high + low;\n+            let res = high + low;\n+            return self.context.new_bitcast(None, res, result_type);\n         }\n \n         // First step.\n@@ -855,7 +887,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u8(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Fourth step.\n@@ -866,7 +898,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u16(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Fifth step.\n@@ -877,7 +909,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let value = left + right;\n \n         if value_type.is_u32(&self.cx) {\n-            return value;\n+            return self.context.new_bitcast(None, value, result_type);\n         }\n \n         // Sixth step.\n@@ -887,7 +919,7 @@ impl<'a, 'gcc, 'tcx> Builder<'a, 'gcc, 'tcx> {\n         let right = shifted & mask;\n         let value = left + right;\n \n-        value\n+        self.context.new_bitcast(None, value, result_type)\n     }\n \n     // Algorithm from: https://blog.regehr.org/archives/1063"}, {"sha": "f3c02e2634ff61cca5f02d6df67d79df7eec3b35", "filename": "compiler/rustc_codegen_gcc/src/lib.rs", "status": "modified", "additions": 4, "deletions": 23, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Flib.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -43,15 +43,14 @@ mod coverageinfo;\n mod debuginfo;\n mod declare;\n mod intrinsic;\n-mod mangled_std_symbols;\n mod mono_item;\n mod type_;\n mod type_of;\n \n use std::any::Any;\n use std::sync::Arc;\n \n-use gccjit::{Block, Context, FunctionType, OptimizationLevel};\n+use gccjit::{Context, OptimizationLevel};\n use rustc_ast::expand::allocator::AllocatorKind;\n use rustc_codegen_ssa::{CodegenResults, CompiledModule, ModuleCodegen};\n use rustc_codegen_ssa::base::codegen_crate;\n@@ -64,13 +63,11 @@ use rustc_errors::{ErrorReported, Handler};\n use rustc_middle::dep_graph::{WorkProduct, WorkProductId};\n use rustc_middle::middle::cstore::EncodedMetadata;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::config::{CrateType, Lto, OptLevel, OutputFilenames};\n+use rustc_session::config::{Lto, OptLevel, OutputFilenames};\n use rustc_session::Session;\n use rustc_span::Symbol;\n use rustc_span::fatal_error::FatalError;\n \n-use crate::context::unit_name;\n-\n pub struct PrintOnPanic<F: Fn() -> String>(pub F);\n \n impl<F: Fn() -> String> Drop for PrintOnPanic<F> {\n@@ -109,16 +106,8 @@ impl CodegenBackend for GccCodegenBackend {\n         Ok((codegen_results, work_products))\n     }\n \n-    fn link(&self, sess: &Session, mut codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorReported> {\n+    fn link(&self, sess: &Session, codegen_results: CodegenResults, outputs: &OutputFilenames) -> Result<(), ErrorReported> {\n         use rustc_codegen_ssa::back::link::link_binary;\n-        if let Some(symbols) = codegen_results.crate_info.exported_symbols.get_mut(&CrateType::Dylib) {\n-            // TODO:(antoyo): remove when global initializer work without calling a function at runtime.\n-            // HACK: since this codegen add some symbols (e.g. __gccGlobalCrateInit) and the UI\n-            // tests load libstd.so as a dynamic library, and rustc use a version-script to specify\n-            // the symbols visibility, we add * to export all symbols.\n-            // It seems other symbols from libstd/libcore are causing some issues here as well.\n-            symbols.push(\"*\".to_string());\n-        }\n \n         link_binary::<crate::archive::ArArchiveBuilder<'_>>(\n             sess,\n@@ -203,6 +192,7 @@ impl WriteBackendMethods for GccCodegenBackend {\n     fn run_fat_lto(_cgcx: &CodegenContext<Self>, mut modules: Vec<FatLTOInput<Self>>, _cached_modules: Vec<(SerializedModule<Self::ModuleBuffer>, WorkProduct)>) -> Result<LtoModuleCodegen<Self>, FatalError> {\n         // TODO(antoyo): implement LTO by sending -flto to libgccjit and adding the appropriate gcc linker plugins.\n         // NOTE: implemented elsewhere.\n+        // TODO: what is implemented elsewhere ^ ?\n         let module =\n             match modules.remove(0) {\n                 FatLTOInput::InMemory(module) => module,\n@@ -273,15 +263,6 @@ fn to_gcc_opt_level(optlevel: Option<OptLevel>) -> OptimizationLevel {\n     }\n }\n \n-fn create_function_calling_initializers<'gcc, 'tcx>(tcx: TyCtxt<'tcx>, context: &Context<'gcc>, block: Block<'gcc>) {\n-    let codegen_units = tcx.collect_and_partition_mono_items(()).1;\n-    for codegen_unit in codegen_units {\n-        let codegen_init_func = context.new_function(None, FunctionType::Extern, context.new_type::<()>(), &[],\n-            &format!(\"__gccGlobalInit{}\", unit_name(&codegen_unit)), false);\n-        block.add_eval(None, context.new_call(None, codegen_init_func, &[]));\n-    }\n-}\n-\n fn handle_native(name: &str) -> &str {\n     if name != \"native\" {\n         return name;"}, {"sha": "b0c3f214d66c15510342df74221e469054ddb619", "filename": "compiler/rustc_codegen_gcc/src/mangled_std_symbols.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmangled_std_symbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df487317d08eb1bf194e87aa7c193bb738ed7546/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmangled_std_symbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmangled_std_symbols.rs?ref=df487317d08eb1bf194e87aa7c193bb738ed7546", "patch": "@@ -1,4 +0,0 @@\n-pub const ARGV_INIT_ARRAY: &str = \"_ZN3std3sys4unix4args3imp15ARGV_INIT_ARRAY\";\n-pub const ARGV_INIT_WRAPPER: &str = \"_ZN3std3sys4unix4args3imp15ARGV_INIT_ARRAY12init_wrapper\";\n-pub const ARGC: &str = \"_ZN3std3sys4unix4args3imp4ARGC\";\n-pub const ARGV: &str = \"_ZN3std3sys4unix4args3imp4ARGV\";"}, {"sha": "e21d40b6c37e37f67bf4644b78aefcd7c13fe2cd", "filename": "compiler/rustc_codegen_gcc/src/mono_item.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Fmono_item.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -2,9 +2,8 @@ use rustc_codegen_ssa::traits::PreDefineMethods;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::mono::{Linkage, Visibility};\n use rustc_middle::ty::{self, Instance, TypeFoldable};\n-use rustc_middle::ty::layout::{FnAbiExt, LayoutOf};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf};\n use rustc_span::def_id::DefId;\n-use rustc_target::abi::call::FnAbi;\n \n use crate::base;\n use crate::context::CodegenCx;\n@@ -18,12 +17,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n         let gcc_type = self.layout_of(ty).gcc_type(self, true);\n \n         let is_tls = attrs.flags.contains(CodegenFnAttrFlags::THREAD_LOCAL);\n-        let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section).unwrap_or_else(|| {\n-            self.sess().span_fatal(\n-                self.tcx.def_span(def_id),\n-                &format!(\"symbol `{}` is already defined\", symbol_name),\n-            )\n-        });\n+        let global = self.define_global(symbol_name, gcc_type, is_tls, attrs.link_section);\n \n         // TODO(antoyo): set linkage and visibility.\n         self.instances.borrow_mut().insert(instance, global);\n@@ -32,7 +26,7 @@ impl<'gcc, 'tcx> PreDefineMethods<'tcx> for CodegenCx<'gcc, 'tcx> {\n     fn predefine_fn(&self, instance: Instance<'tcx>, linkage: Linkage, _visibility: Visibility, symbol_name: &str) {\n         assert!(!instance.substs.needs_infer());\n \n-        let fn_abi = FnAbi::of_instance(self, instance, &[]);\n+        let fn_abi = self.fn_abi_of_instance(instance, ty::List::empty());\n         self.linkage.set(base::linkage_to_gcc(linkage));\n         let _decl = self.declare_fn(symbol_name, &fn_abi);\n         //let attrs = self.tcx.codegen_fn_attrs(instance.def_id());"}, {"sha": "9c39c8f91a1ff54ece1fdccfd27b92adef4602eb", "filename": "compiler/rustc_codegen_gcc/src/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fsrc%2Ftype_of.rs?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -4,7 +4,7 @@ use gccjit::{Struct, Type};\n use crate::rustc_codegen_ssa::traits::{BaseTypeMethods, DerivedTypeMethods, LayoutTypeMethods};\n use rustc_middle::bug;\n use rustc_middle::ty::{self, Ty, TypeFoldable};\n-use rustc_middle::ty::layout::{FnAbiExt, LayoutOf, TyAndLayout};\n+use rustc_middle::ty::layout::{FnAbiOf, LayoutOf, TyAndLayout};\n use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_target::abi::{self, Abi, F32, F64, FieldsShape, Int, Integer, Pointer, PointeeInfo, Size, TyAbiInterface, Variants};\n use rustc_target::abi::call::{CastTarget, FnAbi, Reg};\n@@ -160,7 +160,7 @@ impl<'tcx> LayoutGccExt<'tcx> for TyAndLayout<'tcx> {\n                     ty::Adt(def, _) if def.is_box() => {\n                         cx.type_ptr_to(cx.layout_of(self.ty.boxed_ty()).gcc_type(cx, true))\n                     }\n-                    ty::FnPtr(sig) => cx.fn_ptr_backend_type(&FnAbi::of_fn_ptr(cx, sig, &[])),\n+                    ty::FnPtr(sig) => cx.fn_ptr_backend_type(&cx.fn_abi_of_fn_ptr(sig, ty::List::empty())),\n                     _ => self.scalar_gcc_type_at(cx, scalar, Size::ZERO),\n                 };\n             cx.scalar_types.borrow_mut().insert(self.ty, ty);"}, {"sha": "944d0ce516e0f553b4e2f1a10471a85212eae9f3", "filename": "compiler/rustc_codegen_gcc/test.sh", "status": "modified", "additions": 110, "deletions": 70, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Ftest.sh", "raw_url": "https://github.com/rust-lang/rust/raw/7f32dd546f23f122a6c5e87db50e404261b75722/compiler%2Frustc_codegen_gcc%2Ftest.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Ftest.sh?ref=7f32dd546f23f122a6c5e87db50e404261b75722", "patch": "@@ -17,6 +17,7 @@ export LIBRARY_PATH=\"$GCC_PATH\"\n if [[ \"$1\" == \"--release\" ]]; then\n     export CHANNEL='release'\n     CARGO_INCREMENTAL=1 cargo rustc --release\n+    shift\n else\n     echo $LD_LIBRARY_PATH\n     export CHANNEL='debug'\n@@ -25,52 +26,60 @@ fi\n \n source config.sh\n \n-rm -r target/out || true\n-mkdir -p target/out/gccjit\n+function clean() {\n+    rm -r target/out || true\n+    mkdir -p target/out/gccjit\n+}\n \n-echo \"[BUILD] mini_core\"\n-$RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target $TARGET_TRIPLE\n+function mini_tests() {\n+    echo \"[BUILD] mini_core\"\n+    $RUSTC example/mini_core.rs --crate-name mini_core --crate-type lib,dylib --target $TARGET_TRIPLE\n \n-echo \"[BUILD] example\"\n-$RUSTC example/example.rs --crate-type lib --target $TARGET_TRIPLE\n+    echo \"[BUILD] example\"\n+    $RUSTC example/example.rs --crate-type lib --target $TARGET_TRIPLE\n \n-echo \"[AOT] mini_core_hello_world\"\n-$RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n+    echo \"[AOT] mini_core_hello_world\"\n+    $RUSTC example/mini_core_hello_world.rs --crate-name mini_core_hello_world --crate-type bin -g --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/mini_core_hello_world abc bcd\n+}\n \n-echo \"[BUILD] sysroot\"\n-time ./build_sysroot/build_sysroot.sh\n+function build_sysroot() {\n+    echo \"[BUILD] sysroot\"\n+    time ./build_sysroot/build_sysroot.sh\n+}\n \n-echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n-$RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n+function std_tests() {\n+    echo \"[AOT] arbitrary_self_types_pointers_and_wrappers\"\n+    $RUSTC example/arbitrary_self_types_pointers_and_wrappers.rs --crate-name arbitrary_self_types_pointers_and_wrappers --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/arbitrary_self_types_pointers_and_wrappers\n \n-echo \"[AOT] alloc_system\"\n-$RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n+    echo \"[AOT] alloc_system\"\n+    $RUSTC example/alloc_system.rs --crate-type lib --target \"$TARGET_TRIPLE\"\n \n-echo \"[AOT] alloc_example\"\n-$RUSTC example/alloc_example.rs --crate-type bin --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/alloc_example\n+    echo \"[AOT] alloc_example\"\n+    $RUSTC example/alloc_example.rs --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/alloc_example\n \n-echo \"[AOT] dst_field_align\"\n-# FIXME(antoyo): Re-add -Zmir-opt-level=2 once rust-lang/rust#67529 is fixed.\n-$RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/dst_field_align || (echo $?; false)\n+    echo \"[AOT] dst_field_align\"\n+    # FIXME(antoyo): Re-add -Zmir-opt-level=2 once rust-lang/rust#67529 is fixed.\n+    $RUSTC example/dst-field-align.rs --crate-name dst_field_align --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/dst_field_align || (echo $?; false)\n \n-echo \"[AOT] std_example\"\n-$RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n+    echo \"[AOT] std_example\"\n+    $RUSTC example/std_example.rs --crate-type bin --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/std_example --target $TARGET_TRIPLE\n \n-echo \"[AOT] subslice-patterns-const-eval\"\n-$RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n+    echo \"[AOT] subslice-patterns-const-eval\"\n+    $RUSTC example/subslice-patterns-const-eval.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/subslice-patterns-const-eval\n \n-echo \"[AOT] track-caller-attribute\"\n-$RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n-$RUN_WRAPPER ./target/out/track-caller-attribute\n+    echo \"[AOT] track-caller-attribute\"\n+    $RUSTC example/track-caller-attribute.rs --crate-type bin -Cpanic=abort --target $TARGET_TRIPLE\n+    $RUN_WRAPPER ./target/out/track-caller-attribute\n \n-echo \"[BUILD] mod_bench\"\n-$RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n+    echo \"[BUILD] mod_bench\"\n+    $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n+}\n \n # FIXME(antoyo): linker gives multiple definitions error on Linux\n #echo \"[BUILD] sysroot in release mode\"\n@@ -95,11 +104,13 @@ $RUSTC example/mod_bench.rs --crate-type bin --target $TARGET_TRIPLE\n #fi\n #popd\n \n-pushd build_sysroot/sysroot_src/library/core/tests\n-echo \"[TEST] libcore\"\n-rm -r ./target || true\n-../../../../../cargo.sh test\n-popd\n+function test_libcore() {\n+    pushd build_sysroot/sysroot_src/library/core/tests\n+    echo \"[TEST] libcore\"\n+    rm -r ./target || true\n+    ../../../../../cargo.sh test\n+    popd\n+}\n \n # TODO(antoyo): uncomment when it works.\n #pushd regex\n@@ -130,20 +141,21 @@ popd\n #echo \"[BENCH RUN] mod_bench\"\n #hyperfine --runs ${RUN_RUNS:-10} ./target/out/mod_bench{,_inline} ./target/out/mod_bench_llvm_*\n \n-echo\n-echo \"[TEST] rust-lang/rust\"\n+function test_rustc() {\n+    echo\n+    echo \"[TEST] rust-lang/rust\"\n \n-rust_toolchain=$(cat rust-toolchain)\n+    rust_toolchain=$(cat rust-toolchain)\n \n-git clone https://github.com/rust-lang/rust.git || true\n-cd rust\n-git fetch\n-git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n-export RUSTFLAGS=\n+    git clone https://github.com/rust-lang/rust.git || true\n+    cd rust\n+    git fetch\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(')\n+    export RUSTFLAGS=\n \n-rm config.toml || true\n+    rm config.toml || true\n \n-cat > config.toml <<EOF\n+    cat > config.toml <<EOF\n [rust]\n codegen-backends = []\n deny-warnings = false\n@@ -154,24 +166,52 @@ local-rebuild = true\n rustc = \"$HOME/.rustup/toolchains/$rust_toolchain-$TARGET_TRIPLE/bin/rustc\"\n EOF\n \n-rustc -V | cut -d' ' -f3 | tr -d '('\n-git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') src/test\n-\n-for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n-  rm $test\n-done\n-\n-git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n-\n-rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n-for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n-  rm $test\n-done\n-git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n-git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n-rm src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs || true # TODO(antoyo): Enable back this test if I ever implement the llvm_asm! macro.\n-\n-RUSTC_ARGS=\"-Zpanic-abort-tests -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n-\n-echo \"[TEST] rustc test suite\"\n-COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n+    rustc -V | cut -d' ' -f3 | tr -d '('\n+    git checkout $(rustc -V | cut -d' ' -f3 | tr -d '(') src/test\n+\n+    for test in $(rg -i --files-with-matches \"//(\\[\\w+\\])?~|// error-pattern:|// build-fail|// run-fail|-Cllvm-args\" src/test/ui); do\n+      rm $test\n+    done\n+\n+    git checkout -- src/test/ui/issues/auxiliary/issue-3136-a.rs # contains //~ERROR, but shouldn't be removed\n+\n+    rm -r src/test/ui/{abi*,extern/,llvm-asm/,panic-runtime/,panics/,unsized-locals/,proc-macro/,threads-sendsync/,thinlto/,simd*,borrowck/,test*,*lto*.rs} || true\n+    for test in $(rg --files-with-matches \"catch_unwind|should_panic|thread|lto\" src/test/ui); do\n+      rm $test\n+    done\n+    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice.rs\n+    git checkout src/test/ui/type-alias-impl-trait/auxiliary/cross_crate_ice2.rs\n+    rm src/test/ui/llvm-asm/llvm-asm-in-out-operand.rs || true # TODO(antoyo): Enable back this test if I ever implement the llvm_asm! macro.\n+\n+    RUSTC_ARGS=\"-Zpanic-abort-tests -Zsymbol-mangling-version=v0 -Zcodegen-backend=\"$(pwd)\"/../target/\"$CHANNEL\"/librustc_codegen_gcc.\"$dylib_ext\" --sysroot \"$(pwd)\"/../build_sysroot/sysroot -Cpanic=abort\"\n+\n+    echo \"[TEST] rustc test suite\"\n+    COMPILETEST_FORCE_STAGE0=1 ./x.py test --run always --stage 0 src/test/ui/ --rustc-args \"$RUSTC_ARGS\"\n+}\n+\n+function clean_ui_tests() {\n+    find rust/build/x86_64-unknown-linux-gnu/test/ui/ -name stamp -exec rm -rf {} \\;\n+}\n+\n+case $1 in\n+    \"--test-rustc\")\n+        test_rustc\n+        ;;\n+\n+    \"--test-libcore\")\n+        test_libcore\n+        ;;\n+\n+    \"--clean-ui-tests\")\n+        clean_ui_tests\n+        ;;\n+\n+    *)\n+        clean\n+        mini_tests\n+        build_sysroot\n+        std_tests\n+        test_libcore\n+        test_rustc\n+        ;;\n+esac"}]}