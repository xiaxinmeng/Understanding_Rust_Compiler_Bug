{"sha": "644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY0NGI2MGFkODVjMTgwMjNjNWI2ZjA5ZmE2MGI5Y2Y1NzJkMjhlN2Y=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-12-11T03:41:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-12-11T03:41:15Z"}, "message": "Merge pull request #2257 from topecongiro/error-on-line-overflow-strings\n\nAdd error_on_line_overflow_strings config option", "tree": {"sha": "1e8c91e664851620d929c2d8710d4bda0406ddfb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1e8c91e664851620d929c2d8710d4bda0406ddfb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaLf5bCRBK7hj4Ov3rIwAAdHIIAIhcHXfDV9vZiDMQ3or7AsOb\nlN6YCTXcdsyfGM5cAN8N7xTosopkyBQwkaqHK/kYw7u+kea9A8BEHgevu8E/+YDj\nhsW+j5JOq6HnVGN/pEJFRXIRvSfZezgP+PlTibO1NXgdIGHlN7Wd+YX+BeI50R6r\nb6xX+PXsPKc3Y7SmePXupPGAx0AkEOPtZ0t3188evRwQpC/o531pFqQ9xr9cHqsg\n46jcBPveKYc1IFN8P8vpfvrBtFps61TR2HLTQXzTSu2Cw6liYToI+ax8CId0g7Lj\n7nja47mYU4MnoIqE0djGU7DYB34n3PSAgzihHO6rstu8x371FA6woYQ3wnuBQPw=\n=me5T\n-----END PGP SIGNATURE-----\n", "payload": "tree 1e8c91e664851620d929c2d8710d4bda0406ddfb\nparent 3c08da3433fe63595e4d46b95f0b1483c1c2650d\nparent 3dd31e25bf3285a52dc02cd5ea0c3b344910f52b\nauthor Nick Cameron <nrc@ncameron.org> 1512963675 +1300\ncommitter GitHub <noreply@github.com> 1512963675 +1300\n\nMerge pull request #2257 from topecongiro/error-on-line-overflow-strings\n\nAdd error_on_line_overflow_strings config option"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "html_url": "https://github.com/rust-lang/rust/commit/644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c08da3433fe63595e4d46b95f0b1483c1c2650d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c08da3433fe63595e4d46b95f0b1483c1c2650d", "html_url": "https://github.com/rust-lang/rust/commit/3c08da3433fe63595e4d46b95f0b1483c1c2650d"}, {"sha": "3dd31e25bf3285a52dc02cd5ea0c3b344910f52b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dd31e25bf3285a52dc02cd5ea0c3b344910f52b", "html_url": "https://github.com/rust-lang/rust/commit/3dd31e25bf3285a52dc02cd5ea0c3b344910f52b"}], "stats": {"total": 189, "additions": 117, "deletions": 72}, "files": [{"sha": "aebd19d8e4bc04fa1eed745c6fa78a171bc15f52", "filename": "src/bin/rustfmt.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fbin%2Frustfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fbin%2Frustfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Frustfmt.rs?ref=644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "patch": "@@ -20,7 +20,7 @@ use std::io::{self, Read, Write};\n use std::path::{Path, PathBuf};\n use std::str::FromStr;\n \n-use getopts::{HasArg, Matches, Occur, Options};\n+use getopts::{Matches, Options};\n \n use rustfmt::{run, Input, Summary};\n use rustfmt::file_lines::FileLines;\n@@ -63,6 +63,7 @@ struct CliOptions {\n     color: Option<Color>,\n     file_lines: FileLines, // Default is all lines in all files.\n     unstable_features: bool,\n+    error_on_unformatted: bool,\n }\n \n impl CliOptions {\n@@ -104,6 +105,10 @@ impl CliOptions {\n             options.file_lines = file_lines.parse()?;\n         }\n \n+        if matches.opt_present(\"error-on-unformatted\") {\n+            options.error_on_unformatted = true;\n+        }\n+\n         Ok(options)\n     }\n \n@@ -112,6 +117,7 @@ impl CliOptions {\n         config.set().verbose(self.verbose);\n         config.set().file_lines(self.file_lines);\n         config.set().unstable_features(self.unstable_features);\n+        config.set().error_on_unformatted(self.error_on_unformatted);\n         if let Some(write_mode) = self.write_mode {\n             config.set().write_mode(write_mode);\n         }\n@@ -135,61 +141,65 @@ fn match_cli_path_or_file(\n \n fn make_opts() -> Options {\n     let mut opts = Options::new();\n-    opts.optflag(\"h\", \"help\", \"show this message\");\n-    opts.optflag(\"V\", \"version\", \"show version information\");\n-    opts.optflag(\"v\", \"verbose\", \"print verbose output\");\n-    opts.optopt(\n-        \"\",\n-        \"write-mode\",\n-        \"how to write output (not usable when piping from stdin)\",\n-        \"[replace|overwrite|display|plain|diff|coverage|checkstyle]\",\n-    );\n+\n+    // Sorted in alphabetical order.\n     opts.optopt(\n         \"\",\n         \"color\",\n-        \"use colored output (if supported)\",\n+        \"Use colored output (if supported)\",\n         \"[always|never|auto]\",\n     );\n-    opts.optflag(\"\", \"skip-children\", \"don't reformat child modules\");\n-\n     opts.optflag(\n         \"\",\n-        \"unstable-features\",\n-        \"Enables unstable features. Only available on nightly channel\",\n+        \"config-help\",\n+        \"Show details of rustfmt configuration options\",\n     );\n-\n-    opts.optflag(\n+    opts.optopt(\n         \"\",\n-        \"config-help\",\n-        \"show details of rustfmt configuration options\",\n+        \"config-path\",\n+        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+         found reverts to the input file path\",\n+        \"[Path for the configuration file]\",\n     );\n-    opts.opt(\n+    opts.optopt(\n         \"\",\n         \"dump-default-config\",\n         \"Dumps default configuration to PATH. PATH defaults to stdout, if omitted.\",\n         \"PATH\",\n-        HasArg::Maybe,\n-        Occur::Optional,\n     );\n     opts.optopt(\n         \"\",\n         \"dump-minimal-config\",\n         \"Dumps configuration options that were checked during formatting to a file.\",\n         \"PATH\",\n     );\n-    opts.optopt(\n+    opts.optflag(\n         \"\",\n-        \"config-path\",\n-        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n-         found reverts to the input file path\",\n-        \"[Path for the configuration file]\",\n+        \"error-on-unformatted\",\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\",\n     );\n     opts.optopt(\n         \"\",\n         \"file-lines\",\n         \"Format specified line ranges. See README for more detail on the JSON format.\",\n         \"JSON\",\n     );\n+    opts.optflag(\"h\", \"help\", \"Show this message\");\n+    opts.optflag(\"\", \"skip-children\", \"Don't reformat child modules\");\n+    opts.optflag(\n+        \"\",\n+        \"unstable-features\",\n+        \"Enables unstable features. Only available on nightly channel\",\n+    );\n+    opts.optflag(\"v\", \"verbose\", \"Print verbose output\");\n+    opts.optflag(\"V\", \"version\", \"Show version information\");\n+    opts.optopt(\n+        \"\",\n+        \"write-mode\",\n+        \"How to write output (not usable when piping from stdin)\",\n+        \"[replace|overwrite|display|plain|diff|coverage|checkstyle]\",\n+    );\n \n     opts\n }"}, {"sha": "a9fc31ea0b010724f512f4cd899c9f3a19b4e05b", "filename": "src/comment.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "patch": "@@ -585,7 +585,7 @@ pub fn remove_trailing_white_spaces(text: &str) -> String {\n     buffer\n }\n \n-struct CharClasses<T>\n+pub struct CharClasses<T>\n where\n     T: Iterator,\n     T::Item: RichChar,\n@@ -594,7 +594,7 @@ where\n     status: CharClassesStatus,\n }\n \n-trait RichChar {\n+pub trait RichChar {\n     fn get_char(&self) -> char;\n }\n \n@@ -610,6 +610,12 @@ impl RichChar for (usize, char) {\n     }\n }\n \n+impl RichChar for (char, usize) {\n+    fn get_char(&self) -> char {\n+        self.0\n+    }\n+}\n+\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n enum CharClassesStatus {\n     Normal,\n@@ -639,7 +645,7 @@ pub enum CodeCharKind {\n /// describing opening and closing of comments for ease when chunking\n /// code from tagged characters\n #[derive(PartialEq, Eq, Debug, Clone, Copy)]\n-enum FullCodeCharKind {\n+pub enum FullCodeCharKind {\n     Normal,\n     /// The first character of a comment, there is only one for a comment (always '/')\n     StartComment,\n@@ -653,7 +659,7 @@ enum FullCodeCharKind {\n }\n \n impl FullCodeCharKind {\n-    fn is_comment(&self) -> bool {\n+    pub fn is_comment(&self) -> bool {\n         match *self {\n             FullCodeCharKind::StartComment\n             | FullCodeCharKind::InComment\n@@ -662,6 +668,10 @@ impl FullCodeCharKind {\n         }\n     }\n \n+    pub fn is_string(&self) -> bool {\n+        *self == FullCodeCharKind::InString\n+    }\n+\n     fn to_codecharkind(&self) -> CodeCharKind {\n         if self.is_comment() {\n             CodeCharKind::Comment\n@@ -676,7 +686,7 @@ where\n     T: Iterator,\n     T::Item: RichChar,\n {\n-    fn new(base: T) -> CharClasses<T> {\n+    pub fn new(base: T) -> CharClasses<T> {\n         CharClasses {\n             base: base.peekable(),\n             status: CharClassesStatus::Normal,"}, {"sha": "ed44df022a944b0c119355db1c614b189ff73822", "filename": "src/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "patch": "@@ -682,8 +682,9 @@ create_config! {\n     disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n     skip_children: bool, false, false, \"Don't reformat out of line modules\";\n     error_on_line_overflow: bool, true, false, \"Error if unable to get all lines within max_width\";\n-    error_on_line_overflow_comments: bool, true, false,\n-        \"Error if unable to get comments within max_width\";\n+    error_on_unformatted: bool, false, false,\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\";\n     report_todo: ReportTactic, ReportTactic::Never, false,\n         \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n     report_fixme: ReportTactic, ReportTactic::Never, false,"}, {"sha": "b00caf40cd5d10f14a219a2e7b0ac33b4a2d6aea", "filename": "src/lib.rs", "status": "modified", "additions": 50, "deletions": 31, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "patch": "@@ -39,6 +39,7 @@ use syntax::codemap::{CodeMap, FilePathMapping};\n use syntax::parse::{self, ParseSess};\n \n use checkstyle::{output_footer, output_header};\n+use comment::{CharClasses, FullCodeCharKind};\n use config::Config;\n use filemap::FileMap;\n use issues::{BadIssueSeeker, Issue};\n@@ -76,6 +77,7 @@ mod patterns;\n mod summary;\n mod vertical;\n \n+#[derive(Clone, Copy)]\n pub enum ErrorKind {\n     // Line has exceeded character limit (found, maximum)\n     LineOverflow(usize, usize),\n@@ -104,6 +106,7 @@ pub struct FormattingError {\n     line: usize,\n     kind: ErrorKind,\n     is_comment: bool,\n+    is_string: bool,\n     line_buffer: String,\n }\n \n@@ -116,12 +119,11 @@ impl FormattingError {\n     }\n \n     fn msg_suffix(&self) -> &str {\n-        match self.kind {\n-            ErrorKind::LineOverflow(..) if self.is_comment => {\n-                \"use `error_on_line_overflow_comments = false` to suppress \\\n-                 the warning against line comments\\n\"\n-            }\n-            _ => \"\",\n+        if self.is_comment || self.is_string {\n+            \"set `error_on_unformatted = false` to suppress \\\n+             the warning against comments or string literals\\n\"\n+        } else {\n+            \"\"\n         }\n     }\n \n@@ -363,6 +365,25 @@ fn is_skipped_line(line_number: usize, skipped_range: &[(usize, usize)]) -> bool\n         .any(|&(lo, hi)| lo <= line_number && line_number <= hi)\n }\n \n+fn should_report_error(\n+    config: &Config,\n+    char_kind: FullCodeCharKind,\n+    is_string: bool,\n+    error_kind: ErrorKind,\n+) -> bool {\n+    let allow_error_report = if char_kind.is_comment() || is_string {\n+        config.error_on_unformatted()\n+    } else {\n+        true\n+    };\n+\n+    match error_kind {\n+        ErrorKind::LineOverflow(..) => config.error_on_line_overflow() && allow_error_report,\n+        ErrorKind::TrailingWhitespace => allow_error_report,\n+        _ => true,\n+    }\n+}\n+\n // Formatting done on a char by char or line by line basis.\n // FIXME(#209) warn on bad license\n // FIXME(#20) other stuff for parity with make tidy\n@@ -381,26 +402,23 @@ fn format_lines(\n     let mut newline_count = 0;\n     let mut errors = vec![];\n     let mut issue_seeker = BadIssueSeeker::new(config.report_todo(), config.report_fixme());\n-    let mut prev_char: Option<char> = None;\n-    let mut is_comment = false;\n     let mut line_buffer = String::with_capacity(config.max_width() * 2);\n-    let mut b = 0;\n+    let mut is_string = false; // true if the current line contains a string literal.\n+    let mut format_line = config.file_lines().contains_line(name, cur_line);\n \n-    for c in text.chars() {\n-        b += 1;\n+    for (kind, (b, c)) in CharClasses::new(text.chars().enumerate()) {\n         if c == '\\r' {\n             continue;\n         }\n \n-        let format_line = config.file_lines().contains_line(name, cur_line as usize);\n-\n         if format_line {\n             // Add warnings for bad todos/ fixmes\n             if let Some(issue) = issue_seeker.inspect(c) {\n                 errors.push(FormattingError {\n                     line: cur_line,\n                     kind: ErrorKind::BadIssue(issue),\n                     is_comment: false,\n+                    is_string: false,\n                     line_buffer: String::new(),\n                 });\n             }\n@@ -409,49 +427,49 @@ fn format_lines(\n         if c == '\\n' {\n             if format_line {\n                 // Check for (and record) trailing whitespace.\n-                if let Some(lw) = last_wspace {\n-                    trims.push((cur_line, lw, b, line_buffer.clone()));\n+                if let Some(..) = last_wspace {\n+                    if should_report_error(config, kind, is_string, ErrorKind::TrailingWhitespace) {\n+                        trims.push((cur_line, kind, line_buffer.clone()));\n+                    }\n                     line_len -= 1;\n                 }\n \n                 // Check for any line width errors we couldn't correct.\n-                let report_error_on_line_overflow = config.error_on_line_overflow()\n-                    && !is_skipped_line(cur_line, skipped_range)\n-                    && (config.error_on_line_overflow_comments() || !is_comment);\n-                if report_error_on_line_overflow && line_len > config.max_width() {\n+                let error_kind = ErrorKind::LineOverflow(line_len, config.max_width());\n+                if line_len > config.max_width() && !is_skipped_line(cur_line, skipped_range)\n+                    && should_report_error(config, kind, is_string, error_kind)\n+                {\n                     errors.push(FormattingError {\n                         line: cur_line,\n-                        kind: ErrorKind::LineOverflow(line_len, config.max_width()),\n-                        is_comment: is_comment,\n+                        kind: error_kind,\n+                        is_comment: kind.is_comment(),\n+                        is_string: is_string,\n                         line_buffer: line_buffer.clone(),\n                     });\n                 }\n             }\n \n             line_len = 0;\n             cur_line += 1;\n+            format_line = config.file_lines().contains_line(name, cur_line);\n             newline_count += 1;\n             last_wspace = None;\n-            prev_char = None;\n-            is_comment = false;\n             line_buffer.clear();\n+            is_string = false;\n         } else {\n             newline_count = 0;\n             line_len += 1;\n             if c.is_whitespace() {\n                 if last_wspace.is_none() {\n                     last_wspace = Some(b);\n                 }\n-            } else if c == '/' {\n-                if let Some('/') = prev_char {\n-                    is_comment = true;\n-                }\n-                last_wspace = None;\n             } else {\n                 last_wspace = None;\n             }\n-            prev_char = Some(c);\n             line_buffer.push(c);\n+            if kind.is_string() {\n+                is_string = true;\n+            }\n         }\n     }\n \n@@ -461,12 +479,13 @@ fn format_lines(\n         text.truncate(line);\n     }\n \n-    for &(l, _, _, ref b) in &trims {\n+    for &(l, kind, ref b) in &trims {\n         if !is_skipped_line(l, skipped_range) {\n             errors.push(FormattingError {\n                 line: l,\n                 kind: ErrorKind::TrailingWhitespace,\n-                is_comment: false,\n+                is_comment: kind.is_comment(),\n+                is_string: kind.is_string(),\n                 line_buffer: b.clone(),\n             });\n         }"}, {"sha": "9fd9e01e274fc97bcbae741bb4db444762b0aa1c", "filename": "tests/target/configs-error_on_line_overflow_comment-false.rs", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3c08da3433fe63595e4d46b95f0b1483c1c2650d/tests%2Ftarget%2Fconfigs-error_on_line_overflow_comment-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c08da3433fe63595e4d46b95f0b1483c1c2650d/tests%2Ftarget%2Fconfigs-error_on_line_overflow_comment-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-error_on_line_overflow_comment-false.rs?ref=3c08da3433fe63595e4d46b95f0b1483c1c2650d", "patch": "@@ -1,7 +0,0 @@\n-// rustfmt-error_on_line_overflow_comments: false\n-// Error on line overflow comment\n-\n-// aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n-fn main() {\n-    // aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n-}"}, {"sha": "6a78374e2a26964493c983891092048174b34540", "filename": "tests/target/configs-error_on_unformatted-false.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/tests%2Ftarget%2Fconfigs-error_on_unformatted-false.rs", "raw_url": "https://github.com/rust-lang/rust/raw/644b60ad85c18023c5b6f09fa60b9cf572d28e7f/tests%2Ftarget%2Fconfigs-error_on_unformatted-false.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-error_on_unformatted-false.rs?ref=644b60ad85c18023c5b6f09fa60b9cf572d28e7f", "patch": "@@ -0,0 +1,12 @@\n+// rustfmt-error_on_unformatted: false\n+// Error on line overflow comment or string literals.\n+\n+// aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+fn main() {\n+    // aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n+\n+    let x = \"                                                                                                  \";\n+    let a = \"\n+  \n+\";\n+}"}]}