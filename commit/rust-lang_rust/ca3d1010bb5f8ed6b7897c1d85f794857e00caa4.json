{"sha": "ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "node_id": "C_kwDOAAsO6NoAKGNhM2QxMDEwYmI1ZjhlZDZiNzg5N2MxZDg1Zjc5NDg1N2UwMGNhYTQ", "commit": {"author": {"name": "Ross MacArthur", "email": "ross@macarthur.io", "date": "2022-01-02T16:31:56Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-08-01T12:39:27Z"}, "message": "Add `Iterator::array_chunks()`", "tree": {"sha": "9930df89cf68a8558905675d22aa790fb44b0663", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9930df89cf68a8558905675d22aa790fb44b0663"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "html_url": "https://github.com/rust-lang/rust/commit/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/comments", "author": {"login": "rossmacarthur", "id": 17109887, "node_id": "MDQ6VXNlcjE3MTA5ODg3", "avatar_url": "https://avatars.githubusercontent.com/u/17109887?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rossmacarthur", "html_url": "https://github.com/rossmacarthur", "followers_url": "https://api.github.com/users/rossmacarthur/followers", "following_url": "https://api.github.com/users/rossmacarthur/following{/other_user}", "gists_url": "https://api.github.com/users/rossmacarthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/rossmacarthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rossmacarthur/subscriptions", "organizations_url": "https://api.github.com/users/rossmacarthur/orgs", "repos_url": "https://api.github.com/users/rossmacarthur/repos", "events_url": "https://api.github.com/users/rossmacarthur/events{/privacy}", "received_events_url": "https://api.github.com/users/rossmacarthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f5d8d49eb6111931091f700d07518cd2b80bc18", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f5d8d49eb6111931091f700d07518cd2b80bc18", "html_url": "https://github.com/rust-lang/rust/commit/1f5d8d49eb6111931091f700d07518cd2b80bc18"}], "stats": {"total": 697, "additions": 696, "deletions": 1}, "files": [{"sha": "f9c3f03cbb81b39d58721e22ed1e923a3eb2821c", "filename": "library/core/src/iter/adapters/array_chunks.rs", "status": "added", "additions": 427, "deletions": 0, "changes": 427, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Farray_chunks.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -0,0 +1,427 @@\n+use crate::iter::{Fuse, FusedIterator, Iterator, TrustedLen};\n+use crate::mem;\n+use crate::mem::MaybeUninit;\n+use crate::ops::{ControlFlow, Try};\n+use crate::ptr;\n+\n+#[derive(Debug)]\n+struct Remainder<T, const N: usize> {\n+    array: [MaybeUninit<T>; N],\n+    init: usize,\n+}\n+\n+impl<T, const N: usize> Remainder<T, N> {\n+    fn new() -> Self {\n+        Self { array: MaybeUninit::uninit_array(), init: 0 }\n+    }\n+\n+    unsafe fn with_init(array: [MaybeUninit<T>; N], init: usize) -> Self {\n+        Self { array, init }\n+    }\n+\n+    fn as_slice(&self) -> &[T] {\n+        debug_assert!(self.init <= N);\n+        // SAFETY: This raw slice will only contain the initialized objects\n+        // within the buffer.\n+        unsafe {\n+            let slice = self.array.get_unchecked(..self.init);\n+            MaybeUninit::slice_assume_init_ref(slice)\n+        }\n+    }\n+\n+    fn as_mut_slice(&mut self) -> &mut [T] {\n+        debug_assert!(self.init <= N);\n+        // SAFETY: This raw slice will only contain the initialized objects\n+        // within the buffer.\n+        unsafe {\n+            let slice = self.array.get_unchecked_mut(..self.init);\n+            MaybeUninit::slice_assume_init_mut(slice)\n+        }\n+    }\n+}\n+\n+impl<T, const N: usize> Clone for Remainder<T, N>\n+where\n+    T: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        let mut new = Self::new();\n+        // SAFETY: The new array is the same size and `init` is always less than\n+        // or equal to `N`.\n+        let this = unsafe { new.array.get_unchecked_mut(..self.init) };\n+        MaybeUninit::write_slice_cloned(this, self.as_slice());\n+        new.init = self.init;\n+        new\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for Remainder<T, N> {\n+    fn drop(&mut self) {\n+        // SAFETY: This raw slice will only contain the initialized objects\n+        // within the buffer.\n+        unsafe { ptr::drop_in_place(self.as_mut_slice()) }\n+    }\n+}\n+\n+/// An iterator over `N` elements of the iterator at a time.\n+///\n+/// The chunks do not overlap. If `N` does not divide the length of the\n+/// iterator, then the last up to `N-1` elements will be omitted.\n+///\n+/// This `struct` is created by the [`array_chunks`][Iterator::array_chunks]\n+/// method on [`Iterator`]. See its documentation for more.\n+#[derive(Debug, Clone)]\n+#[must_use = \"iterators are lazy and do nothing unless consumed\"]\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+pub struct ArrayChunks<I: Iterator, const N: usize> {\n+    iter: Fuse<I>,\n+    remainder: Remainder<I::Item, N>,\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    pub(in crate::iter) fn new(iter: I) -> Self {\n+        assert!(N != 0, \"chunk size must be non-zero\");\n+        Self { iter: iter.fuse(), remainder: Remainder::new() }\n+    }\n+\n+    /// Returns a reference to the remaining elements of the original iterator\n+    /// that are not going to be returned by this iterator. The returned slice\n+    /// has at most `N-1` elements.\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+    #[inline]\n+    pub fn remainder(&self) -> &[I::Item] {\n+        self.remainder.as_slice()\n+    }\n+\n+    /// Returns a mutable reference to the remaining elements of the original\n+    /// iterator that are not going to be returned by this iterator. The\n+    /// returned slice has at most `N-1` elements.\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+    #[inline]\n+    pub fn remainder_mut(&mut self) -> &mut [I::Item] {\n+        self.remainder.as_mut_slice()\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+impl<I, const N: usize> Iterator for ArrayChunks<I, N>\n+where\n+    I: Iterator,\n+{\n+    type Item = [I::Item; N];\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<Self::Item> {\n+        let mut array = MaybeUninit::uninit_array();\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { FrontGuard::new(&mut array) };\n+\n+        for slot in array.iter_mut() {\n+            match self.iter.next() {\n+                Some(item) => {\n+                    slot.write(item);\n+                    guard.init += 1;\n+                }\n+                None => {\n+                    if guard.init > 0 {\n+                        let init = guard.init;\n+                        mem::forget(guard);\n+                        // SAFETY: `array` was initialized with `init` elements.\n+                        self.remainder = unsafe { Remainder::with_init(array, init) };\n+                    }\n+                    return None;\n+                }\n+            }\n+        }\n+\n+        mem::forget(guard);\n+        // SAFETY: All elements of the array were populated in the loop above.\n+        Some(unsafe { MaybeUninit::array_assume_init(array) })\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (lower, upper) = self.iter.size_hint();\n+        // Keep infinite iterator size hint lower bound as `usize::MAX`. This\n+        // is required to implement `TrustedLen`.\n+        if lower == usize::MAX {\n+            return (lower, upper);\n+        }\n+        (lower / N, upper.map(|n| n / N))\n+    }\n+\n+    #[inline]\n+    fn count(self) -> usize {\n+        self.iter.count() / N\n+    }\n+\n+    fn try_fold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        let mut array = MaybeUninit::uninit_array();\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { FrontGuard::new(&mut array) };\n+\n+        let result = self.iter.try_fold(init, |mut acc, item| {\n+            // SAFETY: `init` starts at 0, increases by one each iteration and\n+            // is reset to 0 once it reaches N.\n+            unsafe { array.get_unchecked_mut(guard.init) }.write(item);\n+            guard.init += 1;\n+            if guard.init == N {\n+                guard.init = 0;\n+                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n+                // SAFETY: the condition above asserts that all elements are\n+                // initialized.\n+                let item = unsafe { MaybeUninit::array_assume_init(array) };\n+                acc = f(acc, item)?;\n+            }\n+            R::from_output(acc)\n+        });\n+        match result.branch() {\n+            ControlFlow::Continue(o) => {\n+                if guard.init > 0 {\n+                    let init = guard.init;\n+                    mem::forget(guard);\n+                    // SAFETY: `array` was initialized with `init` elements.\n+                    self.remainder = unsafe { Remainder::with_init(array, init) };\n+                }\n+                R::from_output(o)\n+            }\n+            ControlFlow::Break(r) => R::from_residual(r),\n+        }\n+    }\n+\n+    fn fold<B, F>(self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        let mut array = MaybeUninit::uninit_array();\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { FrontGuard::new(&mut array) };\n+\n+        self.iter.fold(init, |mut acc, item| {\n+            // SAFETY: `init` starts at 0, increases by one each iteration and\n+            // is reset to 0 once it reaches N.\n+            unsafe { array.get_unchecked_mut(guard.init) }.write(item);\n+            guard.init += 1;\n+            if guard.init == N {\n+                guard.init = 0;\n+                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n+                // SAFETY: the condition above asserts that all elements are\n+                // initialized.\n+                let item = unsafe { MaybeUninit::array_assume_init(array) };\n+                acc = f(acc, item);\n+            }\n+            acc\n+        })\n+    }\n+}\n+\n+/// A guard for an array where elements are filled from the left.\n+struct FrontGuard<T, const N: usize> {\n+    /// A pointer to the array that is being filled. We need to use a raw\n+    /// pointer here because of the lifetime issues in the fold implementations.\n+    ptr: *mut T,\n+    /// The number of *initialized* elements.\n+    init: usize,\n+}\n+\n+impl<T, const N: usize> FrontGuard<T, N> {\n+    unsafe fn new(array: &mut [MaybeUninit<T>; N]) -> Self {\n+        Self { ptr: MaybeUninit::slice_as_mut_ptr(array), init: 0 }\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for FrontGuard<T, N> {\n+    fn drop(&mut self) {\n+        debug_assert!(self.init <= N);\n+        // SAFETY: This raw slice will only contain the initialized objects\n+        // within the buffer.\n+        unsafe {\n+            let slice = ptr::slice_from_raw_parts_mut(self.ptr, self.init);\n+            ptr::drop_in_place(slice);\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+impl<I, const N: usize> DoubleEndedIterator for ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back(&mut self) -> Option<Self::Item> {\n+        // We are iterating from the back we need to first handle the remainder.\n+        self.next_back_remainder()?;\n+\n+        let mut array = MaybeUninit::uninit_array();\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { BackGuard::new(&mut array) };\n+\n+        for slot in array.iter_mut().rev() {\n+            slot.write(self.iter.next_back()?);\n+            guard.uninit -= 1;\n+        }\n+\n+        mem::forget(guard);\n+        // SAFETY: All elements of the array were populated in the loop above.\n+        Some(unsafe { MaybeUninit::array_assume_init(array) })\n+    }\n+\n+    fn try_rfold<B, F, R>(&mut self, init: B, mut f: F) -> R\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> R,\n+        R: Try<Output = B>,\n+    {\n+        // We are iterating from the back we need to first handle the remainder.\n+        if self.next_back_remainder().is_none() {\n+            return R::from_output(init);\n+        }\n+\n+        let mut array = MaybeUninit::uninit_array();\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { BackGuard::new(&mut array) };\n+\n+        self.iter.try_rfold(init, |mut acc, item| {\n+            guard.uninit -= 1;\n+            // SAFETY: `uninit` starts at N, decreases by one each iteration and\n+            // is reset to N once it reaches 0.\n+            unsafe { array.get_unchecked_mut(guard.uninit) }.write(item);\n+            if guard.uninit == 0 {\n+                guard.uninit = N;\n+                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n+                // SAFETY: the condition above asserts that all elements are\n+                // initialized.\n+                let item = unsafe { MaybeUninit::array_assume_init(array) };\n+                acc = f(acc, item)?;\n+            }\n+            R::from_output(acc)\n+        })\n+    }\n+\n+    fn rfold<B, F>(mut self, init: B, mut f: F) -> B\n+    where\n+        Self: Sized,\n+        F: FnMut(B, Self::Item) -> B,\n+    {\n+        // We are iterating from the back we need to first handle the remainder.\n+        if self.next_back_remainder().is_none() {\n+            return init;\n+        }\n+\n+        let mut array = MaybeUninit::uninit_array();\n+\n+        // SAFETY: `array` will still be valid if `guard` is dropped.\n+        let mut guard = unsafe { BackGuard::new(&mut array) };\n+\n+        self.iter.rfold(init, |mut acc, item| {\n+            guard.uninit -= 1;\n+            // SAFETY: `uninit` starts at N, decreases by one each iteration and\n+            // is reset to N once it reaches 0.\n+            unsafe { array.get_unchecked_mut(guard.uninit) }.write(item);\n+            if guard.uninit == 0 {\n+                guard.uninit = N;\n+                let array = mem::replace(&mut array, MaybeUninit::uninit_array());\n+                // SAFETY: the condition above asserts that all elements are\n+                // initialized.\n+                let item = unsafe { MaybeUninit::array_assume_init(array) };\n+                acc = f(acc, item);\n+            }\n+            acc\n+        })\n+    }\n+}\n+\n+impl<I, const N: usize> ArrayChunks<I, N>\n+where\n+    I: DoubleEndedIterator + ExactSizeIterator,\n+{\n+    #[inline]\n+    fn next_back_remainder(&mut self) -> Option<()> {\n+        // We use the `ExactSizeIterator` implementation of the underlying\n+        // iterator to know how many remaining elements there are.\n+        let rem = self.iter.len() % N;\n+        if rem == 0 {\n+            return Some(());\n+        }\n+\n+        let mut array = MaybeUninit::uninit_array();\n+\n+        // SAFETY: The array will still be valid if `guard` is dropped and\n+        // it is forgotten otherwise.\n+        let mut guard = unsafe { FrontGuard::new(&mut array) };\n+\n+        // SAFETY: `rem` is in the range 1..N based on how it is calculated.\n+        for slot in unsafe { array.get_unchecked_mut(..rem) }.iter_mut() {\n+            slot.write(self.iter.next_back()?);\n+            guard.init += 1;\n+        }\n+\n+        let init = guard.init;\n+        mem::forget(guard);\n+        // SAFETY: `array` was initialized with exactly `init` elements.\n+        self.remainder = unsafe {\n+            array.get_unchecked_mut(..init).reverse();\n+            Remainder::with_init(array, init)\n+        };\n+        Some(())\n+    }\n+}\n+\n+/// A guard for an array where elements are filled from the right.\n+struct BackGuard<T, const N: usize> {\n+    /// A pointer to the array that is being filled. We need to use a raw\n+    /// pointer here because of the lifetime issues in the rfold implementations.\n+    ptr: *mut T,\n+    /// The number of *uninitialized* elements.\n+    uninit: usize,\n+}\n+\n+impl<T, const N: usize> BackGuard<T, N> {\n+    unsafe fn new(array: &mut [MaybeUninit<T>; N]) -> Self {\n+        Self { ptr: MaybeUninit::slice_as_mut_ptr(array), uninit: N }\n+    }\n+}\n+\n+impl<T, const N: usize> Drop for BackGuard<T, N> {\n+    fn drop(&mut self) {\n+        debug_assert!(self.uninit <= N);\n+        // SAFETY: This raw slice will only contain the initialized objects\n+        // within the buffer.\n+        unsafe {\n+            let ptr = self.ptr.offset(self.uninit as isize);\n+            let slice = ptr::slice_from_raw_parts_mut(ptr, N - self.uninit);\n+            ptr::drop_in_place(slice);\n+        }\n+    }\n+}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+impl<I, const N: usize> FusedIterator for ArrayChunks<I, N> where I: FusedIterator {}\n+\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+impl<I, const N: usize> ExactSizeIterator for ArrayChunks<I, N>\n+where\n+    I: ExactSizeIterator,\n+{\n+    #[inline]\n+    fn len(&self) -> usize {\n+        self.iter.len() / N\n+    }\n+\n+    #[inline]\n+    fn is_empty(&self) -> bool {\n+        self.iter.len() / N == 0\n+    }\n+}\n+\n+#[unstable(feature = \"trusted_len\", issue = \"37572\")]\n+unsafe impl<I, const N: usize> TrustedLen for ArrayChunks<I, N> where I: TrustedLen {}"}, {"sha": "39e7ab87869a22f1b974126fed4d17d963fd03ec", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -1,6 +1,7 @@\n use crate::iter::{InPlaceIterable, Iterator};\n use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, NeverShortCircuit, Residual, Try};\n \n+mod array_chunks;\n mod by_ref_sized;\n mod chain;\n mod cloned;\n@@ -32,6 +33,9 @@ pub use self::{\n     scan::Scan, skip::Skip, skip_while::SkipWhile, take::Take, take_while::TakeWhile, zip::Zip,\n };\n \n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+pub use self::array_chunks::ArrayChunks;\n+\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::by_ref_sized::ByRefSized;\n "}, {"sha": "d48e3a52c79f600195006b35be8422103f571c26", "filename": "library/core/src/iter/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fmod.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -398,6 +398,8 @@ pub use self::traits::{\n \n #[stable(feature = \"iter_zip\", since = \"1.59.0\")]\n pub use self::adapters::zip;\n+#[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+pub use self::adapters::ArrayChunks;\n #[unstable(feature = \"std_internals\", issue = \"none\")]\n pub use self::adapters::ByRefSized;\n #[stable(feature = \"iter_cloned\", since = \"1.1.0\")]"}, {"sha": "8bf41ca6f2a967f41af2f89ec991497aaa1f7bab", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 41, "deletions": 1, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -5,7 +5,7 @@ use crate::ops::{ChangeOutputType, ControlFlow, FromResidual, Residual, Try};\n use super::super::try_process;\n use super::super::ByRefSized;\n use super::super::TrustedRandomAccessNoCoerce;\n-use super::super::{Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n+use super::super::{ArrayChunks, Chain, Cloned, Copied, Cycle, Enumerate, Filter, FilterMap, Fuse};\n use super::super::{FlatMap, Flatten};\n use super::super::{FromIterator, Intersperse, IntersperseWith, Product, Sum, Zip};\n use super::super::{\n@@ -3316,6 +3316,46 @@ pub trait Iterator {\n         Cycle::new(self)\n     }\n \n+    /// Returns an iterator over `N` elements of the iterator at a time.\n+    ///\n+    /// The chunks do not overlap. If `N` does not divide the length of the\n+    /// iterator, then the last up to `N-1` elements will be omitted.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if `N` is 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let mut iter = \"lorem\".chars().array_chunks();\n+    /// assert_eq!(iter.next(), Some(['l', 'o']));\n+    /// assert_eq!(iter.next(), Some(['r', 'e']));\n+    /// assert_eq!(iter.next(), None);\n+    /// assert_eq!(iter.remainder(), &['m']);\n+    /// ```\n+    ///\n+    /// ```\n+    /// #![feature(iter_array_chunks)]\n+    ///\n+    /// let data = [1, 1, 2, -2, 6, 0, 3, 1];\n+    /// //          ^-----^  ^------^\n+    /// for [x, y, z] in data.iter().array_chunks() {\n+    ///     assert_eq!(x + y + z, 4);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"iter_array_chunks\", reason = \"recently added\", issue = \"none\")]\n+    fn array_chunks<const N: usize>(self) -> ArrayChunks<Self, N>\n+    where\n+        Self: Sized,\n+    {\n+        ArrayChunks::new(self)\n+    }\n+\n     /// Sums the elements of an iterator.\n     ///\n     /// Takes each element, adds them together, and returns the result."}, {"sha": "6845c94d364cad06fee5340dcc5587a618bcb259", "filename": "library/core/tests/iter/adapters/array_chunks.rs", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Farray_chunks.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -0,0 +1,198 @@\n+use core::cell::Cell;\n+use core::iter::{self, Iterator};\n+\n+use super::*;\n+\n+#[test]\n+fn test_iterator_array_chunks_infer() {\n+    let xs = [1, 1, 2, -2, 6, 0, 3, 1];\n+    for [a, b, c] in xs.iter().copied().array_chunks() {\n+        assert_eq!(a + b + c, 4);\n+    }\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_clone_and_drop() {\n+    let count = Cell::new(0);\n+    let mut it = (0..5).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+\n+    assert_eq!(it.by_ref().count(), 1);\n+    assert_eq!(count.get(), 3);\n+    assert_eq!(it.remainder().len(), 2);\n+\n+    let mut it2 = it.clone();\n+    assert_eq!(count.get(), 3);\n+    assert_eq!(it2.remainder().len(), 2);\n+\n+    drop(it);\n+    assert_eq!(count.get(), 5);\n+    assert_eq!(it2.remainder().len(), 2);\n+    assert!(it2.next().is_none());\n+\n+    drop(it2);\n+    assert_eq!(count.get(), 7);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    assert_eq!(it.remainder(), &[]);\n+    assert_eq!(it.remainder_mut(), &[]);\n+    assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+    assert_eq!(it.remainder(), &[]);\n+    assert_eq!(it.remainder_mut(), &[]);\n+    assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+    assert_eq!(it.remainder(), &[]);\n+    assert_eq!(it.remainder_mut(), &[]);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.remainder(), &[8, 9, 10]);\n+    assert_eq!(it.remainder_mut(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_size_hint() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.size_hint(), (6, Some(6)));\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.size_hint(), (2, Some(2)));\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+\n+    let it = (1..).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (usize::MAX, None));\n+\n+    let it = (1..).filter(|x| x % 2 != 0).array_chunks::<2>();\n+    assert_eq!(it.size_hint(), (0, None));\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_count() {\n+    let it = (0..6).array_chunks::<1>();\n+    assert_eq!(it.count(), 6);\n+\n+    let it = (0..6).array_chunks::<3>();\n+    assert_eq!(it.count(), 2);\n+\n+    let it = (0..6).array_chunks::<5>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = (0..6).array_chunks::<7>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = (0..6).filter(|x| x % 2 == 0).array_chunks::<2>();\n+    assert_eq!(it.count(), 1);\n+\n+    let it = iter::empty::<i32>().array_chunks::<2>();\n+    assert_eq!(it.count(), 0);\n+\n+    let it = [(); usize::MAX].iter().array_chunks::<2>();\n+    assert_eq!(it.count(), usize::MAX / 2);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_next_and_next_back() {\n+    let mut it = (0..11).array_chunks::<3>();\n+    assert_eq!(it.next(), Some([0, 1, 2]));\n+    assert_eq!(it.next_back(), Some([6, 7, 8]));\n+    assert_eq!(it.next(), Some([3, 4, 5]));\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.next_back(), None);\n+    assert_eq!(it.next(), None);\n+    assert_eq!(it.remainder(), &[9, 10]);\n+    assert_eq!(it.remainder_mut(), &[9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rev_remainder() {\n+    let mut it = (0..11).array_chunks::<4>();\n+    {\n+        let mut it = it.by_ref().rev();\n+        assert_eq!(it.next(), Some([4, 5, 6, 7]));\n+        assert_eq!(it.next(), Some([0, 1, 2, 3]));\n+        assert_eq!(it.next(), None);\n+        assert_eq!(it.next(), None);\n+    }\n+    assert_eq!(it.remainder(), &[8, 9, 10]);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_fold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.by_ref().try_fold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(it.remainder().len(), 1);\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.by_ref().try_fold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(it.remainder().len(), 0);\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 9);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_fold() {\n+    let result = (1..11).array_chunks::<3>().fold(0, |acc, [a, b, c]| {\n+        assert_eq!(acc + 1, a);\n+        assert_eq!(acc + 2, b);\n+        assert_eq!(acc + 3, c);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().fold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_try_rfold() {\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result: Result<_, ()> = it.try_rfold(0, |acc, _item| Ok(acc + 1));\n+    assert_eq!(result, Ok(3));\n+    assert_eq!(it.remainder().len(), 1);\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+\n+    let count = Cell::new(0);\n+    let mut it = (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>();\n+    let result = it.try_rfold(0, |acc, _item| if acc < 2 { Ok(acc + 1) } else { Err(acc) });\n+    assert_eq!(result, Err(2));\n+    assert_eq!(count.get(), 9);\n+    drop(it);\n+    assert_eq!(count.get(), 10);\n+}\n+\n+#[test]\n+fn test_iterator_array_chunks_rfold() {\n+    let result = (1..11).array_chunks::<3>().rfold(0, |acc, [a, b, c]| {\n+        assert_eq!(10 - (acc + 1), c);\n+        assert_eq!(10 - (acc + 2), b);\n+        assert_eq!(10 - (acc + 3), a);\n+        acc + 3\n+    });\n+    assert_eq!(result, 9);\n+\n+    let count = Cell::new(0);\n+    let result =\n+        (0..10).map(|_| CountDrop::new(&count)).array_chunks::<3>().rfold(0, |acc, _item| acc + 1);\n+    assert_eq!(result, 3);\n+    assert_eq!(count.get(), 10);\n+}"}, {"sha": "96539c0c394e2e683720fc0d8b44aa5e688e40b0", "filename": "library/core/tests/iter/adapters/mod.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fiter%2Fadapters%2Fmod.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -1,3 +1,4 @@\n+mod array_chunks;\n mod chain;\n mod cloned;\n mod copied;\n@@ -183,3 +184,25 @@ impl Clone for CountClone {\n         ret\n     }\n }\n+\n+#[derive(Debug, Clone)]\n+struct CountDrop<'a> {\n+    dropped: bool,\n+    count: &'a Cell<usize>,\n+}\n+\n+impl<'a> CountDrop<'a> {\n+    pub fn new(count: &'a Cell<usize>) -> Self {\n+        Self { dropped: false, count }\n+    }\n+}\n+\n+impl Drop for CountDrop<'_> {\n+    fn drop(&mut self) {\n+        if self.dropped {\n+            panic!(\"double drop\");\n+        }\n+        self.dropped = true;\n+        self.count.set(self.count.get() + 1);\n+    }\n+}"}, {"sha": "8b4838bb7bc57892006c125b23c30c8b9aa80ff1", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca3d1010bb5f8ed6b7897c1d85f794857e00caa4/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=ca3d1010bb5f8ed6b7897c1d85f794857e00caa4", "patch": "@@ -61,6 +61,7 @@\n #![feature(slice_partition_dedup)]\n #![feature(int_log)]\n #![feature(iter_advance_by)]\n+#![feature(iter_array_chunks)]\n #![feature(iter_collect_into)]\n #![feature(iter_partition_in_place)]\n #![feature(iter_intersperse)]"}]}