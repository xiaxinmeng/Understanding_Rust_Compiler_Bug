{"sha": "ad95279c34272949d6babc31d54209434a97f46e", "node_id": "C_kwDOAAsO6NoAKGFkOTUyNzljMzQyNzI5NDlkNmJhYmMzMWQ1NDIwOTQzNGE5N2Y0NmU", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-05T23:27:10Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2022-01-12T18:03:38Z"}, "message": "Suggest deref when needed in `implicit_clone`", "tree": {"sha": "166747c92b4776b7a0363eb82d769820b989d9b0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/166747c92b4776b7a0363eb82d769820b989d9b0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad95279c34272949d6babc31d54209434a97f46e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad95279c34272949d6babc31d54209434a97f46e", "html_url": "https://github.com/rust-lang/rust/commit/ad95279c34272949d6babc31d54209434a97f46e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad95279c34272949d6babc31d54209434a97f46e/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92048f4826a445872eb50760a4f46a92837b243e", "url": "https://api.github.com/repos/rust-lang/rust/commits/92048f4826a445872eb50760a4f46a92837b243e", "html_url": "https://github.com/rust-lang/rust/commit/92048f4826a445872eb50760a4f46a92837b243e"}], "stats": {"total": 86, "additions": 58, "deletions": 28}, "files": [{"sha": "865e7702b7151567bb0e12da002d1265b2b77301", "filename": "clippy_lints/src/methods/implicit_clone.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ad95279c34272949d6babc31d54209434a97f46e/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad95279c34272949d6babc31d54209434a97f46e/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fimplicit_clone.rs?ref=ad95279c34272949d6babc31d54209434a97f46e", "patch": "@@ -1,31 +1,40 @@\n use clippy_utils::diagnostics::span_lint_and_sugg;\n+use clippy_utils::source::snippet_with_context;\n+use clippy_utils::ty::peel_mid_ty_refs;\n use clippy_utils::{is_diag_item_method, is_diag_trait_item};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_lint::LateContext;\n use rustc_middle::ty::TyS;\n-use rustc_span::{sym, Span};\n+use rustc_span::sym;\n \n use super::IMPLICIT_CLONE;\n \n-pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>, span: Span) {\n+pub fn check(cx: &LateContext<'_>, method_name: &str, expr: &hir::Expr<'_>, recv: &hir::Expr<'_>) {\n     if_chain! {\n         if let Some(method_def_id) = cx.typeck_results().type_dependent_def_id(expr.hir_id);\n         if is_clone_like(cx, method_name, method_def_id);\n         let return_type = cx.typeck_results().expr_ty(expr);\n-        let input_type = cx.typeck_results().expr_ty(recv).peel_refs();\n+        let input_type = cx.typeck_results().expr_ty(recv);\n+        let (input_type, ref_count) = peel_mid_ty_refs(input_type);\n         if let Some(ty_name) = input_type.ty_adt_def().map(|adt_def| cx.tcx.item_name(adt_def.did));\n         if TyS::same_type(return_type, input_type);\n         then {\n+            let mut app = Applicability::MachineApplicable;\n+            let recv_snip = snippet_with_context(cx, recv.span, expr.span.ctxt(), \"..\", &mut app).0;\n             span_lint_and_sugg(\n                 cx,\n                 IMPLICIT_CLONE,\n-                span,\n+                expr.span,\n                 &format!(\"implicitly cloning a `{}` by calling `{}` on its dereferenced type\", ty_name, method_name),\n                 \"consider using\",\n-                \"clone\".to_string(),\n-                Applicability::MachineApplicable\n+                if ref_count > 1 {\n+                    format!(\"({}{}).clone()\", \"*\".repeat(ref_count - 1), recv_snip)\n+                } else {\n+                    format!(\"{}.clone()\", recv_snip)\n+                },\n+                app,\n             );\n         }\n     }"}, {"sha": "ae5bfadbc5f611db0b55efc829389117d58a91f5", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad95279c34272949d6babc31d54209434a97f46e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad95279c34272949d6babc31d54209434a97f46e/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=ad95279c34272949d6babc31d54209434a97f46e", "patch": "@@ -2342,7 +2342,7 @@ fn check_methods<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, msrv: Optio\n             },\n             (\"step_by\", [arg]) => iterator_step_by_zero::check(cx, expr, arg),\n             (\"to_os_string\" | \"to_owned\" | \"to_path_buf\" | \"to_vec\", []) => {\n-                implicit_clone::check(cx, name, expr, recv, span);\n+                implicit_clone::check(cx, name, expr, recv);\n             },\n             (\"unwrap\", []) => match method_call!(recv) {\n                 Some((\"get\", [recv, get_arg], _)) => get_unwrap::check(cx, expr, recv, get_arg, false),"}, {"sha": "639fecb8927bd322b4754c9fb00268107612e793", "filename": "tests/ui/implicit_clone.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ad95279c34272949d6babc31d54209434a97f46e/tests%2Fui%2Fimplicit_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad95279c34272949d6babc31d54209434a97f46e/tests%2Fui%2Fimplicit_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.rs?ref=ad95279c34272949d6babc31d54209434a97f46e", "patch": "@@ -105,4 +105,13 @@ fn main() {\n     let os_str = OsStr::new(\"foo\");\n     let _ = os_str.to_owned();\n     let _ = os_str.to_os_string();\n+\n+    // issue #8227\n+    let pathbuf_ref = &pathbuf;\n+    let pathbuf_ref = &pathbuf_ref;\n+    let _ = pathbuf_ref.to_owned(); // Don't lint. Returns `&PathBuf`\n+    let _ = pathbuf_ref.to_path_buf();\n+    let pathbuf_ref = &pathbuf_ref;\n+    let _ = pathbuf_ref.to_owned(); // Don't lint. Returns `&&PathBuf`\n+    let _ = pathbuf_ref.to_path_buf();\n }"}, {"sha": "0f4124241907f3b73dd9d38d0d9abac3e885053b", "filename": "tests/ui/implicit_clone.stderr", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/ad95279c34272949d6babc31d54209434a97f46e/tests%2Fui%2Fimplicit_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/ad95279c34272949d6babc31d54209434a97f46e/tests%2Fui%2Fimplicit_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimplicit_clone.stderr?ref=ad95279c34272949d6babc31d54209434a97f46e", "patch": "@@ -1,64 +1,76 @@\n error: implicitly cloning a `Vec` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:65:17\n+  --> $DIR/implicit_clone.rs:65:13\n    |\n LL |     let _ = vec.to_owned();\n-   |                 ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^ help: consider using: `vec.clone()`\n    |\n    = note: `-D clippy::implicit-clone` implied by `-D warnings`\n \n error: implicitly cloning a `Vec` by calling `to_vec` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:66:17\n+  --> $DIR/implicit_clone.rs:66:13\n    |\n LL |     let _ = vec.to_vec();\n-   |                 ^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^ help: consider using: `vec.clone()`\n \n error: implicitly cloning a `Vec` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:70:21\n+  --> $DIR/implicit_clone.rs:70:13\n    |\n LL |     let _ = vec_ref.to_owned();\n-   |                     ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^^ help: consider using: `vec_ref.clone()`\n \n error: implicitly cloning a `Vec` by calling `to_vec` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:71:21\n+  --> $DIR/implicit_clone.rs:71:13\n    |\n LL |     let _ = vec_ref.to_vec();\n-   |                     ^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^ help: consider using: `vec_ref.clone()`\n \n error: implicitly cloning a `String` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:83:17\n+  --> $DIR/implicit_clone.rs:83:13\n    |\n LL |     let _ = str.to_owned();\n-   |                 ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^ help: consider using: `str.clone()`\n \n error: implicitly cloning a `Kitten` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:87:20\n+  --> $DIR/implicit_clone.rs:87:13\n    |\n LL |     let _ = kitten.to_owned();\n-   |                    ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using: `kitten.clone()`\n \n error: implicitly cloning a `PathBuf` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:97:21\n+  --> $DIR/implicit_clone.rs:97:13\n    |\n LL |     let _ = pathbuf.to_owned();\n-   |                     ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^^ help: consider using: `pathbuf.clone()`\n \n error: implicitly cloning a `PathBuf` by calling `to_path_buf` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:98:21\n+  --> $DIR/implicit_clone.rs:98:13\n    |\n LL |     let _ = pathbuf.to_path_buf();\n-   |                     ^^^^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `pathbuf.clone()`\n \n error: implicitly cloning a `OsString` by calling `to_owned` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:101:23\n+  --> $DIR/implicit_clone.rs:101:13\n    |\n LL |     let _ = os_string.to_owned();\n-   |                       ^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^^^^ help: consider using: `os_string.clone()`\n \n error: implicitly cloning a `OsString` by calling `to_os_string` on its dereferenced type\n-  --> $DIR/implicit_clone.rs:102:23\n+  --> $DIR/implicit_clone.rs:102:13\n    |\n LL |     let _ = os_string.to_os_string();\n-   |                       ^^^^^^^^^^^^ help: consider using: `clone`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `os_string.clone()`\n \n-error: aborting due to 10 previous errors\n+error: implicitly cloning a `PathBuf` by calling `to_path_buf` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:113:13\n+   |\n+LL |     let _ = pathbuf_ref.to_path_buf();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(*pathbuf_ref).clone()`\n+\n+error: implicitly cloning a `PathBuf` by calling `to_path_buf` on its dereferenced type\n+  --> $DIR/implicit_clone.rs:116:13\n+   |\n+LL |     let _ = pathbuf_ref.to_path_buf();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(**pathbuf_ref).clone()`\n+\n+error: aborting due to 12 previous errors\n "}]}