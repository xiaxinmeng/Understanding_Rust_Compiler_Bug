{"sha": "b5542f7f5b1eb11430960687f69b5766857efaa0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI1NTQyZjdmNWIxZWIxMTQzMDk2MDY4N2Y2OWI1NzY2ODU3ZWZhYTA=", "commit": {"author": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-13T20:13:05Z"}, "committer": {"name": "Keegan McAllister", "email": "kmcallister@mozilla.com", "date": "2014-06-24T18:36:27Z"}, "message": "Convert builtin lints to uppercase names for style consistency", "tree": {"sha": "921d4259febcfcc533fb726a5c419e683a4fada8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/921d4259febcfcc533fb726a5c419e683a4fada8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b5542f7f5b1eb11430960687f69b5766857efaa0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b5542f7f5b1eb11430960687f69b5766857efaa0", "html_url": "https://github.com/rust-lang/rust/commit/b5542f7f5b1eb11430960687f69b5766857efaa0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b5542f7f5b1eb11430960687f69b5766857efaa0/comments", "author": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kmcallister", "id": 444997, "node_id": "MDQ6VXNlcjQ0NDk5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/444997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kmcallister", "html_url": "https://github.com/kmcallister", "followers_url": "https://api.github.com/users/kmcallister/followers", "following_url": "https://api.github.com/users/kmcallister/following{/other_user}", "gists_url": "https://api.github.com/users/kmcallister/gists{/gist_id}", "starred_url": "https://api.github.com/users/kmcallister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kmcallister/subscriptions", "organizations_url": "https://api.github.com/users/kmcallister/orgs", "repos_url": "https://api.github.com/users/kmcallister/repos", "events_url": "https://api.github.com/users/kmcallister/events{/privacy}", "received_events_url": "https://api.github.com/users/kmcallister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21e7b936d3a669b62e9cb8c6b2cf2c2eb0a5986c", "url": "https://api.github.com/repos/rust-lang/rust/commits/21e7b936d3a669b62e9cb8c6b2cf2c2eb0a5986c", "html_url": "https://github.com/rust-lang/rust/commit/21e7b936d3a669b62e9cb8c6b2cf2c2eb0a5986c"}], "stats": {"total": 252, "additions": 126, "deletions": 126}, "files": [{"sha": "2fb8b2d4ac9b2171f0f7eaf4a5efc10bf987da7f", "filename": "src/librustc/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdriver%2Fdriver.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -786,15 +786,15 @@ pub fn collect_crate_types(session: &Session,\n                 }\n                 Some(ref n) if n.equiv(&(\"bin\")) => Some(config::CrateTypeExecutable),\n                 Some(_) => {\n-                    session.add_lint(lint::builtin::unknown_crate_type,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"invalid `crate_type` \\\n                                       value\".to_string());\n                     None\n                 }\n                 _ => {\n-                    session.add_lint(lint::builtin::unknown_crate_type,\n+                    session.add_lint(lint::builtin::UNKNOWN_CRATE_TYPE,\n                                      ast::CRATE_NODE_ID,\n                                      a.span,\n                                      \"`crate_type` requires a \\"}, {"sha": "89697dc1674fa625968ade04f59597b23dae7a35", "filename": "src/librustc/front/feature_gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Ffront%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ffeature_gate.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -409,7 +409,7 @@ pub fn check_crate(sess: &Session, krate: &ast::Crate) {\n                                                      directive not necessary\");\n                         }\n                         None => {\n-                            sess.add_lint(lint::builtin::unknown_features,\n+                            sess.add_lint(lint::builtin::UNKNOWN_FEATURES,\n                                           ast::CRATE_NODE_ID,\n                                           mi.span,\n                                           \"unknown feature\".to_string());"}, {"sha": "903cb7f4f269263bdb7230f02319dc00a7081fd9", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 107, "deletions": 107, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -54,14 +54,14 @@ use syntax::codemap::Span;\n use syntax::parse::token;\n use syntax::{ast, ast_util, visit};\n \n-declare_lint!(while_true, Warn,\n+declare_lint!(WHILE_TRUE, Warn,\n     \"suggest using `loop { }` instead of `while true { }`\")\n \n pub struct WhileTrue;\n \n impl LintPass for WhileTrue {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(while_true)\n+        lint_array!(WHILE_TRUE)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -71,7 +71,7 @@ impl LintPass for WhileTrue {\n                     ast::ExprLit(lit) => {\n                         match lit.node {\n                             ast::LitBool(true) => {\n-                                cx.span_lint(while_true, e.span,\n+                                cx.span_lint(WHILE_TRUE, e.span,\n                                              \"denote infinite loops with loop \\\n                                               { ... }\");\n                             }\n@@ -86,36 +86,36 @@ impl LintPass for WhileTrue {\n     }\n }\n \n-declare_lint!(unnecessary_typecast, Allow,\n+declare_lint!(UNNECESSARY_TYPECAST, Allow,\n     \"detects unnecessary type casts, that can be removed\")\n \n pub struct UnusedCasts;\n \n impl LintPass for UnusedCasts {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unnecessary_typecast)\n+        lint_array!(UNNECESSARY_TYPECAST)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             ast::ExprCast(expr, ty) => {\n                 let t_t = ast_ty_to_ty(cx, &infer::new_infer_ctxt(cx.tcx), ty);\n                 if  ty::get(ty::expr_ty(cx.tcx, expr)).sty == ty::get(t_t).sty {\n-                    cx.span_lint(unnecessary_typecast, ty.span, \"unnecessary type cast\");\n+                    cx.span_lint(UNNECESSARY_TYPECAST, ty.span, \"unnecessary type cast\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n-declare_lint!(unsigned_negate, Warn,\n+declare_lint!(UNSIGNED_NEGATE, Warn,\n     \"using an unary minus operator on unsigned type\")\n \n-declare_lint!(type_limits, Warn,\n+declare_lint!(TYPE_LIMITS, Warn,\n     \"comparisons made useless by limits of the types involved\")\n \n-declare_lint!(type_overflow, Warn,\n+declare_lint!(TYPE_OVERFLOW, Warn,\n     \"literal out of range for its type\")\n \n pub struct TypeLimits {\n@@ -133,7 +133,7 @@ impl TypeLimits {\n \n impl LintPass for TypeLimits {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unsigned_negate, type_limits, type_overflow)\n+        lint_array!(UNSIGNED_NEGATE, TYPE_LIMITS, TYPE_OVERFLOW)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -143,7 +143,7 @@ impl LintPass for TypeLimits {\n                     ast::ExprLit(lit) => {\n                         match lit.node {\n                             ast::LitUint(..) => {\n-                                cx.span_lint(unsigned_negate, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n                                              \"negation of unsigned int literal may \\\n                                              be unintentional\");\n                             },\n@@ -154,7 +154,7 @@ impl LintPass for TypeLimits {\n                         let t = ty::expr_ty(cx.tcx, expr);\n                         match ty::get(t).sty {\n                             ty::ty_uint(_) => {\n-                                cx.span_lint(unsigned_negate, e.span,\n+                                cx.span_lint(UNSIGNED_NEGATE, e.span,\n                                              \"negation of unsigned int variable may \\\n                                              be unintentional\");\n                             },\n@@ -172,7 +172,7 @@ impl LintPass for TypeLimits {\n             },\n             ast::ExprBinary(binop, l, r) => {\n                 if is_comparison(binop) && !check_limits(cx.tcx, binop, l, r) {\n-                    cx.span_lint(type_limits, e.span,\n+                    cx.span_lint(TYPE_LIMITS, e.span,\n                                  \"comparison is useless due to type limits\");\n                 }\n             },\n@@ -193,7 +193,7 @@ impl LintPass for TypeLimits {\n                             lit_val *= -1;\n                         }\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(type_overflow, e.span,\n+                            cx.span_lint(TYPE_OVERFLOW, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -209,7 +209,7 @@ impl LintPass for TypeLimits {\n                             _ => fail!()\n                         };\n                         if  lit_val < min || lit_val > max {\n-                            cx.span_lint(type_overflow, e.span,\n+                            cx.span_lint(TYPE_OVERFLOW, e.span,\n                                          \"literal out of range for its type\");\n                         }\n                     },\n@@ -315,14 +315,14 @@ impl LintPass for TypeLimits {\n     }\n }\n \n-declare_lint!(ctypes, Warn,\n+declare_lint!(CTYPES, Warn,\n     \"proper use of libc types in foreign modules\")\n \n pub struct CTypes;\n \n impl LintPass for CTypes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(ctypes)\n+        lint_array!(CTYPES)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -331,18 +331,18 @@ impl LintPass for CTypes {\n                 ast::TyPath(_, _, id) => {\n                     match cx.tcx.def_map.borrow().get_copy(&id) {\n                         def::DefPrimTy(ast::TyInt(ast::TyI)) => {\n-                            cx.span_lint(ctypes, ty.span,\n+                            cx.span_lint(CTYPES, ty.span,\n                                 \"found rust type `int` in foreign module, while \\\n                                  libc::c_int or libc::c_long should be used\");\n                         }\n                         def::DefPrimTy(ast::TyUint(ast::TyU)) => {\n-                            cx.span_lint(ctypes, ty.span,\n+                            cx.span_lint(CTYPES, ty.span,\n                                 \"found rust type `uint` in foreign module, while \\\n                                  libc::c_uint or libc::c_ulong should be used\");\n                         }\n                         def::DefTy(def_id) => {\n                             if !adt::is_ffi_safe(cx.tcx, def_id) {\n-                                cx.span_lint(ctypes, ty.span,\n+                                cx.span_lint(CTYPES, ty.span,\n                                     \"found enum type without foreign-function-safe \\\n                                      representation annotation in foreign module\");\n                                 // hmm... this message could be more helpful\n@@ -377,13 +377,13 @@ impl LintPass for CTypes {\n     }\n }\n \n-declare_lint!(managed_heap_memory, Allow,\n+declare_lint!(MANAGED_HEAP_MEMORY, Allow,\n     \"use of managed (@ type) heap memory\")\n \n-declare_lint!(owned_heap_memory, Allow,\n+declare_lint!(OWNED_HEAP_MEMORY, Allow,\n     \"use of owned (Box type) heap memory\")\n \n-declare_lint!(heap_memory, Allow,\n+declare_lint!(HEAP_MEMORY, Allow,\n     \"use of any (Box type or @ type) heap memory\")\n \n pub struct HeapMemory;\n@@ -416,22 +416,22 @@ impl HeapMemory {\n         if n_uniq > 0 {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(owned_heap_memory, span, m.as_slice());\n-            cx.span_lint(heap_memory, span, m.as_slice());\n+            cx.span_lint(OWNED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(HEAP_MEMORY, span, m.as_slice());\n         }\n \n         if n_box > 0 {\n             let s = ty_to_str(cx.tcx, ty);\n             let m = format!(\"type uses managed (@ type) pointers: {}\", s);\n-            cx.span_lint(managed_heap_memory, span, m.as_slice());\n-            cx.span_lint(heap_memory, span, m.as_slice());\n+            cx.span_lint(MANAGED_HEAP_MEMORY, span, m.as_slice());\n+            cx.span_lint(HEAP_MEMORY, span, m.as_slice());\n         }\n     }\n }\n \n impl LintPass for HeapMemory {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(managed_heap_memory, owned_heap_memory, heap_memory)\n+        lint_array!(MANAGED_HEAP_MEMORY, OWNED_HEAP_MEMORY, HEAP_MEMORY)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -463,7 +463,7 @@ impl LintPass for HeapMemory {\n     }\n }\n \n-declare_lint!(raw_pointer_deriving, Warn,\n+declare_lint!(RAW_POINTER_DERIVING, Warn,\n     \"uses of #[deriving] with raw pointers are rarely correct\")\n \n struct RawPtrDerivingVisitor<'a> {\n@@ -474,7 +474,7 @@ impl<'a> visit::Visitor<()> for RawPtrDerivingVisitor<'a> {\n     fn visit_ty(&mut self, ty: &ast::Ty, _: ()) {\n         static MSG: &'static str = \"use of `#[deriving]` with a raw pointer\";\n         match ty.node {\n-            ast::TyPtr(..) => self.cx.span_lint(raw_pointer_deriving, ty.span, MSG),\n+            ast::TyPtr(..) => self.cx.span_lint(RAW_POINTER_DERIVING, ty.span, MSG),\n             _ => {}\n         }\n         visit::walk_ty(self, ty, ());\n@@ -498,7 +498,7 @@ impl RawPointerDeriving {\n \n impl LintPass for RawPointerDeriving {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(raw_pointer_deriving)\n+        lint_array!(RAW_POINTER_DERIVING)\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n@@ -531,14 +531,14 @@ impl LintPass for RawPointerDeriving {\n     }\n }\n \n-declare_lint!(unused_attribute, Warn,\n+declare_lint!(UNUSED_ATTRIBUTE, Warn,\n     \"detects attributes that were not used by the compiler\")\n \n pub struct UnusedAttribute;\n \n impl LintPass for UnusedAttribute {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unused_attribute)\n+        lint_array!(UNUSED_ATTRIBUTE)\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n@@ -598,35 +598,35 @@ impl LintPass for UnusedAttribute {\n         }\n \n         if !attr::is_used(attr) {\n-            cx.span_lint(unused_attribute, attr.span, \"unused attribute\");\n+            cx.span_lint(UNUSED_ATTRIBUTE, attr.span, \"unused attribute\");\n             if CRATE_ATTRS.contains(&attr.name().get()) {\n                 let msg = match attr.node.style {\n                    ast::AttrOuter => \"crate-level attribute should be an inner \\\n                                       attribute: add an exclamation mark: #![foo]\",\n                     ast::AttrInner => \"crate-level attribute should be in the \\\n                                        root module\",\n                 };\n-                cx.span_lint(unused_attribute, attr.span, msg);\n+                cx.span_lint(UNUSED_ATTRIBUTE, attr.span, msg);\n             }\n         }\n     }\n }\n \n-declare_lint!(path_statement, Warn,\n+declare_lint!(PATH_STATEMENT, Warn,\n     \"path statements with no effect\")\n \n pub struct PathStatement;\n \n impl LintPass for PathStatement {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(path_statement)\n+        lint_array!(PATH_STATEMENT)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n         match s.node {\n             ast::StmtSemi(expr, _) => {\n                 match expr.node {\n-                    ast::ExprPath(_) => cx.span_lint(path_statement, s.span,\n+                    ast::ExprPath(_) => cx.span_lint(PATH_STATEMENT, s.span,\n                                                      \"path statement with no effect\"),\n                     _ => ()\n                 }\n@@ -636,17 +636,17 @@ impl LintPass for PathStatement {\n     }\n }\n \n-declare_lint!(unused_must_use, Warn,\n+declare_lint!(UNUSED_MUST_USE, Warn,\n     \"unused result of a type flagged as #[must_use]\")\n \n-declare_lint!(unused_result, Allow,\n+declare_lint!(UNUSED_RESULT, Allow,\n     \"unused result of an expression in a statement\")\n \n pub struct UnusedResult;\n \n impl LintPass for UnusedResult {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unused_must_use, unused_result)\n+        lint_array!(UNUSED_MUST_USE, UNUSED_RESULT)\n     }\n \n     fn check_stmt(&mut self, cx: &Context, s: &ast::Stmt) {\n@@ -674,7 +674,7 @@ impl LintPass for UnusedResult {\n                         ast_map::NodeItem(it) => {\n                             if attr::contains_name(it.attrs.as_slice(),\n                                                    \"must_use\") {\n-                                cx.span_lint(unused_must_use, s.span,\n+                                cx.span_lint(UNUSED_MUST_USE, s.span,\n                                              \"unused result which must be used\");\n                                 warned = true;\n                             }\n@@ -684,7 +684,7 @@ impl LintPass for UnusedResult {\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n                         if attr::contains_name(attrs.as_slice(), \"must_use\") {\n-                            cx.span_lint(unused_must_use, s.span,\n+                            cx.span_lint(UNUSED_MUST_USE, s.span,\n                                          \"unused result which must be used\");\n                             warned = true;\n                         }\n@@ -694,27 +694,27 @@ impl LintPass for UnusedResult {\n             _ => {}\n         }\n         if !warned {\n-            cx.span_lint(unused_result, s.span, \"unused result\");\n+            cx.span_lint(UNUSED_RESULT, s.span, \"unused result\");\n         }\n     }\n }\n \n-declare_lint!(deprecated_owned_vector, Allow,\n+declare_lint!(DEPRECATED_OWNED_VECTOR, Allow,\n     \"use of a `~[T]` vector\")\n \n pub struct DeprecatedOwnedVector;\n \n impl LintPass for DeprecatedOwnedVector {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(deprecated_owned_vector)\n+        lint_array!(DEPRECATED_OWNED_VECTOR)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         let t = ty::expr_ty(cx.tcx, e);\n         match ty::get(t).sty {\n             ty::ty_uniq(t) => match ty::get(t).sty {\n                 ty::ty_vec(_, None) => {\n-                    cx.span_lint(deprecated_owned_vector, e.span,\n+                    cx.span_lint(DEPRECATED_OWNED_VECTOR, e.span,\n                         \"use of deprecated `~[]` vector; replaced by `std::vec::Vec`\")\n                 }\n                 _ => {}\n@@ -724,14 +724,14 @@ impl LintPass for DeprecatedOwnedVector {\n     }\n }\n \n-declare_lint!(non_camel_case_types, Warn,\n+declare_lint!(NON_CAMEL_CASE_TYPES, Warn,\n     \"types, variants and traits should have camel case names\")\n \n pub struct NonCamelCaseTypes;\n \n impl LintPass for NonCamelCaseTypes {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(non_camel_case_types)\n+        lint_array!(NON_CAMEL_CASE_TYPES)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -756,7 +756,7 @@ impl LintPass for NonCamelCaseTypes {\n             let s = token::get_ident(ident);\n \n             if !is_camel_case(ident) {\n-                cx.span_lint(non_camel_case_types, span,\n+                cx.span_lint(NON_CAMEL_CASE_TYPES, span,\n                     format!(\"{} `{}` should have a camel case name such as `{}`\",\n                         sort, s, to_camel_case(s.get())).as_slice());\n             }\n@@ -809,7 +809,7 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n     }\n }\n \n-declare_lint!(non_snake_case_functions, Warn,\n+declare_lint!(NON_SNAKE_CASE_FUNCTIONS, Warn,\n     \"methods and functions should have snake case names\")\n \n pub struct NonSnakeCaseFunctions;\n@@ -852,7 +852,7 @@ impl NonSnakeCaseFunctions {\n         let s = token::get_ident(ident);\n \n         if !is_snake_case(ident) {\n-            cx.span_lint(non_snake_case_functions, span,\n+            cx.span_lint(NON_SNAKE_CASE_FUNCTIONS, span,\n                 format!(\"{} `{}` should have a snake case name such as `{}`\",\n                     sort, s, to_snake_case(s.get())).as_slice());\n         }\n@@ -861,7 +861,7 @@ impl NonSnakeCaseFunctions {\n \n impl LintPass for NonSnakeCaseFunctions {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(non_snake_case_functions)\n+        lint_array!(NON_SNAKE_CASE_FUNCTIONS)\n     }\n \n     fn check_fn(&mut self, cx: &Context,\n@@ -886,14 +886,14 @@ impl LintPass for NonSnakeCaseFunctions {\n     }\n }\n \n-declare_lint!(non_uppercase_statics, Allow,\n+declare_lint!(NON_UPPERCASE_STATICS, Allow,\n     \"static constants should have uppercase identifiers\")\n \n pub struct NonUppercaseStatics;\n \n impl LintPass for NonUppercaseStatics {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(non_uppercase_statics)\n+        lint_array!(NON_UPPERCASE_STATICS)\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -905,7 +905,7 @@ impl LintPass for NonUppercaseStatics {\n                 // ones (some scripts don't have a concept of\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(non_uppercase_statics, it.span,\n+                    cx.span_lint(NON_UPPERCASE_STATICS, it.span,\n                         format!(\"static constant `{}` should have an uppercase name \\\n                             such as `{}`\", s.get(),\n                             s.get().chars().map(|c| c.to_uppercase())\n@@ -917,14 +917,14 @@ impl LintPass for NonUppercaseStatics {\n     }\n }\n \n-declare_lint!(non_uppercase_pattern_statics, Warn,\n+declare_lint!(NON_UPPERCASE_PATTERN_STATICS, Warn,\n     \"static constants in match patterns should be all caps\")\n \n pub struct NonUppercasePatternStatics;\n \n impl LintPass for NonUppercasePatternStatics {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(non_uppercase_pattern_statics)\n+        lint_array!(NON_UPPERCASE_PATTERN_STATICS)\n     }\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n@@ -935,7 +935,7 @@ impl LintPass for NonUppercasePatternStatics {\n                 let ident = path.segments.last().unwrap().identifier;\n                 let s = token::get_ident(ident);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n-                    cx.span_lint(non_uppercase_pattern_statics, path.span,\n+                    cx.span_lint(NON_UPPERCASE_PATTERN_STATICS, path.span,\n                         format!(\"static constant in pattern `{}` should have an uppercase \\\n                             name such as `{}`\", s.get(),\n                             s.get().chars().map(|c| c.to_uppercase())\n@@ -947,14 +947,14 @@ impl LintPass for NonUppercasePatternStatics {\n     }\n }\n \n-declare_lint!(uppercase_variables, Warn,\n+declare_lint!(UPPERCASE_VARIABLES, Warn,\n     \"variable and structure field names should start with a lowercase character\")\n \n pub struct UppercaseVariables;\n \n impl LintPass for UppercaseVariables {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(uppercase_variables)\n+        lint_array!(UPPERCASE_VARIABLES)\n     }\n \n     fn check_pat(&mut self, cx: &Context, p: &ast::Pat) {\n@@ -967,7 +967,7 @@ impl LintPass for UppercaseVariables {\n                         let ident = path.segments.last().unwrap().identifier;\n                         let s = token::get_ident(ident);\n                         if s.get().len() > 0 && s.get().char_at(0).is_uppercase() {\n-                            cx.span_lint(uppercase_variables, path.span,\n+                            cx.span_lint(UPPERCASE_VARIABLES, path.span,\n                                 \"variable names should start with a lowercase character\");\n                         }\n                     }\n@@ -985,7 +985,7 @@ impl LintPass for UppercaseVariables {\n                 ast::StructField_ { kind: ast::NamedField(ident, _), .. } => {\n                     let s = token::get_ident(ident);\n                     if s.get().char_at(0).is_uppercase() {\n-                        cx.span_lint(uppercase_variables, sf.span,\n+                        cx.span_lint(UPPERCASE_VARIABLES, sf.span,\n                             \"structure field names should start with a lowercase character\");\n                     }\n                 }\n@@ -995,7 +995,7 @@ impl LintPass for UppercaseVariables {\n     }\n }\n \n-declare_lint!(unnecessary_parens, Warn,\n+declare_lint!(UNNECESSARY_PARENS, Warn,\n     \"`if`, `match`, `while` and `return` do not need parentheses\")\n \n pub struct UnnecessaryParens;\n@@ -1004,7 +1004,7 @@ impl UnnecessaryParens {\n     fn check_unnecessary_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str) {\n         match value.node {\n             ast::ExprParen(_) => {\n-                cx.span_lint(unnecessary_parens, value.span,\n+                cx.span_lint(UNNECESSARY_PARENS, value.span,\n                     format!(\"unnecessary parentheses around {}\", msg).as_slice())\n             }\n             _ => {}\n@@ -1014,7 +1014,7 @@ impl UnnecessaryParens {\n \n impl LintPass for UnnecessaryParens {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unnecessary_parens)\n+        lint_array!(UNNECESSARY_PARENS)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1045,14 +1045,14 @@ impl LintPass for UnnecessaryParens {\n     }\n }\n \n-declare_lint!(unused_unsafe, Warn,\n+declare_lint!(UNUSED_UNSAFE, Warn,\n     \"unnecessary use of an `unsafe` block\")\n \n pub struct UnusedUnsafe;\n \n impl LintPass for UnusedUnsafe {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unused_unsafe)\n+        lint_array!(UNUSED_UNSAFE)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1061,36 +1061,36 @@ impl LintPass for UnusedUnsafe {\n             ast::ExprBlock(ref blk) => {\n                 if blk.rules == ast::UnsafeBlock(ast::UserProvided) &&\n                     !cx.tcx.used_unsafe.borrow().contains(&blk.id) {\n-                    cx.span_lint(unused_unsafe, blk.span, \"unnecessary `unsafe` block\");\n+                    cx.span_lint(UNUSED_UNSAFE, blk.span, \"unnecessary `unsafe` block\");\n                 }\n             }\n             _ => ()\n         }\n     }\n }\n \n-declare_lint!(unsafe_block, Allow,\n+declare_lint!(UNSAFE_BLOCK, Allow,\n     \"usage of an `unsafe` block\")\n \n pub struct UnsafeBlock;\n \n impl LintPass for UnsafeBlock {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unsafe_block)\n+        lint_array!(UNSAFE_BLOCK)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         match e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             ast::ExprBlock(ref blk) if blk.rules == ast::UnsafeBlock(ast::UserProvided) => {\n-                cx.span_lint(unsafe_block, blk.span, \"usage of an `unsafe` block\");\n+                cx.span_lint(UNSAFE_BLOCK, blk.span, \"usage of an `unsafe` block\");\n             }\n             _ => ()\n         }\n     }\n }\n \n-declare_lint!(unused_mut, Warn,\n+declare_lint!(UNUSED_MUT, Warn,\n     \"detect mut variables which don't need to be mutable\")\n \n pub struct UnusedMut;\n@@ -1124,7 +1124,7 @@ impl UnusedMut {\n         let used_mutables = cx.tcx.used_mut_nodes.borrow();\n         for (_, v) in mutables.iter() {\n             if !v.iter().any(|e| used_mutables.contains(e)) {\n-                cx.span_lint(unused_mut, cx.tcx.map.span(*v.get(0)),\n+                cx.span_lint(UNUSED_MUT, cx.tcx.map.span(*v.get(0)),\n                     \"variable does not need to be mutable\");\n             }\n         }\n@@ -1133,7 +1133,7 @@ impl UnusedMut {\n \n impl LintPass for UnusedMut {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unused_mut)\n+        lint_array!(UNUSED_MUT)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1175,14 +1175,14 @@ enum Allocation {\n     BoxAllocation\n }\n \n-declare_lint!(unnecessary_allocation, Warn,\n+declare_lint!(UNNECESSARY_ALLOCATION, Warn,\n     \"detects unnecessary allocations that can be eliminated\")\n \n pub struct UnnecessaryAllocation;\n \n impl LintPass for UnnecessaryAllocation {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(unnecessary_allocation)\n+        lint_array!(UNNECESSARY_ALLOCATION)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1210,17 +1210,17 @@ impl LintPass for UnnecessaryAllocation {\n                     ty::AutoDerefRef(ty::AutoDerefRef { autoref, .. }) => {\n                         match (allocation, autoref) {\n                             (VectorAllocation, Some(ty::AutoBorrowVec(..))) => {\n-                                cx.span_lint(unnecessary_allocation, e.span,\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                     \"unnecessary allocation, the sigil can be removed\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutImmutable))) => {\n-                                cx.span_lint(unnecessary_allocation, e.span,\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                     \"unnecessary allocation, use & instead\");\n                             }\n                             (BoxAllocation,\n                              Some(ty::AutoPtr(_, ast::MutMutable))) => {\n-                                cx.span_lint(unnecessary_allocation, e.span,\n+                                cx.span_lint(UNNECESSARY_ALLOCATION, e.span,\n                                     \"unnecessary allocation, use &mut instead\");\n                             }\n                             _ => ()\n@@ -1234,7 +1234,7 @@ impl LintPass for UnnecessaryAllocation {\n     }\n }\n \n-declare_lint!(missing_doc, Allow,\n+declare_lint!(MISSING_DOC, Allow,\n     \"detects missing documentation for public members\")\n \n pub struct MissingDoc {\n@@ -1291,15 +1291,15 @@ impl MissingDoc {\n             }\n         });\n         if !has_doc {\n-            cx.span_lint(missing_doc, sp,\n+            cx.span_lint(MISSING_DOC, sp,\n                 format!(\"missing documentation for {}\", desc).as_slice());\n         }\n     }\n }\n \n impl LintPass for MissingDoc {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(missing_doc)\n+        lint_array!(MISSING_DOC)\n     }\n \n     fn enter_lint_attrs(&mut self, _: &Context, attrs: &[ast::Attribute]) {\n@@ -1388,13 +1388,13 @@ impl LintPass for MissingDoc {\n     }\n }\n \n-declare_lint!(deprecated, Warn,\n+declare_lint!(DEPRECATED, Warn,\n     \"detects use of #[deprecated] items\")\n \n-declare_lint!(experimental, Warn,\n+declare_lint!(EXPERIMENTAL, Warn,\n     \"detects use of #[experimental] items\")\n \n-declare_lint!(unstable, Allow,\n+declare_lint!(UNSTABLE, Allow,\n     \"detects use of #[unstable] items (incl. items with no stability attribute)\")\n \n /// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n@@ -1403,7 +1403,7 @@ pub struct Stability;\n \n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(deprecated, experimental, unstable)\n+        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE)\n     }\n \n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n@@ -1474,13 +1474,13 @@ impl LintPass for Stability {\n \n         let (lint, label) = match stability {\n             // no stability attributes == Unstable\n-            None => (unstable, \"unmarked\"),\n+            None => (UNSTABLE, \"unmarked\"),\n             Some(attr::Stability { level: attr::Unstable, .. }) =>\n-                    (unstable, \"unstable\"),\n+                    (UNSTABLE, \"unstable\"),\n             Some(attr::Stability { level: attr::Experimental, .. }) =>\n-                    (experimental, \"experimental\"),\n+                    (EXPERIMENTAL, \"experimental\"),\n             Some(attr::Stability { level: attr::Deprecated, .. }) =>\n-                    (deprecated, \"deprecated\"),\n+                    (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n \n@@ -1495,40 +1495,40 @@ impl LintPass for Stability {\n     }\n }\n \n-declare_lint!(pub unused_imports, Warn,\n+declare_lint!(pub UNUSED_IMPORTS, Warn,\n     \"imports that are never used\")\n \n-declare_lint!(pub unnecessary_qualification, Allow,\n+declare_lint!(pub UNNECESSARY_QUALIFICATION, Allow,\n     \"detects unnecessarily qualified names\")\n \n-declare_lint!(pub unrecognized_lint, Warn,\n+declare_lint!(pub UNRECOGNIZED_LINT, Warn,\n     \"unrecognized lint attribute\")\n \n-declare_lint!(pub unused_variable, Warn,\n+declare_lint!(pub UNUSED_VARIABLE, Warn,\n     \"detect variables which are not used in any way\")\n \n-declare_lint!(pub dead_assignment, Warn,\n+declare_lint!(pub DEAD_ASSIGNMENT, Warn,\n     \"detect assignments that will never be read\")\n \n-declare_lint!(pub dead_code, Warn,\n+declare_lint!(pub DEAD_CODE, Warn,\n     \"detect piece of code that will never be used\")\n \n-declare_lint!(pub visible_private_types, Warn,\n+declare_lint!(pub VISIBLE_PRIVATE_TYPES, Warn,\n     \"detect use of private types in exported type signatures\")\n \n-declare_lint!(pub unreachable_code, Warn,\n+declare_lint!(pub UNREACHABLE_CODE, Warn,\n     \"detects unreachable code\")\n \n-declare_lint!(pub warnings, Warn,\n+declare_lint!(pub WARNINGS, Warn,\n     \"mass-change the level for lints which produce warnings\")\n \n-declare_lint!(pub unknown_features, Deny,\n+declare_lint!(pub UNKNOWN_FEATURES, Deny,\n     \"unknown features found in crate-level #[feature] directives\")\n \n-declare_lint!(pub unknown_crate_type, Deny,\n+declare_lint!(pub UNKNOWN_CRATE_TYPE, Deny,\n     \"unknown crate type found in #[crate_type] directive\")\n \n-declare_lint!(pub variant_size_difference, Allow,\n+declare_lint!(pub VARIANT_SIZE_DIFFERENCE, Allow,\n     \"detects enums with widely varying variant sizes\")\n \n /// Does nothing as a lint pass, but registers some `Lint`s\n@@ -1538,9 +1538,9 @@ pub struct HardwiredLints;\n impl LintPass for HardwiredLints {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(\n-            unused_imports, unnecessary_qualification, unrecognized_lint,\n-            unused_variable, dead_assignment, dead_code, visible_private_types,\n-            unreachable_code, warnings, unknown_features, unknown_crate_type,\n-            variant_size_difference)\n+            UNUSED_IMPORTS, UNNECESSARY_QUALIFICATION, UNRECOGNIZED_LINT,\n+            UNUSED_VARIABLE, DEAD_ASSIGNMENT, DEAD_CODE, VISIBLE_PRIVATE_TYPES,\n+            UNREACHABLE_CODE, WARNINGS, UNKNOWN_FEATURES, UNKNOWN_CRATE_TYPE,\n+            VARIANT_SIZE_DIFFERENCE)\n     }\n }"}, {"sha": "31e6f3907dcd4e3eca8018d2da7110a6b5fc92f9", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -264,7 +264,7 @@ impl<'a> Context<'a> {\n         let (level, src) = match self.lints.levels.find(&LintId::of(lint)) {\n             None => return,\n             Some(&(Warn, src)) => {\n-                let lint_id = LintId::of(builtin::warnings);\n+                let lint_id = LintId::of(builtin::WARNINGS);\n                 (self.lints.get_level_source(lint_id).val0(), src)\n             }\n             Some(&pair) => pair,\n@@ -359,7 +359,7 @@ impl<'a> Context<'a> {\n                         match self.lints.by_name.find_equiv(&lint_name.get()) {\n                             Some(lint_id) => out.push((*lint_id, level, meta.span)),\n \n-                            None => self.span_lint(builtin::unrecognized_lint,\n+                            None => self.span_lint(builtin::UNRECOGNIZED_LINT,\n                                 meta.span,\n                                 format!(\"unknown `{}` attribute: `{}`\",\n                                     level.as_str(), lint_name).as_slice()),\n@@ -588,7 +588,7 @@ impl LintPass for GatherNodeLevels {\n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n         match it.node {\n             ast::ItemEnum(..) => {\n-                let lint_id = LintId::of(builtin::variant_size_difference);\n+                let lint_id = LintId::of(builtin::VARIANT_SIZE_DIFFERENCE);\n                 match cx.lints.get_level_source(lint_id) {\n                     lvlsrc @ (lvl, _) if lvl != Allow => {\n                         cx.node_levels.borrow_mut()"}, {"sha": "50ba073aafc21a96685f6f6b68e8bb620409a817", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -461,7 +461,7 @@ impl<'a> DeadVisitor<'a> {\n                       ident: ast::Ident) {\n         self.tcx\n             .sess\n-            .add_lint(lint::builtin::dead_code,\n+            .add_lint(lint::builtin::DEAD_CODE,\n                       id,\n                       span,\n                       format!(\"code is never used: `{}`\","}, {"sha": "f09af6ea4416e415157168443bdaeb2fa6289763", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -1560,11 +1560,11 @@ impl<'a> Liveness<'a> {\n                 };\n \n                 if is_assigned {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::unused_variable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n                         format!(\"variable `{}` is assigned to, but never used\",\n                                 *name));\n                 } else {\n-                    self.ir.tcx.sess.add_lint(lint::builtin::unused_variable, id, sp,\n+                    self.ir.tcx.sess.add_lint(lint::builtin::UNUSED_VARIABLE, id, sp,\n                         format!(\"unused variable: `{}`\", *name));\n                 }\n             }\n@@ -1582,7 +1582,7 @@ impl<'a> Liveness<'a> {\n         if self.live_on_exit(ln, var).is_none() {\n             let r = self.should_warn(var);\n             for name in r.iter() {\n-                self.ir.tcx.sess.add_lint(lint::builtin::dead_assignment, id, sp,\n+                self.ir.tcx.sess.add_lint(lint::builtin::DEAD_ASSIGNMENT, id, sp,\n                     format!(\"value assigned to `{}` is never read\", *name));\n             }\n         }"}, {"sha": "414aac47cdcc0882719525d04160e9e6bf1fabc3", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -1394,7 +1394,7 @@ impl<'a> Visitor<()> for VisiblePrivateTypesVisitor<'a> {\n             ast::TyPath(ref p, _, path_id) => {\n                 if self.path_is_private_type(path_id) {\n                     self.tcx.sess.add_lint(\n-                        lint::builtin::visible_private_types,\n+                        lint::builtin::VISIBLE_PRIVATE_TYPES,\n                         path_id, p.span,\n                         \"private type in exported type \\\n                          signature\".to_string());"}, {"sha": "2329d5d685d66a8172742f0cba821ba29e9b62d7", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -4632,7 +4632,7 @@ impl<'a> Resolver<'a> {\n             match (def, unqualified_def) {\n                 (Some((d, _)), Some((ud, _))) if d == ud => {\n                     self.session\n-                        .add_lint(lint::builtin::unnecessary_qualification,\n+                        .add_lint(lint::builtin::UNNECESSARY_QUALIFICATION,\n                                   id,\n                                   path.span,\n                                   \"unnecessary qualification\".to_string());\n@@ -5487,7 +5487,7 @@ impl<'a> Resolver<'a> {\n                         if !self.used_imports.contains(&(id, TypeNS)) &&\n                            !self.used_imports.contains(&(id, ValueNS)) {\n                             self.session\n-                                .add_lint(lint::builtin::unused_imports,\n+                                .add_lint(lint::builtin::UNUSED_IMPORTS,\n                                           id,\n                                           p.span,\n                                           \"unused import\".to_string());\n@@ -5511,7 +5511,7 @@ impl<'a> Resolver<'a> {\n \n         if !self.used_imports.contains(&(id, TypeNS)) &&\n            !self.used_imports.contains(&(id, ValueNS)) {\n-            self.session.add_lint(lint::builtin::unused_imports,\n+            self.session.add_lint(lint::builtin::UNUSED_IMPORTS,\n                                   id,\n                                   span,\n                                   \"unused import\".to_string());"}, {"sha": "9c38fa938b5b45a873bbb819031e78ee16f13b2a", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -1553,7 +1553,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     let mut sizes = Vec::new(); // does no allocation if no pushes, thankfully\n \n     let levels = ccx.tcx.node_lint_levels.borrow();\n-    let lint_id = lint::LintId::of(lint::builtin::variant_size_difference);\n+    let lint_id = lint::LintId::of(lint::builtin::VARIANT_SIZE_DIFFERENCE);\n     let lvlsrc = match levels.find(&(id, lint_id)) {\n         None | Some(&(lint::Allow, _)) => return,\n         Some(&lvlsrc) => lvlsrc,\n@@ -1590,7 +1590,7 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n     if largest > slargest * 3 && slargest > 0 {\n         // Use lint::raw_emit_lint rather than sess.add_lint because the lint-printing\n         // pass for the latter already ran.\n-        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::variant_size_difference,\n+        lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCE,\n             lvlsrc, Some(sp),\n             format!(\"enum variant is more than three times larger \\\n                      ({} bytes) than the next largest (ignoring padding)\","}, {"sha": "9d155ef31f98438790959f3565e5285f7c702001", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -3416,7 +3416,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(lint::builtin::unreachable_code,\n+                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n                              s_id,\n                              s.span,\n                              \"unreachable statement\".to_string());\n@@ -3443,7 +3443,7 @@ pub fn check_block_with_expected(fcx: &FnCtxt,\n                 fcx.ccx\n                    .tcx\n                    .sess\n-                   .add_lint(lint::builtin::unreachable_code,\n+                   .add_lint(lint::builtin::UNREACHABLE_CODE,\n                              e.id,\n                              e.span,\n                              \"unreachable expression\".to_string());"}, {"sha": "ba0161da7e664054f9affe3d72cfc5c6c932c030", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b5542f7f5b1eb11430960687f69b5766857efaa0/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=b5542f7f5b1eb11430960687f69b5766857efaa0", "patch": "@@ -75,7 +75,7 @@ fn get_ast_and_resolve(cpath: &Path, libs: HashSet<Path>, cfgs: Vec<String>)\n \n     let input = FileInput(cpath.clone());\n \n-    let warning_lint = lint::builtin::warnings.name.to_string();\n+    let warning_lint = lint::builtin::WARNINGS.name_lower();\n \n     let sessopts = driver::config::Options {\n         maybe_sysroot: Some(os::self_exe_path().unwrap().dir_path()),"}]}