{"sha": "4f7612ac1499258025077f1fd05d2f429f9accfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmNzYxMmFjMTQ5OTI1ODAyNTA3N2YxZmQwNWQyZjQyOWY5YWNjZmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-31T17:09:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-31T17:09:38Z"}, "message": "Auto merge of #78594 - m-ou-se:rollup-h5c8frs, r=m-ou-se\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #74622 (Add std::panic::panic_any.)\n - #77099 (make exp_m1 and ln_1p examples more representative of use)\n - #78526 (Strip tokens from trait and impl items before printing AST JSON)\n - #78550 (x.py setup: Create config.toml in the current directory, not the top-level directory)\n - #78577 (validator: Extend aliasing check to a call terminator)\n - #78581 (Constantify more BTreeMap and BTreeSet functions)\n - #78587 (parser: Cleanup `LazyTokenStream` and avoid some clones)\n\nFailed merges:\n\nr? `@ghost`", "tree": {"sha": "314e6ed97dbc2ace70df03241836406f6558989d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/314e6ed97dbc2ace70df03241836406f6558989d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f7612ac1499258025077f1fd05d2f429f9accfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f7612ac1499258025077f1fd05d2f429f9accfb", "html_url": "https://github.com/rust-lang/rust/commit/4f7612ac1499258025077f1fd05d2f429f9accfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f7612ac1499258025077f1fd05d2f429f9accfb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3478d7c3607ffbba629af2265c01002771e48c18", "url": "https://api.github.com/repos/rust-lang/rust/commits/3478d7c3607ffbba629af2265c01002771e48c18", "html_url": "https://github.com/rust-lang/rust/commit/3478d7c3607ffbba629af2265c01002771e48c18"}, {"sha": "1873ca55b3fa296a149eaf57b975583dc40cf67b", "url": "https://api.github.com/repos/rust-lang/rust/commits/1873ca55b3fa296a149eaf57b975583dc40cf67b", "html_url": "https://github.com/rust-lang/rust/commit/1873ca55b3fa296a149eaf57b975583dc40cf67b"}], "stats": {"total": 332, "additions": 219, "deletions": 113}, "files": [{"sha": "b53acb97aeb9e6596601cdef63713a8d839c99b9", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 22, "deletions": 43, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -22,7 +22,7 @@ use rustc_serialize::{Decodable, Decoder, Encodable, Encoder};\n use rustc_span::{Span, DUMMY_SP};\n use smallvec::{smallvec, SmallVec};\n \n-use std::{iter, mem};\n+use std::{fmt, iter, mem};\n \n /// When the main rust parser encounters a syntax-extension invocation, it\n /// parses the arguments to the invocation as a token-tree. This is a very\n@@ -120,72 +120,51 @@ where\n     }\n }\n \n-// A cloneable callback which produces a `TokenStream`. Each clone\n-// of this should produce the same `TokenStream`\n-pub trait CreateTokenStream: sync::Send + sync::Sync + FnOnce() -> TokenStream {\n-    // Workaround for the fact that `Clone` is not object-safe\n-    fn clone_it(&self) -> Box<dyn CreateTokenStream>;\n+pub trait CreateTokenStream: sync::Send + sync::Sync {\n+    fn create_token_stream(&self) -> TokenStream;\n }\n \n-impl<F: 'static + Clone + sync::Send + sync::Sync + FnOnce() -> TokenStream> CreateTokenStream\n-    for F\n-{\n-    fn clone_it(&self) -> Box<dyn CreateTokenStream> {\n-        Box::new(self.clone())\n-    }\n-}\n-\n-impl Clone for Box<dyn CreateTokenStream> {\n-    fn clone(&self) -> Self {\n-        let val: &(dyn CreateTokenStream) = &**self;\n-        val.clone_it()\n+impl CreateTokenStream for TokenStream {\n+    fn create_token_stream(&self) -> TokenStream {\n+        self.clone()\n     }\n }\n \n-/// A lazy version of `TokenStream`, which may defer creation\n+/// A lazy version of `TokenStream`, which defers creation\n /// of an actual `TokenStream` until it is needed.\n-pub type LazyTokenStream = Lrc<LazyTokenStreamInner>;\n-\n+/// `Box` is here only to reduce the structure size.\n #[derive(Clone)]\n-pub enum LazyTokenStreamInner {\n-    Lazy(Box<dyn CreateTokenStream>),\n-    Ready(TokenStream),\n-}\n+pub struct LazyTokenStream(Lrc<Box<dyn CreateTokenStream>>);\n \n-impl std::fmt::Debug for LazyTokenStreamInner {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            LazyTokenStreamInner::Lazy(..) => f.debug_struct(\"LazyTokenStream::Lazy\").finish(),\n-            LazyTokenStreamInner::Ready(..) => f.debug_struct(\"LazyTokenStream::Ready\").finish(),\n-        }\n+impl LazyTokenStream {\n+    pub fn new(inner: impl CreateTokenStream + 'static) -> LazyTokenStream {\n+        LazyTokenStream(Lrc::new(Box::new(inner)))\n+    }\n+\n+    pub fn create_token_stream(&self) -> TokenStream {\n+        self.0.create_token_stream()\n     }\n }\n \n-impl LazyTokenStreamInner {\n-    pub fn into_token_stream(&self) -> TokenStream {\n-        match self {\n-            // Note that we do not cache this. If this ever becomes a performance\n-            // problem, we should investigate wrapping `LazyTokenStreamInner`\n-            // in a lock\n-            LazyTokenStreamInner::Lazy(cb) => (cb.clone())(),\n-            LazyTokenStreamInner::Ready(stream) => stream.clone(),\n-        }\n+impl fmt::Debug for LazyTokenStream {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Debug::fmt(\"LazyTokenStream\", f)\n     }\n }\n \n-impl<S: Encoder> Encodable<S> for LazyTokenStreamInner {\n+impl<S: Encoder> Encodable<S> for LazyTokenStream {\n     fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n         panic!(\"Attempted to encode LazyTokenStream\");\n     }\n }\n \n-impl<D: Decoder> Decodable<D> for LazyTokenStreamInner {\n+impl<D: Decoder> Decodable<D> for LazyTokenStream {\n     fn decode(_d: &mut D) -> Result<Self, D::Error> {\n         panic!(\"Attempted to decode LazyTokenStream\");\n     }\n }\n \n-impl<CTX> HashStable<CTX> for LazyTokenStreamInner {\n+impl<CTX> HashStable<CTX> for LazyTokenStream {\n     fn hash_stable(&self, _hcx: &mut CTX, _hasher: &mut StableHasher) {\n         panic!(\"Attempted to compute stable hash for LazyTokenStream\");\n     }"}, {"sha": "c124ab64218620600bd93b11c33790a9bff22bd0", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -4,12 +4,11 @@ use rustc_ast::attr::HasAttrs;\n use rustc_ast::mut_visit::*;\n use rustc_ast::ptr::P;\n use rustc_ast::token::{DelimToken, Token, TokenKind};\n-use rustc_ast::tokenstream::{DelimSpan, LazyTokenStreamInner, Spacing, TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{DelimSpan, LazyTokenStream, Spacing, TokenStream, TokenTree};\n use rustc_ast::{self as ast, AttrItem, Attribute, MetaItem};\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n@@ -303,7 +302,7 @@ impl<'a> StripUnconfigured<'a> {\n \n                 // Use the `#` in `#[cfg_attr(pred, attr)]` as the `#` token\n                 // for `attr` when we expand it to `#[attr]`\n-                let pound_token = orig_tokens.into_token_stream().trees().next().unwrap();\n+                let pound_token = orig_tokens.create_token_stream().trees().next().unwrap();\n                 if !matches!(pound_token, TokenTree::Token(Token { kind: TokenKind::Pound, .. })) {\n                     panic!(\"Bad tokens for attribute {:?}\", attr);\n                 }\n@@ -313,16 +312,16 @@ impl<'a> StripUnconfigured<'a> {\n                     DelimSpan::from_single(pound_token.span()),\n                     DelimToken::Bracket,\n                     item.tokens\n-                        .clone()\n+                        .as_ref()\n                         .unwrap_or_else(|| panic!(\"Missing tokens for {:?}\", item))\n-                        .into_token_stream(),\n+                        .create_token_stream(),\n                 );\n \n                 let mut attr = attr::mk_attr_from_item(attr.style, item, span);\n-                attr.tokens = Some(Lrc::new(LazyTokenStreamInner::Ready(TokenStream::new(vec![\n+                attr.tokens = Some(LazyTokenStream::new(TokenStream::new(vec![\n                     (pound_token, Spacing::Alone),\n                     (bracket_group, Spacing::Alone),\n-                ]))));\n+                ])));\n                 self.process_cfg_attr(attr)\n             })\n             .collect()"}, {"sha": "a1487aa0060d5fe08000d8863f2874928dd842b1", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -70,6 +70,17 @@ impl mut_visit::MutVisitor for TokenStripper {\n         i.tokens = None;\n         mut_visit::noop_flat_map_foreign_item(i, self)\n     }\n+    fn flat_map_trait_item(\n+        &mut self,\n+        mut i: P<ast::AssocItem>,\n+    ) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        i.tokens = None;\n+        mut_visit::noop_flat_map_assoc_item(i, self)\n+    }\n+    fn flat_map_impl_item(&mut self, mut i: P<ast::AssocItem>) -> SmallVec<[P<ast::AssocItem>; 1]> {\n+        i.tokens = None;\n+        mut_visit::noop_flat_map_assoc_item(i, self)\n+    }\n     fn visit_block(&mut self, b: &mut P<ast::Block>) {\n         b.tokens = None;\n         mut_visit::noop_visit_block(b, self);"}, {"sha": "ecdd0c517ef4f6ed57fb7a947ca22220170f4bf5", "filename": "compiler/rustc_mir/src/transform/validate.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fvalidate.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -10,8 +10,8 @@ use rustc_middle::mir::{\n     visit::{PlaceContext, Visitor},\n };\n use rustc_middle::mir::{\n-    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, Rvalue,\n-    SourceScope, Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n+    AggregateKind, BasicBlock, Body, BorrowKind, Local, Location, MirPhase, Operand, PlaceRef,\n+    Rvalue, SourceScope, Statement, StatementKind, Terminator, TerminatorKind, VarDebugInfo,\n };\n use rustc_middle::ty::relate::{Relate, RelateResult, TypeRelation};\n use rustc_middle::ty::{self, ParamEnv, Ty, TyCtxt};\n@@ -46,8 +46,16 @@ impl<'tcx> MirPass<'tcx> for Validator {\n             .iterate_to_fixpoint()\n             .into_results_cursor(body);\n \n-        TypeChecker { when: &self.when, body, tcx, param_env, mir_phase, storage_liveness }\n-            .visit_body(body);\n+        TypeChecker {\n+            when: &self.when,\n+            body,\n+            tcx,\n+            param_env,\n+            mir_phase,\n+            storage_liveness,\n+            place_cache: Vec::new(),\n+        }\n+        .visit_body(body);\n     }\n }\n \n@@ -150,6 +158,7 @@ struct TypeChecker<'a, 'tcx> {\n     param_env: ParamEnv<'tcx>,\n     mir_phase: MirPhase,\n     storage_liveness: ResultsCursor<'a, 'tcx, MaybeStorageLive>,\n+    place_cache: Vec<PlaceRef<'tcx>>,\n }\n \n impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n@@ -391,7 +400,7 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                     self.check_edge(location, *unwind, EdgeKind::Unwind);\n                 }\n             }\n-            TerminatorKind::Call { func, destination, cleanup, .. } => {\n+            TerminatorKind::Call { func, args, destination, cleanup, .. } => {\n                 let func_ty = func.ty(&self.body.local_decls, self.tcx);\n                 match func_ty.kind() {\n                     ty::FnPtr(..) | ty::FnDef(..) => {}\n@@ -406,6 +415,32 @@ impl<'a, 'tcx> Visitor<'tcx> for TypeChecker<'a, 'tcx> {\n                 if let Some(cleanup) = cleanup {\n                     self.check_edge(location, *cleanup, EdgeKind::Unwind);\n                 }\n+\n+                // The call destination place and Operand::Move place used as an argument might be\n+                // passed by a reference to the callee. Consequently they must be non-overlapping.\n+                // Currently this simply checks for duplicate places.\n+                self.place_cache.clear();\n+                if let Some((destination, _)) = destination {\n+                    self.place_cache.push(destination.as_ref());\n+                }\n+                for arg in args {\n+                    if let Operand::Move(place) = arg {\n+                        self.place_cache.push(place.as_ref());\n+                    }\n+                }\n+                let all_len = self.place_cache.len();\n+                self.place_cache.sort_unstable();\n+                self.place_cache.dedup();\n+                let has_duplicates = all_len != self.place_cache.len();\n+                if has_duplicates {\n+                    self.fail(\n+                        location,\n+                        format!(\n+                            \"encountered overlapping memory in `Call` terminator: {:?}\",\n+                            terminator.kind,\n+                        ),\n+                    );\n+                }\n             }\n             TerminatorKind::Assert { cond, target, cleanup, .. } => {\n                 let cond_ty = cond.ty(&self.body.local_decls, self.tcx);"}, {"sha": "e851451269e324809e349a23f249abe4b84028a9", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -249,29 +249,30 @@ pub fn nt_to_tokenstream(nt: &Nonterminal, sess: &ParseSess, span: Span) -> Toke\n     // came from. Here we attempt to extract these lossless token streams\n     // before we fall back to the stringification.\n \n-    let convert_tokens = |tokens: Option<LazyTokenStream>| tokens.map(|t| t.into_token_stream());\n+    let convert_tokens =\n+        |tokens: &Option<LazyTokenStream>| tokens.as_ref().map(|t| t.create_token_stream());\n \n     let tokens = match *nt {\n         Nonterminal::NtItem(ref item) => prepend_attrs(&item.attrs, item.tokens.as_ref()),\n-        Nonterminal::NtBlock(ref block) => convert_tokens(block.tokens.clone()),\n+        Nonterminal::NtBlock(ref block) => convert_tokens(&block.tokens),\n         Nonterminal::NtStmt(ref stmt) => {\n             // FIXME: We currently only collect tokens for `:stmt`\n             // matchers in `macro_rules!` macros. When we start collecting\n             // tokens for attributes on statements, we will need to prepend\n             // attributes here\n-            convert_tokens(stmt.tokens.clone())\n+            convert_tokens(&stmt.tokens)\n         }\n-        Nonterminal::NtPat(ref pat) => convert_tokens(pat.tokens.clone()),\n-        Nonterminal::NtTy(ref ty) => convert_tokens(ty.tokens.clone()),\n+        Nonterminal::NtPat(ref pat) => convert_tokens(&pat.tokens),\n+        Nonterminal::NtTy(ref ty) => convert_tokens(&ty.tokens),\n         Nonterminal::NtIdent(ident, is_raw) => {\n             Some(tokenstream::TokenTree::token(token::Ident(ident.name, is_raw), ident.span).into())\n         }\n         Nonterminal::NtLifetime(ident) => {\n             Some(tokenstream::TokenTree::token(token::Lifetime(ident.name), ident.span).into())\n         }\n-        Nonterminal::NtMeta(ref attr) => convert_tokens(attr.tokens.clone()),\n-        Nonterminal::NtPath(ref path) => convert_tokens(path.tokens.clone()),\n-        Nonterminal::NtVis(ref vis) => convert_tokens(vis.tokens.clone()),\n+        Nonterminal::NtMeta(ref attr) => convert_tokens(&attr.tokens),\n+        Nonterminal::NtPath(ref path) => convert_tokens(&path.tokens),\n+        Nonterminal::NtVis(ref vis) => convert_tokens(&vis.tokens),\n         Nonterminal::NtTT(ref tt) => Some(tt.clone().into()),\n         Nonterminal::NtExpr(ref expr) | Nonterminal::NtLiteral(ref expr) => {\n             if expr.tokens.is_none() {\n@@ -604,7 +605,7 @@ fn prepend_attrs(\n     attrs: &[ast::Attribute],\n     tokens: Option<&tokenstream::LazyTokenStream>,\n ) -> Option<tokenstream::TokenStream> {\n-    let tokens = tokens?.clone().into_token_stream();\n+    let tokens = tokens?.create_token_stream();\n     if attrs.is_empty() {\n         return Some(tokens);\n     }\n@@ -617,9 +618,9 @@ fn prepend_attrs(\n         );\n         builder.push(\n             attr.tokens\n-                .clone()\n+                .as_ref()\n                 .unwrap_or_else(|| panic!(\"Attribute {:?} is missing tokens!\", attr))\n-                .into_token_stream(),\n+                .create_token_stream(),\n         );\n     }\n     builder.push(tokens);"}, {"sha": "da1c54e88b5e20ea997054a67c34485e23d3ac56", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -16,8 +16,8 @@ pub use path::PathStyle;\n \n use rustc_ast::ptr::P;\n use rustc_ast::token::{self, DelimToken, Token, TokenKind};\n-use rustc_ast::tokenstream::{self, DelimSpan, LazyTokenStream, LazyTokenStreamInner, Spacing};\n-use rustc_ast::tokenstream::{TokenStream, TokenTree};\n+use rustc_ast::tokenstream::{self, DelimSpan, LazyTokenStream, Spacing};\n+use rustc_ast::tokenstream::{CreateTokenStream, TokenStream, TokenTree};\n use rustc_ast::DUMMY_NODE_ID;\n use rustc_ast::{self as ast, AnonConst, AttrStyle, AttrVec, Const, CrateSugar, Extern, Unsafe};\n use rustc_ast::{Async, Expr, ExprKind, MacArgs, MacDelimiter, Mutability, StrLit};\n@@ -1199,15 +1199,12 @@ impl<'a> Parser<'a> {\n         f: impl FnOnce(&mut Self) -> PResult<'a, R>,\n     ) -> PResult<'a, (R, Option<LazyTokenStream>)> {\n         let start_token = (self.token.clone(), self.token_spacing);\n-        let mut cursor_snapshot = self.token_cursor.clone();\n+        let cursor_snapshot = self.token_cursor.clone();\n \n         let ret = f(self)?;\n \n-        let new_calls = self.token_cursor.num_next_calls;\n-        let num_calls = new_calls - cursor_snapshot.num_next_calls;\n-        let desugar_doc_comments = self.desugar_doc_comments;\n-\n         // We didn't capture any tokens\n+        let num_calls = self.token_cursor.num_next_calls - cursor_snapshot.num_next_calls;\n         if num_calls == 0 {\n             return Ok((ret, None));\n         }\n@@ -1220,27 +1217,41 @@ impl<'a> Parser<'a> {\n         //\n         // This also makes `Parser` very cheap to clone, since\n         // there is no intermediate collection buffer to clone.\n-        let lazy_cb = move || {\n-            // The token produced by the final call to `next` or `next_desugared`\n-            // was not actually consumed by the callback. The combination\n-            // of chaining the initial token and using `take` produces the desired\n-            // result - we produce an empty `TokenStream` if no calls were made,\n-            // and omit the final token otherwise.\n-            let tokens = std::iter::once(start_token)\n-                .chain((0..num_calls).map(|_| {\n-                    if desugar_doc_comments {\n-                        cursor_snapshot.next_desugared()\n-                    } else {\n-                        cursor_snapshot.next()\n-                    }\n-                }))\n-                .take(num_calls);\n+        struct LazyTokenStreamImpl {\n+            start_token: (Token, Spacing),\n+            cursor_snapshot: TokenCursor,\n+            num_calls: usize,\n+            desugar_doc_comments: bool,\n+        }\n+        impl CreateTokenStream for LazyTokenStreamImpl {\n+            fn create_token_stream(&self) -> TokenStream {\n+                // The token produced by the final call to `next` or `next_desugared`\n+                // was not actually consumed by the callback. The combination\n+                // of chaining the initial token and using `take` produces the desired\n+                // result - we produce an empty `TokenStream` if no calls were made,\n+                // and omit the final token otherwise.\n+                let mut cursor_snapshot = self.cursor_snapshot.clone();\n+                let tokens = std::iter::once(self.start_token.clone())\n+                    .chain((0..self.num_calls).map(|_| {\n+                        if self.desugar_doc_comments {\n+                            cursor_snapshot.next_desugared()\n+                        } else {\n+                            cursor_snapshot.next()\n+                        }\n+                    }))\n+                    .take(self.num_calls);\n \n-            make_token_stream(tokens)\n-        };\n-        let stream = LazyTokenStream::new(LazyTokenStreamInner::Lazy(Box::new(lazy_cb)));\n+                make_token_stream(tokens)\n+            }\n+        }\n \n-        Ok((ret, Some(stream)))\n+        let lazy_impl = LazyTokenStreamImpl {\n+            start_token,\n+            cursor_snapshot,\n+            num_calls,\n+            desugar_doc_comments: self.desugar_doc_comments,\n+        };\n+        Ok((ret, Some(LazyTokenStream::new(lazy_impl))))\n     }\n \n     /// `::{` or `::*`"}, {"sha": "07c23d29e20a6364efae2bca144cace2799805da", "filename": "library/alloc/src/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -2188,7 +2188,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(a.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn len(&self) -> usize {\n         self.length\n     }\n \n@@ -2207,7 +2208,8 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert!(!a.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n "}, {"sha": "09aabdcd0fb27b7c2103f453665875256116507d", "filename": "library/alloc/src/collections/btree/map/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fmap%2Ftests.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -1527,6 +1527,13 @@ fn test_send() {\n     }\n }\n \n+#[allow(dead_code)]\n+fn test_const() {\n+    const MAP: &'static BTreeMap<(), ()> = &BTreeMap::new();\n+    const LEN: usize = MAP.len();\n+    const IS_EMPTY: bool = MAP.is_empty();\n+}\n+\n #[test]\n fn test_occupied_entry_key() {\n     let mut a = BTreeMap::new();"}, {"sha": "684019f8f5f5e02c6afa472a5a960686a1d46e59", "filename": "library/alloc/src/collections/btree/set.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -950,7 +950,8 @@ impl<T> BTreeSet<T> {\n     /// assert_eq!(v.len(), 1);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn len(&self) -> usize {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn len(&self) -> usize {\n         self.map.len()\n     }\n \n@@ -967,7 +968,8 @@ impl<T> BTreeSet<T> {\n     /// assert!(!v.is_empty());\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn is_empty(&self) -> bool {\n+    #[rustc_const_unstable(feature = \"const_btree_new\", issue = \"71835\")]\n+    pub const fn is_empty(&self) -> bool {\n         self.len() == 0\n     }\n }"}, {"sha": "2069cde4dba3b7aa72ce98c393d54b87482c08fe", "filename": "library/alloc/src/collections/btree/set/tests.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fset%2Ftests.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -15,6 +15,13 @@ fn test_clone_eq() {\n     assert_eq!(m.clone(), m);\n }\n \n+#[allow(dead_code)]\n+fn test_const() {\n+    const SET: &'static BTreeSet<()> = &BTreeSet::new();\n+    const LEN: usize = SET.len();\n+    const IS_EMPTY: bool = SET.is_empty();\n+}\n+\n #[test]\n fn test_iter_min_max() {\n     let mut a = BTreeSet::new();"}, {"sha": "2a54b117ff4f8eab5bd2be2d4ca340d27f795a4f", "filename": "library/std/src/f32.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff32.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -719,12 +719,13 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x = 6.0f32;\n+    /// let x = 1e-8_f32;\n     ///\n-    /// // e^(ln(6)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 5.0).abs();\n+    /// // for very small x, e^x is approximately 1 + x + x^2 / 2\n+    /// let approx = x + x * x / 2.0;\n+    /// let abs_difference = (x.exp_m1() - approx).abs();\n     ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n+    /// assert!(abs_difference < 1e-10);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -739,12 +740,13 @@ impl f32 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x = std::f32::consts::E - 1.0;\n+    /// let x = 1e-8_f32;\n     ///\n-    /// // ln(1 + (e - 1)) == ln(e) == 1\n-    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n+    /// // for very small x, ln(1 + x) is approximately x - x^2 / 2\n+    /// let approx = x - x * x / 2.0;\n+    /// let abs_difference = (x.ln_1p() - approx).abs();\n     ///\n-    /// assert!(abs_difference <= f32::EPSILON);\n+    /// assert!(abs_difference < 1e-10);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "363d1a0047613134669dfb8f3de7745c45d4d43d", "filename": "library/std/src/f64.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ff64.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -721,12 +721,13 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x = 7.0_f64;\n+    /// let x = 1e-16_f64;\n     ///\n-    /// // e^(ln(7)) - 1\n-    /// let abs_difference = (x.ln().exp_m1() - 6.0).abs();\n+    /// // for very small x, e^x is approximately 1 + x + x^2 / 2\n+    /// let approx = x + x * x / 2.0;\n+    /// let abs_difference = (x.exp_m1() - approx).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference < 1e-20);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -741,12 +742,13 @@ impl f64 {\n     /// # Examples\n     ///\n     /// ```\n-    /// let x = std::f64::consts::E - 1.0;\n+    /// let x = 1e-16_f64;\n     ///\n-    /// // ln(1 + (e - 1)) == ln(e) == 1\n-    /// let abs_difference = (x.ln_1p() - 1.0).abs();\n+    /// // for very small x, ln(1 + x) is approximately x - x^2 / 2\n+    /// let approx = x - x * x / 2.0;\n+    /// let abs_difference = (x.ln_1p() - approx).abs();\n     ///\n-    /// assert!(abs_difference < 1e-10);\n+    /// assert!(abs_difference < 1e-20);\n     /// ```\n     #[must_use = \"method returns a new number and does not mutate the original value\"]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d18b94b6c1aefc284e54433053c3209f4da5afd5", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -23,6 +23,20 @@ pub use crate::panicking::{set_hook, take_hook};\n #[stable(feature = \"panic_hooks\", since = \"1.10.0\")]\n pub use core::panic::{Location, PanicInfo};\n \n+/// Panic the current thread with the given message as the panic payload.\n+///\n+/// The message can be of any (`Any + Send`) type, not just strings.\n+///\n+/// The message is wrapped in a `Box<'static + Any + Send>`, which can be\n+/// accessed later using [`PanicInfo::payload`].\n+///\n+/// See the [`panic!`] macro for more information about panicking.\n+#[unstable(feature = \"panic_any\", issue = \"78500\")]\n+#[inline]\n+pub fn panic_any<M: Any + Send>(msg: M) -> ! {\n+    crate::panicking::begin_panic(msg);\n+}\n+\n /// A marker trait which represents \"panic safe\" types in Rust.\n ///\n /// This trait is implemented by default for many types and behaves similarly in"}, {"sha": "f5ce45a5bd11b38cbd6899603287b3001b0a020d", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -89,7 +89,7 @@ pub fn setup(src_path: &Path, profile: Profile) {\n         std::process::exit(1);\n     }\n \n-    let path = cfg_file.unwrap_or_else(|| src_path.join(\"config.toml\"));\n+    let path = cfg_file.unwrap_or(\"config.toml\".into());\n     let settings = format!(\n         \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n     profile = \\\"{}\\\"\\n\\"}, {"sha": "ef3117c49cad3d2d62f7e2e91d0b4617daa5976b", "filename": "src/test/ui/ast-json/issue-78510-assoc-ice.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.rs?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -0,0 +1,18 @@\n+// compile-flags: -Zast-json\n+//\n+// Regression test for issue #78510\n+// Tests that we don't ICE when we have tokens for an associated item\n+\n+struct S;\n+\n+impl S {\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    fn f() {}\n+}\n+\n+trait Bar {\n+    #[derive(Debug)] //~ ERROR `derive` may only be applied to structs, enums and unions\n+    fn foo() {}\n+}\n+\n+fn main() {}"}, {"sha": "3573c203a789309f6e28a01dd0853c9d7249a55a", "filename": "src/test/ui/ast-json/issue-78510-assoc-ice.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stderr?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -0,0 +1,15 @@\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-78510-assoc-ice.rs:9:5\n+   |\n+LL |     #[derive(Debug)]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error[E0774]: `derive` may only be applied to structs, enums and unions\n+  --> $DIR/issue-78510-assoc-ice.rs:14:5\n+   |\n+LL |     #[derive(Debug)]\n+   |     ^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0774`."}, {"sha": "fef9504285b530dec83f0ff48e6a91f4c6decd84", "filename": "src/test/ui/ast-json/issue-78510-assoc-ice.stdout", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/4f7612ac1499258025077f1fd05d2f429f9accfb/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fast-json%2Fissue-78510-assoc-ice.stdout?ref=4f7612ac1499258025077f1fd05d2f429f9accfb", "patch": "@@ -0,0 +1 @@\n+{\"module\":{\"inner\":{\"lo\":139,\"hi\":397},\"unsafety\":\"No\",\"items\":[{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"prelude_import\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":3,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":4,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Use\",\"fields\":[{\"prefix\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"{{root}}\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":5,\"args\":null},{\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":6,\"args\":null},{\"ident\":{\"name\":\"prelude\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":7,\"args\":null},{\"ident\":{\"name\":\"v1\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":8,\"args\":null}],\"tokens\":null},\"kind\":\"Glob\",\"span\":{\"lo\":0,\"hi\":0}}]},\"tokens\":null},{\"attrs\":[{\"kind\":{\"variant\":\"Normal\",\"fields\":[{\"path\":{\"span\":{\"lo\":0,\"hi\":0},\"segments\":[{\"ident\":{\"name\":\"macro_use\",\"span\":{\"lo\":0,\"hi\":0}},\"id\":9,\"args\":null}],\"tokens\":null},\"args\":\"Empty\",\"tokens\":null}]},\"id\":null,\"style\":\"Outer\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null}],\"id\":10,\"span\":{\"lo\":0,\"hi\":0},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":0,\"hi\":0},\"tokens\":null},\"ident\":{\"name\":\"std\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"ExternCrate\",\"fields\":[null]},\"tokens\":null},{\"attrs\":[],\"id\":11,\"span\":{\"lo\":139,\"hi\":148},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":139,\"hi\":139},\"tokens\":null},\"ident\":{\"name\":\"S\",\"span\":{\"lo\":146,\"hi\":147}},\"kind\":{\"variant\":\"Struct\",\"fields\":[{\"variant\":\"Unit\",\"fields\":[12]},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":147,\"hi\":147}},\"span\":{\"lo\":147,\"hi\":147}}]},\"tokens\":null},{\"attrs\":[],\"id\":13,\"span\":{\"lo\":150,\"hi\":263},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":150,\"hi\":150},\"tokens\":null},\"ident\":{\"name\":\"\",\"span\":{\"lo\":0,\"hi\":0}},\"kind\":{\"variant\":\"Impl\",\"fields\":[\"No\",\"Positive\",\"Final\",\"No\",{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":156,\"hi\":156}},\"span\":{\"lo\":154,\"hi\":154}},null,{\"id\":14,\"kind\":{\"variant\":\"Path\",\"fields\":[null,{\"span\":{\"lo\":155,\"hi\":156},\"segments\":[{\"ident\":{\"name\":\"S\",\"span\":{\"lo\":155,\"hi\":156}},\"id\":15,\"args\":null}],\"tokens\":null}]},\"span\":{\"lo\":155,\"hi\":156},\"tokens\":null},[{\"attrs\":[],\"id\":19,\"span\":{\"lo\":252,\"hi\":261},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":252,\"hi\":252},\"tokens\":null},\"ident\":{\"name\":\"f\",\"span\":{\"lo\":255,\"hi\":256}},\"kind\":{\"variant\":\"Fn\",\"fields\":[\"Final\",{\"header\":{\"unsafety\":\"No\",\"asyncness\":\"No\",\"constness\":\"No\",\"ext\":\"None\"},\"decl\":{\"inputs\":[],\"output\":{\"variant\":\"Default\",\"fields\":[{\"lo\":259,\"hi\":259}]}},\"span\":{\"lo\":252,\"hi\":258}},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":258,\"hi\":258}},\"span\":{\"lo\":256,\"hi\":256}},{\"stmts\":[],\"id\":20,\"rules\":\"Default\",\"span\":{\"lo\":259,\"hi\":261},\"tokens\":null}]},\"tokens\":null}]]},\"tokens\":null},{\"attrs\":[],\"id\":16,\"span\":{\"lo\":265,\"hi\":383},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":265,\"hi\":265},\"tokens\":null},\"ident\":{\"name\":\"Bar\",\"span\":{\"lo\":271,\"hi\":274}},\"kind\":{\"variant\":\"Trait\",\"fields\":[\"No\",\"No\",{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":274,\"hi\":274}},\"span\":{\"lo\":274,\"hi\":274}},[],[{\"attrs\":[],\"id\":21,\"span\":{\"lo\":370,\"hi\":381},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":370,\"hi\":370},\"tokens\":null},\"ident\":{\"name\":\"foo\",\"span\":{\"lo\":373,\"hi\":376}},\"kind\":{\"variant\":\"Fn\",\"fields\":[\"Final\",{\"header\":{\"unsafety\":\"No\",\"asyncness\":\"No\",\"constness\":\"No\",\"ext\":\"None\"},\"decl\":{\"inputs\":[],\"output\":{\"variant\":\"Default\",\"fields\":[{\"lo\":379,\"hi\":379}]}},\"span\":{\"lo\":370,\"hi\":378}},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":378,\"hi\":378}},\"span\":{\"lo\":376,\"hi\":376}},{\"stmts\":[],\"id\":22,\"rules\":\"Default\",\"span\":{\"lo\":379,\"hi\":381},\"tokens\":null}]},\"tokens\":null}]]},\"tokens\":null},{\"attrs\":[],\"id\":17,\"span\":{\"lo\":385,\"hi\":397},\"vis\":{\"kind\":\"Inherited\",\"span\":{\"lo\":385,\"hi\":385},\"tokens\":null},\"ident\":{\"name\":\"main\",\"span\":{\"lo\":388,\"hi\":392}},\"kind\":{\"variant\":\"Fn\",\"fields\":[\"Final\",{\"header\":{\"unsafety\":\"No\",\"asyncness\":\"No\",\"constness\":\"No\",\"ext\":\"None\"},\"decl\":{\"inputs\":[],\"output\":{\"variant\":\"Default\",\"fields\":[{\"lo\":395,\"hi\":395}]}},\"span\":{\"lo\":385,\"hi\":394}},{\"params\":[],\"where_clause\":{\"has_where_token\":false,\"predicates\":[],\"span\":{\"lo\":394,\"hi\":394}},\"span\":{\"lo\":392,\"hi\":392}},{\"stmts\":[],\"id\":18,\"rules\":\"Default\",\"span\":{\"lo\":395,\"hi\":397},\"tokens\":null}]},\"tokens\":null}],\"inline\":true},\"attrs\":[],\"span\":{\"lo\":139,\"hi\":397},\"proc_macros\":[]}"}]}