{"sha": "675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3NTQ3NWM0ZDNlM2IxZWJmZjViNzYxNTcwZjRhM2Y5YTBjYTIzZGY=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2017-03-10T01:53:01Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2017-04-15T16:01:56Z"}, "message": "Specialize Vec::from_elem<u8> to use calloc or memset\n\nFixes #38723.", "tree": {"sha": "49cfa5b4d6edca5205909e9b0729e9744507940c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49cfa5b4d6edca5205909e9b0729e9744507940c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "html_url": "https://github.com/rust-lang/rust/commit/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5637ed756632ded9e458b82a23cc1dddbb57c51f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5637ed756632ded9e458b82a23cc1dddbb57c51f", "html_url": "https://github.com/rust-lang/rust/commit/5637ed756632ded9e458b82a23cc1dddbb57c51f"}], "stats": {"total": 151, "additions": 144, "deletions": 7}, "files": [{"sha": "cfcf8e22d7088f3d676dbcc0de2efb09c3f447f8", "filename": "src/doc/unstable-book/src/allocator.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fallocator.md?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -51,6 +51,11 @@ pub extern fn __rust_allocate(size: usize, _align: usize) -> *mut u8 {\n     unsafe { libc::malloc(size as libc::size_t) as *mut u8 }\n }\n \n+#[no_mangle]\n+pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n+    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n+}\n+\n #[no_mangle]\n pub extern fn __rust_deallocate(ptr: *mut u8, _old_size: usize, _align: usize) {\n     unsafe { libc::free(ptr as *mut libc::c_void) }"}, {"sha": "08a0b2a6d0080a2dfc053c78ea73f62900ac1a39", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -23,6 +23,7 @@ use core::intrinsics::{min_align_of_val, size_of_val};\n extern \"C\" {\n     #[allocator]\n     fn __rust_allocate(size: usize, align: usize) -> *mut u8;\n+    fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8;\n     fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize);\n     fn __rust_reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8;\n     fn __rust_reallocate_inplace(ptr: *mut u8,\n@@ -59,6 +60,20 @@ pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n     __rust_allocate(size, align)\n }\n \n+/// Return a pointer to `size` bytes of memory aligned to `align` and\n+/// initialized to zeroes.\n+///\n+/// On failure, return a null pointer.\n+///\n+/// Behavior is undefined if the requested size is 0 or the alignment is not a\n+/// power of 2. The alignment must be no larger than the largest supported page\n+/// size on the platform.\n+#[inline]\n+pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+    check_size_and_alignment(size, align);\n+    __rust_allocate_zeroed(size, align)\n+}\n+\n /// Resize the allocation referenced by `ptr` to `size` bytes.\n ///\n /// On failure, return a null pointer and leave the original allocation intact.\n@@ -162,6 +177,25 @@ mod tests {\n     use boxed::Box;\n     use heap;\n \n+    #[test]\n+    fn allocate_zeroed() {\n+        unsafe {\n+            let size = 1024;\n+            let ptr = heap::allocate_zeroed(size, 1);\n+            if ptr.is_null() {\n+                ::oom()\n+            }\n+\n+            let end = ptr.offset(size as isize);\n+            let mut i = ptr;\n+            while i < end {\n+                assert_eq!(*i, 0);\n+                i = i.offset(1);\n+            }\n+            heap::deallocate(ptr, size, 1);\n+        }\n+    }\n+\n     #[test]\n     fn basic_reallocate_inplace_noop() {\n         unsafe {"}, {"sha": "6a53d3a9ca57afeeca839fdb9b99740ed4f2930b", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -81,7 +81,18 @@ impl<T> RawVec<T> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n+    #[inline]\n     pub fn with_capacity(cap: usize) -> Self {\n+        RawVec::allocate(cap, false)\n+    }\n+\n+    /// Like `with_capacity` but guarantees the buffer is zeroed.\n+    #[inline]\n+    pub fn with_capacity_zeroed(cap: usize) -> Self {\n+        RawVec::allocate(cap, true)\n+    }\n+\n+    fn allocate(cap: usize, zeroed: bool) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n@@ -93,7 +104,11 @@ impl<T> RawVec<T> {\n                 heap::EMPTY as *mut u8\n             } else {\n                 let align = mem::align_of::<T>();\n-                let ptr = heap::allocate(alloc_size, align);\n+                let ptr = if zeroed {\n+                    heap::allocate_zeroed(alloc_size, align)\n+                } else {\n+                    heap::allocate(alloc_size, align)\n+                };\n                 if ptr.is_null() {\n                     oom()\n                 }"}, {"sha": "288531cb5b21f3b438edb8f3fb1d0bca76b4f520", "filename": "src/liballoc_jemalloc/lib.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc_jemalloc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc_jemalloc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2Flib.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -38,6 +38,10 @@ mod imp {\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_mallocx\")]\n         fn mallocx(size: size_t, flags: c_int) -> *mut c_void;\n+        #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n+                       target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n+                   link_name = \"je_calloc\")]\n+        fn calloc(size: size_t, flags: c_int) -> *mut c_void;\n         #[cfg_attr(any(target_os = \"macos\", target_os = \"android\", target_os = \"ios\",\n                        target_os = \"dragonfly\", target_os = \"windows\", target_env = \"musl\"),\n                    link_name = \"je_rallocx\")]\n@@ -56,6 +60,8 @@ mod imp {\n         fn nallocx(size: size_t, flags: c_int) -> size_t;\n     }\n \n+    const MALLOCX_ZERO: c_int = 0x40;\n+\n     // The minimum alignment guaranteed by the architecture. This value is used to\n     // add fast paths for low alignment values. In practice, the alignment is a\n     // constant at the call site and the branch will be optimized out.\n@@ -91,6 +97,16 @@ mod imp {\n         unsafe { mallocx(size as size_t, flags) as *mut u8 }\n     }\n \n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            unsafe { calloc(size as size_t, 1) as *mut u8 }\n+        } else {\n+            let flags = align_to_flags(align) | MALLOCX_ZERO;\n+            unsafe { mallocx(size as size_t, flags) as *mut u8 }\n+        }\n+    }\n+\n     #[no_mangle]\n     pub extern \"C\" fn __rust_reallocate(ptr: *mut u8,\n                                         _old_size: usize,\n@@ -135,6 +151,11 @@ mod imp {\n         bogus()\n     }\n \n+    #[no_mangle]\n+    pub extern \"C\" fn __rust_allocate_zeroed(_size: usize, _align: usize) -> *mut u8 {\n+        bogus()\n+    }\n+\n     #[no_mangle]\n     pub extern \"C\" fn __rust_reallocate(_ptr: *mut u8,\n                                         _old_size: usize,"}, {"sha": "6d47c2ff28fbf77ad565d1eeea92c622f03dd9f4", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 31, "deletions": 3, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -44,6 +44,11 @@ pub extern \"C\" fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     unsafe { imp::allocate(size, align) }\n }\n \n+#[no_mangle]\n+pub extern \"C\" fn __rust_allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+    unsafe { imp::allocate_zeroed(size, align) }\n+}\n+\n #[no_mangle]\n pub extern \"C\" fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe { imp::deallocate(ptr, old_size, align) }\n@@ -121,6 +126,18 @@ mod imp {\n         }\n     }\n \n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        if align <= MIN_ALIGN {\n+            libc::calloc(size as libc::size_t, 1) as *mut u8\n+        } else {\n+            let ptr = aligned_malloc(size, align);\n+            if !ptr.is_null() {\n+                ptr::write_bytes(ptr, 0, size);\n+            }\n+            ptr\n+        }\n+    }\n+\n     pub unsafe fn reallocate(ptr: *mut u8, old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             libc::realloc(ptr as *mut libc::c_void, size as libc::size_t) as *mut u8\n@@ -173,6 +190,8 @@ mod imp {\n     #[repr(C)]\n     struct Header(*mut u8);\n \n+\n+    const HEAP_ZERO_MEMORY: DWORD = 0x00000008;\n     const HEAP_REALLOC_IN_PLACE_ONLY: DWORD = 0x00000010;\n \n     unsafe fn get_header<'a>(ptr: *mut u8) -> &'a mut Header {\n@@ -185,18 +204,27 @@ mod imp {\n         aligned\n     }\n \n-    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+    #[inline]\n+    unsafe fn allocate_with_flags(size: usize, align: usize, flags: DWORD) -> *mut u8 {\n         if align <= MIN_ALIGN {\n-            HeapAlloc(GetProcessHeap(), 0, size as SIZE_T) as *mut u8\n+            HeapAlloc(GetProcessHeap(), flags, size as SIZE_T) as *mut u8\n         } else {\n-            let ptr = HeapAlloc(GetProcessHeap(), 0, (size + align) as SIZE_T) as *mut u8;\n+            let ptr = HeapAlloc(GetProcessHeap(), flags, (size + align) as SIZE_T) as *mut u8;\n             if ptr.is_null() {\n                 return ptr;\n             }\n             align_ptr(ptr, align)\n         }\n     }\n \n+    pub unsafe fn allocate(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, 0)\n+    }\n+\n+    pub unsafe fn allocate_zeroed(size: usize, align: usize) -> *mut u8 {\n+        allocate_with_flags(size, align, HEAP_ZERO_MEMORY)\n+    }\n+\n     pub unsafe fn reallocate(ptr: *mut u8, _old_size: usize, size: usize, align: usize) -> *mut u8 {\n         if align <= MIN_ALIGN {\n             HeapReAlloc(GetProcessHeap(), 0, ptr as LPVOID, size as SIZE_T) as *mut u8"}, {"sha": "f488e36c077cb78a162ef827be9b3b9fd3e6829f", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -1370,9 +1370,38 @@ impl<T: PartialEq> Vec<T> {\n #[doc(hidden)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn from_elem<T: Clone>(elem: T, n: usize) -> Vec<T> {\n-    let mut v = Vec::with_capacity(n);\n-    v.extend_with_element(n, elem);\n-    v\n+    <T as SpecFromElem>::from_elem(elem, n)\n+}\n+\n+// Specialization trait used for Vec::from_elem\n+trait SpecFromElem: Sized {\n+    fn from_elem(elem: Self, n: usize) -> Vec<Self>;\n+}\n+\n+impl<T: Clone> SpecFromElem for T {\n+    default fn from_elem(elem: Self, n: usize) -> Vec<Self> {\n+        let mut v = Vec::with_capacity(n);\n+        v.extend_with_element(n, elem);\n+        v\n+    }\n+}\n+\n+impl SpecFromElem for u8 {\n+    #[inline]\n+    fn from_elem(elem: u8, n: usize) -> Vec<u8> {\n+        if elem == 0 {\n+            return Vec {\n+                buf: RawVec::with_capacity_zeroed(n),\n+                len: n,\n+            }\n+        }\n+        unsafe {\n+            let mut v = Vec::with_capacity(n);\n+            ptr::write_bytes(v.as_mut_ptr(), elem, n);\n+            v.set_len(n);\n+            v\n+        }\n+    }\n }\n \n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "1133ace275b864be750fa416ba5a697f892a3c04", "filename": "src/test/run-pass/auxiliary/allocator-dummy.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/675475c4d3e3b1ebff5b761570f4a3f9a0ca23df/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fallocator-dummy.rs?ref=675475c4d3e3b1ebff5b761570f4a3f9a0ca23df", "patch": "@@ -27,6 +27,11 @@ pub extern fn __rust_allocate(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n+#[no_mangle]\n+pub extern fn __rust_allocate_zeroed(size: usize, _align: usize) -> *mut u8 {\n+    unsafe { libc::calloc(size as libc::size_t, 1) as *mut u8 }\n+}\n+\n #[no_mangle]\n pub extern fn __rust_deallocate(ptr: *mut u8, old_size: usize, align: usize) {\n     unsafe {"}]}