{"sha": "62ec04bbd53ba50e21a7b8f23d46958d322640eb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyZWMwNGJiZDUzYmE1MGUyMWE3YjhmMjNkNDY5NThkMzIyNjQwZWI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-16T07:57:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-16T07:57:33Z"}, "message": "Merge #8036 #8046\n\n8036: completions: provide relevance bonus for enum types, and suggest ref matches for fn and enum r=matklad a=JoshMcguigan\n\nThis PR makes several improvements to completions and completion sorting:\r\n\r\n1. Provide exact match type relevance score bonus for enum variants\r\n2. Suggest `&Foo` (ref_match) for enums if that is an exact type match\r\n3. Suggest `&foo()` (ref_match) if `foo` returns a type which would be an exact match either with the reference or due to a `Deref` impl\r\n\r\n### Before\r\n\r\n![pre-ref-relevance-centralized](https://user-images.githubusercontent.com/22216761/111189377-3f05a580-8573-11eb-89be-58a45cb7f829.png)\r\n\r\n### After\r\n\r\n![post-ref-relevance-centralized](https://user-images.githubusercontent.com/22216761/111189395-45941d00-8573-11eb-871b-09186b35cbb9.png)\r\n\r\n### Caveats\r\n\r\nI think generic types will require some kind of fancier logic when testing for `exact_type_match`, so for now `Option`/`Result`/etc unfortunately still don't have great completions.\r\n\r\n### Implementation\r\n\r\nI implemented this in a way that I think makes it most likely for each completion type to be handled consistently. Just replace `CompletionItem::new` with `CompletionItem::new_with_type_info` and `exact_type_match`/`exact_name_match`/`ref_match` are all handled for you, in a way which is sure to be consistent across completion types. \r\n\r\nThis approach does introduce some coupling/plumbing that didn't exist before. Notice for example `set_is_local` on the builder, because `set_relevance` was removed from the builder to enforce that the relevance was built \"properly\" with `CompletionItem::new_with_type_info`. But I think there are benefits to this approach, like `CompletionRelevance` should probably consider deprecation status, and we already tell the builder about that, so in the (likely near term) future we can just pass that information along to `CompletionRelevance` when the user calls `set_deprecated` rather than the user having to manually set it in two places. This basically just hides `CompletionRelevance` from the individual completions, so they only worry about the `CompletionItem` interface. At the moment this seems like a cleaner approach to me, but I'm open to feedback here. \r\n\r\nedit - I've reimplemented this in a simpler way, per feedback below.\n\n8046: Prefer match to if let else r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "64e76e782e6befe998907e631e125ea1b7a27475", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64e76e782e6befe998907e631e125ea1b7a27475"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62ec04bbd53ba50e21a7b8f23d46958d322640eb", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgUGTtCRBK7hj4Ov3rIwAAdHIIAGeoqPZuOcWKDxtXTE/GBG5X\nBG96jbU5xlpgPdi393pPsPrs4sLREJkJnBEOA+jSV+L1VB2Y88jx8bMKde6//Leq\nicZTCYG/3ETfMC3yU6tdIHssn5nV8jWR0/5GQrV+m6RcJZgdgL818iLYGAyjI44R\nKWpxaBHZeG5PD6fHEgWx2H5l3n7OxV6GlP2pCbTfAEVdsZCWkeszPoiiBP5iZyC6\nMJODIOflFnLiEII3fsu3w0SwwZekhZNtjuEm21ittAfE+v9z4Oj+DM2Hb5jFaTJU\nSeKFfLsCn43wrB8BwFvqTmI66XmrWr5qvEKb0h278HtflNJpN1UiJggiSzBdT/w=\n=jzi3\n-----END PGP SIGNATURE-----\n", "payload": "tree 64e76e782e6befe998907e631e125ea1b7a27475\nparent 5fa26d05fb5041c4061ee484e12453aa6e465fa7\nparent 405bbb3aa46ecbfa5124969739695565d9841b9c\nparent 30dea3a727879f9ed6cfe06433f1adb51765fa9e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615881453 +0000\ncommitter GitHub <noreply@github.com> 1615881453 +0000\n\nMerge #8036 #8046\n\n8036: completions: provide relevance bonus for enum types, and suggest ref matches for fn and enum r=matklad a=JoshMcguigan\n\nThis PR makes several improvements to completions and completion sorting:\r\n\r\n1. Provide exact match type relevance score bonus for enum variants\r\n2. Suggest `&Foo` (ref_match) for enums if that is an exact type match\r\n3. Suggest `&foo()` (ref_match) if `foo` returns a type which would be an exact match either with the reference or due to a `Deref` impl\r\n\r\n### Before\r\n\r\n![pre-ref-relevance-centralized](https://user-images.githubusercontent.com/22216761/111189377-3f05a580-8573-11eb-89be-58a45cb7f829.png)\r\n\r\n### After\r\n\r\n![post-ref-relevance-centralized](https://user-images.githubusercontent.com/22216761/111189395-45941d00-8573-11eb-871b-09186b35cbb9.png)\r\n\r\n### Caveats\r\n\r\nI think generic types will require some kind of fancier logic when testing for `exact_type_match`, so for now `Option`/`Result`/etc unfortunately still don't have great completions.\r\n\r\n### Implementation\r\n\r\nI implemented this in a way that I think makes it most likely for each completion type to be handled consistently. Just replace `CompletionItem::new` with `CompletionItem::new_with_type_info` and `exact_type_match`/`exact_name_match`/`ref_match` are all handled for you, in a way which is sure to be consistent across completion types. \r\n\r\nThis approach does introduce some coupling/plumbing that didn't exist before. Notice for example `set_is_local` on the builder, because `set_relevance` was removed from the builder to enforce that the relevance was built \"properly\" with `CompletionItem::new_with_type_info`. But I think there are benefits to this approach, like `CompletionRelevance` should probably consider deprecation status, and we already tell the builder about that, so in the (likely near term) future we can just pass that information along to `CompletionRelevance` when the user calls `set_deprecated` rather than the user having to manually set it in two places. This basically just hides `CompletionRelevance` from the individual completions, so they only worry about the `CompletionItem` interface. At the moment this seems like a cleaner approach to me, but I'm open to feedback here. \r\n\r\nedit - I've reimplemented this in a simpler way, per feedback below.\n\n8046: Prefer match to if let else r=matklad a=matklad\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Josh Mcguigan <joshmcg88@gmail.com>\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62ec04bbd53ba50e21a7b8f23d46958d322640eb", "html_url": "https://github.com/rust-lang/rust/commit/62ec04bbd53ba50e21a7b8f23d46958d322640eb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62ec04bbd53ba50e21a7b8f23d46958d322640eb/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5fa26d05fb5041c4061ee484e12453aa6e465fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/5fa26d05fb5041c4061ee484e12453aa6e465fa7", "html_url": "https://github.com/rust-lang/rust/commit/5fa26d05fb5041c4061ee484e12453aa6e465fa7"}, {"sha": "405bbb3aa46ecbfa5124969739695565d9841b9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/405bbb3aa46ecbfa5124969739695565d9841b9c", "html_url": "https://github.com/rust-lang/rust/commit/405bbb3aa46ecbfa5124969739695565d9841b9c"}, {"sha": "30dea3a727879f9ed6cfe06433f1adb51765fa9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/30dea3a727879f9ed6cfe06433f1adb51765fa9e", "html_url": "https://github.com/rust-lang/rust/commit/30dea3a727879f9ed6cfe06433f1adb51765fa9e"}], "stats": {"total": 243, "additions": 193, "deletions": 50}, "files": [{"sha": "09a27de7141a6c1d743c069c187de37465cc09bd", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 147, "deletions": 35, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=62ec04bbd53ba50e21a7b8f23d46958d322640eb", "patch": "@@ -10,10 +10,8 @@ pub(crate) mod type_alias;\n \n mod builder_ext;\n \n-use base_db::Upcast;\n use hir::{\n-    db::HirDatabase, AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability,\n-    ScopeDef, Type,\n+    AsAssocItem, Documentation, HasAttrs, HirDisplay, ModuleDef, Mutability, ScopeDef, Type,\n };\n use ide_db::{\n     helpers::{item_name, SnippetCap},\n@@ -22,8 +20,8 @@ use ide_db::{\n use syntax::TextRange;\n \n use crate::{\n-    item::{CompletionRelevance, ImportEdit},\n-    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n+    item::ImportEdit, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind,\n+    CompletionRelevance,\n };\n \n use crate::render::{enum_variant::render_variant, function::render_fn, macro_::render_macro};\n@@ -144,7 +142,15 @@ impl<'a> Render<'a> {\n             .set_documentation(field.docs(self.ctx.db()))\n             .set_deprecated(is_deprecated);\n \n-        item.set_relevance(compute_relevance(&self.ctx, &ty, &name.to_string()));\n+        item.set_relevance(CompletionRelevance {\n+            exact_type_match: compute_exact_type_match(self.ctx.completion, ty),\n+            exact_name_match: compute_exact_name_match(self.ctx.completion, name.to_string()),\n+            ..CompletionRelevance::default()\n+        });\n+\n+        if let Some(ref_match) = compute_ref_match(self.ctx.completion, ty) {\n+            item.ref_match(ref_match);\n+        }\n \n         item.build()\n     }\n@@ -234,31 +240,18 @@ impl<'a> Render<'a> {\n             if !ty.is_unknown() {\n                 item.detail(ty.display(self.ctx.db()).to_string());\n             }\n-        };\n \n-        if let ScopeDef::Local(local) = resolution {\n-            let ty = local.ty(self.ctx.db());\n+            item.set_relevance(CompletionRelevance {\n+                exact_type_match: compute_exact_type_match(self.ctx.completion, &ty),\n+                exact_name_match: compute_exact_name_match(self.ctx.completion, local_name.clone()),\n+                is_local: true,\n+                ..CompletionRelevance::default()\n+            });\n \n-            let mut relevance = compute_relevance(&self.ctx, &ty, &local_name);\n-            relevance.is_local = true;\n-            item.set_relevance(relevance);\n-\n-            if let Some(expected_type) = self.ctx.completion.expected_type.as_ref() {\n-                if &ty != expected_type {\n-                    if let Some(ty_without_ref) = expected_type.remove_ref() {\n-                        if relevance_type_match(self.ctx.db().upcast(), &ty, &ty_without_ref) {\n-                            cov_mark::hit!(suggest_ref);\n-                            let mutability = if expected_type.is_mutable_reference() {\n-                                Mutability::Mut\n-                            } else {\n-                                Mutability::Shared\n-                            };\n-                            item.ref_match(mutability);\n-                        }\n-                    }\n-                }\n+            if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n+                item.ref_match(ref_match);\n             }\n-        }\n+        };\n \n         // Add `<>` for generic types\n         if self.ctx.completion.is_path_type\n@@ -313,17 +306,44 @@ impl<'a> Render<'a> {\n     }\n }\n \n-fn compute_relevance(ctx: &RenderContext, ty: &Type, name: &str) -> CompletionRelevance {\n-    let mut res = CompletionRelevance::default();\n+fn compute_exact_type_match(ctx: &CompletionContext, completion_ty: &hir::Type) -> bool {\n+    if let Some(expected_type) = ctx.expected_type.as_ref() {\n+        // We don't ever consider unit type to be an exact type match, since\n+        // nearly always this is not meaningful to the user.\n+        completion_ty == expected_type && !expected_type.is_unit()\n+    } else {\n+        false\n+    }\n+}\n \n-    res.exact_type_match = Some(ty) == ctx.completion.expected_type.as_ref();\n-    res.exact_name_match = Some(name) == ctx.completion.expected_name.as_deref();\n+fn compute_exact_name_match(ctx: &CompletionContext, completion_name: impl Into<String>) -> bool {\n+    let completion_name = completion_name.into();\n \n-    res\n+    Some(&completion_name) == ctx.expected_name.as_ref()\n }\n \n-fn relevance_type_match(db: &dyn HirDatabase, ty: &Type, expected_type: &Type) -> bool {\n-    ty == expected_type || ty.autoderef(db).any(|deref_ty| &deref_ty == expected_type)\n+fn compute_ref_match(ctx: &CompletionContext, completion_ty: &hir::Type) -> Option<Mutability> {\n+    let mut ref_match = None;\n+    if let Some(expected_type) = &ctx.expected_type {\n+        if completion_ty != expected_type {\n+            if let Some(expected_type_without_ref) = expected_type.remove_ref() {\n+                if completion_ty == &expected_type_without_ref\n+                    || completion_ty\n+                        .autoderef(ctx.db)\n+                        .any(|deref_ty| deref_ty == expected_type_without_ref)\n+                {\n+                    cov_mark::hit!(suggest_ref);\n+                    let mutability = if expected_type.is_mutable_reference() {\n+                        Mutability::Mut\n+                    } else {\n+                        Mutability::Shared\n+                    };\n+                    ref_match = Some(mutability);\n+                }\n+            }\n+        }\n+    };\n+    ref_match\n }\n \n #[cfg(test)]\n@@ -477,6 +497,11 @@ fn main() { let _: m::Spam = S$0 }\n                         ),\n                         lookup: \"Spam::Bar\",\n                         detail: \"(i32)\",\n+                        relevance: CompletionRelevance {\n+                            exact_name_match: false,\n+                            exact_type_match: true,\n+                            is_local: false,\n+                        },\n                         trigger_call_info: true,\n                     },\n                     CompletionItem {\n@@ -498,6 +523,11 @@ fn main() { let _: m::Spam = S$0 }\n                         ),\n                         lookup: \"Spam::Foo\",\n                         detail: \"()\",\n+                        relevance: CompletionRelevance {\n+                            exact_name_match: false,\n+                            exact_type_match: true,\n+                            is_local: false,\n+                        },\n                     },\n                     CompletionItem {\n                         label: \"main()\",\n@@ -1169,4 +1199,86 @@ fn foo(bar: u32) {\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn enum_owned() {\n+        check_relevance(\n+            r#\"\n+enum Foo { A, B }\n+fn foo() {\n+    bar($0);\n+}\n+fn bar(t: Foo) {}\n+\"#,\n+            expect![[r#\"\n+                ev Foo::A [type]\n+                ev Foo::B [type]\n+                en Foo []\n+                fn bar(\u2026) []\n+                fn foo() []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn enum_ref() {\n+        check_relevance(\n+            r#\"\n+enum Foo { A, B }\n+fn foo() {\n+    bar($0);\n+}\n+fn bar(t: &Foo) {}\n+\"#,\n+            expect![[r#\"\n+                ev Foo::A []\n+                ev &Foo::A [type]\n+                ev Foo::B []\n+                ev &Foo::B [type]\n+                en Foo []\n+                fn bar(\u2026) []\n+                fn foo() []\n+            \"#]],\n+        );\n+    }\n+\n+    #[test]\n+    fn suggest_deref_fn_ret() {\n+        check_relevance(\n+            r#\"\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+struct S;\n+struct T(S);\n+\n+impl Deref for T {\n+    type Target = S;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+fn foo(s: &S) {}\n+fn bar() -> T {}\n+\n+fn main() {\n+    foo($0);\n+}\n+            \"#,\n+            expect![[r#\"\n+                tt Deref []\n+                fn bar() []\n+                fn &bar() [type]\n+                fn foo(\u2026) []\n+                st T []\n+                st S []\n+                fn main() []\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "374247b0569051c7219c93670f54ddc70f7f41fa", "filename": "crates/ide_completion/src/render/enum_variant.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Fenum_variant.rs?ref=62ec04bbd53ba50e21a7b8f23d46958d322640eb", "patch": "@@ -6,7 +6,8 @@ use itertools::Itertools;\n \n use crate::{\n     item::{CompletionItem, CompletionKind, ImportEdit},\n-    render::{builder_ext::Params, RenderContext},\n+    render::{builder_ext::Params, compute_exact_type_match, compute_ref_match, RenderContext},\n+    CompletionRelevance,\n };\n \n pub(crate) fn render_variant<'a>(\n@@ -74,6 +75,16 @@ impl<'a> EnumRender<'a> {\n             item.lookup_by(self.short_qualified_name);\n         }\n \n+        let ty = self.variant.parent_enum(self.ctx.completion.db).ty(self.ctx.completion.db);\n+        item.set_relevance(CompletionRelevance {\n+            exact_type_match: compute_exact_type_match(self.ctx.completion, &ty),\n+            ..CompletionRelevance::default()\n+        });\n+\n+        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ty) {\n+            item.ref_match(ref_match);\n+        }\n+\n         item.build()\n     }\n "}, {"sha": "194ea135e9839a1a7763ffee0edeb54b7c737914", "filename": "crates/ide_completion/src/render/function.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62ec04bbd53ba50e21a7b8f23d46958d322640eb/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Ffunction.rs?ref=62ec04bbd53ba50e21a7b8f23d46958d322640eb", "patch": "@@ -6,7 +6,10 @@ use syntax::ast::Fn;\n \n use crate::{\n     item::{CompletionItem, CompletionItemKind, CompletionKind, CompletionRelevance, ImportEdit},\n-    render::{builder_ext::Params, RenderContext},\n+    render::{\n+        builder_ext::Params, compute_exact_name_match, compute_exact_type_match, compute_ref_match,\n+        RenderContext,\n+    },\n };\n \n pub(crate) fn render_fn<'a>(\n@@ -52,23 +55,19 @@ impl<'a> FunctionRender<'a> {\n                 self.ctx.is_deprecated(self.func) || self.ctx.is_deprecated_assoc_item(self.func),\n             )\n             .detail(self.detail())\n-            .add_call_parens(self.ctx.completion, self.name, params)\n+            .add_call_parens(self.ctx.completion, self.name.clone(), params)\n             .add_import(import_to_add);\n \n-        let mut relevance = CompletionRelevance::default();\n-        if let Some(expected_type) = &self.ctx.completion.expected_type {\n-            let ret_ty = self.func.ret_type(self.ctx.db());\n+        let ret_type = self.func.ret_type(self.ctx.db());\n+        item.set_relevance(CompletionRelevance {\n+            exact_type_match: compute_exact_type_match(self.ctx.completion, &ret_type),\n+            exact_name_match: compute_exact_name_match(self.ctx.completion, self.name.clone()),\n+            ..CompletionRelevance::default()\n+        });\n \n-            // We don't ever consider a function which returns unit type to be an\n-            // exact type match, since nearly always this is not meaningful to the\n-            // user.\n-            relevance.exact_type_match = &ret_ty == expected_type && !ret_ty.is_unit();\n+        if let Some(ref_match) = compute_ref_match(self.ctx.completion, &ret_type) {\n+            item.ref_match(ref_match);\n         }\n-        if let Some(expected_name) = &self.ctx.completion.expected_name {\n-            relevance.exact_name_match =\n-                expected_name == &self.func.name(self.ctx.db()).to_string();\n-        }\n-        item.set_relevance(relevance);\n \n         item.build()\n     }"}, {"sha": "e4a1672cab5d20ee9ce056ded2c01291424623db", "filename": "docs/dev/style.md", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62ec04bbd53ba50e21a7b8f23d46958d322640eb/docs%2Fdev%2Fstyle.md", "raw_url": "https://github.com/rust-lang/rust/raw/62ec04bbd53ba50e21a7b8f23d46958d322640eb/docs%2Fdev%2Fstyle.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fdev%2Fstyle.md?ref=62ec04bbd53ba50e21a7b8f23d46958d322640eb", "patch": "@@ -787,6 +787,27 @@ assert!(0 > x);\n \n **Rationale:** Less-then comparisons are more intuitive, they correspond spatially to [real line](https://en.wikipedia.org/wiki/Real_line).\n \n+## If-let\n+\n+Avoid `if let ... { } else { }` construct, use `match` instead.\n+\n+```rust\n+// GOOD\n+match ctx.expected_type.as_ref() {\n+    Some(expected_type) => completion_ty == expected_type && !expected_type.is_unit(),\n+    None => false,\n+}\n+\n+// BAD\n+if let Some(expected_type) = ctx.expected_type.as_ref() {\n+    completion_ty == expected_type && !expected_type.is_unit()\n+} else {\n+    false\n+}\n+```\n+\n+**Rational:** `match` is almost always more compact.\n+The `else` branch can get a more precise pattern: `None` or `Err(_)` instead of `_`.\n \n ## Token names\n "}]}