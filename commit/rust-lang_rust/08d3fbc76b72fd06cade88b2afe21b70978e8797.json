{"sha": "08d3fbc76b72fd06cade88b2afe21b70978e8797", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDNmYmM3NmI3MmZkMDZjYWRlODhiMmFmZTIxYjcwOTc4ZTg3OTc=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-04-15T01:02:55Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-11-17T13:34:25Z"}, "message": "Support unwinding after a panic\n\nFixes #658\n\nThis commit adds support for unwinding after a panic. It requires a\ncompanion rustc PR to be merged, in order for the necessary hooks to\nwork properly.\n\nCurrently implemented:\n* Selecting between unwind/abort mode based on the rustc Session\n* Properly popping off stack frames, unwinding back the caller\n* Running 'unwind' blocks in Mir terminators\n\nNot yet implemented:\n* 'Abort' terminators\n\nThis PR was getting fairly large, so I decided to open it for review without\nimplementing 'Abort' terminator support. This could either be added on\nto this PR, or merged separately.", "tree": {"sha": "6b84fd939547fbd48cfe2c0adc68f14bf7d8f177", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6b84fd939547fbd48cfe2c0adc68f14bf7d8f177"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d3fbc76b72fd06cade88b2afe21b70978e8797", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl3RTGIACgkQtAh+UQ6Y\nsWTT2Q//cXxGtk1xrxFSd6L6U6AhmeMLEzBJD+C3A90F8yS1nXbv5vCfAmVntv49\nC8PdEyMp1Q7Wfqd4Jglgf/iG3ayJ/D6kj34cFn0/N+LpsDbHH94ORFjn9NCe/3gD\nTqs1j6OzdaKqvvGlIjbD5XvBo9z9nP9DnjLJR0jGQ3ijJuzI4zQdAQb6RRSCTOC4\n+Fyb6sraaqWJ3U5hBii3ZO8SKy/0sp8RgfaADdvCOaVWE8MRSUhOpSh31tV8w+SU\nq/Jyl0q/IJ2247v+H6OLiNeWIR0FYbcxHO2Y52l6Cpm+O88csenKD74MVgdHk6KG\nfKoNO5YpS/tRkxGwWC/3LufedxHc4Q2lUg2r4lBlDSMNw2J6+4a8ZdmW9ugbUZu8\nAuJUf96qeZls9ML9goh2evxoMnEPARMbQJUb/Z8CbVM1baoFgejyia8vzJ+KtNV0\naEuTygcRUTf2sQ2LnKL2DkCm3clJCjyHnVywyxjImgRaHrjWYd9pOxxq7rn8vPX7\nkMYPSbpN2quPRxxOnOB7amPe0/kmtBJf8tUTXRxkaneA/JJiYQGE5iQ2hfodOP6n\n/68mbPAdnD+qd66PlCSzGP8u+xbsBALjcERxzvl2GDc7dl2KXkj5w88WI3O/1QOd\na19VfX8PstaiAzj2+KwLKFrk0hmnhcqdmshZcvXTa1bMSy4ICHQ=\n=3ckU\n-----END PGP SIGNATURE-----", "payload": "tree 6b84fd939547fbd48cfe2c0adc68f14bf7d8f177\nparent 67a63f89d8c0e5b22fb52cc33274283819f41792\nauthor Aaron Hill <aa1ronham@gmail.com> 1555290175 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1573997665 -0500\n\nSupport unwinding after a panic\n\nFixes #658\n\nThis commit adds support for unwinding after a panic. It requires a\ncompanion rustc PR to be merged, in order for the necessary hooks to\nwork properly.\n\nCurrently implemented:\n* Selecting between unwind/abort mode based on the rustc Session\n* Properly popping off stack frames, unwinding back the caller\n* Running 'unwind' blocks in Mir terminators\n\nNot yet implemented:\n* 'Abort' terminators\n\nThis PR was getting fairly large, so I decided to open it for review without\nimplementing 'Abort' terminator support. This could either be added on\nto this PR, or merged separately.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d3fbc76b72fd06cade88b2afe21b70978e8797", "html_url": "https://github.com/rust-lang/rust/commit/08d3fbc76b72fd06cade88b2afe21b70978e8797", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d3fbc76b72fd06cade88b2afe21b70978e8797/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "67a63f89d8c0e5b22fb52cc33274283819f41792", "url": "https://api.github.com/repos/rust-lang/rust/commits/67a63f89d8c0e5b22fb52cc33274283819f41792", "html_url": "https://github.com/rust-lang/rust/commit/67a63f89d8c0e5b22fb52cc33274283819f41792"}], "stats": {"total": 535, "additions": 404, "deletions": 131}, "files": [{"sha": "7203ba6bf1db95404d6de079850302a42c0c70a3", "filename": "src/eval.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -39,10 +39,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n         tcx.at(syntax::source_map::DUMMY_SP),\n         ty::ParamEnv::reveal_all(),\n         Evaluator::new(config.communicate),\n-        MemoryExtra::new(\n-            StdRng::seed_from_u64(config.seed.unwrap_or(0)),\n-            config.validate,\n-        ),\n+        MemoryExtra::new(StdRng::seed_from_u64(config.seed.unwrap_or(0)), config.validate),\n     );\n     // Complete initialization.\n     EnvVars::init(&mut ecx, config.excluded_env_vars);"}, {"sha": "cff78859df8df391c3a57e22fd7422cf0edda9e9", "filename": "src/helpers.rs", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -6,6 +6,7 @@ use rustc::mir;\n use rustc::ty::{\n     self,\n     List,\n+    TyCtxt,\n     layout::{self, LayoutOf, Size, TyLayout},\n };\n \n@@ -15,40 +16,45 @@ use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n \n-pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    /// Gets an instance for a path.\n-    fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n-        let this = self.eval_context_ref();\n-        this.tcx\n-            .crates()\n-            .iter()\n-            .find(|&&krate| this.tcx.original_crate_name(krate).as_str() == path[0])\n-            .and_then(|krate| {\n-                let krate = DefId {\n-                    krate: *krate,\n-                    index: CRATE_DEF_INDEX,\n-                };\n-                let mut items = this.tcx.item_children(krate);\n-                let mut path_it = path.iter().skip(1).peekable();\n-\n-                while let Some(segment) = path_it.next() {\n-                    for item in mem::replace(&mut items, Default::default()).iter() {\n-                        if item.ident.name.as_str() == *segment {\n-                            if path_it.peek().is_none() {\n-                                return Some(ty::Instance::mono(this.tcx.tcx, item.res.def_id()));\n-                            }\n-\n-                            items = this.tcx.item_children(item.res.def_id());\n-                            break;\n+/// Gets an instance for a path.\n+fn resolve_did<'mir, 'tcx>(tcx: TyCtxt<'tcx>, path: &[&str]) -> InterpResult<'tcx, DefId> {\n+    tcx\n+        .crates()\n+        .iter()\n+        .find(|&&krate| tcx.original_crate_name(krate).as_str() == path[0])\n+        .and_then(|krate| {\n+            let krate = DefId {\n+                krate: *krate,\n+                index: CRATE_DEF_INDEX,\n+            };\n+            let mut items = tcx.item_children(krate);\n+            let mut path_it = path.iter().skip(1).peekable();\n+\n+            while let Some(segment) = path_it.next() {\n+                for item in mem::replace(&mut items, Default::default()).iter() {\n+                    if item.ident.name.as_str() == *segment {\n+                        if path_it.peek().is_none() {\n+                            return Some(item.res.def_id())\n                         }\n+\n+                        items = tcx.item_children(item.res.def_id());\n+                        break;\n                     }\n                 }\n-                None\n-            })\n-            .ok_or_else(|| {\n-                let path = path.iter().map(|&s| s.to_owned()).collect();\n-                err_unsup!(PathNotFound(path)).into()\n-            })\n+            }\n+            None\n+        })\n+        .ok_or_else(|| {\n+            let path = path.iter().map(|&s| s.to_owned()).collect();\n+            err_unsup!(PathNotFound(path)).into()\n+        })\n+}\n+\n+\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    fn resolve_path(&self, path: &[&str]) -> InterpResult<'tcx, ty::Instance<'tcx>> {\n+        Ok(ty::Instance::mono(self.eval_context_ref().tcx.tcx, resolve_did(self.eval_context_ref().tcx.tcx, path)?))\n     }\n \n     /// Write a 0 of the appropriate size to `dest`."}, {"sha": "f29ec8f22bbaea993960dabde730410e4a5e052e", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -37,6 +37,7 @@ pub use crate::shims::time::{EvalContextExt as TimeEvalContextExt};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n pub use crate::shims::fs::{FileHandler, EvalContextExt as FileEvalContextExt};\n+pub use crate::shims::panic::{CatchUnwindData, EvalContextExt as PanicEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};"}, {"sha": "8910c589ee70edf22fa20f9565c0f5896b134379", "filename": "src/machine.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -8,12 +8,8 @@ use std::rc::Rc;\n use rand::rngs::StdRng;\n \n use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, layout::{Size, LayoutOf}, Ty, TyCtxt};\n use rustc::mir;\n-use rustc::ty::{\n-    self,\n-    layout::{LayoutOf, Size},\n-    Ty, TyCtxt,\n-};\n use syntax::{attr, source_map::Span, symbol::sym};\n \n use crate::*;\n@@ -24,6 +20,19 @@ pub const STACK_ADDR: u64 = 32 * PAGE_SIZE; // not really about the \"stack\", but\n pub const STACK_SIZE: u64 = 16 * PAGE_SIZE; // whatever\n pub const NUM_CPUS: u64 = 1;\n \n+/// Extra data stored with each stack frame\n+#[derive(Debug)]\n+pub struct FrameData<'tcx> {\n+    /// Extra data for Stacked Borrows.\n+    pub call_id: stacked_borrows::CallId,\n+    /// If this is Some(), then this is a special 'catch unwind'\n+    /// frame. When this frame is popped during unwinding a panic,\n+    /// we stop unwinding, and use the `CatchUnwindData` to\n+    /// store the panic payload and continue execution in the parent frame.\n+    pub catch_panic: Option<CatchUnwindData<'tcx>>,\n+}\n+\n+\n /// Extra memory kinds\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum MiriMemoryKind {\n@@ -101,6 +110,10 @@ pub struct Evaluator<'tcx> {\n     pub(crate) communicate: bool,\n \n     pub(crate) file_handler: FileHandler,\n+\n+    /// The temporary used for storing the argument of\n+    /// the call to `miri_start_panic` (the panic payload) when unwinding.\n+    pub(crate) panic_payload: Option<ImmTy<'tcx, Tag>>\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -116,6 +129,7 @@ impl<'tcx> Evaluator<'tcx> {\n             tls: TlsData::default(),\n             communicate,\n             file_handler: Default::default(),\n+            panic_payload: None\n         }\n     }\n }\n@@ -143,7 +157,7 @@ impl<'mir, 'tcx> MiriEvalContextExt<'mir, 'tcx> for MiriEvalContext<'mir, 'tcx>\n impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     type MemoryKinds = MiriMemoryKind;\n \n-    type FrameExtra = stacked_borrows::CallId;\n+    type FrameExtra = FrameData<'tcx>;\n     type MemoryExtra = MemoryExtra;\n     type AllocExtra = AllocExtra;\n     type PointerTag = Tag;\n@@ -173,9 +187,9 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-        _unwind: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n-        ecx.find_fn(instance, args, dest, ret)\n+        ecx.find_fn(instance, args, dest, ret, unwind)\n     }\n \n     #[inline(always)]\n@@ -196,14 +210,10 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n-        _ret: Option<mir::BasicBlock>,\n-        _unwind: Option<mir::BasicBlock>\n+        ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        let dest = match dest {\n-            Some(dest) => dest,\n-            None => throw_ub!(Unreachable)\n-        };\n-        ecx.call_intrinsic(span, instance, args, dest)\n+        ecx.call_intrinsic(span, instance, args, dest, ret, unwind)\n     }\n \n     #[inline(always)]\n@@ -352,23 +362,20 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'tcx> {\n     #[inline(always)]\n     fn stack_push(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> InterpResult<'tcx, stacked_borrows::CallId> {\n-        Ok(ecx.memory.extra.stacked_borrows.borrow_mut().new_call())\n+    ) -> InterpResult<'tcx, FrameData<'tcx>> {\n+        Ok(FrameData {\n+            call_id: ecx.memory.extra.stacked_borrows.borrow_mut().new_call(),\n+            catch_panic: None,\n+        })\n     }\n \n     #[inline(always)]\n     fn stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        extra: stacked_borrows::CallId,\n-        _unwinding: bool\n+        extra: FrameData<'tcx>,\n+        unwinding: bool\n     ) -> InterpResult<'tcx, StackPopInfo> {\n-        ecx\n-            .memory\n-            .extra\n-            .stacked_borrows\n-            .borrow_mut()\n-            .end_call(extra);\n-        Ok(StackPopInfo::Normal)\n+        ecx.handle_stack_pop(extra, unwinding)\n     }\n \n     #[inline(always)]"}, {"sha": "781c5ad40f9300054aead5c02b051a3752471ae4", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 31, "deletions": 47, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -1,9 +1,10 @@\n use std::{iter, convert::TryInto};\n \n-use rustc::hir::def_id::DefId;\n use rustc::mir;\n use rustc::ty::layout::{Align, LayoutOf, Size};\n+use rustc::hir::def_id::DefId;\n use rustc_apfloat::Float;\n+use rustc::ty;\n use syntax::attr;\n use syntax::symbol::sym;\n \n@@ -105,13 +106,18 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n+    /// Returns Ok(None) if the foreign item was completely handled\n+    /// by this function.\n+    /// Returns Ok(Some(body)) if processing the foreign item\n+    /// is delegated to another function.\n     fn emulate_foreign_item(\n         &mut self,\n         def_id: DefId,\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n-    ) -> InterpResult<'tcx> {\n+        _unwind: Option<mir::BasicBlock>\n+    ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         let attrs = this.tcx.get_attrs(def_id);\n         let link_name = match attr::first_attr_value_str_by_name(&attrs, sym::link_name) {\n@@ -124,8 +130,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // First: functions that diverge.\n         match link_name {\n-            \"__rust_start_panic\" | \"panic_impl\" => {\n-                throw_unsup_format!(\"the evaluated program panicked\");\n+            // Note that this matches calls to the *foreign* item \"__rust_start_panic\" -\n+            // that is, calls `extern \"Rust\" { fn __rust_start_panic(...) }`\n+            // We forward this to the underlying *implementation* in \"libpanic_unwind\"\n+            \"__rust_start_panic\" => {\n+                let start_panic_instance = this.resolve_path(&[\"panic_unwind\", \"__rust_start_panic\"])?;\n+                return Ok(Some(this.load_mir(start_panic_instance.def, None)?));\n+            }\n+\n+            // During a normal (non-Miri) compilation,\n+            // this gets resolved to the '#[panic_handler]` function at link time,\n+            // which corresponds to the function with the `#[panic_handler]` attribute.\n+            //\n+            // Since we're interpreting mir, we forward it to the implementation of `panic_impl`\n+            //\n+            // This is used by libcore to forward panics to the actual\n+            // panic impl\n+            \"panic_impl\" => {\n+                let panic_impl_id = this.tcx.lang_items().panic_impl().unwrap();\n+                let panic_impl_instance = ty::Instance::mono(*this.tcx, panic_impl_id);\n+                return Ok(Some(this.load_mir(panic_impl_instance.def, None)?));\n             }\n             \"exit\" | \"ExitProcess\" => {\n                 // it's really u32 for ExitProcess, but we have to put it into the `Exit` error variant anyway\n@@ -310,48 +334,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             }\n \n             \"__rust_maybe_catch_panic\" => {\n-                // fn __rust_maybe_catch_panic(\n-                //     f: fn(*mut u8),\n-                //     data: *mut u8,\n-                //     data_ptr: *mut usize,\n-                //     vtable_ptr: *mut usize,\n-                // ) -> u32\n-                // We abort on panic, so not much is going on here, but we still have to call the closure.\n-                let f = this.read_scalar(args[0])?.not_undef()?;\n-                let data = this.read_scalar(args[1])?.not_undef()?;\n-                let f_instance = this.memory.get_fn(f)?.as_instance()?;\n-                this.write_null(dest)?;\n-                trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n-\n-                // Now we make a function call.\n-                // TODO: consider making this reusable? `InterpCx::step` does something similar\n-                // for the TLS destructors, and of course `eval_main`.\n-                let mir = this.load_mir(f_instance.def, None)?;\n-                let ret_place =\n-                    MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n-                this.push_stack_frame(\n-                    f_instance,\n-                    mir.span,\n-                    mir,\n-                    Some(ret_place),\n-                    // Directly return to caller.\n-                    StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n-                )?;\n-                let mut args = this.frame().body.args_iter();\n-\n-                let arg_local = args\n-                    .next()\n-                    .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n-                let arg_dest = this.local_place(arg_local)?;\n-                this.write_scalar(data, arg_dest)?;\n-\n-                args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n-\n-                // We ourselves will return `0`, eventually (because we will not return if we paniced).\n-                this.write_null(dest)?;\n-\n-                // Don't fall through, we do *not* want to `goto_block`!\n-                return Ok(());\n+                this.handle_catch_panic(args, dest, ret)?;\n+                return Ok(None)\n             }\n \n             \"memcmp\" => {\n@@ -943,7 +927,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         this.goto_block(Some(ret))?;\n         this.dump_place(*dest);\n-        Ok(())\n+        Ok(None)\n     }\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)"}, {"sha": "0e7314c1809f16224b95181671b4487fa19dfafa", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 25, "deletions": 8, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -7,10 +7,7 @@ use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n use syntax::source_map::Span;\n \n-use crate::{\n-    PlaceTy, OpTy, Immediate, Scalar, Tag,\n-    OperatorEvalContextExt\n-};\n+use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n@@ -19,10 +16,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         span: Span,\n         instance: ty::Instance<'tcx>,\n         args: &[OpTy<'tcx, Tag>],\n-        dest: PlaceTy<'tcx, Tag>,\n+        dest: Option<PlaceTy<'tcx, Tag>>,\n+        _ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        if this.emulate_intrinsic(span, instance, args, Some(dest))? {\n+        if this.emulate_intrinsic(span, instance, args, dest)? {\n             return Ok(());\n         }\n         let tcx = &{this.tcx.tcx};\n@@ -31,8 +30,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // All these intrinsics take raw pointers, so if we access memory directly\n         // (as opposed to through a place), we have to remember to erase any tag\n         // that might still hang around!\n-\n         let intrinsic_name = &*tcx.item_name(instance.def_id()).as_str();\n+\n+        // Handle diverging intrinsics\n+        match intrinsic_name {\n+            \"abort\" => {\n+                // FIXME: Add a better way of indicating 'abnormal' termination,\n+                // since this is not really an 'unsupported' behavior\n+                throw_unsup_format!(\"the evaluated program aborted!\");\n+            }\n+            \"miri_start_panic\" => return this.handle_miri_start_panic(args, unwind),\n+            _ => {}\n+        }\n+\n+        // Handle non-diverging intrinsics\n+        // The intrinsic itself cannot diverge (otherwise, we would have handled it above),\n+        // so if we got here without a return place... (can happen e.g., for transmute returning `!`)\n+        let dest = match dest {\n+            Some(dest) => dest,\n+            None => throw_ub!(Unreachable)\n+        };\n+\n         match intrinsic_name {\n             \"arith_offset\" => {\n                 let offset = this.read_scalar(args[1])?.to_machine_isize(this)?;\n@@ -526,7 +544,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 // However, this only affects direct calls of the intrinsic; calls to the stable\n                 // functions wrapping them do get their validation.\n                 // FIXME: should we check alignment for ZSTs?\n-                use crate::ScalarMaybeUndef;\n                 if !dest.layout.is_zst() {\n                     match dest.layout.abi {\n                         layout::Abi::Scalar(..) => {"}, {"sha": "f554c19f11c2708dbfb7c5164844ed4d1043167b", "filename": "src/shims/mod.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -5,9 +5,9 @@ pub mod intrinsics;\n pub mod tls;\n pub mod fs;\n pub mod time;\n+pub mod panic;\n \n use rustc::{mir, ty};\n-\n use crate::*;\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n@@ -18,6 +18,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         args: &[OpTy<'tcx, Tag>],\n         dest: Option<PlaceTy<'tcx, Tag>>,\n         ret: Option<mir::BasicBlock>,\n+        unwind: Option<mir::BasicBlock>\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>> {\n         let this = self.eval_context_mut();\n         trace!(\n@@ -26,11 +27,6 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             dest.map(|place| *place)\n         );\n \n-        // First, run the common hooks also supported by CTFE.\n-        if this.hook_panic_fn(instance, args, dest)? {\n-            this.goto_block(ret)?;\n-            return Ok(None);\n-        }\n         // There are some more lang items we want to hook that CTFE does not hook (yet).\n         if this.tcx.lang_items().align_offset_fn() == Some(instance.def.def_id()) {\n             let dest = dest.unwrap();\n@@ -44,11 +40,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n         // Try to see if we can do something about foreign items.\n         if this.tcx.is_foreign_item(instance.def_id()) {\n-            // An external function that we cannot find MIR for, but we can still run enough\n-            // of them to make miri viable.\n-            this.emulate_foreign_item(instance.def_id(), args, dest, ret)?;\n-            // `goto_block` already handled.\n-            return Ok(None);\n+            // An external function call that does not have a MIR body. We either find MIR elsewhere\n+            // or emulate its effect.\n+            // This will be Ok(None) if we're emulating the intrinsic entirely within Miri (no need\n+            // to run extra MIR), and Ok(Some(body)) if we found MIR to run for the\n+            // foreign function\n+            // Any needed call to `goto_block` will be performed by `emulate_foreign_item`.\n+            return this.emulate_foreign_item(instance.def_id(), args, dest, ret, unwind);\n         }\n \n         // Otherwise, load the MIR."}, {"sha": "3e0dd767d8231000dc67758463e4a4bac83ae2d6", "filename": "src/shims/panic.rs", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1,179 @@\n+use rustc::mir;\n+use crate::*;\n+use super::machine::FrameData;\n+use rustc_target::spec::PanicStrategy;\n+use crate::rustc_target::abi::LayoutOf;\n+\n+/// Holds all of the relevant data for a call to\n+/// __rust_maybe_catch_panic\n+///\n+/// If a panic occurs, we update this data with\n+/// the information from the panic site\n+#[derive(Debug)]\n+pub struct CatchUnwindData<'tcx> {\n+    /// The 'data' argument passed to `__rust_maybe_catch_panic`\n+    pub data: Pointer<Tag>,\n+    /// The `data_ptr` argument passed to `__rust_maybe_catch_panic`\n+    pub data_place: MPlaceTy<'tcx, Tag>,\n+    /// The `vtable_ptr` argument passed to `__rust_maybe_catch_panic`\n+    pub vtable_place: MPlaceTy<'tcx, Tag>,\n+    /// The `dest` from the original call to `__rust_maybe_catch_panic`\n+    pub dest: PlaceTy<'tcx, Tag>,\n+    /// The `ret` from the original call to `__rust_maybe_catch_panic`\n+    pub ret: mir::BasicBlock,\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+\n+    /// Handles the special \"miri_start_panic\" intrinsic, which is called\n+    /// by libpanic_unwind to delegate the actual unwinding process to Miri\n+    #[inline(always)]\n+    fn handle_miri_start_panic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        unwind: Option<mir::BasicBlock>\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        trace!(\"miri_start_panic: {:?}\", this.frame().span);\n+\n+        if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Abort  {\n+            // FIXME: Add a better way of indicating 'abnormal' termination,\n+            // since this is not really an 'unsupported' behavior\n+            throw_unsup_format!(\"the evaluated program panicked\");\n+        }\n+\n+        // Get the raw pointer stored in arg[0]\n+        let scalar = this.read_immediate(args[0])?;\n+        this.machine.panic_payload = Some(scalar);\n+\n+        // Jump to the unwind block to begin unwinding\n+        // We don't use 'goto_block' - if `unwind` is None,\n+        // we'll end up immediately returning out of the\n+        // function during the next step() call\n+        let next_frame = this.frame_mut();\n+        next_frame.block = unwind;\n+        next_frame.stmt = 0;\n+        return Ok(())\n+    }\n+\n+    #[inline(always)]\n+    fn handle_catch_panic(\n+        &mut self,\n+        args: &[OpTy<'tcx, Tag>],\n+        dest: PlaceTy<'tcx, Tag>,\n+        ret: mir::BasicBlock,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let tcx = &{this.tcx.tcx};\n+\n+        // fn __rust_maybe_catch_panic(\n+        //     f: fn(*mut u8),\n+        //     data: *mut u8,\n+        //     data_ptr: *mut usize,\n+        //     vtable_ptr: *mut usize,\n+        // ) -> u32\n+        let f = this.read_scalar(args[0])?.not_undef()?;\n+        let data = this.read_scalar(args[1])?.not_undef()?;\n+        let data_place = this.deref_operand(args[2])?;\n+        let vtable_place = this.deref_operand(args[3])?;\n+        let f_instance = this.memory.get_fn(f)?.as_instance()?;\n+        this.write_null(dest)?;\n+        trace!(\"__rust_maybe_catch_panic: {:?}\", f_instance);\n+\n+\n+        // Now we make a function call.\n+        // TODO: consider making this reusable? `InterpCx::step` does something similar\n+        // for the TLS destructors, and of course `eval_main`.\n+        let mir = this.load_mir(f_instance.def, None)?;\n+        let ret_place =\n+            MPlaceTy::dangling(this.layout_of(tcx.mk_unit())?, this).into();\n+        this.push_stack_frame(\n+            f_instance,\n+            mir.span,\n+            mir,\n+            Some(ret_place),\n+            // Directly return to caller.\n+            StackPopCleanup::Goto { ret: Some(ret), unwind: None },\n+        )?;\n+\n+        // In unwind mode, we tag this frame with some extra data.\n+        // This lets `handle_stack_pop` (below) know that we should stop unwinding\n+        // when we pop this frame.\n+        if this.tcx.tcx.sess.panic_strategy() == PanicStrategy::Unwind {\n+            this.frame_mut().extra.catch_panic = Some(CatchUnwindData {\n+                data: data.to_ptr()?,\n+                data_place,\n+                vtable_place,\n+                dest,\n+                ret,\n+            })\n+        }\n+\n+        let mut args = this.frame().body.args_iter();\n+\n+        let arg_local = args\n+            .next()\n+            .expect(\"Argument to __rust_maybe_catch_panic does not take enough arguments.\");\n+        let arg_dest = this.local_place(arg_local)?;\n+        this.write_scalar(data, arg_dest)?;\n+\n+        args.next().expect_none(\"__rust_maybe_catch_panic argument has more arguments than expected\");\n+\n+        // We ourselves will return `0`, eventually (because we will not return if we paniced).\n+        this.write_null(dest)?;\n+\n+        return Ok(());\n+    }\n+\n+    #[inline(always)]\n+    fn handle_stack_pop(\n+        &mut self,\n+        mut extra: FrameData<'tcx>,\n+        unwinding: bool\n+    ) -> InterpResult<'tcx, StackPopInfo> {\n+        let this = self.eval_context_mut();\n+\n+        trace!(\"handle_stack_pop(extra = {:?}, unwinding = {})\", extra, unwinding);\n+\n+        // We only care about `catch_panic` if we're unwinding - if we're doing a normal\n+        // return, then we don't need to do anything special.\n+        let res = if let (true, Some(unwind_data)) = (unwinding, extra.catch_panic.take()) {\n+            // We've just popped the frame that was immediately above\n+            // the frame which originally called `__rust_maybe_catch_panic`\n+            trace!(\"unwinding: found catch_panic frame: {:?}\", this.frame().span);\n+\n+            // `panic_payload` now holds a  '*mut (dyn Any + Send)',\n+            // provided by the `miri_start_panic` intrinsic.\n+            // We want to split this into its consituient parts -\n+            // the data and vtable pointers - and store them back\n+            // into the panic handler frame\n+            let real_ret = this.machine.panic_payload.take().unwrap();\n+\n+            let payload = this.ref_to_mplace(real_ret)?;\n+            let payload_data_place = payload.ptr;\n+            let payload_vtable_place = payload.meta.expect(\"Expected fat pointer\");\n+\n+\n+            let data_place = unwind_data.data_place;\n+            let vtable_place = unwind_data.vtable_place;\n+            let dest = unwind_data.dest;\n+\n+            // Here, we write to the pointers provided to the call\n+            // to '__rust_maybe_catch_panic`.\n+            this.write_scalar(payload_data_place, data_place.into())?;\n+            this.write_scalar(payload_vtable_place, vtable_place.into())?;\n+\n+            // We set the return value of `__rust_maybe_catch_panic` to 1,\n+            // since there was a panic.\n+            this.write_scalar(Scalar::from_int(1, dest.layout.size), dest)?;\n+\n+            StackPopInfo::StopUnwinding\n+        } else {\n+            StackPopInfo::Normal\n+        };\n+        this.memory.extra.stacked_borrows.borrow_mut().end_call(extra.call_id);\n+        Ok(res)\n+    }\n+}"}, {"sha": "3b821c7155a6f0c0d4ea78fd4afc8839595b4123", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -532,7 +532,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         protect: bool,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let protector = if protect { Some(this.frame().extra) } else { None };\n+        let protector = if protect { Some(this.frame().extra.call_id) } else { None };\n         let ptr = place.ptr.to_ptr().expect(\"we should have a proper pointer\");\n         trace!(\"reborrow: {} reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr.erase_tag(), size.bytes());"}, {"sha": "950d865c2a5624712e68ed6bc6ea683b00c28b96", "filename": "tests/compile-fail/double_panic.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fdouble_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fdouble_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdouble_panic.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1,11 @@\n+ //error-pattern: the evaluated program aborted\n+struct Foo;\n+impl Drop for Foo {\n+    fn drop(&mut self) {\n+        panic!(\"second\");\n+    }\n+}\n+fn main() {\n+    let _foo = Foo;\n+    panic!(\"first\"); \n+}"}, {"sha": "ff499316920f843758e025313c8321638d6d4084", "filename": "tests/compile-fail/panic1.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic1.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -1,5 +1,5 @@\n-//error-pattern: the evaluated program panicked\n-\n+// error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n fn main() {\n     std::panic!(\"panicking from libstd\");\n }"}, {"sha": "3b36db2d2d81dfb0a6f21e78fcf0fac7e2117989", "filename": "tests/compile-fail/panic2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic2.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -1,4 +1,5 @@\n-//error-pattern: the evaluated program panicked\n+// error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     std::panic!(\"{}-panicking from libstd\", 42);"}, {"sha": "6f5d6c3e1ce343b1573ee62388ba0e70936ec570", "filename": "tests/compile-fail/panic3.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic3.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -1,4 +1,5 @@\n //error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     core::panic!(\"panicking from libcore\");"}, {"sha": "22d675375ac422e7f74c65d52b4b066cfc7b429e", "filename": "tests/compile-fail/panic4.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Fcompile-fail%2Fpanic4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fpanic4.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -1,4 +1,5 @@\n //error-pattern: the evaluated program panicked\n+// compile-flags: -C panic=abort\n \n fn main() {\n     core::panic!(\"{}-panicking from libcore\", 42);"}, {"sha": "8e254385d4743413b944c662bf83e1633287d683", "filename": "tests/run-pass/catch_panic.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fcatch_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fcatch_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fcatch_panic.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1,61 @@\n+use std::panic::catch_unwind;\n+use std::cell::Cell;\n+\n+thread_local! {\n+    static MY_COUNTER: Cell<usize> = Cell::new(0);\n+    static DROPPED: Cell<bool> = Cell::new(false);\n+    static HOOK_CALLED: Cell<bool> = Cell::new(false);\n+}\n+\n+struct DropTester;\n+\n+impl Drop for DropTester {\n+    fn drop(&mut self) {\n+        DROPPED.with(|c| {\n+            c.set(true);\n+        });\n+    }\n+}\n+\n+fn do_panic_counter() {\n+    // If this gets leaked, it will be easy to spot\n+    // in Miri's leak report\n+    let _string = \"LEAKED FROM do_panic_counter\".to_string();\n+\n+    // When we panic, this should get dropped during unwinding\n+    let _drop_tester = DropTester;\n+\n+    // Check for bugs in Miri's panic implementation.\n+    // If do_panic_counter() somehow gets called more than once,\n+    // we'll generate a different panic message\n+    let old_val = MY_COUNTER.with(|c| {\n+        let val = c.get();\n+        c.set(val + 1);\n+        val\n+    });\n+    panic!(format!(\"Hello from panic: {:?}\", old_val));\n+}\n+\n+fn main() {\n+    std::panic::set_hook(Box::new(|_panic_info| {\n+        HOOK_CALLED.with(|h| h.set(true));\n+    }));\n+    let res = catch_unwind(|| {\n+        let _string = \"LEAKED FROM CLOSURE\".to_string();\n+        do_panic_counter()\n+    });\n+    let expected: Box<String> = Box::new(\"Hello from panic: 0\".to_string());\n+    let actual = res.expect_err(\"do_panic() did not panic!\")\n+        .downcast::<String>().expect(\"Failed to cast to string!\");\n+        \n+    assert_eq!(expected, actual);\n+    DROPPED.with(|c| {\n+        // This should have been set to 'true' by DropTester\n+        assert!(c.get());\n+    });\n+\n+    HOOK_CALLED.with(|h| {\n+        assert!(h.get());\n+    });\n+}\n+"}, {"sha": "b9bb52b95b13fce39ec2a9be00a9362d1cb89477", "filename": "tests/run-pass/panic1.rs", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic1.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1,3 @@\n+fn main() {\n+    panic!(\"Miri panic!\");\n+}"}, {"sha": "a29ba479825a7ec7b47175c8d600752e5d301f9b", "filename": "tests/run-pass/panic1.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic1.stderr?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1 @@\n+thread 'main' panicked at 'Miri panic!', $DIR/panic1.rs:2:5"}, {"sha": "9a1da6656c26d5371ed35cdf4f795c952a38fe2d", "filename": "tests/run-pass/panic2.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic2.rs?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    let val = \"Value\".to_string();\n+    panic!(\"Miri panic with value: {}\", val);\n+}"}, {"sha": "de70fd4d583e9ffc777d4b62fa1746a260d34365", "filename": "tests/run-pass/panic2.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/08d3fbc76b72fd06cade88b2afe21b70978e8797/tests%2Frun-pass%2Fpanic2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fpanic2.stderr?ref=08d3fbc76b72fd06cade88b2afe21b70978e8797", "patch": "@@ -0,0 +1 @@\n+thread 'main' panicked at 'Miri panic with value: Value', $DIR/panic2.rs:3:5"}]}