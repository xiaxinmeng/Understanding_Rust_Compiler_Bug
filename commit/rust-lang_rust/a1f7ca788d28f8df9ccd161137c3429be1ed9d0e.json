{"sha": "a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExZjdjYTc4OGQyOGY4ZGY5Y2NkMTYxMTM3YzM0MjliZTFlZDlkMGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-13T11:49:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-11-13T11:49:33Z"}, "message": "Auto merge of #77990 - bugadani:copies, r=lcnr\n\nEliminate some temporary vectors\n\nThis PR changes `get_item_attrs` and `get_item_variances` to return iterator impls instead of vectors. On top of that, this PR replaces some seemingly unnecessary vectors with iterators or SmallVec, and also reserves space where we know (the minimum) number of elements that will be inserted. This change hopes to remove a few heap allocations and unnecessary copies.", "tree": {"sha": "4d3f4dc61f814c865a2e52b8eb6addc1de7dc223", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4d3f4dc61f814c865a2e52b8eb6addc1de7dc223"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "html_url": "https://github.com/rust-lang/rust/commit/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c4df6bb343e89c382ae2301505013132af77319", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c4df6bb343e89c382ae2301505013132af77319", "html_url": "https://github.com/rust-lang/rust/commit/2c4df6bb343e89c382ae2301505013132af77319"}, {"sha": "f0d0d87a2002dea7365ce2230e2df2ed4786fcbe", "url": "https://api.github.com/repos/rust-lang/rust/commits/f0d0d87a2002dea7365ce2230e2df2ed4786fcbe", "html_url": "https://github.com/rust-lang/rust/commit/f0d0d87a2002dea7365ce2230e2df2ed4786fcbe"}], "stats": {"total": 95, "additions": 50, "deletions": 45}, "files": [{"sha": "fe67b905bf30f01a9b3eead31fc7cd2f5472c3ce", "filename": "compiler/rustc_ast/src/tokenstream.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast%2Fsrc%2Ftokenstream.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -221,7 +221,7 @@ impl TokenStream {\n             }\n         }\n         if let Some((pos, comma, sp)) = suggestion {\n-            let mut new_stream = vec![];\n+            let mut new_stream = Vec::with_capacity(self.0.len() + 1);\n             let parts = self.0.split_at(pos + 1);\n             new_stream.extend_from_slice(parts.0);\n             new_stream.push(comma);"}, {"sha": "b94fb1d8437ed7089a6e84708e70116a4b851edd", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -1367,14 +1367,18 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n         let mut used_input_regs = FxHashMap::default();\n         let mut used_output_regs = FxHashMap::default();\n+        let mut required_features: Vec<&str> = vec![];\n         for (idx, op) in operands.iter().enumerate() {\n             let op_sp = asm.operands[idx].1;\n             if let Some(reg) = op.reg() {\n+                // Make sure we don't accidentally carry features from the\n+                // previous iteration.\n+                required_features.clear();\n+\n                 // Validate register classes against currently enabled target\n                 // features. We check that at least one type is available for\n                 // the current target.\n                 let reg_class = reg.reg_class();\n-                let mut required_features: Vec<&str> = vec![];\n                 for &(_, feature) in reg_class.supported_types(asm_arch) {\n                     if let Some(feature) = feature {\n                         if self.sess.target_features.contains(&Symbol::intern(feature)) {"}, {"sha": "88ad2706eacf5899c459935f8e1a92fe9fba9479", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -2011,17 +2011,17 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         //\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n-        let mut generic_args: Vec<_> = lifetime_params[..input_lifetimes_count]\n-            .iter()\n-            .map(|&(span, hir_name)| {\n+        let mut generic_args = Vec::with_capacity(lifetime_params.len());\n+        generic_args.extend(lifetime_params[..input_lifetimes_count].iter().map(\n+            |&(span, hir_name)| {\n                 // Input lifetime like `'a` or `'1`:\n                 GenericArg::Lifetime(hir::Lifetime {\n                     hir_id: self.next_id(),\n                     span,\n                     name: hir::LifetimeName::Param(hir_name),\n                 })\n-            })\n-            .collect();\n+            },\n+        ));\n         generic_args.extend(lifetime_params[input_lifetimes_count..].iter().map(|&(span, _)|\n             // Output lifetime like `'_`.\n             GenericArg::Lifetime(hir::Lifetime {\n@@ -2312,29 +2312,30 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     }\n \n     fn lower_block_noalloc(&mut self, b: &Block, targeted_by_break: bool) -> hir::Block<'hir> {\n-        let mut stmts = vec![];\n         let mut expr: Option<&'hir _> = None;\n \n-        for (index, stmt) in b.stmts.iter().enumerate() {\n-            if index == b.stmts.len() - 1 {\n-                if let StmtKind::Expr(ref e) = stmt.kind {\n-                    expr = Some(self.lower_expr(e));\n-                } else {\n-                    stmts.extend(self.lower_stmt(stmt));\n-                }\n-            } else {\n-                stmts.extend(self.lower_stmt(stmt));\n-            }\n-        }\n+        let stmts = self.arena.alloc_from_iter(\n+            b.stmts\n+                .iter()\n+                .enumerate()\n+                .filter_map(|(index, stmt)| {\n+                    if index == b.stmts.len() - 1 {\n+                        if let StmtKind::Expr(ref e) = stmt.kind {\n+                            expr = Some(self.lower_expr(e));\n+                            None\n+                        } else {\n+                            Some(self.lower_stmt(stmt))\n+                        }\n+                    } else {\n+                        Some(self.lower_stmt(stmt))\n+                    }\n+                })\n+                .flatten(),\n+        );\n+        let rules = self.lower_block_check_mode(&b.rules);\n+        let hir_id = self.lower_node_id(b.id);\n \n-        hir::Block {\n-            hir_id: self.lower_node_id(b.id),\n-            stmts: self.arena.alloc_from_iter(stmts),\n-            expr,\n-            rules: self.lower_block_check_mode(&b.rules),\n-            span: b.span,\n-            targeted_by_break,\n-        }\n+        hir::Block { hir_id, stmts, expr, rules, span: b.span, targeted_by_break }\n     }\n \n     /// Lowers a block directly to an expression, presuming that it"}, {"sha": "9381264f498f34938949cba477cd6c113b9d1e85", "filename": "compiler/rustc_builtin_macros/src/deriving/debug.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdebug.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -66,7 +66,7 @@ fn show_substructure(cx: &mut ExtCtxt<'_>, span: Span, substr: &Substructure<'_>\n \n     let fmt = substr.nonself_args[0].clone();\n \n-    let mut stmts = vec![];\n+    let mut stmts = Vec::with_capacity(fields.len() + 2);\n     match vdata {\n         ast::VariantData::Tuple(..) | ast::VariantData::Unit(..) => {\n             // tuple struct/\"normal\" variant"}, {"sha": "02da85d25d5c552de3f232edc2ba6accb0e4380a", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -30,6 +30,8 @@ fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> LintLevelMap {\n     let mut builder = LintLevelMapBuilder { levels, tcx, store };\n     let krate = tcx.hir().krate();\n \n+    builder.levels.id_to_set.reserve(krate.exported_macros.len() + 1);\n+\n     let push = builder.levels.push(&krate.item.attrs, &store, true);\n     builder.levels.register_id(hir::CRATE_HIR_ID);\n     for macro_def in krate.exported_macros {"}, {"sha": "a1df1a63fc58d3f265cbb4bd602f8ca13913b1e6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -784,14 +784,15 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             }\n         };\n \n+        let attrs: Vec<_> = self.get_item_attrs(id, sess).collect();\n         SyntaxExtension::new(\n             sess,\n             kind,\n             self.get_span(id, sess),\n             helper_attrs,\n             self.root.edition,\n             Symbol::intern(name),\n-            &self.get_item_attrs(id, sess),\n+            &attrs,\n         )\n     }\n \n@@ -1157,7 +1158,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n                                 // within the crate. We only need this for fictive constructors,\n                                 // for other constructors correct visibilities\n                                 // were already encoded in metadata.\n-                                let attrs = self.get_item_attrs(def_id.index, sess);\n+                                let attrs: Vec<_> =\n+                                    self.get_item_attrs(def_id.index, sess).collect();\n                                 if sess.contains_name(&attrs, sym::non_exhaustive) {\n                                     let crate_def_id = self.local_def_id(CRATE_DEF_INDEX);\n                                     vis = ty::Visibility::Restricted(crate_def_id);\n@@ -1283,8 +1285,8 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_variances(&self, id: DefIndex) -> Vec<ty::Variance> {\n-        self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self).collect()\n+    fn get_item_variances(&'a self, id: DefIndex) -> impl Iterator<Item = ty::Variance> + 'a {\n+        self.root.tables.variances.get(self, id).unwrap_or_else(Lazy::empty).decode(self)\n     }\n \n     fn get_ctor_kind(&self, node_id: DefIndex) -> CtorKind {\n@@ -1308,7 +1310,11 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         }\n     }\n \n-    fn get_item_attrs(&self, node_id: DefIndex, sess: &Session) -> Vec<ast::Attribute> {\n+    fn get_item_attrs(\n+        &'a self,\n+        node_id: DefIndex,\n+        sess: &'a Session,\n+    ) -> impl Iterator<Item = ast::Attribute> + 'a {\n         // The attributes for a tuple struct/variant are attached to the definition, not the ctor;\n         // we assume that someone passing in a tuple struct ctor is actually wanting to\n         // look at the definition\n@@ -1325,7 +1331,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n             .get(self, item_id)\n             .unwrap_or_else(Lazy::empty)\n             .decode((self, sess))\n-            .collect::<Vec<_>>()\n     }\n \n     fn get_struct_field_names(&self, id: DefIndex, sess: &Session) -> Vec<Spanned<Symbol>> {"}, {"sha": "85dc60d7eed6d57b61745fdca12410b0207ce7c8", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -138,7 +138,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         cdata.get_deprecation(def_id.index).map(DeprecationEntry::external)\n     }\n     item_attrs => { tcx.arena.alloc_from_iter(\n-        cdata.get_item_attrs(def_id.index, tcx.sess).into_iter()\n+        cdata.get_item_attrs(def_id.index, tcx.sess)\n     ) }\n     fn_arg_names => { cdata.get_fn_param_names(tcx, def_id.index) }\n     rendered_const => { cdata.get_rendered_const(def_id.index) }\n@@ -415,11 +415,7 @@ impl CStore {\n \n         let span = data.get_span(id.index, sess);\n \n-        // Mark the attrs as used\n-        let attrs = data.get_item_attrs(id.index, sess);\n-        for attr in attrs.iter() {\n-            sess.mark_attr_used(attr);\n-        }\n+        let attrs = data.get_item_attrs(id.index, sess).collect();\n \n         let ident = data.item_ident(id.index, sess);\n \n@@ -428,7 +424,7 @@ impl CStore {\n                 ident,\n                 id: ast::DUMMY_NODE_ID,\n                 span,\n-                attrs: attrs.to_vec(),\n+                attrs,\n                 kind: ast::ItemKind::MacroDef(data.get_macro(id.index, sess)),\n                 vis: ast::Visibility {\n                     span: span.shrink_to_lo(),"}, {"sha": "ea18a689065e30adc5462fde012afbdabf261dc3", "filename": "compiler/rustc_trait_selection/src/traits/select/candidate_assembly.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1f7ca788d28f8df9ccd161137c3429be1ed9d0e/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fcandidate_assembly.rs?ref=a1f7ca788d28f8df9ccd161137c3429be1ed9d0e", "patch": "@@ -353,16 +353,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             all_bounds.filter(|p| p.def_id() == stack.obligation.predicate.def_id());\n \n         // Keep only those bounds which may apply, and propagate overflow if it occurs.\n-        let mut param_candidates = vec![];\n         for bound in matching_bounds {\n             let wc = self.evaluate_where_clause(stack, bound)?;\n             if wc.may_apply() {\n-                param_candidates.push(ParamCandidate(bound));\n+                candidates.vec.push(ParamCandidate(bound));\n             }\n         }\n \n-        candidates.vec.extend(param_candidates);\n-\n         Ok(())\n     }\n "}]}