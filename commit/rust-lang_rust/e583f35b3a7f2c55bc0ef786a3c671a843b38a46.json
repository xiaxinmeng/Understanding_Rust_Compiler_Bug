{"sha": "e583f35b3a7f2c55bc0ef786a3c671a843b38a46", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1ODNmMzViM2E3ZjJjNTViYzBlZjc4NmEzYzY3MWE4NDNiMzhhNDY=", "commit": {"author": {"name": "Unknown", "email": "dobbybabee@gmail.com", "date": "2019-01-13T21:53:26Z"}, "committer": {"name": "unknown", "email": "unknown@example.com", "date": "2019-02-01T18:21:19Z"}, "message": "rustfmt", "tree": {"sha": "df2acbb0fa2c3850f5bb274a84a965c34e6b67cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/df2acbb0fa2c3850f5bb274a84a965c34e6b67cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e583f35b3a7f2c55bc0ef786a3c671a843b38a46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e583f35b3a7f2c55bc0ef786a3c671a843b38a46", "html_url": "https://github.com/rust-lang/rust/commit/e583f35b3a7f2c55bc0ef786a3c671a843b38a46", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e583f35b3a7f2c55bc0ef786a3c671a843b38a46/comments", "author": null, "committer": null, "parents": [{"sha": "3a97b5fa2048211b16d362be34293912fe996113", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a97b5fa2048211b16d362be34293912fe996113", "html_url": "https://github.com/rust-lang/rust/commit/3a97b5fa2048211b16d362be34293912fe996113"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "e95bf6639fc87584380fa744ba59b21254793683", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e583f35b3a7f2c55bc0ef786a3c671a843b38a46/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e583f35b3a7f2c55bc0ef786a3c671a843b38a46/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=e583f35b3a7f2c55bc0ef786a3c671a843b38a46", "patch": "@@ -85,15 +85,12 @@ declare_clippy_lint! {\n #[derive(Copy, Clone)]\n pub struct Functions {\n     threshold: u64,\n-    max_lines: u64\n+    max_lines: u64,\n }\n \n impl Functions {\n     pub fn new(threshold: u64, max_lines: u64) -> Self {\n-        Self {\n-            threshold,\n-            max_lines\n-        }\n+        Self { threshold, max_lines }\n     }\n }\n \n@@ -190,36 +187,38 @@ impl<'a, 'tcx> Functions {\n         // Skip the surrounding function decl.\n         let start_brace_idx = match code_snippet.find(\"{\") {\n             Some(i) => i + 1,\n-            None => 0\n+            None => 0,\n         };\n         let end_brace_idx = match code_snippet.find(\"}\") {\n             Some(i) => i,\n-            None => code_snippet.len()\n+            None => code_snippet.len(),\n         };\n         let function_lines = code_snippet[start_brace_idx..end_brace_idx].lines();\n \n         for mut line in function_lines {\n             code_in_line = false;\n             loop {\n                 line = line.trim_start();\n-                if line.is_empty() { break; }\n+                if line.is_empty() {\n+                    break;\n+                }\n                 if in_comment {\n                     match line.find(\"*/\") {\n                         Some(i) => {\n                             line = &line[i + 2..];\n                             in_comment = false;\n                             continue;\n                         },\n-                        None => break\n+                        None => break,\n                     }\n                 } else {\n                     let multi_idx = match line.find(\"/*\") {\n                         Some(i) => i,\n-                        None => line.len()\n+                        None => line.len(),\n                     };\n                     let single_idx = match line.find(\"//\") {\n                         Some(i) => i,\n-                        None => line.len()\n+                        None => line.len(),\n                     };\n                     code_in_line |= multi_idx > 0 && single_idx > 0;\n                     // Implies multi_idx is below line.len()\n@@ -231,12 +230,13 @@ impl<'a, 'tcx> Functions {\n                     break;\n                 }\n             }\n-            if code_in_line { line_count += 1; }\n+            if code_in_line {\n+                line_count += 1;\n+            }\n         }\n \n         if line_count > self.max_lines {\n-            span_lint(cx, TOO_MANY_LINES, span,\n-                      \"This function has a large number of lines.\")\n+            span_lint(cx, TOO_MANY_LINES, span, \"This function has a large number of lines.\")\n         }\n     }\n "}]}