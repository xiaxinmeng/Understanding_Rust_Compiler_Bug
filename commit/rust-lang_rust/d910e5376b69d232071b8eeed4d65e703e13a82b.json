{"sha": "d910e5376b69d232071b8eeed4d65e703e13a82b", "node_id": "C_kwDOAAsO6NoAKGQ5MTBlNTM3NmI2OWQyMzIwNzFiOGVlZWQ0ZDY1ZTcwM2UxM2E4MmI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-08-09T12:04:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-08-09T12:04:54Z"}, "message": "Rollup merge of #100221 - compiler-errors:impossible-trait-items, r=lcnr,notriddle,camelid\n\nDon't document impossible to call default trait items on impls\n\nCloses #100176\n\nThis only skips documenting _default_ trait items on impls, not ones that are written inside the impl block. This is a conservative approach, since I think we should document all items written in an impl block (I guess unless hidden or whatever), but the existence of this new query I added makes this easy to extend to other rustdoc cases.", "tree": {"sha": "81ea31c690e0e14ab9d751b47b80431ad51ac0b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/81ea31c690e0e14ab9d751b47b80431ad51ac0b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d910e5376b69d232071b8eeed4d65e703e13a82b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJi8k1mCRBK7hj4Ov3rIwAAfiMIACWTzqQT+pVGaYcDvuPvd6DL\naNwMUSOGMOdKCYCujaE3/iapkUIz0LLNr2awA9sQmM6pHg5noymelcjm+J6cLtr7\niCL+9uIJi+sj/ZHMB19TRjnZX/7tkUZV8sCCxVxDbqWjKdo3x9uXYsFO7CtKik5O\nFsiaJNkwyeOEk5X/iOUw/iKRFnjbFXO5q1gsetOSJ8Inxe7wpRaBglBHbckXzmLV\ncOdK/SohCj5HT12csjmz4PlfLqmjJgGSIDU6FjyRPkrLDPC9wpaza744U1mUVh79\nwDi4BjpNFJX3UKiXHt42etG7AAFp7L0cUEn5xozvtySZxTzr73mf+z9UNVeSwGs=\n=0/ty\n-----END PGP SIGNATURE-----\n", "payload": "tree 81ea31c690e0e14ab9d751b47b80431ad51ac0b6\nparent 7efe24c3ed070193ca64f402036166c8ab0c44b3\nparent b3b23aada9382e7768c0bd4d8f79319d73558259\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1660046694 +0530\ncommitter GitHub <noreply@github.com> 1660046694 +0530\n\nRollup merge of #100221 - compiler-errors:impossible-trait-items, r=lcnr,notriddle,camelid\n\nDon't document impossible to call default trait items on impls\n\nCloses #100176\n\nThis only skips documenting _default_ trait items on impls, not ones that are written inside the impl block. This is a conservative approach, since I think we should document all items written in an impl block (I guess unless hidden or whatever), but the existence of this new query I added makes this easy to extend to other rustdoc cases.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d910e5376b69d232071b8eeed4d65e703e13a82b", "html_url": "https://github.com/rust-lang/rust/commit/d910e5376b69d232071b8eeed4d65e703e13a82b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d910e5376b69d232071b8eeed4d65e703e13a82b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7efe24c3ed070193ca64f402036166c8ab0c44b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/7efe24c3ed070193ca64f402036166c8ab0c44b3", "html_url": "https://github.com/rust-lang/rust/commit/7efe24c3ed070193ca64f402036166c8ab0c44b3"}, {"sha": "b3b23aada9382e7768c0bd4d8f79319d73558259", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b23aada9382e7768c0bd4d8f79319d73558259", "html_url": "https://github.com/rust-lang/rust/commit/b3b23aada9382e7768c0bd4d8f79319d73558259"}], "stats": {"total": 114, "additions": 113, "deletions": 1}, "files": [{"sha": "cfc75f673c8f5bb047a051662ef550d5b52edf0c", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d910e5376b69d232071b8eeed4d65e703e13a82b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d910e5376b69d232071b8eeed4d65e703e13a82b/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=d910e5376b69d232071b8eeed4d65e703e13a82b", "patch": "@@ -1956,6 +1956,14 @@ rustc_queries! {\n         }\n     }\n \n+    query is_impossible_method(key: (DefId, DefId)) -> bool {\n+        desc { |tcx|\n+            \"checking if {} is impossible to call within {}\",\n+            tcx.def_path_str(key.1),\n+            tcx.def_path_str(key.0),\n+        }\n+    }\n+\n     query method_autoderef_steps(\n         goal: CanonicalTyGoal<'tcx>\n     ) -> MethodAutoderefStepsResult<'tcx> {"}, {"sha": "b6d6df1eec6a12a56d3bd570f4a61eb04a25793d", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 76, "deletions": 1, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/d910e5376b69d232071b8eeed4d65e703e13a82b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d910e5376b69d232071b8eeed4d65e703e13a82b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=d910e5376b69d232071b8eeed4d65e703e13a82b", "patch": "@@ -34,7 +34,10 @@ use rustc_infer::traits::TraitEngineExt as _;\n use rustc_middle::ty::fold::TypeFoldable;\n use rustc_middle::ty::subst::{InternalSubsts, SubstsRef};\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, VtblEntry};\n+use rustc_middle::ty::{\n+    self, DefIdTree, GenericParamDefKind, Subst, ToPredicate, Ty, TyCtxt, TypeSuperVisitable,\n+    VtblEntry,\n+};\n use rustc_span::{sym, Span};\n use smallvec::SmallVec;\n \n@@ -503,6 +506,77 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     result\n }\n \n+/// Checks whether a trait's method is impossible to call on a given impl.\n+///\n+/// This only considers predicates that reference the impl's generics, and not\n+/// those that reference the method's generics.\n+fn is_impossible_method<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    (impl_def_id, trait_item_def_id): (DefId, DefId),\n+) -> bool {\n+    struct ReferencesOnlyParentGenerics<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n+        generics: &'tcx ty::Generics,\n+        trait_item_def_id: DefId,\n+    }\n+    impl<'tcx> ty::TypeVisitor<'tcx> for ReferencesOnlyParentGenerics<'tcx> {\n+        type BreakTy = ();\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            // If this is a parameter from the trait item's own generics, then bail\n+            if let ty::Param(param) = t.kind()\n+                && let param_def_id = self.generics.type_param(param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            t.super_visit_with(self)\n+        }\n+        fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ReEarlyBound(param) = r.kind()\n+                && let param_def_id = self.generics.region_param(&param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            r.super_visit_with(self)\n+        }\n+        fn visit_const(&mut self, ct: ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            if let ty::ConstKind::Param(param) = ct.kind()\n+                && let param_def_id = self.generics.const_param(&param, self.tcx).def_id\n+                && self.tcx.parent(param_def_id) == self.trait_item_def_id\n+            {\n+                return ControlFlow::BREAK;\n+            }\n+            ct.super_visit_with(self)\n+        }\n+    }\n+\n+    let generics = tcx.generics_of(trait_item_def_id);\n+    let predicates = tcx.predicates_of(trait_item_def_id);\n+    let impl_trait_ref =\n+        tcx.impl_trait_ref(impl_def_id).expect(\"expected impl to correspond to trait\");\n+    let param_env = tcx.param_env(impl_def_id);\n+\n+    let mut visitor = ReferencesOnlyParentGenerics { tcx, generics, trait_item_def_id };\n+    let predicates_for_trait = predicates.predicates.iter().filter_map(|(pred, span)| {\n+        if pred.visit_with(&mut visitor).is_continue() {\n+            Some(Obligation::new(\n+                ObligationCause::dummy_with_span(*span),\n+                param_env,\n+                ty::EarlyBinder(*pred).subst(tcx, impl_trait_ref.substs),\n+            ))\n+        } else {\n+            None\n+        }\n+    });\n+\n+    tcx.infer_ctxt().ignoring_regions().enter(|ref infcx| {\n+        let mut fulfill_ctxt = <dyn TraitEngine<'_>>::new(tcx);\n+        fulfill_ctxt.register_predicate_obligations(infcx, predicates_for_trait);\n+        !fulfill_ctxt.select_all_or_error(infcx).is_empty()\n+    })\n+}\n+\n #[derive(Clone, Debug)]\n enum VtblSegment<'tcx> {\n     MetadataDSA,\n@@ -883,6 +957,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         vtable_entries,\n         vtable_trait_upcasting_coercion_new_vptr_slot,\n         subst_and_check_impossible_predicates,\n+        is_impossible_method,\n         try_unify_abstract_consts: |tcx, param_env_and| {\n             let (param_env, (a, b)) = param_env_and.into_parts();\n             const_evaluatable::try_unify_abstract_consts(tcx, (a, b), param_env)"}, {"sha": "ae7d8c108d3eefa21cf0d1293b1dfea9432cc82d", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d910e5376b69d232071b8eeed4d65e703e13a82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d910e5376b69d232071b8eeed4d65e703e13a82b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d910e5376b69d232071b8eeed4d65e703e13a82b", "patch": "@@ -1550,6 +1550,15 @@ fn render_impl(\n         rendering_params: ImplRenderingParameters,\n     ) {\n         for trait_item in &t.items {\n+            // Skip over any default trait items that are impossible to call\n+            // (e.g. if it has a `Self: Sized` bound on an unsized type).\n+            if let Some(impl_def_id) = parent.item_id.as_def_id()\n+                && let Some(trait_item_def_id) = trait_item.item_id.as_def_id()\n+                && cx.tcx().is_impossible_method((impl_def_id, trait_item_def_id))\n+            {\n+                continue;\n+            }\n+\n             let n = trait_item.name;\n             if i.items.iter().any(|m| m.name == n) {\n                 continue;"}, {"sha": "24d6e3bdac1bd259a6213fedd7cf55d6aa96e216", "filename": "src/test/rustdoc/impossible-default.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d910e5376b69d232071b8eeed4d65e703e13a82b/src%2Ftest%2Frustdoc%2Fimpossible-default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d910e5376b69d232071b8eeed4d65e703e13a82b/src%2Ftest%2Frustdoc%2Fimpossible-default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimpossible-default.rs?ref=d910e5376b69d232071b8eeed4d65e703e13a82b", "patch": "@@ -0,0 +1,20 @@\n+#![crate_name = \"foo\"]\n+\n+// Check that default trait items that are impossible to satisfy\n+\n+pub trait Foo {\n+    fn needs_sized(&self)\n+    where\n+        Self: Sized,\n+    {}\n+\n+    fn no_needs_sized(&self) {}\n+}\n+\n+// @!has foo/struct.Bar.html '//*[@id=\"method.needs_sized\"]//h4[@class=\"code-header\"]' \\\n+// \"fn needs_sized\"\n+// @has foo/struct.Bar.html '//*[@id=\"method.no_needs_sized\"]//h4[@class=\"code-header\"]' \\\n+// \"fn no_needs_sized\"\n+pub struct Bar([u8]);\n+\n+impl Foo for Bar {}"}]}