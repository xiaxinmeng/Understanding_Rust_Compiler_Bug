{"sha": "2eb4f05850e25863f05a56b60931e9eb03944b56", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlYjRmMDU4NTBlMjU4NjNmMDVhNTZiNjA5MzFlOWViMDM5NDRiNTY=", "commit": {"author": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2013-12-12T21:27:26Z"}, "committer": {"name": "Florian Hahn", "email": "flo@fhahn.com", "date": "2014-01-22T18:20:47Z"}, "message": "Replace C types with Rust types in libstd, closes #7313", "tree": {"sha": "dbbb1b2aeb64ff54abf331d7be7bb9ce6615c9e0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbbb1b2aeb64ff54abf331d7be7bb9ce6615c9e0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2eb4f05850e25863f05a56b60931e9eb03944b56", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2eb4f05850e25863f05a56b60931e9eb03944b56", "html_url": "https://github.com/rust-lang/rust/commit/2eb4f05850e25863f05a56b60931e9eb03944b56", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2eb4f05850e25863f05a56b60931e9eb03944b56/comments", "author": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fhahn", "id": 450489, "node_id": "MDQ6VXNlcjQ1MDQ4OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/450489?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fhahn", "html_url": "https://github.com/fhahn", "followers_url": "https://api.github.com/users/fhahn/followers", "following_url": "https://api.github.com/users/fhahn/following{/other_user}", "gists_url": "https://api.github.com/users/fhahn/gists{/gist_id}", "starred_url": "https://api.github.com/users/fhahn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fhahn/subscriptions", "organizations_url": "https://api.github.com/users/fhahn/orgs", "repos_url": "https://api.github.com/users/fhahn/repos", "events_url": "https://api.github.com/users/fhahn/events{/privacy}", "received_events_url": "https://api.github.com/users/fhahn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "750d48b0ad1854b389ce1c209484f9146dc7aba0", "url": "https://api.github.com/repos/rust-lang/rust/commits/750d48b0ad1854b389ce1c209484f9146dc7aba0", "html_url": "https://github.com/rust-lang/rust/commit/750d48b0ad1854b389ce1c209484f9146dc7aba0"}], "stats": {"total": 331, "additions": 158, "deletions": 173}, "files": [{"sha": "40c4ad842fffeb8104b335120384b92ab9910551", "filename": "src/libstd/cleanup.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcleanup.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -10,12 +10,11 @@\n \n #[doc(hidden)];\n \n-use libc::c_void;\n use ptr;\n use unstable::intrinsics::TyDesc;\n use unstable::raw;\n \n-type DropGlue<'a> = 'a |**TyDesc, *c_void|;\n+type DropGlue<'a> = 'a |**TyDesc, *u8|;\n \n static RC_IMMORTAL : uint = 0x77777777;\n \n@@ -107,7 +106,7 @@ pub unsafe fn annihilate() {\n         stats.n_bytes_freed +=\n             (*((*alloc).type_desc)).size\n             + mem::size_of::<raw::Box<()>>();\n-        local_free(alloc as *i8);\n+        local_free(alloc as *u8);\n         true\n     });\n "}, {"sha": "7406fe8ee408d3ed4615e656b89cc6c880aead02", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -41,10 +41,9 @@ local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n // magic.\n \n use cast;\n-use libc;\n use prelude::*;\n use rt::task::{Task, LocalStorage};\n-use util;\n+use util::replace;\n \n /**\n  * Indexes a task-local data slot. This pointer is used for comparison to\n@@ -87,7 +86,7 @@ impl<T: 'static> LocalData for T {}\n // n.b. If TLS is used heavily in future, this could be made more efficient with\n //      a proper map.\n #[doc(hidden)]\n-pub type Map = ~[Option<(*libc::c_void, TLSValue, LoanState)>];\n+pub type Map = ~[Option<(*u8, TLSValue, LoanState)>];\n type TLSValue = ~LocalData;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n@@ -128,7 +127,7 @@ impl LoanState {\n     }\n }\n \n-fn key_to_key_value<T: 'static>(key: Key<T>) -> *libc::c_void {\n+fn key_to_key_value<T: 'static>(key: Key<T>) -> *u8 {\n     unsafe { cast::transmute(key) }\n }\n \n@@ -151,7 +150,7 @@ pub fn pop<T: 'static>(key: Key<T>) -> Option<T> {\n                 // Move the data out of the `entry` slot via util::replace.\n                 // This is guaranteed to succeed because we already matched\n                 // on `Some` above.\n-                let data = match util::replace(entry, None) {\n+                let data = match replace(entry, None) {\n                     Some((_, data, _)) => data,\n                     None => abort()\n                 };\n@@ -302,7 +301,7 @@ pub fn set<T: 'static>(key: Key<T>, data: T) {\n     let data = ~data as ~LocalData:;\n \n     fn insertion_position(map: &mut Map,\n-                          key: *libc::c_void) -> Option<uint> {\n+                          key: *u8) -> Option<uint> {\n         // First see if the map contains this key already\n         let curspot = map.iter().position(|entry| {\n             match *entry {"}, {"sha": "93762a3cdd5c7bf12b1b6faa07c3bc8e28462c09", "filename": "src/libstd/os.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -44,9 +44,9 @@ use unstable::finally::Finally;\n use sync::atomics::{AtomicInt, INIT_ATOMIC_INT, SeqCst};\n \n /// Delegates to the libc close() function, returning the same return value.\n-pub fn close(fd: c_int) -> c_int {\n+pub fn close(fd: int) -> int {\n     unsafe {\n-        libc::close(fd)\n+        libc::close(fd as c_int) as int\n     }\n }\n \n@@ -57,7 +57,7 @@ static BUF_BYTES : uint = 2048u;\n pub fn getcwd() -> Path {\n     use c_str::CString;\n \n-    let mut buf = [0 as libc::c_char, ..BUF_BYTES];\n+    let mut buf = [0 as c_char, ..BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as size_t).is_null() {\n             fail!()\n@@ -164,7 +164,7 @@ pub fn env() -> ~[(~str,~str)] {\n                        os::last_os_error());\n             }\n             let mut result = ~[];\n-            c_str::from_c_multistring(ch as *libc::c_char, None, |cstr| {\n+            c_str::from_c_multistring(ch as *c_char, None, |cstr| {\n                 result.push(cstr.as_str().unwrap().to_owned());\n             });\n             FreeEnvironmentStringsA(ch);\n@@ -173,7 +173,7 @@ pub fn env() -> ~[(~str,~str)] {\n         #[cfg(unix)]\n         unsafe fn get_env_pairs() -> ~[~str] {\n             extern {\n-                fn rust_env_pairs() -> **libc::c_char;\n+                fn rust_env_pairs() -> **c_char;\n             }\n             let environ = rust_env_pairs();\n             if environ as uint == 0 {\n@@ -306,9 +306,9 @@ pub struct Pipe {\n #[cfg(unix)]\n pub fn pipe() -> Pipe {\n     unsafe {\n-        let mut fds = Pipe {input: 0 as c_int,\n-                            out: 0 as c_int };\n-        assert_eq!(libc::pipe(&mut fds.input), (0 as c_int));\n+        let mut fds = Pipe {input: 0,\n+                            out: 0};\n+        assert_eq!(libc::pipe(&mut fds.input), 0);\n         return Pipe {input: fds.input, out: fds.out};\n     }\n }\n@@ -321,13 +321,13 @@ pub fn pipe() -> Pipe {\n         // fully understand. Here we explicitly make the pipe non-inheritable,\n         // which means to pass it to a subprocess they need to be duplicated\n         // first, as in std::run.\n-        let mut fds = Pipe {input: 0 as c_int,\n-                    out: 0 as c_int };\n+        let mut fds = Pipe {input: 0,\n+                    out: 0};\n         let res = libc::pipe(&mut fds.input, 1024 as ::libc::c_uint,\n                              (libc::O_BINARY | libc::O_NOINHERIT) as c_int);\n-        assert_eq!(res, 0 as c_int);\n-        assert!((fds.input != -1 as c_int && fds.input != 0 as c_int));\n-        assert!((fds.out != -1 as c_int && fds.input != 0 as c_int));\n+        assert_eq!(res, 0);\n+        assert!((fds.input != -1 && fds.input != 0 ));\n+        assert!((fds.out != -1 && fds.input != 0));\n         return Pipe {input: fds.input, out: fds.out};\n     }\n }\n@@ -699,7 +699,7 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n+unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~str] {\n     let mut args = ~[];\n     for i in range(0u, argc as uint) {\n         args.push(str::raw::from_c_str(*argv.offset(i as int)));\n@@ -715,7 +715,7 @@ unsafe fn load_argc_and_argv(argc: c_int, argv: **c_char) -> ~[~str] {\n #[cfg(target_os = \"macos\")]\n fn real_args() -> ~[~str] {\n     unsafe {\n-        let (argc, argv) = (*_NSGetArgc() as c_int,\n+        let (argc, argv) = (*_NSGetArgc() as int,\n                             *_NSGetArgv() as **c_char);\n         load_argc_and_argv(argc, argv)\n     }\n@@ -833,7 +833,7 @@ pub struct MemoryMap {\n     /// Pointer to the memory created or modified by this map.\n     data: *mut u8,\n     /// Number of bytes this map applies to\n-    len: size_t,\n+    len: uint,\n     /// Type of mapping\n     kind: MemoryMapKind\n }\n@@ -842,7 +842,7 @@ pub struct MemoryMap {\n pub enum MemoryMapKind {\n     /// Memory-mapped file. On Windows, the inner pointer is a handle to the mapping, and\n     /// corresponds to `CreateFileMapping`. Elsewhere, it is null.\n-    MapFile(*c_void),\n+    MapFile(*u8),\n     /// Virtual memory map. Usually used to change the permissions of a given chunk of memory.\n     /// Corresponds to `VirtualAlloc` on Windows.\n     MapVirtual\n@@ -857,7 +857,7 @@ pub enum MapOption {\n     /// The memory should be executable\n     MapExecutable,\n     /// Create a map for a specific address range. Corresponds to `MAP_FIXED` on POSIX.\n-    MapAddr(*c_void),\n+    MapAddr(*u8),\n     /// Create a memory mapping for a file with a given fd.\n     MapFd(c_int),\n     /// When using `MapFd`, the start of the map is `uint` bytes from the start of the file.\n@@ -881,7 +881,7 @@ pub enum MapError {\n     /// using `MapFd`, the target of the fd didn't have enough resources to fulfill the request.\n     ErrNoMem,\n     /// Unrecognized error. The inner value is the unrecognized errno.\n-    ErrUnknown(libc::c_int),\n+    ErrUnknown(int),\n     /// ## The following are win32-specific\n     ///\n     /// Unsupported combination of protection flags (`MapReadable`/`MapWritable`/`MapExecutable`).\n@@ -926,12 +926,12 @@ impl MemoryMap {\n     pub fn new(min_len: uint, options: &[MapOption]) -> Result<MemoryMap, MapError> {\n         use libc::off_t;\n \n-        let mut addr: *c_void = ptr::null();\n-        let mut prot: c_int = 0;\n-        let mut flags: c_int = libc::MAP_PRIVATE;\n-        let mut fd: c_int = -1;\n-        let mut offset: off_t = 0;\n-        let len = round_up(min_len, page_size()) as size_t;\n+        let mut addr: *u8 = ptr::null();\n+        let mut prot = 0;\n+        let mut flags = libc::MAP_PRIVATE;\n+        let mut fd = -1;\n+        let mut offset = 0;\n+        let len = round_up(min_len, page_size());\n \n         for &o in options.iter() {\n             match o {\n@@ -952,7 +952,7 @@ impl MemoryMap {\n         if fd == -1 { flags |= libc::MAP_ANON; }\n \n         let r = unsafe {\n-            libc::mmap(addr, len, prot, flags, fd, offset)\n+            libc::mmap(addr as *c_void, len as size_t, prot, flags, fd, offset)\n         };\n         if r.equiv(&libc::MAP_FAILED) {\n             Err(match errno() as c_int {\n@@ -961,7 +961,7 @@ impl MemoryMap {\n                 libc::EINVAL => ErrUnaligned,\n                 libc::ENODEV => ErrNoMapSupport,\n                 libc::ENOMEM => ErrNoMem,\n-                code => ErrUnknown(code)\n+                code => ErrUnknown(code as int)\n             })\n         } else {\n             Ok(MemoryMap {\n@@ -987,7 +987,7 @@ impl Drop for MemoryMap {\n     /// Unmap the mapping. Fails the task if `munmap` fails.\n     fn drop(&mut self) {\n         unsafe {\n-            match libc::munmap(self.data as *c_void, self.len) {\n+            match libc::munmap(self.data as *c_void, self.len as libc::size_t) {\n                 0 => (),\n                 -1 => match errno() as c_int {\n                     libc::EINVAL => error!(\"invalid addr or len\"),\n@@ -1011,7 +1011,7 @@ impl MemoryMap {\n         let mut executable = false;\n         let mut fd: c_int = -1;\n         let mut offset: uint = 0;\n-        let len = round_up(min_len, page_size()) as SIZE_T;\n+        let len = round_up(min_len, page_size());\n \n         for &o in options.iter() {\n             match o {\n@@ -1040,7 +1040,7 @@ impl MemoryMap {\n             }\n             let r = unsafe {\n                 libc::VirtualAlloc(lpAddress,\n-                                   len,\n+                                   len as SIZE_T,\n                                    libc::MEM_COMMIT | libc::MEM_RESERVE,\n                                    flProtect)\n             };\n@@ -1085,7 +1085,7 @@ impl MemoryMap {\n                     _ => Ok(MemoryMap {\n                        data: r as *mut u8,\n                        len: len,\n-                       kind: MapFile(mapping as *c_void)\n+                       kind: MapFile(mapping as *u8)\n                     })\n                 }\n             }\n@@ -1116,7 +1116,7 @@ impl Drop for MemoryMap {\n             match self.kind {\n                 MapVirtual => {\n                     if libc::VirtualFree(self.data as *mut c_void,\n-                                         self.len,\n+                                         self.len as size_t,\n                                          libc::MEM_RELEASE) == FALSE {\n                         error!(\"VirtualFree failed: {}\", errno());\n                     }"}, {"sha": "fe82ac7406924881789d111afa3e6edfa81d06ef", "filename": "src/libstd/rc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frc.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -78,7 +78,7 @@ impl<T> Drop for Rc<T> {\n                 if (*self.ptr).strong == 0 {\n                     read_ptr(self.borrow()); // destroy the contained object\n                     if (*self.ptr).weak == 0 {\n-                        exchange_free(self.ptr as *mut u8 as *i8)\n+                        exchange_free(self.ptr as *u8)\n                     }\n                 }\n             }\n@@ -153,7 +153,7 @@ impl<T> Drop for Weak<T> {\n             if self.ptr != 0 as *mut RcBox<T> {\n                 (*self.ptr).weak -= 1;\n                 if (*self.ptr).weak == 0 && (*self.ptr).strong == 0 {\n-                    exchange_free(self.ptr as *mut u8 as *i8)\n+                    exchange_free(self.ptr as *u8)\n                 }\n             }\n         }"}, {"sha": "c0af649f26cfe7395843f473b120248e2c0825d6", "filename": "src/libstd/reflect.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Freflect.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -17,7 +17,6 @@ Runtime type reflection\n #[allow(missing_doc)];\n \n use unstable::intrinsics::{Disr, Opaque, TyDesc, TyVisitor};\n-use libc::c_void;\n use mem;\n use unstable::raw;\n \n@@ -28,7 +27,7 @@ use unstable::raw;\n  * then build a MovePtrAdaptor wrapped around your struct.\n  */\n pub trait MovePtr {\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void);\n+    fn move_ptr(&mut self, adjustment: |*u8| -> *u8);\n     fn push_ptr(&mut self);\n     fn pop_ptr(&mut self);\n }\n@@ -50,12 +49,12 @@ pub fn MovePtrAdaptor<V:TyVisitor + MovePtr>(v: V) -> MovePtrAdaptor<V> {\n impl<V:TyVisitor + MovePtr> MovePtrAdaptor<V> {\n     #[inline]\n     pub fn bump(&mut self, sz: uint) {\n-        self.inner.move_ptr(|p| ((p as uint) + sz) as *c_void)\n+        self.inner.move_ptr(|p| ((p as uint) + sz) as *u8)\n     }\n \n     #[inline]\n     pub fn align(&mut self, a: uint) {\n-        self.inner.move_ptr(|p| align(p as uint, a) as *c_void)\n+        self.inner.move_ptr(|p| align(p as uint, a) as *u8)\n     }\n \n     #[inline]"}, {"sha": "e3b34147c010a33e33413fa8d1dab0b3fde898a3", "filename": "src/libstd/repr.rs", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frepr.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -21,7 +21,6 @@ use char;\n use container::Container;\n use io;\n use iter::Iterator;\n-use libc::c_void;\n use option::{Some, None};\n use ptr;\n use reflect;\n@@ -98,13 +97,13 @@ enum VariantState {\n }\n \n pub struct ReprVisitor<'a> {\n-    priv ptr: *c_void,\n-    priv ptr_stk: ~[*c_void],\n+    priv ptr: *u8,\n+    priv ptr_stk: ~[*u8],\n     priv var_stk: ~[VariantState],\n     priv writer: &'a mut io::Writer\n }\n \n-pub fn ReprVisitor<'a>(ptr: *c_void,\n+pub fn ReprVisitor<'a>(ptr: *u8,\n                        writer: &'a mut io::Writer) -> ReprVisitor<'a> {\n     ReprVisitor {\n         ptr: ptr,\n@@ -116,7 +115,7 @@ pub fn ReprVisitor<'a>(ptr: *c_void,\n \n impl<'a> MovePtr for ReprVisitor<'a> {\n     #[inline]\n-    fn move_ptr(&mut self, adjustment: |*c_void| -> *c_void) {\n+    fn move_ptr(&mut self, adjustment: |*u8| -> *u8) {\n         self.ptr = adjustment(self.ptr);\n     }\n     fn push_ptr(&mut self) {\n@@ -133,7 +132,7 @@ impl<'a> ReprVisitor<'a> {\n     #[inline]\n     pub fn get<T>(&mut self, f: |&mut ReprVisitor, &T|) -> bool {\n         unsafe {\n-            f(self, transmute::<*c_void,&T>(self.ptr));\n+            f(self, transmute::<*u8,&T>(self.ptr));\n         }\n         true\n     }\n@@ -144,7 +143,7 @@ impl<'a> ReprVisitor<'a> {\n     }\n \n     #[inline]\n-    pub fn visit_ptr_inner(&mut self, ptr: *c_void, inner: *TyDesc) -> bool {\n+    pub fn visit_ptr_inner(&mut self, ptr: *u8, inner: *TyDesc) -> bool {\n         unsafe {\n             // This should call the constructor up above, but due to limiting\n             // issues we have to recreate it here.\n@@ -200,7 +199,7 @@ impl<'a> ReprVisitor<'a> {\n             } else {\n                 self.writer.write(\", \".as_bytes());\n             }\n-            self.visit_ptr_inner(p as *c_void, inner);\n+            self.visit_ptr_inner(p as *u8, inner);\n             p = align(unsafe { ptr::offset(p, sz as int) as uint }, al) as *u8;\n             left -= dec;\n         }\n@@ -298,20 +297,20 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n         self.writer.write(['@' as u8]);\n         self.write_mut_qualifier(mtbl);\n         self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n             this.visit_ptr_inner(p, inner);\n         })\n     }\n \n     fn visit_uniq(&mut self, _mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['~' as u8]);\n-        self.get::<*c_void>(|this, b| {\n+        self.get::<*u8>(|this, b| {\n             this.visit_ptr_inner(*b, inner);\n         })\n     }\n \n     fn visit_ptr(&mut self, mtbl: uint, _inner: *TyDesc) -> bool {\n-        self.get::<*c_void>(|this, p| {\n+        self.get::<*u8>(|this, p| {\n             write!(this.writer, \"({} as *\", *p);\n             this.write_mut_qualifier(mtbl);\n             this.writer.write(\"())\".as_bytes());\n@@ -321,7 +320,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_rptr(&mut self, mtbl: uint, inner: *TyDesc) -> bool {\n         self.writer.write(['&' as u8]);\n         self.write_mut_qualifier(mtbl);\n-        self.get::<*c_void>(|this, p| {\n+        self.get::<*u8>(|this, p| {\n             this.visit_ptr_inner(*p, inner);\n         })\n     }\n@@ -584,7 +583,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n     fn visit_opaque_box(&mut self) -> bool {\n         self.writer.write(['@' as u8]);\n         self.get::<&raw::Box<()>>(|this, b| {\n-            let p = ptr::to_unsafe_ptr(&b.data) as *c_void;\n+            let p = ptr::to_unsafe_ptr(&b.data) as *u8;\n             this.visit_ptr_inner(p, b.type_desc);\n         })\n     }\n@@ -594,7 +593,7 @@ impl<'a> TyVisitor for ReprVisitor<'a> {\n \n pub fn write_repr<T>(writer: &mut io::Writer, object: &T) {\n     unsafe {\n-        let ptr = ptr::to_unsafe_ptr(object) as *c_void;\n+        let ptr = ptr::to_unsafe_ptr(object) as *u8;\n         let tydesc = get_tydesc::<T>();\n         let u = ReprVisitor(ptr, writer);\n         let mut v = reflect::MovePtrAdaptor(u);"}, {"sha": "54442cedb683e3dcffff4f9830ba8018c2c3e703", "filename": "src/libstd/rt/global_heap.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fglobal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fglobal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fglobal_heap.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use libc::{c_void, c_char, size_t, uintptr_t, free, malloc, realloc};\n+use libc::{c_void, size_t, free, malloc, realloc};\n use ptr::{RawPtr, mut_null};\n use unstable::intrinsics::{TyDesc, abort};\n use unstable::raw;\n@@ -31,7 +31,7 @@ fn align_to(size: uint, align: uint) -> uint {\n \n /// A wrapper around libc::malloc, aborting on out-of-memory\n #[inline]\n-pub unsafe fn malloc_raw(size: uint) -> *mut c_void {\n+pub unsafe fn malloc_raw(size: uint) -> *mut u8 {\n     // `malloc(0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/malloc.html\n     if size == 0 {\n@@ -42,48 +42,48 @@ pub unsafe fn malloc_raw(size: uint) -> *mut c_void {\n             // we need a non-allocating way to print an error here\n             abort();\n         }\n-        p\n+        p as *mut u8\n     }\n }\n \n /// A wrapper around libc::realloc, aborting on out-of-memory\n #[inline]\n-pub unsafe fn realloc_raw(ptr: *mut c_void, size: uint) -> *mut c_void {\n+pub unsafe fn realloc_raw(ptr: *mut u8, size: uint) -> *mut u8 {\n     // `realloc(ptr, 0)` may allocate, but it may also return a null pointer\n     // http://pubs.opengroup.org/onlinepubs/9699919799/functions/realloc.html\n     if size == 0 {\n         free(ptr as *c_void);\n         mut_null()\n     } else {\n-        let p = realloc(ptr, size as size_t);\n+        let p = realloc(ptr as *mut c_void, size as size_t);\n         if p.is_null() {\n             // we need a non-allocating way to print an error here\n             abort();\n         }\n-        p\n+        p as *mut u8\n     }\n }\n \n /// The allocator for unique pointers without contained managed pointers.\n #[cfg(not(test))]\n #[lang=\"exchange_malloc\"]\n #[inline]\n-pub unsafe fn exchange_malloc(size: uintptr_t) -> *c_char {\n-    malloc_raw(size as uint) as *c_char\n+pub unsafe fn exchange_malloc(size: uint) -> *u8 {\n+    malloc_raw(size) as *u8\n }\n \n // FIXME: #7496\n #[cfg(not(test))]\n #[lang=\"closure_exchange_malloc\"]\n #[inline]\n-pub unsafe fn closure_exchange_malloc_(td: *c_char, size: uintptr_t) -> *c_char {\n+pub unsafe fn closure_exchange_malloc_(td: *u8, size: uint) -> *u8 {\n     closure_exchange_malloc(td, size)\n }\n \n #[inline]\n-pub unsafe fn closure_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub unsafe fn closure_exchange_malloc(td: *u8, size: uint) -> *u8 {\n     let td = td as *TyDesc;\n-    let size = size as uint;\n+    let size = size;\n \n     assert!(td.is_not_null());\n \n@@ -93,20 +93,20 @@ pub unsafe fn closure_exchange_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n     let alloc = p as *mut raw::Box<()>;\n     (*alloc).type_desc = td;\n \n-    alloc as *c_char\n+    alloc as *u8\n }\n \n // NB: Calls to free CANNOT be allowed to fail, as throwing an exception from\n // inside a landing pad may corrupt the state of the exception handler.\n #[cfg(not(test))]\n #[lang=\"exchange_free\"]\n #[inline]\n-pub unsafe fn exchange_free_(ptr: *c_char) {\n+pub unsafe fn exchange_free_(ptr: *u8) {\n     exchange_free(ptr)\n }\n \n #[inline]\n-pub unsafe fn exchange_free(ptr: *c_char) {\n+pub unsafe fn exchange_free(ptr: *u8) {\n     free(ptr as *c_void);\n }\n "}, {"sha": "36e3bf858e3efde618c28d6fe8134488437a4aaa", "filename": "src/libstd/rt/local_heap.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Flocal_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Flocal_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_heap.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -12,8 +12,6 @@\n \n use cast;\n use iter::Iterator;\n-use libc::{c_void, uintptr_t};\n-use libc;\n use mem;\n use ops::Drop;\n use option::{Option, None, Some};\n@@ -223,7 +221,7 @@ impl MemoryRegion {\n \n         let total_size = size + AllocHeader::size();\n         let alloc: *AllocHeader = unsafe {\n-            global_heap::realloc_raw(orig_alloc as *mut libc::c_void,\n+            global_heap::realloc_raw(orig_alloc as *mut u8,\n                                      total_size) as *AllocHeader\n         };\n \n@@ -243,7 +241,7 @@ impl MemoryRegion {\n             self.release(cast::transmute(alloc));\n             rtassert!(self.live_allocations > 0);\n             self.live_allocations -= 1;\n-            global_heap::exchange_free(alloc as *libc::c_char)\n+            global_heap::exchange_free(alloc as *u8)\n         }\n     }\n \n@@ -294,20 +292,20 @@ impl Drop for MemoryRegion {\n }\n \n #[inline]\n-pub unsafe fn local_malloc(td: *libc::c_char, size: libc::uintptr_t) -> *libc::c_char {\n+pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     // XXX: Unsafe borrow for speed. Lame.\n     let task: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task {\n         Some(task) => {\n-            (*task).heap.alloc(td as *TyDesc, size as uint) as *libc::c_char\n+            (*task).heap.alloc(td as *TyDesc, size) as *u8\n         }\n         None => rtabort!(\"local malloc outside of task\")\n     }\n }\n \n // A little compatibility function\n #[inline]\n-pub unsafe fn local_free(ptr: *libc::c_char) {\n+pub unsafe fn local_free(ptr: *u8) {\n     // XXX: Unsafe borrow for speed. Lame.\n     let task_ptr: Option<*mut Task> = Local::try_unsafe_borrow();\n     match task_ptr {"}, {"sha": "d4e57ab19b167eecebfee41455ba4a37b1137a52", "filename": "src/libstd/rt/local_ptr.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Flocal_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Flocal_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal_ptr.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -81,14 +81,13 @@ pub mod compiled {\n     use cast;\n     use option::{Option, Some, None};\n     use ptr::RawPtr;\n-    #[cfg(not(test))] use libc::c_void;\n \n     #[cfg(test)]\n     pub use realstd::rt::shouldnt_be_public::RT_TLS_PTR;\n \n     #[cfg(not(test))]\n     #[thread_local]\n-    pub static mut RT_TLS_PTR: *mut c_void = 0 as *mut c_void;\n+    pub static mut RT_TLS_PTR: *mut u8 = 0 as *mut u8;\n \n     pub fn init() {}\n \n@@ -230,7 +229,6 @@ pub mod compiled {\n /// thread-local value.\n pub mod native {\n     use cast;\n-    use libc::c_void;\n     use option::{Option, Some, None};\n     use ptr;\n     use ptr::RawPtr;\n@@ -259,7 +257,7 @@ pub mod native {\n     #[inline]\n     pub unsafe fn put<T>(sched: ~T) {\n         let key = tls_key();\n-        let void_ptr: *mut c_void = cast::transmute(sched);\n+        let void_ptr: *mut u8 = cast::transmute(sched);\n         tls::set(key, void_ptr);\n     }\n \n@@ -271,7 +269,7 @@ pub mod native {\n     #[inline]\n     pub unsafe fn take<T>() -> ~T {\n         let key = tls_key();\n-        let void_ptr: *mut c_void = tls::get(key);\n+        let void_ptr: *mut u8 = tls::get(key);\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }\n@@ -289,7 +287,7 @@ pub mod native {\n     pub unsafe fn try_take<T>() -> Option<~T> {\n         match maybe_tls_key() {\n             Some(key) => {\n-                let void_ptr: *mut c_void = tls::get(key);\n+                let void_ptr: *mut u8 = tls::get(key);\n                 if void_ptr.is_null() {\n                     None\n                 } else {\n@@ -311,7 +309,7 @@ pub mod native {\n     #[inline]\n     pub unsafe fn unsafe_take<T>() -> ~T {\n         let key = tls_key();\n-        let void_ptr: *mut c_void = tls::get(key);\n+        let void_ptr: *mut u8 = tls::get(key);\n         if void_ptr.is_null() {\n             rtabort!(\"thread-local pointer is null. bogus!\");\n         }"}, {"sha": "b5262424c065c23761a0bbff7e85f88dd7796e54", "filename": "src/libstd/rt/thread.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -196,7 +196,7 @@ mod imp {\n     use unstable::intrinsics;\n \n     pub type rust_thread = libc::pthread_t;\n-    pub type rust_thread_return = *libc::c_void;\n+    pub type rust_thread_return = *u8;\n \n     pub unsafe fn create(stack: uint, p: ~proc()) -> rust_thread {\n         let mut native: libc::pthread_t = intrinsics::uninit();"}, {"sha": "40d9523cf3aace38c038180c5f2892d58a3b2e3d", "filename": "src/libstd/rt/thread_local_storage.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Fthread_local_storage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fthread_local_storage.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -10,7 +10,6 @@\n \n #[allow(dead_code)];\n \n-use libc::c_void;\n #[cfg(unix)]\n use libc::c_int;\n #[cfg(unix)]\n@@ -27,12 +26,12 @@ pub unsafe fn create(key: &mut Key) {\n }\n \n #[cfg(unix)]\n-pub unsafe fn set(key: Key, value: *mut c_void) {\n+pub unsafe fn set(key: Key, value: *mut u8) {\n     assert_eq!(0, pthread_setspecific(key, value));\n }\n \n #[cfg(unix)]\n-pub unsafe fn get(key: Key) -> *mut c_void {\n+pub unsafe fn get(key: Key) -> *mut u8 {\n     pthread_getspecific(key)\n }\n \n@@ -55,8 +54,8 @@ type pthread_key_t = ::libc::c_uint;\n extern {\n     fn pthread_key_create(key: *mut pthread_key_t, dtor: *u8) -> c_int;\n     fn pthread_key_delete(key: pthread_key_t) -> c_int;\n-    fn pthread_getspecific(key: pthread_key_t) -> *mut c_void;\n-    fn pthread_setspecific(key: pthread_key_t, value: *mut c_void) -> c_int;\n+    fn pthread_getspecific(key: pthread_key_t) -> *mut u8;\n+    fn pthread_setspecific(key: pthread_key_t, value: *mut u8) -> c_int;\n }\n \n #[cfg(windows)]\n@@ -70,13 +69,13 @@ pub unsafe fn create(key: &mut Key) {\n }\n \n #[cfg(windows)]\n-pub unsafe fn set(key: Key, value: *mut c_void) {\n-    assert!(0 != TlsSetValue(key, value))\n+pub unsafe fn set(key: Key, value: *mut u8) {\n+    assert!(0 != TlsSetValue(key, value as *mut ::libc::c_void))\n }\n \n #[cfg(windows)]\n-pub unsafe fn get(key: Key) -> *mut c_void {\n-    TlsGetValue(key)\n+pub unsafe fn get(key: Key) -> *mut u8 {\n+    TlsGetValue(key) as *mut u8\n }\n \n #[cfg(windows)]"}, {"sha": "6f3aa4c4fd07ba70225bd2ede9e96f36b8629ee0", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -59,7 +59,6 @@ use any::{Any, AnyRefExt};\n use c_str::CString;\n use cast;\n use kinds::Send;\n-use libc::{c_void, c_char, size_t};\n use option::{Some, None, Option};\n use prelude::drop;\n use ptr::RawPtr;\n@@ -79,7 +78,7 @@ mod libunwind {\n     #[allow(non_camel_case_types)];\n     #[allow(dead_code)] // these are just bindings\n \n-    use libc::{uintptr_t, uint64_t};\n+    use libc::{uintptr_t};\n \n     #[cfg(not(target_arch = \"arm\"))]\n     #[repr(C)]\n@@ -118,7 +117,7 @@ mod libunwind {\n         _URC_FAILURE = 9, // used only by ARM EABI\n     }\n \n-    pub type _Unwind_Exception_Class = uint64_t;\n+    pub type _Unwind_Exception_Class = u64;\n \n     pub type _Unwind_Word = uintptr_t;\n \n@@ -164,6 +163,7 @@ impl Unwinder {\n \n     pub fn try(&mut self, f: ||) {\n         use unstable::raw::Closure;\n+        use libc::{c_void};\n \n         unsafe {\n             let closure: Closure = cast::transmute(f);\n@@ -365,10 +365,11 @@ pub mod eabi {\n /// The arguments are normally generated by the compiler, and need to\n /// have static lifetimes.\n #[inline(never)] #[cold] // this is the slow path, please never inline this\n-pub fn begin_unwind_raw(msg: *c_char, file: *c_char, line: size_t) -> ! {\n+pub fn begin_unwind_raw(msg: *u8, file: *u8, line: uint) -> ! {\n+    use libc::c_char;\n     #[inline]\n-    fn static_char_ptr(p: *c_char) -> &'static str {\n-        let s = unsafe { CString::new(p, false) };\n+    fn static_char_ptr(p: *u8) -> &'static str {\n+        let s = unsafe { CString::new(p as *c_char, false) };\n         match s.as_str() {\n             Some(s) => unsafe { cast::transmute::<&str, &'static str>(s) },\n             None => rtabort!(\"message wasn't utf8?\")"}, {"sha": "b482e2fb67fae080d5c831e828d6b21dfa4bb737", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -70,7 +70,6 @@ pub fn default_sched_threads() -> uint {\n \n pub fn dumb_println(args: &fmt::Arguments) {\n     use io;\n-    use libc;\n \n     struct Stderr;\n     impl io::Writer for Stderr {"}, {"sha": "f42163791a6abc36c7e1eb4586810ed21d58fb8b", "filename": "src/libstd/run.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -331,14 +331,14 @@ pub fn process_output(prog: &str, args: &[~str]) -> Option<ProcessOutput> {\n #[cfg(test)]\n mod tests {\n     use prelude::*;\n-    use libc::c_int;\n     use os;\n     use run;\n     use str;\n     use task::spawn;\n     use unstable::running_on_valgrind;\n     use io::pipe::PipeStream;\n     use io::{io_error, FileNotFound};\n+    use libc::c_int;\n \n     #[test]\n     #[cfg(not(target_os=\"android\"))] // FIXME(#10380)\n@@ -410,9 +410,9 @@ mod tests {\n             err_fd: Some(pipe_err.out)\n         }).expect(\"failed to exec `cat`\");\n \n-        os::close(pipe_in.input);\n-        os::close(pipe_out.out);\n-        os::close(pipe_err.out);\n+        os::close(pipe_in.input as int);\n+        os::close(pipe_out.out as int);\n+        os::close(pipe_err.out as int);\n \n         do spawn {\n             writeclose(pipe_in.out, \"test\");"}, {"sha": "30d9ede8a433e7e8f3c781f90c08e6fe63f97303", "filename": "src/libstd/sync/atomics.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fsync%2Fatomics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fsync%2Fatomics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fatomics.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -24,7 +24,6 @@\n use unstable::intrinsics;\n use cast;\n use option::{Option,Some,None};\n-use libc::c_void;\n use ops::Drop;\n use util::NonCopyable;\n \n@@ -73,7 +72,7 @@ pub struct AtomicPtr<T> {\n  */\n #[unsafe_no_drop_flag]\n pub struct AtomicOption<T> {\n-    priv p: *mut c_void\n+    priv p: *mut u8\n }\n \n pub enum Ordering {"}, {"sha": "8529b69c6eb8a33570b504c33d314b4543ad6ee9", "filename": "src/libstd/unstable/dynamic_lib.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fdynamic_lib.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -18,12 +18,11 @@ A simple wrapper over the platform's dynamic library facilities\n use c_str::ToCStr;\n use cast;\n use path;\n-use libc;\n use ops::*;\n use option::*;\n use result::*;\n \n-pub struct DynamicLibrary { priv handle: *libc::c_void }\n+pub struct DynamicLibrary { priv handle: *u8}\n \n impl Drop for DynamicLibrary {\n     fn drop(&mut self) {\n@@ -142,14 +141,14 @@ pub mod dl {\n     use str;\n     use result::*;\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n         filename.with_c_str(|raw_name| {\n-            dlopen(raw_name, Lazy as libc::c_int)\n+            dlopen(raw_name, Lazy as libc::c_int) as *u8\n         })\n     }\n \n-    pub unsafe fn open_internal() -> *libc::c_void {\n-        dlopen(ptr::null(), Lazy as libc::c_int)\n+    pub unsafe fn open_internal() -> *u8 {\n+        dlopen(ptr::null(), Lazy as libc::c_int) as *u8\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n@@ -174,11 +173,11 @@ pub mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n-        dlsym(handle, symbol)\n+    pub unsafe fn symbol(handle: *u8, symbol: *libc::c_char) -> *u8 {\n+        dlsym(handle as *libc::c_void, symbol) as *u8\n     }\n-    pub unsafe fn close(handle: *libc::c_void) {\n-        dlclose(handle); ()\n+    pub unsafe fn close(handle: *u8) {\n+        dlclose(handle as *libc::c_void); ()\n     }\n \n     pub enum RTLD {\n@@ -206,16 +205,16 @@ pub mod dl {\n     use ptr;\n     use result::{Ok, Err, Result};\n \n-    pub unsafe fn open_external(filename: &path::Path) -> *libc::c_void {\n+    pub unsafe fn open_external(filename: &path::Path) -> *u8 {\n         os::win32::as_utf16_p(filename.as_str().unwrap(), |raw_name| {\n-            LoadLibraryW(raw_name)\n+            LoadLibraryW(raw_name as *libc::c_void) as *u8\n         })\n     }\n \n-    pub unsafe fn open_internal() -> *libc::c_void {\n+    pub unsafe fn open_internal() -> *u8 {\n         let handle = ptr::null();\n         GetModuleHandleExW(0 as libc::DWORD, ptr::null(), &handle as **libc::c_void);\n-        handle\n+        handle as *u8\n     }\n \n     pub fn check_for_errors_in<T>(f: || -> T) -> Result<T, ~str> {\n@@ -233,17 +232,17 @@ pub mod dl {\n         }\n     }\n \n-    pub unsafe fn symbol(handle: *libc::c_void, symbol: *libc::c_char) -> *libc::c_void {\n-        GetProcAddress(handle, symbol)\n+    pub unsafe fn symbol(handle: *u8, symbol: *libc::c_char) -> *u8 {\n+        GetProcAddress(handle as *libc::c_void, symbol) as *u8\n     }\n-    pub unsafe fn close(handle: *libc::c_void) {\n-        FreeLibrary(handle); ()\n+    pub unsafe fn close(handle: *u8) {\n+        FreeLibrary(handle as *libc::c_void); ()\n     }\n \n     #[link_name = \"kernel32\"]\n     extern \"system\" {\n-        fn SetLastError(error: u32);\n-        fn LoadLibraryW(name: *u16) -> *libc::c_void;\n+        fn SetLastError(error: libc::size_t);\n+        fn LoadLibraryW(name: *libc::c_void) -> *libc::c_void;\n         fn GetModuleHandleExW(dwFlags: libc::DWORD, name: *u16,\n                               handle: **libc::c_void) -> *libc::c_void;\n         fn GetProcAddress(handle: *libc::c_void, name: *libc::c_char) -> *libc::c_void;"}, {"sha": "046d3fc820dd1504ff9952e08dc2277727cf679e", "filename": "src/libstd/unstable/lang.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Flang.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Flang.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Flang.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -11,25 +11,24 @@\n //! Runtime calls emitted by the compiler.\n \n use c_str::ToCStr;\n-use libc::{c_char, size_t, uintptr_t};\n \n #[cold]\n #[lang=\"fail_\"]\n-pub fn fail_(expr: *c_char, file: *c_char, line: size_t) -> ! {\n+pub fn fail_(expr: *u8, file: *u8, line: uint) -> ! {\n     ::rt::begin_unwind_raw(expr, file, line);\n }\n \n #[cold]\n #[lang=\"fail_bounds_check\"]\n-pub fn fail_bounds_check(file: *c_char, line: size_t, index: size_t, len: size_t) -> ! {\n+pub fn fail_bounds_check(file: *u8, line: uint, index: uint, len: uint) -> ! {\n     let msg = format!(\"index out of bounds: the len is {} but the index is {}\",\n                       len as uint, index as uint);\n-    msg.with_c_str(|buf| fail_(buf, file, line))\n+    msg.with_c_str(|buf| fail_(buf as *u8, file, line))\n }\n \n #[lang=\"malloc\"]\n #[inline]\n-pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n+pub unsafe fn local_malloc(td: *u8, size: uint) -> *u8 {\n     ::rt::local_heap::local_malloc(td, size)\n }\n \n@@ -38,6 +37,6 @@ pub unsafe fn local_malloc(td: *c_char, size: uintptr_t) -> *c_char {\n // problem occurs, call exit instead.\n #[lang=\"free\"]\n #[inline]\n-pub unsafe fn local_free(ptr: *c_char) {\n+pub unsafe fn local_free(ptr: *u8) {\n     ::rt::local_heap::local_free(ptr);\n }"}, {"sha": "ff38a8c019933e6cbfbfe97679db8fe41f6588fc", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 27, "deletions": 29, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -48,7 +48,6 @@\n #[allow(non_camel_case_types)];\n \n use int;\n-use libc::c_void;\n use sync::atomics;\n \n pub struct Mutex {\n@@ -133,38 +132,37 @@ impl Mutex {\n         if cond != 0 { imp::free_cond(cond) }\n     }\n \n-    unsafe fn getlock(&mut self) -> *c_void {\n+    unsafe fn getlock(&mut self) -> uint{\n         match self.lock.load(atomics::Relaxed) {\n             0 => {}\n-            n => return n as *c_void\n+            n => return n\n         }\n         let lock = imp::init_lock();\n         match self.lock.compare_and_swap(0, lock, atomics::SeqCst) {\n-            0 => return lock as *c_void,\n+            0 => return lock,\n             _ => {}\n         }\n         imp::free_lock(lock);\n-        return self.lock.load(atomics::Relaxed) as *c_void;\n+        self.lock.load(atomics::Relaxed)\n     }\n \n-    unsafe fn getcond(&mut self) -> *c_void {\n+    unsafe fn getcond(&mut self) -> uint {\n         match self.cond.load(atomics::Relaxed) {\n             0 => {}\n-            n => return n as *c_void\n+            n => return n\n         }\n         let cond = imp::init_cond();\n         match self.cond.compare_and_swap(0, cond, atomics::SeqCst) {\n-            0 => return cond as *c_void,\n+            0 => return cond,\n             _ => {}\n         }\n         imp::free_cond(cond);\n-        return self.cond.load(atomics::Relaxed) as *c_void;\n+        self.cond.load(atomics::Relaxed)\n     }\n }\n \n #[cfg(unix)]\n mod imp {\n-    use libc::c_void;\n     use libc;\n     use ptr;\n     use rt::global_heap::malloc_raw;\n@@ -175,49 +173,49 @@ mod imp {\n     type pthread_condattr_t = libc::c_void;\n \n     pub unsafe fn init_lock() -> uint {\n-        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *c_void;\n+        let block = malloc_raw(rust_pthread_mutex_t_size() as uint) as *pthread_mutex_t;\n         let n = pthread_mutex_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn init_cond() -> uint {\n-        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *c_void;\n+        let block = malloc_raw(rust_pthread_cond_t_size() as uint) as *pthread_cond_t;\n         let n = pthread_cond_init(block, ptr::null());\n         assert_eq!(n, 0);\n         return block as uint;\n     }\n \n     pub unsafe fn free_lock(h: uint) {\n-        let block = h as *c_void;\n+        let block = h as *libc::c_void;\n         assert_eq!(pthread_mutex_destroy(block), 0);\n         libc::free(block);\n     }\n \n     pub unsafe fn free_cond(h: uint) {\n-        let block = h as *c_void;\n+        let block = h as *pthread_cond_t;\n         assert_eq!(pthread_cond_destroy(block), 0);\n         libc::free(block);\n     }\n \n-    pub unsafe fn lock(l: *pthread_mutex_t) {\n-        assert_eq!(pthread_mutex_lock(l), 0);\n+    pub unsafe fn lock(l: uint) {\n+        assert_eq!(pthread_mutex_lock(l as *pthread_mutex_t), 0);\n     }\n \n-    pub unsafe fn trylock(l: *c_void) -> bool {\n-        pthread_mutex_trylock(l) == 0\n+    pub unsafe fn trylock(l: uint) -> bool {\n+        pthread_mutex_trylock(l as *pthread_mutex_t) == 0\n     }\n \n-    pub unsafe fn unlock(l: *pthread_mutex_t) {\n-        assert_eq!(pthread_mutex_unlock(l), 0);\n+    pub unsafe fn unlock(l: uint) {\n+        assert_eq!(pthread_mutex_unlock(l as *pthread_mutex_t), 0);\n     }\n \n-    pub unsafe fn wait(cond: *pthread_cond_t, m: *pthread_mutex_t) {\n-        assert_eq!(pthread_cond_wait(cond, m), 0);\n+    pub unsafe fn wait(cond: uint, m: uint) {\n+        assert_eq!(pthread_cond_wait(cond as *pthread_cond_t, m as *pthread_mutex_t), 0);\n     }\n \n-    pub unsafe fn signal(cond: *pthread_cond_t) {\n-        assert_eq!(pthread_cond_signal(cond), 0);\n+    pub unsafe fn signal(cond: uint) {\n+        assert_eq!(pthread_cond_signal(cond as *pthread_cond_t), 0);\n     }\n \n     extern {\n@@ -273,25 +271,25 @@ mod imp {\n         libc::CloseHandle(block);\n     }\n \n-    pub unsafe fn lock(l: *c_void) {\n+    pub unsafe fn lock(l: uint) {\n         EnterCriticalSection(l as LPCRITICAL_SECTION)\n     }\n \n-    pub unsafe fn trylock(l: *c_void) -> bool {\n+    pub unsafe fn trylock(l: uint) -> bool {\n         TryEnterCriticalSection(l as LPCRITICAL_SECTION) != 0\n     }\n \n-    pub unsafe fn unlock(l: *c_void) {\n+    pub unsafe fn unlock(l: uint) {\n         LeaveCriticalSection(l as LPCRITICAL_SECTION)\n     }\n \n-    pub unsafe fn wait(cond: *c_void, m: *c_void) {\n+    pub unsafe fn wait(cond: uint, m: uint) {\n         unlock(m);\n         WaitForSingleObject(cond as HANDLE, libc::INFINITE);\n         lock(m);\n     }\n \n-    pub unsafe fn signal(cond: *c_void) {\n+    pub unsafe fn signal(cond: uint) {\n         assert!(SetEvent(cond as HANDLE) != 0);\n     }\n "}, {"sha": "885c669ecb411d0433cf9521a981061e91f7036e", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2eb4f05850e25863f05a56b60931e9eb03944b56/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=2eb4f05850e25863f05a56b60931e9eb03944b56", "patch": "@@ -109,7 +109,6 @@ use cmp::{Eq, TotalOrd, Ordering, Less, Equal, Greater};\n use cmp;\n use default::Default;\n use iter::*;\n-use libc::{c_char, c_void};\n use num::{Integer, CheckedAdd, Saturating};\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n@@ -1478,8 +1477,8 @@ impl<T> OwnedVector<T> for ~[T] {\n                 if alloc / mem::nonzero_size_of::<T>() != n || size < alloc {\n                     fail!(\"vector size is too large: {}\", n);\n                 }\n-                *ptr = realloc_raw(*ptr as *mut c_void, size)\n-                       as *mut Vec<()>;\n+                *ptr = realloc_raw(*ptr as *mut u8, size)\n+                                   as *mut Vec<()>;\n                 (**ptr).alloc = alloc;\n             }\n         }\n@@ -1513,7 +1512,7 @@ impl<T> OwnedVector<T> for ~[T] {\n             let ptr: *mut *mut Vec<()> = cast::transmute(self);\n             let alloc = (**ptr).fill;\n             let size = alloc + mem::size_of::<Vec<()>>();\n-            *ptr = realloc_raw(*ptr as *mut c_void, size) as *mut Vec<()>;\n+            *ptr = realloc_raw(*ptr as *mut u8, size) as *mut Vec<()>;\n             (**ptr).alloc = alloc;\n         }\n     }\n@@ -2877,7 +2876,7 @@ impl<T> Drop for MoveItems<T> {\n         // destroy the remaining elements\n         for _x in *self {}\n         unsafe {\n-            exchange_free(self.allocation as *u8 as *c_char)\n+            exchange_free(self.allocation as *u8)\n         }\n     }\n }"}]}