{"sha": "49999e9b1d816e1ca7365887fd42422702bc46cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5OTk5ZTliMWQ4MTZlMWNhNzM2NTg4N2ZkNDI0MjI3MDJiYzQ2Y2I=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-18T11:46:52Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2018-08-22T11:08:39Z"}, "message": "optimize sanity check path printing\n\nDuring the sanity check, we keep track of the path we are below in a `Vec`.  We\navoid cloning that `Vec` unless we hit a pointer indirection.  The `String`\nrepresentation is only computed when validation actually fails.", "tree": {"sha": "1b8ce51e24dbffce002926541ca0b8822cf43fac", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b8ce51e24dbffce002926541ca0b8822cf43fac"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49999e9b1d816e1ca7365887fd42422702bc46cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49999e9b1d816e1ca7365887fd42422702bc46cb", "html_url": "https://github.com/rust-lang/rust/commit/49999e9b1d816e1ca7365887fd42422702bc46cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49999e9b1d816e1ca7365887fd42422702bc46cb/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "42a1239a18138db3b765d9b249b1ef83e19cccfa", "url": "https://api.github.com/repos/rust-lang/rust/commits/42a1239a18138db3b765d9b249b1ef83e19cccfa", "html_url": "https://github.com/rust-lang/rust/commit/42a1239a18138db3b765d9b249b1ef83e19cccfa"}], "stats": {"total": 305, "additions": 179, "deletions": 126}, "files": [{"sha": "681e9195805674541c9b70d7af86e532fd99c6ae", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -1622,13 +1622,13 @@ fn validate_const<'a, 'tcx>(\n         let layout = ecx.layout_of(constant.ty)?;\n         let place = ecx.allocate_op(OpTy { op, layout })?.into();\n \n-        let mut todo = vec![(place, String::new())];\n+        let mut todo = vec![(place, Vec::new())];\n         let mut seen = FxHashSet();\n         seen.insert(place);\n-        while let Some((place, path)) = todo.pop() {\n+        while let Some((place, mut path)) = todo.pop() {\n             ecx.validate_mplace(\n                 place,\n-                path,\n+                &mut path,\n                 &mut seen,\n                 &mut todo,\n             )?;"}, {"sha": "7e32f3a971f8e91e5ddae256881168a6c775b33b", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 97, "deletions": 82, "changes": 179, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -1,5 +1,6 @@\n use std::fmt::Write;\n \n+use syntax_pos::symbol::Symbol;\n use rustc::ty::layout::{self, Size, Primitive};\n use rustc::ty::{self, Ty};\n use rustc_data_structures::fx::FxHashSet;\n@@ -13,21 +14,23 @@ use super::{\n \n macro_rules! validation_failure{\n     ($what:expr, $where:expr, $details:expr) => {{\n-        let where_ = if $where.is_empty() {\n+        let where_ = path_format($where);\n+        let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n-            format!(\" at {}\", $where)\n+            format!(\" at {}\", where_)\n         };\n         err!(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n         )))\n     }};\n     ($what:expr, $where:expr) => {{\n-        let where_ = if $where.is_empty() {\n+        let where_ = path_format($where);\n+        let where_ = if where_.is_empty() {\n             String::new()\n         } else {\n-            format!(\" at {}\", $where)\n+            format!(\" at {}\", where_)\n         };\n         err!(ValidationFailure(format!(\n             \"encountered {}{}\",\n@@ -36,13 +39,59 @@ macro_rules! validation_failure{\n     }};\n }\n \n+/// We want to show a nice path to the invalid field for diagnotsics,\n+/// but avoid string operations in the happy case where no error happens.\n+/// So we track a `Vec<PathElem>` where `PathElem` contains all the data we\n+/// need to later print something for the user.\n+#[derive(Copy, Clone, Debug)]\n+pub enum PathElem {\n+    Field(Symbol),\n+    ClosureVar(Symbol),\n+    ArrayElem(usize),\n+    TupleElem(usize),\n+    Deref,\n+    Tag,\n+}\n+\n+// Adding a Deref and making a copy of the path to be put into the queue\n+// always go together.  This one does it with only new allocation.\n+fn path_clone_and_deref(path: &Vec<PathElem>) -> Vec<PathElem> {\n+    let mut new_path = Vec::with_capacity(path.len()+1);\n+    new_path.clone_from(path);\n+    new_path.push(PathElem::Deref);\n+    new_path\n+}\n+\n+/// Format a path\n+fn path_format(path: &Vec<PathElem>) -> String {\n+    use self::PathElem::*;\n+\n+    let mut out = String::new();\n+    for elem in path.iter() {\n+        match elem {\n+            Field(name) => write!(out, \".{}\", name).unwrap(),\n+            ClosureVar(name) => write!(out, \".<closure-var({})>\", name).unwrap(),\n+            TupleElem(idx) => write!(out, \".{}\", idx).unwrap(),\n+            ArrayElem(idx) => write!(out, \"[{}]\", idx).unwrap(),\n+            Deref =>\n+                // This does not match Rust syntax, but it is more readable for long paths -- and\n+                // some of the other items here also are not Rust syntax.  Actually we can't\n+                // even use the usual syntax because we are just showing the projections,\n+                // not the root.\n+                write!(out, \".<deref>\").unwrap(),\n+            Tag => write!(out, \".<enum-tag>\").unwrap(),\n+        }\n+    }\n+    out\n+}\n+\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     fn validate_scalar(\n         &self,\n         value: ScalarMaybeUndef,\n         size: Size,\n         scalar: &layout::Scalar,\n-        path: &str,\n+        path: &Vec<PathElem>,\n         ty: Ty,\n     ) -> EvalResult<'tcx> {\n         trace!(\"validate scalar: {:#?}, {:#?}, {:#?}, {}\", value, size, scalar, ty);\n@@ -93,7 +142,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n             ty::TyChar => {\n                 debug_assert_eq!(size.bytes(), 4);\n                 if ::std::char::from_u32(bits as u32).is_none() {\n-                    return err!(InvalidChar(bits));\n+                    return validation_failure!(\n+                        \"character\",\n+                        path,\n+                        \"a valid unicode codepoint\"\n+                    );\n                 }\n             }\n             _ => {},\n@@ -127,46 +180,57 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n     /// This function checks the memory where `dest` points to.  The place must be sized\n     /// (i.e., dest.extra == PlaceExtra::None).\n     /// It will error if the bits at the destination do not match the ones described by the layout.\n+    /// The `path` may be pushed to, but the part that is present when the function\n+    /// starts must not be changed!\n     pub fn validate_mplace(\n         &self,\n         dest: MPlaceTy<'tcx>,\n-        path: String,\n+        path: &mut Vec<PathElem>,\n         seen: &mut FxHashSet<(MPlaceTy<'tcx>)>,\n-        todo: &mut Vec<(MPlaceTy<'tcx>, String)>,\n+        todo: &mut Vec<(MPlaceTy<'tcx>, Vec<PathElem>)>,\n     ) -> EvalResult<'tcx> {\n         self.memory.dump_alloc(dest.to_ptr()?.alloc_id);\n         trace!(\"validate_mplace: {:?}, {:#?}\", *dest, dest.layout);\n \n-        // Find the right variant\n+        // Find the right variant.  We have to handle this as a prelude, not via\n+        // proper recursion with the new inner layout, to be able to later nicely\n+        // print the field names of the enum field that is being accessed.\n         let (variant, dest) = match dest.layout.variants {\n             layout::Variants::NicheFilling { niche: ref tag, .. } |\n             layout::Variants::Tagged { ref tag, .. } => {\n                 let size = tag.value.size(self);\n                 // we first read the tag value as scalar, to be able to validate it\n                 let tag_mplace = self.mplace_field(dest, 0)?;\n                 let tag_value = self.read_scalar(tag_mplace.into())?;\n-                let path = format!(\"{}.TAG\", path);\n+                path.push(PathElem::Tag);\n                 self.validate_scalar(\n                     tag_value, size, tag, &path, tag_mplace.layout.ty\n                 )?;\n+                path.pop(); // remove the element again\n                 // then we read it again to get the index, to continue\n                 let variant = self.read_discriminant_as_variant_index(dest.into())?;\n-                let dest = self.mplace_downcast(dest, variant)?;\n+                let inner_dest = self.mplace_downcast(dest, variant)?;\n+                // Put the variant projection onto the path, as a field\n+                path.push(PathElem::Field(dest.layout.ty.ty_adt_def().unwrap().variants[variant].name));\n                 trace!(\"variant layout: {:#?}\", dest.layout);\n-                (variant, dest)\n+                (variant, inner_dest)\n             },\n             layout::Variants::Single { index } => {\n                 (index, dest)\n             }\n         };\n \n+        // Remember the length, in case we need to truncate\n+        let path_len = path.len();\n+\n         // Validate all fields\n         match dest.layout.fields {\n             // primitives are unions with zero fields\n             layout::FieldPlacement::Union(0) => {\n                 match dest.layout.abi {\n                     // nothing to do, whatever the pointer points to, it is never going to be read\n-                    layout::Abi::Uninhabited => validation_failure!(\"a value of an uninhabited type\", path),\n+                    layout::Abi::Uninhabited =>\n+                        return validation_failure!(\"a value of an uninhabited type\", path),\n                     // check that the scalar is a valid pointer or that its bit range matches the\n                     // expectation.\n                     layout::Abi::Scalar(ref scalar_layout) => {\n@@ -179,8 +243,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                             if let Scalar::Ptr(ptr) = scalar.not_undef()? {\n                                 let alloc_kind = self.tcx.alloc_map.lock().get(ptr.alloc_id);\n                                 if let Some(AllocType::Static(did)) = alloc_kind {\n-                                    // statics from other crates are already checked\n-                                    // extern statics should not be validated as they have no body\n+                                    // statics from other crates are already checked.\n+                                    // extern statics should not be validated as they have no body.\n                                     if !did.is_local() || self.tcx.is_foreign_item(did) {\n                                         return Ok(());\n                                     }\n@@ -190,12 +254,11 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                                     let ptr_place = self.ref_to_mplace(value)?;\n                                     // we have not encountered this pointer+layout combination before\n                                     if seen.insert(ptr_place) {\n-                                        todo.push((ptr_place, format!(\"(*{})\", path)))\n+                                        todo.push((ptr_place, path_clone_and_deref(path)));\n                                     }\n                                 }\n                             }\n                         }\n-                        Ok(())\n                     },\n                     _ => bug!(\"bad abi for FieldPlacement::Union(0): {:#?}\", dest.layout.abi),\n                 }\n@@ -204,16 +267,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                 // We can't check unions, their bits are allowed to be anything.\n                 // The fields don't need to correspond to any bit pattern of the union's fields.\n                 // See https://github.com/rust-lang/rust/issues/32836#issuecomment-406875389\n-                Ok(())\n             },\n             layout::FieldPlacement::Array { .. } => {\n                 for (i, field) in self.mplace_array_fields(dest)?.enumerate() {\n                     let field = field?;\n-                    let mut path = path.clone();\n-                    self.dump_field_name(&mut path, dest.layout.ty, i as usize, variant).unwrap();\n+                    path.push(PathElem::ArrayElem(i));\n                     self.validate_mplace(field, path, seen, todo)?;\n+                    path.truncate(path_len);\n                 }\n-                Ok(())\n             },\n             layout::FieldPlacement::Arbitrary { ref offsets, .. } => {\n                 // fat pointers need special treatment\n@@ -232,9 +293,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         assert_eq!(ptr.extra, PlaceExtra::Length(len));\n                         let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n                         if seen.insert(unpacked_ptr) {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n-                            todo.push((unpacked_ptr, path))\n+                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n                         }\n                     },\n                     Some(ty::TyDynamic(..)) => {\n@@ -249,9 +308,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                         assert_eq!(ptr.extra, PlaceExtra::Vtable(vtable));\n                         let unpacked_ptr = self.unpack_unsized_mplace(ptr)?;\n                         if seen.insert(unpacked_ptr) {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, 0, 0).unwrap();\n-                            todo.push((unpacked_ptr, path))\n+                            todo.push((unpacked_ptr, path_clone_and_deref(path)));\n                         }\n                         // FIXME: More checks for the vtable... making sure it is exactly\n                         // the one one would expect for this type.\n@@ -261,84 +318,42 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M> {\n                     None => {\n                         // Not a pointer, perform regular aggregate handling below\n                         for i in 0..offsets.len() {\n-                            let mut path = path.clone();\n-                            self.dump_field_name(&mut path, dest.layout.ty, i, variant).unwrap();\n                             let field = self.mplace_field(dest, i as u64)?;\n+                            path.push(self.aggregate_field_path_elem(dest.layout.ty, variant, i));\n                             self.validate_mplace(field, path, seen, todo)?;\n+                            path.truncate(path_len);\n                         }\n                         // FIXME: For a TyStr, check that this is valid UTF-8.\n                     },\n                 }\n-\n-                Ok(())\n             }\n         }\n+        Ok(())\n     }\n \n-    fn dump_field_name(&self, s: &mut String, ty: Ty<'tcx>, i: usize, variant: usize) -> ::std::fmt::Result {\n+    fn aggregate_field_path_elem(&self, ty: Ty<'tcx>, variant: usize, field: usize) -> PathElem {\n         match ty.sty {\n-            ty::TyBool |\n-            ty::TyChar |\n-            ty::TyInt(_) |\n-            ty::TyUint(_) |\n-            ty::TyFloat(_) |\n-            ty::TyFnPtr(_) |\n-            ty::TyNever |\n-            ty::TyFnDef(..) |\n-            ty::TyGeneratorWitness(..) |\n-            ty::TyForeign(..) |\n-            ty::TyDynamic(..) => {\n-                bug!(\"field_name({:?}): not applicable\", ty)\n-            }\n-\n-            // Potentially-fat pointers.\n-            ty::TyRef(_, pointee, _) |\n-            ty::TyRawPtr(ty::TypeAndMut { ty: pointee, .. }) => {\n-                assert!(i < 2);\n-\n-                // Reuse the fat *T type as its own thin pointer data field.\n-                // This provides information about e.g. DST struct pointees\n-                // (which may have no non-DST form), and will work as long\n-                // as the `Abi` or `FieldPlacement` is checked by users.\n-                if i == 0 {\n-                    return write!(s, \".data_ptr\");\n-                }\n-\n-                match self.tcx.struct_tail(pointee).sty {\n-                    ty::TySlice(_) |\n-                    ty::TyStr => write!(s, \".len\"),\n-                    ty::TyDynamic(..) => write!(s, \".vtable_ptr\"),\n-                    _ => bug!(\"field_name({:?}): not applicable\", ty)\n-                }\n-            }\n-\n-            // Arrays and slices.\n-            ty::TyArray(_, _) |\n-            ty::TySlice(_) |\n-            ty::TyStr => write!(s, \"[{}]\", i),\n-\n             // generators and closures.\n             ty::TyClosure(def_id, _) | ty::TyGenerator(def_id, _, _) => {\n                 let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n-                let freevar = self.tcx.with_freevars(node_id, |fv| fv[i]);\n-                write!(s, \".upvar({})\", self.tcx.hir.name(freevar.var_id()))\n+                let freevar = self.tcx.with_freevars(node_id, |fv| fv[field]);\n+                PathElem::ClosureVar(self.tcx.hir.name(freevar.var_id()))\n             }\n \n-            ty::TyTuple(_) => write!(s, \".{}\", i),\n+            // tuples\n+            ty::TyTuple(_) => PathElem::TupleElem(field),\n \n             // enums\n             ty::TyAdt(def, ..) if def.is_enum() => {\n                 let variant = &def.variants[variant];\n-                write!(s, \".{}::{}\", variant.name, variant.fields[i].ident)\n+                PathElem::Field(variant.fields[field].ident.name)\n             }\n \n-            // other ADTs.\n-            ty::TyAdt(def, _) => write!(s, \".{}\", def.non_enum_variant().fields[i].ident),\n+            // other ADTs\n+            ty::TyAdt(def, _) => PathElem::Field(def.non_enum_variant().fields[field].ident.name),\n \n-            ty::TyProjection(_) | ty::TyAnon(..) | ty::TyParam(_) |\n-            ty::TyInfer(_) | ty::TyError => {\n-                bug!(\"dump_field_name: unexpected type `{}`\", ty)\n-            }\n+            // nothing else has an aggregate layout\n+            _ => bug!(\"aggregate_field_path_elem: got non-aggregate type {:?}\", ty),\n         }\n     }\n }"}, {"sha": "739af12d09c6937b81cfdfaef036c256da19cf1f", "filename": "src/test/ui/consts/const-eval/double_check2.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fdouble_check2.stderr?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -5,7 +5,7 @@ LL | / static FOO: (&Foo, &Bar) = unsafe {( //~ undefined behavior\n LL | |     Union { usize: &BAR }.foo,\n LL | |     Union { usize: &BAR }.bar,\n LL | | )};\n-   | |___^ type validation failed: encountered 5 at (*.1).TAG, but expected something in the range 42..=99\n+   | |___^ type validation failed: encountered 5 at .1.<deref>.<enum-tag>, but expected something in the range 42..=99\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}, {"sha": "8538dd14afed19292d3678d20279354fa02246ce", "filename": "src/test/ui/consts/const-eval/ub-enum-ptr.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.rs?ref=42a1239a18138db3b765d9b249b1ef83e19cccfa", "patch": "@@ -1,27 +0,0 @@\n-// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#[repr(usize)]\n-#[derive(Copy, Clone)]\n-enum Enum {\n-    A = 0,\n-}\n-\n-union Foo {\n-    a: &'static u8,\n-    b: Enum,\n-}\n-\n-// A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n-//~^ ERROR this constant likely exhibits undefined behavior\n-\n-fn main() {\n-}"}, {"sha": "4b7ccc25c6c014615bba5bd7b3c68a707a0b58a2", "filename": "src/test/ui/consts/const-eval/ub-enum-ptr.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/42a1239a18138db3b765d9b249b1ef83e19cccfa/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum-ptr.stderr?ref=42a1239a18138db3b765d9b249b1ef83e19cccfa", "patch": "@@ -1,11 +0,0 @@\n-error[E0080]: this constant likely exhibits undefined behavior\n-  --> $DIR/ub-enum-ptr.rs:23:1\n-   |\n-LL | const BAD_ENUM: Enum = unsafe { Foo { a: &1 }.b};\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .TAG, but expected something in the range 0..=0\n-   |\n-   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0080`."}, {"sha": "bcb71af54afdb4f03225b147f169f8303795c685", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -0,0 +1,49 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum {\n+    A = 0,\n+}\n+union TransmuteEnum {\n+    a: &'static u8,\n+    b: Enum,\n+}\n+\n+// A pointer is guaranteed non-null\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// Invalid enum discriminant\n+#[repr(usize)]\n+#[derive(Copy, Clone)]\n+enum Enum2 {\n+    A = 2,\n+}\n+union TransmuteEnum2 {\n+    a: usize,\n+    b: Enum2,\n+}\n+const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+// Invalid enum field content (mostly to test printing of apths for enum tuple\n+// variants and tuples).\n+union TransmuteChar {\n+    a: u32,\n+    b: char,\n+}\n+// Need to create something which does not clash with enum layout optimizations.\n+const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+//~^ ERROR this constant likely exhibits undefined behavior\n+\n+fn main() {\n+}"}, {"sha": "98e9b598b543f9acf3d3c117d84b33ea005d4b83", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -0,0 +1,27 @@\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:22:1\n+   |\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { a: &1 }.b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered pointer at .<enum-tag>, but expected something in the range 0..=0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:35:1\n+   |\n+LL | const BAD_ENUM2 : Enum2 = unsafe { TransmuteEnum2 { a: 0 }.b };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0 at .<enum-tag>, but expected something in the range 2..=2\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: this constant likely exhibits undefined behavior\n+  --> $DIR/ub-enum.rs:45:1\n+   |\n+LL | const BAD_ENUM_CHAR : Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered character at .Some.0.1, but expected a valid unicode codepoint\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "af85d1d39c45695c179baec369335080aeb7736e", "filename": "src/test/ui/union-ub-fat-ptr.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/49999e9b1d816e1ca7365887fd42422702bc46cb/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion-ub-fat-ptr.stderr?ref=49999e9b1d816e1ca7365887fd42422702bc46cb", "patch": "@@ -58,15 +58,15 @@ error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:102:1\n    |\n LL | const G: &Trait = &unsafe { BoolTransmute { val: 3 }.bl };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .data_ptr, but expected something in the range 0..=1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>, but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: this constant likely exhibits undefined behavior\n   --> $DIR/union-ub-fat-ptr.rs:106:1\n    |\n LL | const H: &[bool] = &[unsafe { BoolTransmute { val: 3 }.bl }];\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .data_ptr[0], but expected something in the range 0..=1\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 3 at .<deref>[0], but expected something in the range 0..=1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n "}]}