{"sha": "c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5NmYwYmY3Mzg2MDgxZDIxYjAwYWY0ZmE3ZmNmNzNhYzhkNzk1NzU=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-07-13T02:39:29Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2010-07-16T01:27:09Z"}, "message": "Implement the \"simple typechecker\", which avoids HM inference", "tree": {"sha": "c006fa1a8d9d817b3ccf60a3874034dce5975e3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c006fa1a8d9d817b3ccf60a3874034dce5975e3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "html_url": "https://github.com/rust-lang/rust/commit/c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91b4cae8daccf450d3d061b4a0251f80d4d15a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/91b4cae8daccf450d3d061b4a0251f80d4d15a91", "html_url": "https://github.com/rust-lang/rust/commit/91b4cae8daccf450d3d061b4a0251f80d4d15a91"}], "stats": {"total": 2407, "additions": 854, "deletions": 1553}, "files": [{"sha": "357672a071a881cc292cc596aa0a4e83a7495cb6", "filename": "src/Makefile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FMakefile?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -361,7 +361,8 @@ TEST_XFAILS_X86 :=  $(MUT_BOX_XFAILS) \\\n                     test/compile-fail/bad-send.rs \\\n                     test/compile-fail/bad-recv.rs \\\n                     test/compile-fail/infinite-tag-type-recursion.rs \\\n-                    test/compile-fail/infinite-vec-type-recursion.rs\n+                    test/compile-fail/infinite-vec-type-recursion.rs \\\n+                    test/compile-fail/writing-through-read-alias.rs\n \n TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       acyclic-unwind.rs \\\n@@ -492,6 +493,7 @@ TEST_XFAILS_LLVM := $(addprefix test/run-pass/, \\\n                       bad-recv.rs \\\n                       infinite-tag-type-recursion.rs \\\n                       infinite-vec-type-recursion.rs \\\n+                      writing-through-read-alias.rs \\\n                      )\n \n ifdef MINGW_CROSS"}, {"sha": "9efaa8f6ab3a782610d77da0175c915eb5e910c7", "filename": "src/boot/me/type.ml", "status": "modified", "additions": 836, "deletions": 1547, "changes": 2383, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Fboot%2Fme%2Ftype.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Fboot%2Fme%2Ftype.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Fme%2Ftype.ml?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -1,1639 +1,928 @@\n-open Common;;\n-open Semant;;\n-\n-type tyspec =\n-    TYSPEC_equiv of tyvar\n-  | TYSPEC_all\n-  | TYSPEC_resolved of (Ast.ty_param array) * Ast.ty\n-  | TYSPEC_box of tyvar                       (* @ of some t *)\n-  | TYSPEC_mutable of tyvar                   (* something mutable *)\n-  | TYSPEC_callable of (tyvar * tyvar array)  (* out, ins *)\n-  | TYSPEC_collection of tyvar                (* vec or str *)\n-  | TYSPEC_comparable                         (* comparable with = and != *)\n-  | TYSPEC_plusable                           (* nums, vecs, and strings *)\n-  | TYSPEC_dictionary of dict\n-  | TYSPEC_integral                           (* int-like *)\n-  | TYSPEC_numeric                            (* int-like or float-like *)\n-  | TYSPEC_ordered                            (* comparable with < etc. *)\n-  | TYSPEC_record of dict\n-  | TYSPEC_tuple of tyvar array               (* heterogeneous tuple *)\n-  | TYSPEC_vector of tyvar\n-  | TYSPEC_app of (tyvar * Ast.ty array)\n-\n-and dict = (Ast.ident, tyvar) Hashtbl.t\n-\n-and tyvar = tyspec ref;;\n-\n-(* Signatures for binary operators. *)\n-type binopsig =\n-    BINOPSIG_bool_bool_bool     (* bool * bool -> bool *)\n-  | BINOPSIG_comp_comp_bool     (* comparable a * comparable a -> bool *)\n-  | BINOPSIG_ord_ord_bool       (* ordered a * ordered a -> bool *)\n-  | BINOPSIG_integ_integ_integ  (* integral a * integral a -> integral a *)\n-  | BINOPSIG_num_num_num        (* numeric a * numeric a -> numeric a *)\n-  | BINOPSIG_plus_plus_plus     (* plusable a * plusable a -> plusable a *)\n-;;\n-\n-\n-let rec tyspec_to_str (ts:tyspec) : string =\n-\n-  let fmt = Format.fprintf in\n-  let fmt_ident (ff:Format.formatter) (i:Ast.ident) : unit =\n-    fmt ff  \"%s\" i\n+(* rust/src/boot/me/type.ml *)\n+\n+(* An ltype is the type of a segment of an lvalue. It is used only by\n+ * [check_lval] and friends and are the closest Rust ever comes to polymorphic\n+ * types. All ltypes must be resolved into monotypes by the time an outer\n+ * lvalue (i.e. an lvalue whose parent is not also an lvalue) is finished\n+ * typechecking. *)\n+\n+type ltype =\n+    LTYPE_mono of Ast.ty\n+  | LTYPE_poly of Ast.ty_param array * Ast.ty   (* \"big lambda\" *)\n+  | LTYPE_module of Ast.mod_items               (* type of a module *)\n+\n+type fn_ctx = {\n+  fnctx_return_type: Ast.ty;\n+  fnctx_is_iter: bool\n+}\n+\n+exception Type_error of string * Ast.ty\n+\n+let log cx =\n+  Session.log\n+    \"type\"\n+    cx.Semant.ctxt_sess.Session.sess_log_type\n+    cx.Semant.ctxt_sess.Session.sess_log_out\n+\n+let type_error expected actual = raise (Type_error (expected, actual))\n+\n+(* We explicitly curry [cx] like this to avoid threading it through all the\n+ * inner functions. *)\n+let check_stmt (cx:Semant.ctxt) : (fn_ctx -> Ast.stmt -> unit) =\n+  (* Returns the part of the type that matters for typechecking. *)\n+  let rec fundamental_ty (ty:Ast.ty) : Ast.ty =\n+    match ty with\n+        Ast.TY_constrained (ty', _) | Ast.TY_mutable ty' -> fundamental_ty ty'\n+      | _ -> ty\n   in\n-  let fmt_obox ff = Format.pp_open_box ff 4 in\n-  let fmt_cbox ff = Format.pp_close_box ff () in\n-  let fmt_obr ff = fmt ff \"<\" in\n-  let fmt_cbr ff = fmt ff \">\" in\n-  let fmt_obb ff = (fmt_obox ff; fmt_obr ff) in\n-  let fmt_cbb ff = (fmt_cbox ff; fmt_cbr ff) in\n-\n-  let rec fmt_fields (flav:string) (ff:Format.formatter) (flds:dict) : unit =\n-    fmt_obb ff;\n-    fmt ff \"%s :\" flav;\n-    let fmt_entry ident tv =\n-      fmt ff \"@\\n\";\n-      fmt_ident ff ident;\n-      fmt ff \" : \";\n-      fmt_tyspec ff (!tv);\n-    in\n-      Hashtbl.iter fmt_entry flds;\n-      fmt_cbb ff\n-\n-  and fmt_app ff tv args =\n-    begin\n-      assert (Array.length args <> 0);\n-      fmt_obb ff;\n-      fmt ff \"app(\";\n-      fmt_tyspec ff (!tv);\n-      fmt ff \")\";\n-      Ast.fmt_app_args ff args;\n-      fmt_cbb ff;\n-    end\n-\n-  and fmt_tvs ff tvs =\n-    fmt_obox ff;\n-    let fmt_tv i tv =\n-      if i <> 0\n-      then fmt ff \", \";\n-      fmt_tyspec ff (!tv)\n-    in\n-      Array.iteri fmt_tv tvs;\n-      fmt_cbox ff;\n-\n-  and fmt_tyspec ff ts =\n-    match ts with\n-        TYSPEC_all -> fmt ff \"<?>\"\n-      | TYSPEC_comparable -> fmt ff \"<comparable>\"\n-      | TYSPEC_plusable -> fmt ff \"<plusable>\"\n-      | TYSPEC_integral -> fmt ff \"<integral>\"\n-      | TYSPEC_numeric -> fmt ff \"<numeric>\"\n-      | TYSPEC_ordered -> fmt ff \"<ordered>\"\n-      | TYSPEC_resolved (params, ty) ->\n-          if Array.length params <> 0\n-          then\n-            begin\n-              fmt ff \"abs\";\n-              Ast.fmt_decl_params ff params;\n-              fmt ff \"(\";\n-              Ast.fmt_ty ff ty;\n-              fmt ff \")\"\n-            end\n-          else\n-            Ast.fmt_ty ff ty\n-\n-      | TYSPEC_equiv tv ->\n-          fmt_tyspec ff (!tv)\n-\n-      | TYSPEC_box tv ->\n-          fmt_obr ff;\n-          fmt ff \"box \";\n-          fmt_tyspec ff (!tv);\n-          fmt_cbr ff;\n-\n-      | TYSPEC_mutable tv ->\n-          fmt_obr ff;\n-          fmt ff \"mut \";\n-          fmt_tyspec ff (!tv);\n-          fmt_cbr ff\n-\n-      | TYSPEC_callable (out, ins) ->\n-          fmt_obb ff;\n-          fmt ff \"callable fn(\";\n-          fmt_tvs ff ins;\n-          fmt ff \") -> \";\n-          fmt_tyspec ff (!out);\n-          fmt_cbb ff;\n-\n-      | TYSPEC_collection tv ->\n-          fmt_obb ff;\n-          fmt ff \"collection : \";\n-          fmt_tyspec ff (!tv);\n-          fmt_cbb ff;\n-\n-      | TYSPEC_tuple tvs ->\n-          fmt_obr ff;\n-          fmt ff \"tuple (\";\n-          fmt_tvs ff tvs;\n-          fmt ff \")\";\n-          fmt_cbr ff;\n-\n-      | TYSPEC_vector tv ->\n-          fmt_obb ff;\n-          fmt ff \"vector \";\n-          fmt_tyspec ff (!tv);\n-          fmt_cbb ff;\n-\n-      | TYSPEC_dictionary dct ->\n-          fmt_fields \"dictionary\" ff dct\n-\n-      | TYSPEC_record dct ->\n-          fmt_fields \"record\" ff dct\n-\n-      | TYSPEC_app (tv, args) ->\n-          fmt_app ff tv args\n \n-  in\n-  let buf = Buffer.create 16 in\n-  let bf = Format.formatter_of_buffer buf in\n-    begin\n-      fmt_tyspec bf ts;\n-      Format.pp_print_flush bf ();\n-      Buffer.contents buf\n-    end\n-;;\n-\n-let iflog cx thunk =\n-  if cx.ctxt_sess.Session.sess_log_type\n-  then thunk ()\n-  else ()\n-;;\n-\n-let rec resolve_tyvar (tv:tyvar) : tyvar =\n-  match !tv with\n-      TYSPEC_equiv subtv -> resolve_tyvar subtv\n-    | _ -> tv\n-;;\n-\n-type unify_ctxt =\n-    { mut_ok: bool;\n-      box_ok: bool }\n-;;\n-\n-let arg_pass_ctx =\n-  { box_ok = false;\n-    mut_ok = true }\n-;;\n-\n-let rval_ctx =\n-  { box_ok = true;\n-    mut_ok = true }\n-;;\n-\n-let lval_ctx =\n-  { box_ok = false;\n-    mut_ok = true }\n-;;\n-\n-let init_ctx =\n-  { box_ok = true;\n-    mut_ok = true }\n-;;\n-\n-let strict_ctx =\n-  { box_ok = false;\n-    mut_ok = false }\n-;;\n-\n-\n-let process_crate (cx:ctxt) (crate:Ast.crate) : unit =\n-\n-  let depth = ref 0 in\n-\n-  let log cx = Session.log \"type\"\n-    cx.ctxt_sess.Session.sess_log_type\n-    cx.ctxt_sess.Session.sess_log_out\n+  let sprintf_ltype _ (lty:ltype) : string =\n+    match lty with\n+        LTYPE_mono ty | LTYPE_poly (_, ty) -> Ast.sprintf_ty () ty\n+      | LTYPE_module items -> Ast.sprintf_mod_items () items\n   in\n \n-  let retval_tvs = Stack.create () in\n-  let fns = Stack.create () in\n+  let get_slot_ty (slot:Ast.slot) : Ast.ty =\n+    match slot.Ast.slot_ty with\n+        Some ty -> ty \n+      | None -> Common.bug () \"get_slot_ty: no type in slot\"\n+  in\n \n-  let push_fn fn =\n-    Stack.push fn fns\n+  (* [unbox ty] strips off all boxes in [ty] and returns a tuple consisting of\n+   * the number of boxes that were stripped off. *)\n+  let unbox (ty:Ast.ty) : (Ast.ty * int) =\n+    let rec unbox ty acc =\n+      match ty with\n+          Ast.TY_box ty' -> unbox ty' (acc + 1)\n+        | _ -> (ty, acc)\n+    in\n+    unbox ty 0\n   in\n \n-  let pop_fn _ =\n-    ignore (Stack.pop fns)\n+  let maybe_mutable (mutability:Ast.mutability) (ty:Ast.ty) : Ast.ty =\n+    if mutability = Ast.MUT_mutable then Ast.TY_mutable ty else ty\n   in\n \n-  let fn_is_iter() =\n-    (Stack.top fns).Ast.fn_aux.Ast.fn_is_iter\n+  (*\n+   * Type assertions\n+   *)\n+\n+  let is_integer (ty:Ast.ty) =\n+    match ty with\n+        Ast.TY_int | Ast.TY_uint\n+      | Ast.TY_mach Common.TY_u8 | Ast.TY_mach Common.TY_u16\n+      | Ast.TY_mach Common.TY_u32 | Ast.TY_mach Common.TY_u64\n+      | Ast.TY_mach Common.TY_i8 | Ast.TY_mach Common.TY_i16\n+      | Ast.TY_mach Common.TY_i32 | Ast.TY_mach Common.TY_i64 -> true\n+      | _ -> false\n   in\n \n-  let push_retval_tv tv =\n-    Stack.push tv retval_tvs\n+  let demand (expected:Ast.ty) (actual:Ast.ty) : unit =\n+    let expected, actual = fundamental_ty expected, fundamental_ty actual in\n+    if expected <> actual then\n+      type_error (Printf.sprintf \"%a\" Ast.sprintf_ty expected) actual\n   in\n-  let pop_retval_tv _ =\n-    ignore (Stack.pop retval_tvs)\n+  let demand_integer (actual:Ast.ty) : unit =\n+    if not (is_integer (fundamental_ty actual)) then\n+      type_error \"integer\" actual\n   in\n-  let retval_tv _ =\n-    Stack.top retval_tvs\n+  let demand_bool_or_char_or_integer (actual:Ast.ty) : unit =\n+    match fundamental_ty actual with\n+        Ast.TY_bool | Ast.TY_char -> ()\n+      | ty when is_integer ty -> ()\n+      | _ -> type_error \"bool, char, or integer\" actual\n   in\n-\n-  let pat_tvs = Stack.create () in\n-  let push_pat_tv tv =\n-    Stack.push tv pat_tvs\n+  let demand_number (actual:Ast.ty) : unit =\n+    match fundamental_ty actual with\n+        Ast.TY_int | Ast.TY_uint | Ast.TY_mach _ -> ()\n+      | ty -> type_error \"number\" ty\n   in\n-  let pop_pat_tv _ =\n-    ignore (Stack.pop pat_tvs)\n+  let demand_number_or_str_or_vector (actual:Ast.ty) : unit =\n+    match fundamental_ty actual with\n+        Ast.TY_int | Ast.TY_uint | Ast.TY_mach _ | Ast.TY_str\n+      | Ast.TY_vec _ ->\n+          ()\n+      | ty -> type_error \"number, string, or vector\" ty\n   in\n-  let pat_tv _ =\n-    Stack.top pat_tvs\n+  let demand_vec (actual:Ast.ty) : Ast.ty =\n+    match fundamental_ty actual with\n+        Ast.TY_vec ty -> ty\n+      | ty -> type_error \"vector\" ty\n+  in\n+  let demand_vec_with_mutability\n+      (mut:Ast.mutability)\n+      (actual:Ast.ty)\n+      : Ast.ty =\n+    match mut, fundamental_ty actual with\n+        Ast.MUT_mutable, Ast.TY_vec ((Ast.TY_mutable _) as ty) -> ty\n+      | Ast.MUT_mutable, ty -> type_error \"mutable vector\" ty\n+      | Ast.MUT_immutable, ((Ast.TY_vec (Ast.TY_mutable _)) as ty) ->\n+          type_error \"immutable vector\" ty\n+      | Ast.MUT_immutable, Ast.TY_vec ty -> ty\n+      | Ast.MUT_immutable, ty -> type_error \"immutable vector\" ty\n+  in\n+  let demand_vec_or_str (actual:Ast.ty) : Ast.ty =\n+    match fundamental_ty actual with\n+        Ast.TY_vec ty -> ty\n+      | Ast.TY_str -> Ast.TY_mach Common.TY_u8\n+      | ty -> type_error \"vector or string\" ty\n+  in\n+  let demand_rec (actual:Ast.ty) : Ast.ty_rec =\n+    match fundamental_ty actual with\n+        Ast.TY_rec ty_rec -> ty_rec\n+      | ty -> type_error \"record\" ty\n+  in\n+  let demand_fn (arg_tys:Ast.ty option array) (actual:Ast.ty) : Ast.ty =\n+    let expected = lazy begin\n+      Format.fprintf Format.str_formatter \"fn(\";\n+      let print_arg_ty i arg_ty_opt =\n+        if i > 0 then Format.fprintf Format.str_formatter \", \";\n+        match arg_ty_opt with\n+            None -> Format.fprintf Format.str_formatter \"<?>\"\n+          | Some arg_ty -> Ast.fmt_ty Format.str_formatter arg_ty\n+      in\n+      Array.iteri print_arg_ty arg_tys;\n+      Format.fprintf Format.str_formatter \")\";\n+      Format.flush_str_formatter()\n+    end in\n+    match fundamental_ty actual with\n+        Ast.TY_fn (ty_sig, _) as ty ->\n+          let in_slots = ty_sig.Ast.sig_input_slots in\n+          if Array.length arg_tys != Array.length in_slots then\n+            type_error (Lazy.force expected) ty;\n+          let in_slot_tys = Array.map get_slot_ty in_slots in\n+          let maybe_demand a_opt b =\n+            match a_opt with None -> () | Some a -> demand a b\n+          in\n+          Common.arr_iter2 maybe_demand arg_tys in_slot_tys;\n+          get_slot_ty (ty_sig.Ast.sig_output_slot)\n+      | ty -> type_error \"function\" ty\n+  in\n+  let demand_chan (actual:Ast.ty) : Ast.ty =\n+    match fundamental_ty actual with\n+        Ast.TY_chan ty -> ty\n+      | ty -> type_error \"channel\" ty\n+  in\n+  let demand_port (actual:Ast.ty) : Ast.ty =\n+    match fundamental_ty actual with\n+        Ast.TY_port ty -> ty\n+      | ty -> type_error \"port\" ty\n+  in\n+  let demand_all (tys:Ast.ty array) : Ast.ty =\n+    if Array.length tys == 0 then\n+      Common.bug () \"demand_all called with an empty array of types\";\n+    let pivot = fundamental_ty tys.(0) in\n+    for i = 1 to Array.length tys - 1 do\n+      demand pivot tys.(i)\n+    done;\n+    pivot\n   in\n \n-  let (bindings:(node_id, tyvar) Hashtbl.t) = Hashtbl.create 10 in\n-  let (item_params:(node_id, tyvar array) Hashtbl.t) = Hashtbl.create 10 in\n-  let (lval_tyvars:(node_id, tyvar) Hashtbl.t) = Hashtbl.create 0 in\n-\n-  let path = Stack.create () in\n+  (* Performs beta-reduction (that is, type-param substitution). *)\n+  let beta_reduce\n+      (lval_id:Common.node_id)\n+      (lty:ltype)\n+      (args:Ast.ty array)\n+      : ltype =\n+    if Hashtbl.mem cx.Semant.ctxt_call_lval_params lval_id then\n+      assert (args = Hashtbl.find cx.Semant.ctxt_call_lval_params lval_id)\n+    else\n+      Hashtbl.add cx.Semant.ctxt_call_lval_params lval_id args;\n+\n+    match lty with\n+        LTYPE_poly (params, ty) ->\n+          LTYPE_mono (Semant.rebuild_ty_under_params ty params args true)\n+      | _ ->\n+        Common.err None \"expected polymorphic type but found %a\"\n+          sprintf_ltype lty\n+  in\n \n-  let visitor (cx:ctxt) (inner:Walk.visitor) : Walk.visitor =\n-\n-    let rec unify_slot\n-        (ucx:unify_ctxt)\n-        (slot:Ast.slot)\n-        (id_opt:node_id option)\n-        (tv:tyvar) : unit =\n-      match id_opt with\n-          Some id ->\n-            unify_tyvars ucx (Hashtbl.find bindings id) tv\n-        | None ->\n-            match slot.Ast.slot_ty with\n-                None -> bug () \"untyped unidentified slot\"\n-              | Some ty -> unify_ty ucx ty tv\n-\n-    and check_sane_tyvar tv =\n-      match !tv with\n-          TYSPEC_resolved (_, (Ast.TY_named _)) ->\n-            bug () \"named-type in type checker\"\n-        | _ -> ()\n+  (*\n+   * Lvalue and slot checking.\n+   *\n+   * We use a slightly different type language here which includes polytypes;\n+   * see [ltype] above.\n+   *)\n+\n+  let check_literal (lit:Ast.lit) : Ast.ty =\n+    match lit with\n+        Ast.LIT_nil -> Ast.TY_nil\n+      | Ast.LIT_bool _ -> Ast.TY_bool\n+      | Ast.LIT_mach (mty, _, _) -> Ast.TY_mach mty\n+      | Ast.LIT_int _ -> Ast.TY_int\n+      | Ast.LIT_uint _ -> Ast.TY_uint\n+      | Ast.LIT_char _ -> Ast.TY_char\n+  in\n \n-    and unify_tyvars (ucx:unify_ctxt) (av:tyvar) (bv:tyvar) : unit =\n-      let indent = String.make (4 * (!depth)) ' ' in\n-        iflog cx\n-          (fun _ ->\n-             log cx \"%s> unifying types:\" indent;\n-             if ucx.box_ok || ucx.mut_ok\n-             then\n-               log cx \"%s> (w/ %s%s%s)\"\n-                 indent\n-                 (if ucx.box_ok then \"ext-ok\" else \"\")\n-                 (if ucx.box_ok && ucx.mut_ok then \" \" else \"\")\n-                 (if ucx.mut_ok then \"mut-ok\" else \"\");\n-             log cx \"%s> input tyvar A:     %s\" indent (tyspec_to_str !av);\n-             log cx \"%s> input tyvar B:     %s\" indent (tyspec_to_str !bv));\n-        check_sane_tyvar av;\n-        check_sane_tyvar bv;\n-\n-        incr depth;\n-        unify_tyvars' ucx av bv;\n-        decr depth;\n-\n-        iflog cx\n-          (fun _ ->\n-             log cx \"%s< unified types:\" indent;\n-             log cx \"%s< output tyvar A:     %s\" indent (tyspec_to_str !av);\n-             log cx \"%s< output tyvar B:     %s\" indent (tyspec_to_str !bv));\n-        check_sane_tyvar av;\n-        check_sane_tyvar bv;\n-\n-    and unify_tyvars' (ucx:unify_ctxt) (av:tyvar) (bv:tyvar) : unit =\n-      let (a, b) = ((resolve_tyvar av), (resolve_tyvar bv)) in\n-      let fail () =\n-        err None \"mismatched types: %s vs. %s\" (tyspec_to_str !av)\n-          (tyspec_to_str !bv);\n-      in\n+  (* Here the actual inference happens. *)\n+  let internal_check_slot\n+      (infer:Ast.ty option)\n+      (defn_id:Common.node_id)\n+      : Ast.ty =\n+    let slot =\n+      match Hashtbl.find cx.Semant.ctxt_all_defns defn_id with\n+          Semant.DEFN_slot slot -> slot\n+        | _ ->\n+          Common.bug\n+            ()\n+            \"internal_check_slot: supplied defn wasn't a slot at all\"\n+    in\n+    match infer, slot.Ast.slot_ty with \n+        Some expected, Some actual ->\n+          demand expected actual;\n+          actual\n+      | Some inferred, None ->\n+          log cx \"setting auto slot #%d = %a to type %a\"\n+            (Common.int_of_node defn_id)\n+            Ast.sprintf_slot_key\n+              (Hashtbl.find cx.Semant.ctxt_slot_keys defn_id)\n+            Ast.sprintf_ty inferred;\n+          let new_slot = { slot with Ast.slot_ty = Some inferred } in\n+          Hashtbl.replace cx.Semant.ctxt_all_defns defn_id\n+            (Semant.DEFN_slot new_slot);\n+          inferred\n+      | None, Some actual -> actual\n+      | None, None ->\n+          Common.err None \"can't infer any type for this slot\"\n+  in\n \n-      let merge_dicts a b =\n-        let c = Hashtbl.create ((Hashtbl.length a) + (Hashtbl.length b)) in\n-        let merge ident tv_a =\n-          if Hashtbl.mem c ident\n-          then unify_tyvars ucx (Hashtbl.find c ident) tv_a\n-          else Hashtbl.add c ident tv_a\n-        in\n-          Hashtbl.iter (Hashtbl.add c) b;\n-          Hashtbl.iter merge a;\n-          c\n-      in\n+  let internal_check_mod_item_decl\n+      (mid:Ast.mod_item_decl)\n+      (mid_id:Common.node_id)\n+      : ltype =\n+    match mid.Ast.decl_item with\n+        Ast.MOD_ITEM_mod (_, items) -> LTYPE_module items\n+      | Ast.MOD_ITEM_fn _ | Ast.MOD_ITEM_obj _ | Ast.MOD_ITEM_tag _ ->\n+          let ty = Hashtbl.find cx.Semant.ctxt_all_item_types mid_id in\n+          let params = mid.Ast.decl_params in\n+          if Array.length params == 0 then\n+            LTYPE_mono ty\n+          else\n+            LTYPE_poly ((Array.map (fun p -> p.Common.node) params), ty)\n+      | Ast.MOD_ITEM_type _ ->\n+          Common.bug\n+            ()\n+            \"internal_check_mod_item_decl: unexpected mod item type\"\n+  in\n \n-      let unify_dict_with_record_fields\n-          (dct:dict)\n-          (fields:Ast.ty_rec)\n-          : unit =\n-        let find_ty (query:Ast.ident) : Ast.ty =\n-          match atab_search fields query with\n-              None -> fail()\n-            | Some t -> t\n-        in\n-\n-        let check_entry ident tv =\n-          unify_ty ucx (find_ty ident) tv\n-        in\n-          Hashtbl.iter check_entry dct\n-      in\n+  let rec internal_check_base_lval\n+      (infer:Ast.ty option)\n+      (nbi:Ast.name_base Common.identified)\n+      : ltype =\n+    let lval_id = nbi.Common.id in\n+    let referent = Semant.lval_to_referent cx lval_id in\n+    let lty =\n+      match Hashtbl.find cx.Semant.ctxt_all_defns referent with\n+          Semant.DEFN_slot _ ->\n+            LTYPE_mono (internal_check_slot infer referent)\n+        | Semant.DEFN_item mid -> internal_check_mod_item_decl mid referent\n+        | _ -> Common.bug () \"internal_check_base_lval: unexpected defn type\"\n+    in\n+    match nbi.Common.node with\n+        Ast.BASE_ident _ | Ast.BASE_temp _ -> lty\n+      | Ast.BASE_app (_, args) -> beta_reduce lval_id lty args\n+\n+  and internal_check_ext_lval\n+      (base:Ast.lval)\n+      (comp:Ast.lval_component)\n+      : ltype =\n+    let base_ity =\n+      match internal_check_lval None base with\n+          LTYPE_poly (_, ty) ->\n+            Common.err None \"can't index the polymorphic type '%a'\"\n+              Ast.sprintf_ty ty\n+        | LTYPE_mono ty -> `Type (fundamental_ty ty)\n+        | LTYPE_module items -> `Module items\n+    in\n \n-      let unify_dict_with_obj_fns\n-          (dct:dict)\n-          (fns:(Ast.ident,Ast.ty_fn) Hashtbl.t) : unit =\n-        let check_entry (query:Ast.ident) tv : unit =\n-          match htab_search fns query with\n-              None -> fail ()\n-            | Some fn -> unify_ty ucx (Ast.TY_fn fn) tv\n-        in\n-          Hashtbl.iter check_entry dct\n-      in\n+    let sprintf_itype chan () =\n+      match base_ity with\n+          `Type ty -> Ast.sprintf_ty chan ty\n+        | `Module items -> Ast.sprintf_mod_items chan items\n+    in\n \n-      let rec unify_resolved_types\n-          (ty_a:Ast.ty)\n-          (ty_b:Ast.ty)\n-          : Ast.ty =\n-        match ty_a, ty_b with\n-            a, b when a = b -> a\n-          | Ast.TY_box a, b | b, Ast.TY_box a when ucx.box_ok ->\n-              Ast.TY_box (unify_resolved_types a b)\n-          | Ast.TY_mutable a, b | b, Ast.TY_mutable a when ucx.mut_ok ->\n-              Ast.TY_mutable (unify_resolved_types a b)\n-          | Ast.TY_constrained (a, constrs), b\n-          | b, Ast.TY_constrained (a, constrs) ->\n-              Ast.TY_constrained ((unify_resolved_types a b), constrs)\n-          | _ -> fail()\n-      in\n+    let rec typecheck base_ity =\n+      match base_ity, comp with\n+          `Type (Ast.TY_rec ty_rec), Ast.COMP_named (Ast.COMP_ident id) ->\n+            let find _ (k, v) = if id = k then Some v else None in\n+            let comp_ty =\n+              match Common.arr_search ty_rec find with\n+                  Some elem_ty -> elem_ty\n+                | None ->\n+                    Common.err\n+                      None\n+                      \"field '%s' is not one of the fields of '%a'\"\n+                      id\n+                      sprintf_itype ()\n+            in\n+            LTYPE_mono comp_ty\n+\n+        | `Type (Ast.TY_rec _), _ ->\n+            Common.err None \"the record type '%a' must be indexed by name\"\n+              sprintf_itype ()\n+\n+        | `Type (Ast.TY_obj ty_obj), Ast.COMP_named (Ast.COMP_ident id) ->\n+            let comp_ty =\n+              try\n+                Ast.TY_fn (Hashtbl.find (snd ty_obj) id)\n+              with Not_found ->\n+                Common.err\n+                  None\n+                  \"method '%s' is not one of the methods of '%a'\"\n+                  id\n+                  sprintf_itype ()\n+            in\n+            LTYPE_mono comp_ty\n+\n+        | `Type (Ast.TY_obj _), _ ->\n+            Common.err\n+              None\n+              \"the object type '%a' must be indexed by name\"\n+              sprintf_itype ()\n+\n+        | `Type (Ast.TY_tup ty_tup), Ast.COMP_named (Ast.COMP_idx idx)\n+              when idx < Array.length ty_tup ->\n+            LTYPE_mono (ty_tup.(idx))\n+\n+        | `Type (Ast.TY_tup _), Ast.COMP_named (Ast.COMP_idx idx) ->\n+            Common.err\n+              None\n+              \"member '_%d' is not one of the members of '%a'\"\n+              idx\n+              sprintf_itype ()\n+\n+        | `Type (Ast.TY_tup _), _ ->\n+            Common.err\n+              None\n+              \"the tuple type '%a' must be indexed by tuple index\"\n+              sprintf_itype ()\n+\n+        | `Type (Ast.TY_vec ty_vec), Ast.COMP_atom atom ->\n+            demand Ast.TY_int (check_atom atom);\n+            LTYPE_mono ty_vec\n+\n+        | `Type (Ast.TY_vec _), _ ->\n+            Common.err None \"the vector type '%a' must be indexed via an int\"\n+              sprintf_itype ()\n+\n+        | `Type Ast.TY_str, Ast.COMP_atom atom ->\n+            demand Ast.TY_int (check_atom atom);\n+            LTYPE_mono (Ast.TY_mach Common.TY_u8)\n+\n+        | `Type Ast.TY_str, _ ->\n+            Common.err None \"strings must be indexed via an int\"\n+\n+        | `Type (Ast.TY_box ty_box), Ast.COMP_deref -> LTYPE_mono ty_box\n+\n+        | `Type (Ast.TY_box ty_box), _ ->\n+            typecheck (`Type ty_box)  (* automatically dereference! *)\n+\n+        | `Type ty, Ast.COMP_named (Ast.COMP_ident _) ->\n+            Common.err None \"the type '%a' can't be indexed by name\"\n+              Ast.sprintf_ty ty\n+\n+        | `Type ty, Ast.COMP_named (Ast.COMP_app _) ->\n+            Common.err\n+              None\n+              \"the type '%a' has no type parameters, so it can't be applied \\\n+              to types\"\n+              Ast.sprintf_ty ty\n+\n+        | `Module items, Ast.COMP_named ((Ast.COMP_ident id) as name_comp)\n+              | `Module items, Ast.COMP_named ((Ast.COMP_app (id, _))\n+                as name_comp) ->\n+            let mod_item =\n+              try\n+                Hashtbl.find items id\n+              with Not_found ->\n+                Common.bug\n+                  ()\n+                  \"internal_check_ext_lval: ident not found in mod item\"\n+            in\n+            let lty =\n+              internal_check_mod_item_decl\n+                mod_item.Common.node\n+                mod_item.Common.id\n+            in\n+            begin\n+              match name_comp with\n+                  Ast.COMP_ident _ -> lty\n+                | Ast.COMP_app (_, args) ->\n+                    beta_reduce (Semant.lval_base_id base) lty args\n+                | _ ->\n+                  Common.bug ()\n+                    \"internal_check_ext_lval: unexpected name_comp\"\n+            end\n \n-      let rec is_comparable_or_ordered (comparable:bool) (ty:Ast.ty) : bool =\n-        match ty with\n-            Ast.TY_mach _ | Ast.TY_int | Ast.TY_uint\n-          | Ast.TY_char | Ast.TY_str -> true\n-          | Ast.TY_any | Ast.TY_nil | Ast.TY_bool | Ast.TY_chan _\n-          | Ast.TY_port _ | Ast.TY_task | Ast.TY_tup _ | Ast.TY_vec _\n-          | Ast.TY_rec _ | Ast.TY_tag _ | Ast.TY_iso _ | Ast.TY_idx _ ->\n-              comparable\n-          | Ast.TY_fn _ | Ast.TY_obj _\n-          | Ast.TY_param _ | Ast.TY_native _ | Ast.TY_type -> false\n-          | Ast.TY_named _ -> bug () \"unexpected named type\"\n-          | Ast.TY_constrained (ty, _) ->\n-              is_comparable_or_ordered comparable ty\n-          | Ast.TY_mutable ty ->\n-              is_comparable_or_ordered comparable ty\n-          | Ast.TY_box ty ->\n-              ucx.box_ok && is_comparable_or_ordered comparable ty\n-      in\n+        | _, Ast.COMP_named (Ast.COMP_idx _) ->\n+            Common.err\n+              None\n+              \"%a isn't a tuple, so it can't be indexed by tuple index\"\n+              sprintf_itype ()\n+\n+        | _, Ast.COMP_atom atom ->\n+            Common.err\n+              None\n+              \"%a can't by indexed by the type '%a'\"\n+              sprintf_itype ()\n+              Ast.sprintf_ty (check_atom atom)\n+\n+        | _, Ast.COMP_deref ->\n+            Common.err\n+              None\n+              \"%a isn't a box and can't be dereferenced\"\n+              sprintf_itype ()\n+    in\n+    typecheck base_ity\n+\n+  and internal_check_lval (infer:Ast.ty option) (lval:Ast.lval) : ltype =\n+    match lval with\n+        Ast.LVAL_base nbi -> internal_check_base_lval infer nbi\n+      | Ast.LVAL_ext (base, comp) -> internal_check_ext_lval base comp\n+\n+  (* Checks the outermost lvalue and returns the resulting monotype and the\n+   * number of layers of indirection needed to access it (i.e. the number of\n+   * boxes that were automatically dereferenced, which will always be zero if\n+   * the supplied [autoderef] parameter is false). This function is the bridge\n+   * between the polymorphically typed lvalue world and the monomorphically\n+   * typed value world. *)\n+  and internal_check_outer_lval\n+      ~mut:(mut:Ast.mutability)\n+      ~deref:(deref:bool)\n+      (infer:Ast.ty option)\n+      (lval:Ast.lval)\n+      : (Ast.ty * int) =\n+    let yield_ty ty =\n+      let (ty, n_boxes) = if deref then unbox ty else (ty, 0) in\n+      (maybe_mutable mut ty, n_boxes)\n+    in\n+    match infer, internal_check_lval infer lval with\n+      | None, LTYPE_mono ty -> yield_ty ty\n+      | Some expected, LTYPE_mono actual ->\n+          demand expected actual;\n+          yield_ty actual\n+      | None, (LTYPE_poly _ as lty) -> \n+          Common.err\n+            None\n+            \"not enough context to automatically instantiate the polymorphic \\\n+              type '%a'; supply type parameters explicitly\"\n+            sprintf_ltype lty\n+      | Some _, (LTYPE_poly _) ->\n+          (* FIXME: auto-instantiate *)\n+          Common.err\n+            None\n+            \"sorry, automatic polymorphic instantiation isn't supported yet; \\\n+              please supply type parameters explicitly\"\n+      | _, LTYPE_module _ ->\n+          Common.err None \"can't refer to a module as a first-class value\"\n+\n+  and generic_check_lval\n+      ~mut:(mut:Ast.mutability)\n+      ~deref:(deref:bool)\n+      (infer:Ast.ty option)\n+      (lval:Ast.lval)\n+      : Ast.ty =\n+    (* The lval we got is an impostor (it may contain unresolved TY_nameds).\n+     * Get the real one. *)\n+    let lval_id = Semant.lval_base_id lval in\n+    let lval = Hashtbl.find cx.Semant.ctxt_all_lvals lval_id in\n+    let (lval_ty, n_boxes) =\n+      internal_check_outer_lval ~mut:mut ~deref:deref infer lval\n+    in\n \n-      let rec floating (ty:Ast.ty) : bool =\n-        match ty with\n-            Ast.TY_mach TY_f32 | Ast.TY_mach TY_f64 -> true\n-          | Ast.TY_mutable ty when ucx.mut_ok -> floating ty\n-          | Ast.TY_box ty when ucx.box_ok -> floating ty\n-          | _ -> false\n-      in\n+    if Hashtbl.mem cx.Semant.ctxt_all_lval_types lval_id then\n+      assert ((Hashtbl.find cx.Semant.ctxt_all_lval_types lval_id) = lval_ty)\n+    else\n+      Hashtbl.replace cx.Semant.ctxt_all_lval_types lval_id lval_ty;\n \n-      let rec integral (ty:Ast.ty) : bool =\n-        match ty with\n-            Ast.TY_int | Ast.TY_uint | Ast.TY_mach TY_u8 | Ast.TY_mach TY_u16\n-          | Ast.TY_mach TY_u32 | Ast.TY_mach TY_u64 | Ast.TY_mach TY_i8\n-          | Ast.TY_mach TY_i16 | Ast.TY_mach TY_i32\n-          | Ast.TY_mach TY_i64 ->\n-              true\n-          | Ast.TY_mutable ty when ucx.mut_ok -> integral ty\n-          | Ast.TY_box ty when ucx.box_ok -> integral ty\n-          | _ -> false\n+    if Hashtbl.mem cx.Semant.ctxt_auto_deref_lval lval_id then begin\n+      let prev_autoderef =\n+        Hashtbl.find cx.Semant.ctxt_auto_deref_lval lval_id\n       in\n+      if n_boxes == 0 && prev_autoderef then\n+        Common.bug () \"generic_check_lval: lval was previously marked as \\\n+          deref but isn't any longer\";\n+      if n_boxes > 0 && not prev_autoderef then\n+        Common.bug () \"generic_check_lval: lval wasn't marked as autoderef \\\n+          before, but now it is\"\n+    end;\n+    if n_boxes > 1 then\n+      (* TODO: allow more than one level of automatic dereference *)\n+      Common.err None \"sorry, only one level of automatic dereference is \\\n+        implemented; please add explicit dereference operators\";\n+    Hashtbl.replace cx.Semant.ctxt_auto_deref_lval lval_id (n_boxes > 0);\n+\n+    (* Before demoting the lval to a value, strip off mutability. *)\n+    fundamental_ty lval_ty\n+\n+  (* Note that this function should be avoided when possible, because it\n+   * cannot perform type inference. In general you should prefer\n+   * [infer_lval]. *)\n+  and check_lval\n+      ?mut:(mut=Ast.MUT_immutable)\n+      ?deref:(deref=false)\n+      (lval:Ast.lval)\n+      : Ast.ty =\n+    generic_check_lval ~mut:mut ~deref:deref None lval\n+\n+  and check_atom ?deref:(deref=false) (atom:Ast.atom) : Ast.ty =\n+    match atom with\n+        Ast.ATOM_lval lval -> check_lval ~deref:deref lval\n+      | Ast.ATOM_literal lit_id -> check_literal lit_id.Common.node\n+  in\n \n-      let numeric (ty:Ast.ty) : bool = (integral ty) || (floating ty) in\n-\n-      let rec plusable (ty:Ast.ty) : bool =\n-        match ty with\n-            Ast.TY_str -> true\n-          | Ast.TY_vec _ -> true\n-          | Ast.TY_mutable ty when ucx.mut_ok -> plusable ty\n-          | Ast.TY_box ty when ucx.box_ok -> plusable ty\n-          | _ -> numeric ty\n-      in\n+  let infer_slot (ty:Ast.ty) (slot_id:Common.node_id) : unit =\n+    ignore (internal_check_slot (Some ty) slot_id)\n+  in\n \n-      let result =\n-        match (!a, !b) with\n-            (TYSPEC_equiv _, _) | (_, TYSPEC_equiv _) ->\n-              bug () \"equiv found even though tyvar was resolved\"\n+  let infer_lval\n+      ?mut:(mut=Ast.MUT_mutable)\n+      (ty:Ast.ty)\n+      (lval:Ast.lval)\n+      : unit =\n+    ignore (generic_check_lval ?mut:mut ~deref:false (Some ty) lval)\n+  in\n \n-          | (TYSPEC_all, other) | (other, TYSPEC_all) -> other\n+  (*\n+   * AST fragment checking\n+   *)\n+\n+  let check_binop (binop:Ast.binop) (operand_ty:Ast.ty) =\n+    match binop with\n+        Ast.BINOP_eq | Ast.BINOP_ne | Ast.BINOP_lt | Ast.BINOP_le\n+      | Ast.BINOP_ge | Ast.BINOP_gt ->\n+          Ast.TY_bool\n+      | Ast.BINOP_or | Ast.BINOP_and | Ast.BINOP_xor | Ast.BINOP_lsl\n+      | Ast.BINOP_lsr | Ast.BINOP_asr ->\n+          demand_integer operand_ty;\n+          operand_ty\n+      | Ast.BINOP_add ->\n+          demand_number_or_str_or_vector operand_ty;\n+          operand_ty\n+      | Ast.BINOP_sub | Ast.BINOP_mul | Ast.BINOP_div | Ast.BINOP_mod ->\n+          demand_number operand_ty;\n+          operand_ty\n+      | Ast.BINOP_send ->\n+          Common.bug () \"check_binop: BINOP_send found in expr\"\n+  in\n \n-          (* box *)\n+  let check_expr (expr:Ast.expr) : Ast.ty =\n+    match expr with\n+        Ast.EXPR_atom atom -> check_atom atom\n+      | Ast.EXPR_binary (binop, lhs, rhs) ->\n+          let operand_ty = check_atom ~deref:true lhs in\n+          demand operand_ty (check_atom ~deref:true rhs);\n+          check_binop binop operand_ty \n+      | Ast.EXPR_unary (Ast.UNOP_not, atom) ->\n+          demand Ast.TY_bool (check_atom ~deref:true atom);\n+          Ast.TY_bool\n+      | Ast.EXPR_unary (Ast.UNOP_bitnot, atom)\n+      | Ast.EXPR_unary (Ast.UNOP_neg, atom) ->\n+          let ty = check_atom atom in\n+          demand_integer ty;\n+          ty\n+      | Ast.EXPR_unary (Ast.UNOP_cast dst_ty_id, atom) ->\n+          (* TODO: probably we want to handle more cases here *)\n+          demand_bool_or_char_or_integer (check_atom atom);\n+          let dst_ty = dst_ty_id.Common.node in\n+          demand_bool_or_char_or_integer dst_ty;\n+          dst_ty\n+  in\n \n-          | (TYSPEC_box a', TYSPEC_box b') ->\n-              unify_tyvars ucx a' b'; !a\n+  (* Checks a function call pattern, with arguments specified as atoms, and\n+   * returns the return type. *)\n+  let check_fn (callee:Ast.lval) (args:Ast.atom array) : Ast.ty =\n+    let arg_tys = Array.map check_atom args in\n+    let callee_ty = check_lval callee in\n+    demand_fn (Array.map (fun ty -> Some ty) arg_tys) callee_ty \n+  in\n \n-          | (TYSPEC_box tv,\n-             TYSPEC_resolved (params, Ast.TY_box ty))\n-          | (TYSPEC_resolved (params, Ast.TY_box ty),\n-             TYSPEC_box tv) ->\n-               unify_ty_parametric ucx ty params tv; !a\n+  let rec check_pat (expected:Ast.ty) (pat:Ast.pat) : unit =\n+    match pat with\n+        Ast.PAT_lit lit -> demand expected (check_literal lit)\n+      | Ast.PAT_tag (constr_fn, arg_pats) ->\n+          let constr_ty = check_lval constr_fn in\n+          let arg_tys =\n+            match constr_ty with\n+                Ast.TY_fn (ty_sig, _) ->\n+                  Array.map get_slot_ty ty_sig.Ast.sig_input_slots\n+              | _ -> type_error \"constructor function\" constr_ty\n+          in\n+          Common.arr_iter2 check_pat arg_tys arg_pats\n+      | Ast.PAT_slot (slot, _) -> infer_slot expected slot.Common.id\n+      | Ast.PAT_wild -> ()\n+  in\n \n-          | (_, TYSPEC_resolved (params, Ast.TY_box ty))\n-              when ucx.box_ok ->\n-              unify_ty_parametric ucx ty params a; !b\n+  let check_check_calls (calls:Ast.check_calls) : unit =\n+    let check_call (callee, args) =\n+      demand Ast.TY_bool (check_fn callee args)\n+    in\n+    Array.iter check_call calls\n+  in\n \n-          | (TYSPEC_resolved (params, Ast.TY_box ty), _)\n-              when ucx.box_ok ->\n-              unify_ty_parametric ucx ty params b; !a\n+  (*\n+   * Statement checking\n+   *)\n \n-          | (TYSPEC_box a', _) when ucx.box_ok\n-              -> unify_tyvars ucx a' b; !a\n-          | (_, TYSPEC_box b') when ucx.box_ok\n-              -> unify_tyvars ucx a b'; !b\n+  (* Again as above, we explicitly curry [fn_ctx] to avoid threading it\n+   * through these functions. *)\n+  let check_stmt (fn_ctx:fn_ctx) : (Ast.stmt -> unit) =\n+    let rec check_block (block:Ast.block) : unit =\n+      Array.iter check_stmt block.Common.node\n \n-          | (_, TYSPEC_box _)\n-          | (TYSPEC_box _, _) -> fail()\n+    and check_stmt (stmt:Ast.stmt) : unit =\n+      match stmt.Common.node with\n+          Ast.STMT_spawn (dst, _, callee, args) ->\n+            infer_lval Ast.TY_task dst;\n+            demand Ast.TY_nil (check_fn callee args)\n \n-          (* mutable *)\n+        | Ast.STMT_init_rec (dst, fields, Some base) ->\n+            let ty = check_lval base in\n+            let ty_rec = demand_rec ty in\n+            let field_tys = Hashtbl.create (Array.length ty_rec) in\n+            Array.iter (fun (id, ty) -> Hashtbl.add field_tys id ty) ty_rec;\n+            let check_field (name, mut, atom) =\n+              let field_ty =\n+                try\n+                  Hashtbl.find field_tys name\n+                with Not_found ->\n+                  Common.err None\n+                    \"field '%s' is not one of the base record's fields\" name\n+              in\n+              demand field_ty (maybe_mutable mut (check_atom atom))\n+            in\n+            Array.iter check_field fields;\n+            infer_lval ty dst\n \n-          | (TYSPEC_mutable a', TYSPEC_mutable b') ->\n-              unify_tyvars ucx a' b'; !a\n+        | Ast.STMT_init_rec (dst, fields, None) ->\n+            let check_field (name, mut, atom) =\n+              (name, maybe_mutable mut (check_atom atom))\n+            in\n+            let ty = Ast.TY_rec (Array.map check_field fields) in\n+            infer_lval ty dst\n \n-          | (TYSPEC_mutable tv,\n-             TYSPEC_resolved (params, Ast.TY_mutable ty))\n-          | (TYSPEC_resolved (params, Ast.TY_mutable ty),\n-             TYSPEC_mutable tv) ->\n-               unify_ty_parametric ucx ty params tv; !a\n+        | Ast.STMT_init_tup (dst, members) ->\n+            let check_member (mut, atom) =\n+              maybe_mutable mut (check_atom atom)\n+            in\n+            let ty = Ast.TY_tup (Array.map check_member members) in\n+            infer_lval ty dst\n \n-          | (_, TYSPEC_resolved (params, Ast.TY_mutable ty))\n-              when ucx.mut_ok ->\n-              unify_ty_parametric ucx ty params a; !b\n+        | Ast.STMT_init_vec (dst, mut, [| |]) ->\n+            (* no inference allowed here *)\n+            let lval_ty = check_lval ~mut:Ast.MUT_mutable dst in\n+            ignore (demand_vec_with_mutability mut lval_ty)\n \n-          | (TYSPEC_resolved (params, Ast.TY_mutable ty), _)\n-              when ucx.mut_ok ->\n-              unify_ty_parametric ucx ty params b; !a\n+        | Ast.STMT_init_vec (dst, mut, elems) ->\n+            let atom_ty = demand_all (Array.map check_atom elems) in\n+            let ty = Ast.TY_vec (maybe_mutable mut atom_ty) in\n+            infer_lval ty dst\n \n-          | (TYSPEC_mutable a', _) when ucx.mut_ok\n-              -> unify_tyvars ucx a' b; !a\n-          | (_, TYSPEC_mutable b') when ucx.mut_ok\n-              -> unify_tyvars ucx a b'; !b\n+        | Ast.STMT_init_str (dst, _) -> infer_lval Ast.TY_str dst\n \n-          | (_, TYSPEC_mutable _)\n-          | (TYSPEC_mutable _, _) -> fail()\n+        | Ast.STMT_init_port _ -> ()  (* we can't actually typecheck this *)\n \n-          (* resolved *)\n+        | Ast.STMT_init_chan (dst, Some port) ->\n+            let ty = Ast.TY_chan (demand_port (check_lval port)) in\n+            infer_lval ty dst\n \n-          | (TYSPEC_resolved (params_a, ty_a),\n-             TYSPEC_resolved (params_b, ty_b)) ->\n-              if params_a <> params_b then fail()\n-              else TYSPEC_resolved\n-                (params_a, (unify_resolved_types ty_a ty_b))\n+        | Ast.STMT_init_chan (_, None) -> ()  (* can't check this either *)\n \n-          | (TYSPEC_resolved (params, ty),\n-             TYSPEC_callable (out_tv, in_tvs))\n-          | (TYSPEC_callable (out_tv, in_tvs),\n-             TYSPEC_resolved (params, ty)) ->\n-              let unify_in_slot i in_slot =\n-                unify_slot arg_pass_ctx in_slot None in_tvs.(i)\n-              in\n-                let rec unify ty =\n-                  match ty with\n-                      Ast.TY_fn ({\n-                                   Ast.sig_input_slots = in_slots;\n-                                   Ast.sig_output_slot = out_slot\n-                                 }, _) ->\n-                        if Array.length in_slots != Array.length in_tvs\n-                        then\n-                          fail ()\n-                        else\n-                          unify_slot arg_pass_ctx out_slot None out_tv;\n-                          Array.iteri unify_in_slot in_slots;\n-                          ty\n-                    | Ast.TY_box ty when ucx.box_ok\n-                        -> Ast.TY_box (unify ty)\n-                    | Ast.TY_mutable ty when ucx.mut_ok\n-                        -> Ast.TY_mutable (unify ty)\n-                    | _ -> fail ()\n-                in\n-                TYSPEC_resolved (params, unify ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_collection tv)\n-          | (TYSPEC_collection tv, TYSPEC_resolved (params, ty)) ->\n-              let rec unify ty =\n-                match ty with\n-                    Ast.TY_vec ty' -> unify_ty ucx ty' tv; ty\n-                  | Ast.TY_str ->\n-                      unify_ty ucx (Ast.TY_mach TY_u8) tv; ty\n-                  | Ast.TY_box ty\n-                      when ucx.box_ok -> Ast.TY_box (unify ty)\n-                  | Ast.TY_mutable ty\n-                      when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n-                  | _ -> fail ()\n-              in\n-              TYSPEC_resolved (params, unify ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_comparable)\n-          | (TYSPEC_comparable, TYSPEC_resolved (params, ty)) ->\n-              if not (is_comparable_or_ordered true ty) then fail ()\n-              else TYSPEC_resolved (params, ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_plusable)\n-          | (TYSPEC_plusable, TYSPEC_resolved (params, ty)) ->\n-              if not (plusable ty) then fail ()\n-              else TYSPEC_resolved (params, ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_dictionary dct)\n-          | (TYSPEC_dictionary dct, TYSPEC_resolved (params, ty)) ->\n-              let rec unify ty =\n-                match ty with\n-                    Ast.TY_rec fields ->\n-                      unify_dict_with_record_fields dct fields;\n-                      ty\n-                  | Ast.TY_obj (_, fns) ->\n-                      unify_dict_with_obj_fns dct fns;\n-                      ty\n-                  | Ast.TY_box ty\n-                      when ucx.box_ok -> Ast.TY_box (unify ty)\n-                  | Ast.TY_mutable ty\n-                      when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n-                  | _ -> fail ()\n-              in\n-              TYSPEC_resolved (params, unify ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_integral)\n-          | (TYSPEC_integral, TYSPEC_resolved (params, ty)) ->\n-              if not (integral ty)\n-              then fail ()\n-              else TYSPEC_resolved (params, ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_numeric)\n-          | (TYSPEC_numeric, TYSPEC_resolved (params, ty)) ->\n-              if not (numeric ty) then fail ()\n-              else TYSPEC_resolved (params, ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_ordered)\n-          | (TYSPEC_ordered, TYSPEC_resolved (params, ty)) ->\n-              if not (is_comparable_or_ordered false ty) then fail ()\n-              else TYSPEC_resolved (params, ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_app (tv, args))\n-          | (TYSPEC_app (tv, args), TYSPEC_resolved (params, ty)) ->\n-              let ty = rebuild_ty_under_params ty params args false in\n-                unify_ty ucx ty tv;\n-                TYSPEC_resolved ([| |], ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_record dct)\n-          | (TYSPEC_record dct, TYSPEC_resolved (params, ty)) ->\n-              let rec unify ty =\n-                match ty with\n-                    Ast.TY_rec fields ->\n-                      unify_dict_with_record_fields dct fields;\n-                      ty\n-                  | Ast.TY_box ty\n-                      when ucx.box_ok -> Ast.TY_box (unify ty)\n-                  | Ast.TY_mutable ty\n-                      when ucx.mut_ok -> Ast.TY_mutable (unify ty)\n-                  | _ -> fail ()\n-              in\n-              TYSPEC_resolved (params, unify ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_tuple tvs)\n-          | (TYSPEC_tuple tvs, TYSPEC_resolved (params, ty)) ->\n-              let rec unify ty =\n-                match ty with\n-                    Ast.TY_tup (elem_tys:Ast.ty array) ->\n-                      if (Array.length elem_tys) < (Array.length tvs)\n-                      then fail ()\n-                      else\n-                        let check_elem i tv =\n-                          unify_ty ucx (elem_tys.(i)) tv\n-                        in\n-                          Array.iteri check_elem tvs;\n-                          ty\n-                  | Ast.TY_box ty\n-                      when ucx.box_ok -> Ast.TY_box (unify ty)\n-                  | Ast.TY_mutable ty\n-                      when ucx.box_ok -> Ast.TY_mutable (unify ty)\n-                  | _ -> fail ()\n-              in\n-              TYSPEC_resolved (params, unify ty)\n-\n-          | (TYSPEC_resolved (params, ty), TYSPEC_vector tv)\n-          | (TYSPEC_vector tv, TYSPEC_resolved (params, ty)) ->\n-              let rec unify ty =\n-                match ty with\n-                    Ast.TY_vec ty' -> unify_ty ucx ty' tv; ty\n-                  | Ast.TY_box ty when ucx.box_ok ->\n-                      Ast.TY_box (unify ty)\n-                  | Ast.TY_mutable ty when ucx.mut_ok ->\n-                      Ast.TY_mutable (unify ty)\n-                  | _ -> fail ()\n-              in\n-              TYSPEC_resolved (params, unify ty)\n+        | Ast.STMT_init_box (dst, mut, src) ->\n+            let ty = Ast.TY_box (maybe_mutable mut (check_atom src)) in\n+            infer_lval ty dst\n \n-          (* callable *)\n+        | Ast.STMT_copy (dst, src) ->\n+            infer_lval (check_expr src) dst\n \n-          | (TYSPEC_callable (a_out_tv, a_in_tvs),\n-             TYSPEC_callable (b_out_tv, b_in_tvs)) ->\n-              unify_tyvars arg_pass_ctx a_out_tv b_out_tv;\n-              let check_in_tv i a_in_tv =\n-                unify_tyvars arg_pass_ctx\n-                  a_in_tv b_in_tvs.(i)\n-              in\n-                Array.iteri check_in_tv a_in_tvs;\n-                TYSPEC_callable (a_out_tv, a_in_tvs)\n-\n-          | (TYSPEC_callable _, TYSPEC_collection _)\n-          | (TYSPEC_callable _, TYSPEC_comparable)\n-          | (TYSPEC_callable _, TYSPEC_plusable)\n-          | (TYSPEC_callable _, TYSPEC_dictionary _)\n-          | (TYSPEC_callable _, TYSPEC_integral)\n-          | (TYSPEC_callable _, TYSPEC_numeric)\n-          | (TYSPEC_callable _, TYSPEC_ordered)\n-          | (TYSPEC_callable _, TYSPEC_app _)\n-          | (TYSPEC_callable _, TYSPEC_record _)\n-          | (TYSPEC_callable _, TYSPEC_tuple _)\n-          | (TYSPEC_callable _, TYSPEC_vector _)\n-          | (TYSPEC_collection _, TYSPEC_callable _)\n-          | (TYSPEC_comparable, TYSPEC_callable _)\n-          | (TYSPEC_plusable, TYSPEC_callable _)\n-          | (TYSPEC_dictionary _, TYSPEC_callable _)\n-          | (TYSPEC_integral, TYSPEC_callable _)\n-          | (TYSPEC_numeric, TYSPEC_callable _)\n-          | (TYSPEC_ordered, TYSPEC_callable _)\n-          | (TYSPEC_app _, TYSPEC_callable _)\n-          | (TYSPEC_record _, TYSPEC_callable _)\n-          | (TYSPEC_tuple _, TYSPEC_callable _)\n-          | (TYSPEC_vector _, TYSPEC_callable _) -> fail ()\n+        | Ast.STMT_copy_binop (dst, binop, src) ->\n+            let ty = check_atom ~deref:true src in\n+            infer_lval ty dst;\n+            demand ty (check_binop binop ty)\n \n-          (* collection *)\n-\n-          | (TYSPEC_collection av, TYSPEC_collection bv) ->\n-              unify_tyvars ucx av bv;\n-              TYSPEC_collection av\n-\n-          | (TYSPEC_collection av, TYSPEC_comparable)\n-          | (TYSPEC_comparable, TYSPEC_collection av) ->\n-              TYSPEC_collection av\n-\n-          | (TYSPEC_collection v, TYSPEC_plusable)\n-          | (TYSPEC_plusable, TYSPEC_collection v) -> TYSPEC_collection v\n-\n-          | (TYSPEC_collection _, TYSPEC_dictionary _)\n-          | (TYSPEC_collection _, TYSPEC_integral)\n-          | (TYSPEC_collection _, TYSPEC_numeric)\n-          | (TYSPEC_collection _, TYSPEC_ordered)\n-          | (TYSPEC_collection _, TYSPEC_app _)\n-          | (TYSPEC_collection _, TYSPEC_record _)\n-          | (TYSPEC_collection _, TYSPEC_tuple _)\n-          | (TYSPEC_dictionary _, TYSPEC_collection _)\n-          | (TYSPEC_integral, TYSPEC_collection _)\n-          | (TYSPEC_numeric, TYSPEC_collection _)\n-          | (TYSPEC_ordered, TYSPEC_collection _)\n-          | (TYSPEC_app _, TYSPEC_collection _)\n-          | (TYSPEC_record _, TYSPEC_collection _)\n-          | (TYSPEC_tuple _, TYSPEC_collection _) -> fail ()\n-\n-          | (TYSPEC_collection av, TYSPEC_vector bv)\n-          | (TYSPEC_vector bv, TYSPEC_collection av) ->\n-              unify_tyvars ucx av bv;\n-              TYSPEC_vector av\n-\n-          (* comparable *)\n-\n-          | (TYSPEC_comparable, TYSPEC_comparable) -> TYSPEC_comparable\n-\n-          | (TYSPEC_comparable, TYSPEC_plusable)\n-          | (TYSPEC_plusable, TYSPEC_comparable) -> TYSPEC_plusable\n-\n-          | (TYSPEC_comparable, TYSPEC_dictionary dict)\n-          | (TYSPEC_dictionary dict, TYSPEC_comparable) ->\n-              TYSPEC_dictionary dict\n-\n-          | (TYSPEC_comparable, TYSPEC_integral)\n-          | (TYSPEC_integral, TYSPEC_comparable) -> TYSPEC_integral\n-\n-          | (TYSPEC_comparable, TYSPEC_numeric)\n-          | (TYSPEC_numeric, TYSPEC_comparable) -> TYSPEC_numeric\n-\n-          | (TYSPEC_comparable, TYSPEC_ordered)\n-          | (TYSPEC_ordered, TYSPEC_comparable) -> TYSPEC_ordered\n-\n-          | (TYSPEC_comparable, TYSPEC_app _)\n-          | (TYSPEC_app _, TYSPEC_comparable) -> fail ()\n-\n-          | (TYSPEC_comparable, TYSPEC_record r)\n-          | (TYSPEC_record r, TYSPEC_comparable) -> TYSPEC_record r\n-\n-          | (TYSPEC_comparable, TYSPEC_tuple t)\n-          | (TYSPEC_tuple t, TYSPEC_comparable) -> TYSPEC_tuple t\n-\n-          | (TYSPEC_comparable, TYSPEC_vector v)\n-          | (TYSPEC_vector v, TYSPEC_comparable) -> TYSPEC_vector v\n-\n-          (* plusable *)\n-\n-          | (TYSPEC_plusable, TYSPEC_plusable) -> TYSPEC_plusable\n-\n-          | (TYSPEC_plusable, TYSPEC_dictionary _)\n-          | (TYSPEC_dictionary _, TYSPEC_plusable) -> fail ()\n-\n-          | (TYSPEC_plusable, TYSPEC_integral)\n-          | (TYSPEC_integral, TYSPEC_plusable) -> TYSPEC_integral\n-\n-          | (TYSPEC_plusable, TYSPEC_numeric)\n-          | (TYSPEC_numeric, TYSPEC_plusable) -> TYSPEC_numeric\n-\n-          | (TYSPEC_plusable, TYSPEC_ordered)\n-          | (TYSPEC_ordered, TYSPEC_plusable) -> TYSPEC_plusable\n-\n-          | (TYSPEC_plusable, TYSPEC_record _)\n-          | (TYSPEC_record _, TYSPEC_plusable) -> fail ()\n-\n-          | (TYSPEC_plusable, TYSPEC_tuple _)\n-          | (TYSPEC_tuple _, TYSPEC_plusable) -> fail ()\n-\n-          | (TYSPEC_plusable, TYSPEC_vector v)\n-          | (TYSPEC_vector v, TYSPEC_plusable) -> TYSPEC_vector v\n-\n-          | (TYSPEC_plusable, TYSPEC_app _)\n-          | (TYSPEC_app _, TYSPEC_plusable) -> fail ()\n+        | Ast.STMT_call (dst, callee, args) ->\n+            infer_lval (check_fn callee args) dst\n \n-          (* dictionary *)\n+        | Ast.STMT_bind (bound, callee, args) ->\n+            let check_arg arg_opt =\n+              match arg_opt with\n+                  None -> None\n+                | Some arg -> Some (check_atom arg)\n+            in\n+            let callee_ty = check_lval callee in\n+            ignore (demand_fn (Array.map check_arg args) callee_ty);\n+            infer_lval callee_ty bound\n+\n+        | Ast.STMT_recv (dst, src) ->\n+            infer_lval (demand_port (check_lval src)) dst\n+\n+        | Ast.STMT_slice (dst, src, slice) ->\n+            let src_ty = check_lval src in\n+            ignore (demand_vec src_ty);\n+            infer_lval src_ty dst;\n+            let check_index index = demand Ast.TY_int (check_atom index) in\n+            Common.may check_index slice.Ast.slice_start;\n+            Common.may check_index slice.Ast.slice_len\n+\n+        | Ast.STMT_while w | Ast.STMT_do_while w ->\n+            let (stmts, expr) = w.Ast.while_lval in\n+            Array.iter check_stmt stmts;\n+            demand Ast.TY_bool (check_expr expr);\n+            check_block w.Ast.while_body\n+\n+        | Ast.STMT_for sf ->\n+            let elem_ty = demand_vec_or_str (check_lval sf.Ast.for_seq) in\n+            infer_slot elem_ty (fst sf.Ast.for_slot).Common.id;\n+            check_block sf.Ast.for_body\n+\n+        | Ast.STMT_for_each sfe ->\n+            let (callee, args) = sfe.Ast.for_each_call in\n+            let elem_ty = check_fn callee args in\n+            infer_slot elem_ty (fst (sfe.Ast.for_each_slot)).Common.id;\n+            check_block sfe.Ast.for_each_head;\n+            check_block sfe.Ast.for_each_body\n+\n+        | Ast.STMT_if si ->\n+            demand Ast.TY_bool (check_expr si.Ast.if_test);\n+            check_block si.Ast.if_then;\n+            Common.may check_block si.Ast.if_else\n+\n+        | Ast.STMT_put _ when not fn_ctx.fnctx_is_iter ->\n+            Common.err None \"'put' may only be used in an iterator function\"\n+\n+        | Ast.STMT_put (Some atom) ->\n+            demand fn_ctx.fnctx_return_type (check_atom atom)\n+\n+        | Ast.STMT_put None -> () (* always well-typed *)\n+\n+        | Ast.STMT_put_each (callee, args) -> ignore (check_fn callee args)\n+\n+        | Ast.STMT_ret (Some atom) ->\n+            if fn_ctx.fnctx_is_iter then\n+              Common.err None\n+                \"iterators can't return values; did you mean 'put'?\"\n+            demand fn_ctx.fnctx_return_type (check_atom atom)\n+\n+        | Ast.STMT_ret None ->\n+            if not fn_ctx.fnctx_is_iter then\n+              demand Ast.TY_nil fn_ctx.fnctx_return_type\n \n-          | (TYSPEC_dictionary da, TYSPEC_dictionary db) ->\n-              TYSPEC_dictionary (merge_dicts da db)\n+        | Ast.STMT_be (callee, args) ->\n+            demand fn_ctx.fnctx_return_type (check_fn callee args)\n \n-          | (TYSPEC_dictionary _, TYSPEC_integral)\n-          | (TYSPEC_dictionary _, TYSPEC_numeric)\n-          | (TYSPEC_dictionary _, TYSPEC_ordered)\n-          | (TYSPEC_dictionary _, TYSPEC_app _)\n-          | (TYSPEC_integral, TYSPEC_dictionary _)\n-          | (TYSPEC_numeric, TYSPEC_dictionary _)\n-          | (TYSPEC_ordered, TYSPEC_dictionary _)\n-          | (TYSPEC_app _, TYSPEC_dictionary _) -> fail ()\n-\n-          | (TYSPEC_dictionary d, TYSPEC_record r)\n-          | (TYSPEC_record r, TYSPEC_dictionary d) ->\n-              TYSPEC_record (merge_dicts d r)\n-\n-          | (TYSPEC_dictionary _, TYSPEC_tuple _)\n-          | (TYSPEC_dictionary _, TYSPEC_vector _)\n-          | (TYSPEC_tuple _, TYSPEC_dictionary _)\n-          | (TYSPEC_vector _, TYSPEC_dictionary _) -> fail ()\n-\n-          (* integral *)\n-\n-          | (TYSPEC_integral, TYSPEC_integral)\n-          | (TYSPEC_integral, TYSPEC_numeric)\n-          | (TYSPEC_integral, TYSPEC_ordered)\n-          | (TYSPEC_numeric, TYSPEC_integral)\n-          | (TYSPEC_ordered, TYSPEC_integral) -> TYSPEC_integral\n+        | Ast.STMT_alt_tag alt_tag ->\n+            let get_pat arm = fst arm.Common.node in\n+            let pats = Array.map get_pat alt_tag.Ast.alt_tag_arms in\n+            let ty = check_lval alt_tag.Ast.alt_tag_lval in\n+            Array.iter (check_pat ty) pats\n \n-          | (TYSPEC_integral, TYSPEC_app _)\n-          | (TYSPEC_integral, TYSPEC_record _)\n-          | (TYSPEC_integral, TYSPEC_tuple _)\n-          | (TYSPEC_integral, TYSPEC_vector _)\n-          | (TYSPEC_app _, TYSPEC_integral)\n-          | (TYSPEC_record _, TYSPEC_integral)\n-          | (TYSPEC_tuple _, TYSPEC_integral)\n-          | (TYSPEC_vector _, TYSPEC_integral) -> fail ()\n+        | Ast.STMT_alt_type _ -> () (* TODO *)\n \n-          (* numeric *)\n+        | Ast.STMT_alt_port _ -> () (* TODO *)\n \n-          | (TYSPEC_numeric, TYSPEC_numeric) -> TYSPEC_numeric\n+        | Ast.STMT_fail | Ast.STMT_yield -> ()  (* always well-typed *)\n \n-          | (TYSPEC_numeric, TYSPEC_ordered)\n-          | (TYSPEC_ordered, TYSPEC_numeric) -> TYSPEC_ordered\n+        | Ast.STMT_join lval -> infer_lval Ast.TY_task lval\n \n-          | (TYSPEC_numeric, TYSPEC_app _)\n-          | (TYSPEC_numeric, TYSPEC_record _)\n-          | (TYSPEC_numeric, TYSPEC_tuple _)\n-          | (TYSPEC_numeric, TYSPEC_vector _)\n-          | (TYSPEC_app _, TYSPEC_numeric)\n-          | (TYSPEC_record _, TYSPEC_numeric)\n-          | (TYSPEC_tuple _, TYSPEC_numeric)\n-          | (TYSPEC_vector _, TYSPEC_numeric) -> fail ()\n-\n-          (* ordered *)\n-\n-          | (TYSPEC_ordered, TYSPEC_ordered) -> TYSPEC_ordered\n-\n-          | (TYSPEC_ordered, TYSPEC_app _)\n-          | (TYSPEC_ordered, TYSPEC_record _)\n-          | (TYSPEC_ordered, TYSPEC_tuple _)\n-          | (TYSPEC_ordered, TYSPEC_vector _)\n-          | (TYSPEC_app _, TYSPEC_ordered)\n-          | (TYSPEC_record _, TYSPEC_ordered)\n-          | (TYSPEC_tuple _, TYSPEC_ordered)\n-          | (TYSPEC_vector _, TYSPEC_ordered) -> fail ()\n-\n-          (* app *)\n-\n-          | (TYSPEC_app (tv_a, args_a),\n-             TYSPEC_app (tv_b, args_b)) ->\n-              if args_a <> args_b\n-              then fail()\n-              else\n-                begin\n-                  unify_tyvars ucx tv_a tv_b;\n-                  TYSPEC_app (tv_a, args_a)\n-                end\n-\n-          | (TYSPEC_app _, TYSPEC_record _)\n-          | (TYSPEC_app _, TYSPEC_tuple _)\n-          | (TYSPEC_app _, TYSPEC_vector _)\n-          | (TYSPEC_record _, TYSPEC_app _)\n-          | (TYSPEC_tuple _, TYSPEC_app _)\n-          | (TYSPEC_vector _, TYSPEC_app _) -> fail ()\n-\n-          (* record *)\n-\n-          | (TYSPEC_record da, TYSPEC_record db) ->\n-              TYSPEC_record (merge_dicts da db)\n-\n-          | (TYSPEC_record _, TYSPEC_tuple _)\n-          | (TYSPEC_record _, TYSPEC_vector _)\n-          | (TYSPEC_tuple _, TYSPEC_record _)\n-          | (TYSPEC_vector _, TYSPEC_record _) -> fail ()\n-\n-          (* tuple *)\n-\n-          | (TYSPEC_tuple tvs_a, TYSPEC_tuple tvs_b) ->\n-              let len_a = Array.length tvs_a in\n-              let len_b = Array.length tvs_b in\n-              let max_len = max len_a len_b in\n-              let init_tuple_elem i =\n-                if i >= len_a\n-                then tvs_b.(i)\n-                else if i >= len_b\n-                then tvs_a.(i)\n-                else begin\n-                  unify_tyvars strict_ctx tvs_a.(i) tvs_b.(i);\n-                  tvs_a.(i)\n-                end\n-              in\n-                TYSPEC_tuple (Array.init max_len init_tuple_elem)\n+        | Ast.STMT_send (chan, value) ->\n+            let value_ty = demand_chan (check_lval chan) in\n+            infer_lval ~mut:Ast.MUT_immutable value_ty value\n \n-          | (TYSPEC_tuple _, TYSPEC_vector _)\n-          | (TYSPEC_vector _, TYSPEC_tuple _) -> fail ()\n+        | Ast.STMT_log _ | Ast.STMT_note _ | Ast.STMT_prove _ ->\n+            () (* always well-typed *)\n \n-          (* vector *)\n+        | Ast.STMT_check (_, calls) -> check_check_calls calls\n \n-          | (TYSPEC_vector av, TYSPEC_vector bv) ->\n-              unify_tyvars strict_ctx av bv;\n-              TYSPEC_vector av\n-      in\n-      let c = ref result in\n-        a := TYSPEC_equiv c;\n-        b := TYSPEC_equiv c\n+        | Ast.STMT_check_expr expr -> demand Ast.TY_bool (check_expr expr)\n \n-    and unify_ty_parametric\n-        (ucx:unify_ctxt)\n-        (ty:Ast.ty)\n-        (tps:Ast.ty_param array)\n-        (tv:tyvar)\n-        : unit =\n-      unify_tyvars ucx (ref (TYSPEC_resolved (tps, ty))) tv\n+        | Ast.STMT_check_if (_, calls, block) ->\n+            check_check_calls calls;\n+            check_block block\n \n-    and unify_ty (ucx:unify_ctxt) (ty:Ast.ty) (tv:tyvar) : unit =\n-      unify_ty_parametric ucx ty [||] tv\n+        | Ast.STMT_block block -> check_block block\n \n+        | Ast.STMT_decl _ -> () (* always well-typed *)\n     in\n \n-    let rec unify_lit (ucx:unify_ctxt) (lit:Ast.lit) (tv:tyvar) : unit =\n-      let ty =\n-        match lit with\n-            Ast.LIT_nil -> Ast.TY_nil\n-          | Ast.LIT_bool _ -> Ast.TY_bool\n-          | Ast.LIT_mach (mty, _, _) -> Ast.TY_mach mty\n-          | Ast.LIT_int (_, _) -> Ast.TY_int\n-          | Ast.LIT_uint (_, _) -> Ast.TY_uint\n-          | Ast.LIT_char _ -> Ast.TY_char\n-      in\n-        unify_ty ucx ty tv\n-\n-    and unify_atom (ucx:unify_ctxt) (atom:Ast.atom) (tv:tyvar) : unit =\n-      match atom with\n-          Ast.ATOM_literal { node = literal; id = _ } ->\n-            unify_lit ucx literal tv\n-        | Ast.ATOM_lval lval ->\n-            unify_lval ucx lval tv\n-\n-    and unify_expr (ucx:unify_ctxt) (expr:Ast.expr) (tv:tyvar) : unit =\n-      match expr with\n-          Ast.EXPR_binary (binop, lhs, rhs) ->\n-            let binop_sig = match binop with\n-                Ast.BINOP_eq\n-              | Ast.BINOP_ne -> BINOPSIG_comp_comp_bool\n-\n-              | Ast.BINOP_lt\n-              | Ast.BINOP_le\n-              | Ast.BINOP_ge\n-              | Ast.BINOP_gt -> BINOPSIG_ord_ord_bool\n-\n-              | Ast.BINOP_or\n-              | Ast.BINOP_and\n-              | Ast.BINOP_xor\n-              | Ast.BINOP_lsl\n-              | Ast.BINOP_lsr\n-              | Ast.BINOP_asr -> BINOPSIG_integ_integ_integ\n-\n-              | Ast.BINOP_add -> BINOPSIG_plus_plus_plus\n-\n-              | Ast.BINOP_sub\n-              | Ast.BINOP_mul\n-              | Ast.BINOP_div\n-              | Ast.BINOP_mod -> BINOPSIG_num_num_num\n-\n-              | Ast.BINOP_send -> bug () \"BINOP_send found in expr\"\n-            in\n-              begin\n-                match binop_sig with\n-                    BINOPSIG_bool_bool_bool ->\n-                      unify_atom rval_ctx lhs\n-                        (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_atom rval_ctx rhs\n-                        (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                      unify_ty rval_ctx Ast.TY_bool tv\n-                  | BINOPSIG_comp_comp_bool ->\n-                      let tv_a = ref TYSPEC_comparable in\n-                        unify_atom rval_ctx lhs tv_a;\n-                        unify_atom rval_ctx rhs tv_a;\n-                        unify_ty rval_ctx Ast.TY_bool tv\n-                  | BINOPSIG_ord_ord_bool ->\n-                      let tv_a = ref TYSPEC_ordered in\n-                        unify_atom rval_ctx lhs tv_a;\n-                        unify_atom rval_ctx rhs tv_a;\n-                        unify_ty rval_ctx Ast.TY_bool tv\n-                  | BINOPSIG_integ_integ_integ ->\n-                      let tv_a = ref TYSPEC_integral in\n-                        unify_atom rval_ctx lhs tv_a;\n-                        unify_atom rval_ctx rhs tv_a;\n-                        unify_tyvars rval_ctx tv tv_a\n-                  | BINOPSIG_num_num_num ->\n-                      let tv_a = ref TYSPEC_numeric in\n-                        unify_atom rval_ctx lhs tv_a;\n-                        unify_atom rval_ctx rhs tv_a;\n-                        unify_tyvars rval_ctx tv tv_a\n-                  | BINOPSIG_plus_plus_plus ->\n-                      let tv_a = ref TYSPEC_plusable in\n-                        unify_atom rval_ctx lhs tv_a;\n-                        unify_atom rval_ctx rhs tv_a;\n-                        unify_tyvars rval_ctx tv tv_a\n-              end\n-        | Ast.EXPR_unary (unop, atom) ->\n-            begin\n-              match unop with\n-                  Ast.UNOP_not ->\n-                    unify_atom rval_ctx atom\n-                      (ref (TYSPEC_resolved ([||], Ast.TY_bool)));\n-                    unify_ty rval_ctx Ast.TY_bool tv\n-                | Ast.UNOP_bitnot ->\n-                    let tv_a = ref TYSPEC_integral in\n-                      unify_atom rval_ctx atom tv_a;\n-                      unify_tyvars rval_ctx tv tv_a\n-                | Ast.UNOP_neg ->\n-                    let tv_a = ref TYSPEC_numeric in\n-                      unify_atom rval_ctx atom tv_a;\n-                      unify_tyvars rval_ctx tv tv_a\n-                | Ast.UNOP_cast t ->\n-                    (* FIXME (issue #84): check cast-validity in\n-                     * post-typecheck pass.  Only some casts make sense.\n-                     *)\n-                    let tv_a = ref TYSPEC_all in\n-                    let t = Hashtbl.find cx.ctxt_all_cast_types t.id in\n-                      unify_atom rval_ctx atom tv_a;\n-                      unify_ty rval_ctx t tv\n-            end\n-        | Ast.EXPR_atom atom -> unify_atom ucx atom tv\n-\n-    and unify_lval' (ucx:unify_ctxt) (lval:Ast.lval) (tv:tyvar) : unit =\n-      let note_args args =\n-        iflog cx (fun _ -> log cx \"noting lval '%a' type arguments: %a\"\n-                    Ast.sprintf_lval lval Ast.sprintf_app_args args);\n-        Hashtbl.add\n-          cx.ctxt_call_lval_params\n-          (lval_base_id lval)\n-          args;\n-      in\n-        match lval with\n-            Ast.LVAL_base nbi ->\n-              let referent = lval_to_referent cx nbi.id in\n-                begin\n-                  match Hashtbl.find cx.ctxt_all_defns referent with\n-                      DEFN_slot slot ->\n-                        iflog cx\n-                          begin\n-                            fun _ ->\n-                              let tv = Hashtbl.find bindings referent in\n-                                log cx \"lval-base slot tyspec for %a = %s\"\n-                                  Ast.sprintf_lval lval (tyspec_to_str (!tv));\n-                          end;\n-                        begin\n-                          match htab_search\n-                            cx.ctxt_auto_deref_lval nbi.id\n-                          with\n-                              None ->\n-                                htab_put cx.ctxt_auto_deref_lval\n-                                  nbi.id ucx.box_ok\n-                            | Some b ->\n-                                (* A given source-occurrence of a name-base\n-                                 * should never change its auto-deref\n-                                 * nature.\n-                                 *)\n-                                assert (b = ucx.box_ok);\n-                        end;\n-                        unify_slot ucx slot (Some referent) tv\n-\n-                    | _ ->\n-                        let spec = (!(Hashtbl.find bindings referent)) in\n-                        let _ =\n-                          iflog cx\n-                            begin\n-                              fun _ ->\n-                                log cx \"lval-base item tyspec for %a = %s\"\n-                                  Ast.sprintf_lval lval (tyspec_to_str spec);\n-                                log cx \"unifying with supplied spec %s\"\n-                                  (tyspec_to_str !tv)\n-                            end\n-                        in\n-                        let tv =\n-                          match nbi.node with\n-                              Ast.BASE_ident _ -> tv\n-                            | Ast.BASE_app (_, args) ->\n-                                note_args args;\n-                                ref (TYSPEC_app (tv, args))\n-                            | _ -> err None \"bad lval / tyspec combination\"\n-                        in\n-                          unify_tyvars ucx (ref spec) tv\n-                end\n-          | Ast.LVAL_ext (base, comp) ->\n-              let base_ts = match comp with\n-                  Ast.COMP_named (Ast.COMP_ident id) ->\n-                    let names = Hashtbl.create 1 in\n-                      Hashtbl.add names id tv;\n-                      TYSPEC_dictionary names\n-\n-                | Ast.COMP_named (Ast.COMP_app (id, args)) ->\n-                    note_args args;\n-                    let tv = ref (TYSPEC_app (tv, args)) in\n-                    let names = Hashtbl.create 1 in\n-                      Hashtbl.add names id tv;\n-                      TYSPEC_dictionary names\n-\n-                | Ast.COMP_named (Ast.COMP_idx i) ->\n-                    let init j = if i = j then tv else ref TYSPEC_all in\n-                      TYSPEC_tuple (Array.init (i + 1) init)\n-\n-                | Ast.COMP_atom atom ->\n-                    unify_atom rval_ctx atom\n-                      (ref (TYSPEC_resolved ([||], Ast.TY_int)));\n-                    TYSPEC_collection tv\n-\n-                | Ast.COMP_deref ->\n-                    TYSPEC_box tv\n-              in\n-              let base_tv = ref base_ts in\n-                unify_lval' { ucx with box_ok = true } base base_tv;\n-                match !(resolve_tyvar base_tv) with\n-                    TYSPEC_resolved (_, ty) ->\n-                      unify_ty ucx (project_type ty comp) tv\n-                  | _ ->\n-                      ()\n-\n-    and unify_lval (ucx:unify_ctxt) (lval:Ast.lval) (tv:tyvar) : unit =\n-      let id = lval_base_id lval in\n-        (* Fetch lval with type components resolved. *)\n-        let lval = Hashtbl.find cx.ctxt_all_lvals id in\n-        iflog cx (fun _ -> log cx\n-                    \"fetched resolved version of lval #%d = %a\"\n-                    (int_of_node id) Ast.sprintf_lval lval);\n-          Hashtbl.add lval_tyvars id tv;\n-          unify_lval' ucx lval tv\n-\n-    in\n-    let gen_atom_tvs atoms =\n-      let gen_atom_tv atom =\n-        let tv = ref TYSPEC_all in\n-          unify_atom strict_ctx atom tv;\n-          tv\n-      in\n-        Array.map gen_atom_tv atoms\n+    let check_stmt' stmt =\n+      try\n+        check_stmt stmt\n+      with Type_error (expected, actual) ->\n+        Common.err\n+          (Some stmt.Common.id)\n+          \"mismatched types: expected %s but found %a\"\n+          expected\n+          Ast.sprintf_ty actual\n     in\n-    let visit_stmt_pre_full (stmt:Ast.stmt) : unit =\n-\n-      let check_callable out_tv callee args =\n-        let in_tvs = gen_atom_tvs args in\n-        let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n-          unify_lval rval_ctx callee callee_tv;\n-      in\n-\n-      let set_auto_deref lv b =\n-        Hashtbl.replace cx.ctxt_auto_deref_lval (lval_base_id lv) b;\n-      in\n-\n-      let ty t = ref (TYSPEC_resolved ([||], t)) in\n-      let any _ = ref TYSPEC_all in\n-\n-      match stmt.node with\n-          Ast.STMT_spawn (dst, _, callee, args) ->\n-            let out_tv = ty Ast.TY_nil in\n-              unify_lval lval_ctx dst (ty Ast.TY_task);\n-              check_callable out_tv callee args\n-\n-        | Ast.STMT_init_rec (dst, fields, Some base) ->\n-            let dct = Hashtbl.create 10 in\n-            let tvrec = ref (TYSPEC_record dct) in\n-            let add_field (ident, _, atom) =\n-              let tv = any() in\n-                unify_atom arg_pass_ctx atom tv;\n-                Hashtbl.add dct ident tv\n-            in\n-              Array.iter add_field fields;\n-              let tvbase = any() in\n-                unify_lval rval_ctx base tvbase;\n-                unify_tyvars rval_ctx tvrec tvbase;\n-                unify_lval init_ctx dst tvrec\n-\n-        | Ast.STMT_init_rec (dst, fields, None) ->\n-            let dct = Hashtbl.create 10 in\n-            let add_field (ident, _, atom) =\n-              let tv = any() in\n-                unify_atom arg_pass_ctx atom tv;\n-                Hashtbl.add dct ident tv\n-            in\n-              Array.iter add_field fields;\n-              unify_lval init_ctx dst (ref (TYSPEC_record dct))\n-\n-        | Ast.STMT_init_tup (dst, members) ->\n-            let member_to_tv (_, atom) =\n-              let tv = any() in\n-                unify_atom arg_pass_ctx atom tv;\n-                tv\n-            in\n-            let member_tvs = Array.map member_to_tv members in\n-              unify_lval init_ctx dst (ref (TYSPEC_tuple member_tvs))\n-\n-        | Ast.STMT_init_vec (dst, _, atoms) ->\n-            let tv = any() in\n-            let unify_with_tv atom = unify_atom arg_pass_ctx atom tv in\n-              Array.iter unify_with_tv atoms;\n-              unify_lval init_ctx dst (ref (TYSPEC_vector tv))\n-\n-        | Ast.STMT_init_str (dst, _) ->\n-            unify_lval init_ctx dst (ty Ast.TY_str)\n-\n-        | Ast.STMT_copy (dst, expr) ->\n-            let tv = any() in\n-              unify_expr arg_pass_ctx expr tv;\n-              unify_lval lval_ctx dst tv\n-\n-        | Ast.STMT_copy_binop (dst, binop, at) ->\n-            let tv = any() in\n-              unify_expr arg_pass_ctx\n-                (Ast.EXPR_binary (binop, Ast.ATOM_lval dst, at)) tv;\n-              (* Force-override the 'auto-deref' judgment that was cached \n-               * in cx.ctxt_auto_deref_lval by preceding unify_expr call.\n-               *)\n-              set_auto_deref dst false;\n-              unify_lval lval_ctx dst tv;\n-\n-        | Ast.STMT_call (out, callee, args) ->\n-            let out_tv = any() in\n-              unify_lval arg_pass_ctx out out_tv;\n-              check_callable out_tv callee args\n-\n-        | Ast.STMT_log atom ->\n-            begin\n-              match atom with\n-                  Ast.ATOM_lval lv ->\n-                    unify_lval rval_ctx lv (any());\n-                    set_auto_deref lv true\n-                | _ -> ()\n-            end\n-\n-        | Ast.STMT_check_expr expr ->\n-            unify_expr rval_ctx expr (ty Ast.TY_bool)\n+    check_stmt'\n+  in\n+  check_stmt\n \n-        | Ast.STMT_check (_, check_calls) ->\n-            let out_tv = ty Ast.TY_bool in\n-              Array.iter\n-                (fun (callee, args) ->\n-                   check_callable out_tv callee args)\n-                check_calls\n+let process_crate (cx:Semant.ctxt) (crate:Ast.crate) : unit =\n+  let path = Stack.create () in\n+  let fn_ctx_stack = Stack.create () in\n \n-        | Ast.STMT_while { Ast.while_lval = (_, expr) }\n-        | Ast.STMT_do_while { Ast.while_lval = (_, expr) } ->\n-            unify_expr rval_ctx expr (ty Ast.TY_bool)\n+  (* Verify that, if main is present, it has the right form. *)\n+  let verify_main (item_id:Common.node_id) : unit =\n+    let path_name = Semant.string_of_name (Semant.path_to_name path) in\n+    if cx.Semant.ctxt_main_name = Some path_name then\n+      try\n+        match Hashtbl.find cx.Semant.ctxt_all_item_types item_id with\n+            Ast.TY_fn ({ Ast.sig_input_slots = [| |] }, _)\n+          | Ast.TY_fn ({ Ast.sig_input_slots = [| {\n+                Ast.slot_mode = Ast.MODE_local;\n+                Ast.slot_ty = Some (Ast.TY_vec Ast.TY_str)\n+              } |] }, _) ->\n+            ()\n+          | _ -> Common.err (Some item_id) \"main fn has bad type signature\"\n+      with Not_found ->\n+        Common.err (Some item_id) \"main item has no type (is it a function?)\"\n+  in\n \n-        | Ast.STMT_if { Ast.if_test = if_test } ->\n-            unify_expr rval_ctx if_test (ty Ast.TY_bool);\n+  let visitor (cx:Semant.ctxt) (inner:Walk.visitor) : Walk.visitor =\n+    let push_fn_ctx (ret_ty:Ast.ty) (is_iter:bool) =\n+      let fn_ctx = { fnctx_return_type = ret_ty; fnctx_is_iter = is_iter } in\n+      Stack.push fn_ctx fn_ctx_stack\n+    in\n \n-        | Ast.STMT_ret atom_opt ->\n+    let visit_mod_item_pre _ _ item =\n+      match item.Common.node.Ast.decl_item with\n+          Ast.MOD_ITEM_fn _ ->\n+            let id = item.Common.id in\n             begin\n-              if fn_is_iter()\n-              then\n-                match atom_opt with\n-                  | None -> ()\n-                  | Some _ -> err None \"Iter returning value\"\n-              else\n-                match atom_opt with\n-                  | None -> unify_ty arg_pass_ctx Ast.TY_nil (retval_tv())\n-                  | Some atom -> unify_atom arg_pass_ctx atom (retval_tv())\n+              match Hashtbl.find cx.Semant.ctxt_all_item_types id with\n+                  Ast.TY_fn (ty_sig, ty_fn_aux) ->\n+                    let ret_ty = ty_sig.Ast.sig_output_slot.Ast.slot_ty in\n+                    let is_iter = ty_fn_aux.Ast.fn_is_iter in\n+                    push_fn_ctx (Common.option_get ret_ty) is_iter\n+                | _ ->\n+                  Common.bug\n+                    ()\n+                    \"Type.visit_mod_item_pre: fn item doesn't have a fn type\"\n             end\n+        | _ -> ()\n+    in\n+    let visit_mod_item_post _ _ item =\n+      verify_main item.Common.id;\n+      match item.Common.node.Ast.decl_item with\n+          Ast.MOD_ITEM_fn _ -> ignore (Stack.pop fn_ctx_stack)\n+        | _ -> ()\n+    in\n \n-        | Ast.STMT_put atom_opt ->\n-            if fn_is_iter()\n-            then\n-              match atom_opt with\n-                | None -> unify_ty arg_pass_ctx Ast.TY_nil (retval_tv())\n-                | Some atom -> unify_atom arg_pass_ctx atom (retval_tv())\n-            else\n-              err None \"Non-iter function with 'put'\"\n-\n-        | Ast.STMT_be (callee, args) ->\n-            check_callable (retval_tv()) callee args\n-\n-        | Ast.STMT_bind (bound, callee, arg_opts) ->\n-            (* FIXME (issue #81): handle binding type parameters\n-             * eventually.\n-             *)\n-            let out_tv = any() in\n-            let residue = ref [] in\n-            let gen_atom_opt_tvs atoms =\n-              let gen_atom_tv atom_opt =\n-                let tv = any() in\n-                  begin\n-                    match atom_opt with\n-                        None -> residue := tv :: (!residue);\n-                      | Some atom -> unify_atom arg_pass_ctx atom tv\n-                  end;\n-                  tv\n-              in\n-                Array.map gen_atom_tv atoms\n-            in\n-\n-            let in_tvs = gen_atom_opt_tvs arg_opts in\n-            let arg_residue_tvs = Array.of_list (List.rev (!residue)) in\n-            let callee_tv = ref (TYSPEC_callable (out_tv, in_tvs)) in\n-            let bound_tv = ref (TYSPEC_callable (out_tv, arg_residue_tvs)) in\n-              unify_lval rval_ctx callee callee_tv;\n-              unify_lval lval_ctx bound bound_tv\n-\n-        | Ast.STMT_for_each fe ->\n-            let out_tv = any() in\n-            let (si, _) = fe.Ast.for_each_slot in\n-            let (callee, args) = fe.Ast.for_each_call in\n-              unify_slot lval_ctx si.node (Some si.id) out_tv;\n-              check_callable out_tv callee args\n-\n-        | Ast.STMT_for fo ->\n-            let mem_tv = ref TYSPEC_all in\n-            let seq_tv = ref (TYSPEC_collection mem_tv) in\n-            let (si, _) = fo.Ast.for_slot in\n-            let seq = fo.Ast.for_seq in\n-              unify_lval rval_ctx seq seq_tv;\n-              unify_slot lval_ctx si.node (Some si.id) mem_tv\n-\n-        | Ast.STMT_alt_tag\n-            { Ast.alt_tag_lval = lval; Ast.alt_tag_arms = arms } ->\n-            let lval_tv = any() in\n-              unify_lval arg_pass_ctx lval lval_tv;\n-              Array.iter (fun _ -> push_pat_tv lval_tv) arms\n-\n-        | Ast.STMT_join lval ->\n-            unify_lval rval_ctx lval (ty Ast.TY_task);\n-\n-        | Ast.STMT_init_box (dst, _, v) ->\n-            let in_tv = any() in\n-            let tv = ref (TYSPEC_mutable (ref (TYSPEC_box in_tv))) in\n-              unify_lval strict_ctx dst tv;\n-              unify_atom rval_ctx v in_tv;\n-\n-        (* FIXME (issue #52): Finish these. *)\n-        (* Fake-typecheck a few comm-related statements for now, just enough\n-         * to supply the auto-deref contexts; we will need new tyspecs for\n-         * port and channel constraints.\n-         *)\n-\n-        | Ast.STMT_recv (dst, port) ->\n-            set_auto_deref dst rval_ctx.box_ok;\n-            set_auto_deref port rval_ctx.box_ok;\n-\n-        | Ast.STMT_send (chan, v) ->\n-            set_auto_deref chan rval_ctx.box_ok;\n-            set_auto_deref v rval_ctx.box_ok;\n-\n-        | Ast.STMT_init_chan (dst, port_opt) ->\n-            begin\n-              match port_opt with\n-                  None -> ()\n-                | Some port -> set_auto_deref port rval_ctx.box_ok\n-            end;\n-            set_auto_deref dst init_ctx.box_ok\n-\n-        | Ast.STMT_init_port dst ->\n-            set_auto_deref dst init_ctx.box_ok\n-\n-\n-        (* Nothing to typecheck on these. *)\n-        | Ast.STMT_block _\n-        | Ast.STMT_decl _\n-        | Ast.STMT_yield\n-        | Ast.STMT_fail -> ()\n-\n-        (* Unimplemented. *)\n-        | Ast.STMT_check_if _\n-        | Ast.STMT_prove _\n-        | Ast.STMT_note _\n-        | Ast.STMT_alt_port _\n-        | Ast.STMT_alt_type _\n-        | Ast.STMT_put_each _\n-        | Ast.STMT_slice _ -> err None \"Unimplemented typecheck for stmt\"\n+    let visit_obj_fn_pre _ _ fn =\n+      let fn = fn.Common.node in\n+      let ret_ty = fn.Ast.fn_output_slot.Common.node.Ast.slot_ty in\n+      push_fn_ctx (Common.option_get ret_ty) fn.Ast.fn_aux.Ast.fn_is_iter\n     in\n+    let visit_obj_fn_post _ _ _ = ignore (Stack.pop fn_ctx_stack) in\n \n+    let visit_obj_drop_pre _ _ = push_fn_ctx Ast.TY_nil false in\n+    let visit_obj_drop_post _ _ = ignore (Stack.pop fn_ctx_stack) in\n+\n+    (* TODO: make sure you can't fall off the end of a function if it doesn't\n+     * return void *)\n     let visit_stmt_pre (stmt:Ast.stmt) : unit =\n       try\n         log cx \"\";\n         log cx \"typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n         log cx \"\";\n-        visit_stmt_pre_full stmt;\n-        (* \n-         * Reset any item-parameters that were resolved to types\n-         * during inference for this statement.\n-         *)\n-        Hashtbl.iter\n-          (fun _ params -> Array.iter (fun tv -> tv := TYSPEC_all) params)\n-          item_params;\n+        check_stmt cx (Stack.top fn_ctx_stack) stmt;\n         log cx \"finished typechecking stmt: %a\" Ast.sprintf_stmt stmt;\n-      with\n-          Semant_err (None, msg) ->\n-            raise (Semant_err ((Some stmt.id), msg))\n-    in\n-\n-    let enter_fn fn retspec =\n-      push_fn fn;\n-      let out = fn.Ast.fn_output_slot in\n-        push_retval_tv (ref retspec);\n-        unify_slot arg_pass_ctx out.node (Some out.id) (retval_tv())\n-    in\n-\n-    let leave_fn _ =\n-      pop_retval_tv ();\n-      pop_fn ();\n-    in\n-\n-    let visit_obj_fn_pre obj ident fn =\n-      enter_fn fn.node TYSPEC_all;\n-      inner.Walk.visit_obj_fn_pre obj ident fn\n-    in\n-\n-    let visit_obj_fn_post obj ident fn =\n-      inner.Walk.visit_obj_fn_post obj ident fn;\n-      leave_fn ();\n-    in\n-\n-    let visit_mod_item_pre n p mod_item =\n-      begin\n-        try\n-          match mod_item.node.Ast.decl_item with\n-              Ast.MOD_ITEM_fn fn ->\n-                enter_fn fn TYSPEC_all\n-\n-            | _ -> ()\n-        with Semant_err (None, msg) ->\n-          raise (Semant_err ((Some mod_item.id), msg))\n-      end;\n-      inner.Walk.visit_mod_item_pre n p mod_item\n+      with Common.Semant_err (None, msg) ->\n+        raise (Common.Semant_err ((Some stmt.Common.id), msg))\n     in\n \n-    let path_name (_:unit) : string =\n-      string_of_name (path_to_name path)\n-    in\n-\n-    let visit_mod_item_post n p mod_item =\n-      inner.Walk.visit_mod_item_post n p mod_item;\n-      match mod_item.node.Ast.decl_item with\n-\n-        | Ast.MOD_ITEM_fn _ ->\n-            leave_fn ();\n-            if (Some (path_name())) = cx.ctxt_main_name\n-            then\n-              begin\n-                match Hashtbl.find cx.ctxt_all_item_types mod_item.id with\n-                    Ast.TY_fn (tsig, _) ->\n-                      begin\n-                        let vec_str =\n-                          local_slot (Ast.TY_vec Ast.TY_str)\n-                        in\n-                          match tsig.Ast.sig_input_slots with\n-                              [| |] -> ()\n-                            | [| vs |] when vs = vec_str -> ()\n-                            | _ -> err (Some mod_item.id)\n-                                \"main fn has bad type signature\"\n-                      end\n-                  | _ ->\n-                      err (Some mod_item.id) \"main item is not a function\"\n-              end\n-        | _ -> ()\n-    in\n-\n-    (*\n-     * Tag patterns give us the type of every sub-pattern in the tag tuple, so\n-     * we can \"expect\" those types by pushing them on a stack.  Checking a\n-     * pattern therefore involves seeing that it matches the \"expected\" type,\n-     * and in turn setting any expectations for the inner descent.\n-     *)\n-    let visit_pat_pre (pat:Ast.pat) : unit =\n-      let expected = pat_tv() in\n-        match pat with\n-            Ast.PAT_lit lit -> unify_lit strict_ctx lit expected\n-\n-          | Ast.PAT_tag (lval, _) ->\n-              let expect ty =\n-                let tv = ref TYSPEC_all in\n-                  unify_ty strict_ctx ty tv;\n-                  push_pat_tv tv;\n-              in\n-\n-              let lval_nm = lval_to_name lval in\n-\n-              (* The lval here is our tag constructor, which we've already\n-               * resolved (in Resolve) to have a the actual tag constructor\n-               * function item as its referent.  It should hence unify\n-               * exactly to that function type, rebuilt under any latent type\n-               * parameters applied in the lval. *)\n-              let lval_tv = ref TYSPEC_all in\n-                unify_lval strict_ctx lval lval_tv;\n-                let tag_ctor_ty =\n-                  match !(resolve_tyvar lval_tv) with\n-                      TYSPEC_resolved (_, ty) -> ty\n-                    | _ ->\n-                        bug () \"tag constructor is not a fully resolved type.\"\n-                in\n-\n-                let tag_ty = fn_output_ty tag_ctor_ty in\n-                let tag_ty_tup = tag_or_iso_ty_tup_by_name tag_ty lval_nm in\n-\n-                let tag_tv = ref TYSPEC_all in\n-                  unify_ty strict_ctx tag_ty tag_tv;\n-                  unify_tyvars strict_ctx expected tag_tv;\n-                  List.iter expect\n-                    (List.rev (Array.to_list tag_ty_tup));\n-\n-          | Ast.PAT_slot (sloti, _) ->\n-              unify_slot lval_ctx sloti.node (Some sloti.id) expected\n-\n-          | Ast.PAT_wild -> ()\n-    in\n-\n-    let visit_pat_post (_:Ast.pat) : unit =\n-      pop_pat_tv()\n+    let visit_crate_post _ : unit =\n+      (* Fill in the autoderef info for any lvals we didn't get to. *)\n+      let fill lval_id _ =\n+        if not (Hashtbl.mem cx.Semant.ctxt_auto_deref_lval lval_id) then\n+          Hashtbl.add cx.Semant.ctxt_auto_deref_lval lval_id false\n+      in\n+      Hashtbl.iter fill cx.Semant.ctxt_all_lvals\n     in\n \n-      {\n-        inner with\n-          Walk.visit_mod_item_pre = visit_mod_item_pre;\n-          Walk.visit_mod_item_post = visit_mod_item_post;\n-          Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n-          Walk.visit_obj_fn_post = visit_obj_fn_post;\n-          Walk.visit_stmt_pre = visit_stmt_pre;\n-          Walk.visit_pat_pre = visit_pat_pre;\n-          Walk.visit_pat_post = visit_pat_post;\n-      }\n-\n+    {\n+      inner with\n+        Walk.visit_stmt_pre = visit_stmt_pre;\n+        Walk.visit_mod_item_pre = visit_mod_item_pre;\n+        Walk.visit_mod_item_post = visit_mod_item_post;\n+        Walk.visit_obj_fn_pre = visit_obj_fn_pre;\n+        Walk.visit_obj_fn_post = visit_obj_fn_post;\n+        Walk.visit_obj_drop_pre = visit_obj_drop_pre;\n+        Walk.visit_obj_drop_post = visit_obj_drop_post;\n+        Walk.visit_crate_post = visit_crate_post\n+    }\n   in\n-    try\n-      let auto_queue = Queue.create () in\n-\n-      let init_slot_tyvar id defn =\n-        match defn with\n-            DEFN_slot { Ast.slot_mode = _; Ast.slot_ty = None } ->\n-              Queue.add id auto_queue;\n-              Hashtbl.add bindings id (ref (TYSPEC_mutable (ref TYSPEC_all)))\n-          | DEFN_slot { Ast.slot_mode = _; Ast.slot_ty = Some ty } ->\n-              let _ = iflog cx (fun _ -> log cx \"initial slot #%d type: %a\"\n-                                  (int_of_node id) Ast.sprintf_ty ty)\n-              in\n-                Hashtbl.add bindings id (ref (TYSPEC_resolved ([||], ty)))\n-          | _ -> ()\n-      in\n-\n-      let init_item_tyvar id ty =\n-        let _ = iflog cx (fun _ -> log cx \"initial item #%d type: %a\"\n-                            (int_of_node id) Ast.sprintf_ty ty)\n-        in\n-        let params =\n-          match Hashtbl.find cx.ctxt_all_defns id with\n-              DEFN_item i -> Array.map (fun p -> p.node) i.Ast.decl_params\n-            | DEFN_obj_fn _ -> [| |]\n-            | DEFN_obj_drop _ -> [| |]\n-            | DEFN_loop_body _ -> [| |]\n-            | _ -> err (Some id) \"expected item defn for item tyvar\"\n-        in\n-        let spec = TYSPEC_resolved (params, ty) in\n-          Hashtbl.add bindings id (ref spec)\n-      in\n-\n-      let init_mod_dict id defn =\n-        let rec tv_of_item id item =\n-          match item.Ast.decl_item with\n-              Ast.MOD_ITEM_mod (_, items) ->\n-                if Hashtbl.mem bindings id\n-                then Hashtbl.find bindings id\n-                else\n-                  let dict = htab_map items\n-                    (fun i item -> (i, tv_of_item item.id item.node))\n-                  in\n-                  let spec = TYSPEC_dictionary dict in\n-                  let tv = ref spec in\n-                    Hashtbl.add bindings id tv;\n-                    tv\n-            | _ ->\n-                Hashtbl.find bindings id\n-        in\n-          match defn with\n-              DEFN_item ({ Ast.decl_item = Ast.MOD_ITEM_mod _ } as item) ->\n-                ignore (tv_of_item id item)\n-            | _ -> ()\n-      in\n-        Hashtbl.iter init_slot_tyvar cx.ctxt_all_defns;\n-        Hashtbl.iter init_item_tyvar cx.ctxt_all_item_types;\n-        Hashtbl.iter init_mod_dict cx.ctxt_all_defns;\n-        Walk.walk_crate\n-          (Walk.path_managing_visitor path\n-             (mod_item_logging_visitor cx\n-                cx.ctxt_sess.Session.sess_log_type log 0 path\n-                (visitor cx Walk.empty_visitor)))\n-          crate;\n-\n-        let update_auto_tyvar id ty =\n-          let defn = Hashtbl.find cx.ctxt_all_defns id in\n-            match defn with\n-                DEFN_slot slot_defn ->\n-                  begin\n-                    match slot_defn.Ast.slot_ty with\n-                        Some _ -> ()\n-                      | None ->\n-                          log cx \"setting auto slot #%d = %a to type %a\"\n-                            (int_of_node id)\n-                            Ast.sprintf_slot_key\n-                            (Hashtbl.find cx.ctxt_slot_keys id)\n-                            Ast.sprintf_ty ty;\n-                          Hashtbl.replace cx.ctxt_all_defns id\n-                            (DEFN_slot { slot_defn with\n-                                           Ast.slot_ty = Some ty })\n-                  end\n-              | _ -> bug () \"check_auto_tyvar: no slot defn\"\n-        in\n-\n-        let rec get_resolved_ty tv id =\n-          let ts = !(resolve_tyvar tv) in\n-            match ts with\n-                TYSPEC_resolved ([||], ty) -> ty\n-              | TYSPEC_box tv ->\n-                  Ast.TY_box (get_resolved_ty tv id)\n-\n-              | TYSPEC_mutable tv ->\n-                  Ast.TY_mutable (get_resolved_ty tv id)\n-\n-              | TYSPEC_vector tv ->\n-                  Ast.TY_vec (get_resolved_ty tv id)\n-\n-              | TYSPEC_tuple tvs ->\n-                  Ast.TY_tup\n-                    (Array.map\n-                       (fun tv -> get_resolved_ty tv id) tvs)\n-\n-              | _ -> err (Some id)\n-                  \"unresolved type %s (%d)\"\n-                    (tyspec_to_str ts)\n-                    (int_of_node id)\n-        in\n-\n-        let check_auto_tyvar id =\n-          let tv = Hashtbl.find bindings id in\n-          let ty = get_resolved_ty tv id in\n-            update_auto_tyvar id ty\n-        in\n-\n-        let record_lval_ty id tv =\n-          let ty = get_resolved_ty tv id in\n-          let _ =\n-            iflog cx\n-              (fun _ ->\n-                 log cx \"recording resolved lval #%d = %a type %a\"\n-                   (int_of_node id)\n-                   Ast.sprintf_lval (Hashtbl.find cx.ctxt_all_lvals id)\n-                   Ast.sprintf_ty ty)\n-          in\n-            Hashtbl.add cx.ctxt_all_lval_types id ty\n-        in\n \n-          Queue.iter check_auto_tyvar auto_queue;\n-          Hashtbl.iter record_lval_ty lval_tyvars;\n-    with Semant_err (ido, str) -> report_err cx ido str\n-;;\n+  try\n+    Walk.walk_crate\n+      (Walk.path_managing_visitor path\n+        (Semant.mod_item_logging_visitor\n+          cx\n+          cx.Semant.ctxt_sess.Session.sess_log_type log 0 path\n+          (visitor cx Walk.empty_visitor)))\n+      crate\n+  with Common.Semant_err (ido, str) -> Semant.report_err cx ido str;\n \n (*\n  * Local Variables:"}, {"sha": "3271b644d231dcdacca30e78986fb09484752999", "filename": "src/boot/util/common.ml", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Fboot%2Futil%2Fcommon.ml", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Fboot%2Futil%2Fcommon.ml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fboot%2Futil%2Fcommon.ml?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -341,6 +341,16 @@ let bool_of_option x =\n       Some _ -> true\n     | None -> false\n \n+let may f x =\n+  match x with\n+      Some x' -> f x'\n+    | None -> ()\n+\n+let option_get x =\n+  match x with\n+      Some x -> x\n+    | None -> raise Not_found\n+\n (*\n  * Auxiliary stack functions.\n  *)"}, {"sha": "decb09f8e083c735a0ae36925c57e79ed0296d15", "filename": "src/lib/_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Flib%2F_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Flib%2F_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2F_vec.rs?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -80,7 +80,7 @@ fn map[T,U](&op[T,U] f, &vec[T] v) -> vec[U] {\n   // but this does not work presently.\n   let vec[U] u = vec();\n   for (T ve in v) {\n-    u += vec(f[T,U](ve));\n+    u += vec(f(ve));\n   }\n   ret u;\n }"}, {"sha": "51f0707c6be9ef04bfecf0cd90c823cf29add6af", "filename": "src/lib/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Flib%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Flib%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Futil.rs?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -5,7 +5,7 @@ type operator[T, U] = fn(&T) -> U;\n fn option_map[T, U](&operator[T, U] f, &option[T] opt) -> option[U] {\n   alt (opt) {\n     case (some[T](x)) {\n-      ret some[U](f[T, U](x));\n+      ret some[U](f(x));\n     }\n     case (none[T]()) {\n       ret none[U]();"}, {"sha": "9f704bc35b0d1a395b10097135f5c1e5b348c8fa", "filename": "src/test/compile-fail/put-in-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fput-in-fn.rs?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -1,8 +1,8 @@\n-// error-pattern: Non-iter function\n+// error-pattern: iterator function\n \n fn f() -> int {\n   put 10;\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c9ed2ae390a1a241ddd3c151f4f6b8e4c36d0a6c", "filename": "src/test/run-pass/acyclic-unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c96f0bf7386081d21b00af4fa7fcf73ac8d79575/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Facyclic-unwind.rs?ref=c96f0bf7386081d21b00af4fa7fcf73ac8d79575", "patch": "@@ -5,7 +5,7 @@ io fn f(chan[int] c)\n   type t = tup(int,int,int);\n \n   // Allocate a box.\n-  let @t x = tup(1,2,3);\n+  let @t x = @tup(1,2,3);\n \n   // Signal parent that we've allocated a box.\n   c <| 1;"}]}