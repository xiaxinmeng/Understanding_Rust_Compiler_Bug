{"sha": "425455b18e2278ff62841dabc305cf6a013af09d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNTQ1NWIxOGUyMjc4ZmY2Mjg0MWRhYmMzMDVjZjZhMDEzYWYwOWQ=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-12T03:24:19Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-05-12T03:24:19Z"}, "message": "Rollup merge of #25292 - steveklabnik:stack_and_heap, r=nikomatsakis\n\nI think someday I'd like to make these drawings rather than text, but for now, this will have to be good enough.", "tree": {"sha": "84eb74d6825cb66ec8007f5a2d320e529c1046aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84eb74d6825cb66ec8007f5a2d320e529c1046aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/425455b18e2278ff62841dabc305cf6a013af09d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/425455b18e2278ff62841dabc305cf6a013af09d", "html_url": "https://github.com/rust-lang/rust/commit/425455b18e2278ff62841dabc305cf6a013af09d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/425455b18e2278ff62841dabc305cf6a013af09d/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abb97af508c053111318bfd37b5508db86c5c9ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/abb97af508c053111318bfd37b5508db86c5c9ba", "html_url": "https://github.com/rust-lang/rust/commit/abb97af508c053111318bfd37b5508db86c5c9ba"}, {"sha": "e66653bee52b87ada8d591b13b915e5ed2c86d5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/e66653bee52b87ada8d591b13b915e5ed2c86d5a", "html_url": "https://github.com/rust-lang/rust/commit/e66653bee52b87ada8d591b13b915e5ed2c86d5a"}], "stats": {"total": 569, "additions": 568, "deletions": 1}, "files": [{"sha": "7b1cd7dc8093b3646730023c36a5a12c5e1570c5", "filename": "src/doc/trpl/the-stack-and-the-heap.md", "status": "modified", "additions": 568, "deletions": 1, "changes": 569, "blob_url": "https://github.com/rust-lang/rust/blob/425455b18e2278ff62841dabc305cf6a013af09d/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "raw_url": "https://github.com/rust-lang/rust/raw/425455b18e2278ff62841dabc305cf6a013af09d/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fthe-stack-and-the-heap.md?ref=425455b18e2278ff62841dabc305cf6a013af09d", "patch": "@@ -1,3 +1,570 @@\n % The Stack and the Heap\n \n-Coming Soon\n+As a systems language, Rust operates at a low level. If you\u2019re coming from a\n+high-level language, there are some aspects of systems programming that you may\n+not be familiar with. The most important one is how memory works, with a stack\n+and a heap. If you\u2019re familiar with how C-like languages use stack allocation,\n+this chapter will be a refresher. If you\u2019re not, you\u2019ll learn about this more\n+general concept, but with a Rust-y focus.\n+\n+# Memory management\n+\n+These two terms are about memory management. The stack and the heap are\n+abstractions that help you determine when to allocate and deallocate memory.\n+\n+Here\u2019s a high-level comparison:\n+\n+The stack is very fast, and is where memory is allocated in Rust by default.\n+But the allocation is local to a function call, and is limited in size. The\n+heap, on the other hand, is slower, and is explicitly allocated by your\n+program. But it\u2019s effectively unlimited in size, and is globally accessible.\n+\n+# The Stack\n+\n+Let\u2019s talk about this Rust program:\n+\n+```rust\n+fn main() {\n+    let x = 42;\n+}\n+```\n+\n+This program has one variable binding, `x`. This memory needs to be allocated\n+from somewhere. Rust \u2018stack allocates\u2019 by default, which means that basic\n+values \u2018go on the stack\u2019. What does that mean?\n+\n+Well, when a function gets called, some memory gets allocated for all of its\n+local variables and some other information. This is called a \u2018stack frame\u2019, and\n+for the purpose of this tutorial, we\u2019re going to ignore the extra information\n+and just consider the local variables we\u2019re allocating. So in this case, when\n+`main()` is run, we\u2019ll allocate a single 32-bit integer for our stack frame.\n+This is automatically handled for you, as you can see, we didn\u2019t have to write\n+any special Rust code or anything.\n+\n+When the function is over, its stack frame gets deallocated. This happens\n+automatically, we didn\u2019t have to do anything special here.\n+\n+That\u2019s all there is for this simple program. The key thing to understand here\n+is that stack allocation is very, very fast. Since we know all the local\n+variables we have ahead of time, we can grab the memory all at once. And since\n+we\u2019ll throw them all away at the same time as well, we can get rid of it very\n+fast too.\n+\n+The downside is that we can\u2019t keep values around if we need them for longer\n+than a single function. We also haven\u2019t talked about what that name, \u2018stack\u2019\n+means. To do that, we need a slightly more complicated example:\n+\n+```rust\n+fn foo() {\n+    let y = 5;\n+    let z = 100;\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+This program has three variables total: two in `foo()`, one in `main()`. Just\n+as before, when `main()` is called, a single integer is allocated for its stack\n+frame. But before we can show what happens when `foo()` is called, we need to\n+visualize what\u2019s going on with memory. Your operating system presents a view of\n+memory to your program that\u2019s pretty simple: a huge list of addresses, from 0\n+to a large number, representing how much RAM your computer has. For example, if\n+you have a gigabyte of RAM, your addresses go from `0` to `1,073,741,824`. That\n+number comes from 2<sup>30</sup>, the number of bytes in a gigabyte.\n+\n+This memory is kind of like a giant array: addresses start at zero and go\n+up to the final number. So here\u2019s a diagram of our first stack frame:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+We\u2019ve got `x` located at address `0`, with the value `42`.\n+\n+When `foo()` is called, a new stack frame is allocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 2       | z    | 100   |\n+| 1       | y    | 5     |\n+| 0       | x    | 42    |\n+\n+Because `0` was taken by the first frame, `1` and `2` are used for `foo()`\u2019s\n+stack frame. It grows upward, the more functions we call.\n+\n+\n+There\u2019s some important things we have to take note of here. The numbers 0, 1,\n+and 2 are all solely for illustrative purposes, and bear no relationship to the\n+actual numbers the computer will actually use. In particular, the series of\n+addresses are in reality going to be separated by some number of bytes that\n+separate each address, and that separation may even exceed the size of the\n+value being stored.\n+\n+After `foo()` is over, its frame is deallocated:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then, after `main()`, even this last value goes away. Easy!\n+\n+It\u2019s called a \u2018stack\u2019 because it works like a stack of dinner plates: the first\n+plate you put down is the last plate to pick back up. Stacks are sometimes\n+called \u2018last in, first out queues\u2019 for this reason, as the last value you put\n+on the stack is the first one you retrieve from it.\n+\n+Let\u2019s try a three-deep example:\n+\n+```rust\n+fn bar() {\n+    let i = 6;\n+}\n+\n+fn foo() {\n+    let a = 5;\n+    let b = 100;\n+    let c = 1;\n+\n+    bar();\n+}\n+\n+fn main() {\n+    let x = 42;\n+\n+    foo();\n+}\n+```\n+\n+Okay, first, we call `main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+Next up, `main()` calls `foo()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` calls `bar()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 4       | i    | 6     |\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+Whew! Our stack is growing tall.\n+\n+After `bar()` is over, its frame is deallocated, leaving just `foo()` and\n+`main()`:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | c    | 1     |\n+| 2       | b    | 100   |\n+| 1       | a    | 5     |\n+| 0       | x    | 42    |\n+\n+And then `foo()` ends, leaving just `main()`\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 0       | x    | 42    |\n+\n+And then we\u2019re done. Getting the hang of it? It\u2019s like piling up dishes: you\n+add to the top, you take away from the top.\n+\n+# The Heap\n+\n+Now, this works pretty well, but not everything can work like this. Sometimes,\n+you need to pass some memory between different functions, or keep it alive for\n+longer than a single function\u2019s execution. For this, we can use the heap.\n+\n+In Rust, you can allocate memory on the heap with the [`Box<T>` type][box].\n+Here\u2019s an example:\n+\n+```rust\n+fn main() {\n+    let x = Box::new(5);\n+    let y = 42;\n+}\n+```\n+\n+[box]: ../std/boxed/index.html\n+\n+Here\u2019s what happens in memory when `main()` is called:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+We allocate space for two variables on the stack. `y` is `42`, as it always has\n+been, but what about `x`? Well, `x` is a `Box<i32>`, and boxes allocate memory\n+on the heap. The actual value of the box is a structure which has a pointer to\n+\u2018the heap\u2019. When we start executing the function, and `Box::new()` is called,\n+it allocates some memory for the heap, and puts `5` there. The memory now looks\n+like this:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 5              |\n+| ...             | ...  | ...            |\n+| 1               | y    | 42             |\n+| 0               | x    | 2<sup>30</sup> |\n+\n+We have 2<sup>30</sup> in our hypothetical computer with 1GB of RAM. And since\n+our stack grows from zero, the easiest place to allocate memory is from the\n+other end. So our first value is at the highest place in memory. And the value\n+of the struct at `x` has a [raw pointer][rawpointer] to the place we\u2019ve\n+allocated on the heap, so the value of `x` is 2<sup>30</sup>, the memory\n+location we\u2019ve asked for.\n+\n+[rawpointer]: raw-pointers.html\n+\n+We haven\u2019t really talked too much about what it actually means to allocate and\n+deallocate memory in these contexts. Getting into very deep detail is out of\n+the scope of this tutorial, but what\u2019s important to point out here is that\n+the heap isn\u2019t just a stack that grows from the opposite end. We\u2019ll have an\n+example of this later in the book, but because the heap can be allocated and\n+freed in any order, it can end up with \u2018holes\u2019. Here\u2019s a diagram of the memory\n+layout of a program which has been running for a while now:\n+\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+| 2<sup>30</sup>       |      | 5                    |\n+| (2<sup>30</sup>) - 1 |      |                      |\n+| (2<sup>30</sup>) - 2 |      |                      |\n+| (2<sup>30</sup>) - 3 |      | 42                   |\n+| ...                  | ...  | ...                  |\n+| 3                    | y    | (2<sup>30</sup>) - 3 |\n+| 2                    | y    | 42                   |\n+| 1                    | y    | 42                   |\n+| 0                    | x    | 2<sup>30</sup>       |\n+\n+In this case, we\u2019ve allocated four things on the heap, but deallocated two of\n+them. There\u2019s a gap between 2<sup>30</sup> and (2<sup>30</sup>) - 3 which isn\u2019t\n+currently being used. The specific details of how and why this happens depends\n+on what kind of strategy you use to manage the heap. Different programs can use\n+different \u2018memory allocators\u2019, which are libraries that manage this for you.\n+Rust programs use [jemalloc][jemalloc] for this purpose.\n+\n+[jemalloc]: http://www.canonware.com/jemalloc/\n+\n+Anyway, back to our example. Since this memory is on the heap, it can stay\n+alive longer than the function which allocates the box. In this case, however,\n+it doesn\u2019t.[^moving] When the function is over, we need to free the stack frame\n+for `main()`. `Box<T>`, though, has a trick up its sleve: [Drop][drop]. The\n+implementation of `Drop` for `Box` deallocates the memory that was allocated\n+when it was created. Great! So when `x` goes away, it first frees the memory\n+allocated on the heap:\n+\n+| Address | Name | Value  |\n++---------+------+--------+\n+| 1       | y    | 42     |\n+| 0       | x    | ?????? |\n+\n+[drop]: drop.html\n+[moving]: We can make the memory live longer by transferring ownership,\n+          sometimes called \u2018moving out of the box\u2019. More complex examples will\n+          be covered later.\n+\n+\n+And then the stack frame goes away, freeing all of our memory.\n+\n+# Arguments and borrowing\n+\n+We\u2019ve got some basic examples with the stack and the heap going, but what about\n+function arguments and borrowing? Here\u2019s a small Rust program:\n+\n+```rust\n+fn foo(i: &i32) {\n+    let z = 42;\n+}\n+\n+fn main() {\n+    let x = 5;\n+    let y = &x;\n+\n+    foo(y);\n+}\n+```\n+\n+When we enter `main()`, memory looks like this:\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+`x` is a plain old `5`, and `y` is a reference to `x`. So its value is the\n+memory location that `x` lives at, which in this case is `0`.\n+\n+What about when we call `foo()`, passing `y` as an argument?\n+\n+| Address | Name | Value |\n++---------+------+-------+\n+| 3       | z    | 42    |\n+| 2       | i    | 0     |\n+| 1       | y    | 0     |\n+| 0       | x    | 5     |\n+\n+Stack frames aren\u2019t just for local bindings, they\u2019re for arguments too. So in\n+this case, we need to have both `i`, our argument, and `z`, our local variable\n+binding. `i` is a copy of the argument, `y`. Since `y`\u2019s value is `0`, so is\n+`i`\u2019s.\n+\n+This is one reason why borrowing a variable doesn\u2019t deallocate any memory: the\n+value of a reference is just a pointer to a memory location. If we got rid of\n+the underlying memory, things wouldn\u2019t work very well.\n+\n+# A complex example\n+\n+Okay, let\u2019s go through this complex program step-by-step:\n+\n+```rust\n+fn foo(x: &i32) {\n+    let y = 10;\n+    let z = &y;\n+\n+    baz(z);\n+    bar(x, z);\n+}\n+\n+fn bar(a: &i32, b: &i32) {\n+    let c = 5;\n+    let d = Box::new(5);\n+    let e = &d;\n+\n+    baz(e);\n+}\n+\n+fn baz(f: &i32) {\n+    let g = 100;\n+}\n+\n+fn main() {\n+    let h = 3;\n+    let i = Box::new(20);\n+    let j = &h;\n+\n+    foo(j);\n+}\n+```\n+\n+First, we call `main()`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We allocate memory for `j`, `i`, and `h`. `i` is on the heap, and so has a\n+value pointing there.\n+\n+Next, at the end of `main()`, `foo()` gets called:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Space gets allocated for `x`, `y`, and `z`. The argument `x` has the same value\n+as `j`, since that\u2019s what we passed it in. It\u2019s a pointer to the `0` address,\n+since `j` points at `h`.\n+\n+Next, `foo()` calls `baz()`, passing `z`:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 7               | g    | 100            |\n+| 6               | f    | 4              |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+We\u2019ve allocated memory for `f` and `g`. `baz()` is very short, so when it\u2019s\n+over, we get rid of its stack frame:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+| 2<sup>30</sup>  |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+Next, `foo()` calls `bar()` with `x` and `z`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+We end up allocating another value on the heap, and so we have to subtract one\n+from 2<sup>30</sup>. It\u2019s easier to just write that than `1,073,741,823`. In any\n+case, we set up the variables as usual.\n+\n+At the end of `bar()`, it calls `baz()`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 12                   | g    | 100                  |\n+| 11                   | f    | 4                    |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+With this, we\u2019re at our deepest point! Whew! Congrats for following along this\n+far.\n+\n+After `baz()` is over, we get rid of `f` and `g`:\n+\n+| Address              | Name | Value                |\n++----------------------+------+----------------------+\n+|  2<sup>30</sup>      |      | 20                   |\n+| (2<sup>30</sup>) - 1 |      | 5                    |\n+| ...                  | ...  | ...                  |\n+| 10                   | e    | 4                    |\n+| 9                    | d    | (2<sup>30</sup>) - 1 |\n+| 8                    | c    | 5                    |\n+| 7                    | b    | 4                    |\n+| 6                    | a    | 0                    |\n+| 5                    | z    | 4                    |\n+| 4                    | y    | 10                   |\n+| 3                    | x    | 0                    |\n+| 2                    | j    | 0                    |\n+| 1                    | i    | 2<sup>30</sup>       |\n+| 0                    | h    | 3                    |\n+\n+Next, we return from `bar()`. `d` in this case is a `Box<T>`, so it also frees\n+what it points to: (2<sup>30</sup>) - 1.\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 5               | z    | 4              |\n+| 4               | y    | 10             |\n+| 3               | x    | 0              |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And after that, `foo()` returns:\n+\n+| Address         | Name | Value          |\n++-----------------+------+----------------+\n+|  2<sup>30</sup> |      | 20             |\n+| ...             | ...  | ...            |\n+| 2               | j    | 0              |\n+| 1               | i    | 2<sup>30</sup> |\n+| 0               | h    | 3              |\n+\n+And then, finally, `main()`, which cleans the rest up. When `i` is `Drop`ped,\n+it will clean up the last of the heap too.\n+\n+# What do other languages do?\n+\n+Most languages with a garbage collector heap-allocate by default. This means\n+that every value is boxed. There are a number of reasons why this is done, but\n+they\u2019re out of scope for this tutorial. There are some possible optimizations\n+that don\u2019t make it true 100% of the time, too. Rather than relying on the stack\n+and `Drop` to clean up memory, the garbage collector deals with the heap\n+instead.\n+\n+# Which to use?\n+\n+So if the stack is faster and easier to manage, why do we need the heap? A big\n+reason is that Stack-allocation alone means you only have LIFO semantics for\n+reclaiming storage. Heap-allocation is strictly more general, allowing storage\n+to be taken from and returned to the pool in arbitrary order, but at a\n+complexity cost.\n+\n+Generally, you should prefer stack allocation, and so, Rust stack-allocates by\n+default. The LIFO model of the stack is simpler, at a fundamental level. This\n+has two big impacts: runtime efficiency and semantic impact.\n+\n+## Runtime Efficiency.\n+\n+Managing the memory for the stack is trivial: The machine just\n+increments or decrements a single value, the so-called \u201cstack pointer\u201d.\n+Managing memory for the heap is non-trivial: heap-allocated memory is freed at\n+arbitrary points, and each block of heap-allocated memory can be of arbitrary\n+size, the memory manager must generally work much harder to identify memory for\n+reuse.\n+\n+If you\u2019d like to dive into this topic in greater detail, [this paper][wilson]\n+is a great introduction.\n+\n+[wilson]: http://www.cs.northwestern.edu/~pdinda/icsclass/doc/dsa.pdf\n+\n+## Semantic impact \n+\n+Stack-allocation impacts the Rust language itself, and thus the developer\u2019s\n+mental model. The LIFO semantics is what drives how the Rust language handles\n+automatic memory management. Even the deallocation of a uniquely-owned\n+heap-allocated box can be driven by the stack-based LIFO semantics, as\n+discussed throughout this chapter. The flexibility (i.e. expressiveness) of non\n+LIFO-semantics means that in general the compiler cannot automatically infer at\n+compile-time where memory should be freed; it has to rely on dynamic protocols,\n+potentially from outside the language itself, to drive deallocation (reference\n+counting, as used by `Rc<T>` and `Arc<T>`, is one example of this).\n+\n+When taken to the extreme, the increased expressive power of heap allocation\n+comes at the cost of either significant runtime support (e.g. in the form of a\n+garbage collector) or significant programmer effort (in the form of explicit\n+memory management calls that require verification not provided by the Rust\n+compiler)."}]}