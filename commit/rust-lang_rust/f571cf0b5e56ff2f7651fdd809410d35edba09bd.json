{"sha": "f571cf0b5e56ff2f7651fdd809410d35edba09bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY1NzFjZjBiNWU1NmZmMmY3NjUxZmRkODA5NDEwZDM1ZWRiYTA5YmQ=", "commit": {"author": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2017-09-24T11:31:12Z"}, "committer": {"name": "Michael Recachinas", "email": "mgr3yp@virginia.edu", "date": "2017-09-24T11:31:12Z"}, "message": "Change rtype of int_plus_one detection to Option<String>", "tree": {"sha": "c9e60c8a6d39b52a28826b0ad83ff0a7ff635afa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c9e60c8a6d39b52a28826b0ad83ff0a7ff635afa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f571cf0b5e56ff2f7651fdd809410d35edba09bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f571cf0b5e56ff2f7651fdd809410d35edba09bd", "html_url": "https://github.com/rust-lang/rust/commit/f571cf0b5e56ff2f7651fdd809410d35edba09bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f571cf0b5e56ff2f7651fdd809410d35edba09bd/comments", "author": null, "committer": null, "parents": [{"sha": "9437d2909c601525a7313cf8a4d72ef3b9810127", "url": "https://api.github.com/repos/rust-lang/rust/commits/9437d2909c601525a7313cf8a4d72ef3b9810127", "html_url": "https://github.com/rust-lang/rust/commit/9437d2909c601525a7313cf8a4d72ef3b9810127"}], "stats": {"total": 39, "additions": 11, "deletions": 28}, "files": [{"sha": "420427e7d0ab7eecb40707924e8f7d9a8a66cbc4", "filename": "clippy_lints/src/int_plus_one.rs", "status": "modified", "additions": 11, "deletions": 28, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/f571cf0b5e56ff2f7651fdd809410d35edba09bd/clippy_lints%2Fsrc%2Fint_plus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f571cf0b5e56ff2f7651fdd809410d35edba09bd/clippy_lints%2Fsrc%2Fint_plus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fint_plus_one.rs?ref=f571cf0b5e56ff2f7651fdd809410d35edba09bd", "patch": "@@ -59,59 +59,43 @@ impl IntPlusOne {\n         false\n     }\n \n-    fn check_binop(&self, cx: &EarlyContext, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<(bool, Option<String>)> {\n+    fn check_binop(&self, cx: &EarlyContext, binop: BinOpKind, lhs: &Expr, rhs: &Expr) -> Option<String> {\n         match (binop, &lhs.node, &rhs.node) {\n             // case where `x - 1 >= ...` or `-1 + x >= ...`\n             (BinOpKind::Ge, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) => {\n                 match (lhskind.node, &lhslhs.node, &lhsrhs.node) {\n                     // `-1 + x`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) => {\n-                        Some((self.check_lit(lit, -1), self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)))\n-                    },\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS),\n                     // `x - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)))\n-                    }\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS),\n                     _ => None\n                 }\n             },\n             // case where `... >= y + 1` or `... >= 1 + y`\n             (BinOpKind::Ge, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) if rhskind.node == BinOpKind::Add => {\n                 match (&rhslhs.node, &rhsrhs.node) {\n                     // `y + 1` and `1 + y`\n-                    (&ExprKind::Lit(ref lit), _) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)))\n-                    },\n-                    (_, &ExprKind::Lit(ref lit)) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)))\n-                    },\n+                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS),\n+                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS),\n                     _ => None\n                 }\n             },\n             // case where `x + 1 <= ...` or `1 + x <= ...`\n             (BinOpKind::Le, &ExprKind::Binary(ref lhskind, ref lhslhs, ref lhsrhs), _) if lhskind.node == BinOpKind::Add => {\n                 match (&lhslhs.node, &lhsrhs.node) {\n                     // `1 + x` and `x + 1`\n-                    (&ExprKind::Lit(ref lit), _) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS)))\n-                    },\n-                    (_, &ExprKind::Lit(ref lit)) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS)))\n-                    },\n+                    (&ExprKind::Lit(ref lit), _) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhsrhs, rhs, Side::LHS),\n+                    (_, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, lhslhs, rhs, Side::LHS),\n                     _ => None\n                 }\n             },\n             // case where `... >= y - 1` or `... >= -1 + y`\n             (BinOpKind::Le, _, &ExprKind::Binary(ref rhskind, ref rhslhs, ref rhsrhs)) => {\n                 match (rhskind.node, &rhslhs.node, &rhsrhs.node) {\n                     // `-1 + y`\n-                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) => {\n-                        Some((self.check_lit(lit, -1), self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS)))\n-                    },\n+                    (BinOpKind::Add, &ExprKind::Lit(ref lit), _) if self.check_lit(lit, -1) => self.generate_recommendation(cx, binop, rhsrhs, lhs, Side::RHS),\n                     // `y - 1`\n-                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) => {\n-                        Some((self.check_lit(lit, 1), self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS)))\n-                    },\n+                    (BinOpKind::Sub, _, &ExprKind::Lit(ref lit)) if self.check_lit(lit, 1) => self.generate_recommendation(cx, binop, rhslhs, lhs, Side::RHS),\n                     _ => None\n                 }\n             },\n@@ -151,9 +135,8 @@ impl IntPlusOne {\n impl EarlyLintPass for IntPlusOne {\n     fn check_expr(&mut self, cx: &EarlyContext, item: &Expr) {\n         if let ExprKind::Binary(ref kind, ref lhs, ref rhs) = item.node {\n-            match self.check_binop(cx, kind.node, lhs, rhs) {\n-                Some((should_emit, Some(ref rec))) if should_emit => self.emit_warning(cx, item, rec.clone()),\n-                _ => ()\n+            if let Some(ref rec) = self.check_binop(cx, kind.node, lhs, rhs) {\n+                self.emit_warning(cx, item, rec.clone());\n             }\n         }\n     }"}]}