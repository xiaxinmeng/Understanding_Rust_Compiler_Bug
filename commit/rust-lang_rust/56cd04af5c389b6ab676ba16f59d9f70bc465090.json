{"sha": "56cd04af5c389b6ab676ba16f59d9f70bc465090", "node_id": "C_kwDOAAsO6NoAKDU2Y2QwNGFmNWMzODliNmFiNjc2YmExNmY1OWQ5ZjcwYmM0NjUwOTA", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-10T09:37:07Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-10T09:37:07Z"}, "message": "Auto merge of #93511 - cjgillot:query-copy, r=oli-obk\n\nEnsure that queries only return Copy types.\n\nThis should pervent the perf footgun of returning a result with an expensive `Clone` impl (like a `Vec` of a hash map).\n\nI went for the stupid solution of allocating on an arena everything that was not `Copy`. Some query results could be made Copy easily, but I did not really investigate.", "tree": {"sha": "af86c44fca9e62cce5d7e5b6701b2227489fe06d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/af86c44fca9e62cce5d7e5b6701b2227489fe06d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/56cd04af5c389b6ab676ba16f59d9f70bc465090", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/56cd04af5c389b6ab676ba16f59d9f70bc465090", "html_url": "https://github.com/rust-lang/rust/commit/56cd04af5c389b6ab676ba16f59d9f70bc465090", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/56cd04af5c389b6ab676ba16f59d9f70bc465090/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5d6ee0db96aada145725838379f909bbb8aa2312", "url": "https://api.github.com/repos/rust-lang/rust/commits/5d6ee0db96aada145725838379f909bbb8aa2312", "html_url": "https://github.com/rust-lang/rust/commit/5d6ee0db96aada145725838379f909bbb8aa2312"}, {"sha": "8edd32c9404f416945d82c438a62acb7f90c2f62", "url": "https://api.github.com/repos/rust-lang/rust/commits/8edd32c9404f416945d82c438a62acb7f90c2f62", "html_url": "https://github.com/rust-lang/rust/commit/8edd32c9404f416945d82c438a62acb7f90c2f62"}], "stats": {"total": 390, "additions": 208, "deletions": 182}, "files": [{"sha": "dca7f5dd48769f5a7455dc5ee9f16c763e3714c2", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -604,7 +604,7 @@ pub fn eval_condition(\n     }\n }\n \n-#[derive(Debug, Encodable, Decodable, Clone, HashStable_Generic)]\n+#[derive(Copy, Debug, Encodable, Decodable, Clone, HashStable_Generic)]\n pub struct Deprecation {\n     pub since: Option<Symbol>,\n     /// The note to issue a reason."}, {"sha": "f6fddbb509dc8a90404fee0d2c3208c4293fcd5a", "filename": "compiler/rustc_codegen_ssa/src/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fwrite.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -477,7 +477,7 @@ pub fn start_async_codegen<B: ExtraBackendMethods>(\n         codegen_worker_receive,\n         shared_emitter_main,\n         future: coordinator_thread,\n-        output_filenames: tcx.output_filenames(()),\n+        output_filenames: tcx.output_filenames(()).clone(),\n     }\n }\n \n@@ -1050,7 +1050,7 @@ fn start_executing_work<B: ExtraBackendMethods>(\n         cgu_reuse_tracker: sess.cgu_reuse_tracker.clone(),\n         coordinator_send,\n         diag_emitter: shared_emitter.clone(),\n-        output_filenames: tcx.output_filenames(()),\n+        output_filenames: tcx.output_filenames(()).clone(),\n         regular_module_config: regular_config,\n         metadata_module_config: metadata_config,\n         allocator_module_config: allocator_config,"}, {"sha": "4a5eabc87554cb67ba05ac51d393bf8794291836", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -843,7 +843,7 @@ impl CrateInfo {\n             used_crate_source: Default::default(),\n             lang_item_to_crate: Default::default(),\n             missing_lang_items: Default::default(),\n-            dependency_formats: tcx.dependency_formats(()),\n+            dependency_formats: tcx.dependency_formats(()).clone(),\n             windows_subsystem,\n         };\n         let lang_items = tcx.lang_items();\n@@ -860,7 +860,7 @@ impl CrateInfo {\n             info.native_libraries\n                 .insert(cnum, tcx.native_libraries(cnum).iter().map(Into::into).collect());\n             info.crate_name.insert(cnum, tcx.crate_name(cnum).to_string());\n-            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum));\n+            info.used_crate_source.insert(cnum, tcx.used_crate_source(cnum).clone());\n             if tcx.is_compiler_builtins(cnum) {\n                 info.compiler_builtins = Some(cnum);\n             }"}, {"sha": "f5a4e11de16c07c52b79e0ac8534b137b91fb922", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -658,13 +658,13 @@ fn write_out_deps(\n             boxed_resolver.borrow_mut().access(|resolver| {\n                 for cnum in resolver.cstore().crates_untracked() {\n                     let source = resolver.cstore().crate_source_untracked(cnum);\n-                    if let Some((path, _)) = source.dylib {\n+                    if let Some((path, _)) = &source.dylib {\n                         files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n-                    if let Some((path, _)) = source.rlib {\n+                    if let Some((path, _)) = &source.rlib {\n                         files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n-                    if let Some((path, _)) = source.rmeta {\n+                    if let Some((path, _)) = &source.rmeta {\n                         files.push(escape_dep_filename(&path.display().to_string()));\n                     }\n                 }"}, {"sha": "87a88fbac71238cce3e1699c2d6bd2a9537dc6a2", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -120,7 +120,7 @@ crate struct CrateMetadata {\n     /// How to link (or not link) this crate to the currently compiled crate.\n     dep_kind: Lock<CrateDepKind>,\n     /// Filesystem location of this crate.\n-    source: CrateSource,\n+    source: Lrc<CrateSource>,\n     /// Whether or not this crate should be consider a private dependency\n     /// for purposes of the 'exported_private_dependencies' lint\n     private_dep: bool,\n@@ -1875,7 +1875,7 @@ impl CrateMetadata {\n             cnum_map,\n             dependencies,\n             dep_kind: Lock::new(dep_kind),\n-            source,\n+            source: Lrc::new(source),\n             private_dep,\n             host_hash,\n             extern_crate: Lock::new(None),\n@@ -1903,7 +1903,7 @@ impl CrateMetadata {\n     }\n \n     crate fn source(&self) -> &CrateSource {\n-        &self.source\n+        &*self.source\n     }\n \n     crate fn dep_kind(&self) -> CrateDepKind {"}, {"sha": "ad82165ebd485315a37206c3d089f322cb34f0ea", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -3,7 +3,6 @@ use crate::foreign_modules;\n use crate::native_libs;\n \n use rustc_ast as ast;\n-use rustc_data_structures::stable_map::FxHashMap;\n use rustc_hir::def::{CtorKind, DefKind, Res};\n use rustc_hir::def_id::{CrateNum, DefId, DefIdMap, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc_hir::definitions::{DefKey, DefPath, DefPathHash};\n@@ -13,7 +12,7 @@ use rustc_middle::middle::stability::DeprecationEntry;\n use rustc_middle::ty::fast_reject::SimplifiedType;\n use rustc_middle::ty::query::{ExternProviders, Providers};\n use rustc_middle::ty::{self, TyCtxt, Visibility};\n-use rustc_session::cstore::{CrateSource, CrateStore, ForeignModule};\n+use rustc_session::cstore::{CrateSource, CrateStore};\n use rustc_session::utils::NativeLibKind;\n use rustc_session::{Session, StableCrateId};\n use rustc_span::hygiene::{ExpnHash, ExpnId};\n@@ -179,10 +178,8 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n \n         reachable_non_generics\n     }\n-    native_libraries => { Lrc::new(cdata.get_native_libraries(tcx.sess).collect()) }\n-    foreign_modules => {\n-        Lrc::new(cdata.get_foreign_modules(tcx.sess).map(|m| (m.def_id, m)).collect())\n-    }\n+    native_libraries => { cdata.get_native_libraries(tcx.sess).collect() }\n+    foreign_modules => { cdata.get_foreign_modules(tcx.sess).map(|m| (m.def_id, m)).collect() }\n     crate_hash => { cdata.root.hash }\n     crate_host_hash => { cdata.host_hash }\n     crate_name => { cdata.root.name }\n@@ -212,7 +209,7 @@ provide! { <'tcx> tcx, def_id, other, cdata,\n         r\n     }\n \n-    used_crate_source => { Lrc::new(cdata.source.clone()) }\n+    used_crate_source => { Lrc::clone(&cdata.source) }\n \n     exported_symbols => {\n         let syms = cdata.exported_symbols(tcx);\n@@ -266,13 +263,11 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n         },\n         native_libraries: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n-            Lrc::new(native_libs::collect(tcx))\n+            native_libs::collect(tcx)\n         },\n         foreign_modules: |tcx, cnum| {\n             assert_eq!(cnum, LOCAL_CRATE);\n-            let modules: FxHashMap<DefId, ForeignModule> =\n-                foreign_modules::collect(tcx).into_iter().map(|m| (m.def_id, m)).collect();\n-            Lrc::new(modules)\n+            foreign_modules::collect(tcx).into_iter().map(|m| (m.def_id, m)).collect()\n         },\n \n         // Returns a map from a sufficiently visible external item (i.e., an\n@@ -354,7 +349,7 @@ pub(in crate::rmeta) fn provide(providers: &mut Providers) {\n                 visible_parent_map.entry(child).or_insert(parent);\n             }\n \n-            Lrc::new(visible_parent_map)\n+            visible_parent_map\n         },\n \n         dependency_formats: |tcx, ()| Lrc::new(crate::dependency_format::calculate(tcx)),\n@@ -438,7 +433,7 @@ impl CStore {\n         self.get_crate_data(def.krate).get_fn_has_self_parameter(def.index)\n     }\n \n-    pub fn crate_source_untracked(&self, cnum: CrateNum) -> CrateSource {\n+    pub fn crate_source_untracked(&self, cnum: CrateNum) -> Lrc<CrateSource> {\n         self.get_crate_data(cnum).source.clone()\n     }\n "}, {"sha": "c92b3b9434c2b95657a8a5e574fff74778efa84e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -1742,7 +1742,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                     hash: self.tcx.crate_hash(cnum),\n                     host_hash: self.tcx.crate_host_hash(cnum),\n                     kind: self.tcx.dep_kind(cnum),\n-                    extra_filename: self.tcx.extra_filename(cnum),\n+                    extra_filename: self.tcx.extra_filename(cnum).clone(),\n                 };\n                 (cnum, dep)\n             })"}, {"sha": "9caf77532a9f9a01bb1524e3d61cc6f6a8cc65f2", "filename": "compiler/rustc_middle/src/arena.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Farena.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Farena.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -52,6 +52,9 @@ macro_rules! arena_types {\n                         Vec<rustc_middle::traits::query::OutlivesBound<'tcx>>\n                     >\n                 >,\n+            [] dtorck_constraint: rustc_middle::traits::query::DtorckConstraint<'tcx>,\n+            [] candidate_step: rustc_middle::traits::query::CandidateStep<'tcx>,\n+            [] autoderef_bad_ty: rustc_middle::traits::query::MethodAutoderefBadTy<'tcx>,\n             [] type_op_subtype:\n                 rustc_middle::infer::canonical::Canonical<'tcx,\n                     rustc_middle::infer::canonical::QueryResponse<'tcx, ()>\n@@ -95,6 +98,7 @@ macro_rules! arena_types {\n             // This is used to decode the &'tcx [Span] for InlineAsm's line_spans.\n             [decode] span: rustc_span::Span,\n             [decode] used_trait_imports: rustc_data_structures::fx::FxHashSet<rustc_hir::def_id::LocalDefId>,\n+            [decode] impl_source: rustc_middle::traits::ImplSource<'tcx, ()>,\n \n             [] dep_kind: rustc_middle::dep_graph::DepKindStruct,\n         ]);"}, {"sha": "03cca51dc0b5474b28fa75dcb1627480197616b0", "filename": "compiler/rustc_middle/src/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fstability.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -29,7 +29,7 @@ pub enum StabilityLevel {\n }\n \n /// An entry in the `depr_map`.\n-#[derive(Clone, HashStable, Debug)]\n+#[derive(Copy, Clone, HashStable, Debug)]\n pub struct DeprecationEntry {\n     /// The metadata of the attribute associated with this entry.\n     pub attr: Deprecation,"}, {"sha": "fc2750d230395c16068c023071f1806c0b49afb5", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -215,7 +215,8 @@ rustc_queries! {\n         desc { |tcx| \"elaborating item bounds for `{}`\", tcx.def_path_str(key) }\n     }\n \n-    query native_libraries(_: CrateNum) -> Lrc<Vec<NativeLib>> {\n+    query native_libraries(_: CrateNum) -> Vec<NativeLib> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { \"looking up the native libraries of a linked crate\" }\n         separate_provide_extern\n     }\n@@ -254,6 +255,7 @@ rustc_queries! {\n     /// Create a THIR tree for debugging.\n     query thir_tree(key: ty::WithOptConstParam<LocalDefId>) -> String {\n         no_hash\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { |tcx| \"constructing THIR tree for `{}`\", tcx.def_path_str(key.did.to_def_id()) }\n     }\n \n@@ -368,6 +370,7 @@ rustc_queries! {\n     query symbols_for_closure_captures(\n         key: (LocalDefId, DefId)\n     ) -> Vec<rustc_span::Symbol> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc {\n             |tcx| \"symbols for captures of closure `{}` in `{}`\",\n             tcx.def_path_str(key.1),\n@@ -538,7 +541,7 @@ rustc_queries! {\n \n     query adt_dtorck_constraint(\n         key: DefId\n-    ) -> Result<DtorckConstraint<'tcx>, NoSolution> {\n+    ) -> Result<&'tcx DtorckConstraint<'tcx>, NoSolution> {\n         desc { |tcx| \"computing drop-check constraints for `{}`\", tcx.def_path_str(key) }\n     }\n \n@@ -646,8 +649,8 @@ rustc_queries! {\n     /// The map returned for `tcx.impl_item_implementor_ids(impl_id)` would be\n     ///`{ trait_f: impl_f, trait_g: impl_g }`\n     query impl_item_implementor_ids(impl_id: DefId) -> FxHashMap<DefId, DefId> {\n-        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n         storage(ArenaCacheSelector<'tcx>)\n+        desc { |tcx| \"comparing impl items against trait for {}\", tcx.def_path_str(impl_id) }\n     }\n \n     /// Given an `impl_id`, return the trait it implements.\n@@ -1042,6 +1045,7 @@ rustc_queries! {\n     /// Gets the rendered value of the specified constant or associated constant.\n     /// Used by rustdoc.\n     query rendered_const(def_id: DefId) -> String {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { |tcx| \"rendering constant intializer of `{}`\", tcx.def_path_str(def_id) }\n         separate_provide_extern\n     }\n@@ -1091,7 +1095,7 @@ rustc_queries! {\n \n     query codegen_fulfill_obligation(\n         key: (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>)\n-    ) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n+    ) -> Result<&'tcx ImplSource<'tcx, ()>, ErrorReported> {\n         cache_on_disk_if { true }\n         desc { |tcx|\n             \"checking if `{}` fulfills its obligations\",\n@@ -1237,6 +1241,7 @@ rustc_queries! {\n     }\n \n     query dependency_formats(_: ()) -> Lrc<crate::middle::dependency_format::Dependencies> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { \"get the linkage format of all dependencies\" }\n     }\n \n@@ -1369,13 +1374,15 @@ rustc_queries! {\n     /// You likely want to call `Instance::upstream_monomorphization()`\n     /// instead of invoking this query directly.\n     query upstream_monomorphizations_for(def_id: DefId)\n-        -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>> {\n-            desc { |tcx|\n-                \"collecting available upstream monomorphizations for `{}`\",\n-                tcx.def_path_str(def_id),\n-            }\n-            separate_provide_extern\n+        -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n+    {\n+        storage(ArenaCacheSelector<'tcx>)\n+        desc { |tcx|\n+            \"collecting available upstream monomorphizations for `{}`\",\n+            tcx.def_path_str(def_id),\n         }\n+        separate_provide_extern\n+    }\n \n     /// Returns the upstream crate that exports drop-glue for the given\n     /// type (`substs` is expected to be a single-item list containing the\n@@ -1396,7 +1403,8 @@ rustc_queries! {\n         desc { \"available upstream drop-glue for `{:?}`\", substs }\n     }\n \n-    query foreign_modules(_: CrateNum) -> Lrc<FxHashMap<DefId, ForeignModule>> {\n+    query foreign_modules(_: CrateNum) -> FxHashMap<DefId, ForeignModule> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { \"looking up the foreign modules of a linked crate\" }\n         separate_provide_extern\n     }\n@@ -1422,11 +1430,13 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query extra_filename(_: CrateNum) -> String {\n+        storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"looking up the extra filename for a crate\" }\n         separate_provide_extern\n     }\n     query crate_extern_paths(_: CrateNum) -> Vec<PathBuf> {\n+        storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"looking up the paths for extern crates\" }\n         separate_provide_extern\n@@ -1478,8 +1488,7 @@ rustc_queries! {\n     /// for each parameter if a trait object were to be passed for that parameter.\n     /// For example, for `struct Foo<'a, T, U>`, this would be `['static, 'static]`.\n     /// For `struct Foo<'a, T: 'a, U>`, this would instead be `['a, 'static]`.\n-    query object_lifetime_defaults_map(_: LocalDefId)\n-        -> Option<Vec<ObjectLifetimeDefault>> {\n+    query object_lifetime_defaults(_: LocalDefId) -> Option<&'tcx [ObjectLifetimeDefault]> {\n         desc { \"looking up lifetime defaults for a region on an item\" }\n     }\n     query late_bound_vars_map(_: LocalDefId)\n@@ -1488,6 +1497,7 @@ rustc_queries! {\n     }\n \n     query lifetime_scope_map(_: LocalDefId) -> Option<FxHashMap<ItemLocalId, LifetimeScopeForPath>> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { \"finds the lifetime scope for an HirId of a PathSegment\" }\n     }\n \n@@ -1501,7 +1511,7 @@ rustc_queries! {\n     /// check whether the forest is empty.\n     query type_uninhabited_from(\n         key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>\n-    ) -> ty::inhabitedness::DefIdForest {\n+    ) -> ty::inhabitedness::DefIdForest<'tcx> {\n         desc { \"computing the inhabitedness of `{:?}`\", key }\n         remap_env_constness\n     }\n@@ -1566,7 +1576,8 @@ rustc_queries! {\n         desc { \"calculating the missing lang items in a crate\" }\n         separate_provide_extern\n     }\n-    query visible_parent_map(_: ()) -> Lrc<DefIdMap<DefId>> {\n+    query visible_parent_map(_: ()) -> DefIdMap<DefId> {\n+        storage(ArenaCacheSelector<'tcx>)\n         desc { \"calculating the visible parent map\" }\n     }\n     query trimmed_def_paths(_: ()) -> FxHashMap<DefId, Symbol> {\n@@ -1579,6 +1590,7 @@ rustc_queries! {\n         separate_provide_extern\n     }\n     query used_crate_source(_: CrateNum) -> Lrc<CrateSource> {\n+        storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         desc { \"looking at the source for a crate\" }\n         separate_provide_extern\n@@ -1669,7 +1681,11 @@ rustc_queries! {\n         desc { \"optimization level used by backend\" }\n     }\n \n-    query output_filenames(_: ()) -> Arc<OutputFilenames> {\n+    /// Return the filenames where output artefacts shall be stored.\n+    ///\n+    /// This query returns an `&Arc` because codegen backends need the value even after the `TyCtxt`\n+    /// has been destroyed.\n+    query output_filenames(_: ()) -> &'tcx Arc<OutputFilenames> {\n         eval_always\n         desc { \"output_filenames\" }\n     }\n@@ -1911,6 +1927,7 @@ rustc_queries! {\n     /// all of the cases that the normal `ty::Ty`-based wfcheck does. This is fine,\n     /// because the `ty::Ty`-based wfcheck is always run.\n     query diagnostic_hir_wf_check(key: (ty::Predicate<'tcx>, traits::WellFormedLoc)) -> Option<traits::ObligationCause<'tcx>> {\n+        storage(ArenaCacheSelector<'tcx>)\n         eval_always\n         no_hash\n         desc { \"performing HIR wf-checking for predicate {:?} at item {:?}\", key.0, key.1 }"}, {"sha": "07cfe83b0143867fc6dd07b7fb8abc6dd2c6a1ec", "filename": "compiler/rustc_middle/src/traits/query.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Ftraits%2Fquery.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -11,7 +11,6 @@ use crate::ty::subst::GenericArg;\n use crate::ty::{self, Ty, TyCtxt};\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::struct_span_err;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_span::source_map::Span;\n@@ -97,7 +96,7 @@ pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n     Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n \n-#[derive(Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct NoSolution;\n \n pub type Fallible<T> = Result<T, NoSolution>;\n@@ -191,12 +190,12 @@ pub struct CandidateStep<'tcx> {\n     pub unsize: bool,\n }\n \n-#[derive(Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub struct MethodAutoderefStepsResult<'tcx> {\n     /// The valid autoderef steps that could be find.\n-    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    pub steps: &'tcx [CandidateStep<'tcx>],\n     /// If Some(T), a type autoderef reported an error on.\n-    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    pub opt_bad_ty: Option<&'tcx MethodAutoderefBadTy<'tcx>>,\n     /// If `true`, `steps` has been truncated due to reaching the\n     /// recursion limit.\n     pub reached_recursion_limit: bool,"}, {"sha": "aa264c26de88f8ac16e66ff7cc8b5ca60078bb48", "filename": "compiler/rustc_middle/src/ty/adt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fadt.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -26,7 +26,7 @@ use super::{\n     Destructor, FieldDef, GenericPredicates, ReprOptions, Ty, TyCtxt, VariantDef, VariantDiscr,\n };\n \n-#[derive(Clone, HashStable, Debug)]\n+#[derive(Copy, Clone, HashStable, Debug)]\n pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n \n bitflags! {"}, {"sha": "69b116166e06581a67375a7b59467a2d47555aaa", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -13,6 +13,7 @@ use crate::mir::{\n     interpret::{AllocId, Allocation},\n };\n use crate::thir;\n+use crate::traits;\n use crate::ty::subst::SubstsRef;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_data_structures::fx::FxHashMap;\n@@ -156,6 +157,7 @@ macro_rules! encodable_via_deref {\n encodable_via_deref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     ty::Region<'tcx>,\n+    &'tcx traits::ImplSource<'tcx, ()>,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,\n     &'tcx mir::BorrowCheckResult<'tcx>,\n@@ -385,6 +387,7 @@ impl_decodable_via_ref! {\n     &'tcx ty::TypeckResults<'tcx>,\n     &'tcx ty::List<Ty<'tcx>>,\n     &'tcx ty::List<ty::Binder<'tcx, ty::ExistentialPredicate<'tcx>>>,\n+    &'tcx traits::ImplSource<'tcx, ()>,\n     &'tcx Allocation,\n     &'tcx mir::Body<'tcx>,\n     &'tcx mir::UnsafetyCheckResult,"}, {"sha": "b739607c89f995e9a9f6ef7792bfa0a0646b709d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -5,7 +5,7 @@ use crate::dep_graph::{DepGraph, DepKind, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n use crate::lint::{struct_lint_level, LintDiagnosticBuilder, LintLevelSource};\n-use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n+use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath};\n use crate::middle::stability;\n use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n@@ -2713,10 +2713,6 @@ impl<'tcx> TyCtxt<'tcx> {\n             .map_or(false, |(owner, set)| owner == id.owner && set.contains(&id.local_id))\n     }\n \n-    pub fn object_lifetime_defaults(self, id: HirId) -> Option<Vec<ObjectLifetimeDefault>> {\n-        self.object_lifetime_defaults_map(id.owner)\n-    }\n-\n     pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n         self.mk_bound_variable_kinds(\n             self.late_bound_vars_map(id.owner)\n@@ -2728,8 +2724,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         )\n     }\n \n-    pub fn lifetime_scope(self, id: HirId) -> Option<LifetimeScopeForPath> {\n-        self.lifetime_scope_map(id.owner).and_then(|mut map| map.remove(&id.local_id))\n+    pub fn lifetime_scope(self, id: HirId) -> Option<&'tcx LifetimeScopeForPath> {\n+        self.lifetime_scope_map(id.owner).as_ref().and_then(|map| map.get(&id.local_id))\n     }\n \n     /// Whether the `def_id` counts as const fn in the current crate, considering all active\n@@ -2902,7 +2898,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n         |tcx, id| tcx.stability().local_deprecation_entry(id.expect_local());\n     providers.extern_mod_stmt_cnum =\n         |tcx, id| tcx.resolutions(()).extern_crate_map.get(&id).cloned();\n-    providers.output_filenames = |tcx, ()| tcx.output_filenames.clone();\n+    providers.output_filenames = |tcx, ()| &tcx.output_filenames;\n     providers.features_query = |tcx, ()| tcx.sess.features_untracked();\n     providers.is_panic_runtime = |tcx, cnum| {\n         assert_eq!(cnum, LOCAL_CRATE);"}, {"sha": "c4ad698ba763531896eb8d5e1a633c2c4afb0228", "filename": "compiler/rustc_middle/src/ty/inhabitedness/def_id_forest.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fdef_id_forest.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -3,7 +3,6 @@ use crate::ty::{DefId, DefIdTree};\n use rustc_span::def_id::CRATE_DEF_ID;\n use smallvec::SmallVec;\n use std::mem;\n-use std::sync::Arc;\n \n use DefIdForest::*;\n \n@@ -18,14 +17,13 @@ use DefIdForest::*;\n /// We store the minimal set of `DefId`s required to represent the whole set. If A and B are\n /// `DefId`s in the `DefIdForest`, and A is a parent of B, then only A will be stored. When this is\n /// used with `type_uninhabited_from`, there will very rarely be more than one `DefId` stored.\n-#[derive(Clone, HashStable, Debug)]\n-pub enum DefIdForest {\n+#[derive(Copy, Clone, HashStable, Debug)]\n+pub enum DefIdForest<'a> {\n     Empty,\n     Single(DefId),\n     /// This variant is very rare.\n     /// Invariant: >1 elements\n-    /// We use `Arc` because this is used in the output of a query.\n-    Multiple(Arc<[DefId]>),\n+    Multiple(&'a [DefId]),\n }\n \n /// Tests whether a slice of roots contains a given DefId.\n@@ -34,21 +32,21 @@ fn slice_contains<'tcx>(tcx: TyCtxt<'tcx>, slice: &[DefId], id: DefId) -> bool {\n     slice.iter().any(|root_id| tcx.is_descendant_of(id, *root_id))\n }\n \n-impl<'tcx> DefIdForest {\n+impl<'tcx> DefIdForest<'tcx> {\n     /// Creates an empty forest.\n-    pub fn empty() -> DefIdForest {\n+    pub fn empty() -> DefIdForest<'tcx> {\n         DefIdForest::Empty\n     }\n \n     /// Creates a forest consisting of a single tree representing the entire\n     /// crate.\n     #[inline]\n-    pub fn full() -> DefIdForest {\n+    pub fn full() -> DefIdForest<'tcx> {\n         DefIdForest::from_id(CRATE_DEF_ID.to_def_id())\n     }\n \n     /// Creates a forest containing a `DefId` and all its descendants.\n-    pub fn from_id(id: DefId) -> DefIdForest {\n+    pub fn from_id(id: DefId) -> DefIdForest<'tcx> {\n         DefIdForest::Single(id)\n     }\n \n@@ -61,11 +59,11 @@ impl<'tcx> DefIdForest {\n     }\n \n     // Only allocates in the rare `Multiple` case.\n-    fn from_slice(root_ids: &[DefId]) -> DefIdForest {\n-        match root_ids {\n+    fn from_vec(tcx: TyCtxt<'tcx>, root_ids: SmallVec<[DefId; 1]>) -> DefIdForest<'tcx> {\n+        match &root_ids[..] {\n             [] => Empty,\n             [id] => Single(*id),\n-            _ => DefIdForest::Multiple(root_ids.into()),\n+            _ => DefIdForest::Multiple(tcx.arena.alloc_from_iter(root_ids)),\n         }\n     }\n \n@@ -88,9 +86,9 @@ impl<'tcx> DefIdForest {\n     }\n \n     /// Calculate the intersection of a collection of forests.\n-    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n+    pub fn intersection<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n     where\n-        I: IntoIterator<Item = DefIdForest>,\n+        I: IntoIterator<Item = DefIdForest<'tcx>>,\n     {\n         let mut iter = iter.into_iter();\n         let mut ret: SmallVec<[_; 1]> = if let Some(first) = iter.next() {\n@@ -114,13 +112,13 @@ impl<'tcx> DefIdForest {\n             mem::swap(&mut next_ret, &mut ret);\n             next_ret.clear();\n         }\n-        DefIdForest::from_slice(&ret)\n+        DefIdForest::from_vec(tcx, ret)\n     }\n \n     /// Calculate the union of a collection of forests.\n-    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest\n+    pub fn union<I>(tcx: TyCtxt<'tcx>, iter: I) -> DefIdForest<'tcx>\n     where\n-        I: IntoIterator<Item = DefIdForest>,\n+        I: IntoIterator<Item = DefIdForest<'tcx>>,\n     {\n         let mut ret: SmallVec<[_; 1]> = SmallVec::new();\n         let mut next_ret: SmallVec<[_; 1]> = SmallVec::new();\n@@ -142,6 +140,6 @@ impl<'tcx> DefIdForest {\n             mem::swap(&mut next_ret, &mut ret);\n             next_ret.clear();\n         }\n-        DefIdForest::from_slice(&ret)\n+        DefIdForest::from_vec(tcx, ret)\n     }\n }"}, {"sha": "14ddccbfd83ae993e177b4d98529fa723e108ed9", "filename": "compiler/rustc_middle/src/ty/inhabitedness/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Finhabitedness%2Fmod.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -112,7 +112,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n         substs: SubstsRef<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         // Non-exhaustive ADTs from other crates are always considered inhabited.\n         if self.is_variant_list_non_exhaustive() && !self.did.is_local() {\n             DefIdForest::empty()\n@@ -135,7 +135,7 @@ impl<'tcx> VariantDef {\n         substs: SubstsRef<'tcx>,\n         adt_kind: AdtKind,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         let is_enum = match adt_kind {\n             // For now, `union`s are never considered uninhabited.\n             // The precise semantics of inhabitedness with respect to unions is currently undecided.\n@@ -163,7 +163,7 @@ impl<'tcx> FieldDef {\n         substs: SubstsRef<'tcx>,\n         is_enum: bool,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n+    ) -> DefIdForest<'tcx> {\n         let data_uninhabitedness = move || self.ty(tcx, substs).uninhabited_from(tcx, param_env);\n         // FIXME(canndrew): Currently enum fields are (incorrectly) stored with\n         // `Visibility::Invisible` so we need to override `self.vis` if we're\n@@ -190,16 +190,16 @@ impl<'tcx> TyS<'tcx> {\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n-    ) -> DefIdForest {\n-        tcx.type_uninhabited_from(param_env.and(self))\n+    ) -> DefIdForest<'tcx> {\n+        tcx.type_uninhabited_from(param_env.and(self)).clone()\n     }\n }\n \n // Query provider for `type_uninhabited_from`.\n pub(crate) fn type_uninhabited_from<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     key: ty::ParamEnvAnd<'tcx, Ty<'tcx>>,\n-) -> DefIdForest {\n+) -> DefIdForest<'tcx> {\n     let ty = key.value;\n     let param_env = key.param_env;\n     match *ty.kind() {"}, {"sha": "c59918df4de5b79640042e83fe568dbfa1cee4fb", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -2839,7 +2839,7 @@ pub fn conv_from_spec_abi(tcx: TyCtxt<'_>, abi: SpecAbi) -> Conv {\n }\n \n /// Error produced by attempting to compute or adjust a `FnAbi`.\n-#[derive(Clone, Debug, HashStable)]\n+#[derive(Copy, Clone, Debug, HashStable)]\n pub enum FnAbiError<'tcx> {\n     /// Error produced by a `layout_of` call, while computing `FnAbi` initially.\n     Layout(LayoutError<'tcx>),"}, {"sha": "1688e59cdd12fe89fd7ba6858a9706691e2dc1f9", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -106,6 +106,12 @@ impl<'tcx> TyCtxt<'tcx> {\n #[inline(always)]\n fn noop<T>(_: &T) {}\n \n+/// Helper to ensure that queries only return `Copy` types.\n+#[inline(always)]\n+fn copy<T: Copy>(x: &T) -> T {\n+    *x\n+}\n+\n macro_rules! query_helper_param_ty {\n     (DefId) => { impl IntoQueryParam<DefId> };\n     ($K:ty) => { $K };\n@@ -243,7 +249,7 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, Clone::clone);\n+                let cached = try_get_cached(self.tcx, &self.tcx.query_caches.$name, &key, copy);\n \n                 let lookup = match cached {\n                     Ok(value) => return value,\n@@ -347,6 +353,13 @@ mod sealed {\n         }\n     }\n \n+    impl<'a, P: Copy> IntoQueryParam<P> for &'a P {\n+        #[inline(always)]\n+        fn into_query_param(self) -> P {\n+            *self\n+        }\n+    }\n+\n     impl IntoQueryParam<DefId> for LocalDefId {\n         #[inline(always)]\n         fn into_query_param(self) -> DefId {"}, {"sha": "88d994e32fe0c452122002a81e2be8fa1de4e34c", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -935,7 +935,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     };\n \n                     self.var_debug_info.push(VarDebugInfo {\n-                        name: sym,\n+                        name: *sym,\n                         source_info: SourceInfo::outermost(tcx_hir.span(var_id)),\n                         value: VarDebugInfoContents::Place(Place {\n                             local: ty::CAPTURE_STRUCT_LOCAL,"}, {"sha": "56879ef1808f63d89b25359b685099a54a634197", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 76, "deletions": 77, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -377,7 +377,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n-        object_lifetime_defaults_map: |tcx, id| match tcx.hir().find_by_def_id(id) {\n+        object_lifetime_defaults: |tcx, id| match tcx.hir().find_by_def_id(id) {\n             Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n             _ => None,\n         },\n@@ -1673,10 +1673,10 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n     }\n }\n \n-fn compute_object_lifetime_defaults(\n-    tcx: TyCtxt<'_>,\n+fn compute_object_lifetime_defaults<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     item: &hir::Item<'_>,\n-) -> Option<Vec<ObjectLifetimeDefault>> {\n+) -> Option<&'tcx [ObjectLifetimeDefault]> {\n     match item.kind {\n         hir::ItemKind::Struct(_, ref generics)\n         | hir::ItemKind::Union(_, ref generics)\n@@ -1729,10 +1729,10 @@ fn compute_object_lifetime_defaults(\n /// Scan the bounds and where-clauses on parameters to extract bounds\n /// of the form `T:'a` so as to determine the `ObjectLifetimeDefault`\n /// for each type parameter.\n-fn object_lifetime_defaults_for_item(\n-    tcx: TyCtxt<'_>,\n+fn object_lifetime_defaults_for_item<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     generics: &hir::Generics<'_>,\n-) -> Vec<ObjectLifetimeDefault> {\n+) -> &'tcx [ObjectLifetimeDefault] {\n     fn add_bounds(set: &mut Set1<hir::LifetimeName>, bounds: &[hir::GenericBound<'_>]) {\n         for bound in bounds {\n             if let hir::GenericBound::Outlives(ref lifetime) = *bound {\n@@ -1741,81 +1741,75 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics\n-        .params\n-        .iter()\n-        .filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => None,\n-            GenericParamKind::Type { .. } => {\n-                let mut set = Set1::Empty;\n-\n-                add_bounds(&mut set, &param.bounds);\n-\n-                let param_def_id = tcx.hir().local_def_id(param.hir_id);\n-                for predicate in generics.where_clause.predicates {\n-                    // Look for `type: ...` where clauses.\n-                    let data = match *predicate {\n-                        hir::WherePredicate::BoundPredicate(ref data) => data,\n-                        _ => continue,\n-                    };\n+    let process_param = |param: &hir::GenericParam<'_>| match param.kind {\n+        GenericParamKind::Lifetime { .. } => None,\n+        GenericParamKind::Type { .. } => {\n+            let mut set = Set1::Empty;\n \n-                    // Ignore `for<'a> type: ...` as they can change what\n-                    // lifetimes mean (although we could \"just\" handle it).\n-                    if !data.bound_generic_params.is_empty() {\n-                        continue;\n-                    }\n+            add_bounds(&mut set, &param.bounds);\n \n-                    let res = match data.bounded_ty.kind {\n-                        hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n-                        _ => continue,\n-                    };\n+            let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+            for predicate in generics.where_clause.predicates {\n+                // Look for `type: ...` where clauses.\n+                let data = match *predicate {\n+                    hir::WherePredicate::BoundPredicate(ref data) => data,\n+                    _ => continue,\n+                };\n \n-                    if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n-                        add_bounds(&mut set, &data.bounds);\n-                    }\n+                // Ignore `for<'a> type: ...` as they can change what\n+                // lifetimes mean (although we could \"just\" handle it).\n+                if !data.bound_generic_params.is_empty() {\n+                    continue;\n                 }\n \n-                Some(match set {\n-                    Set1::Empty => Set1::Empty,\n-                    Set1::One(name) => {\n-                        if name == hir::LifetimeName::Static {\n-                            Set1::One(Region::Static)\n-                        } else {\n-                            generics\n-                                .params\n-                                .iter()\n-                                .filter_map(|param| match param.kind {\n-                                    GenericParamKind::Lifetime { .. } => Some((\n-                                        param.hir_id,\n-                                        hir::LifetimeName::Param(param.name),\n-                                        LifetimeDefOrigin::from_param(param),\n-                                    )),\n-                                    _ => None,\n-                                })\n-                                .enumerate()\n-                                .find(|&(_, (_, lt_name, _))| lt_name == name)\n-                                .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                                    let def_id = tcx.hir().local_def_id(id);\n-                                    Set1::One(Region::EarlyBound(\n-                                        i as u32,\n-                                        def_id.to_def_id(),\n-                                        origin,\n-                                    ))\n-                                })\n-                        }\n-                    }\n-                    Set1::Many => Set1::Many,\n-                })\n-            }\n-            GenericParamKind::Const { .. } => {\n-                // Generic consts don't impose any constraints.\n-                //\n-                // We still store a dummy value here to allow generic parameters\n-                // in an arbitrary order.\n-                Some(Set1::Empty)\n+                let res = match data.bounded_ty.kind {\n+                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.res,\n+                    _ => continue,\n+                };\n+\n+                if res == Res::Def(DefKind::TyParam, param_def_id.to_def_id()) {\n+                    add_bounds(&mut set, &data.bounds);\n+                }\n             }\n-        })\n-        .collect()\n+\n+            Some(match set {\n+                Set1::Empty => Set1::Empty,\n+                Set1::One(name) => {\n+                    if name == hir::LifetimeName::Static {\n+                        Set1::One(Region::Static)\n+                    } else {\n+                        generics\n+                            .params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamKind::Lifetime { .. } => Some((\n+                                    param.hir_id,\n+                                    hir::LifetimeName::Param(param.name),\n+                                    LifetimeDefOrigin::from_param(param),\n+                                )),\n+                                _ => None,\n+                            })\n+                            .enumerate()\n+                            .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                            .map_or(Set1::Many, |(i, (id, _, origin))| {\n+                                let def_id = tcx.hir().local_def_id(id);\n+                                Set1::One(Region::EarlyBound(i as u32, def_id.to_def_id(), origin))\n+                            })\n+                    }\n+                }\n+                Set1::Many => Set1::Many,\n+            })\n+        }\n+        GenericParamKind::Const { .. } => {\n+            // Generic consts don't impose any constraints.\n+            //\n+            // We still store a dummy value here to allow generic parameters\n+            // in an arbitrary order.\n+            Some(Set1::Empty)\n+        }\n+    };\n+\n+    tcx.arena.alloc_from_iter(generics.params.iter().filter_map(process_param))\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -2509,7 +2503,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             };\n             if let Some(def_id) = def_id.as_local() {\n                 let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                self.tcx.object_lifetime_defaults(id).unwrap().iter().map(set_to_region).collect()\n+                self.tcx\n+                    .object_lifetime_defaults(id.owner)\n+                    .unwrap()\n+                    .iter()\n+                    .map(set_to_region)\n+                    .collect()\n             } else {\n                 let tcx = self.tcx;\n                 self.xcrate_object_lifetime_defaults"}, {"sha": "0870b1054e43097e894c99e291d238b7abf5c44d", "filename": "compiler/rustc_target/src/abi/call/mod.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_target%2Fsrc%2Fabi%2Fcall%2Fmod.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -1,6 +1,7 @@\n use crate::abi::{self, Abi, Align, FieldsShape, Size};\n use crate::abi::{HasDataLayout, TyAbiInterface, TyAndLayout};\n use crate::spec::{self, HasTargetSpec};\n+use rustc_span::Symbol;\n use std::fmt;\n \n mod aarch64;\n@@ -623,10 +624,10 @@ pub struct FnAbi<'a, Ty> {\n }\n \n /// Error produced by attempting to adjust a `FnAbi`, for a \"foreign\" ABI.\n-#[derive(Clone, Debug, HashStable_Generic)]\n+#[derive(Copy, Clone, Debug, HashStable_Generic)]\n pub enum AdjustForForeignAbiError {\n     /// Target architecture doesn't support \"foreign\" (i.e. non-Rust) ABIs.\n-    Unsupported { arch: String, abi: spec::abi::Abi },\n+    Unsupported { arch: Symbol, abi: spec::abi::Abi },\n }\n \n impl fmt::Display for AdjustForForeignAbiError {\n@@ -703,7 +704,10 @@ impl<'a, Ty> FnAbi<'a, Ty> {\n             \"asmjs\" => wasm::compute_c_abi_info(cx, self),\n             \"bpf\" => bpf::compute_abi_info(self),\n             arch => {\n-                return Err(AdjustForForeignAbiError::Unsupported { arch: arch.to_string(), abi });\n+                return Err(AdjustForForeignAbiError::Unsupported {\n+                    arch: Symbol::intern(arch),\n+                    abi,\n+                });\n             }\n         }\n "}, {"sha": "138d535a5694de88537ec80c80a02b91bdc96fc7", "filename": "compiler/rustc_trait_selection/src/traits/codegen.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcodegen.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -22,7 +22,7 @@ use rustc_middle::ty::{self, TyCtxt};\n pub fn codegen_fulfill_obligation<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     (param_env, trait_ref): (ty::ParamEnv<'tcx>, ty::PolyTraitRef<'tcx>),\n-) -> Result<ImplSource<'tcx, ()>, ErrorReported> {\n+) -> Result<&'tcx ImplSource<'tcx, ()>, ErrorReported> {\n     // Remove any references to regions; this helps improve caching.\n     let trait_ref = tcx.erase_regions(trait_ref);\n     // We expect the input to be fully normalized.\n@@ -96,7 +96,7 @@ pub fn codegen_fulfill_obligation<'tcx>(\n         drop(infcx.inner.borrow_mut().opaque_type_storage.take_opaque_types());\n \n         debug!(\"Cache miss: {:?} => {:?}\", trait_ref, impl_source);\n-        Ok(impl_source)\n+        Ok(&*tcx.arena.alloc(impl_source))\n     })\n }\n "}, {"sha": "96671787b31637dce1ae82b0ff2ff39e85d234f6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -262,7 +262,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         .tcx\n                         .diagnostic_hir_wf_check((tcx.erase_regions(obligation.predicate), *wf_loc))\n                     {\n-                        obligation.cause = cause;\n+                        obligation.cause = cause.clone();\n                         span = obligation.cause.span;\n                     }\n                 }"}, {"sha": "087c216af14167ac81c1101b387bfe8f0e7b6579", "filename": "compiler/rustc_traits/src/dropck_outlives.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fdropck_outlives.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -278,9 +278,9 @@ fn dtorck_constraint_for_ty<'tcx>(\n                 tcx.at(span).adt_dtorck_constraint(def.did)?;\n             // FIXME: we can try to recursively `dtorck_constraint_on_ty`\n             // there, but that needs some way to handle cycles.\n-            constraints.dtorck_types.extend(dtorck_types.subst(tcx, substs));\n-            constraints.outlives.extend(outlives.subst(tcx, substs));\n-            constraints.overflows.extend(overflows.subst(tcx, substs));\n+            constraints.dtorck_types.extend(dtorck_types.iter().map(|t| t.subst(tcx, substs)));\n+            constraints.outlives.extend(outlives.iter().map(|t| t.subst(tcx, substs)));\n+            constraints.overflows.extend(overflows.iter().map(|t| t.subst(tcx, substs)));\n         }\n \n         // Objects must be alive in order for their destructor\n@@ -308,7 +308,7 @@ fn dtorck_constraint_for_ty<'tcx>(\n crate fn adt_dtorck_constraint(\n     tcx: TyCtxt<'_>,\n     def_id: DefId,\n-) -> Result<DtorckConstraint<'_>, NoSolution> {\n+) -> Result<&DtorckConstraint<'_>, NoSolution> {\n     let def = tcx.adt_def(def_id);\n     let span = tcx.def_span(def_id);\n     debug!(\"dtorck_constraint: {:?}\", def);\n@@ -324,7 +324,7 @@ crate fn adt_dtorck_constraint(\n             overflows: vec![],\n         };\n         debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n-        return Ok(result);\n+        return Ok(tcx.arena.alloc(result));\n     }\n \n     let mut result = DtorckConstraint::empty();\n@@ -337,7 +337,7 @@ crate fn adt_dtorck_constraint(\n \n     debug!(\"dtorck_constraint: {:?} => {:?}\", def, result);\n \n-    Ok(result)\n+    Ok(tcx.arena.alloc(result))\n }\n \n fn dedup_dtorck_constraint(c: &mut DtorckConstraint<'_>) {"}, {"sha": "2103c12694f100e075e23002c66a5e67733c3cd2", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -9,7 +9,6 @@ use crate::hir::def::DefKind;\n use crate::hir::def_id::DefId;\n \n use rustc_data_structures::fx::FxHashSet;\n-use rustc_data_structures::sync::Lrc;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n@@ -59,7 +58,7 @@ struct ProbeContext<'a, 'tcx> {\n     /// This is the OriginalQueryValues for the steps queries\n     /// that are answered in steps.\n     orig_steps_var_values: OriginalQueryValues<'tcx>,\n-    steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    steps: &'tcx [CandidateStep<'tcx>],\n \n     inherent_candidates: Vec<Candidate<'tcx>>,\n     extension_candidates: Vec<Candidate<'tcx>>,\n@@ -364,7 +363,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     param_env_and_self_ty, self_ty\n                 );\n                 MethodAutoderefStepsResult {\n-                    steps: Lrc::new(vec![CandidateStep {\n+                    steps: infcx.tcx.arena.alloc_from_iter([CandidateStep {\n                         self_ty: self.make_query_response_ignoring_pending_obligations(\n                             canonical_inference_vars,\n                             self_ty,\n@@ -533,8 +532,8 @@ fn method_autoderef_steps<'tcx>(\n         debug!(\"method_autoderef_steps: steps={:?} opt_bad_ty={:?}\", steps, opt_bad_ty);\n \n         MethodAutoderefStepsResult {\n-            steps: Lrc::new(steps),\n-            opt_bad_ty: opt_bad_ty.map(Lrc::new),\n+            steps: tcx.arena.alloc_from_iter(steps),\n+            opt_bad_ty: opt_bad_ty.map(|ty| &*tcx.arena.alloc(ty)),\n             reached_recursion_limit: autoderef.reached_recursion_limit(),\n         }\n     })\n@@ -548,7 +547,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         method_name: Option<Ident>,\n         return_type: Option<Ty<'tcx>>,\n         orig_steps_var_values: OriginalQueryValues<'tcx>,\n-        steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+        steps: &'tcx [CandidateStep<'tcx>],\n         is_suggestion: IsSuggestion,\n         scope_expr_id: hir::HirId,\n     ) -> ProbeContext<'a, 'tcx> {\n@@ -605,8 +604,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n     }\n \n     fn assemble_inherent_candidates(&mut self) {\n-        let steps = Lrc::clone(&self.steps);\n-        for step in steps.iter() {\n+        for step in self.steps.iter() {\n             self.assemble_probe(&step.self_ty);\n         }\n     }"}, {"sha": "3f0c3edfe09264c22bebdb2050ec87feffe98088", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -1696,7 +1696,7 @@ fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n         kind: ty::GenericParamDefKind::Lifetime,\n     }));\n \n-    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id);\n+    let object_lifetime_defaults = tcx.object_lifetime_defaults(hir_id.owner);\n \n     // Now create the real type and const parameters.\n     let type_start = own_start - has_self as u32 + params.len() as u32;"}, {"sha": "f0ae01f3803f408349c0f3c5cc286b17f461cf13", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/56cd04af5c389b6ab676ba16f59d9f70bc465090/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/56cd04af5c389b6ab676ba16f59d9f70bc465090/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=56cd04af5c389b6ab676ba16f59d9f70bc465090", "patch": "@@ -564,7 +564,7 @@ crate fn print_inlined_const(tcx: TyCtxt<'_>, did: DefId) -> String {\n         let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n         rustc_hir_pretty::id_to_string(&tcx.hir(), hir_id)\n     } else {\n-        tcx.rendered_const(did)\n+        tcx.rendered_const(did).clone()\n     }\n }\n "}]}