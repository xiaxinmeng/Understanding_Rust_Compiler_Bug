{"sha": "a5c6cb888eac7ad8905a3902b985e412aaceb002", "node_id": "C_kwDOAAsO6NoAKGE1YzZjYjg4OGVhYzdhZDg5MDVhMzkwMmI5ODVlNDEyYWFjZWIwMDI", "commit": {"author": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2022-08-01T20:51:58Z"}, "committer": {"name": "DrMeepster", "email": "19316085+DrMeepster@users.noreply.github.com", "date": "2023-06-16T20:41:06Z"}, "message": "remove box_free and replace with drop impl", "tree": {"sha": "18124f347f8405e4d746023018fa354580efac00", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/18124f347f8405e4d746023018fa354580efac00"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5c6cb888eac7ad8905a3902b985e412aaceb002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5c6cb888eac7ad8905a3902b985e412aaceb002", "html_url": "https://github.com/rust-lang/rust/commit/a5c6cb888eac7ad8905a3902b985e412aaceb002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5c6cb888eac7ad8905a3902b985e412aaceb002/comments", "author": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "DrMeepster", "id": 19316085, "node_id": "MDQ6VXNlcjE5MzE2MDg1", "avatar_url": "https://avatars.githubusercontent.com/u/19316085?v=4", "gravatar_id": "", "url": "https://api.github.com/users/DrMeepster", "html_url": "https://github.com/DrMeepster", "followers_url": "https://api.github.com/users/DrMeepster/followers", "following_url": "https://api.github.com/users/DrMeepster/following{/other_user}", "gists_url": "https://api.github.com/users/DrMeepster/gists{/gist_id}", "starred_url": "https://api.github.com/users/DrMeepster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/DrMeepster/subscriptions", "organizations_url": "https://api.github.com/users/DrMeepster/orgs", "repos_url": "https://api.github.com/users/DrMeepster/repos", "events_url": "https://api.github.com/users/DrMeepster/events{/privacy}", "received_events_url": "https://api.github.com/users/DrMeepster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0966f3202d1e811cd3aa35ac876b61a211b4819a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0966f3202d1e811cd3aa35ac876b61a211b4819a", "html_url": "https://github.com/rust-lang/rust/commit/0966f3202d1e811cd3aa35ac876b61a211b4819a"}], "stats": {"total": 237, "additions": 91, "deletions": 146}, "files": [{"sha": "79ca4c039854ede9da0d615c0d0f23f1535b65d9", "filename": "compiler/rustc_codegen_cranelift/example/mini_core.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fexample%2Fmini_core.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -546,7 +546,8 @@ impl<T> Box<T> {\n \n impl<T: ?Sized, A> Drop for Box<T, A> {\n     fn drop(&mut self) {\n-        // drop is currently performed by compiler.\n+        // inner value is dropped by compiler\n+        libc::free(self.0.pointer.0 as *mut u8);\n     }\n }\n \n@@ -563,11 +564,6 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     libc::malloc(size)\n }\n \n-#[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n-    libc::free(ptr.pointer.0 as *mut u8);\n-}\n-\n #[lang = \"drop\"]\n pub trait Drop {\n     fn drop(&mut self);"}, {"sha": "c27b610f2aba93d4f302e89e789a4b31fadb9bbf", "filename": "compiler/rustc_codegen_gcc/example/mini_core.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_gcc%2Fexample%2Fmini_core.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -490,7 +490,8 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized, A: Allocator> CoerceUnsized<Box<U, A>> fo\n \n impl<T: ?Sized, A: Allocator> Drop for Box<T, A> {\n     fn drop(&mut self) {\n-        // drop is currently performed by compiler.\n+        // inner value is dropped by compiler\n+        libc::free(self.pointer.0 as *mut u8);\n     }\n }\n \n@@ -507,11 +508,6 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     libc::malloc(size)\n }\n \n-#[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>, _alloc: ()) {\n-    libc::free(ptr.pointer.0 as *mut u8);\n-}\n-\n #[lang = \"drop\"]\n pub trait Drop {\n     fn drop(&mut self);"}, {"sha": "c717565d4d5e603e152483388c448961d93c6cc5", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -250,7 +250,6 @@ language_item_table! {\n     FormatUnsafeArg,         sym::format_unsafe_arg,   format_unsafe_arg,          Target::Struct,         GenericRequirement::None;\n \n     ExchangeMalloc,          sym::exchange_malloc,     exchange_malloc_fn,         Target::Fn,             GenericRequirement::None;\n-    BoxFree,                 sym::box_free,            box_free_fn,                Target::Fn,             GenericRequirement::Minimum(1);\n     DropInPlace,             sym::drop_in_place,       drop_in_place_fn,           Target::Fn,             GenericRequirement::Minimum(1);\n     AllocLayout,             sym::alloc_layout,        alloc_layout,               Target::Struct,         GenericRequirement::None;\n "}, {"sha": "4fc45eaf5220d4324f3ff91ee295e704957ed891", "filename": "compiler/rustc_mir_dataflow/src/elaborate_drops.rs", "status": "modified", "additions": 26, "deletions": 74, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_dataflow%2Fsrc%2Felaborate_drops.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -409,8 +409,15 @@ where\n         self.drop_ladder(fields, succ, unwind).0\n     }\n \n+    /// Drops the T contained in a `Box<T>` if it has not been moved out of\n     #[instrument(level = \"debug\", ret)]\n-    fn open_drop_for_box(&mut self, adt: ty::AdtDef<'tcx>, substs: SubstsRef<'tcx>) -> BasicBlock {\n+    fn open_drop_for_box_contents(\n+        &mut self,\n+        adt: ty::AdtDef<'tcx>,\n+        substs: SubstsRef<'tcx>,\n+        succ: BasicBlock,\n+        unwind: Unwind,\n+    ) -> BasicBlock {\n         // drop glue is sent straight to codegen\n         // box cannot be directly dereferenced\n         let unique_ty = adt.non_enum_variant().fields[FieldIdx::new(0)].ty(self.tcx(), substs);\n@@ -425,11 +432,7 @@ where\n \n         let interior_path = self.elaborator.deref_subpath(self.path);\n \n-        let succ = self.box_free_block(adt, substs, self.succ, self.unwind);\n-        let unwind_succ =\n-            self.unwind.map(|unwind| self.box_free_block(adt, substs, unwind, Unwind::InCleanup));\n-\n-        self.drop_subpath(interior, interior_path, succ, unwind_succ)\n+        self.drop_subpath(interior, interior_path, succ, unwind)\n     }\n \n     #[instrument(level = \"debug\", ret)]\n@@ -453,7 +456,15 @@ where\n             self.open_drop_for_adt_contents(adt, substs)\n         };\n \n-        if adt.has_dtor(self.tcx()) {\n+        if adt.is_box() {\n+            // we need to drop the inside of the box before running the destructor\n+            let succ = self.destructor_call_block(contents_drop);\n+            let unwind = contents_drop\n+                .1\n+                .map(|unwind| self.destructor_call_block((unwind, Unwind::InCleanup)));\n+\n+            self.open_drop_for_box_contents(adt, substs, succ, unwind)\n+        } else if adt.has_dtor(self.tcx()) {\n             self.destructor_call_block(contents_drop)\n         } else {\n             contents_drop.0\n@@ -650,7 +661,13 @@ where\n             }),\n             is_cleanup: unwind.is_cleanup(),\n         };\n-        self.elaborator.patch().new_block(result)\n+\n+        let destructor_block = self.elaborator.patch().new_block(result);\n+\n+        let block_start = Location { block: destructor_block, statement_index: 0 };\n+        self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n+\n+        self.drop_flag_test_block(destructor_block, succ, unwind)\n     }\n \n     /// Create a loop that drops an array:\n@@ -851,13 +868,7 @@ where\n                 self.open_drop_for_tuple(&tys)\n             }\n             ty::Tuple(fields) => self.open_drop_for_tuple(fields),\n-            ty::Adt(def, substs) => {\n-                if def.is_box() {\n-                    self.open_drop_for_box(*def, substs)\n-                } else {\n-                    self.open_drop_for_adt(*def, substs)\n-                }\n-            }\n+            ty::Adt(def, substs) => self.open_drop_for_adt(*def, substs),\n             ty::Dynamic(..) => self.complete_drop(self.succ, self.unwind),\n             ty::Array(ety, size) => {\n                 let size = size.try_eval_target_usize(self.tcx(), self.elaborator.param_env());\n@@ -905,65 +916,6 @@ where\n         blk\n     }\n \n-    /// Creates a block that frees the backing memory of a `Box` if its drop is required (either\n-    /// statically or by checking its drop flag).\n-    ///\n-    /// The contained value will not be dropped.\n-    fn box_free_block(\n-        &mut self,\n-        adt: ty::AdtDef<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        target: BasicBlock,\n-        unwind: Unwind,\n-    ) -> BasicBlock {\n-        let block = self.unelaborated_free_block(adt, substs, target, unwind);\n-        self.drop_flag_test_block(block, target, unwind)\n-    }\n-\n-    /// Creates a block that frees the backing memory of a `Box` (without dropping the contained\n-    /// value).\n-    fn unelaborated_free_block(\n-        &mut self,\n-        adt: ty::AdtDef<'tcx>,\n-        substs: SubstsRef<'tcx>,\n-        target: BasicBlock,\n-        unwind: Unwind,\n-    ) -> BasicBlock {\n-        let tcx = self.tcx();\n-        let unit_temp = Place::from(self.new_temp(tcx.mk_unit()));\n-        let free_func = tcx.require_lang_item(LangItem::BoxFree, Some(self.source_info.span));\n-        let args = adt\n-            .variant(FIRST_VARIANT)\n-            .fields\n-            .iter()\n-            .enumerate()\n-            .map(|(i, f)| {\n-                let field = FieldIdx::new(i);\n-                let field_ty = f.ty(tcx, substs);\n-                Operand::Move(tcx.mk_place_field(self.place, field, field_ty))\n-            })\n-            .collect();\n-\n-        let call = TerminatorKind::Call {\n-            func: Operand::function_handle(tcx, free_func, substs, self.source_info.span),\n-            args,\n-            destination: unit_temp,\n-            target: Some(target),\n-            unwind: if unwind.is_cleanup() {\n-                UnwindAction::Terminate\n-            } else {\n-                UnwindAction::Continue\n-            },\n-            from_hir_call: false,\n-            fn_span: self.source_info.span,\n-        }; // FIXME(#43234)\n-        let free_block = self.new_block(unwind, call);\n-\n-        let block_start = Location { block: free_block, statement_index: 0 };\n-        self.elaborator.clear_drop_flag(block_start, self.path, DropFlagMode::Shallow);\n-        free_block\n-    }\n-\n     fn drop_block(&mut self, target: BasicBlock, unwind: Unwind) -> BasicBlock {\n         let block = TerminatorKind::Drop {\n             place: self.place,"}, {"sha": "4a5953c11492cffef57490eb87e9c86b62198daa", "filename": "compiler/rustc_monomorphize/src/collector.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Fcollector.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -123,12 +123,6 @@\n //! pointers to these functions even if they never get called anywhere. This can\n //! be seen as a special case of taking a function reference.\n //!\n-//! #### Boxes\n-//! Since `Box` expression have special compiler support, no explicit calls to\n-//! `exchange_malloc()` and `box_free()` may show up in MIR, even if the\n-//! compiler will generate them. We have to observe `Rvalue::Box` expressions\n-//! and Box-typed drop-statements for that purpose.\n-//!\n //!\n //! Interaction with Cross-Crate Inlining\n //! -------------------------------------"}, {"sha": "7f7262f54e5cc1d72d810417bcc512ef8e0ac83a", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -432,7 +432,6 @@ symbols! {\n         bool,\n         borrowck_graphviz_format,\n         borrowck_graphviz_postflow,\n-        box_free,\n         box_new,\n         box_patterns,\n         box_syntax,"}, {"sha": "e24a0fe51bda0bc64f357c135fdde068b764de83", "filename": "library/alloc/src/alloc.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Falloc.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -4,8 +4,10 @@\n \n #[cfg(not(test))]\n use core::intrinsics;\n+#[cfg(all(bootstrap, not(test)))]\n use core::intrinsics::{min_align_of_val, size_of_val};\n \n+#[cfg(all(bootstrap, not(test)))]\n use core::ptr::Unique;\n #[cfg(not(test))]\n use core::ptr::{self, NonNull};\n@@ -335,14 +337,15 @@ unsafe fn exchange_malloc(size: usize, align: usize) -> *mut u8 {\n     }\n }\n \n-#[cfg_attr(not(test), lang = \"box_free\")]\n+#[cfg(all(bootstrap, not(test)))]\n+#[lang = \"box_free\"]\n #[inline]\n // This signature has to be the same as `Box`, otherwise an ICE will happen.\n // When an additional parameter to `Box` is added (like `A: Allocator`), this has to be added here as\n // well.\n // For example if `Box` is changed to  `struct Box<T: ?Sized, A: Allocator>(Unique<T>, A)`,\n // this function has to be changed to `fn box_free<T: ?Sized, A: Allocator>(Unique<T>, A)` as well.\n-pub(crate) unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n+unsafe fn box_free<T: ?Sized, A: Allocator>(ptr: Unique<T>, alloc: A) {\n     unsafe {\n         let size = size_of_val(ptr.as_ref());\n         let align = min_align_of_val(ptr.as_ref());"}, {"sha": "8ef2bac9282cd4d417d78b622b317939b1d976a5", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -1211,8 +1211,16 @@ impl<T: ?Sized, A: Allocator> Box<T, A> {\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<#[may_dangle] T: ?Sized, A: Allocator> Drop for Box<T, A> {\n+    #[inline]\n     fn drop(&mut self) {\n-        // FIXME: Do nothing, drop is currently performed by compiler.\n+        // the T in the Box is dropped by the compiler before the destructor is run\n+\n+        let ptr = self.0;\n+\n+        unsafe {\n+            let layout = Layout::for_value_raw(ptr.as_ptr());\n+            self.1.deallocate(From::from(ptr.cast()), layout)\n+        }\n     }\n }\n "}, {"sha": "34d3acae5464cb911b413e45a81ce8fb0cf4ef3b", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -270,7 +270,7 @@ use core::slice::from_raw_parts_mut;\n #[cfg(not(no_global_oom_handling))]\n use crate::alloc::handle_alloc_error;\n #[cfg(not(no_global_oom_handling))]\n-use crate::alloc::{box_free, WriteCloneIntoRaw};\n+use crate::alloc::WriteCloneIntoRaw;\n use crate::alloc::{AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n #[cfg(not(no_global_oom_handling))]\n@@ -1442,23 +1442,21 @@ impl<T: ?Sized> Rc<T> {\n     }\n \n     #[cfg(not(no_global_oom_handling))]\n-    fn from_box(v: Box<T>) -> Rc<T> {\n+    fn from_box(src: Box<T>) -> Rc<T> {\n         unsafe {\n-            let (box_unique, alloc) = Box::into_unique(v);\n-            let bptr = box_unique.as_ptr();\n-\n-            let value_size = size_of_val(&*bptr);\n-            let ptr = Self::allocate_for_ptr(bptr);\n+            let value_size = size_of_val(&*src);\n+            let ptr = Self::allocate_for_ptr(&*src);\n \n             // Copy value as bytes\n             ptr::copy_nonoverlapping(\n-                bptr as *const T as *const u8,\n+                &*src as *const T as *const u8,\n                 &mut (*ptr).value as *mut _ as *mut u8,\n                 value_size,\n             );\n \n             // Free the allocation without dropping its contents\n-            box_free(box_unique, alloc);\n+            let src = Box::from_raw(Box::into_raw(src) as *mut mem::ManuallyDrop<T>);\n+            drop(src);\n \n             Self::from_ptr(ptr)\n         }"}, {"sha": "d2c87cf705c61ecdd18373a50b9aef31c6e1a2ff", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -33,7 +33,7 @@ use core::sync::atomic::Ordering::{Acquire, Relaxed, Release};\n #[cfg(not(no_global_oom_handling))]\n use crate::alloc::handle_alloc_error;\n #[cfg(not(no_global_oom_handling))]\n-use crate::alloc::{box_free, WriteCloneIntoRaw};\n+use crate::alloc::WriteCloneIntoRaw;\n use crate::alloc::{AllocError, Allocator, Global, Layout};\n use crate::borrow::{Cow, ToOwned};\n use crate::boxed::Box;\n@@ -1360,23 +1360,21 @@ impl<T: ?Sized> Arc<T> {\n     }\n \n     #[cfg(not(no_global_oom_handling))]\n-    fn from_box(v: Box<T>) -> Arc<T> {\n+    fn from_box(src: Box<T>) -> Arc<T> {\n         unsafe {\n-            let (box_unique, alloc) = Box::into_unique(v);\n-            let bptr = box_unique.as_ptr();\n-\n-            let value_size = size_of_val(&*bptr);\n-            let ptr = Self::allocate_for_ptr(bptr);\n+            let value_size = size_of_val(&*src);\n+            let ptr = Self::allocate_for_ptr(&*src);\n \n             // Copy value as bytes\n             ptr::copy_nonoverlapping(\n-                bptr as *const T as *const u8,\n+                &*src as *const T as *const u8,\n                 &mut (*ptr).data as *mut _ as *mut u8,\n                 value_size,\n             );\n \n             // Free the allocation without dropping its contents\n-            box_free(box_unique, alloc);\n+            let src = Box::from_raw(Box::into_raw(src) as *mut mem::ManuallyDrop<T>);\n+            drop(src);\n \n             Self::from_ptr(ptr)\n         }"}, {"sha": "f4bc18bc7dabd3c4dd2ff008f4847fa80ea50e99", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -11,8 +11,8 @@ it exists. The marker is the attribute `#[lang = \"...\"]` and there are\n various different values of `...`, i.e. various different 'lang\n items'.\n \n-For example, `Box` pointers require two lang items, one for allocation\n-and one for deallocation. A freestanding program that uses the `Box`\n+For example, `Box` pointers require a lang item for allocation.\n+A freestanding program that uses the `Box`\n sugar for dynamic allocations via `malloc` and `free`:\n \n ```rust,ignore (libc-is-finicky)\n@@ -48,9 +48,10 @@ unsafe fn allocate(size: usize, _align: usize) -> *mut u8 {\n     p\n }\n \n-#[lang = \"box_free\"]\n-unsafe fn box_free<T: ?Sized>(ptr: *mut T) {\n-    libc::free(ptr as *mut libc::c_void)\n+impl<T> Drop for Box<T> {\n+    fn drop(&mut self) {\n+      libc::free(self.0.0.0 as *mut libc::c_void)\n+    }\n }\n \n #[start]\n@@ -84,8 +85,8 @@ Other features provided by lang items include:\n   `contravariant_lifetime`, etc.\n \n Lang items are loaded lazily by the compiler; e.g. if one never uses\n-`Box` then there is no need to define functions for `exchange_malloc`\n-and `box_free`. `rustc` will emit an error when an item is needed\n+`Box` then there is no need to define a function for `exchange_malloc`.\n+`rustc` will emit an error when an item is needed\n but not found in the current crate or any that it depends on.\n \n Most lang items are defined by `libcore`, but if you're trying to build\n@@ -250,7 +251,6 @@ the source code.\n - Allocations\n   - `owned_box`: `liballoc/boxed.rs`\n   - `exchange_malloc`: `liballoc/heap.rs`\n-  - `box_free`: `liballoc/heap.rs`\n - Operands\n   - `not`: `libcore/ops/bit.rs`\n   - `bitand`: `libcore/ops/bit.rs`"}, {"sha": "7c14d372f0c7cc6690d427c6a0789a1e8713d16d", "filename": "src/tools/miri/tests/fail/alloc/stack_free.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Falloc%2Fstack_free.stderr?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -9,7 +9,7 @@ LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n    = note: BACKTRACE:\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n    = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<i32, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::boxed::Box<i32> as std::ops::Drop>::drop` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::ptr::drop_in_place::<std::boxed::Box<i32>> - shim(Some(std::boxed::Box<i32>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n    = note: inside `std::mem::drop::<std::boxed::Box<i32>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n note: inside `main`"}, {"sha": "8ebb35450e5fa0eb1dae47dd4952af76eb1a99ce", "filename": "src/tools/miri/tests/fail/stacked_borrows/deallocate_against_protector1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fdeallocate_against_protector1.stderr?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -9,7 +9,7 @@ LL |     unsafe { __rust_dealloc(ptr, layout.size(), layout.align()) }\n    = note: BACKTRACE:\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n    = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<i32, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::boxed::Box<i32> as std::ops::Drop>::drop` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::ptr::drop_in_place::<std::boxed::Box<i32>> - shim(Some(std::boxed::Box<i32>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n    = note: inside `std::mem::drop::<std::boxed::Box<i32>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n note: inside closure"}, {"sha": "55665e63e8a7e6875e697d57e75acd00d638bef9", "filename": "src/tools/miri/tests/fail/tree-borrows/strongly-protected.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fstrongly-protected.stderr?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -20,7 +20,7 @@ LL | fn inner(x: &mut i32, f: fn(&mut i32)) {\n    = note: BACKTRACE (of the first span):\n    = note: inside `std::alloc::dealloc` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n    = note: inside `<std::alloc::Global as std::alloc::Allocator>::deallocate` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n-   = note: inside `alloc::alloc::box_free::<i32, std::alloc::Global>` at RUSTLIB/alloc/src/alloc.rs:LL:CC\n+   = note: inside `<std::boxed::Box<i32> as std::ops::Drop>::drop` at RUSTLIB/alloc/src/boxed.rs:LL:CC\n    = note: inside `std::ptr::drop_in_place::<std::boxed::Box<i32>> - shim(Some(std::boxed::Box<i32>))` at RUSTLIB/core/src/ptr/mod.rs:LL:CC\n    = note: inside `std::mem::drop::<std::boxed::Box<i32>>` at RUSTLIB/core/src/mem/mod.rs:LL:CC\n note: inside closure"}, {"sha": "011a253c6ff6146c95c0ea1b3127e0f0efc878f3", "filename": "tests/assembly/stack-protector/stack-protector-heuristics-effect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fassembly%2Fstack-protector%2Fstack-protector-heuristics-effect.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -370,7 +370,7 @@ pub fn unsized_fn_param(s: [u8], l: bool, f: fn([u8])) {\n \n \n     // all: __stack_chk_fail\n-    // strong-NOT: __stack_chk_fail\n+    // strong: __stack_chk_fail\n     // basic-NOT: __stack_chk_fail\n     // none-NOT: __stack_chk_fail\n     // missing-NOT: __stack_chk_fail"}, {"sha": "6ee6a0ffe4cdee9ff6c23a0f43b687678bf480d3", "filename": "tests/mir-opt/inline/unsized_argument.caller.Inline.diff", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fmir-opt%2Finline%2Funsized_argument.caller.Inline.diff", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fmir-opt%2Finline%2Funsized_argument.caller.Inline.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Finline%2Funsized_argument.caller.Inline.diff?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -6,36 +6,41 @@\n       let mut _0: ();\n       let _2: ();\n       let mut _3: std::boxed::Box<[i32]>;\n-      let mut _4: ();\n+      let mut _4: &mut std::boxed::Box<[i32]>;\n       let mut _5: ();\n-      let mut _6: ();\n-      let mut _7: *const [i32];\n+      let mut _6: &mut std::boxed::Box<[i32]>;\n+      let mut _7: ();\n+      let mut _8: &mut std::boxed::Box<[i32]>;\n+      let mut _9: ();\n+      let mut _10: *const [i32];\n   \n       bb0: {\n           StorageLive(_2);\n           StorageLive(_3);\n           _3 = move _1;\n-          _7 = (((_3.0: std::ptr::Unique<[i32]>).0: std::ptr::NonNull<[i32]>).0: *const [i32]);\n-          _2 = callee(move (*_7)) -> [return: bb3, unwind: bb4];\n+          _10 = (((_3.0: std::ptr::Unique<[i32]>).0: std::ptr::NonNull<[i32]>).0: *const [i32]);\n+          _2 = callee(move (*_10)) -> [return: bb3, unwind: bb4];\n       }\n   \n-      bb1: {\n+      bb1 (cleanup): {\n+          resume;\n+      }\n+  \n+      bb2: {\n           StorageDead(_3);\n           StorageDead(_2);\n           _0 = const ();\n           return;\n       }\n   \n-      bb2 (cleanup): {\n-          resume;\n-      }\n-  \n       bb3: {\n-          _4 = alloc::alloc::box_free::<[i32], std::alloc::Global>(move (_3.0: std::ptr::Unique<[i32]>), move (_3.1: std::alloc::Global)) -> bb1;\n+          _4 = &mut _3;\n+          _5 = <Box<[i32]> as Drop>::drop(move _4) -> [return: bb2, unwind: bb1];\n       }\n   \n       bb4 (cleanup): {\n-          _6 = alloc::alloc::box_free::<[i32], std::alloc::Global>(move (_3.0: std::ptr::Unique<[i32]>), move (_3.1: std::alloc::Global)) -> [return: bb2, unwind terminate];\n+          _8 = &mut _3;\n+          _9 = <Box<[i32]> as Drop>::drop(move _8) -> [return: bb1, unwind terminate];\n       }\n   }\n   "}, {"sha": "534f1c465bb872020611a444bb1dad8991c42ab7", "filename": "tests/ui/mir/ssa-analysis-regression-50041.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5c6cb888eac7ad8905a3902b985e412aaceb002/tests%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fmir%2Fssa-analysis-regression-50041.rs?ref=a5c6cb888eac7ad8905a3902b985e412aaceb002", "patch": "@@ -13,13 +13,10 @@ struct Unique<T: ?Sized>(NonNull<T>);\n pub struct Box<T: ?Sized>(Unique<T>);\n \n impl<T: ?Sized> Drop for Box<T> {\n-    fn drop(&mut self) {}\n-}\n-\n-#[lang = \"box_free\"]\n-#[inline(always)]\n-unsafe fn box_free<T: ?Sized>(ptr: Unique<T>) {\n-    dealloc(ptr.0.0)\n+    #[inline(always)]\n+    fn drop(&mut self) {\n+        dealloc(self.0.0.0)\n+    }\n }\n \n #[inline(never)]"}]}