{"sha": "df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "node_id": "C_kwDOAAsO6NoAKGRmMDdjOGZhZmE3OGFjZTRjNGQyZGVkODJkNTYxZjc2YTM1ZTBhZGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T08:16:14Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-06T08:16:14Z"}, "message": "Auto merge of #13730 - lowr:feat/builtin-macro-helper-attr, r=Veykril\n\nSupport builtin derive macro helper attributes\n\nCloses #13244\n\nIt's a bit wasteful for `Macro2Data` to have `helpers` field currently just for `Default` derive macro, but I tend to think it's okay for the time being given how rare macro2's are used.", "tree": {"sha": "5600e72c365890099c3b4805a4b63f4113bb3687", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5600e72c365890099c3b4805a4b63f4113bb3687"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "html_url": "https://github.com/rust-lang/rust/commit/df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9bd48770832a8556ccd1b8e9f147d3f16bcc44a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9bd48770832a8556ccd1b8e9f147d3f16bcc44a", "html_url": "https://github.com/rust-lang/rust/commit/f9bd48770832a8556ccd1b8e9f147d3f16bcc44a"}, {"sha": "051c6598bedadcb65710276d1ee853e3743730a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/051c6598bedadcb65710276d1ee853e3743730a3", "html_url": "https://github.com/rust-lang/rust/commit/051c6598bedadcb65710276d1ee853e3743730a3"}], "stats": {"total": 153, "additions": 113, "deletions": 40}, "files": [{"sha": "b78ab71ef21bd69e5506afc0c2d2747ab647a010", "filename": "crates/hir-def/src/data.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fdata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fdata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fdata.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -13,7 +13,9 @@ use crate::{\n     intern::Interned,\n     item_tree::{self, AssocItem, FnFlags, ItemTree, ItemTreeId, ModItem, Param, TreeId},\n     nameres::{\n-        attr_resolution::ResolvedAttr, diagnostics::DefDiagnostic, proc_macro::ProcMacroKind,\n+        attr_resolution::ResolvedAttr,\n+        diagnostics::DefDiagnostic,\n+        proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroKind},\n         DefMap,\n     },\n     type_ref::{TraitRef, TypeBound, TypeRef},\n@@ -348,6 +350,10 @@ impl ImplData {\n pub struct Macro2Data {\n     pub name: Name,\n     pub visibility: RawVisibility,\n+    // It's a bit wasteful as currently this is only for builtin `Default` derive macro, but macro2\n+    // are rarely used in practice so I think it's okay for now.\n+    /// Derive helpers, if this is a derive rustc_builtin_macro\n+    pub helpers: Option<Box<[Name]>>,\n }\n \n impl Macro2Data {\n@@ -356,9 +362,18 @@ impl Macro2Data {\n         let item_tree = loc.id.item_tree(db);\n         let makro = &item_tree[loc.id.value];\n \n+        let helpers = item_tree\n+            .attrs(db, loc.container.krate(), ModItem::from(loc.id.value).into())\n+            .by_key(\"rustc_builtin_macro\")\n+            .tt_values()\n+            .next()\n+            .and_then(|attr| parse_macro_name_and_helper_attrs(&attr.token_trees))\n+            .map(|(_, helpers)| helpers);\n+\n         Arc::new(Macro2Data {\n             name: makro.name.clone(),\n             visibility: item_tree[makro.visibility].clone(),\n+            helpers,\n         })\n     }\n }"}, {"sha": "f21d674f20d6a60405d048580e29f8120a6882c1", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -40,7 +40,7 @@ use crate::{\n         diagnostics::DefDiagnostic,\n         mod_resolution::ModDir,\n         path_resolution::ReachedFixedPoint,\n-        proc_macro::{ProcMacroDef, ProcMacroKind},\n+        proc_macro::{parse_macro_name_and_helper_attrs, ProcMacroDef, ProcMacroKind},\n         BuiltinShadowMode, DefMap, ModuleData, ModuleOrigin, ResolveMode,\n     },\n     path::{ImportAlias, ModPath, PathKind},\n@@ -2005,6 +2005,7 @@ impl ModCollector<'_, '_> {\n         let ast_id = InFile::new(self.file_id(), mac.ast_id.upcast());\n \n         // Case 1: builtin macros\n+        let mut helpers_opt = None;\n         let attrs = self.item_tree.attrs(self.def_collector.db, krate, ModItem::from(id).into());\n         let expander = if attrs.by_key(\"rustc_builtin_macro\").exists() {\n             if let Some(expander) = find_builtin_macro(&mac.name) {\n@@ -2013,6 +2014,25 @@ impl ModCollector<'_, '_> {\n                     Either::Right(it) => MacroExpander::BuiltInEager(it),\n                 }\n             } else if let Some(expander) = find_builtin_derive(&mac.name) {\n+                if let Some(attr) = attrs.by_key(\"rustc_builtin_macro\").tt_values().next() {\n+                    // NOTE: The item *may* have both `#[rustc_builtin_macro]` and `#[proc_macro_derive]`,\n+                    // in which case rustc ignores the helper attributes from the latter, but it\n+                    // \"doesn't make sense in practice\" (see rust-lang/rust#87027).\n+                    if let Some((name, helpers)) =\n+                        parse_macro_name_and_helper_attrs(&attr.token_trees)\n+                    {\n+                        // NOTE: rustc overrides the name if the macro name if it's different from the\n+                        // macro name, but we assume it isn't as there's no such case yet. FIXME if\n+                        // the following assertion fails.\n+                        stdx::always!(\n+                            name == mac.name,\n+                            \"built-in macro {} has #[rustc_builtin_macro] which declares different name {}\",\n+                            mac.name,\n+                            name\n+                        );\n+                        helpers_opt = Some(helpers);\n+                    }\n+                }\n                 MacroExpander::BuiltInDerive(expander)\n             } else if let Some(expander) = find_builtin_attr(&mac.name) {\n                 MacroExpander::BuiltInAttr(expander)\n@@ -2037,6 +2057,12 @@ impl ModCollector<'_, '_> {\n             macro_id,\n             &self.item_tree[mac.visibility],\n         );\n+        if let Some(helpers) = helpers_opt {\n+            self.def_collector\n+                .def_map\n+                .exported_derives\n+                .insert(macro_id_to_def_id(self.def_collector.db, macro_id.into()), helpers);\n+        }\n     }\n \n     fn collect_macro_call(&mut self, mac: &MacroCall, container: ItemContainerId) {"}, {"sha": "06b23392cfe46f4e167ec364f4fcc7e016871b47", "filename": "crates/hir-def/src/nameres/proc_macro.rs", "status": "modified", "additions": 43, "deletions": 35, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fproc_macro.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -37,45 +37,53 @@ impl Attrs {\n             Some(ProcMacroDef { name: func_name.clone(), kind: ProcMacroKind::Attr })\n         } else if self.by_key(\"proc_macro_derive\").exists() {\n             let derive = self.by_key(\"proc_macro_derive\").tt_values().next()?;\n+            let def = parse_macro_name_and_helper_attrs(&derive.token_trees)\n+                .map(|(name, helpers)| ProcMacroDef { name, kind: ProcMacroKind::CustomDerive { helpers } });\n \n-            match &*derive.token_trees {\n-                // `#[proc_macro_derive(Trait)]`\n-                [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some(ProcMacroDef {\n-                    name: trait_name.as_name(),\n-                    kind: ProcMacroKind::CustomDerive { helpers: Box::new([]) },\n-                }),\n-\n-                // `#[proc_macro_derive(Trait, attributes(helper1, helper2, ...))]`\n-                [\n-                    TokenTree::Leaf(Leaf::Ident(trait_name)),\n-                    TokenTree::Leaf(Leaf::Punct(comma)),\n-                    TokenTree::Leaf(Leaf::Ident(attributes)),\n-                    TokenTree::Subtree(helpers)\n-                ] if comma.char == ',' && attributes.text == \"attributes\" =>\n-                {\n-                    let helpers = helpers.token_trees.iter()\n-                        .filter(|tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','))\n-                        .map(|tt| {\n-                            match tt {\n-                                TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n-                                _ => None\n-                            }\n-                        })\n-                        .collect::<Option<Box<[_]>>>()?;\n-\n-                    Some(ProcMacroDef {\n-                        name: trait_name.as_name(),\n-                        kind: ProcMacroKind::CustomDerive { helpers },\n-                    })\n-                }\n-\n-                _ => {\n-                    tracing::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n-                    None\n-                }\n+            if def.is_none() {\n+                tracing::trace!(\"malformed `#[proc_macro_derive]`: {}\", derive);\n             }\n+\n+            def\n         } else {\n             None\n         }\n     }\n }\n+\n+// This fn is intended for `#[proc_macro_derive(..)]` and `#[rustc_builtin_macro(..)]`, which have\n+// the same strucuture.\n+#[rustfmt::skip]\n+pub(crate) fn parse_macro_name_and_helper_attrs(tt: &[TokenTree]) -> Option<(Name, Box<[Name]>)> {\n+    match tt {\n+        // `#[proc_macro_derive(Trait)]`\n+        // `#[rustc_builtin_macro(Trait)]`\n+        [TokenTree::Leaf(Leaf::Ident(trait_name))] => Some((trait_name.as_name(), Box::new([]))),\n+\n+        // `#[proc_macro_derive(Trait, attributes(helper1, helper2, ...))]`\n+        // `#[rustc_builtin_macro(Trait, attributes(helper1, helper2, ...))]`\n+        [\n+            TokenTree::Leaf(Leaf::Ident(trait_name)),\n+            TokenTree::Leaf(Leaf::Punct(comma)),\n+            TokenTree::Leaf(Leaf::Ident(attributes)),\n+            TokenTree::Subtree(helpers)\n+        ] if comma.char == ',' && attributes.text == \"attributes\" =>\n+        {\n+            let helpers = helpers\n+                .token_trees\n+                .iter()\n+                .filter(\n+                    |tt| !matches!(tt, TokenTree::Leaf(Leaf::Punct(comma)) if comma.char == ','),\n+                )\n+                .map(|tt| match tt {\n+                    TokenTree::Leaf(Leaf::Ident(helper)) => Some(helper.as_name()),\n+                    _ => None,\n+                })\n+                .collect::<Option<Box<[_]>>>()?;\n+\n+            Some((trait_name.as_name(), helpers))\n+        }\n+\n+        _ => None,\n+    }\n+}"}, {"sha": "fe0ad4f3863c469aaae629dc121d1d764e8d8586", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -822,6 +822,28 @@ fn derive() {}\n     );\n }\n \n+#[test]\n+fn resolves_derive_helper_rustc_builtin_macro() {\n+    cov_mark::check!(resolved_derive_helper);\n+    // This is NOT the correct usage of `default` helper attribute, but we don't resolve helper\n+    // attributes on non mod items in hir nameres.\n+    check(\n+        r#\"\n+//- minicore: derive, default\n+#[derive(Default)]\n+#[default]\n+enum E {\n+    A,\n+    B,\n+}\n+\"#,\n+        expect![[r#\"\n+            crate\n+            E: t\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn unresolved_attr_with_cfg_attr_hang() {\n     // Another regression test for https://github.com/rust-lang/rust-analyzer/issues/8905"}, {"sha": "5f36ce62f87f49dd75c583c2337cc9c69099fe05", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -2349,12 +2349,14 @@ impl DeriveHelper {\n \n     pub fn name(&self, db: &dyn HirDatabase) -> Name {\n         match self.derive {\n-            MacroId::Macro2Id(_) => None,\n+            MacroId::Macro2Id(it) => {\n+                db.macro2_data(it).helpers.as_deref().and_then(|it| it.get(self.idx)).cloned()\n+            }\n             MacroId::MacroRulesId(_) => None,\n             MacroId::ProcMacroId(proc_macro) => db\n                 .proc_macro_data(proc_macro)\n                 .helpers\n-                .as_ref()\n+                .as_deref()\n                 .and_then(|it| it.get(self.idx))\n                 .cloned(),\n         }"}, {"sha": "013fd6b4fdf1732b7935e34706845076f0979812", "filename": "crates/test-utils/src/minicore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/df07c8fafa78ace4c4d2ded82d561f76a35e0ade/crates%2Ftest-utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest-utils%2Fsrc%2Fminicore.rs?ref=df07c8fafa78ace4c4d2ded82d561f76a35e0ade", "patch": "@@ -112,7 +112,7 @@ pub mod default {\n         fn default() -> Self;\n     }\n     // region:derive\n-    #[rustc_builtin_macro]\n+    #[rustc_builtin_macro(Default, attributes(default))]\n     pub macro Default($item:item) {}\n     // endregion:derive\n }"}]}