{"sha": "ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmYjkwNDkyNzRiZWFhYzhkZGRlNmI5NjMyZDhjOWFjNzcxNWY5ZDE=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-21T22:25:57Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-01-22T13:09:53Z"}, "message": "add a Mutable container trait with clear", "tree": {"sha": "6521f4df09db86beda63fd542dc38b834ce508f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6521f4df09db86beda63fd542dc38b834ce508f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "html_url": "https://github.com/rust-lang/rust/commit/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e50892c1840a030892b2dc6480d42635990b0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/66e50892c1840a030892b2dc6480d42635990b0c", "html_url": "https://github.com/rust-lang/rust/commit/66e50892c1840a030892b2dc6480d42635990b0c"}], "stats": {"total": 82, "additions": 68, "deletions": 14}, "files": [{"sha": "f8ccd0148ab7150b87270ed5228a3d63d3273a6e", "filename": "src/libcore/container.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "patch": "@@ -10,7 +10,12 @@\n \n //! Container traits\n \n-pub trait Set<T> {\n+pub trait Mutable {\n+    /// Clear the container, removing all values.\n+    fn clear(&mut self);\n+}\n+\n+pub trait Set<T>: Mutable {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool;\n "}, {"sha": "5f440aa6d37bd155f0a6d4988999b87e4af0dab1", "filename": "src/libcore/send_map.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibcore%2Fsend_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibcore%2Fsend_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsend_map.rs?ref=ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "patch": "@@ -31,7 +31,6 @@ pub trait SendMap<K:Eq Hash, V: Copy> {\n     fn pop(&mut self, k: &K) -> Option<V>;\n     fn swap(&mut self, k: K, +v: V) -> Option<V>;\n     fn consume(&mut self, f: fn(K, V));\n-    fn clear(&mut self);\n     pure fn len(&const self) -> uint;\n     pure fn is_empty(&const self) -> bool;\n     pure fn contains_key(&const self, k: &K) -> bool;\n@@ -47,7 +46,7 @@ pub trait SendMap<K:Eq Hash, V: Copy> {\n /// Open addressing with linear probing.\n pub mod linear {\n     use iter::BaseIter;\n-    use container::Set;\n+    use container::{Mutable, Set};\n     use cmp::Eq;\n     use cmp;\n     use hash::Hash;\n@@ -279,6 +278,15 @@ pub mod linear {\n         }\n     }\n \n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Mutable {\n+        fn clear(&mut self) {\n+            for uint::range(0, self.buckets.len()) |idx| {\n+                self.buckets[idx] = None;\n+            }\n+            self.size = 0;\n+        }\n+    }\n+\n     impl<K:Hash IterBytes Eq,V> LinearMap<K,V> {\n         fn insert(&mut self, k: K, v: V) -> bool {\n             if self.size >= self.resize_at {\n@@ -347,13 +355,6 @@ pub mod linear {\n             }\n         }\n \n-        fn clear(&mut self) {\n-            for uint::range(0, self.buckets.len()) |idx| {\n-                self.buckets[idx] = None;\n-            }\n-            self.size = 0;\n-        }\n-\n         pure fn len(&const self) -> uint {\n             self.size\n         }\n@@ -482,6 +483,10 @@ pub mod linear {\n         }\n     }\n \n+    impl <T: Hash IterBytes Eq> LinearSet<T>: Mutable {\n+        fn clear(&mut self) { self.map.clear() }\n+    }\n+\n     impl <T: Hash IterBytes Eq> LinearSet<T>: Set<T> {\n         /// Return true if the set contains a value\n         pure fn contains(&self, value: &T) -> bool {"}, {"sha": "0ff40b6421a90f54d25756800065997a43c096c9", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "patch": "@@ -10,6 +10,7 @@\n \n //! A priority queue implemented with a binary heap\n \n+use core::container::Mutable;\n use core::cmp::Ord;\n use core::prelude::*;\n use core::ptr::addr_of;\n@@ -24,6 +25,11 @@ pub struct PriorityQueue <T: Ord>{\n     priv data: ~[T],\n }\n \n+impl <T: Ord> PriorityQueue<T>: Mutable {\n+    /// Drop all items from the queue\n+    fn clear(&mut self) { self.data.truncate(0) }\n+}\n+\n impl <T: Ord> PriorityQueue<T> {\n     /// Returns the greatest item in the queue - fails if empty\n     pure fn top(&self) -> &self/T { &self.data[0] }\n@@ -51,9 +57,6 @@ impl <T: Ord> PriorityQueue<T> {\n         vec::reserve_at_least(&mut self.data, n)\n     }\n \n-    /// Drop all items from the queue\n-    fn clear(&mut self) { self.data.truncate(0) }\n-\n     /// Pop the greatest item from the queue - fails if empty\n     fn pop(&mut self) -> T {\n         let mut item = self.data.pop();"}, {"sha": "74a14b7903cc0c00ed1bafa63a6055dc46efdc82", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ffb9049274beaac8ddde6b9632d8c9ac7715f9d1/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=ffb9049274beaac8ddde6b9632d8c9ac7715f9d1", "patch": "@@ -14,7 +14,7 @@\n \n #[forbid(deprecated_mode)];\n \n-use core::container::Set;\n+use core::container::{Mutable, Set};\n use core::cmp::{Eq, Ord};\n use core::option::{Option, Some, None};\n use core::prelude::*;\n@@ -67,6 +67,14 @@ impl <K: Eq Ord, V: Eq> TreeMap<K, V>: Eq {\n     pure fn ne(&self, other: &TreeMap<K, V>) -> bool { !self.eq(other) }\n }\n \n+impl <K: Ord, V> TreeMap<K, V>: Mutable {\n+    /// Clear the map, removing all key-value pairs.\n+    fn clear(&mut self) {\n+        self.root = None;\n+        self.length = 0\n+    }\n+}\n+\n impl <K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n@@ -196,6 +204,11 @@ impl <T: Eq Ord> TreeSet<T>: Eq {\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n+impl <T: Ord> TreeSet<T>: Mutable {\n+    /// Clear the set, removing all values.\n+    fn clear(&mut self) { self.map.clear() }\n+}\n+\n impl <T: Ord> TreeSet<T>: Set<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n@@ -624,6 +637,20 @@ mod test_treemap {\n         assert m.find(&2).unwrap() == &11;\n     }\n \n+    #[test]\n+    fn test_clear() {\n+        let mut m = TreeMap::new();\n+        m.clear();\n+        assert m.insert(5, 11);\n+        assert m.insert(12, -3);\n+        assert m.insert(19, 2);\n+        m.clear();\n+        assert m.find(&5).is_none();\n+        assert m.find(&12).is_none();\n+        assert m.find(&19).is_none();\n+        assert m.is_empty();\n+    }\n+\n     #[test]\n     fn u8_map() {\n         let mut m = TreeMap::new();\n@@ -844,6 +871,20 @@ mod test_treemap {\n mod test_set {\n     use super::*;\n \n+    #[test]\n+    fn test_clear() {\n+        let mut s = TreeSet::new();\n+        s.clear();\n+        assert s.insert(5);\n+        assert s.insert(12);\n+        assert s.insert(19);\n+        s.clear();\n+        assert !s.contains(&5);\n+        assert !s.contains(&12);\n+        assert !s.contains(&19);\n+        assert s.is_empty();\n+    }\n+\n     #[test]\n     fn test_disjoint() {\n         let mut xs = TreeSet::new();"}]}