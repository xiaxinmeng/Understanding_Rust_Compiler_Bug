{"sha": "6970f88db3ac2a9cefa9c585228291ae1f18fb04", "node_id": "C_kwDOAAsO6NoAKDY5NzBmODhkYjNhYzJhOWNlZmE5YzU4NTIyODI5MWFlMWYxOGZiMDQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T01:43:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-03-24T01:43:21Z"}, "message": "Auto merge of #87667 - the8472:document-in-place-iter, r=yaahc\n\nadd module-level documentation for vec's in-place iteration\n\nAs requested in the last libs team meeting and during previous reviews.\n\nFeel free to point out any gaps you encounter, after all non-obvious things may with hindsight seem obvious to me.\n\nr? `@yaahc`\n\nCC `@steffahn`", "tree": {"sha": "9c2f6c8dee9dc21cf7269bc03b46f648b35ace42", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c2f6c8dee9dc21cf7269bc03b46f648b35ace42"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6970f88db3ac2a9cefa9c585228291ae1f18fb04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6970f88db3ac2a9cefa9c585228291ae1f18fb04", "html_url": "https://github.com/rust-lang/rust/commit/6970f88db3ac2a9cefa9c585228291ae1f18fb04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6970f88db3ac2a9cefa9c585228291ae1f18fb04/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "37b55c8a0cafdb60b9168da34f904acc70157df8", "url": "https://api.github.com/repos/rust-lang/rust/commits/37b55c8a0cafdb60b9168da34f904acc70157df8", "html_url": "https://github.com/rust-lang/rust/commit/37b55c8a0cafdb60b9168da34f904acc70157df8"}, {"sha": "29e29ce65d4a798927d1e2055613b81de8503b9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/29e29ce65d4a798927d1e2055613b81de8503b9f", "html_url": "https://github.com/rust-lang/rust/commit/29e29ce65d4a798927d1e2055613b81de8503b9f"}], "stats": {"total": 494, "additions": 326, "deletions": 168}, "files": [{"sha": "ef5bef0253a569b2cbcc60d277a1b3ad8217d55c", "filename": "library/alloc/src/collections/binary_heap.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbinary_heap.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -151,7 +151,7 @@ use core::ptr;\n \n use crate::collections::TryReserveError;\n use crate::slice;\n-use crate::vec::{self, AsIntoIter, Vec};\n+use crate::vec::{self, AsVecIntoIter, Vec};\n \n use super::SpecExtend;\n \n@@ -1401,6 +1401,8 @@ impl<T> ExactSizeIterator for IntoIter<T> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<T> FusedIterator for IntoIter<T> {}\n \n+// In addition to the SAFETY invariants of the following three unsafe traits\n+// also refer to the vec::in_place_collect module documentation to get an overview\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n unsafe impl<T> SourceIter for IntoIter<T> {\n@@ -1416,7 +1418,7 @@ unsafe impl<T> SourceIter for IntoIter<T> {\n #[doc(hidden)]\n unsafe impl<I> InPlaceIterable for IntoIter<I> {}\n \n-impl<I> AsIntoIter for IntoIter<I> {\n+unsafe impl<I> AsVecIntoIter for IntoIter<I> {\n     type Item = I;\n \n     fn as_into_iter(&mut self) -> &mut vec::IntoIter<Self::Item> {"}, {"sha": "282af8cc33fddbfa9c54751501ae8a91a027fd26", "filename": "library/alloc/src/vec/in_place_collect.rs", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fin_place_collect.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -0,0 +1,302 @@\n+//! Inplace iterate-and-collect specialization for `Vec`\n+//!\n+//! Note: This documents Vec internals, some of the following sections explain implementation\n+//! details and are best read together with the source of this module.\n+//!\n+//! The specialization in this module applies to iterators in the shape of\n+//! `source.adapter().adapter().adapter().collect::<Vec<U>>()`\n+//! where `source` is an owning iterator obtained from [`Vec<T>`], [`Box<[T]>`][box] (by conversion to `Vec`)\n+//! or [`BinaryHeap<T>`], the adapters each consume one or more items per step\n+//! (represented by [`InPlaceIterable`]), provide transitive access to `source` (via [`SourceIter`])\n+//! and thus the underlying allocation. And finally the layouts of `T` and `U` must\n+//! have the same size and alignment, this is currently ensured via const eval instead of trait bounds\n+//! in the specialized [`SpecFromIter`] implementation.\n+//!\n+//! [`BinaryHeap<T>`]: crate::collections::BinaryHeap\n+//! [box]: crate::boxed::Box\n+//!\n+//! By extension some other collections which use `collect::<Vec<_>>()` internally in their\n+//! `FromIterator` implementation benefit from this too.\n+//!\n+//! Access to the underlying source goes through a further layer of indirection via the private\n+//! trait [`AsVecIntoIter`] to hide the implementation detail that other collections may use\n+//! `vec::IntoIter` internally.\n+//!\n+//! In-place iteration depends on the interaction of several unsafe traits, implementation\n+//! details of multiple parts in the iterator pipeline and often requires holistic reasoning\n+//! across multiple structs since iterators are executed cooperatively rather than having\n+//! a central evaluator/visitor struct executing all iterator components.\n+//!\n+//! # Reading from and writing to the same allocation\n+//!\n+//! By its nature collecting in place means that the reader and writer side of the iterator\n+//! use the same allocation. Since `try_fold()` (used in [`SpecInPlaceCollect`]) takes a\n+//! reference to the iterator for the duration of the iteration that means we can't interleave\n+//! the step of reading a value and getting a reference to write to. Instead raw pointers must be\n+//! used on the reader and writer side.\n+//!\n+//! That writes never clobber a yet-to-be-read item is ensured by the [`InPlaceIterable`] requirements.\n+//!\n+//! # Layout constraints\n+//!\n+//! [`Allocator`] requires that `allocate()` and `deallocate()` have matching alignment and size.\n+//! Additionally this specialization doesn't make sense for ZSTs as there is no reallocation to\n+//! avoid and it would make pointer arithmetic more difficult.\n+//!\n+//! [`Allocator`]: core::alloc::Allocator\n+//!\n+//! # Drop- and panic-safety\n+//!\n+//! Iteration can panic, requiring dropping the already written parts but also the remainder of\n+//! the source. Iteration can also leave some source items unconsumed which must be dropped.\n+//! All those drops in turn can panic which then must either leak the allocation or abort to avoid\n+//! double-drops.\n+//!\n+//! This is handled by the [`InPlaceDrop`] guard for sink items (`U`) and by\n+//! [`vec::IntoIter::forget_allocation_drop_remaining()`] for remaining source items (`T`).\n+//!\n+//! [`vec::IntoIter::forget_allocation_drop_remaining()`]: super::IntoIter::forget_allocation_drop_remaining()\n+//!\n+//! # O(1) collect\n+//!\n+//! The main iteration itself is further specialized when the iterator implements\n+//! [`TrustedRandomAccessNoCoerce`] to let the optimizer see that it is a counted loop with a single\n+//! [induction variable]. This can turn some iterators into a noop, i.e. it reduces them from O(n) to\n+//! O(1). This particular optimization is quite fickle and doesn't always work, see [#79308]\n+//!\n+//! [#79308]: https://github.com/rust-lang/rust/issues/79308\n+//! [induction variable]: https://en.wikipedia.org/wiki/Induction_variable\n+//!\n+//! Since unchecked accesses through that trait do not advance the read pointer of `IntoIter`\n+//! this would interact unsoundly with the requirements about dropping the tail described above.\n+//! But since the normal `Drop` implementation of `IntoIter` would suffer from the same problem it\n+//! is only correct for `TrustedRandomAccessNoCoerce` to be implemented when the items don't\n+//! have a destructor. Thus that implicit requirement also makes the specialization safe to use for\n+//! in-place collection.\n+//! Note that this safety concern is about the correctness of `impl Drop for IntoIter`,\n+//! not the guarantees of `InPlaceIterable`.\n+//!\n+//! # Adapter implementations\n+//!\n+//! The invariants for adapters are documented in [`SourceIter`] and [`InPlaceIterable`], but\n+//! getting them right can be rather subtle for multiple, sometimes non-local reasons.\n+//! For example `InPlaceIterable` would be valid to implement for [`Peekable`], except\n+//! that it is stateful, cloneable and `IntoIter`'s clone implementation shortens the underlying\n+//! allocation which means if the iterator has been peeked and then gets cloned there no longer is\n+//! enough room, thus breaking an invariant ([#85322]).\n+//!\n+//! [#85322]: https://github.com/rust-lang/rust/issues/85322\n+//! [`Peekable`]: core::iter::Peekable\n+//!\n+//!\n+//! # Examples\n+//!\n+//! Some cases that are optimized by this specialization, more can be found in the `Vec`\n+//! benchmarks:\n+//!\n+//! ```rust\n+//! # #[allow(dead_code)]\n+//! /// Converts a usize vec into an isize one.\n+//! pub fn cast(vec: Vec<usize>) -> Vec<isize> {\n+//!   // Does not allocate, free or panic. On optlevel>=2 it does not loop.\n+//!   // Of course this particular case could and should be written with `into_raw_parts` and\n+//!   // `from_raw_parts` instead.\n+//!   vec.into_iter().map(|u| u as isize).collect()\n+//! }\n+//! ```\n+//!\n+//! ```rust\n+//! # #[allow(dead_code)]\n+//! /// Drops remaining items in `src` and if the layouts of `T` and `U` match it\n+//! /// returns an empty Vec backed by the original allocation. Otherwise it returns a new\n+//! /// empty vec.\n+//! pub fn recycle_allocation<T, U>(src: Vec<T>) -> Vec<U> {\n+//!   src.into_iter().filter_map(|_| None).collect()\n+//! }\n+//! ```\n+//!\n+//! ```rust\n+//! let vec = vec![13usize; 1024];\n+//! let _ = vec.into_iter()\n+//!   .enumerate()\n+//!   .filter_map(|(idx, val)| if idx % 2 == 0 { Some(val+idx) } else {None})\n+//!   .collect::<Vec<_>>();\n+//!\n+//! // is equivalent to the following, but doesn't require bounds checks\n+//!\n+//! let mut vec = vec![13usize; 1024];\n+//! let mut write_idx = 0;\n+//! for idx in 0..vec.len() {\n+//!    if idx % 2 == 0 {\n+//!       vec[write_idx] = vec[idx] + idx;\n+//!       write_idx += 1;\n+//!    }\n+//! }\n+//! vec.truncate(write_idx);\n+//! ```\n+use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccessNoCoerce};\n+use core::mem::{self, ManuallyDrop};\n+use core::ptr::{self};\n+\n+use super::{InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n+\n+/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n+/// source allocation, i.e. executing the pipeline in place.\n+#[rustc_unsafe_specialization_marker]\n+pub(super) trait InPlaceIterableMarker {}\n+\n+impl<T> InPlaceIterableMarker for T where T: InPlaceIterable {}\n+\n+impl<T, I> SpecFromIter<T, I> for Vec<T>\n+where\n+    I: Iterator<Item = T> + SourceIter<Source: AsVecIntoIter> + InPlaceIterableMarker,\n+{\n+    default fn from_iter(mut iterator: I) -> Self {\n+        // See \"Layout constraints\" section in the module documentation. We rely on const\n+        // optimization here since these conditions currently cannot be expressed as trait bounds\n+        if mem::size_of::<T>() == 0\n+            || mem::size_of::<T>()\n+                != mem::size_of::<<<I as SourceIter>::Source as AsVecIntoIter>::Item>()\n+            || mem::align_of::<T>()\n+                != mem::align_of::<<<I as SourceIter>::Source as AsVecIntoIter>::Item>()\n+        {\n+            // fallback to more generic implementations\n+            return SpecFromIterNested::from_iter(iterator);\n+        }\n+\n+        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n+            let inner = iterator.as_inner().as_into_iter();\n+            (\n+                inner.buf.as_ptr(),\n+                inner.ptr,\n+                inner.buf.as_ptr() as *mut T,\n+                inner.end as *const T,\n+                inner.cap,\n+            )\n+        };\n+\n+        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n+\n+        let src = unsafe { iterator.as_inner().as_into_iter() };\n+        // check if SourceIter contract was upheld\n+        // caveat: if they weren't we might not even make it to this point\n+        debug_assert_eq!(src_buf, src.buf.as_ptr());\n+        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n+        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n+        // then the source pointer will stay in its initial position and we can't use it as reference\n+        if src.ptr != src_ptr {\n+            debug_assert!(\n+                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n+                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n+            );\n+        }\n+\n+        // Drop any remaining values at the tail of the source but prevent drop of the allocation\n+        // itself once IntoIter goes out of scope.\n+        // If the drop panics then we also leak any elements collected into dst_buf.\n+        //\n+        // Note: This access to the source wouldn't be allowed by the TrustedRandomIteratorNoCoerce\n+        // contract (used by SpecInPlaceCollect below). But see the \"O(1) collect\" section in the\n+        // module documenttation why this is ok anyway.\n+        src.forget_allocation_drop_remaining();\n+\n+        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n+\n+        vec\n+    }\n+}\n+\n+fn write_in_place_with_drop<T>(\n+    src_end: *const T,\n+) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n+    move |mut sink, item| {\n+        unsafe {\n+            // the InPlaceIterable contract cannot be verified precisely here since\n+            // try_fold has an exclusive reference to the source pointer\n+            // all we can do is check if it's still in range\n+            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n+            ptr::write(sink.dst, item);\n+            // Since this executes user code which can panic we have to bump the pointer\n+            // after each step.\n+            sink.dst = sink.dst.add(1);\n+        }\n+        Ok(sink)\n+    }\n+}\n+\n+/// Helper trait to hold specialized implementations of the in-place iterate-collect loop\n+trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n+    /// Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items\n+    /// collected. `end` is the last writable element of the allocation and used for bounds checks.\n+    ///\n+    /// This method is specialized and one of its implementations makes use of\n+    /// `Iterator::__iterator_get_unchecked` calls with a `TrustedRandomAccessNoCoerce` bound\n+    /// on `I` which means the caller of this method must take the safety conditions\n+    /// of that trait into consideration.\n+    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T>,\n+{\n+    #[inline]\n+    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        // use try-fold since\n+        // - it vectorizes better for some iterator adapters\n+        // - unlike most internal iteration methods, it only takes a &mut self\n+        // - it lets us thread the write pointer through its innards and get it back in the end\n+        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        let sink =\n+            self.try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(end)).unwrap();\n+        // iteration succeeded, don't drop head\n+        unsafe { ManuallyDrop::new(sink).dst.offset_from(dst_buf) as usize }\n+    }\n+}\n+\n+impl<T, I> SpecInPlaceCollect<T, I> for I\n+where\n+    I: Iterator<Item = T> + TrustedRandomAccessNoCoerce,\n+{\n+    #[inline]\n+    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n+        let len = self.size();\n+        let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n+        for i in 0..len {\n+            // Safety: InplaceIterable contract guarantees that for every element we read\n+            // one slot in the underlying storage will have been freed up and we can immediately\n+            // write back the result.\n+            unsafe {\n+                let dst = dst_buf.offset(i as isize);\n+                debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n+                ptr::write(dst, self.__iterator_get_unchecked(i));\n+                // Since this executes user code which can panic we have to bump the pointer\n+                // after each step.\n+                drop_guard.dst = dst.add(1);\n+            }\n+        }\n+        mem::forget(drop_guard);\n+        len\n+    }\n+}\n+\n+/// Internal helper trait for in-place iteration specialization.\n+///\n+/// Currently this is only implemented by [`vec::IntoIter`] - returning a reference to itself - and\n+/// [`binary_heap::IntoIter`] which returns a reference to its inner representation.\n+///\n+/// Since this is an internal trait it hides the implementation detail `binary_heap::IntoIter`\n+/// uses `vec::IntoIter` internally.\n+///\n+/// [`vec::IntoIter`]: super::IntoIter\n+/// [`binary_heap::IntoIter`]: crate::collections::binary_heap::IntoIter\n+///\n+/// # Safety\n+///\n+/// In-place iteration relies on implementation details of `vec::IntoIter`, most importantly that\n+/// it does not create references to the whole allocation during iteration, only raw pointers\n+#[rustc_specialization_trait]\n+pub(crate) unsafe trait AsVecIntoIter {\n+    type Item;\n+    fn as_into_iter(&mut self) -> &mut super::IntoIter<Self::Item>;\n+}"}, {"sha": "f17b8d71b3a1a23815d56e7fc15c3187d3a602cc", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -1,3 +1,5 @@\n+#[cfg(not(no_global_oom_handling))]\n+use super::AsVecIntoIter;\n use crate::alloc::{Allocator, Global};\n use crate::raw_vec::RawVec;\n use core::fmt;\n@@ -97,6 +99,9 @@ impl<T, A: Allocator> IntoIter<T, A> {\n     /// (&mut into_iter).for_each(core::mem::drop);\n     /// unsafe { core::ptr::write(&mut into_iter, Vec::new().into_iter()); }\n     /// ```\n+    ///\n+    /// This method is used by in-place iteration, refer to the vec::in_place_collect\n+    /// documentation for an overview.\n     #[cfg(not(no_global_oom_handling))]\n     pub(super) fn forget_allocation_drop_remaining(&mut self) {\n         let remaining = self.as_raw_mut_slice();\n@@ -323,6 +328,8 @@ unsafe impl<#[may_dangle] T, A: Allocator> Drop for IntoIter<T, A> {\n     }\n }\n \n+// In addition to the SAFETY invariants of the following three unsafe traits\n+// also refer to the vec::in_place_collect module documentation to get an overview\n #[unstable(issue = \"none\", feature = \"inplace_iteration\")]\n #[doc(hidden)]\n unsafe impl<T, A: Allocator> InPlaceIterable for IntoIter<T, A> {}\n@@ -338,14 +345,8 @@ unsafe impl<T, A: Allocator> SourceIter for IntoIter<T, A> {\n     }\n }\n \n-// internal helper trait for in-place iteration specialization.\n-#[rustc_specialization_trait]\n-pub(crate) trait AsIntoIter {\n-    type Item;\n-    fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item>;\n-}\n-\n-impl<T> AsIntoIter for IntoIter<T> {\n+#[cfg(not(no_global_oom_handling))]\n+unsafe impl<T> AsVecIntoIter for IntoIter<T> {\n     type Item = T;\n \n     fn as_into_iter(&mut self) -> &mut IntoIter<Self::Item> {"}, {"sha": "9a66e69bdc0615e7a6191d38370617802bb7b12d", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -96,7 +96,7 @@ mod drain;\n mod cow;\n \n #[cfg(not(no_global_oom_handling))]\n-pub(crate) use self::into_iter::AsIntoIter;\n+pub(crate) use self::in_place_collect::AsVecIntoIter;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::into_iter::IntoIter;\n \n@@ -108,7 +108,7 @@ use self::is_zero::IsZero;\n mod is_zero;\n \n #[cfg(not(no_global_oom_handling))]\n-mod source_iter_marker;\n+mod in_place_collect;\n \n mod partial_eq;\n "}, {"sha": "6e78534cf5b10d3a515134d933bdc9508fddab12", "filename": "library/alloc/src/vec/source_iter_marker.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/37b55c8a0cafdb60b9168da34f904acc70157df8/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37b55c8a0cafdb60b9168da34f904acc70157df8/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fsource_iter_marker.rs?ref=37b55c8a0cafdb60b9168da34f904acc70157df8", "patch": "@@ -1,156 +0,0 @@\n-use core::iter::{InPlaceIterable, SourceIter, TrustedRandomAccessNoCoerce};\n-use core::mem::{self, ManuallyDrop};\n-use core::ptr::{self};\n-\n-use super::{AsIntoIter, InPlaceDrop, SpecFromIter, SpecFromIterNested, Vec};\n-\n-/// Specialization marker for collecting an iterator pipeline into a Vec while reusing the\n-/// source allocation, i.e. executing the pipeline in place.\n-#[rustc_unsafe_specialization_marker]\n-pub(super) trait InPlaceIterableMarker {}\n-\n-impl<T> InPlaceIterableMarker for T where T: InPlaceIterable {}\n-\n-impl<T, I> SpecFromIter<T, I> for Vec<T>\n-where\n-    I: Iterator<Item = T> + SourceIter<Source: AsIntoIter> + InPlaceIterableMarker,\n-{\n-    default fn from_iter(mut iterator: I) -> Self {\n-        // Additional requirements which cannot expressed via trait bounds. We rely on const eval\n-        // instead:\n-        // a) no ZSTs as there would be no allocation to reuse and pointer arithmetic would panic\n-        // b) size match as required by Alloc contract\n-        // c) alignments match as required by Alloc contract\n-        if mem::size_of::<T>() == 0\n-            || mem::size_of::<T>()\n-                != mem::size_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-            || mem::align_of::<T>()\n-                != mem::align_of::<<<I as SourceIter>::Source as AsIntoIter>::Item>()\n-        {\n-            // fallback to more generic implementations\n-            return SpecFromIterNested::from_iter(iterator);\n-        }\n-\n-        let (src_buf, src_ptr, dst_buf, dst_end, cap) = unsafe {\n-            let inner = iterator.as_inner().as_into_iter();\n-            (\n-                inner.buf.as_ptr(),\n-                inner.ptr,\n-                inner.buf.as_ptr() as *mut T,\n-                inner.end as *const T,\n-                inner.cap,\n-            )\n-        };\n-\n-        let len = SpecInPlaceCollect::collect_in_place(&mut iterator, dst_buf, dst_end);\n-\n-        let src = unsafe { iterator.as_inner().as_into_iter() };\n-        // check if SourceIter contract was upheld\n-        // caveat: if they weren't we might not even make it to this point\n-        debug_assert_eq!(src_buf, src.buf.as_ptr());\n-        // check InPlaceIterable contract. This is only possible if the iterator advanced the\n-        // source pointer at all. If it uses unchecked access via TrustedRandomAccess\n-        // then the source pointer will stay in its initial position and we can't use it as reference\n-        if src.ptr != src_ptr {\n-            debug_assert!(\n-                unsafe { dst_buf.add(len) as *const _ } <= src.ptr,\n-                \"InPlaceIterable contract violation, write pointer advanced beyond read pointer\"\n-            );\n-        }\n-\n-        // drop any remaining values at the tail of the source\n-        // but prevent drop of the allocation itself once IntoIter goes out of scope\n-        // if the drop panics then we also leak any elements collected into dst_buf\n-        //\n-        // FIXME: Since `SpecInPlaceCollect::collect_in_place` above might use\n-        // `__iterator_get_unchecked` internally, this call might be operating on\n-        // a `vec::IntoIter` with incorrect internal state regarding which elements\n-        // have already been \u201cconsumed\u201d. However, the `TrustedRandomIteratorNoCoerce`\n-        // implementation of `vec::IntoIter` is only present if the `Vec` elements\n-        // don\u2019t have a destructor, so it doesn\u2019t matter if elements are \u201cdropped multiple times\u201d\n-        // in this case.\n-        // This argument technically currently lacks justification from the `# Safety` docs for\n-        // `SourceIter`/`InPlaceIterable` and/or `TrustedRandomAccess`, so it might be possible that\n-        // someone could inadvertently create new library unsoundness\n-        // involving this `.forget_allocation_drop_remaining()` call.\n-        src.forget_allocation_drop_remaining();\n-\n-        let vec = unsafe { Vec::from_raw_parts(dst_buf, len, cap) };\n-\n-        vec\n-    }\n-}\n-\n-fn write_in_place_with_drop<T>(\n-    src_end: *const T,\n-) -> impl FnMut(InPlaceDrop<T>, T) -> Result<InPlaceDrop<T>, !> {\n-    move |mut sink, item| {\n-        unsafe {\n-            // the InPlaceIterable contract cannot be verified precisely here since\n-            // try_fold has an exclusive reference to the source pointer\n-            // all we can do is check if it's still in range\n-            debug_assert!(sink.dst as *const _ <= src_end, \"InPlaceIterable contract violation\");\n-            ptr::write(sink.dst, item);\n-            // Since this executes user code which can panic we have to bump the pointer\n-            // after each step.\n-            sink.dst = sink.dst.add(1);\n-        }\n-        Ok(sink)\n-    }\n-}\n-\n-/// Helper trait to hold specialized implementations of the in-place iterate-collect loop\n-trait SpecInPlaceCollect<T, I>: Iterator<Item = T> {\n-    /// Collects an iterator (`self`) into the destination buffer (`dst`) and returns the number of items\n-    /// collected. `end` is the last writable element of the allocation and used for bounds checks.\n-    ///\n-    /// This method is specialized and one of its implementations makes use of\n-    /// `Iterator::__iterator_get_unchecked` calls with a `TrustedRandomAccessNoCoerce` bound\n-    /// on `I` which means the caller of this method must take the safety conditions\n-    /// of that trait into consideration.\n-    fn collect_in_place(&mut self, dst: *mut T, end: *const T) -> usize;\n-}\n-\n-impl<T, I> SpecInPlaceCollect<T, I> for I\n-where\n-    I: Iterator<Item = T>,\n-{\n-    #[inline]\n-    default fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n-        // use try-fold since\n-        // - it vectorizes better for some iterator adapters\n-        // - unlike most internal iteration methods, it only takes a &mut self\n-        // - it lets us thread the write pointer through its innards and get it back in the end\n-        let sink = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        let sink =\n-            self.try_fold::<_, _, Result<_, !>>(sink, write_in_place_with_drop(end)).unwrap();\n-        // iteration succeeded, don't drop head\n-        unsafe { ManuallyDrop::new(sink).dst.offset_from(dst_buf) as usize }\n-    }\n-}\n-\n-impl<T, I> SpecInPlaceCollect<T, I> for I\n-where\n-    I: Iterator<Item = T> + TrustedRandomAccessNoCoerce,\n-{\n-    #[inline]\n-    fn collect_in_place(&mut self, dst_buf: *mut T, end: *const T) -> usize {\n-        let len = self.size();\n-        let mut drop_guard = InPlaceDrop { inner: dst_buf, dst: dst_buf };\n-        for i in 0..len {\n-            // Safety: InplaceIterable contract guarantees that for every element we read\n-            // one slot in the underlying storage will have been freed up and we can immediately\n-            // write back the result.\n-            unsafe {\n-                let dst = dst_buf.offset(i as isize);\n-                debug_assert!(dst as *const _ <= end, \"InPlaceIterable contract violation\");\n-                ptr::write(dst, self.__iterator_get_unchecked(i));\n-                // Since this executes user code which can panic we have to bump the pointer\n-                // after each step.\n-                drop_guard.dst = dst.add(1);\n-            }\n-        }\n-        mem::forget(drop_guard);\n-        len\n-    }\n-}"}, {"sha": "4500b44b7e9aff39ccd2589d1cd0f8f7c68c23d1", "filename": "library/core/src/iter/adapters/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Fadapters%2Fmod.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -78,6 +78,11 @@ pub use self::zip::zip;\n /// The trait is unsafe because implementers must uphold additional safety properties.\n /// See [`as_inner`] for details.\n ///\n+/// The primary use of this trait is in-place iteration. Refer to the [`vec::in_place_collect`]\n+/// module documentation for more information.\n+///\n+/// [`vec::in_place_collect`]: ../../../../alloc/vec/in_place_collect/index.html\n+///\n /// # Examples\n ///\n /// Retrieving a partially consumed source:"}, {"sha": "da753745740d70cfd376f46f747a9b4bd6810f0e", "filename": "library/core/src/iter/traits/marker.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6970f88db3ac2a9cefa9c585228291ae1f18fb04/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fmarker.rs?ref=6970f88db3ac2a9cefa9c585228291ae1f18fb04", "patch": "@@ -51,6 +51,10 @@ unsafe impl<I: TrustedLen + ?Sized> TrustedLen for &mut I {}\n /// in its place, assuming structural constraints of the source allow such an insertion.\n /// In other words this trait indicates that an iterator pipeline can be collected in place.\n ///\n+/// The primary use of this trait is in-place iteration. Refer to the [`vec::in_place_collect`]\n+/// module documentation for more information.\n+///\n+/// [`vec::in_place_collect`]: ../../../../alloc/vec/in_place_collect/index.html\n /// [`SourceIter`]: crate::iter::SourceIter\n /// [`next()`]: Iterator::next\n /// [`try_fold()`]: Iterator::try_fold"}]}