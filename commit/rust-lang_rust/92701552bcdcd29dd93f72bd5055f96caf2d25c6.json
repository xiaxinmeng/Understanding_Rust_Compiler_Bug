{"sha": "92701552bcdcd29dd93f72bd5055f96caf2d25c6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNzAxNTUyYmNkY2QyOWRkOTNmNzJiZDUwNTVmOTZjYWYyZDI1YzY=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-10T00:24:45Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-07-24T03:43:29Z"}, "message": "chains: refactor block formatting", "tree": {"sha": "2279d9b5b034ce06493c971869c345058bcbed53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2279d9b5b034ce06493c971869c345058bcbed53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92701552bcdcd29dd93f72bd5055f96caf2d25c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92701552bcdcd29dd93f72bd5055f96caf2d25c6", "html_url": "https://github.com/rust-lang/rust/commit/92701552bcdcd29dd93f72bd5055f96caf2d25c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92701552bcdcd29dd93f72bd5055f96caf2d25c6/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "914e750c9ead9a80e6514c08388cce11380cb949", "url": "https://api.github.com/repos/rust-lang/rust/commits/914e750c9ead9a80e6514c08388cce11380cb949", "html_url": "https://github.com/rust-lang/rust/commit/914e750c9ead9a80e6514c08388cce11380cb949"}], "stats": {"total": 207, "additions": 93, "deletions": 114}, "files": [{"sha": "ff3633a8cffdf06cdca4f15501fd3c6735895128", "filename": "src/chains.rs", "status": "modified", "additions": 93, "deletions": 114, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/92701552bcdcd29dd93f72bd5055f96caf2d25c6/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92701552bcdcd29dd93f72bd5055f96caf2d25c6/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=92701552bcdcd29dd93f72bd5055f96caf2d25c6", "patch": "@@ -71,10 +71,7 @@ use macros::convert_try_mac;\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n use spanned::Spanned;\n-use utils::{\n-    first_line_width, last_line_extendable, last_line_width, mk_sp, trimmed_last_line_width,\n-    wrap_str,\n-};\n+use utils::{first_line_width, last_line_extendable, last_line_width, mk_sp, wrap_str};\n \n use std::borrow::Cow;\n use std::cmp::min;\n@@ -99,11 +96,13 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n }\n \n // An expression plus trailing `?`s to be formatted together.\n+#[derive(Debug)]\n struct ChainItem {\n     expr: ast::Expr,\n     tries: usize,\n }\n \n+#[derive(Debug)]\n struct Chain {\n     parent: ChainItem,\n     // TODO do we need to clone the exprs?\n@@ -136,82 +135,89 @@ impl Chain {\n         }\n \n         Chain {\n-            parent: children.pop().unwrap(),\n-            children: children.into_iter().rev().collect(),\n+            parent: children.remove(0),\n+            children,\n         }\n     }\n }\n \n-fn rewrite_chain_block(mut chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n-    let last = chain.children.pop().unwrap();\n-\n+fn rewrite_chain_block(chain: Chain, context: &RewriteContext, shape: Shape) -> Option<String> {\n+    debug!(\"rewrite_chain_block {:?} {:?}\", chain, shape);\n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let parent_rewrite = chain.parent.expr\n+    // Root is the parent plus any other chain items placed on the first line to\n+    // avoid an orphan. E.g.,\n+    // ```\n+    // foo.bar\n+    //     .baz()\n+    // ```\n+    // If `bar` were not part of the root, then baz would be orphaned and 'float'.\n+    let mut root_rewrite = chain.parent.expr\n         .rewrite(context, shape)\n         .map(|parent_rw| parent_rw + &\"?\".repeat(chain.parent.tries))?;\n-    let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n-    let is_small_parent = shape.offset + parent_rewrite.len() <= context.config.tab_spaces();\n-    let parent_is_block = is_block_expr(context, &chain.parent.expr, &parent_rewrite);\n \n-    // Decide how to layout the rest of the chain. `extend` is true if we can\n-    // put the first non-parent item on the same line as the parent.\n-    let other_child_shape = if parent_is_block {\n+    let mut children: &[_] = &chain.children;\n+    let mut root_ends_with_block = is_block_expr(context, &chain.parent.expr, &root_rewrite);\n+    let tab_width = context.config.tab_spaces().saturating_sub(shape.offset);\n+\n+    while root_rewrite.len() <= tab_width && !root_rewrite.contains('\\n') {\n+        let item = &children[0];\n+        let shape = shape.offset_left(root_rewrite.len())?;\n+        match rewrite_chain_subexpr(&item.expr, context, shape) {\n+            Some(rewrite) => {\n+                root_rewrite.push_str(&rewrite);\n+                root_rewrite.push_str(&\"?\".repeat(item.tries));\n+            }\n+            None => break,\n+        }\n+\n+        root_ends_with_block = is_block_expr(context, &item.expr, &root_rewrite);\n+\n+        children = &children[1..];\n+        if children.is_empty() {\n+            return Some(root_rewrite);\n+        }\n+    }\n+\n+    // Separate out the last item in the chain for special treatment below.\n+    let last = &children[children.len() - 1];\n+    children = &children[..children.len() - 1];\n+\n+    // Decide how to layout the rest of the chain.\n+    let child_shape = if root_ends_with_block {\n         shape\n     } else {\n         shape.block_indent(context.config.tab_spaces())\n     }.with_max_width(context.config);\n \n-    let extend = parent_is_block || (is_small_parent && !parent_rewrite_contains_newline && is_continuable(&chain.parent.expr));\n-\n-    let first_child_shape = if extend {\n-        let offset = trimmed_last_line_width(&parent_rewrite) + chain.parent.tries;\n-        other_child_shape.offset_left(offset)?\n-    } else {\n-        other_child_shape\n-    };\n-    debug!(\n-        \"child_shapes {:?} {:?}\",\n-        first_child_shape, other_child_shape\n-    );\n-\n-    let mut rewrites: Vec<String> = Vec::with_capacity(chain.children.len());\n-    let mut is_block_like = Vec::with_capacity(chain.children.len());\n-    is_block_like.push(true);\n-    for (i, item) in chain.children.iter().enumerate() {\n-        let shape = if *is_block_like.last().unwrap() && !(extend && i == 0) {\n-            first_child_shape\n-        } else {\n-            other_child_shape\n-        };\n-        let rewrite = rewrite_chain_subexpr(&item.expr, context, shape)?;\n+    let mut rewrites: Vec<String> = Vec::with_capacity(children.len());\n+    rewrites.push(root_rewrite);\n+    let mut is_block_like = Vec::with_capacity(children.len());\n+    is_block_like.push(root_ends_with_block);\n+    for item in children {\n+        let rewrite = rewrite_chain_subexpr(&item.expr, context, child_shape)?;\n         is_block_like.push(is_block_expr(context, &item.expr, &rewrite));\n         rewrites.push(format!(\"{}{}\", rewrite, \"?\".repeat(item.tries)));\n     }\n \n     // Total of all items excluding the last.\n-    let extend_last_subexpr = if is_small_parent {\n-        rewrites.len() == 1 && last_line_extendable(&rewrites[0])\n-    } else {\n-        rewrites.is_empty() && last_line_extendable(&parent_rewrite)\n-    };\n+    let extend_last_subexpr = last_line_extendable(&rewrites[rewrites.len() - 1]);\n     let almost_total = if extend_last_subexpr {\n-        last_line_width(&parent_rewrite)\n+        last_line_width(&rewrites[rewrites.len() - 1])\n     } else {\n-        rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len()\n+        rewrites.iter().fold(0, |a, b| a + b.len())\n     } + last.tries;\n-    let one_line_budget = if rewrites.is_empty() {\n+    let one_line_budget = if rewrites.len() == 1 {\n         shape.width\n     } else {\n         min(shape.width, context.config.width_heuristics().chain_width)\n     };\n-    let all_in_one_line = !parent_rewrite_contains_newline\n-        && rewrites.iter().all(|s| !s.contains('\\n'))\n+    let all_in_one_line = rewrites.iter().all(|s| !s.contains('\\n'))\n         && almost_total < one_line_budget;\n-    let last_shape = if is_block_like[rewrites.len()] {\n-        first_child_shape\n+    let last_shape = if all_in_one_line {\n+        shape.sub_width(last.tries)?\n     } else {\n-        other_child_shape\n-    }.sub_width(shape.rhs_overhead(context.config) + last.tries)?;\n+        child_shape.sub_width(shape.rhs_overhead(context.config) + last.tries)?\n+    };\n \n     // Rewrite the last child. The last child of a chain requires special treatment. We need to\n     // know whether 'overflowing' the last child make a better formatting:\n@@ -246,91 +252,65 @@ fn rewrite_chain_block(mut chain: Chain, context: &RewriteContext, shape: Shape)\n     // })\n     // ```\n \n-    // `rewrite_last` rewrites the last child on its own line. We use a closure here instead of\n-    // directly calling `rewrite_chain_subexpr()` to avoid exponential blowup.\n-    let (last_subexpr_str, fits_single_line) = if all_in_one_line || extend_last_subexpr {\n+    let mut last_subexpr_str = None;\n+    let mut fits_single_line = false;\n+    if all_in_one_line || extend_last_subexpr {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n-        shape.offset_left(almost_total).map(|shape| {\n+        if let Some(shape) = last_shape.offset_left(almost_total) {\n             if let Some(rw) = rewrite_chain_subexpr(&last.expr, context, shape) {\n                 // We allow overflowing here only if both of the following conditions match:\n                 // 1. The entire chain fits in a single line except the last child.\n                 // 2. `last_child_str.lines().count() >= 5`.\n                 let line_count = rw.lines().count();\n-                let fits_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n+                let could_fit_single_line = almost_total + first_line_width(&rw) <= one_line_budget;\n                 if fits_single_line && line_count >= 5 {\n-                    (Some(rw), true)\n+                    last_subexpr_str = Some(rw);\n+                    fits_single_line = true;\n                 } else {\n                     // We could not know whether overflowing is better than using vertical layout,\n                     // just by looking at the overflowed rewrite. Now we rewrite the last child\n                     // on its own line, and compare two rewrites to choose which is better.\n                     match rewrite_chain_subexpr(&last.expr, context, last_shape) {\n-                        Some(ref new_rw) if !fits_single_line => (Some(new_rw.clone()), false),\n+                        Some(ref new_rw) if !could_fit_single_line => {\n+                            last_subexpr_str = Some(new_rw.clone());\n+                        }\n                         Some(ref new_rw) if new_rw.lines().count() >= line_count => {\n-                            (Some(rw), fits_single_line)\n+                            last_subexpr_str = Some(rw);\n+                            fits_single_line = could_fit_single_line;\n+                        }\n+                        new_rw @ Some(..) => {\n+                            last_subexpr_str = new_rw;\n+                        }\n+                        _ => {\n+                            last_subexpr_str = Some(rw);\n+                            fits_single_line = could_fit_single_line;\n                         }\n-                        new_rw @ Some(..) => (new_rw, false),\n-                        _ => (Some(rw), fits_single_line),\n                     }\n                 }\n-            } else {\n-                (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n             }\n-        })?\n-    } else {\n-        (rewrite_chain_subexpr(&last.expr, context, last_shape), false)\n-    };\n-    rewrites.push(last_subexpr_str?);\n+        }\n+    }\n+\n+    last_subexpr_str = last_subexpr_str.or_else(|| rewrite_chain_subexpr(&last.expr, context, last_shape));\n+    rewrites.push(format!(\"{}{}\", last_subexpr_str?, \"?\".repeat(last.tries)));\n+\n     // We should never look at this, since we only look at the block-ness of the\n     // previous item in the chain.\n     is_block_like.push(false);\n \n-    let connector = if fits_single_line && !parent_rewrite_contains_newline {\n+    let connector = if fits_single_line && all_in_one_line {\n         // Yay, we can put everything on one line.\n         Cow::from(\"\")\n     } else {\n         // Use new lines.\n         if *context.force_one_line_chain.borrow() {\n             return None;\n         }\n-        other_child_shape.indent.to_string_with_newline(context.config)\n+        child_shape.indent.to_string_with_newline(context.config)\n     };\n \n-    let first_connector = if is_small_parent\n-        || fits_single_line\n-        || last_line_extendable(&parent_rewrite)\n-    {\n-        \"\"\n-    } else {\n-        &connector\n-    };\n-\n-    let result = if is_small_parent && rewrites.len() > 1 {\n-        let second_connector = if fits_single_line\n-            || rewrites[1] == \"?\"\n-            || last_line_extendable(&rewrites[0])\n-        {\n-            \"\"\n-        } else {\n-            &connector\n-        };\n-        format!(\n-            \"{}{}{}{}{}\",\n-            parent_rewrite,\n-            first_connector,\n-            rewrites[0],\n-            second_connector,\n-            join_rewrites(&rewrites[1..], &is_block_like[2..], &connector),\n-        )\n-    } else {\n-        format!(\n-            \"{}{}{}\",\n-            parent_rewrite,\n-            first_connector,\n-            join_rewrites(&rewrites, &is_block_like[1..], &connector),\n-        )\n-    };\n-    let result = format!(\"{}{}\", result, \"?\".repeat(last.tries));\n+    let result = join_rewrites(&rewrites, &is_block_like, &connector);\n     Some(result)\n }\n \n@@ -424,7 +404,6 @@ fn rewrite_chain_visual(mut chain: Chain, context: &RewriteContext, shape: Shape\n \n     let mut last_subexpr_str = None;\n     let mut fits_single_line = false;\n-\n     if all_in_one_line {\n         // First we try to 'overflow' the last child and see if it looks better than using\n         // vertical layout.\n@@ -517,7 +496,9 @@ fn join_rewrites_vis(rewrites: &[String], connector: &str) -> String {\n // parens, braces, and brackets in its idiomatic formatting.\n fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n-        ast::ExprKind::Mac(..) | ast::ExprKind::Call(..) => {\n+        ast::ExprKind::Mac(..)\n+        | ast::ExprKind::Call(..)\n+        | ast::ExprKind::MethodCall(..) => {\n             context.use_block_indent() && repr.contains('\\n')\n         }\n         ast::ExprKind::Struct(..)\n@@ -533,11 +514,9 @@ fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool\n         | ast::ExprKind::Binary(_, _, ref expr)\n         | ast::ExprKind::Index(_, ref expr)\n         | ast::ExprKind::Unary(_, ref expr)\n-        | ast::ExprKind::Closure(_, _, _, _, ref expr, _) => is_block_expr(context, expr, repr),\n-        ast::ExprKind::MethodCall(_, ref exprs) => {\n-            // TODO maybe should be like Call\n-            is_block_expr(context, exprs.last().unwrap(), repr)\n-        }\n+        | ast::ExprKind::Closure(_, _, _, _, ref expr, _) \n+        | ast::ExprKind::Try(ref expr)\n+        | ast::ExprKind::Yield(Some(ref expr)) => is_block_expr(context, expr, repr),\n         _ => false,\n     }\n }"}]}