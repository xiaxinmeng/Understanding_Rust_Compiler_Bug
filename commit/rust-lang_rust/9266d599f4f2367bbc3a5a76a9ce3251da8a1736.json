{"sha": "9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNjZkNTk5ZjRmMjM2N2JiYzNhNWE3NmE5Y2UzMjUxZGE4YTE3MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T12:57:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-08T12:57:58Z"}, "message": "Auto merge of #24021 - pnkfelix:fn-params-outlive-body, r=nikomatsakis\n\nEncode more precise scoping rules for function params\r\n\r\nFunction params outlive everything in the body (incl temporaries).  Thus if we assign them their own `CodeExtent`, the region inference can properly show that it is sound to have temporaries with destructors that reference the parameters (because such temporaries will be dropped before the parameters are dropped).\r\n\r\nFix #23338", "tree": {"sha": "bca22711b9fd98d6e1c57dbf04f72f8d3f0fbd75", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bca22711b9fd98d6e1c57dbf04f72f8d3f0fbd75"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "html_url": "https://github.com/rust-lang/rust/commit/9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "926f38e588bb99aff1902fa94ab82b1db89cbbce", "url": "https://api.github.com/repos/rust-lang/rust/commits/926f38e588bb99aff1902fa94ab82b1db89cbbce", "html_url": "https://github.com/rust-lang/rust/commit/926f38e588bb99aff1902fa94ab82b1db89cbbce"}, {"sha": "86c5faf42bea29da18c82ab0af29b3a8428c5a44", "url": "https://api.github.com/repos/rust-lang/rust/commits/86c5faf42bea29da18c82ab0af29b3a8428c5a44", "html_url": "https://github.com/rust-lang/rust/commit/86c5faf42bea29da18c82ab0af29b3a8428c5a44"}], "stats": {"total": 309, "additions": 301, "deletions": 8}, "files": [{"sha": "cce31b1f4c249fb5aaa89758adae6428947cdfeb", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -369,6 +369,16 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n \n fn parse_scope(st: &mut PState) -> region::CodeExtent {\n     match next(st) {\n+        'P' => {\n+            assert_eq!(next(st), '[');\n+            let fn_id = parse_uint(st) as ast::NodeId;\n+            assert_eq!(next(st), '|');\n+            let body_id = parse_uint(st) as ast::NodeId;\n+            assert_eq!(next(st), ']');\n+            region::CodeExtent::ParameterScope {\n+                fn_id: fn_id, body_id: body_id\n+            }\n+        }\n         'M' => {\n             let node_id = parse_uint(st) as ast::NodeId;\n             region::CodeExtent::Misc(node_id)\n@@ -378,8 +388,11 @@ fn parse_scope(st: &mut PState) -> region::CodeExtent {\n             region::CodeExtent::DestructionScope(node_id)\n         }\n         'B' => {\n+            assert_eq!(next(st), '[');\n             let node_id = parse_uint(st) as ast::NodeId;\n+            assert_eq!(next(st), '|');\n             let first_stmt_index = parse_uint(st);\n+            assert_eq!(next(st), ']');\n             let block_remainder = region::BlockRemainder {\n                 block: node_id, first_statement_index: first_stmt_index,\n             };"}, {"sha": "90a905f1840714401c9cfe4ec1c36b5ffe5ed7c9", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -275,9 +275,11 @@ pub fn enc_region(w: &mut Encoder, cx: &ctxt, r: ty::Region) {\n \n fn enc_scope(w: &mut Encoder, _cx: &ctxt, scope: region::CodeExtent) {\n     match scope {\n+        region::CodeExtent::ParameterScope {\n+            fn_id, body_id } => mywrite!(w, \"P[{}|{}]\", fn_id, body_id),\n         region::CodeExtent::Misc(node_id) => mywrite!(w, \"M{}\", node_id),\n         region::CodeExtent::Remainder(region::BlockRemainder {\n-            block: b, first_statement_index: i }) => mywrite!(w, \"B{}{}\", b, i),\n+            block: b, first_statement_index: i }) => mywrite!(w, \"B[{}|{}]\", b, i),\n         region::CodeExtent::DestructionScope(node_id) => mywrite!(w, \"D{}\", node_id),\n     }\n }"}, {"sha": "5131322dc41ea701b3b4b25bb03d69623d50826d", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -95,7 +95,15 @@ use syntax::visit::{Visitor, FnKind};\n            RustcDecodable, Debug, Copy)]\n pub enum CodeExtent {\n     Misc(ast::NodeId),\n-    DestructionScope(ast::NodeId), // extent of destructors for temporaries of node-id\n+\n+    // extent of parameters passed to a function or closure (they\n+    // outlive its body)\n+    ParameterScope { fn_id: ast::NodeId, body_id: ast::NodeId },\n+\n+    // extent of destructors for temporaries of node-id\n+    DestructionScope(ast::NodeId),\n+\n+    // extent of code following a `let id = expr;` binding in a block\n     Remainder(BlockRemainder)\n }\n \n@@ -153,15 +161,19 @@ impl CodeExtent {\n     pub fn node_id(&self) -> ast::NodeId {\n         match *self {\n             CodeExtent::Misc(node_id) => node_id,\n+\n+            // These cases all return rough approximations to the\n+            // precise extent denoted by `self`.\n             CodeExtent::Remainder(br) => br.block,\n             CodeExtent::DestructionScope(node_id) => node_id,\n+            CodeExtent::ParameterScope { fn_id: _, body_id } => body_id,\n         }\n     }\n \n     /// Maps this scope to a potentially new one according to the\n     /// NodeId transformer `f_id`.\n-    pub fn map_id<F>(&self, f_id: F) -> CodeExtent where\n-        F: FnOnce(ast::NodeId) -> ast::NodeId,\n+    pub fn map_id<F>(&self, mut f_id: F) -> CodeExtent where\n+        F: FnMut(ast::NodeId) -> ast::NodeId,\n     {\n         match *self {\n             CodeExtent::Misc(node_id) => CodeExtent::Misc(f_id(node_id)),\n@@ -170,6 +182,8 @@ impl CodeExtent {\n                     block: f_id(br.block), first_statement_index: br.first_statement_index }),\n             CodeExtent::DestructionScope(node_id) =>\n                 CodeExtent::DestructionScope(f_id(node_id)),\n+            CodeExtent::ParameterScope { fn_id, body_id } =>\n+                CodeExtent::ParameterScope { fn_id: f_id(fn_id), body_id: f_id(body_id) },\n         }\n     }\n \n@@ -180,6 +194,7 @@ impl CodeExtent {\n         match ast_map.find(self.node_id()) {\n             Some(ast_map::NodeBlock(ref blk)) => {\n                 match *self {\n+                    CodeExtent::ParameterScope { .. } |\n                     CodeExtent::Misc(_) |\n                     CodeExtent::DestructionScope(_) => Some(blk.span),\n \n@@ -277,6 +292,7 @@ enum InnermostDeclaringBlock {\n     Block(ast::NodeId),\n     Statement(DeclaringStatementContext),\n     Match(ast::NodeId),\n+    FnDecl { fn_id: ast::NodeId, body_id: ast::NodeId },\n }\n \n impl InnermostDeclaringBlock {\n@@ -285,6 +301,8 @@ impl InnermostDeclaringBlock {\n             InnermostDeclaringBlock::None => {\n                 return Option::None;\n             }\n+            InnermostDeclaringBlock::FnDecl { fn_id, body_id } =>\n+                CodeExtent::ParameterScope { fn_id: fn_id, body_id: body_id },\n             InnermostDeclaringBlock::Block(id) |\n             InnermostDeclaringBlock::Match(id) => CodeExtent::from_node_id(id),\n             InnermostDeclaringBlock::Statement(s) =>  s.to_code_extent(),\n@@ -1198,25 +1216,34 @@ fn resolve_fn(visitor: &mut RegionResolutionVisitor,\n            body.id,\n            visitor.cx.parent);\n \n+    // This scope covers the function body, which includes the\n+    // bindings introduced by let statements as well as temporaries\n+    // created by the fn's tail expression (if any). It does *not*\n+    // include the fn parameters (see below).\n     let body_scope = CodeExtent::from_node_id(body.id);\n     visitor.region_maps.mark_as_terminating_scope(body_scope);\n \n     let dtor_scope = CodeExtent::DestructionScope(body.id);\n     visitor.region_maps.record_encl_scope(body_scope, dtor_scope);\n \n-    record_superlifetime(visitor, dtor_scope, body.span);\n+    let fn_decl_scope = CodeExtent::ParameterScope { fn_id: id, body_id: body.id };\n+    visitor.region_maps.record_encl_scope(dtor_scope, fn_decl_scope);\n+\n+    record_superlifetime(visitor, fn_decl_scope, body.span);\n \n     if let Some(root_id) = visitor.cx.root_id {\n         visitor.region_maps.record_fn_parent(body.id, root_id);\n     }\n \n     let outer_cx = visitor.cx;\n \n-    // The arguments and `self` are parented to the body of the fn.\n+    // The arguments and `self` are parented to the fn.\n     visitor.cx = Context {\n         root_id: Some(body.id),\n-        parent: InnermostEnclosingExpr::Some(body.id),\n-        var_parent: InnermostDeclaringBlock::Block(body.id)\n+        parent: InnermostEnclosingExpr::None,\n+        var_parent: InnermostDeclaringBlock::FnDecl {\n+            fn_id: id, body_id: body.id\n+        },\n     };\n     visit::walk_fn_decl(visitor, decl);\n "}, {"sha": "7358b4cc0f6ecbbf5fe517125b72be04f5fb00dd", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -113,6 +113,9 @@ pub fn explain_region_and_span(cx: &ctxt, region: ty::Region)\n         };\n         let scope_decorated_tag = match scope {\n             region::CodeExtent::Misc(_) => tag,\n+            region::CodeExtent::ParameterScope { .. } => {\n+                \"scope of parameters for function\"\n+            }\n             region::CodeExtent::DestructionScope(_) => {\n                 new_string = format!(\"destruction scope surrounding {}\", tag);\n                 &*new_string\n@@ -952,6 +955,8 @@ impl<'tcx> Repr<'tcx> for ty::FreeRegion {\n impl<'tcx> Repr<'tcx> for region::CodeExtent {\n     fn repr(&self, _tcx: &ctxt) -> String {\n         match *self {\n+            region::CodeExtent::ParameterScope { fn_id, body_id } =>\n+                format!(\"ParameterScope({}, {})\", fn_id, body_id),\n             region::CodeExtent::Misc(node_id) =>\n                 format!(\"Misc({})\", node_id),\n             region::CodeExtent::DestructionScope(node_id) =>"}, {"sha": "993893438e53642124186dd200743662ae9dd24d", "filename": "src/test/compile-fail/issue-23338-locals-die-before-temps-of-body.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Fcompile-fail%2Fissue-23338-locals-die-before-temps-of-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Fcompile-fail%2Fissue-23338-locals-die-before-temps-of-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-23338-locals-die-before-temps-of-body.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is just checking that we still reject code where temp values\n+// are borrowing values for longer than they will be around.\n+//\n+// Compare to run-pass/issue-23338-params-outlive-temps-of-body.rs\n+\n+use std::cell::RefCell;\n+\n+fn foo(x: RefCell<String>) -> String {\n+    let y = x;\n+    y.borrow().clone() //~ ERROR `y` does not live long enough\n+}\n+\n+fn foo2(x: RefCell<String>) -> String {\n+    let ret = {\n+        let y = x;\n+        y.borrow().clone() //~ ERROR `y` does not live long enough\n+    };\n+    ret\n+}\n+\n+fn main() {\n+    let r = RefCell::new(format!(\"data\"));\n+    assert_eq!(foo(r), \"data\");\n+    let r = RefCell::new(format!(\"data\"));\n+    assert_eq!(foo2(r), \"data\");\n+}"}, {"sha": "0815ff084fb51c67ff732d173dc6a6bd614aa6f1", "filename": "src/test/run-pass/issue-23338-ensure-param-drop-order.rs", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23338-ensure-param-drop-order.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-pretty : (#23623) problems when  ending with // comments\n+\n+// This test is ensuring that parameters are indeed dropped after\n+// temporaries in a fn body.\n+\n+use std::cell::RefCell;\n+\n+use self::d::D;\n+\n+pub fn main() {\n+    let log = RefCell::new(vec![]);\n+    d::println(&format!(\"created empty log\"));\n+    test(&log);\n+\n+    assert_eq!(&log.borrow()[..],\n+               [\n+                   //                                    created empty log\n+                   //    +-- Make D(da_0, 0)\n+                   //    | +-- Make D(de_1, 1)\n+                   //    | |                             calling foo\n+                   //    | |                             entered foo\n+                   //    | | +-- Make D(de_2, 2)\n+                   //    | | | +-- Make D(da_1, 3)\n+                   //    | | | | +-- Make D(de_3, 4)\n+                   //    | | | | | +-- Make D(de_4, 5)\n+                   3, // | | | +-- Drop D(da_1, 3)\n+                   //    | | |   | |\n+                   4, // | | |   +-- Drop D(de_3, 4)\n+                   //    | | |     |\n+                   //    | | |     |                     eval tail of foo\n+                   //    | | | +-- Make D(de_5, 6)\n+                   //    | | | | +-- Make D(de_6, 7)\n+                   6, // | | | +-- Drop D(de_5, 6)\n+                   //    | | |   | |\n+                   5, // | | |   | +-- Drop D(de_4, 5)\n+                   //    | | |   |\n+                   2, // | | +-- Drop D(de_2, 2)\n+                   //    | |     |\n+                   1, // | +-- Drop D(de_1, 1)\n+                   //    |       |\n+                   0, // +-- Drop D(da_0, 0)\n+                   //            |\n+                   //            |                       result D(de_6, 7)\n+                   7 //          +-- Drop D(de_6, 7)\n+\n+                       ]);\n+}\n+\n+fn test<'a>(log: d::Log<'a>) {\n+    let da = D::new(\"da\", 0, log);\n+    let de = D::new(\"de\", 1, log);\n+    d::println(&format!(\"calling foo\"));\n+    let result = foo(da, de);\n+    d::println(&format!(\"result {}\", result));\n+}\n+\n+fn foo<'a>(da0: D<'a>, de1: D<'a>) -> D<'a> {\n+    d::println(&format!(\"entered foo\"));\n+    let de2 = de1.incr();      // creates D(de_2, 2)\n+    let de4 = {\n+        let _da1 = da0.incr(); // creates D(da_1, 3)\n+        de2.incr().incr()      // creates D(de_3, 4) and D(de_4, 5)\n+    };\n+    d::println(&format!(\"eval tail of foo\"));\n+    de4.incr().incr()          // creates D(de_5, 6) and D(de_6, 7)\n+}\n+\n+// This module provides simultaneous printouts of the dynamic extents\n+// of all of the D values, in addition to logging the order that each\n+// is dropped.\n+\n+const PREF_INDENT: u32 = 16;\n+\n+pub mod d {\n+    #![allow(unused_parens)]\n+    use std::fmt;\n+    use std::mem;\n+    use std::cell::RefCell;\n+\n+    static mut counter: u32 = 0;\n+    static mut trails: u64 = 0;\n+\n+    pub type Log<'a> = &'a RefCell<Vec<u32>>;\n+\n+    pub fn current_width() -> u32 {\n+        unsafe { max_width() - trails.leading_zeros() }\n+    }\n+\n+    pub fn max_width() -> u32 {\n+        unsafe {\n+            (mem::size_of_val(&trails)*8) as u32\n+        }\n+    }\n+\n+    pub fn indent_println(my_trails: u32, s: &str) {\n+        let mut indent: String = String::new();\n+        for i in 0..my_trails {\n+            unsafe {\n+                if trails & (1 << i) != 0 {\n+                    indent = indent + \"| \";\n+                } else {\n+                    indent = indent + \"  \";\n+                }\n+            }\n+        }\n+        println!(\"{}{}\", indent, s);\n+    }\n+\n+    pub fn println(s: &str) {\n+        indent_println(super::PREF_INDENT, s);\n+    }\n+\n+    fn first_avail() -> u32 {\n+        unsafe {\n+            for i in 0..64 {\n+                if trails & (1 << i) == 0 {\n+                    return i;\n+                }\n+            }\n+        }\n+        panic!(\"exhausted trails\");\n+    }\n+\n+    pub struct D<'a> {\n+        name: &'static str, i: u32, uid: u32, trail: u32, log: Log<'a>\n+    }\n+\n+    impl<'a> fmt::Display for D<'a> {\n+        fn fmt(&self, w: &mut fmt::Formatter) -> fmt::Result {\n+            write!(w, \"D({}_{}, {})\", self.name, self.i, self.uid)\n+        }\n+    }\n+\n+    impl<'a> D<'a> {\n+        pub fn new(name: &'static str, i: u32, log: Log<'a>) -> D<'a> {\n+            unsafe {\n+                let trail = first_avail();\n+                let ctr = counter;\n+                counter += 1;\n+                trails |= (1 << trail);\n+                let ret = D {\n+                    name: name, i: i, log: log, uid: ctr, trail: trail\n+                };\n+                indent_println(trail, &format!(\"+-- Make {}\", ret));\n+                ret\n+            }\n+        }\n+        pub fn incr(&self) -> D<'a> {\n+            D::new(self.name, self.i + 1, self.log)\n+        }\n+    }\n+\n+    impl<'a> Drop for D<'a> {\n+        fn drop(&mut self) {\n+            unsafe { trails &= !(1 << self.trail); };\n+            self.log.borrow_mut().push(self.uid);\n+            indent_println(self.trail, &format!(\"+-- Drop {}\", self));\n+            indent_println(::PREF_INDENT, \"\");\n+        }\n+    }\n+}"}, {"sha": "cb9e852e526928b068178b803e161acdcfc0e9c2", "filename": "src/test/run-pass/issue-23338-params-outlive-temps-of-body.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Frun-pass%2Fissue-23338-params-outlive-temps-of-body.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9266d599f4f2367bbc3a5a76a9ce3251da8a1736/src%2Ftest%2Frun-pass%2Fissue-23338-params-outlive-temps-of-body.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-23338-params-outlive-temps-of-body.rs?ref=9266d599f4f2367bbc3a5a76a9ce3251da8a1736", "patch": "@@ -0,0 +1,39 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is largely checking that we now accept code where temp values\n+// are borrowing from the input parameters (the `foo` case below).\n+//\n+// Compare to run-pass/issue-23338-params-outlive-temps-of-body.rs\n+//\n+// (The `foo2` case is just for parity with the above test, which\n+//  shows what happens when you move the `y`-binding to the inside of\n+//  the inner block.)\n+\n+use std::cell::RefCell;\n+\n+fn foo(x: RefCell<String>) -> String {\n+    x.borrow().clone()\n+}\n+\n+fn foo2(x: RefCell<String>) -> String {\n+    let y = x;\n+    let ret = {\n+        y.borrow().clone()\n+    };\n+    ret\n+}\n+\n+pub fn main() {\n+    let r = RefCell::new(format!(\"data\"));\n+    assert_eq!(foo(r), \"data\");\n+    let r = RefCell::new(format!(\"data\"));\n+    assert_eq!(foo2(r), \"data\");\n+}"}]}