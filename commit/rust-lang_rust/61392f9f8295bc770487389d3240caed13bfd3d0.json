{"sha": "61392f9f8295bc770487389d3240caed13bfd3d0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxMzkyZjlmODI5NWJjNzcwNDg3Mzg5ZDMyNDBjYWVkMTNiZmQzZDA=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T12:02:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-08-30T12:02:20Z"}, "message": "Clean up trans_build, factor repeated code into function", "tree": {"sha": "50a9872ca75211d2d1d3884cee98185a9b074ae8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50a9872ca75211d2d1d3884cee98185a9b074ae8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61392f9f8295bc770487389d3240caed13bfd3d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61392f9f8295bc770487389d3240caed13bfd3d0", "html_url": "https://github.com/rust-lang/rust/commit/61392f9f8295bc770487389d3240caed13bfd3d0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61392f9f8295bc770487389d3240caed13bfd3d0/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e17e6af4f0acd692225130a278174047ecb252ae", "url": "https://api.github.com/repos/rust-lang/rust/commits/e17e6af4f0acd692225130a278174047ecb252ae", "html_url": "https://github.com/rust-lang/rust/commit/e17e6af4f0acd692225130a278174047ecb252ae"}], "stats": {"total": 387, "additions": 105, "deletions": 282}, "files": [{"sha": "97904e9cbf57b2fc53abc1fca43c1325b11685fc", "filename": "src/comp/middle/trans_build.rs", "status": "modified", "additions": 96, "deletions": 265, "changes": 361, "blob_url": "https://github.com/rust-lang/rust/blob/61392f9f8295bc770487389d3240caed13bfd3d0/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61392f9f8295bc770487389d3240caed13bfd3d0/src%2Fcomp%2Fmiddle%2Ftrans_build.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_build.rs?ref=61392f9f8295bc770487389d3240caed13bfd3d0", "patch": "@@ -5,620 +5,478 @@ import llvm::{ValueRef, TypeRef, BasicBlockRef, BuilderRef,\n               Opcode, ModuleRef};\n import trans_common::block_ctxt;\n \n+fn B(cx: &@block_ctxt) -> BuilderRef {\n+    let b = *cx.fcx.lcx.ccx.builder;\n+    llvm::LLVMPositionBuilderAtEnd(b, cx.llbb);\n+    ret b;\n+}\n+\n fn RetVoid(cx: &@block_ctxt) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildRetVoid(B);\n+    ret llvm::LLVMBuildRetVoid(B(cx));\n }\n \n fn Ret(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildRet(B, V);\n+    ret llvm::LLVMBuildRet(B(cx), V);\n }\n \n fn AggregateRet(cx: &@block_ctxt, RetVals: &[ValueRef]) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildAggregateRet(B, vec::to_ptr(RetVals),\n+    ret llvm::LLVMBuildAggregateRet(B(cx), vec::to_ptr(RetVals),\n                                     vec::len(RetVals));\n }\n \n fn Br(cx: &@block_ctxt, Dest: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildBr(B, Dest);\n+    ret llvm::LLVMBuildBr(B(cx), Dest);\n }\n \n fn CondBr(cx: &@block_ctxt, If: ValueRef, Then: BasicBlockRef,\n           Else: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildCondBr(B, If, Then, Else);\n+    ret llvm::LLVMBuildCondBr(B(cx), If, Then, Else);\n }\n \n fn Switch(cx: &@block_ctxt, V: ValueRef, Else: BasicBlockRef,\n           NumCases: uint) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildSwitch(B, V, Else, NumCases);\n+    ret llvm::LLVMBuildSwitch(B(cx), V, Else, NumCases);\n }\n \n fn IndirectBr(cx: &@block_ctxt, Addr: ValueRef,\n               NumDests: uint) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildIndirectBr(B, Addr, NumDests);\n+    ret llvm::LLVMBuildIndirectBr(B(cx), Addr, NumDests);\n }\n \n fn Invoke(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n           Then: BasicBlockRef, Catch: BasicBlockRef) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInvoke(B, Fn, vec::to_ptr(Args),\n+        llvm::LLVMBuildInvoke(B(cx), Fn, vec::to_ptr(Args),\n                               vec::len(Args), Then, Catch, buf)\n     });\n }\n \n fn Unreachable(cx: &@block_ctxt) -> ValueRef {\n     assert (!cx.terminated);;\n     cx.terminated = true;\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildUnreachable(B);\n+    ret llvm::LLVMBuildUnreachable(B(cx));\n }\n \n /* Arithmetic */\n fn Add(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAdd(B, LHS, RHS, buf)\n+        llvm::LLVMBuildAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWAdd(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNSWAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWAdd(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNUWAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FAdd(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFAdd(B, LHS, RHS, buf)\n+        llvm::LLVMBuildFAdd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Sub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSub(B, LHS, RHS, buf)\n+        llvm::LLVMBuildSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWSub(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNSWSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWSub(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNUWSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FSub(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFSub(B, LHS, RHS, buf)\n+        llvm::LLVMBuildFSub(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Mul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildMul(B, LHS, RHS, buf)\n+        llvm::LLVMBuildMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NSWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWMul(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNSWMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn NUWMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWMul(B, LHS, RHS, buf)\n+        llvm::LLVMBuildNUWMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FMul(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFMul(B, LHS, RHS, buf)\n+        llvm::LLVMBuildFMul(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn UDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildUDiv(B, LHS, RHS, buf)\n+        llvm::LLVMBuildUDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn SDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSDiv(B, LHS, RHS, buf)\n+        llvm::LLVMBuildSDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn ExactSDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExactSDiv(B, LHS, RHS, buf)\n+        llvm::LLVMBuildExactSDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FDiv(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFDiv(B, LHS, RHS, buf)\n+        llvm::LLVMBuildFDiv(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn URem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildURem(B, LHS, RHS, buf)\n+        llvm::LLVMBuildURem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn SRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSRem(B, LHS, RHS, buf)\n+        llvm::LLVMBuildSRem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn FRem(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFRem(B, LHS, RHS, buf)\n+        llvm::LLVMBuildFRem(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Shl(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildShl(B, LHS, RHS, buf)\n+        llvm::LLVMBuildShl(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn LShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildLShr(B, LHS, RHS, buf)\n+        llvm::LLVMBuildLShr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn AShr(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAShr(B, LHS, RHS, buf)\n+        llvm::LLVMBuildAShr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn And(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAnd(B, LHS, RHS, buf)\n+        llvm::LLVMBuildAnd(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Or(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildOr(B, LHS, RHS, buf)\n+        llvm::LLVMBuildOr(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Xor(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildXor(B, LHS, RHS, buf)\n+        llvm::LLVMBuildXor(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn BinOp(cx: &@block_ctxt, Op: Opcode, LHS: ValueRef,\n          RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildBinOp(B, Op, LHS, RHS, buf)\n+        llvm::LLVMBuildBinOp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n \n fn Neg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNeg(B, V, buf)\n+        llvm::LLVMBuildNeg(B(cx), V, buf)\n     });\n }\n \n fn NSWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNSWNeg(B, V, buf)\n+        llvm::LLVMBuildNSWNeg(B(cx), V, buf)\n     });\n }\n \n fn NUWNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNUWNeg(B, V, buf)\n+        llvm::LLVMBuildNUWNeg(B(cx), V, buf)\n     });\n }\n fn FNeg(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFNeg(B, V, buf)\n+        llvm::LLVMBuildFNeg(B(cx), V, buf)\n     });\n }\n \n fn Not(cx: &@block_ctxt, V: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildNot(B, V, buf)\n+        llvm::LLVMBuildNot(B(cx), V, buf)\n     });\n }\n \n /* Memory */\n fn Malloc(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildMalloc(B, Ty, buf)\n+        llvm::LLVMBuildMalloc(B(cx), Ty, buf)\n     });\n }\n \n fn ArrayMalloc(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildArrayMalloc(B, Ty, Val, buf)\n+        llvm::LLVMBuildArrayMalloc(B(cx), Ty, Val, buf)\n     });\n }\n \n fn Alloca(cx: &@block_ctxt, Ty: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildAlloca(B, Ty, buf)\n+        llvm::LLVMBuildAlloca(B(cx), Ty, buf)\n     });\n }\n \n fn ArrayAlloca(cx: &@block_ctxt, Ty: TypeRef, Val: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildArrayAlloca(B, Ty, Val, buf)\n+        llvm::LLVMBuildArrayAlloca(B(cx), Ty, Val, buf)\n     });\n }\n \n fn Free(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildFree(B, PointerVal);\n+    ret llvm::LLVMBuildFree(B(cx), PointerVal);\n }\n \n fn Load(cx: &@block_ctxt, PointerVal: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildLoad(B, PointerVal, buf)\n+        llvm::LLVMBuildLoad(B(cx), PointerVal, buf)\n     });\n }\n \n fn Store(cx: &@block_ctxt, Val: ValueRef, Ptr: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    ret llvm::LLVMBuildStore(B, Val, Ptr);\n+    ret llvm::LLVMBuildStore(B(cx), Val, Ptr);\n }\n \n fn GEP(cx: &@block_ctxt, Pointer: ValueRef,\n        Indices: &[ValueRef]) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGEP(B, Pointer, vec::to_ptr(Indices),\n+        llvm::LLVMBuildGEP(B(cx), Pointer, vec::to_ptr(Indices),\n                            vec::len(Indices), buf)\n     });\n }\n \n fn InBoundsGEP(cx: &@block_ctxt, Pointer: ValueRef,\n                Indices: &[ValueRef]) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInBoundsGEP(B, Pointer, vec::to_ptr(Indices),\n+        llvm::LLVMBuildInBoundsGEP(B(cx), Pointer, vec::to_ptr(Indices),\n                                    vec::len(Indices), buf)\n     });\n }\n \n fn StructGEP(cx: &@block_ctxt, Pointer: ValueRef, Idx: uint) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildStructGEP(B, Pointer, Idx, buf)\n+        llvm::LLVMBuildStructGEP(B(cx), Pointer, Idx, buf)\n     });\n }\n \n fn GlobalString(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGlobalString(B, _Str, buf)\n+        llvm::LLVMBuildGlobalString(B(cx), _Str, buf)\n     });\n }\n \n fn GlobalStringPtr(cx: &@block_ctxt, _Str: sbuf) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildGlobalStringPtr(B, _Str, buf)\n+        llvm::LLVMBuildGlobalStringPtr(B(cx), _Str, buf)\n     });\n }\n \n /* Casts */\n fn Trunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildTrunc(B, Val, DestTy, buf)\n+        llvm::LLVMBuildTrunc(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn ZExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildZExt(B, Val, DestTy, buf)\n+        llvm::LLVMBuildZExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSExt(B, Val, DestTy, buf)\n+        llvm::LLVMBuildSExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPToUI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPToUI(B, Val, DestTy, buf)\n+        llvm::LLVMBuildFPToUI(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPToSI(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPToSI(B, Val, DestTy, buf)\n+        llvm::LLVMBuildFPToSI(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn UIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildUIToFP(B, Val, DestTy, buf)\n+        llvm::LLVMBuildUIToFP(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SIToFP(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSIToFP(B, Val, DestTy, buf)\n+        llvm::LLVMBuildSIToFP(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPTrunc(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPTrunc(B, Val, DestTy, buf)\n+        llvm::LLVMBuildFPTrunc(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPExt(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPExt(B, Val, DestTy, buf)\n+        llvm::LLVMBuildFPExt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn PtrToInt(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPtrToInt(B, Val, DestTy, buf)\n+        llvm::LLVMBuildPtrToInt(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn IntToPtr(cx: &@block_ctxt, Val: ValueRef,\n             DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIntToPtr(B, Val, DestTy, buf)\n+        llvm::LLVMBuildIntToPtr(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn BitCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildBitCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn ZExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildZExtOrBitCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildZExtOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn SExtOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                  DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSExtOrBitCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildSExtOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn TruncOrBitCast(cx: &@block_ctxt, Val: ValueRef,\n                   DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildTruncOrBitCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildTruncOrBitCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn Cast(cx: &@block_ctxt, Op: Opcode, Val: ValueRef,\n         DestTy: TypeRef, _Name: sbuf) ->\n     ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCast(B, Op, Val, DestTy, buf)\n+        llvm::LLVMBuildCast(B(cx), Op, Val, DestTy, buf)\n     });\n }\n \n fn PointerCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPointerCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildPointerCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn IntCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIntCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildIntCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n fn FPCast(cx: &@block_ctxt, Val: ValueRef, DestTy: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFPCast(B, Val, DestTy, buf)\n+        llvm::LLVMBuildFPCast(B(cx), Val, DestTy, buf)\n     });\n }\n \n \n /* Comparisons */\n fn ICmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildICmp(B, Op, LHS, RHS, buf)\n+        llvm::LLVMBuildICmp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n \n fn FCmp(cx: &@block_ctxt, Op: uint, LHS: ValueRef,\n         RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildFCmp(B, Op, LHS, RHS, buf)\n+        llvm::LLVMBuildFCmp(B(cx), Op, LHS, RHS, buf)\n     });\n }\n \n \n /* Miscellaneous instructions */\n fn Phi(cx: &@block_ctxt, Ty: TypeRef, vals: &[ValueRef],\n        bbs: &[BasicBlockRef]) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     let phi = istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPhi(B, Ty, buf)\n+        llvm::LLVMBuildPhi(B(cx), Ty, buf)\n     });\n     assert (vec::len::<ValueRef>(vals) == vec::len::<BasicBlockRef>(bbs));\n     llvm::LLVMAddIncoming(phi, vec::to_ptr(vals), vec::to_ptr(bbs),\n@@ -633,125 +491,98 @@ fn AddIncomingToPhi(phi: ValueRef, vals: &[ValueRef], bbs: &[BasicBlockRef]) {\n }\n \n fn Call(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args),\n+        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args),\n                             vec::len(Args), buf)\n     });\n }\n \n fn FastCall(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef]) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     let v = istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args), buf)\n+        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n     llvm::LLVMSetInstructionCallConv(v, lib::llvm::LLVMFastCallConv);\n     ret v;\n }\n \n fn CallWithConv(cx: &@block_ctxt, Fn: ValueRef, Args: &[ValueRef],\n                 Conv: uint) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     let v = istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B, Fn, vec::to_ptr(Args), vec::len(Args), buf)\n+        llvm::LLVMBuildCall(B(cx), Fn, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n     llvm::LLVMSetInstructionCallConv(v, Conv);\n     ret v;\n }\n \n fn Select(cx: &@block_ctxt, If: ValueRef, Then: ValueRef,\n           Else: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildSelect(B, If, Then, Else, buf)\n+        llvm::LLVMBuildSelect(B(cx), If, Then, Else, buf)\n     });\n }\n \n fn VAArg(cx: &@block_ctxt, list: ValueRef, Ty: TypeRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildVAArg(B, list, Ty, buf)\n+        llvm::LLVMBuildVAArg(B(cx), list, Ty, buf)\n     });\n }\n \n fn ExtractElement(cx: &@block_ctxt, VecVal: ValueRef,\n                   Index: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExtractElement(B, VecVal, Index, buf)\n+        llvm::LLVMBuildExtractElement(B(cx), VecVal, Index, buf)\n     });\n }\n \n fn InsertElement(cx: &@block_ctxt, VecVal: ValueRef, EltVal: ValueRef,\n                  Index: ValueRef) ->\n     ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInsertElement(B, VecVal, EltVal, Index, buf)\n+        llvm::LLVMBuildInsertElement(B(cx), VecVal, EltVal, Index, buf)\n     });\n }\n \n fn ShuffleVector(cx: &@block_ctxt, V1: ValueRef, V2: ValueRef,\n                  Mask: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildShuffleVector(B, V1, V2, Mask, buf)\n+        llvm::LLVMBuildShuffleVector(B(cx), V1, V2, Mask, buf)\n     });\n }\n \n fn ExtractValue(cx: &@block_ctxt, AggVal: ValueRef, Index: uint) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildExtractValue(B, AggVal, Index, buf)\n+        llvm::LLVMBuildExtractValue(B(cx), AggVal, Index, buf)\n     });\n }\n \n fn InsertValue(cx: &@block_ctxt, AggVal: ValueRef,\n                EltVal: ValueRef, Index: uint) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildInsertValue(B, AggVal, EltVal, Index, buf)\n+        llvm::LLVMBuildInsertValue(B(cx), AggVal, EltVal, Index, buf)\n     });\n }\n \n fn IsNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIsNull(B, Val, buf)\n+        llvm::LLVMBuildIsNull(B(cx), Val, buf)\n     });\n }\n \n fn IsNotNull(cx: &@block_ctxt, Val: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildIsNotNull(B, Val, buf)\n+        llvm::LLVMBuildIsNotNull(B(cx), Val, buf)\n     });\n }\n \n fn PtrDiff(cx: &@block_ctxt, LHS: ValueRef, RHS: ValueRef) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildPtrDiff(B, LHS, RHS, buf)\n+        llvm::LLVMBuildPtrDiff(B(cx), LHS, RHS, buf)\n     });\n }\n \n fn Trap(cx: &@block_ctxt) -> ValueRef {\n-    let B = *cx.fcx.lcx.ccx.builder;\n-    llvm::LLVMPositionBuilderAtEnd(B, cx.llbb);\n-    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(B);\n+    let b = B(cx);\n+    let BB: BasicBlockRef = llvm::LLVMGetInsertBlock(b);\n     let FN: ValueRef = llvm::LLVMGetBasicBlockParent(BB);\n     let M: ModuleRef = llvm::LLVMGetGlobalParent(FN);\n     let T: ValueRef = istr::as_buf(~\"llvm.trap\", { |buf|\n@@ -760,7 +591,7 @@ fn Trap(cx: &@block_ctxt) -> ValueRef {\n     assert (T as int != 0);\n     let Args: [ValueRef] = [];\n     ret istr::as_buf(~\"\", { |buf|\n-        llvm::LLVMBuildCall(B, T, vec::to_ptr(Args), vec::len(Args), buf)\n+        llvm::LLVMBuildCall(b, T, vec::to_ptr(Args), vec::len(Args), buf)\n     });\n }\n "}, {"sha": "fc211b1dfaa14bd4a11d33bf0238290f493d714c", "filename": "src/comp/middle/trans_common.rs", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/61392f9f8295bc770487389d3240caed13bfd3d0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61392f9f8295bc770487389d3240caed13bfd3d0/src%2Fcomp%2Fmiddle%2Ftrans_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans_common.rs?ref=61392f9f8295bc770487389d3240caed13bfd3d0", "patch": "@@ -397,29 +397,21 @@ type block_ctxt =\n     // llvm::LLVMAppendBasicBlock(llfn, name), which adds a basic\n     // block to the function pointed to by llfn.  We insert\n     // instructions into that block by way of this block context.\n-\n-    // The llvm::builder object serving as an interface to LLVM's\n-    // LLVMBuild* functions.\n-\n-    // The block pointing to this one in the function's digraph.\n-\n-    // The 'kind' of basic block this is.\n-\n-    // A list of functions that run at the end of translating this\n-    // block, cleaning up any variables that were introduced in the\n-    // block and need to go out of scope at the end of it.\n-\n-    // The source span where this block comes from, for error\n-    // reporting.\n-\n-    // The function context for the function to which this block is\n-    // attached.\n     {llbb: BasicBlockRef,\n      mutable terminated: bool,\n+     // The block pointing to this one in the function's digraph.\n      parent: block_parent,\n+     // The 'kind' of basic block this is.\n      kind: block_kind,\n+     // A list of functions that run at the end of translating this\n+     // block, cleaning up any variables that were introduced in the\n+     // block and need to go out of scope at the end of it.\n      mutable cleanups: [cleanup],\n+     // The source span where this block comes from, for error\n+     // reporting. FIXME this is not currently reliable\n      sp: span,\n+     // The function context for the function to which this block is\n+     // attached.\n      fcx: @fn_ctxt};\n \n fn is_terminated(cx: &@block_ctxt) -> bool {"}]}