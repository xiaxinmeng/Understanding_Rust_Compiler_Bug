{"sha": "9cc3deaa9256060868bb952ea5f850a910633f19", "node_id": "MDY6Q29tbWl0NzI0NzEyOjljYzNkZWFhOTI1NjA2MDg2OGJiOTUyZWE1Zjg1MGE5MTA2MzNmMTk=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-14T04:58:33Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2020-12-14T05:00:02Z"}, "message": "Finish refactoring vector types", "tree": {"sha": "c1404990aa5eec28942e5b56886fc5aa1e4c0603", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c1404990aa5eec28942e5b56886fc5aa1e4c0603"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9cc3deaa9256060868bb952ea5f850a910633f19", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3deaa9256060868bb952ea5f850a910633f19", "html_url": "https://github.com/rust-lang/rust/commit/9cc3deaa9256060868bb952ea5f850a910633f19", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9cc3deaa9256060868bb952ea5f850a910633f19/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25c7640fb331112d5bf445c0893af89ee3e9ea9d", "url": "https://api.github.com/repos/rust-lang/rust/commits/25c7640fb331112d5bf445c0893af89ee3e9ea9d", "html_url": "https://github.com/rust-lang/rust/commit/25c7640fb331112d5bf445c0893af89ee3e9ea9d"}], "stats": {"total": 1253, "additions": 568, "deletions": 685}, "files": [{"sha": "51689cd97bea480fb370dea37b316ea7f0837fab", "filename": "crates/core_simd/src/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fintrinsics.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,7 +1,7 @@\n //! This module contains the LLVM intrinsics bindings that provide the functionality for this\n //! crate.\n //!\n-//! The LLVM assembly language is documented here: https://llvm.org/docs/LangRef.html\n+//! The LLVM assembly language is documented here: <https://llvm.org/docs/LangRef.html>\n \n /// These intrinsics aren't linked directly from LLVM and are mostly undocumented, however they are\n /// simply lowered to the matching LLVM instructions by the compiler.  The associated instruction"}, {"sha": "9d4ce683f22a4324f74f3cb9f0fe591de808568f", "filename": "crates/core_simd/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Flib.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -11,8 +11,8 @@ mod intrinsics;\n mod ops;\n //mod round;\n \n-//pub mod masks;\n-//pub use masks::opaque::*;\n+mod masks;\n+pub use masks::*;\n \n mod vectors_u8;\n pub use vectors_u8::*;"}, {"sha": "829174669c2af02e32ff5c8edc509c467294b0ad", "filename": "crates/core_simd/src/masks/full_masks/mod.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fmod.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -0,0 +1,199 @@\n+//! Masks that take up full SIMD vector registers.\n+\n+/// The error type returned when converting an integer to a mask fails.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub struct TryFromMaskError(());\n+\n+impl core::fmt::Display for TryFromMaskError {\n+    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+        write!(f, \"mask vector must have all bits set or unset in each lane\")\n+    }\n+}\n+\n+macro_rules! define_mask {\n+    { $(#[$attr:meta])* struct $name:ident<const $lanes:ident: usize>($type:ty); } => {\n+        $(#[$attr])*\n+        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n+        #[repr(transparent)]\n+        pub struct $name<const $lanes: usize>($type);\n+\n+        delegate_ops_to_inner! { $name }\n+\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$type>::splat(value.into()))\n+            }\n+\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0[lane] > 0\n+            }\n+\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0[lane] = if value {\n+                    !0\n+                } else {\n+                    0\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<bool> for $name<$lanes> {\n+            fn from(value: bool) -> Self {\n+                Self::splat(value)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::TryFrom<$type> for $name<$lanes> {\n+            type Error = TryFromMaskError;\n+            fn try_from(value: $type) -> Result<Self, Self::Error> {\n+                if value.as_slice().iter().all(|x| *x == 0 || !*x == 0) {\n+                    Ok(Self(value))\n+                } else {\n+                    Err(TryFromMaskError(()))\n+                }\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::convert::From<$name<$lanes>> for $type {\n+            fn from(value: $name<$lanes>) -> Self {\n+                value.0\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                f.debug_list()\n+                    .entries((0..LANES).map(|lane| self.test(lane)))\n+                    .finish()\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Binary for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Binary::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::Octal for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Octal::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::LowerHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::LowerHex::fmt(&self.0, f)\n+            }\n+        }\n+\n+        impl<const $lanes: usize> core::fmt::UpperHex for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::UpperHex::fmt(&self.0, f)\n+            }\n+        }\n+    }\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI8](crate::SimdI8), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI8Mask<const LANES: usize>(crate::SimdI8<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI16](crate::SimdI16), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI16Mask<const LANES: usize>(crate::SimdI16<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI32](crate::SimdI32), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI32Mask<const LANES: usize>(crate::SimdI32<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI64](crate::SimdI64), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI64Mask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdI128](crate::SimdI128), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdI128Mask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+define_mask! {\n+    /// A mask equivalent to [SimdIsize](crate::SimdIsize), where all bits in the lane must be either set\n+    /// or unset.\n+    struct SimdIsizeMask<const LANES: usize>(crate::SimdI64<LANES>);\n+}\n+\n+macro_rules! implement_mask_ext {\n+    { $($vector:ident => $mask:ident,)* } => {\n+        $(\n+            impl<const LANES: usize> crate::masks::MaskExt<$mask<LANES>> for crate::$vector<LANES> {\n+                #[inline]\n+                fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_eq(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_ne(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_lt(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_gt(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_le(self, other) }\n+                }\n+\n+                #[inline]\n+                fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n+                    unsafe { crate::intrinsics::simd_ge(self, other) }\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+implement_mask_ext! {\n+    SimdI8 => SimdI8Mask,\n+    SimdI16 => SimdI16Mask,\n+    SimdI32 => SimdI32Mask,\n+    SimdI64 => SimdI64Mask,\n+    SimdI128 => SimdI128Mask,\n+    SimdIsize => SimdIsizeMask,\n+\n+    SimdU8 => SimdI8Mask,\n+    SimdU16 => SimdI16Mask,\n+    SimdU32 => SimdI32Mask,\n+    SimdU64 => SimdI64Mask,\n+    SimdU128 => SimdI128Mask,\n+    SimdUsize => SimdIsizeMask,\n+\n+    SimdF32 => SimdI32Mask,\n+    SimdF64 => SimdI64Mask,\n+}"}, {"sha": "fddddac5fc4f91e1560b26be61d3eaee81f8969e", "filename": "crates/core_simd/src/masks/full_masks/vectors_m128.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m128.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "previous_filename": "crates/core_simd/src/masks/wide/vectors_m128.rs"}, {"sha": "3b05e83f673d67ae7a0d8c69e7bf9ad637393326", "filename": "crates/core_simd/src/masks/full_masks/vectors_m16.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m16.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "previous_filename": "crates/core_simd/src/masks/wide/vectors_m16.rs"}, {"sha": "de5745fb283312e7c4f34e6e9341778615acb98f", "filename": "crates/core_simd/src/masks/full_masks/vectors_m32.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m32.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "previous_filename": "crates/core_simd/src/masks/wide/vectors_m32.rs"}, {"sha": "55c8687fcfc4b4d033333f76742f634b52ee50dc", "filename": "crates/core_simd/src/masks/full_masks/vectors_m64.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m64.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "previous_filename": "crates/core_simd/src/masks/wide/vectors_m64.rs"}, {"sha": "85506dd93e1351476890ad2d0f4868150f497e7a", "filename": "crates/core_simd/src/masks/full_masks/vectors_m8.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_m8.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -19,3 +19,6 @@ define_mask_vector! {\n     /// Vector of 64 `m8` values\n     struct m8x64([i8 as m8; 64]);\n }\n+\n+#[repr(transparent)]\n+struct VectorMask8<const LANES: usize>(crate::SimdI8<LANES>);", "previous_filename": "crates/core_simd/src/masks/wide/vectors_m8.rs"}, {"sha": "497aba8ddbbf7abff50ec4798318a71f16344d83", "filename": "crates/core_simd/src/masks/full_masks/vectors_msize.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_msize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_msize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks%2Fvectors_msize.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "previous_filename": "crates/core_simd/src/masks/wide/vectors_msize.rs"}, {"sha": "9c90373fb47223e24e5c310cb70f579648dd05a8", "filename": "crates/core_simd/src/masks/mod.rs", "status": "modified", "additions": 269, "deletions": 319, "changes": 588, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fmod.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,440 +1,390 @@\n //! Types and traits associated with masking lanes of vectors.\n+#![allow(non_camel_case_types)]\n \n-pub mod wide;\n-\n-mod ops;\n-pub use ops::*;\n-\n-pub(crate) trait MaskImpl {\n-    type Mask;\n-}\n-\n-impl MaskImpl for [u8; 8] {\n-    type Mask = wide::m8x8;\n-}\n-\n-impl MaskImpl for [u8; 16] {\n-    type Mask = wide::m8x16;\n-}\n-\n-impl MaskImpl for [u8; 32] {\n-    type Mask = wide::m8x32;\n-}\n-\n-impl MaskImpl for [u8; 64] {\n-    type Mask = wide::m8x64;\n-}\n-\n-impl MaskImpl for [u16; 4] {\n-    type Mask = wide::m16x4;\n-}\n-\n-impl MaskImpl for [u16; 8] {\n-    type Mask = wide::m16x8;\n-}\n-\n-impl MaskImpl for [u16; 16] {\n-    type Mask = wide::m16x16;\n-}\n-\n-impl MaskImpl for [u16; 32] {\n-    type Mask = wide::m16x32;\n-}\n-\n-impl MaskImpl for [u32; 2] {\n-    type Mask = wide::m32x2;\n-}\n-\n-impl MaskImpl for [u32; 4] {\n-    type Mask = wide::m32x4;\n-}\n-\n-impl MaskImpl for [u32; 8] {\n-    type Mask = wide::m32x8;\n-}\n-\n-impl MaskImpl for [u32; 16] {\n-    type Mask = wide::m32x16;\n-}\n-\n-impl MaskImpl for [u64; 2] {\n-    type Mask = wide::m64x2;\n-}\n-\n-impl MaskImpl for [u64; 4] {\n-    type Mask = wide::m64x4;\n-}\n-\n-impl MaskImpl for [u64; 8] {\n-    type Mask = wide::m64x8;\n-}\n-\n-impl MaskImpl for [u128; 2] {\n-    type Mask = wide::m128x2;\n-}\n-\n-impl MaskImpl for [u128; 4] {\n-    type Mask = wide::m128x4;\n-}\n-\n-impl MaskImpl for [usize; 2] {\n-    type Mask = wide::msizex2;\n-}\n-\n-impl MaskImpl for [usize; 4] {\n-    type Mask = wide::msizex4;\n-}\n-\n-impl MaskImpl for [usize; 8] {\n-    type Mask = wide::msizex8;\n-}\n-\n-macro_rules! define_opaque_mask {\n-    {\n-        $(#[$attr:meta])*\n-        struct $name:ident([$width:ty; $lanes:tt]);\n-    } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        pub struct $name(<[$width; $lanes] as crate::masks::MaskImpl>::Mask);\n-\n-        impl $name {\n-            pub(crate) fn new_from_inner(inner: <[$width; $lanes] as crate::masks::MaskImpl>::Mask) -> Self {\n-                Self(inner)\n-            }\n-\n-            /// Construct a mask by setting all lanes to the given value.\n-            pub fn splat(value: bool) -> Self {\n-                Self(<[$width; $lanes] as crate::masks::MaskImpl>::Mask::splat(value.into()))\n-            }\n-\n-            call_counting_args! { $lanes => define_opaque_mask => new [$width; $lanes] }\n-\n-            /// Tests the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn test(&self, lane: usize) -> bool {\n-                self.0.test(lane)\n-            }\n-\n-            /// Sets the value of the specified lane.\n-            ///\n-            /// # Panics\n-            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n-            #[inline]\n-            pub fn set(&mut self, lane: usize, value: bool) {\n-                self.0.set(lane, value);\n-            }\n-        }\n-\n-        impl Copy for $name {}\n-\n-        impl Clone for $name {\n-            #[inline]\n-            fn clone(&self) -> Self {\n-                *self\n-            }\n-        }\n-\n-        impl Default for $name {\n-            #[inline]\n-            fn default() -> Self {\n-                Self::splat(false)\n-            }\n-        }\n-\n-        impl PartialEq for $name {\n-            #[inline]\n-            fn eq(&self, other: &Self) -> bool {\n-                self.0 == other.0\n-            }\n-        }\n-\n-        impl PartialOrd for $name {\n-            #[inline]\n-            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n-                self.0.partial_cmp(&other.0)\n-            }\n-        }\n-\n-        impl core::fmt::Debug for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Debug::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::ops::BitAnd for $name {\n+macro_rules! delegate_ops_to_inner {\n+    { $name:ident } => {\n+        impl<const LANES: usize> core::ops::BitAnd for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: Self) -> Self {\n                 Self(self.0 & rhs.0)\n             }\n         }\n \n-        impl core::ops::BitAnd<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitAnd<bool> for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitand(self, rhs: bool) -> Self {\n                 self & Self::splat(rhs)\n             }\n         }\n \n-        impl core::ops::BitAnd<$name> for bool {\n-            type Output = $name;\n+        impl<const LANES: usize> core::ops::BitAnd<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n             #[inline]\n-            fn bitand(self, rhs: $name) -> $name {\n-                $name::splat(self) & rhs\n+            fn bitand(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) & rhs\n             }\n         }\n \n-        impl core::ops::BitOr for $name {\n+        impl<const LANES: usize> core::ops::BitOr for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: Self) -> Self {\n                 Self(self.0 | rhs.0)\n             }\n         }\n \n-        impl core::ops::BitOr<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitOr<bool> for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitor(self, rhs: bool) -> Self {\n                 self | Self::splat(rhs)\n             }\n         }\n \n-        impl core::ops::BitOr<$name> for bool {\n-            type Output = $name;\n+        impl<const LANES: usize> core::ops::BitOr<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n             #[inline]\n-            fn bitor(self, rhs: $name) -> $name {\n-                $name::splat(self) | rhs\n+            fn bitor(self, rhs: $name<LANES>) -> $name<LANES> {\n+                $name::<LANES>::splat(self) | rhs\n             }\n         }\n \n-        impl core::ops::BitXor for $name {\n+        impl<const LANES: usize> core::ops::BitXor for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: Self) -> Self::Output {\n                 Self(self.0 ^ rhs.0)\n             }\n         }\n \n-        impl core::ops::BitXor<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitXor<bool> for $name<LANES> {\n             type Output = Self;\n             #[inline]\n             fn bitxor(self, rhs: bool) -> Self::Output {\n                 self ^ Self::splat(rhs)\n             }\n         }\n \n-        impl core::ops::BitXor<$name> for bool {\n-            type Output = $name;\n+        impl<const LANES: usize> core::ops::BitXor<$name<LANES>> for bool {\n+            type Output = $name<LANES>;\n             #[inline]\n-            fn bitxor(self, rhs: $name) -> Self::Output {\n-                $name::splat(self) ^ rhs\n+            fn bitxor(self, rhs: $name<LANES>) -> Self::Output {\n+                $name::<LANES>::splat(self) ^ rhs\n             }\n         }\n \n-        impl core::ops::Not for $name {\n-            type Output = $name;\n+        impl<const LANES: usize> core::ops::Not for $name<LANES> {\n+            type Output = $name<LANES>;\n             #[inline]\n             fn not(self) -> Self::Output {\n                 Self(!self.0)\n             }\n         }\n \n-        impl core::ops::BitAndAssign for $name {\n+        impl<const LANES: usize> core::ops::BitAndAssign for $name<LANES> {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: Self) {\n                 self.0 &= rhs.0;\n             }\n         }\n \n-        impl core::ops::BitAndAssign<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitAndAssign<bool> for $name<LANES> {\n             #[inline]\n             fn bitand_assign(&mut self, rhs: bool) {\n                 *self &= Self::splat(rhs);\n             }\n         }\n \n-        impl core::ops::BitOrAssign for $name {\n+        impl<const LANES: usize> core::ops::BitOrAssign for $name<LANES> {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: Self) {\n                 self.0 |= rhs.0;\n             }\n         }\n \n-        impl core::ops::BitOrAssign<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitOrAssign<bool> for $name<LANES> {\n             #[inline]\n             fn bitor_assign(&mut self, rhs: bool) {\n                 *self |= Self::splat(rhs);\n             }\n         }\n \n-        impl core::ops::BitXorAssign for $name {\n+        impl<const LANES: usize> core::ops::BitXorAssign for $name<LANES> {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: Self) {\n                 self.0 ^= rhs.0;\n             }\n         }\n \n-        impl core::ops::BitXorAssign<bool> for $name {\n+        impl<const LANES: usize> core::ops::BitXorAssign<bool> for $name<LANES> {\n             #[inline]\n             fn bitxor_assign(&mut self, rhs: bool) {\n                 *self ^= Self::splat(rhs);\n             }\n         }\n-    };\n-    { new [$width:ty; $lanes:tt] $($var:ident)* } => {\n-        /// Construct a vector by setting each lane to the given values.\n-        #[allow(clippy::too_many_arguments)]\n-        #[inline]\n-        pub const fn new($($var: bool),*) -> Self {\n-            Self(<[$width; $lanes] as crate::masks::MaskImpl>::Mask::new_from_bool($($var),*))\n-        }\n     }\n }\n \n-pub(crate) mod opaque {\n-    define_opaque_mask! {\n-        /// Mask for 8 8-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask8x8([u8; 8]);\n-    }\n+pub mod full_masks;\n \n-    define_opaque_mask! {\n-        /// Mask for 16 8-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask8x16([u8; 16]);\n-    }\n+macro_rules! define_opaque_mask {\n+    {\n+        $(#[$attr:meta])*\n+        struct $name:ident<const $lanes:ident: usize>($inner_ty:ty);\n+    } => {\n+        $(#[$attr])*\n+        #[allow(non_camel_case_types)]\n+        pub struct $name<const $lanes: usize>($inner_ty);\n \n-    define_opaque_mask! {\n-        /// Mask for 32 8-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask8x32([u8; 32]);\n-    }\n+        delegate_ops_to_inner! { $name }\n \n-    define_opaque_mask! {\n-        /// Mask for 64 8-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask8x64([u8; 64]);\n-    }\n+        impl<const $lanes: usize> $name<$lanes> {\n+            /// Construct a mask by setting all lanes to the given value.\n+            pub fn splat(value: bool) -> Self {\n+                Self(<$inner_ty>::splat(value))\n+            }\n \n-    define_opaque_mask! {\n-        /// Mask for 4 16-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask16x4([u16; 4]);\n-    }\n+            /// Tests the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn test(&self, lane: usize) -> bool {\n+                self.0.test(lane)\n+            }\n \n-    define_opaque_mask! {\n-        /// Mask for 8 16-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask16x8([u16; 8]);\n-    }\n+            /// Sets the value of the specified lane.\n+            ///\n+            /// # Panics\n+            /// Panics if `lane` is greater than or equal to the number of lanes in the vector.\n+            #[inline]\n+            pub fn set(&mut self, lane: usize, value: bool) {\n+                self.0.set(lane, value);\n+            }\n+        }\n \n-    define_opaque_mask! {\n-        /// Mask for 16 16-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask16x16([u16; 16]);\n-    }\n+        impl<const $lanes: usize> Copy for $name<$lanes> {}\n \n-    define_opaque_mask! {\n-        /// Mask for 32 16-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask16x32([u16; 32]);\n-    }\n+        impl<const $lanes: usize> Clone for $name<$lanes> {\n+            #[inline]\n+            fn clone(&self) -> Self {\n+                *self\n+            }\n+        }\n \n-    define_opaque_mask! {\n-        /// Mask for 2 32-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask32x2([u32; 2]);\n-    }\n+        impl<const $lanes: usize> Default for $name<$lanes> {\n+            #[inline]\n+            fn default() -> Self {\n+                Self::splat(false)\n+            }\n+        }\n \n-    define_opaque_mask! {\n-        /// Mask for 4 32-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask32x4([u32; 4]);\n-    }\n+        impl<const $lanes: usize> PartialEq for $name<$lanes> {\n+            #[inline]\n+            fn eq(&self, other: &Self) -> bool {\n+                self.0 == other.0\n+            }\n+        }\n \n-    define_opaque_mask! {\n-        /// Mask for 8 32-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask32x8([u32; 8]);\n-    }\n+        impl<const $lanes: usize> PartialOrd for $name<$lanes> {\n+            #[inline]\n+            fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n+                self.0.partial_cmp(&other.0)\n+            }\n+        }\n \n-    define_opaque_mask! {\n-        /// Mask for 16 32-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask32x16([u32; 16]);\n-    }\n+        impl<const $lanes: usize> core::fmt::Debug for $name<$lanes> {\n+            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n+                core::fmt::Debug::fmt(&self.0, f)\n+            }\n+        }\n+    };\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 2 64-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask64x2([u64; 2]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 8-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask8<const LANES: usize>(full_masks::SimdI8Mask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 4 64-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask64x4([u64; 4]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 16-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask16<const LANES: usize>(full_masks::SimdI16Mask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 8 64-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask64x8([u64; 8]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 32-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask32<const LANES: usize>(full_masks::SimdI32Mask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 2 128-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask128x2([u128; 2]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 64-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask64<const LANES: usize>(full_masks::SimdI64Mask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 4 128-bit lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct mask128x4([u128; 4]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` 128-bit elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct Mask128<const LANES: usize>(full_masks::SimdI128Mask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 2 `isize`-wide lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct masksizex2([usize; 2]);\n-    }\n+define_opaque_mask! {\n+    /// Mask for vectors with `LANES` pointer-width elements.\n+    ///\n+    /// The layout of this type is unspecified.\n+    struct MaskSize<const LANES: usize>(full_masks::SimdIsizeMask<LANES>);\n+}\n \n-    define_opaque_mask! {\n-        /// Mask for 4 `isize`-wide lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct masksizex4([usize; 4]);\n-    }\n+/// Mask-related operations using a particular mask layout.\n+pub trait MaskExt<Mask> {\n+    /// Test if each lane is equal to the corresponding lane in `other`.\n+    fn lanes_eq(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is not equal to the corresponding lane in `other`.\n+    fn lanes_ne(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is less than the corresponding lane in `other`.\n+    fn lanes_lt(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is greater than the corresponding lane in `other`.\n+    fn lanes_gt(&self, other: &Self) -> Mask;\n \n-    define_opaque_mask! {\n-        /// Mask for 8 `isize`-wide lanes.\n-        ///\n-        /// The layout of this type is unspecified.\n-        struct masksizex8([usize; 8]);\n+    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+    fn lanes_le(&self, other: &Self) -> Mask;\n+\n+    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+    fn lanes_ge(&self, other: &Self) -> Mask;\n+}\n+\n+macro_rules! implement_mask_ops {\n+    { $($vector:ident => $mask:ident,)* } => {\n+        $(\n+            impl<const LANES: usize> crate::$vector<LANES> {\n+                /// Test if each lane is equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_eq(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_eq(self, other))\n+                }\n+\n+                /// Test if each lane is not equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ne(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_ne(self, other))\n+                }\n+\n+                /// Test if each lane is less than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_lt(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_lt(self, other))\n+                }\n+\n+                /// Test if each lane is greater than the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_gt(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_gt(self, other))\n+                }\n+\n+                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_le(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_le(self, other))\n+                }\n+\n+                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n+                #[inline]\n+                pub fn lanes_ge(&self, other: &Self) -> $mask<LANES> {\n+                    $mask(MaskExt::lanes_ge(self, other))\n+                }\n+            }\n+        )*\n     }\n }\n+\n+implement_mask_ops! {\n+    SimdI8 => Mask8,\n+    SimdI16 => Mask16,\n+    SimdI32 => Mask32,\n+    SimdI64 => Mask64,\n+    SimdI128 => Mask128,\n+    SimdIsize => MaskSize,\n+\n+    SimdU8 => Mask8,\n+    SimdU16 => Mask16,\n+    SimdU32 => Mask32,\n+    SimdU64 => Mask64,\n+    SimdU128 => Mask128,\n+    SimdUsize => MaskSize,\n+\n+    SimdF32 => Mask32,\n+    SimdF64 => Mask64,\n+}\n+\n+/// Vector of eight 8-bit masks\n+pub type mask8x8 = Mask8<8>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x16 = Mask8<16>;\n+\n+/// Vector of 32 8-bit masks\n+pub type mask8x32 = Mask8<32>;\n+\n+/// Vector of 16 8-bit masks\n+pub type mask8x64 = Mask8<64>;\n+\n+/// Vector of four 16-bit masks\n+pub type mask16x4 = Mask16<4>;\n+\n+/// Vector of eight 16-bit masks\n+pub type mask16x8 = Mask16<8>;\n+\n+/// Vector of 16 16-bit masks\n+pub type mask16x16 = Mask16<16>;\n+\n+/// Vector of 32 16-bit masks\n+pub type mask16x32 = Mask32<32>;\n+\n+/// Vector of two 32-bit masks\n+pub type mask32x2 = Mask32<2>;\n+\n+/// Vector of four 32-bit masks\n+pub type mask32x4 = Mask32<4>;\n+\n+/// Vector of eight 32-bit masks\n+pub type mask32x8 = Mask32<8>;\n+\n+/// Vector of 16 32-bit masks\n+pub type mask32x16 = Mask32<16>;\n+\n+/// Vector of two 64-bit masks\n+pub type mask64x2 = Mask64<2>;\n+\n+/// Vector of four 64-bit masks\n+pub type mask64x4 = Mask64<4>;\n+\n+/// Vector of eight 64-bit masks\n+pub type mask64x8 = Mask64<8>;\n+\n+/// Vector of two 128-bit masks\n+pub type mask128x2 = Mask128<2>;\n+\n+/// Vector of four 128-bit masks\n+pub type mask128x4 = Mask128<4>;\n+\n+/// Vector of two pointer-width masks\n+pub type masksizex2 = MaskSize<2>;\n+\n+/// Vector of four pointer-width masks\n+pub type masksizex4 = MaskSize<4>;\n+\n+/// Vector of eight pointer-width masks\n+pub type masksizex8 = MaskSize<8>;"}, {"sha": "85ce955459a2fd4a39c0059e75d432fe84700a61", "filename": "crates/core_simd/src/masks/ops.rs", "status": "removed", "additions": 0, "deletions": 208, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fops.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -1,208 +0,0 @@\n-/// Mask-related operations using a particular mask layout.\n-pub trait MaskExt<Mask> {\n-    /// Test if each lane is equal to the corresponding lane in `other`.\n-    fn lanes_eq(self, other: Self) -> Mask;\n-\n-    /// Test if each lane is not equal to the corresponding lane in `other`.\n-    fn lanes_ne(self, other: Self) -> Mask;\n-\n-    /// Test if each lane is less than the corresponding lane in `other`.\n-    fn lanes_lt(self, other: Self) -> Mask;\n-\n-    /// Test if each lane is greater than the corresponding lane in `other`.\n-    fn lanes_gt(self, other: Self) -> Mask;\n-\n-    /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-    fn lanes_le(self, other: Self) -> Mask;\n-\n-    /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-    fn lanes_ge(self, other: Self) -> Mask;\n-}\n-\n-macro_rules! implement_mask_ext {\n-    { $($vector:ty => $($mask:ty),*;)* } => {\n-        $( // vector\n-            $( // mask\n-                impl MaskExt<$mask> for $vector {\n-                    #[inline]\n-                    fn lanes_eq(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_eq(self, other) }\n-                    }\n-\n-                    #[inline]\n-                    fn lanes_ne(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_ne(self, other) }\n-                    }\n-\n-                    #[inline]\n-                    fn lanes_lt(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_lt(self, other) }\n-                    }\n-\n-                    #[inline]\n-                    fn lanes_gt(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_gt(self, other) }\n-                    }\n-\n-                    #[inline]\n-                    fn lanes_le(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_le(self, other) }\n-                    }\n-\n-                    #[inline]\n-                    fn lanes_ge(self, other: Self) -> $mask {\n-                        unsafe { crate::intrinsics::simd_ge(self, other) }\n-                    }\n-                }\n-            )*\n-        )*\n-    }\n-}\n-\n-implement_mask_ext! {\n-    crate::u8x8 => crate::masks::wide::m8x8;\n-    crate::u8x16 => crate::masks::wide::m8x16;\n-    crate::u8x32 => crate::masks::wide::m8x32;\n-    crate::u8x64 => crate::masks::wide::m8x64;\n-    crate::u16x4 => crate::masks::wide::m16x4;\n-    crate::u16x8 => crate::masks::wide::m16x8;\n-    crate::u16x16 => crate::masks::wide::m16x16;\n-    crate::u16x32 => crate::masks::wide::m16x32;\n-    crate::u32x2 => crate::masks::wide::m32x2;\n-    crate::u32x4 => crate::masks::wide::m32x4;\n-    crate::u32x8 => crate::masks::wide::m32x8;\n-    crate::u32x16 => crate::masks::wide::m32x16;\n-    crate::u64x2 => crate::masks::wide::m64x2;\n-    crate::u64x4 => crate::masks::wide::m64x4;\n-    crate::u64x8 => crate::masks::wide::m64x8;\n-    crate::u128x2 => crate::masks::wide::m128x2;\n-    crate::u128x4 => crate::masks::wide::m128x4;\n-    crate::usizex2 => crate::masks::wide::msizex2;\n-    crate::usizex4 => crate::masks::wide::msizex4;\n-    crate::usizex8 => crate::masks::wide::msizex8;\n-\n-    crate::i8x8 => crate::masks::wide::m8x8;\n-    crate::i8x16 => crate::masks::wide::m8x16;\n-    crate::i8x32 => crate::masks::wide::m8x32;\n-    crate::i8x64 => crate::masks::wide::m8x64;\n-    crate::i16x4 => crate::masks::wide::m16x4;\n-    crate::i16x8 => crate::masks::wide::m16x8;\n-    crate::i16x16 => crate::masks::wide::m16x16;\n-    crate::i16x32 => crate::masks::wide::m16x32;\n-    crate::i32x2 => crate::masks::wide::m32x2;\n-    crate::i32x4 => crate::masks::wide::m32x4;\n-    crate::i32x8 => crate::masks::wide::m32x8;\n-    crate::i32x16 => crate::masks::wide::m32x16;\n-    crate::i64x2 => crate::masks::wide::m64x2;\n-    crate::i64x4 => crate::masks::wide::m64x4;\n-    crate::i64x8 => crate::masks::wide::m64x8;\n-    crate::i128x2 => crate::masks::wide::m128x2;\n-    crate::i128x4 => crate::masks::wide::m128x4;\n-    crate::isizex2 => crate::masks::wide::msizex2;\n-    crate::isizex4 => crate::masks::wide::msizex4;\n-    crate::isizex8 => crate::masks::wide::msizex8;\n-\n-    crate::f32x2 => crate::masks::wide::m32x2;\n-    crate::f32x4 => crate::masks::wide::m32x4;\n-    crate::f32x8 => crate::masks::wide::m32x8;\n-    crate::f32x16 => crate::masks::wide::m32x16;\n-    crate::f64x2 => crate::masks::wide::m64x2;\n-    crate::f64x4 => crate::masks::wide::m64x4;\n-    crate::f64x8 => crate::masks::wide::m64x8;\n-}\n-\n-macro_rules! implement_mask_ops {\n-    { $($vector:ty => $mask:ty,)* } => {\n-        $( // vector\n-            impl $vector {\n-                /// Test if each lane is equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_eq(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_eq(self, other))\n-                }\n-\n-                /// Test if each lane is not equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ne(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_ne(self, other))\n-                }\n-\n-                /// Test if each lane is less than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_lt(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_lt(self, other))\n-                }\n-\n-                /// Test if each lane is greater than the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_gt(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_gt(self, other))\n-                }\n-\n-                /// Test if each lane is less than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_le(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_le(self, other))\n-                }\n-\n-                /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n-                #[inline]\n-                pub fn lanes_ge(self, other: Self) -> $mask {\n-                    <$mask>::new_from_inner(MaskExt::lanes_ge(self, other))\n-                }\n-            }\n-        )*\n-    }\n-}\n-\n-implement_mask_ops! {\n-    crate::u8x8 => crate::mask8x8,\n-    crate::u8x16 => crate::mask8x16,\n-    crate::u8x32 => crate::mask8x32,\n-    crate::u8x64 => crate::mask8x64,\n-    crate::u16x4 => crate::mask16x4,\n-    crate::u16x8 => crate::mask16x8,\n-    crate::u16x16 => crate::mask16x16,\n-    crate::u16x32 => crate::mask16x32,\n-    crate::u32x2 => crate::mask32x2,\n-    crate::u32x4 => crate::mask32x4,\n-    crate::u32x8 => crate::mask32x8,\n-    crate::u32x16 => crate::mask32x16,\n-    crate::u64x2 => crate::mask64x2,\n-    crate::u64x4 => crate::mask64x4,\n-    crate::u64x8 => crate::mask64x8,\n-    crate::u128x2 => crate::mask128x2,\n-    crate::u128x4 => crate::mask128x4,\n-    crate::usizex2 => crate::masksizex2,\n-    crate::usizex4 => crate::masksizex4,\n-    crate::usizex8 => crate::masksizex8,\n-\n-    crate::i8x8 => crate::mask8x8,\n-    crate::i8x16 => crate::mask8x16,\n-    crate::i8x32 => crate::mask8x32,\n-    crate::i8x64 => crate::mask8x64,\n-    crate::i16x4 => crate::mask16x4,\n-    crate::i16x8 => crate::mask16x8,\n-    crate::i16x16 => crate::mask16x16,\n-    crate::i16x32 => crate::mask16x32,\n-    crate::i32x2 => crate::mask32x2,\n-    crate::i32x4 => crate::mask32x4,\n-    crate::i32x8 => crate::mask32x8,\n-    crate::i32x16 => crate::mask32x16,\n-    crate::i64x2 => crate::mask64x2,\n-    crate::i64x4 => crate::mask64x4,\n-    crate::i64x8 => crate::mask64x8,\n-    crate::i128x2 => crate::mask128x2,\n-    crate::i128x4 => crate::mask128x4,\n-    crate::isizex2 => crate::masksizex2,\n-    crate::isizex4 => crate::masksizex4,\n-    crate::isizex8 => crate::masksizex8,\n-\n-    crate::f32x2 => crate::mask32x2,\n-    crate::f32x4 => crate::mask32x4,\n-    crate::f32x8 => crate::mask32x8,\n-    crate::f32x16 => crate::mask32x16,\n-    crate::f64x2 => crate::mask64x2,\n-    crate::f64x4 => crate::mask64x4,\n-    crate::f64x8 => crate::mask64x8,\n-}"}, {"sha": "7df8ca7e53d5a88842e77cc060519e1c056c6aae", "filename": "crates/core_simd/src/masks/wide/mod.rs", "status": "removed", "additions": 0, "deletions": 139, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fwide%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25c7640fb331112d5bf445c0893af89ee3e9ea9d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fwide%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fwide%2Fmod.rs?ref=25c7640fb331112d5bf445c0893af89ee3e9ea9d", "patch": "@@ -1,139 +0,0 @@\n-//! Masks that take up full vector registers.\n-\n-mod vectors_m8;\n-pub use vectors_m8::*;\n-mod vectors_m16;\n-pub use vectors_m16::*;\n-mod vectors_m32;\n-pub use vectors_m32::*;\n-mod vectors_m64;\n-pub use vectors_m64::*;\n-mod vectors_m128;\n-pub use vectors_m128::*;\n-mod vectors_msize;\n-pub use vectors_msize::*;\n-\n-/// The error type returned when converting an integer to a mask fails.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n-pub struct TryFromMaskError(());\n-\n-impl core::fmt::Display for TryFromMaskError {\n-    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-        write!(f, \"mask must have all bits set or unset\")\n-    }\n-}\n-\n-macro_rules! define_mask {\n-    { $(#[$attr:meta])* struct $name:ident($type:ty); } => {\n-        $(#[$attr])*\n-        #[allow(non_camel_case_types)]\n-        #[derive(Copy, Clone, Default, PartialEq, PartialOrd, Eq, Ord, Hash)]\n-        #[repr(transparent)]\n-        pub struct $name(pub(crate) $type);\n-\n-        impl $name {\n-            /// Construct a mask from the given value.\n-            pub const fn new(value: bool) -> Self {\n-                if value {\n-                    Self(!0)\n-                } else {\n-                    Self(0)\n-                }\n-            }\n-\n-            /// Test if the mask is set.\n-            pub const fn test(&self) -> bool {\n-                self.0 != 0\n-            }\n-        }\n-\n-        impl core::convert::From<bool> for $name {\n-            fn from(value: bool) -> Self {\n-                Self::new(value)\n-            }\n-        }\n-\n-        impl core::convert::From<$name> for bool {\n-            fn from(mask: $name) -> Self {\n-                mask.test()\n-            }\n-        }\n-\n-        impl core::convert::TryFrom<$type> for $name {\n-            type Error = TryFromMaskError;\n-            fn try_from(value: $type) -> Result<Self, Self::Error> {\n-                if value == 0 || !value == 0 {\n-                    Ok(Self(value))\n-                } else {\n-                    Err(TryFromMaskError(()))\n-                }\n-            }\n-        }\n-\n-        impl core::convert::From<$name> for $type {\n-            fn from(value: $name) -> Self {\n-                value.0\n-            }\n-        }\n-\n-        impl core::fmt::Debug for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                self.test().fmt(f)\n-            }\n-        }\n-\n-        impl core::fmt::Binary for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Binary::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::Octal for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::Octal::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::LowerHex for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::LowerHex::fmt(&self.0, f)\n-            }\n-        }\n-\n-        impl core::fmt::UpperHex for $name {\n-            fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n-                core::fmt::UpperHex::fmt(&self.0, f)\n-            }\n-        }\n-    }\n-}\n-\n-define_mask! {\n-    /// 8-bit mask\n-    struct m8(i8);\n-}\n-\n-define_mask! {\n-    /// 16-bit mask\n-    struct m16(i16);\n-}\n-\n-define_mask! {\n-    /// 32-bit mask\n-    struct m32(i32);\n-}\n-\n-define_mask! {\n-    /// 64-bit mask\n-    struct m64(i64);\n-}\n-\n-define_mask! {\n-    /// 128-bit mask\n-    struct m128(i128);\n-}\n-\n-define_mask! {\n-    /// `isize`-wide mask\n-    struct msize(isize);\n-}"}, {"sha": "0b5d8c6ec49b40eb2f46542c9cc88177a63e4340", "filename": "crates/core_simd/src/vectors_f32.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f32.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `f32`.\n+/// A SIMD vector of containing `LANES` `f32` values.\n #[repr(simd)]\n pub struct SimdF32<const LANES: usize>([f32; LANES]);\n \n impl_float_vector! { SimdF32, f32, SimdU32 }\n \n+/// Vector of two `f32` values\n pub type f32x2 = SimdF32<2>;\n+\n+/// Vector of four `f32` values\n pub type f32x4 = SimdF32<4>;\n+\n+/// Vector of eight `f32` values\n pub type f32x8 = SimdF32<8>;\n+\n+/// Vector of 16 `f32` values\n pub type f32x16 = SimdF32<16>;\n \n from_transmute_x86! { unsafe f32x4 => __m128 }"}, {"sha": "307f8a4acacd760c88480df8aafc885d6bb940bb", "filename": "crates/core_simd/src/vectors_f64.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_f64.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,13 +1,18 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `f64`.\n+/// A SIMD vector of containing `LANES` `f64` values.\n #[repr(simd)]\n pub struct SimdF64<const LANES: usize>([f64; LANES]);\n \n impl_float_vector! { SimdF64, f64, SimdU64 }\n \n+/// Vector of two `f64` values\n pub type f64x2 = SimdF64<2>;\n+\n+/// Vector of four `f64` values\n pub type f64x4 = SimdF64<4>;\n+\n+/// Vector of eight `f64` values\n pub type f64x8 = SimdF64<8>;\n \n from_transmute_x86! { unsafe f64x2 => __m128d }"}, {"sha": "16e6162be5523e07afe81ce92d29298da768b5ed", "filename": "crates/core_simd/src/vectors_i128.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i128.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,12 +1,15 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `i128`.\n+/// A SIMD vector of containing `LANES` `i128` values.\n #[repr(simd)]\n pub struct SimdI128<const LANES: usize>([i128; LANES]);\n \n impl_integer_vector! { SimdI128, i128 }\n \n+/// Vector of two `i128` values\n pub type i128x2 = SimdI128<2>;\n+\n+/// Vector of four `i128` values\n pub type i128x4 = SimdI128<4>;\n \n from_transmute_x86! { unsafe i128x2 => __m256i }"}, {"sha": "08cc4af2a5ea419ab2f7f0b9fb706a864aea3796", "filename": "crates/core_simd/src/vectors_i16.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i16.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `i16`.\n+/// A SIMD vector of containing `LANES` `i16` values.\n #[repr(simd)]\n pub struct SimdI16<const LANES: usize>([i16; LANES]);\n \n impl_integer_vector! { SimdI16, i16 }\n \n+/// Vector of four `i16` values\n pub type i16x4 = SimdI16<4>;\n+\n+/// Vector of eight `i16` values\n pub type i16x8 = SimdI16<8>;\n+\n+/// Vector of 16 `i16` values\n pub type i16x16 = SimdI16<16>;\n+\n+/// Vector of 32 `i16` values\n pub type i16x32 = SimdI16<32>;\n \n from_transmute_x86! { unsafe i16x8 => __m128i }"}, {"sha": "116f2abaeeedb7d234937952269279955a236a2c", "filename": "crates/core_simd/src/vectors_i32.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i32.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `i32`.\n+/// A SIMD vector of containing `LANES` `i32` values.\n #[repr(simd)]\n pub struct SimdI32<const LANES: usize>([i32; LANES]);\n \n impl_integer_vector! { SimdI32, i32 }\n \n+/// Vector of two `i32` values\n pub type i32x2 = SimdI32<2>;\n+\n+/// Vector of four `i32` values\n pub type i32x4 = SimdI32<4>;\n+\n+/// Vector of eight `i32` values\n pub type i32x8 = SimdI32<8>;\n+\n+/// Vector of 16 `i32` values\n pub type i32x16 = SimdI32<16>;\n \n from_transmute_x86! { unsafe i32x4 => __m128i }"}, {"sha": "6a1e2094179bd8d948f3bf6f5b5b586a60696a9c", "filename": "crates/core_simd/src/vectors_i64.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i64.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,13 +1,18 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `i64`.\n+/// A SIMD vector of containing `LANES` `i64` values.\n #[repr(simd)]\n pub struct SimdI64<const LANES: usize>([i64; LANES]);\n \n impl_integer_vector! { SimdI64, i64 }\n \n+/// Vector of two `i64` values\n pub type i64x2 = SimdI64<2>;\n+\n+/// Vector of four `i64` values\n pub type i64x4 = SimdI64<4>;\n+\n+/// Vector of eight `i64` values\n pub type i64x8 = SimdI64<8>;\n \n from_transmute_x86! { unsafe i64x2 => __m128i }"}, {"sha": "0ac5ba9efee56a7d14961f73bad636e091e521e5", "filename": "crates/core_simd/src/vectors_i8.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_i8.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `i8`.\n+/// A SIMD vector of containing `LANES` `i8` values.\n #[repr(simd)]\n pub struct SimdI8<const LANES: usize>([i8; LANES]);\n \n impl_integer_vector! { SimdI8, i8 }\n \n+/// Vector of eight `i8` values\n pub type i8x8 = SimdI8<8>;\n+\n+/// Vector of 16 `i8` values\n pub type i8x16 = SimdI8<16>;\n+\n+/// Vector of 32 `i8` values\n pub type i8x32 = SimdI8<32>;\n+\n+/// Vector of 64 `i8` values\n pub type i8x64 = SimdI8<64>;\n \n from_transmute_x86! { unsafe i8x16 => __m128i }"}, {"sha": "6856f305092d3e97061109cb8d33c00c8b9aa1ab", "filename": "crates/core_simd/src/vectors_isize.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_isize.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,13 +1,18 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `isize`.\n+/// A SIMD vector of containing `LANES` `isize` values.\n #[repr(simd)]\n pub struct SimdIsize<const LANES: usize>([isize; LANES]);\n \n impl_integer_vector! { SimdIsize, isize }\n \n+/// Vector of two `isize` values\n pub type isizex2 = SimdIsize<2>;\n+\n+/// Vector of four `isize` values\n pub type isizex4 = SimdIsize<4>;\n+\n+/// Vector of eight `isize` values\n pub type isizex8 = SimdIsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "522404f133e564d644294fa2d302f844c6d9d8b5", "filename": "crates/core_simd/src/vectors_u128.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u128.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,12 +1,15 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `u128`.\n+/// A SIMD vector of containing `LANES` `u128` values.\n #[repr(simd)]\n pub struct SimdU128<const LANES: usize>([u128; LANES]);\n \n impl_integer_vector! { SimdU128, u128 }\n \n+/// Vector of two `u128` values\n pub type u128x2 = SimdU128<2>;\n+\n+/// Vector of four `u128` values\n pub type u128x4 = SimdU128<4>;\n \n from_transmute_x86! { unsafe u128x2 => __m256i }"}, {"sha": "efe7dea58dc48c26adbc3aff1563b80f6ecde5da", "filename": "crates/core_simd/src/vectors_u16.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u16.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `u16`.\n+/// A SIMD vector of containing `LANES` `u16` values.\n #[repr(simd)]\n pub struct SimdU16<const LANES: usize>([u16; LANES]);\n \n impl_integer_vector! { SimdU16, u16 }\n \n+/// Vector of four `u16` values\n pub type u16x4 = SimdU16<4>;\n+\n+/// Vector of eight `u16` values\n pub type u16x8 = SimdU16<8>;\n+\n+/// Vector of 16 `u16` values\n pub type u16x16 = SimdU16<16>;\n+\n+/// Vector of 32 `u16` values\n pub type u16x32 = SimdU16<32>;\n \n from_transmute_x86! { unsafe u16x8 => __m128i }"}, {"sha": "a6cef5baeb73f63f974ca533612decb1c0a66d79", "filename": "crates/core_simd/src/vectors_u32.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u32.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `u32`.\n+/// A SIMD vector of containing `LANES` `u32` values.\n #[repr(simd)]\n pub struct SimdU32<const LANES: usize>([u32; LANES]);\n \n impl_integer_vector! { SimdU32, u32 }\n \n+/// Vector of two `u32` values\n pub type u32x2 = SimdU32<2>;\n+\n+/// Vector of four `u32` values\n pub type u32x4 = SimdU32<4>;\n+\n+/// Vector of eight `u32` values\n pub type u32x8 = SimdU32<8>;\n+\n+/// Vector of 16 `u32` values\n pub type u32x16 = SimdU32<16>;\n \n from_transmute_x86! { unsafe u32x4 => __m128i }"}, {"sha": "3982e30f57055bf1121cf0f10000fc4a3897705a", "filename": "crates/core_simd/src/vectors_u64.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u64.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,13 +1,18 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `u64`.\n+/// A SIMD vector of containing `LANES` `u64` values.\n #[repr(simd)]\n pub struct SimdU64<const LANES: usize>([u64; LANES]);\n \n impl_integer_vector! { SimdU64, u64 }\n \n+/// Vector of two `u64` values\n pub type u64x2 = SimdU64<2>;\n+\n+/// Vector of four `u64` values\n pub type u64x4 = SimdU64<4>;\n+\n+/// Vector of eight `u64` values\n pub type u64x8 = SimdU64<8>;\n \n from_transmute_x86! { unsafe u64x2 => __m128i }"}, {"sha": "9cc4eaca47ad454a83cd7a581af1523cd70cfa49", "filename": "crates/core_simd/src/vectors_u8.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_u8.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,14 +1,21 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `u8`.\n+/// A SIMD vector of containing `LANES` `u8` values.\n #[repr(simd)]\n pub struct SimdU8<const LANES: usize>([u8; LANES]);\n \n impl_integer_vector! { SimdU8, u8 }\n \n+/// Vector of eight `u8` values\n pub type u8x8 = SimdU8<8>;\n+\n+/// Vector of 16 `u8` values\n pub type u8x16 = SimdU8<16>;\n+\n+/// Vector of 32 `u8` values\n pub type u8x32 = SimdU8<32>;\n+\n+/// Vector of 64 `u8` values\n pub type u8x64 = SimdU8<64>;\n \n from_transmute_x86! { unsafe u8x16 => __m128i }"}, {"sha": "c882898f9fbea8d65d208fbf431e21ca672345b6", "filename": "crates/core_simd/src/vectors_usize.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvectors_usize.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,13 +1,18 @@\n #![allow(non_camel_case_types)]\n \n-/// A SIMD vector of containing `LANES` lanes of `usize`.\n+/// A SIMD vector of containing `LANES` `usize` values.\n #[repr(simd)]\n pub struct SimdUsize<const LANES: usize>([usize; LANES]);\n \n impl_integer_vector! { SimdUsize, usize }\n \n+/// Vector of two `usize` values\n pub type usizex2 = SimdUsize<2>;\n+\n+/// Vector of four `usize` values\n pub type usizex4 = SimdUsize<4>;\n+\n+/// Vector of eight `usize` values\n pub type usizex8 = SimdUsize<8>;\n \n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "795f9e27c4458fa1dcefeb5e23ece1f66d4d859e", "filename": "crates/core_simd/tests/ops_impl/mask_macros.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9cc3deaa9256060868bb952ea5f850a910633f19/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Ftests%2Fops_impl%2Fmask_macros.rs?ref=9cc3deaa9256060868bb952ea5f850a910633f19", "patch": "@@ -1,6 +1,5 @@\n macro_rules! mask_tests {\n     { $vector:ident, $lanes:literal } => {\n-        /*\n         #[cfg(test)]\n         mod $vector {\n             use core_simd::$vector as Vector;\n@@ -222,6 +221,5 @@ macro_rules! mask_tests {\n                 assert_eq!(!v, expected);\n             }\n         }\n-        */\n     }\n }"}]}