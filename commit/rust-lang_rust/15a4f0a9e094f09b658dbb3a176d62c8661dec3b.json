{"sha": "15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "node_id": "C_kwDOAAsO6NoAKDE1YTRmMGE5ZTA5NGYwOWI2NThkYmIzYTE3NmQ2MmM4NjYxZGVjM2I", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-08-17T00:32:58Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2022-08-18T20:36:53Z"}, "message": "some CurrentSpan cleanup", "tree": {"sha": "717ed640a3dc71c380a23cb1bda1dd95815465c8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/717ed640a3dc71c380a23cb1bda1dd95815465c8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "html_url": "https://github.com/rust-lang/rust/commit/15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8", "html_url": "https://github.com/rust-lang/rust/commit/17fc52a06d07828fb7d2ef6f5202a9ae41b532c8"}], "stats": {"total": 134, "additions": 76, "deletions": 58}, "files": [{"sha": "f634c8d0c9ac45ece51e48a2af94c2ac9e9059e3", "filename": "src/helpers.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "patch": "@@ -877,7 +877,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     pub fn current_span(&self, tcx: TyCtxt<'tcx>) -> CurrentSpan<'_, 'mir, 'tcx> {\n-        CurrentSpan { span: None, machine: self, tcx }\n+        CurrentSpan { current_frame_idx: None, machine: self, tcx }\n     }\n }\n \n@@ -887,7 +887,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n /// The result of that search is cached so that later calls are approximately free.\n #[derive(Clone)]\n pub struct CurrentSpan<'a, 'mir, 'tcx> {\n-    span: Option<Span>,\n+    current_frame_idx: Option<usize>,\n     tcx: TyCtxt<'tcx>,\n     machine: &'a Evaluator<'mir, 'tcx>,\n }\n@@ -896,25 +896,19 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n     /// Get the current span, skipping non-local frames.\n     /// This function is backed by a cache, and can be assumed to be very fast.\n     pub fn get(&mut self) -> Span {\n-        *self.span.get_or_insert_with(|| Self::current_span(self.tcx, self.machine))\n+        let idx = self.current_frame_idx();\n+        Self::frame_span(self.machine, idx)\n     }\n \n     /// Similar to `CurrentSpan::get`, but retrieves the parent frame of the first non-local frame.\n     /// This is useful when we are processing something which occurs on function-entry and we want\n     /// to point at the call to the function, not the function definition generally.\n-    #[inline(never)]\n     pub fn get_parent(&mut self) -> Span {\n-        let idx = Self::current_span_index(self.tcx, self.machine);\n-        Self::nth_span(self.machine, idx.wrapping_sub(1))\n-    }\n-\n-    #[inline(never)]\n-    fn current_span(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> Span {\n-        let idx = Self::current_span_index(tcx, machine);\n-        Self::nth_span(machine, idx)\n+        let idx = self.current_frame_idx();\n+        Self::frame_span(self.machine, idx.wrapping_sub(1))\n     }\n \n-    fn nth_span(machine: &Evaluator<'_, '_>, idx: usize) -> Span {\n+    fn frame_span(machine: &Evaluator<'_, '_>, idx: usize) -> Span {\n         machine\n             .threads\n             .active_thread_stack()\n@@ -923,9 +917,16 @@ impl<'a, 'mir: 'a, 'tcx: 'a + 'mir> CurrentSpan<'a, 'mir, 'tcx> {\n             .unwrap_or(rustc_span::DUMMY_SP)\n     }\n \n+    fn current_frame_idx(&mut self) -> usize {\n+        *self\n+            .current_frame_idx\n+            .get_or_insert_with(|| Self::compute_current_frame_index(self.tcx, self.machine))\n+    }\n+\n     // Find the position of the inner-most frame which is part of the crate being\n     // compiled/executed, part of the Cargo workspace, and is also not #[track_caller].\n-    fn current_span_index(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> usize {\n+    #[inline(never)]\n+    fn compute_current_frame_index(tcx: TyCtxt<'_>, machine: &Evaluator<'_, '_>) -> usize {\n         machine\n             .threads\n             .active_thread_stack()"}, {"sha": "741a3d363dd35facc6c2a570d172c572f7b79103", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "patch": "@@ -103,26 +103,30 @@ pub struct TagHistory {\n     pub protected: Option<([(String, SpanData); 2])>,\n }\n \n-pub struct DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+pub struct DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+    // 'span cannot be merged with any other lifetime since they appear invariantly, under the\n+    // mutable ref.\n+    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n     threads: &'ecx ThreadManager<'mir, 'tcx>,\n }\n \n-pub struct DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+pub struct DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n     operation: Operation,\n-    current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+    // 'span and 'history cannot be merged, since when we call `unbuild` we need\n+    // to return the exact 'span that was used when calling `build`.\n+    current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n     threads: &'ecx ThreadManager<'mir, 'tcx>,\n     history: &'history mut AllocHistory,\n     offset: Size,\n }\n \n-impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n-    pub fn build(\n+impl<'span, 'ecx, 'mir, 'tcx> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n+    pub fn build<'history>(\n         self,\n         history: &'history mut AllocHistory,\n         offset: Size,\n-    ) -> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+    ) -> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n         DiagnosticCx {\n             operation: self.operation,\n             current_span: self.current_span,\n@@ -133,7 +137,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     }\n \n     pub fn retag(\n-        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n         threads: &'ecx ThreadManager<'mir, 'tcx>,\n         cause: RetagCause,\n         new_tag: SbTag,\n@@ -147,7 +151,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     }\n \n     pub fn read(\n-        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n         threads: &'ecx ThreadManager<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n@@ -157,7 +161,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     }\n \n     pub fn write(\n-        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n         threads: &'ecx ThreadManager<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n@@ -167,7 +171,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     }\n \n     pub fn dealloc(\n-        current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        current_span: &'span mut CurrentSpan<'ecx, 'mir, 'tcx>,\n         threads: &'ecx ThreadManager<'mir, 'tcx>,\n         tag: ProvenanceExtra,\n     ) -> Self {\n@@ -176,8 +180,8 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n     }\n }\n \n-impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n-    pub fn unbuild(self) -> DiagnosticCxBuilder<'ecx, 'mir, 'tcx> {\n+impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n+    pub fn unbuild(self) -> DiagnosticCxBuilder<'span, 'ecx, 'mir, 'tcx> {\n         DiagnosticCxBuilder {\n             operation: self.operation,\n             current_span: self.current_span,\n@@ -233,7 +237,7 @@ impl AllocHistory {\n     }\n }\n \n-impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n+impl<'span, 'history, 'ecx, 'mir, 'tcx> DiagnosticCx<'span, 'history, 'ecx, 'mir, 'tcx> {\n     pub fn start_grant(&mut self, perm: Permission) {\n         let Operation::Retag(op) = &mut self.operation else {\n             unreachable!(\"start_grant must only be called during a retag, this is: {:?}\", self.operation)\n@@ -247,6 +251,7 @@ impl<'ecx, 'mir, 'tcx, 'history> DiagnosticCx<'ecx, 'mir, 'tcx, 'history> {\n             }\n             Some(previous) =>\n                 if previous != perm {\n+                    // 'Split up' the creation event.\n                     let previous_range = last_creation.retag.range;\n                     last_creation.retag.range = alloc_range(previous_range.start, self.offset);\n                     let mut new_event = last_creation.clone();"}, {"sha": "66fdd685def5bc9a324dfccd55446a6f427a0871", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15a4f0a9e094f09b658dbb3a176d62c8661dec3b/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=15a4f0a9e094f09b658dbb3a176d62c8661dec3b", "patch": "@@ -286,7 +286,7 @@ impl<'tcx> Stack {\n     fn item_popped(\n         item: &Item,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         if !global.tracked_pointer_tags.is_empty() {\n             dcx.check_tracked_tag_popped(item, global);\n@@ -324,7 +324,7 @@ impl<'tcx> Stack {\n         access: AccessKind,\n         tag: ProvenanceExtra,\n         global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Two main steps: Find granting item, remove incompatible items above.\n@@ -410,7 +410,7 @@ impl<'tcx> Stack {\n         &mut self,\n         tag: ProvenanceExtra,\n         global: &GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         // Step 1: Make sure there is a granting item.\n@@ -436,7 +436,7 @@ impl<'tcx> Stack {\n         derived_from: ProvenanceExtra,\n         new: Item,\n         global: &mut GlobalStateInner,\n-        dcx: &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n+        dcx: &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> InterpResult<'tcx> {\n         dcx.start_grant(new.perm());\n@@ -515,10 +515,10 @@ impl<'tcx> Stacks {\n     fn for_each(\n         &mut self,\n         range: AllocRange,\n-        mut dcx_builder: DiagnosticCxBuilder<'_, '_, 'tcx>,\n+        mut dcx_builder: DiagnosticCxBuilder<'_, '_, '_, 'tcx>,\n         mut f: impl FnMut(\n             &mut Stack,\n-            &mut DiagnosticCx<'_, '_, 'tcx, '_>,\n+            &mut DiagnosticCx<'_, '_, '_, '_, 'tcx>,\n             &mut FxHashSet<SbTag>,\n         ) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -554,63 +554,66 @@ impl Stacks {\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_read<'tcx, 'mir>(\n+    pub fn before_memory_read<'tcx, 'mir, 'ecx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n-        threads: &ThreadManager<'mir, 'tcx>,\n-    ) -> InterpResult<'tcx> {\n+        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n+    ) -> InterpResult<'tcx>\n+    where\n+        'tcx: 'ecx,\n+    {\n         trace!(\n             \"read access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::read(current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::read(&mut current_span, threads, tag, range);\n         let mut state = state.borrow_mut();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Read, tag, &mut state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_write<'tcx, 'mir>(\n+    pub fn before_memory_write<'tcx, 'mir, 'ecx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n-        threads: &ThreadManager<'mir, 'tcx>,\n+        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\n             \"write access with tag {:?}: {:?}, size {}\",\n             tag,\n             Pointer::new(alloc_id, range.start),\n             range.size.bytes()\n         );\n-        let dcx = DiagnosticCxBuilder::write(current_span, threads, tag, range);\n+        let dcx = DiagnosticCxBuilder::write(&mut current_span, threads, tag, range);\n         let mut state = state.borrow_mut();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.access(AccessKind::Write, tag, &mut state, dcx, exposed_tags)\n         })\n     }\n \n     #[inline(always)]\n-    pub fn before_memory_deallocation<'tcx, 'mir>(\n+    pub fn before_memory_deallocation<'tcx, 'mir, 'ecx>(\n         &mut self,\n         alloc_id: AllocId,\n         tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n-        current_span: CurrentSpan<'_, 'mir, 'tcx>,\n-        threads: &ThreadManager<'mir, 'tcx>,\n+        mut current_span: CurrentSpan<'ecx, 'mir, 'tcx>,\n+        threads: &'ecx ThreadManager<'mir, 'tcx>,\n     ) -> InterpResult<'tcx> {\n         trace!(\"deallocation with tag {:?}: {:?}, size {}\", tag, alloc_id, range.size.bytes());\n-        let dcx = DiagnosticCxBuilder::dealloc(current_span, threads, tag);\n+        let dcx = DiagnosticCxBuilder::dealloc(&mut current_span, threads, tag);\n         let state = state.borrow();\n         self.for_each(range, dcx, |stack, dcx, exposed_tags| {\n             stack.dealloc(tag, &state, dcx, exposed_tags)\n@@ -621,8 +624,11 @@ impl Stacks {\n \n /// Retagging/reborrowing.  There is some policy in here, such as which permissions\n /// to grant for which references, and when to add protectors.\n-impl<'mir, 'tcx: 'mir> EvalContextPrivExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n-trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n+    for crate::MiriEvalContext<'mir, 'tcx>\n+{\n+}\n+trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     /// Returns the `AllocId` the reborrow was done in, if some actual borrow stack manipulation\n     /// happened.\n     fn reborrow(\n@@ -635,11 +641,9 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         protect: bool,\n     ) -> InterpResult<'tcx, Option<AllocId>> {\n         let this = self.eval_context_mut();\n-        let current_span = this.machine.current_span(*this.tcx);\n \n         // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n         let log_creation = |this: &MiriEvalContext<'mir, 'tcx>,\n-                            current_span: CurrentSpan<'_, 'mir, 'tcx>,\n                             loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n             let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n@@ -658,6 +662,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             let (_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n             match alloc_kind {\n                 AllocKind::LiveData => {\n+                    let current_span = &mut this.machine.current_span(*this.tcx);\n                     // This should have alloc_extra data, but `get_alloc_extra` can still fail\n                     // if converting this alloc_id from a global to a local one\n                     // uncovers a non-supported `extern static`.\n@@ -667,9 +672,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                         .as_ref()\n                         .expect(\"we should have Stacked Borrows data\")\n                         .borrow_mut();\n-                    let  dcx = DiagnosticCxBuilder::retag(\n+                    let threads = &this.machine.threads;\n+                    // Note that we create a *second* `DiagnosticCxBuilder` below for the actual retag.\n+                    // FIXME: can this be done cleaner?\n+                    let dcx = DiagnosticCxBuilder::retag(\n                         current_span,\n-                        &this.machine.threads,\n+                        threads,\n                         retag_cause,\n                         new_tag,\n                         orig_tag,\n@@ -704,16 +712,16 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Dangling slices are a common case here; it's valid to get their length but with raw\n             // pointer tagging for example all calls to get_unchecked on them are invalid.\n             if let Ok((alloc_id, base_offset, orig_tag)) = this.ptr_try_get_alloc_id(place.ptr) {\n-                log_creation(this, current_span, Some((alloc_id, base_offset, orig_tag)))?;\n+                log_creation(this, Some((alloc_id, base_offset, orig_tag)))?;\n                 return Ok(Some(alloc_id));\n             }\n             // This pointer doesn't come with an AllocId. :shrug:\n-            log_creation(this, current_span, None)?;\n+            log_creation(this, None)?;\n             return Ok(None);\n         }\n \n         let (alloc_id, base_offset, orig_tag) = this.ptr_get_alloc_id(place.ptr)?;\n-        log_creation(this, current_span, Some((alloc_id, base_offset, orig_tag)))?;\n+        log_creation(this, Some((alloc_id, base_offset, orig_tag)))?;\n \n         // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n         let (alloc_size, _) = this.get_live_alloc_size_and_align(alloc_id)?;\n@@ -770,6 +778,8 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     .as_ref()\n                     .expect(\"we should have Stacked Borrows data\")\n                     .borrow_mut();\n+                // FIXME: can't share this with the current_span inside log_creation\n+                let mut current_span = this.machine.current_span(*this.tcx);\n                 this.visit_freeze_sensitive(place, size, |mut range, frozen| {\n                     // Adjust range.\n                     range.start += base_offset;\n@@ -789,7 +799,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     let item = Item::new(new_tag, perm, protected);\n                     let mut global = this.machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n                     let dcx = DiagnosticCxBuilder::retag(\n-                        this.machine.current_span(*this.tcx),\n+                        &mut current_span, // FIXME avoid this `clone`\n                         &this.machine.threads,\n                         retag_cause,\n                         new_tag,\n@@ -817,8 +827,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let item = Item::new(new_tag, perm, protect);\n         let range = alloc_range(base_offset, size);\n         let mut global = machine.stacked_borrows.as_ref().unwrap().borrow_mut();\n+        // FIXME: can't share this with the current_span inside log_creation\n+        let current_span = &mut machine.current_span(tcx);\n         let dcx = DiagnosticCxBuilder::retag(\n-            machine.current_span(tcx), // `get_alloc_extra_mut` invalidated our old `current_span`\n+            current_span,\n             &machine.threads,\n             retag_cause,\n             new_tag,"}]}