{"sha": "5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViNjhmOWM0NmE1NTBkZWM5ZjhlZjhiYWZiOWE4MTVjZjU2NGFmMWQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-03-27T21:39:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-03-27T21:39:41Z"}, "message": "Rollup merge of #70478 - lcnr:refactor-type_of, r=varkor\n\nRefactor type_of for constants\n\nIf I have to look at this function for a few hours I want it to at least look good.\n\nr? @varkor", "tree": {"sha": "f2051f8bf8e2a69a81052efbf168cf21ed2052d5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2051f8bf8e2a69a81052efbf168cf21ed2052d5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJefnKdCRBK7hj4Ov3rIwAAdHIIAFGd+pCUsEqokuU1kECqFOAP\ni7Hj7LKhVQZPOjtkJyNygp1/8MQnXBXoLUhozhtAQD6QDTzUMXJFTr6bl3G3Rvvj\nrA/5xqpKy8Wacd09QfM8TXVL4hjlEMM6rddS/cMFhw6khGG4DM5Lg/eQZ9Th5TIQ\nOeI3ZEOBnjNqVOKtYg0f4DHr34aGUsLhxU74KkpDzWkEzBcc+0iSuiQ+2E4bQwqd\n+Wxl66y8/buCQETznf95WzjeIKfhFGtyBVn+JItud4y6GC/J8dILoVXN1UFHWKyE\n3yZGuknZe8SE4LARpodRYHkGIDSU5RL/sVTVKBDzv8yfhu52zl1sibMmi/jBpTs=\n=RQlk\n-----END PGP SIGNATURE-----\n", "payload": "tree f2051f8bf8e2a69a81052efbf168cf21ed2052d5\nparent 23d3fa266cc107ffceced3c5580eb6327662c605\nparent c339b2eb4aaa69499dc79b17575c671d3605723c\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1585345181 +0100\ncommitter GitHub <noreply@github.com> 1585345181 +0100\n\nRollup merge of #70478 - lcnr:refactor-type_of, r=varkor\n\nRefactor type_of for constants\n\nIf I have to look at this function for a few hours I want it to at least look good.\n\nr? @varkor\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "html_url": "https://github.com/rust-lang/rust/commit/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23d3fa266cc107ffceced3c5580eb6327662c605", "url": "https://api.github.com/repos/rust-lang/rust/commits/23d3fa266cc107ffceced3c5580eb6327662c605", "html_url": "https://github.com/rust-lang/rust/commit/23d3fa266cc107ffceced3c5580eb6327662c605"}, {"sha": "c339b2eb4aaa69499dc79b17575c671d3605723c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c339b2eb4aaa69499dc79b17575c671d3605723c", "html_url": "https://github.com/rust-lang/rust/commit/c339b2eb4aaa69499dc79b17575c671d3605723c"}], "stats": {"total": 148, "additions": 71, "deletions": 77}, "files": [{"sha": "23613caa99322121b10b18d98e7f9a9550463599", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 71, "deletions": 77, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b68f9c46a550dec9f8ef8bafb9a815cf564af1d/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=5b68f9c46a550dec9f8ef8bafb9a815cf564af1d", "patch": "@@ -216,93 +216,87 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Expr(&Expr { kind: ExprKind::Path(_), .. })\n                 | Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&Ty {\n-                            kind: TyKind::Path(QPath::Resolved(_, ref path)), ..\n-                        })\n+                        Node::Ty(&Ty { kind: TyKind::Path(QPath::Resolved(_, path)), .. })\n                         | Node::Expr(&Expr {\n-                            kind: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            kind:\n+                                ExprKind::Path(QPath::Resolved(_, path))\n+                                | ExprKind::Struct(&QPath::Resolved(_, path), ..),\n                             ..\n-                        }) => Some(&**path),\n-                        Node::Expr(&Expr { kind: ExprKind::Struct(ref path, ..), .. }) => {\n-                            if let QPath::Resolved(_, ref path) = **path {\n-                                Some(&**path)\n-                            } else {\n-                                None\n-                            }\n+                        })\n+                        | Node::TraitRef(&TraitRef { path, .. }) => &*path,\n+                        _ => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\"unexpected const parent path {:?}\", parent_node),\n+                            );\n+                            return tcx.types.err;\n                         }\n-                        Node::TraitRef(&TraitRef { ref path, .. }) => Some(&**path),\n-                        _ => None,\n                     };\n \n-                    if let Some(path) = path {\n-                        // We've encountered an `AnonConst` in some path, so we need to\n-                        // figure out which generic parameter it corresponds to and return\n-                        // the relevant type.\n-\n-                        let (arg_index, segment) = path\n-                            .segments\n-                            .iter()\n-                            .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n-                            .find_map(|(args, seg)| {\n-                                args.iter()\n-                                    .filter(|arg| arg.is_const())\n-                                    .enumerate()\n-                                    .filter(|(_, arg)| arg.id() == hir_id)\n-                                    .map(|(index, _)| (index, seg))\n-                                    .next()\n-                            })\n-                            .unwrap_or_else(|| {\n-                                bug!(\"no arg matching AnonConst in path\");\n-                            });\n-\n-                        // Try to use the segment resolution if it is valid, otherwise we\n-                        // default to the path resolution.\n-                        let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n-                        let generics = match res {\n-                            Res::Def(DefKind::Ctor(..), def_id) => {\n-                                tcx.generics_of(tcx.parent(def_id).unwrap())\n-                            }\n-                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n-                            res => {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"unexpected anon const res {:?} in path: {:?}\",\n-                                        res, path,\n-                                    ),\n-                                );\n-                                return tcx.types.err;\n+                    // We've encountered an `AnonConst` in some path, so we need to\n+                    // figure out which generic parameter it corresponds to and return\n+                    // the relevant type.\n+\n+                    let (arg_index, segment) = path\n+                        .segments\n+                        .iter()\n+                        .filter_map(|seg| seg.args.as_ref().map(|args| (args.args, seg)))\n+                        .find_map(|(args, seg)| {\n+                            args.iter()\n+                                .filter(|arg| arg.is_const())\n+                                .enumerate()\n+                                .filter(|(_, arg)| arg.id() == hir_id)\n+                                .map(|(index, _)| (index, seg))\n+                                .next()\n+                        })\n+                        .unwrap_or_else(|| {\n+                            bug!(\"no arg matching AnonConst in path\");\n+                        });\n+\n+                    // Try to use the segment resolution if it is valid, otherwise we\n+                    // default to the path resolution.\n+                    let res = segment.res.filter(|&r| r != Res::Err).unwrap_or(path.res);\n+                    let generics = match res {\n+                        Res::Def(DefKind::Ctor(..), def_id) => {\n+                            tcx.generics_of(tcx.parent(def_id).unwrap())\n+                        }\n+                        Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                        res => {\n+                            tcx.sess.delay_span_bug(\n+                                DUMMY_SP,\n+                                &format!(\n+                                    \"unexpected anon const res {:?} in path: {:?}\",\n+                                    res, path,\n+                                ),\n+                            );\n+                            return tcx.types.err;\n+                        }\n+                    };\n+\n+                    let ty = generics\n+                        .params\n+                        .iter()\n+                        .filter(|param| {\n+                            if let ty::GenericParamDefKind::Const = param.kind {\n+                                true\n+                            } else {\n+                                false\n                             }\n-                        };\n+                        })\n+                        .nth(arg_index)\n+                        .map(|param| tcx.type_of(param.def_id));\n \n-                        generics\n-                            .params\n-                            .iter()\n-                            .filter(|param| {\n-                                if let ty::GenericParamDefKind::Const = param.kind {\n-                                    true\n-                                } else {\n-                                    false\n-                                }\n-                            })\n-                            .nth(arg_index)\n-                            .map(|param| tcx.type_of(param.def_id))\n-                            // This is no generic parameter associated with the arg. This is\n-                            // probably from an extra arg where one is not needed.\n-                            .unwrap_or_else(|| {\n-                                tcx.sess.delay_span_bug(\n-                                    DUMMY_SP,\n-                                    &format!(\n-                                        \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n-                                        parent_node, res\n-                                    ),\n-                                );\n-                                tcx.types.err\n-                            })\n+                    if let Some(ty) = ty {\n+                        ty\n                     } else {\n+                        // This is no generic parameter associated with the arg. This is\n+                        // probably from an extra arg where one is not needed.\n                         tcx.sess.delay_span_bug(\n                             DUMMY_SP,\n-                            &format!(\"unexpected const parent path {:?}\", parent_node,),\n+                            &format!(\n+                                \"missing generic parameter for `AnonConst`, parent: {:?}, res: {:?}\",\n+                                parent_node, res\n+                            ),\n                         );\n                         tcx.types.err\n                     }"}]}