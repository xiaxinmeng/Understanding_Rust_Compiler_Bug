{"sha": "746991572fac33ba29c4d1a83574d3b7c2776998", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc0Njk5MTU3MmZhYzMzYmEyOWM0ZDFhODM1NzRkM2I3YzI3NzY5OTg=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-24T17:47:17Z"}, "committer": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2015-11-24T17:47:17Z"}, "message": "Extend match_ref_pats to desugared matches", "tree": {"sha": "e90e0a67e2607bd45a45a6c1f0a8c1484a969a5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e90e0a67e2607bd45a45a6c1f0a8c1484a969a5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/746991572fac33ba29c4d1a83574d3b7c2776998", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/746991572fac33ba29c4d1a83574d3b7c2776998", "html_url": "https://github.com/rust-lang/rust/commit/746991572fac33ba29c4d1a83574d3b7c2776998", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/746991572fac33ba29c4d1a83574d3b7c2776998/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3e8091e875a34aa288f675f90c657fa0a86f0e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3e8091e875a34aa288f675f90c657fa0a86f0e6", "html_url": "https://github.com/rust-lang/rust/commit/a3e8091e875a34aa288f675f90c657fa0a86f0e6"}], "stats": {"total": 65, "additions": 47, "deletions": 18}, "files": [{"sha": "55eb4fe381bb8f7da481aff91172b81038cc6bd2", "filename": "src/matches.rs", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/746991572fac33ba29c4d1a83574d3b7c2776998/src%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746991572fac33ba29c4d1a83574d3b7c2776998/src%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmatches.rs?ref=746991572fac33ba29c4d1a83574d3b7c2776998", "patch": "@@ -25,9 +25,8 @@ impl LintPass for MatchPass {\n \n impl LateLintPass for MatchPass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+        if in_external_macro(cx, expr.span) { return; }\n         if let ExprMatch(ref ex, ref arms, MatchSource::Normal) = expr.node {\n-            if in_external_macro(cx, expr.span) { return; }\n-\n             // check preconditions for SINGLE_MATCH\n                 // only two arms\n             if arms.len() == 2 &&\n@@ -53,19 +52,6 @@ impl LateLintPass for MatchPass {\n                                             expr_block(cx, &arms[0].body, None, \"..\")));\n             }\n \n-            // check preconditions for MATCH_REF_PATS\n-            if has_only_ref_pats(arms) {\n-                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"you don't need to add `&` to both the expression to match \\\n-                         and the patterns: use `match {} {{ ...`\", snippet(cx, inner.span, \"..\")));\n-                } else {\n-                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n-                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n-                         expression to match: `match *{} {{ ...`\", snippet(cx, ex.span, \"..\")));\n-                }\n-            }\n-\n             // check preconditions for MATCH_BOOL\n             // type of expression == bool\n             if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n@@ -123,6 +109,22 @@ impl LateLintPass for MatchPass {\n                 }\n             }\n         }\n+        if let ExprMatch(ref ex, ref arms, source) = expr.node {\n+            // check preconditions for MATCH_REF_PATS\n+            if has_only_ref_pats(arms) {\n+                if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n+                    let template = match_template(source, \"\", &snippet(cx, inner.span, \"..\"));\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"you don't need to add `&` to both the expression \\\n+                         and the patterns: use `{}`\", template));\n+                } else {\n+                    let template = match_template(source, \"*\", &snippet(cx, ex.span, \"..\"));\n+                    span_lint(cx, MATCH_REF_PATS, expr.span, &format!(\n+                        \"instead of prefixing all patterns with `&`, you can dereference the \\\n+                         expression: `{}`\", template));\n+                }\n+            }\n+        }\n     }\n }\n \n@@ -143,3 +145,20 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     // look for Some(v) where there's at least one true element\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n+\n+fn match_template(source: MatchSource, op: &str, expr: &str) -> String {\n+    match source {\n+        MatchSource::Normal => {\n+            format!(\"match {}{} {{ ...\", op, expr)\n+        }\n+        MatchSource::IfLetDesugar { .. } => {\n+            format!(\"if let ... = {}{} {{\", op, expr)\n+        }\n+        MatchSource::WhileLetDesugar => {\n+            format!(\"while let ... = {}{} {{\", op, expr)\n+        }\n+        MatchSource::ForLoopDesugar => {\n+            panic!(\"for loop desugared to match with &-patterns!\")\n+        }\n+    }\n+}"}, {"sha": "ea3a48a94f5d24066bd578900d12a116569d521f", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/746991572fac33ba29c4d1a83574d3b7c2776998/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746991572fac33ba29c4d1a83574d3b7c2776998/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=746991572fac33ba29c4d1a83574d3b7c2776998", "patch": "@@ -78,7 +78,7 @@ fn match_bool() {\n fn ref_pats() {\n     {\n         let v = &Some(0);\n-        match v {  //~ERROR instead of prefixing all patterns with `&`\n+        match v {  //~ERROR dereference the expression: `match *v { ...`\n             &Some(v) => println!(\"{:?}\", v),\n             &None => println!(\"none\"),\n         }\n@@ -88,13 +88,13 @@ fn ref_pats() {\n         }\n     }\n     let tup =& (1, 2);\n-    match tup {  //~ERROR instead of prefixing all patterns with `&`\n+    match tup {  //~ERROR dereference the expression: `match *tup { ...`\n         &(v, 1) => println!(\"{}\", v),\n         _ => println!(\"none\"),\n     }\n     // special case: using & both in expr and pats\n     let w = Some(0);\n-    match &w {  //~ERROR you don't need to add `&` to both\n+    match &w {  //~ERROR use `match w { ...`\n         &Some(v) => println!(\"{:?}\", v),\n         &None => println!(\"none\"),\n     }\n@@ -103,6 +103,16 @@ fn ref_pats() {\n     match w {\n         _ => println!(\"none\"),\n     }\n+\n+    let a = &Some(0);\n+    if let &None = a { //~ERROR dereference the expression: `if let ... = *a {`\n+        println!(\"none\");\n+    }\n+\n+    let b = Some(0);\n+    if let &None = &b { //~ERROR use `if let ... = b {`\n+        println!(\"none\");\n+    }\n }\n \n fn main() {"}]}