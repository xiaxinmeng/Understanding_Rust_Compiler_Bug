{"sha": "cb0eb66672c20404cc87850db98fe00ff94da403", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMGViNjY2NzJjMjA0MDRjYzg3ODUwZGI5OGZlMDBmZjk0ZGE0MDM=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-03T00:32:06Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-09-03T00:32:22Z"}, "message": "std: Camel case the rope module", "tree": {"sha": "49908f3bc054b8b14318a3eebf4c7e80ffd3d6e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/49908f3bc054b8b14318a3eebf4c7e80ffd3d6e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb0eb66672c20404cc87850db98fe00ff94da403", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb0eb66672c20404cc87850db98fe00ff94da403", "html_url": "https://github.com/rust-lang/rust/commit/cb0eb66672c20404cc87850db98fe00ff94da403", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb0eb66672c20404cc87850db98fe00ff94da403/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b808cfbb74a6d9ee01d22a1754f8ddfe3022b1e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/b808cfbb74a6d9ee01d22a1754f8ddfe3022b1e5", "html_url": "https://github.com/rust-lang/rust/commit/b808cfbb74a6d9ee01d22a1754f8ddfe3022b1e5"}], "stats": {"total": 285, "additions": 142, "deletions": 143}, "files": [{"sha": "49d061ecd72a0f419e32311b9d201be299e3818d", "filename": "src/libstd/rope.rs", "status": "modified", "additions": 142, "deletions": 142, "changes": 284, "blob_url": "https://github.com/rust-lang/rust/blob/cb0eb66672c20404cc87850db98fe00ff94da403/src%2Flibstd%2Frope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb0eb66672c20404cc87850db98fe00ff94da403/src%2Flibstd%2Frope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frope.rs?ref=cb0eb66672c20404cc87850db98fe00ff94da403", "patch": "@@ -27,15 +27,15 @@\n #[forbid(deprecated_pattern)];\n \n /// The type of ropes.\n-type rope = node::root;\n+type Rope = node::Root;\n \n /*\n  Section: Creating a rope\n  */\n \n /// Create an empty rope\n-fn empty() -> rope {\n-   return node::empty;\n+fn empty() -> Rope {\n+   return node::Empty;\n }\n \n /**\n@@ -55,7 +55,7 @@ fn empty() -> rope {\n  * * this operation does not copy the string;\n  * * the function runs in linear time.\n  */\n-fn of_str(str: @~str) -> rope {\n+fn of_str(str: @~str) -> Rope {\n     return of_substr(str, 0u, str::len(*str));\n }\n \n@@ -81,10 +81,10 @@ fn of_str(str: @~str) -> rope {\n  * * this function does _not_ check the validity of the substring;\n  * * this function fails if `byte_offset` or `byte_len` do not match `str`.\n  */\n-fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> rope {\n-    if byte_len == 0u { return node::empty; }\n+fn of_substr(str: @~str, byte_offset: uint, byte_len: uint) -> Rope {\n+    if byte_len == 0u { return node::Empty; }\n     if byte_offset + byte_len  > str::len(*str) { fail; }\n-    return node::content(node::of_substr(str, byte_offset, byte_len));\n+    return node::Content(node::of_substr(str, byte_offset, byte_len));\n }\n \n /*\n@@ -98,7 +98,7 @@ Section: Adding things to a rope\n  *\n  * * this function executes in near-constant time\n  */\n-fn append_char(rope: rope, char: char) -> rope {\n+fn append_char(rope: Rope, char: char) -> Rope {\n     return append_str(rope, @str::from_chars(~[char]));\n }\n \n@@ -109,7 +109,7 @@ fn append_char(rope: rope, char: char) -> rope {\n  *\n  * * this function executes in near-linear time\n  */\n-fn append_str(rope: rope, str: @~str) -> rope {\n+fn append_str(rope: Rope, str: @~str) -> Rope {\n     return append_rope(rope, of_str(str))\n }\n \n@@ -119,7 +119,7 @@ fn append_str(rope: rope, str: @~str) -> rope {\n  * # Performance note\n  * * this function executes in near-constant time\n  */\n-fn prepend_char(rope: rope, char: char) -> rope {\n+fn prepend_char(rope: Rope, char: char) -> Rope {\n     return prepend_str(rope, @str::from_chars(~[char]));\n }\n \n@@ -129,19 +129,19 @@ fn prepend_char(rope: rope, char: char) -> rope {\n  * # Performance note\n  * * this function executes in near-linear time\n  */\n-fn prepend_str(rope: rope, str: @~str) -> rope {\n+fn prepend_str(rope: Rope, str: @~str) -> Rope {\n     return append_rope(of_str(str), rope)\n }\n \n /// Concatenate two ropes\n-fn append_rope(left: rope, right: rope) -> rope {\n+fn append_rope(left: Rope, right: Rope) -> Rope {\n    match (left) {\n-     node::empty => return right,\n-     node::content(left_content) => {\n+     node::Empty => return right,\n+     node::Content(left_content) => {\n        match (right) {\n-         node::empty => return left,\n-         node::content(right_content) => {\n-           return node::content(node::concat2(left_content, right_content));\n+         node::Empty => return left,\n+         node::Content(right_content) => {\n+           return node::Content(node::concat2(left_content, right_content));\n          }\n        }\n      }\n@@ -155,10 +155,10 @@ fn append_rope(left: rope, right: rope) -> rope {\n  * rope remains balanced. However, this function does not take any further\n  * measure to ensure that the result is balanced.\n  */\n-fn concat(v: ~[rope]) -> rope {\n+fn concat(v: ~[Rope]) -> Rope {\n     //Copy `v` into a mut vector\n     let mut len = vec::len(v);\n-    if len == 0u { return node::empty; }\n+    if len == 0u { return node::Empty; }\n     let ropes = vec::to_mut(vec::from_elem(len, v[0]));\n     for uint::range(1u, len) |i| {\n        ropes[i] = v[i];\n@@ -198,12 +198,12 @@ Section: Keeping ropes healthy\n  * If you perform numerous rope concatenations, it is generally a good idea\n  * to rebalance your rope at some point, before using it for other purposes.\n  */\n-fn bal(rope:rope) -> rope {\n+fn bal(rope:Rope) -> Rope {\n     match (rope) {\n-      node::empty => return rope,\n-      node::content(x) => match (node::bal(x)) {\n+      node::Empty => return rope,\n+      node::Content(x) => match (node::bal(x)) {\n         option::None    => rope,\n-        option::Some(y) => node::content(y)\n+        option::Some(y) => node::Content(y)\n       }\n     }\n }\n@@ -226,14 +226,14 @@ Section: Transforming ropes\n  * * this function fails if char_offset/char_len do not represent\n  *   valid positions in rope\n  */\n-fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n-    if char_len == 0u { return node::empty; }\n+fn sub_chars(rope: Rope, char_offset: uint, char_len: uint) -> Rope {\n+    if char_len == 0u { return node::Empty; }\n     match (rope) {\n-      node::empty => fail,\n-      node::content(node) => if char_len > node::char_len(node) {\n+      node::Empty => fail,\n+      node::Content(node) => if char_len > node::char_len(node) {\n         fail\n       } else {\n-        return node::content(node::sub_chars(node, char_offset, char_len))\n+        return node::Content(node::sub_chars(node, char_offset, char_len))\n       }\n     }\n }\n@@ -251,14 +251,14 @@ fn sub_chars(rope: rope, char_offset: uint, char_len: uint) -> rope {\n  * * this function fails if byte_offset/byte_len do not represent\n  *   valid positions in rope\n  */\n-fn sub_bytes(rope: rope, byte_offset: uint, byte_len: uint) -> rope {\n-    if byte_len == 0u { return node::empty; }\n+fn sub_bytes(rope: Rope, byte_offset: uint, byte_len: uint) -> Rope {\n+    if byte_len == 0u { return node::Empty; }\n     match (rope) {\n-      node::empty => fail,\n-      node::content(node) =>if byte_len > node::byte_len(node) {\n+      node::Empty => fail,\n+      node::Content(node) =>if byte_len > node::byte_len(node) {\n         fail\n       } else {\n-        return node::content(node::sub_bytes(node, byte_offset, byte_len))\n+        return node::Content(node::sub_bytes(node, byte_offset, byte_len))\n       }\n     }\n }\n@@ -277,12 +277,12 @@ Section: Comparing ropes\n  * A negative value if `left < right`, 0 if eq(left, right) or a positive\n  * value if `left > right`\n  */\n-fn cmp(left: rope, right: rope) -> int {\n+fn cmp(left: Rope, right: Rope) -> int {\n     match ((left, right)) {\n-      (node::empty, node::empty) => return 0,\n-      (node::empty, _)     => return -1,\n-      (_, node::empty)     => return  1,\n-      (node::content(a), node::content(b)) => {\n+      (node::Empty, node::Empty) => return 0,\n+      (node::Empty, _)     => return -1,\n+      (_, node::Empty)     => return  1,\n+      (node::Content(a), node::Content(b)) => {\n         return node::cmp(a, b);\n       }\n     }\n@@ -292,7 +292,7 @@ fn cmp(left: rope, right: rope) -> int {\n  * Returns `true` if both ropes have the same content (regardless of\n  * their structure), `false` otherwise\n  */\n-fn eq(left: rope, right: rope) -> bool {\n+fn eq(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) == 0;\n }\n \n@@ -307,7 +307,7 @@ fn eq(left: rope, right: rope) -> bool {\n  * `true` if `left <= right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn le(left: rope, right: rope) -> bool {\n+fn le(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) <= 0;\n }\n \n@@ -322,7 +322,7 @@ fn le(left: rope, right: rope) -> bool {\n  * `true` if `left < right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn lt(left: rope, right: rope) -> bool {\n+fn lt(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) < 0;\n }\n \n@@ -337,7 +337,7 @@ fn lt(left: rope, right: rope) -> bool {\n  *  `true` if `left >= right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn ge(left: rope, right: rope) -> bool {\n+fn ge(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) >= 0;\n }\n \n@@ -352,7 +352,7 @@ fn ge(left: rope, right: rope) -> bool {\n  * `true` if `left > right` in lexicographical order (regardless of their\n  * structure), `false` otherwise\n  */\n-fn gt(left: rope, right: rope) -> bool {\n+fn gt(left: Rope, right: Rope) -> bool {\n     return cmp(left, right) > 0;\n }\n \n@@ -380,10 +380,10 @@ Section: Iterating\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n+fn loop_chars(rope: Rope, it: fn(char) -> bool) -> bool {\n    match (rope) {\n-      node::empty => return true,\n-      node::content(x) => return node::loop_chars(x, it)\n+      node::Empty => return true,\n+      node::Content(x) => return node::loop_chars(x, it)\n    }\n }\n \n@@ -394,7 +394,7 @@ fn loop_chars(rope: rope, it: fn(char) -> bool) -> bool {\n  * * rope - A rope to traverse. It may be empty\n  * * it - A block to execute with each consecutive character of the rope.\n  */\n-fn iter_chars(rope: rope, it: fn(char)) {\n+fn iter_chars(rope: Rope, it: fn(char)) {\n     do loop_chars(rope) |x| {\n         it(x);\n         true\n@@ -423,33 +423,33 @@ fn iter_chars(rope: rope, it: fn(char)) {\n  * `true` If execution proceeded correctly, `false` if it was interrupted,\n  * that is if `it` returned `false` at any point.\n  */\n-fn loop_leaves(rope: rope, it: fn(node::leaf) -> bool) -> bool{\n+fn loop_leaves(rope: Rope, it: fn(node::Leaf) -> bool) -> bool{\n    match (rope) {\n-      node::empty => return true,\n-      node::content(x) => return node::loop_leaves(x, it)\n+      node::Empty => return true,\n+      node::Content(x) => return node::loop_leaves(x, it)\n    }\n }\n \n mod iterator {\n     mod leaf {\n-        fn start(rope: rope) -> node::leaf_iterator::t {\n+        fn start(rope: Rope) -> node::leaf_iterator::T {\n             match (rope) {\n-              node::empty      => return node::leaf_iterator::empty(),\n-              node::content(x) => return node::leaf_iterator::start(x)\n+              node::Empty      => return node::leaf_iterator::empty(),\n+              node::Content(x) => return node::leaf_iterator::start(x)\n             }\n         }\n-        fn next(it: &node::leaf_iterator::t) -> Option<node::leaf> {\n+        fn next(it: &node::leaf_iterator::T) -> Option<node::Leaf> {\n             return node::leaf_iterator::next(it);\n         }\n     }\n     mod char {\n-        fn start(rope: rope) -> node::char_iterator::t {\n+        fn start(rope: Rope) -> node::char_iterator::T {\n             match (rope) {\n-              node::empty      => return node::char_iterator::empty(),\n-              node::content(x) => return node::char_iterator::start(x)\n+              node::Empty      => return node::char_iterator::empty(),\n+              node::Content(x) => return node::char_iterator::start(x)\n             }\n         }\n-        fn next(it: &node::char_iterator::t) -> Option<char> {\n+        fn next(it: &node::char_iterator::T) -> Option<char> {\n             return node::char_iterator::next(it)\n         }\n     }\n@@ -470,10 +470,10 @@ mod iterator {\n  *\n  * Constant time.\n  */\n-fn height(rope: rope) -> uint {\n+fn height(rope: Rope) -> uint {\n    match (rope) {\n-      node::empty      => return 0u,\n-      node::content(x) => return node::height(x)\n+      node::Empty      => return 0u,\n+      node::Content(x) => return node::height(x)\n    }\n }\n \n@@ -486,10 +486,10 @@ fn height(rope: rope) -> uint {\n  *\n  * Constant time.\n  */\n-pure fn char_len(rope: rope) -> uint {\n+pure fn char_len(rope: Rope) -> uint {\n    match (rope) {\n-     node::empty            => return 0u,\n-     node::content(x)       => return node::char_len(x)\n+     node::Empty            => return 0u,\n+     node::Content(x)       => return node::char_len(x)\n    }\n }\n \n@@ -500,10 +500,10 @@ pure fn char_len(rope: rope) -> uint {\n  *\n  * Constant time.\n  */\n-pure fn byte_len(rope: rope) -> uint {\n+pure fn byte_len(rope: Rope) -> uint {\n    match (rope) {\n-     node::empty            => return 0u,\n-     node::content(x)       => return node::byte_len(x)\n+     node::Empty            => return 0u,\n+     node::Content(x)       => return node::byte_len(x)\n    }\n }\n \n@@ -523,10 +523,10 @@ pure fn byte_len(rope: rope) -> uint {\n  * This function executes in a time proportional to the height of the\n  * rope + the (bounded) length of the largest leaf.\n  */\n-fn char_at(rope: rope, pos: uint) -> char {\n+fn char_at(rope: Rope, pos: uint) -> char {\n    match (rope) {\n-      node::empty => fail,\n-      node::content(x) => return node::char_at(x, pos)\n+      node::Empty => fail,\n+      node::Content(x) => return node::char_at(x, pos)\n    }\n }\n \n@@ -537,11 +537,11 @@ fn char_at(rope: rope, pos: uint) -> char {\n mod node {\n \n     /// Implementation of type `rope`\n-    enum root {\n+    enum Root {\n         /// An empty rope\n-        empty,\n+        Empty,\n         /// A non-empty rope\n-        content(@node),\n+        Content(@Node),\n     }\n \n     /**\n@@ -561,7 +561,7 @@ mod node {\n      *     string can be shared between several ropes, e.g. for indexing\n      *     purposes.\n      */\n-    type leaf = {\n+    type Leaf = {\n         byte_offset: uint,\n         byte_len:    uint,\n         char_len:   uint,\n@@ -585,20 +585,20 @@ mod node {\n      *\n      *     Used for rebalancing and to allocate stacks for traversals.\n      */\n-    type concat = {\n+    type Concat = {\n         //FIXME (#2744): Perhaps a `vec` instead of `left`/`right`\n-        left:     @node,\n-        right:    @node,\n+        left:     @Node,\n+        right:    @Node,\n         char_len: uint,\n         byte_len: uint,\n         height:   uint\n     };\n \n-    enum node {\n+    enum Node {\n         /// A leaf consisting in a `str`\n-        leaf(leaf),\n+        Leaf(Leaf),\n         /// The concatenation of two ropes\n-        concat(concat),\n+        Concat(Concat),\n     }\n \n     /**\n@@ -625,7 +625,7 @@ mod node {\n      * Performance note: The complexity of this function is linear in\n      * the length of `str`.\n      */\n-    fn of_str(str: @~str) -> @node {\n+    fn of_str(str: @~str) -> @Node {\n         return of_substr(str, 0u, str::len(*str));\n     }\n \n@@ -646,7 +646,7 @@ mod node {\n      * Behavior is undefined if `byte_start` or `byte_len` do not represent\n      * valid positions in `str`\n      */\n-    fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @node {\n+    fn of_substr(str: @~str, byte_start: uint, byte_len: uint) -> @Node {\n         return of_substr_unsafer(str, byte_start, byte_len,\n                               str::count_chars(*str, byte_start, byte_len));\n     }\n@@ -673,9 +673,9 @@ mod node {\n      *   number of chars between byte_start and byte_start+byte_len\n      */\n     fn of_substr_unsafer(str: @~str, byte_start: uint, byte_len: uint,\n-                          char_len: uint) -> @node {\n+                          char_len: uint) -> @Node {\n         assert(byte_start + byte_len <= str::len(*str));\n-        let candidate = @leaf({\n+        let candidate = @Leaf({\n                 byte_offset: byte_start,\n                 byte_len:    byte_len,\n                 char_len:    char_len,\n@@ -702,7 +702,7 @@ mod node {\n                     else { hint_max_leaf_char_len };\n                 let chunk_byte_len =\n                     str::count_bytes(*str, offset, chunk_char_len);\n-                nodes[i] = @leaf({\n+                nodes[i] = @Leaf({\n                     byte_offset: offset,\n                     byte_len:    chunk_byte_len,\n                     char_len:    chunk_char_len,\n@@ -730,18 +730,18 @@ mod node {\n         }\n     }\n \n-    pure fn byte_len(node: @node) -> uint {\n+    pure fn byte_len(node: @Node) -> uint {\n         //FIXME (#2744): Could we do this without the pattern-matching?\n         match (*node) {\n-          leaf(y)   => return y.byte_len,\n-          concat(y) => return y.byte_len\n+          Leaf(y)   => return y.byte_len,\n+          Concat(y) => return y.byte_len\n         }\n     }\n \n-    pure fn char_len(node: @node) -> uint {\n+    pure fn char_len(node: @Node) -> uint {\n         match (*node) {\n-          leaf(y)   => return y.char_len,\n-          concat(y) => return y.char_len\n+          Leaf(y)   => return y.char_len,\n+          Concat(y) => return y.char_len\n         }\n     }\n \n@@ -753,7 +753,7 @@ mod node {\n      * * forest - The forest. This vector is progressively rewritten during\n      *            execution and should be discarded as meaningless afterwards.\n      */\n-    fn tree_from_forest_destructive(forest: &[mut @node]) -> @node {\n+    fn tree_from_forest_destructive(forest: &[mut @Node]) -> @Node {\n         let mut i;\n         let mut len = vec::len(forest);\n         while len > 1u {\n@@ -797,7 +797,7 @@ mod node {\n         return forest[0];\n     }\n \n-    fn serialize_node(node: @node) -> ~str unsafe {\n+    fn serialize_node(node: @Node) -> ~str unsafe {\n         let mut buf = vec::to_mut(vec::from_elem(byte_len(node), 0u8));\n         let mut offset = 0u;//Current position in the buffer\n         let it = leaf_iterator::start(node);\n@@ -828,11 +828,11 @@ mod node {\n      *\n      * This function executes in linear time.\n      */\n-    fn flatten(node: @node) -> @node unsafe {\n+    fn flatten(node: @Node) -> @Node unsafe {\n         match (*node) {\n-          leaf(_) => return node,\n-          concat(x) => {\n-            return @leaf({\n+          Leaf(_) => return node,\n+          Concat(x) => {\n+            return @Leaf({\n                 byte_offset: 0u,\n                 byte_len:    x.byte_len,\n                 char_len:    x.char_len,\n@@ -857,15 +857,15 @@ mod node {\n      * * `option::some(x)` otherwise, in which case `x` has the same contents\n      *    as `node` bot lower height and/or fragmentation.\n      */\n-    fn bal(node: @node) -> Option<@node> {\n+    fn bal(node: @Node) -> Option<@Node> {\n         if height(node) < hint_max_node_height { return option::None; }\n         //1. Gather all leaves as a forest\n         let mut forest = ~[mut];\n         let it = leaf_iterator::start(node);\n         loop {\n             match (leaf_iterator::next(&it)) {\n               option::None    => break,\n-              option::Some(x) => vec::push(forest, @leaf(x))\n+              option::Some(x) => vec::push(forest, @Leaf(x))\n             }\n         }\n         //2. Rebuild tree from forest\n@@ -893,23 +893,23 @@ mod node {\n      * This function fails if `byte_offset` or `byte_len` do not represent\n      * valid positions in `node`.\n      */\n-    fn sub_bytes(node: @node, byte_offset: uint, byte_len: uint) -> @node {\n+    fn sub_bytes(node: @Node, byte_offset: uint, byte_len: uint) -> @Node {\n         let mut node        = node;\n         let mut byte_offset = byte_offset;\n         loop {\n             if byte_offset == 0u && byte_len == node::byte_len(node) {\n                 return node;\n             }\n             match (*node) {\n-              node::leaf(x) => {\n+              node::Leaf(x) => {\n                 let char_len =\n                     str::count_chars(*x.content, byte_offset, byte_len);\n-                return @leaf({byte_offset: byte_offset,\n+                return @Leaf({byte_offset: byte_offset,\n                                 byte_len:    byte_len,\n                                 char_len:    char_len,\n                                 content:     x.content});\n               }\n-              node::concat(x) => {\n+              node::Concat(x) => {\n                 let left_len: uint = node::byte_len(x.left);\n                 if byte_offset <= left_len {\n                     if byte_offset + byte_len <= left_len {\n@@ -954,25 +954,25 @@ mod node {\n      * This function fails if `char_offset` or `char_len` do not represent\n      * valid positions in `node`.\n      */\n-    fn sub_chars(node: @node, char_offset: uint, char_len: uint) -> @node {\n+    fn sub_chars(node: @Node, char_offset: uint, char_len: uint) -> @Node {\n         let mut node        = node;\n         let mut char_offset = char_offset;\n         loop {\n             match (*node) {\n-              node::leaf(x) => {\n+              node::Leaf(x) => {\n                 if char_offset == 0u && char_len == x.char_len {\n                     return node;\n                 }\n                 let byte_offset =\n                     str::count_bytes(*x.content, 0u, char_offset);\n                 let byte_len    =\n                     str::count_bytes(*x.content, byte_offset, char_len);\n-                return @leaf({byte_offset: byte_offset,\n+                return @Leaf({byte_offset: byte_offset,\n                            byte_len:    byte_len,\n                            char_len:    char_len,\n                            content:     x.content});\n               }\n-              node::concat(x) => {\n+              node::Concat(x) => {\n                 if char_offset == 0u && char_len == x.char_len {return node;}\n                 let left_len : uint = node::char_len(x.left);\n                 if char_offset <= left_len {\n@@ -999,23 +999,23 @@ mod node {\n         };\n     }\n \n-    fn concat2(left: @node, right: @node) -> @node {\n-        return @concat({left    : left,\n+    fn concat2(left: @Node, right: @Node) -> @Node {\n+        return @Concat({left    : left,\n                      right   : right,\n              char_len: char_len(left) + char_len(right),\n                      byte_len: byte_len(left) + byte_len(right),\n              height: uint::max(height(left), height(right)) + 1u\n                     })\n     }\n \n-    fn height(node: @node) -> uint {\n+    fn height(node: @Node) -> uint {\n         match (*node) {\n-          leaf(_)   => return 0u,\n-          concat(x) => return x.height\n+          Leaf(_)   => return 0u,\n+          Concat(x) => return x.height\n         }\n     }\n \n-    fn cmp(a: @node, b: @node) -> int {\n+    fn cmp(a: @Node, b: @Node) -> int {\n         let ita = char_iterator::start(a);\n         let itb = char_iterator::start(b);\n         let mut result = 0;\n@@ -1036,7 +1036,7 @@ mod node {\n         return result;\n     }\n \n-    fn loop_chars(node: @node, it: fn(char) -> bool) -> bool {\n+    fn loop_chars(node: @Node, it: fn(char) -> bool) -> bool {\n         return loop_leaves(node,|leaf| {\n             str::all_between(*leaf.content,\n                              leaf.byte_offset,\n@@ -1058,12 +1058,12 @@ mod node {\n      * `true` If execution proceeded correctly, `false` if it was interrupted,\n      * that is if `it` returned `false` at any point.\n      */\n-    fn loop_leaves(node: @node, it: fn(leaf) -> bool) -> bool{\n+    fn loop_leaves(node: @Node, it: fn(Leaf) -> bool) -> bool{\n         let mut current = node;\n         loop {\n             match (*current) {\n-              leaf(x) => return it(x),\n-              concat(x) => if loop_leaves(x.left, it) { //non tail call\n+              Leaf(x) => return it(x),\n+              Concat(x) => if loop_leaves(x.left, it) { //non tail call\n                 current = x.right;       //tail call\n               } else {\n                 return false;\n@@ -1089,13 +1089,13 @@ mod node {\n      * proportional to the height of the rope + the (bounded)\n      * length of the largest leaf.\n      */\n-    fn char_at(node: @node, pos: uint) -> char {\n+    fn char_at(node: @Node, pos: uint) -> char {\n         let mut node    = node;\n         let mut pos     = pos;\n         loop {\n             match *node {\n-              leaf(x) => return str::char_at(*x.content, pos),\n-              concat({left, right, _}) => {\n+              Leaf(x) => return str::char_at(*x.content, pos),\n+              Concat({left, right, _}) => {\n                 let left_len = char_len(left);\n                 node = if left_len > pos { left }\n                        else { pos -= left_len; right };\n@@ -1105,66 +1105,66 @@ mod node {\n     }\n \n     mod leaf_iterator {\n-        type t = {\n-            stack:            ~[mut @node],\n+        type T = {\n+            stack:            ~[mut @Node],\n             mut stackpos: int\n         };\n \n-        fn empty() -> t {\n-            let stack : ~[mut @node] = ~[mut];\n+        fn empty() -> T {\n+            let stack : ~[mut @Node] = ~[mut];\n             return {stack: stack, mut stackpos: -1}\n         }\n \n-        fn start(node: @node) -> t {\n+        fn start(node: @Node) -> T {\n             let stack = vec::to_mut(vec::from_elem(height(node)+1u, node));\n             return {\n                 stack:             stack,\n                 mut stackpos:  0\n             }\n         }\n \n-        fn next(it: &t) -> Option<leaf> {\n+        fn next(it: &T) -> Option<Leaf> {\n             if it.stackpos < 0 { return option::None; }\n             loop {\n                 let current = it.stack[it.stackpos];\n                 it.stackpos -= 1;\n                 match (*current) {\n-                  concat(x) => {\n+                  Concat(x) => {\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.right;\n                     it.stackpos += 1;\n                     it.stack[it.stackpos] = x.left;\n                   }\n-                  leaf(x) => return option::Some(x)\n+                  Leaf(x) => return option::Some(x)\n                 }\n             };\n         }\n     }\n \n     mod char_iterator {\n-        type t = {\n-            leaf_iterator: leaf_iterator::t,\n-            mut leaf:  Option<leaf>,\n+        type T = {\n+            leaf_iterator: leaf_iterator::T,\n+            mut leaf:  Option<Leaf>,\n             mut leaf_byte_pos: uint\n         };\n \n-        fn start(node: @node) -> t {\n+        fn start(node: @Node) -> T {\n             return {\n                 leaf_iterator: leaf_iterator::start(node),\n                 mut leaf:          option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n-        fn empty() -> t {\n+        fn empty() -> T {\n             return {\n                 leaf_iterator: leaf_iterator::empty(),\n                 mut leaf:  option::None,\n                 mut leaf_byte_pos: 0u\n             }\n         }\n \n-        fn next(it: &t) -> Option<char> {\n+        fn next(it: &T) -> Option<char> {\n             loop {\n                 match (get_current_or_next_leaf(it)) {\n                   option::None => return option::None,\n@@ -1179,7 +1179,7 @@ mod node {\n             };\n         }\n \n-        fn get_current_or_next_leaf(it: &t) -> Option<leaf> {\n+        fn get_current_or_next_leaf(it: &T) -> Option<Leaf> {\n             match ((*it).leaf) {\n               option::Some(_) => return (*it).leaf,\n               option::None => {\n@@ -1196,7 +1196,7 @@ mod node {\n             }\n         }\n \n-        fn get_next_char_in_leaf(it: &t) -> Option<char> {\n+        fn get_next_char_in_leaf(it: &T) -> Option<char> {\n             match copy (*it).leaf {\n               option::None => return option::None,\n               option::Some(aleaf) => {\n@@ -1221,19 +1221,19 @@ mod node {\n mod tests {\n \n     //Utility function, used for sanity check\n-    fn rope_to_string(r: rope) -> ~str {\n+    fn rope_to_string(r: Rope) -> ~str {\n         match (r) {\n-          node::empty => return ~\"\",\n-          node::content(x) => {\n+          node::Empty => return ~\"\",\n+          node::Content(x) => {\n             let str = @mut ~\"\";\n-            fn aux(str: @mut ~str, node: @node::node) unsafe {\n+            fn aux(str: @mut ~str, node: @node::Node) unsafe {\n                 match (*node) {\n-                  node::leaf(x) => {\n+                  node::Leaf(x) => {\n                     *str += str::slice(\n                         *x.content, x.byte_offset,\n                         x.byte_offset + x.byte_len);\n                   }\n-                  node::concat(x) => {\n+                  node::Concat(x) => {\n                     aux(str, x.left);\n                     aux(str, x.right);\n                   }"}, {"sha": "2b60d4cc4befa27787b4049c5723f52a4aec37bf", "filename": "src/libstd/std.rc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb0eb66672c20404cc87850db98fe00ff94da403/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/cb0eb66672c20404cc87850db98fe00ff94da403/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=cb0eb66672c20404cc87850db98fe00ff94da403", "patch": "@@ -65,7 +65,6 @@ mod fun_treemap;\n mod list;\n #[allow(non_camel_case_types)] // XXX\n mod map;\n-#[allow(non_camel_case_types)] // XXX\n mod rope;\n #[allow(non_camel_case_types)] // XXX\n mod smallintmap;"}]}