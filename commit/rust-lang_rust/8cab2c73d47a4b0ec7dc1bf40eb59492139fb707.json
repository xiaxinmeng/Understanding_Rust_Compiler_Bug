{"sha": "8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjYWIyYzczZDQ3YTRiMGVjN2RjMWJmNDBlYjU5NDkyMTM5ZmI3MDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-06T02:34:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-06T02:34:29Z"}, "message": "Auto merge of #42899 - alexcrichton:compiler-builtins, r=nikomatsakis\n\nSwitch to rust-lang-nursery/compiler-builtins\n\nThis commit migrates the in-tree `libcompiler_builtins` to the upstream version\nat https://github.com/rust-lang-nursery/compiler-builtins. The upstream version\nhas a number of intrinsics written in Rust and serves as an in-progress rewrite\nof compiler-rt into Rust. Additionally it also contains all the existing\nintrinsics defined in `libcompiler_builtins` for 128-bit integers.\n\nIt's been the intention since the beginning to make this transition but\npreviously it just lacked the manpower to get done. As this PR likely shows it\nwasn't a trivial integration! Some highlight changes are:\n\n* The PR rust-lang-nursery/compiler-builtins#166 contains a number of fixes\n  across platforms and also some refactorings to make the intrinsics easier to\n  read. The additional testing added there also fixed a number of integration\n  issues when pulling the repository into this tree.\n\n* LTO with the compiler-builtins crate was fixed to link in the entire crate\n  after the LTO process as these intrinsics are excluded from LTO.\n\n* Treatment of hidden symbols was updated as previously the\n  `#![compiler_builtins]` crate would mark all symbol *imports* as hidden\n  whereas it was only intended to mark *exports* as hidden.", "tree": {"sha": "9c05341fbca4929e1963c8f98271edbebb326a20", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c05341fbca4929e1963c8f98271edbebb326a20"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "html_url": "https://github.com/rust-lang/rust/commit/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1685c9298685f73db4fe890c1ed27b22408aaad7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1685c9298685f73db4fe890c1ed27b22408aaad7", "html_url": "https://github.com/rust-lang/rust/commit/1685c9298685f73db4fe890c1ed27b22408aaad7"}, {"sha": "7e6c9f363501c49d3a1f666d85d41891f50890b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7e6c9f363501c49d3a1f666d85d41891f50890b8", "html_url": "https://github.com/rust-lang/rust/commit/7e6c9f363501c49d3a1f666d85d41891f50890b8"}], "stats": {"total": 1339, "additions": 103, "deletions": 1236}, "files": [{"sha": "6244b3c0951868b30ea8a3bbc0605e647e7ddf6e", "filename": ".gitmodules", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -2,9 +2,6 @@\n \tpath = src/llvm\n \turl = https://github.com/rust-lang/llvm.git\n \tbranch = master\n-[submodule \"src/compiler-rt\"]\n-\tpath = src/compiler-rt\n-\turl = https://github.com/rust-lang/compiler-rt.git\n [submodule \"src/rt/hoedown\"]\n \tpath = src/rt/hoedown\n \turl = https://github.com/rust-lang/hoedown.git\n@@ -33,3 +30,6 @@\n [submodule \"src/tools/rls\"]\n \tpath = src/tools/rls\n \turl = https://github.com/rust-lang-nursery/rls.git\n+[submodule \"src/libcompiler_builtins\"]\n+\tpath = src/libcompiler_builtins\n+\turl = https://github.com/rust-lang-nursery/compiler-builtins"}, {"sha": "28c4d2e981938712b5bf285e11fbcc0b79ec7171", "filename": "src/Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -276,7 +276,6 @@ dependencies = [\n name = \"compiler_builtins\"\n version = \"0.0.0\"\n dependencies = [\n- \"build_helper 0.1.0\",\n  \"core 0.0.0\",\n  \"gcc 0.3.51 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]"}, {"sha": "497a5ab6c536caef5e8fb8ba7e0fbb2afda85b65", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -137,6 +137,11 @@ fn main() {\n             }\n         }\n \n+        let crate_name = args.windows(2)\n+            .find(|a| &*a[0] == \"--crate-name\")\n+            .unwrap();\n+        let crate_name = &*crate_name[1];\n+\n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n         // other crate intentionally as this is the only crate for now that we\n@@ -145,9 +150,7 @@ fn main() {\n         // This... is a bit of a hack how we detect this. Ideally this\n         // information should be encoded in the crate I guess? Would likely\n         // require an RFC amendment to RFC 1513, however.\n-        let is_panic_abort = args.windows(2)\n-            .any(|a| &*a[0] == \"--crate-name\" && &*a[1] == \"panic_abort\");\n-        if is_panic_abort {\n+        if crate_name == \"panic_abort\" {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n@@ -162,7 +165,15 @@ fn main() {\n             Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n             Err(..) => \"n\",\n         };\n-        cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n+\n+        // The compiler builtins are pretty sensitive to symbols referenced in\n+        // libcore and such, so we never compile them with debug assertions.\n+        if crate_name == \"compiler_builtins\" {\n+            cmd.arg(\"-C\").arg(\"debug-assertions=no\");\n+        } else {\n+            cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n+        }\n+\n         if let Ok(s) = env::var(\"RUSTC_CODEGEN_UNITS\") {\n             cmd.arg(\"-C\").arg(format!(\"codegen-units={}\", s));\n         }"}, {"sha": "ebc4c2fdf7bf29d52ee9a65920eb721da7169bb9", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -583,7 +583,7 @@ def update_submodules(self):\n                                (self.get_toml('jemalloc') or\n                                 self.get_mk('CFG_JEMALLOC_ROOT'))))]\n         run([\"git\", \"submodule\", \"update\",\n-             \"--init\"] + submodules,\n+             \"--init\", \"--recursive\"] + submodules,\n             cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"submodule\", \"-q\", \"foreach\", \"git\",\n              \"reset\", \"-q\", \"--hard\"],"}, {"sha": "637bdbe998496f4a74298d701431b7dc98bd80bc", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -553,10 +553,10 @@ pub fn rust_src(build: &Build) {\n         \"src/libstd\",\n         \"src/libstd_unicode\",\n         \"src/libunwind\",\n+        \"src/rustc/compiler_builtins_shim\",\n         \"src/rustc/libc_shim\",\n         \"src/libtest\",\n         \"src/libterm\",\n-        \"src/compiler-rt\",\n         \"src/jemalloc\",\n         \"src/libprofiler_builtins\",\n     ];"}, {"sha": "7011261ab6c16b64ed5c0a944bf001684adfce53", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -239,7 +239,10 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str) -> Result<NativeLibBoiler\n         ),\n         _ => return Err(()),\n     };\n-    native_lib_boilerplate(\"compiler-rt\", sanitizer_name, &link_name, search_path)\n+    native_lib_boilerplate(\"libcompiler_builtins/compiler-rt\",\n+                           sanitizer_name,\n+                           &link_name,\n+                           search_path)\n }\n \n fn dir_up_to_date(src: &Path, threshold: &FileTime) -> bool {"}, {"sha": "f8e86986f82d075123dee5ba904b6f2fe773d054", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -67,13 +67,14 @@ for module in $modules; do\n         mv \"src/llvm-$commit\" src/llvm\n         continue\n     fi\n-    if [ ! -d \"$cache_src_dir/$module\" ]; then\n+    if [ ! -e \"$cache_src_dir/$module/.git\" ]; then\n         echo \"WARNING: $module not found in pristine repo\"\n-        retry sh -c \"git submodule deinit -f $module && git submodule update --init $module\"\n+        retry sh -c \"git submodule deinit -f $module && \\\n+            git submodule update --init --recursive $module\"\n         continue\n     fi\n     retry sh -c \"git submodule deinit -f $module && \\\n-        git submodule update --init --reference $cache_src_dir/$module $module\"\n+        git submodule update --init --recursive --reference $cache_src_dir/$module $module\"\n done\n \n travis_fold end update_submodules"}, {"sha": "c8a8767c56ad3d3f4eb45c87b95026936fb9aa35", "filename": "src/compiler-rt", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiler-rt?ref=1685c9298685f73db4fe890c1ed27b22408aaad7", "patch": "@@ -1 +0,0 @@\n-Subproject commit c8a8767c56ad3d3f4eb45c87b95026936fb9aa35"}, {"sha": "5da8968fd0ce22724a09ae8be37a36ab8053671c", "filename": "src/doc/unstable-book/src/library-features/compiler-builtins-lib.md", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "raw_url": "https://github.com/rust-lang/rust/raw/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fcompiler-builtins-lib.md?ref=1685c9298685f73db4fe890c1ed27b22408aaad7", "patch": "@@ -1,35 +0,0 @@\n-# `compiler_builtins_lib`\n-\n-The tracking issue for this feature is: None.\n-\n-------------------------\n-\n-This feature is required to link to the `compiler_builtins` crate which contains\n-\"compiler intrinsics\". Compiler intrinsics are software implementations of basic\n-operations like multiplication of `u64`s. These intrinsics are only required on\n-platforms where these operations don't directly map to a hardware instruction.\n-\n-You should never need to explicitly link to the `compiler_builtins` crate when\n-building \"std\" programs as `compiler_builtins` is already in the dependency\n-graph of `std`. But you may need it when building `no_std` **binary** crates. If\n-you get a *linker* error like:\n-\n-``` text\n-$PWD/src/main.rs:11: undefined reference to `__aeabi_lmul'\n-$PWD/src/main.rs:11: undefined reference to `__aeabi_uldivmod'\n-```\n-\n-That means that you need to link to this crate.\n-\n-When you link to this crate, make sure it only appears once in your crate\n-dependency graph. Also, it doesn't matter where in the dependency graph, you\n-place the `compiler_builtins` crate.\n-\n-<!-- NOTE(ignore) doctests don't support `no_std` binaries -->\n-\n-``` rust,ignore\n-#![feature(compiler_builtins_lib)]\n-#![no_std]\n-\n-extern crate compiler_builtins;\n-```"}, {"sha": "238647af806470dc73e585c03682083931d29cd5", "filename": "src/libcompiler_builtins", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -0,0 +1 @@\n+Subproject commit 238647af806470dc73e585c03682083931d29cd5"}, {"sha": "2c9cee5e7a0937cf3644a712095f375b212fa8dd", "filename": "src/libcompiler_builtins/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2FCargo.toml?ref=1685c9298685f73db4fe890c1ed27b22408aaad7", "patch": "@@ -1,19 +0,0 @@\n-[package]\n-authors = [\"The Rust Project Developers\"]\n-build = \"build.rs\"\n-name = \"compiler_builtins\"\n-version = \"0.0.0\"\n-\n-[lib]\n-name = \"compiler_builtins\"\n-path = \"lib.rs\"\n-test = false\n-bench = false\n-doc = false\n-\n-[dependencies]\n-core = { path = \"../libcore\" }\n-\n-[build-dependencies]\n-build_helper = { path = \"../build_helper\" }\n-gcc = \"0.3.50\""}, {"sha": "8fe79057bd81738bdca8054bcdf6331fc78f052a", "filename": "src/libcompiler_builtins/build.rs", "status": "removed", "additions": 0, "deletions": 423, "changes": 423, "blob_url": "https://github.com/rust-lang/rust/blob/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Fbuild.rs?ref=1685c9298685f73db4fe890c1ed27b22408aaad7", "patch": "@@ -1,423 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Compiles the `compiler-rt` library, or at least the builtins part of it.\n-//!\n-//! Note that while compiler-rt has a build system associated with it, we\n-//! specifically don't use it here. The compiler-rt build system, written in\n-//! CMake, is actually *very* difficult to work with in terms of getting it to\n-//! compile on all the relevant platforms we want it to compile on. In the end\n-//! it became so much pain to work with local patches, work around the oddities\n-//! of the build system, etc, that we're just building everything by hand now.\n-//!\n-//! In general compiler-rt is just a bunch of intrinsics that are in practice\n-//! *very* stable. We just need to make sure that all the relevant functions and\n-//! such are compiled somewhere and placed in an object file somewhere.\n-//! Eventually, these should all be written in Rust!\n-//!\n-//! So below you'll find a listing of every single file in the compiler-rt repo\n-//! that we're compiling. We just reach in and compile with the `gcc` crate\n-//! which should have all the relevant flags and such already configured.\n-//!\n-//! The risk here is that if we update compiler-rt we may need to compile some\n-//! new intrinsics, but to be honest we surely don't use all of the intrinsics\n-//! listed below today so the likelihood of us actually needing a new intrinsic\n-//! is quite low. The failure case is also just that someone reports a link\n-//! error (if any) and then we just add it to the list. Overall, that cost is\n-//! far far less than working with compiler-rt's build system over time.\n-\n-extern crate build_helper;\n-extern crate gcc;\n-\n-use std::collections::BTreeMap;\n-use std::env;\n-use std::path::Path;\n-use build_helper::native_lib_boilerplate;\n-\n-struct Sources {\n-    // SYMBOL -> PATH TO SOURCE\n-    map: BTreeMap<&'static str, &'static str>,\n-}\n-\n-impl Sources {\n-    fn new() -> Sources {\n-        Sources { map: BTreeMap::new() }\n-    }\n-\n-    fn extend(&mut self, sources: &[&'static str]) {\n-        // NOTE Some intrinsics have both a generic implementation (e.g.\n-        // `floatdidf.c`) and an arch optimized implementation\n-        // (`x86_64/floatdidf.c`). In those cases, we keep the arch optimized\n-        // implementation and discard the generic implementation. If we don't\n-        // and keep both implementations, the linker will yell at us about\n-        // duplicate symbols!\n-        for &src in sources {\n-            let symbol = Path::new(src).file_stem().unwrap().to_str().unwrap();\n-            if src.contains(\"/\") {\n-                // Arch-optimized implementation (preferred)\n-                self.map.insert(symbol, src);\n-            } else {\n-                // Generic implementation\n-                if !self.map.contains_key(symbol) {\n-                    self.map.insert(symbol, src);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn main() {\n-    let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n-\n-    // Emscripten's runtime includes all the builtins\n-    if target.contains(\"emscripten\") {\n-        return;\n-    }\n-\n-    // Can't reuse `sources` list for the freshness check becuse it doesn't contain header files.\n-    let native = match native_lib_boilerplate(\"compiler-rt\", \"compiler-rt\", \"compiler-rt\", \".\") {\n-        Ok(native) => native,\n-        _ => return,\n-    };\n-\n-    let cfg = &mut gcc::Config::new();\n-    cfg.out_dir(&native.out_dir);\n-\n-    if target.contains(\"msvc\") {\n-        // Don't pull in extra libraries on MSVC\n-        cfg.flag(\"/Zl\");\n-\n-        // Emulate C99 and C++11's __func__ for MSVC prior to 2013 CTP\n-        cfg.define(\"__func__\", Some(\"__FUNCTION__\"));\n-    } else {\n-        // Turn off various features of gcc and such, mostly copying\n-        // compiler-rt's build system already\n-        cfg.flag(\"-fno-builtin\");\n-        cfg.flag(\"-fvisibility=hidden\");\n-        // Accepted practice on Solaris is to never omit frame pointer so that\n-        // system observability tools work as expected.  In addition, at least\n-        // on Solaris, -fomit-frame-pointer on sparcv9 appears to generate\n-        // references to data outside of the current stack frame.  A search of\n-        // the gcc bug database provides a variety of issues surrounding\n-        // -fomit-frame-pointer on non-x86 platforms.\n-        if !target.contains(\"solaris\") && !target.contains(\"sparc\") {\n-            cfg.flag(\"-fomit-frame-pointer\");\n-        }\n-        cfg.flag(\"-ffreestanding\");\n-        cfg.define(\"VISIBILITY_HIDDEN\", None);\n-    }\n-\n-    let mut sources = Sources::new();\n-    sources.extend(&[\"absvdi2.c\",\n-                     \"absvsi2.c\",\n-                     \"adddf3.c\",\n-                     \"addsf3.c\",\n-                     \"addvdi3.c\",\n-                     \"addvsi3.c\",\n-                     \"apple_versioning.c\",\n-                     \"ashldi3.c\",\n-                     \"ashrdi3.c\",\n-                     \"clzdi2.c\",\n-                     \"clzsi2.c\",\n-                     \"cmpdi2.c\",\n-                     \"comparedf2.c\",\n-                     \"comparesf2.c\",\n-                     \"ctzdi2.c\",\n-                     \"ctzsi2.c\",\n-                     \"divdc3.c\",\n-                     \"divdf3.c\",\n-                     \"divdi3.c\",\n-                     \"divmoddi4.c\",\n-                     \"divmodsi4.c\",\n-                     \"divsc3.c\",\n-                     \"divsf3.c\",\n-                     \"divsi3.c\",\n-                     \"divxc3.c\",\n-                     \"extendsfdf2.c\",\n-                     \"extendhfsf2.c\",\n-                     \"ffsdi2.c\",\n-                     \"fixdfdi.c\",\n-                     \"fixdfsi.c\",\n-                     \"fixsfdi.c\",\n-                     \"fixsfsi.c\",\n-                     \"fixunsdfdi.c\",\n-                     \"fixunsdfsi.c\",\n-                     \"fixunssfdi.c\",\n-                     \"fixunssfsi.c\",\n-                     \"fixunsxfdi.c\",\n-                     \"fixunsxfsi.c\",\n-                     \"fixxfdi.c\",\n-                     \"floatdidf.c\",\n-                     \"floatdisf.c\",\n-                     \"floatdixf.c\",\n-                     \"floatsidf.c\",\n-                     \"floatsisf.c\",\n-                     \"floatundidf.c\",\n-                     \"floatundisf.c\",\n-                     \"floatundixf.c\",\n-                     \"floatunsidf.c\",\n-                     \"floatunsisf.c\",\n-                     \"int_util.c\",\n-                     \"lshrdi3.c\",\n-                     \"moddi3.c\",\n-                     \"modsi3.c\",\n-                     \"muldc3.c\",\n-                     \"muldf3.c\",\n-                     \"muldi3.c\",\n-                     \"mulodi4.c\",\n-                     \"mulosi4.c\",\n-                     \"muloti4.c\",\n-                     \"mulsc3.c\",\n-                     \"mulsf3.c\",\n-                     \"mulvdi3.c\",\n-                     \"mulvsi3.c\",\n-                     \"mulxc3.c\",\n-                     \"negdf2.c\",\n-                     \"negdi2.c\",\n-                     \"negsf2.c\",\n-                     \"negvdi2.c\",\n-                     \"negvsi2.c\",\n-                     \"paritydi2.c\",\n-                     \"paritysi2.c\",\n-                     \"popcountdi2.c\",\n-                     \"popcountsi2.c\",\n-                     \"powidf2.c\",\n-                     \"powisf2.c\",\n-                     \"powixf2.c\",\n-                     \"subdf3.c\",\n-                     \"subsf3.c\",\n-                     \"subvdi3.c\",\n-                     \"subvsi3.c\",\n-                     \"truncdfhf2.c\",\n-                     \"truncdfsf2.c\",\n-                     \"truncsfhf2.c\",\n-                     \"ucmpdi2.c\",\n-                     \"udivdi3.c\",\n-                     \"udivmoddi4.c\",\n-                     \"udivmodsi4.c\",\n-                     \"udivsi3.c\",\n-                     \"umoddi3.c\",\n-                     \"umodsi3.c\"]);\n-\n-    if !target.contains(\"ios\") {\n-        sources.extend(&[\"absvti2.c\",\n-                         \"addvti3.c\",\n-                         \"ashlti3.c\",\n-                         \"ashrti3.c\",\n-                         \"clzti2.c\",\n-                         \"cmpti2.c\",\n-                         \"ctzti2.c\",\n-                         \"divti3.c\",\n-                         \"ffsti2.c\",\n-                         \"fixdfti.c\",\n-                         \"fixsfti.c\",\n-                         \"fixunsdfti.c\",\n-                         \"fixunssfti.c\",\n-                         \"fixunsxfti.c\",\n-                         \"fixxfti.c\",\n-                         \"floattidf.c\",\n-                         \"floattisf.c\",\n-                         \"floattixf.c\",\n-                         \"floatuntidf.c\",\n-                         \"floatuntisf.c\",\n-                         \"floatuntixf.c\",\n-                         \"lshrti3.c\",\n-                         \"modti3.c\",\n-                         \"multi3.c\",\n-                         \"mulvti3.c\",\n-                         \"negti2.c\",\n-                         \"negvti2.c\",\n-                         \"parityti2.c\",\n-                         \"popcountti2.c\",\n-                         \"subvti3.c\",\n-                         \"ucmpti2.c\",\n-                         \"udivmodti4.c\",\n-                         \"udivti3.c\",\n-                         \"umodti3.c\"]);\n-    }\n-\n-    if target.contains(\"apple\") {\n-        sources.extend(&[\"atomic_flag_clear.c\",\n-                         \"atomic_flag_clear_explicit.c\",\n-                         \"atomic_flag_test_and_set.c\",\n-                         \"atomic_flag_test_and_set_explicit.c\",\n-                         \"atomic_signal_fence.c\",\n-                         \"atomic_thread_fence.c\"]);\n-    }\n-\n-    if target.contains(\"msvc\") {\n-        if target.contains(\"x86_64\") {\n-            sources.extend(&[\"x86_64/floatdidf.c\", \"x86_64/floatdisf.c\", \"x86_64/floatdixf.c\"]);\n-        }\n-    } else {\n-        if !target.contains(\"freebsd\") && !target.contains(\"netbsd\") {\n-            sources.extend(&[\"gcc_personality_v0.c\"]);\n-        }\n-\n-        if target.contains(\"x86_64\") {\n-            sources.extend(&[\"x86_64/chkstk.S\",\n-                             \"x86_64/chkstk2.S\",\n-                             \"x86_64/floatdidf.c\",\n-                             \"x86_64/floatdisf.c\",\n-                             \"x86_64/floatdixf.c\",\n-                             \"x86_64/floatundidf.S\",\n-                             \"x86_64/floatundisf.S\",\n-                             \"x86_64/floatundixf.S\"]);\n-        }\n-\n-        if target.contains(\"i386\") || target.contains(\"i586\") || target.contains(\"i686\") {\n-            sources.extend(&[\"i386/ashldi3.S\",\n-                             \"i386/ashrdi3.S\",\n-                             \"i386/chkstk.S\",\n-                             \"i386/chkstk2.S\",\n-                             \"i386/divdi3.S\",\n-                             \"i386/floatdidf.S\",\n-                             \"i386/floatdisf.S\",\n-                             \"i386/floatdixf.S\",\n-                             \"i386/floatundidf.S\",\n-                             \"i386/floatundisf.S\",\n-                             \"i386/floatundixf.S\",\n-                             \"i386/lshrdi3.S\",\n-                             \"i386/moddi3.S\",\n-                             \"i386/muldi3.S\",\n-                             \"i386/udivdi3.S\",\n-                             \"i386/umoddi3.S\"]);\n-        }\n-    }\n-\n-    if target.contains(\"arm\") && !target.contains(\"ios\") {\n-        // (At least) udivsi3.S is broken for Thumb 1 which our gcc uses by\n-        // default, we don't want Thumb 2 since it isn't supported on some\n-        // devices, so disable thumb entirely.\n-        // Upstream bug: https://bugs.llvm.org/show_bug.cgi?id=32492\n-        cfg.define(\"__ARM_ARCH_ISA_THUMB\", Some(\"0\"));\n-\n-        sources.extend(&[\"arm/aeabi_cdcmp.S\",\n-                         \"arm/aeabi_cdcmpeq_check_nan.c\",\n-                         \"arm/aeabi_cfcmp.S\",\n-                         \"arm/aeabi_cfcmpeq_check_nan.c\",\n-                         \"arm/aeabi_dcmp.S\",\n-                         \"arm/aeabi_div0.c\",\n-                         \"arm/aeabi_drsub.c\",\n-                         \"arm/aeabi_fcmp.S\",\n-                         \"arm/aeabi_frsub.c\",\n-                         \"arm/aeabi_idivmod.S\",\n-                         \"arm/aeabi_ldivmod.S\",\n-                         \"arm/aeabi_memcmp.S\",\n-                         \"arm/aeabi_memcpy.S\",\n-                         \"arm/aeabi_memmove.S\",\n-                         \"arm/aeabi_memset.S\",\n-                         \"arm/aeabi_uidivmod.S\",\n-                         \"arm/aeabi_uldivmod.S\",\n-                         \"arm/bswapdi2.S\",\n-                         \"arm/bswapsi2.S\",\n-                         \"arm/clzdi2.S\",\n-                         \"arm/clzsi2.S\",\n-                         \"arm/comparesf2.S\",\n-                         \"arm/divmodsi4.S\",\n-                         \"arm/divsi3.S\",\n-                         \"arm/modsi3.S\",\n-                         \"arm/switch16.S\",\n-                         \"arm/switch32.S\",\n-                         \"arm/switch8.S\",\n-                         \"arm/switchu8.S\",\n-                         \"arm/sync_synchronize.S\",\n-                         \"arm/udivmodsi4.S\",\n-                         \"arm/udivsi3.S\",\n-                         \"arm/umodsi3.S\"]);\n-    }\n-\n-    if target.contains(\"armv7\") {\n-        sources.extend(&[\"arm/sync_fetch_and_add_4.S\",\n-                         \"arm/sync_fetch_and_add_8.S\",\n-                         \"arm/sync_fetch_and_and_4.S\",\n-                         \"arm/sync_fetch_and_and_8.S\",\n-                         \"arm/sync_fetch_and_max_4.S\",\n-                         \"arm/sync_fetch_and_max_8.S\",\n-                         \"arm/sync_fetch_and_min_4.S\",\n-                         \"arm/sync_fetch_and_min_8.S\",\n-                         \"arm/sync_fetch_and_nand_4.S\",\n-                         \"arm/sync_fetch_and_nand_8.S\",\n-                         \"arm/sync_fetch_and_or_4.S\",\n-                         \"arm/sync_fetch_and_or_8.S\",\n-                         \"arm/sync_fetch_and_sub_4.S\",\n-                         \"arm/sync_fetch_and_sub_8.S\",\n-                         \"arm/sync_fetch_and_umax_4.S\",\n-                         \"arm/sync_fetch_and_umax_8.S\",\n-                         \"arm/sync_fetch_and_umin_4.S\",\n-                         \"arm/sync_fetch_and_umin_8.S\",\n-                         \"arm/sync_fetch_and_xor_4.S\",\n-                         \"arm/sync_fetch_and_xor_8.S\"]);\n-    }\n-\n-    if target.contains(\"eabihf\") {\n-        sources.extend(&[\"arm/adddf3vfp.S\",\n-                         \"arm/addsf3vfp.S\",\n-                         \"arm/divdf3vfp.S\",\n-                         \"arm/divsf3vfp.S\",\n-                         \"arm/eqdf2vfp.S\",\n-                         \"arm/eqsf2vfp.S\",\n-                         \"arm/extendsfdf2vfp.S\",\n-                         \"arm/fixdfsivfp.S\",\n-                         \"arm/fixsfsivfp.S\",\n-                         \"arm/fixunsdfsivfp.S\",\n-                         \"arm/fixunssfsivfp.S\",\n-                         \"arm/floatsidfvfp.S\",\n-                         \"arm/floatsisfvfp.S\",\n-                         \"arm/floatunssidfvfp.S\",\n-                         \"arm/floatunssisfvfp.S\",\n-                         \"arm/gedf2vfp.S\",\n-                         \"arm/gesf2vfp.S\",\n-                         \"arm/gtdf2vfp.S\",\n-                         \"arm/gtsf2vfp.S\",\n-                         \"arm/ledf2vfp.S\",\n-                         \"arm/lesf2vfp.S\",\n-                         \"arm/ltdf2vfp.S\",\n-                         \"arm/ltsf2vfp.S\",\n-                         \"arm/muldf3vfp.S\",\n-                         \"arm/mulsf3vfp.S\",\n-                         \"arm/negdf2vfp.S\",\n-                         \"arm/negsf2vfp.S\",\n-                         \"arm/nedf2vfp.S\",\n-                         \"arm/nesf2vfp.S\",\n-                         \"arm/restore_vfp_d8_d15_regs.S\",\n-                         \"arm/save_vfp_d8_d15_regs.S\",\n-                         \"arm/subdf3vfp.S\",\n-                         \"arm/subsf3vfp.S\",\n-                         \"arm/truncdfsf2vfp.S\",\n-                         \"arm/unorddf2vfp.S\",\n-                         \"arm/unordsf2vfp.S\"]);\n-    }\n-\n-    if target.contains(\"aarch64\") {\n-        sources.extend(&[\"comparetf2.c\",\n-                         \"extenddftf2.c\",\n-                         \"extendsftf2.c\",\n-                         \"fixtfdi.c\",\n-                         \"fixtfsi.c\",\n-                         \"fixtfti.c\",\n-                         \"fixunstfdi.c\",\n-                         \"fixunstfsi.c\",\n-                         \"fixunstfti.c\",\n-                         \"floatditf.c\",\n-                         \"floatsitf.c\",\n-                         \"floatunditf.c\",\n-                         \"floatunsitf.c\",\n-                         \"multc3.c\",\n-                         \"trunctfdf2.c\",\n-                         \"trunctfsf2.c\"]);\n-    }\n-\n-    for src in sources.map.values() {\n-        cfg.file(Path::new(\"../compiler-rt/lib/builtins\").join(src));\n-    }\n-\n-    cfg.compile(\"libcompiler-rt.a\");\n-}"}, {"sha": "09b3d63950705001ed439d06d5c7a85d73d2ff75", "filename": "src/libcompiler_builtins/lib.rs", "status": "removed", "additions": 0, "deletions": 721, "changes": 721, "blob_url": "https://github.com/rust-lang/rust/blob/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1685c9298685f73db4fe890c1ed27b22408aaad7/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=1685c9298685f73db4fe890c1ed27b22408aaad7", "patch": "@@ -1,721 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(compiler_builtins)]\n-#![no_std]\n-#![compiler_builtins]\n-#![unstable(feature = \"compiler_builtins_lib\",\n-            reason = \"internal implementation detail of rustc right now\",\n-            issue = \"0\")]\n-#![crate_name = \"compiler_builtins\"]\n-#![crate_type = \"rlib\"]\n-#![allow(unused_features)]\n-#![feature(staged_api, core_intrinsics, repr_simd,\n-           i128_type, core_float, abi_unadjusted, associated_consts)]\n-#![allow(non_camel_case_types, unused_variables, unused_imports)]\n-\n-#[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n-          target_arch=\"mips64\"))]\n-pub mod reimpls {\n-\n-    #![allow(unused_comparisons)]\n-\n-    use core::intrinsics::unchecked_div;\n-    use core::intrinsics::unchecked_rem;\n-    use core::ptr;\n-\n-    macro_rules! ashl {\n-        ($a:expr, $b:expr, $ty:ty) => {{\n-            let (a, b) = ($a, $b);\n-            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n-            let half_bits = bits.wrapping_shr(1);\n-            if b & half_bits != 0 {\n-                <$ty>::from_parts(0, a.low().wrapping_shl(\n-                                        b.wrapping_sub(half_bits) as u32))\n-            } else if b == 0 {\n-                a\n-            } else {\n-                <$ty>::from_parts(a.low().wrapping_shl(b as u32),\n-                                  a.high().wrapping_shl(b as u32)\n-                                  | a.low()\n-                                     .wrapping_shr(half_bits.wrapping_sub(b) as u32))\n-            }\n-        }}\n-    }\n-\n-    #[export_name=\"__ashlti3\"]\n-    pub extern \"C\" fn shl(a: u128, b: u128) -> u128 {\n-        ashl!(a, b, u128)\n-    }\n-\n-    macro_rules! ashr {\n-        ($a: expr, $b: expr, $ty:ty) => {{\n-            let (a, b) = ($a, $b);\n-            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n-            let half_bits = bits.wrapping_shr(1);\n-            if b & half_bits != 0 {\n-                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n-                                  as <$ty as LargeInt>::LowHalf,\n-                                  a.high().wrapping_shr(half_bits.wrapping_sub(1) as u32))\n-            } else if b == 0 {\n-                a\n-            } else {\n-                let high_unsigned = a.high() as <$ty as LargeInt>::LowHalf;\n-                <$ty>::from_parts(high_unsigned.wrapping_shl(half_bits.wrapping_sub(b) as u32)\n-                                  | a.low().wrapping_shr(b as u32),\n-                                  a.high().wrapping_shr(b as u32))\n-            }\n-        }}\n-    }\n-\n-    #[export_name=\"__ashrti3\"]\n-    pub extern \"C\" fn shr(a: i128, b: i128) -> i128 {\n-        ashr!(a, b, i128)\n-    }\n-\n-    macro_rules! lshr {\n-        ($a: expr, $b: expr, $ty:ty) => {{\n-            let (a, b) = ($a, $b);\n-            let bits = ::core::mem::size_of::<$ty>().wrapping_mul(8) as $ty;\n-            let half_bits = bits.wrapping_shr(1);\n-            if b & half_bits != 0 {\n-                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n-            } else if b == 0 {\n-                a\n-            } else {\n-                <$ty>::from_parts(a.high().wrapping_shl(half_bits.wrapping_sub(b) as u32)\n-                                  | a.low().wrapping_shr(b as u32),\n-                                  a.high().wrapping_shr(b as u32))\n-            }\n-        }}\n-    }\n-\n-\n-    #[export_name=\"__lshrti3\"]\n-    pub extern \"C\" fn lshr(a: u128, b: u128) -> u128 {\n-        lshr!(a, b, u128)\n-    }\n-\n-    pub extern \"C\" fn u128_div_mod(n: u128, d: u128, rem: *mut u128) -> u128 {\n-        // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n-        unsafe {\n-        // special cases, X is unknown, K != 0\n-        if n.high() == 0 {\n-            if d.high() == 0 {\n-                // 0 X\n-                // ---\n-                // 0 X\n-                if !rem.is_null() {\n-                    *rem = u128::from(unchecked_rem(n.low(), d.low()));\n-                }\n-                return u128::from(unchecked_div(n.low(), d.low()));\n-            } else {\n-                // 0 X\n-                // ---\n-                // K X\n-                if !rem.is_null() {\n-                    *rem = n;\n-                }\n-                return 0;\n-            };\n-        }\n-\n-        let mut sr;\n-        let mut q;\n-        let mut r;\n-\n-        if d.low() == 0 {\n-            if d.high() == 0 {\n-                // K X\n-                // ---\n-                // 0 0\n-                if !rem.is_null() {\n-                    *rem = u128::from(unchecked_rem(n.high(), d.low()));\n-                }\n-                return u128::from(unchecked_div(n.high(), d.low()));\n-            }\n-\n-            if n.low() == 0 {\n-                // K 0\n-                // ---\n-                // K 0\n-                if !rem.is_null() {\n-                    *rem = u128::from_parts(0, unchecked_rem(n.high(), d.high()));\n-                }\n-                return u128::from(unchecked_div(n.high(), d.high()));\n-            }\n-\n-            // K K\n-            // ---\n-            // K 0\n-\n-            if d.high().is_power_of_two() {\n-                if !rem.is_null() {\n-                    *rem = u128::from_parts(n.low(),\n-                                            n.high() & (d.high().wrapping_sub(1)));\n-                }\n-                return u128::from(n.high().wrapping_shr(d.high().trailing_zeros()));\n-            }\n-\n-            // K K\n-            // ---\n-            // K 0\n-            sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n-\n-            // D > N\n-            if sr > 64 - 2 {\n-                if !rem.is_null() {\n-                    *rem = n;\n-                }\n-                return 0;\n-            }\n-\n-            sr = sr.wrapping_add(1);\n-\n-            // 1 <= sr <= u64::bits() - 1\n-            q = n.wrapping_shl(128u32.wrapping_sub(sr));\n-            r = n.wrapping_shr(sr);\n-        } else {\n-            if d.high() == 0 {\n-                // K X\n-                // ---\n-                // 0 K\n-                if d.low().is_power_of_two() {\n-                    if !rem.is_null() {\n-                        *rem = u128::from(n.low() & (d.low().wrapping_sub(1)));\n-                    }\n-\n-                    if d.low() == 1 {\n-                        return n;\n-                    } else {\n-                        let sr = d.low().trailing_zeros();\n-                        return n.wrapping_shr(sr);\n-                    };\n-                }\n-\n-                sr = (1 + 64u32)\n-                    .wrapping_add(d.low().leading_zeros())\n-                    .wrapping_sub(n.high().leading_zeros());\n-\n-                // 2 <= sr <= u64::bits() - 1\n-                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n-                r = n.wrapping_shr(sr);\n-                // FIXME the C compiler-rt implementation has something here\n-                // that looks like a speed optimisation.\n-                // It would be worth a try to port it to Rust too and\n-                // compare the speed.\n-            } else {\n-                // K X\n-                // ---\n-                // K K\n-                sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n-\n-                // D > N\n-                if sr > 64 - 1 {\n-                    if !rem.is_null() {\n-                        *rem = n;\n-                    }\n-                    return 0;\n-                }\n-\n-                sr = sr.wrapping_add(1);\n-\n-                // 1 <= sr <= u32::bits()\n-                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n-                r = n.wrapping_shr(sr);\n-            }\n-        }\n-\n-        // Not a special case\n-        // q and r are initialized with\n-        // q = n << (u64::bits() - sr)\n-        // r = n >> sr\n-        // 1 <= sr <= u64::bits() - 1\n-        let mut carry = 0;\n-\n-        // FIXME: replace this with a for loop\n-        // (atm not doable as this generates call to\n-        // eh_personality when optimisations are turned off,\n-        // which in turn gives a linker error in later\n-        // compilation steps)\n-        while sr > 0 {\n-            // r:q = ((r:q) << 1) | carry\n-            r = r.wrapping_shl(1) | q.wrapping_shr(128 - 1);\n-            q = q.wrapping_shl(1) | carry as u128;\n-\n-            // carry = 0\n-            // if r >= d {\n-            //     r -= d;\n-            //     carry = 1;\n-            // }\n-            let s = ((d.wrapping_sub(r).wrapping_sub(1)) as i128).wrapping_shr(128 - 1);\n-            carry = (s & 1) as u64;\n-            r = r.wrapping_sub(d & s as u128);\n-            sr = sr.wrapping_sub(1);\n-        }\n-\n-        if !rem.is_null() {\n-            *rem = r;\n-        }\n-        (q.wrapping_shl(1)) | carry as u128\n-        }\n-    }\n-\n-    fn i128_mod(a: i128, b: i128) -> i128 {\n-        let b = b.uabs();\n-        let sa = a.signum();\n-        let a = a.uabs();\n-        unsafe {\n-            let mut r = ::core::mem::zeroed();\n-            u128_div_mod(a, b, &mut r);\n-            if sa == -1 { (r as i128).unchecked_neg() } else { r as i128 }\n-        }\n-    }\n-\n-    fn i128_div(a: i128, b: i128) -> i128 {\n-        let sa = a.signum();\n-        let sb = b.signum();\n-        let a = a.uabs();\n-        let b = b.uabs();\n-        let sr = sa.wrapping_mul(sb); // sign of quotient\n-        (if sr == -1 {\n-            (u128_div_mod(a, b, ptr::null_mut()) as i128).unchecked_neg()\n-        } else {\n-            u128_div_mod(a, b, ptr::null_mut()) as i128\n-        })\n-    }\n-\n-    macro_rules! mulo {\n-        ($a:expr, $b:expr, $o: expr, $ty: ty) => {{\n-            let (a, b, overflow) = ($a, $b, $o);\n-            *overflow = 0;\n-            let result = a.wrapping_mul(b);\n-            if a == <$ty>::min_value() {\n-                if b != 0 && b != 1 {\n-                    *overflow = 1;\n-                }\n-                return result;\n-            }\n-            if b == <$ty>::min_value() {\n-                if a != 0 && a != 1 {\n-                    *overflow = 1;\n-                }\n-                return result;\n-            }\n-\n-            let sa = a.signum();\n-            let abs_a = a.iabs();\n-            let sb = b.signum();\n-            let abs_b = b.iabs();\n-            if abs_a < 2 || abs_b < 2 {\n-                return result;\n-            }\n-            if sa == sb {\n-                if abs_a > unchecked_div(<$ty>::max_value(), abs_b) {\n-                    *overflow = 1;\n-                }\n-            } else {\n-                if abs_a > unchecked_div(<$ty>::min_value(), abs_b.unchecked_neg()) {\n-                    *overflow = 1;\n-                }\n-            }\n-            result\n-        }}\n-    }\n-\n-    pub trait LargeInt {\n-        type LowHalf;\n-        type HighHalf;\n-\n-        fn low(self) -> Self::LowHalf;\n-        fn high(self) -> Self::HighHalf;\n-        fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n-    }\n-    impl LargeInt for u128 {\n-        type LowHalf = u64;\n-        type HighHalf = u64;\n-\n-        fn low(self) -> u64 {\n-            self as u64\n-        }\n-        fn high(self) -> u64 {\n-            self.wrapping_shr(64) as u64\n-        }\n-        fn from_parts(low: u64, high: u64) -> u128 {\n-            (high as u128).wrapping_shl(64) | low as u128\n-        }\n-    }\n-    impl LargeInt for i128 {\n-        type LowHalf = u64;\n-        type HighHalf = i64;\n-\n-        fn low(self) -> u64 {\n-            self as u64\n-        }\n-        fn high(self) -> i64 {\n-            self.wrapping_shr(64) as i64\n-        }\n-        fn from_parts(low: u64, high: i64) -> i128 {\n-            u128::from_parts(low, high as u64) as i128\n-        }\n-    }\n-\n-    macro_rules! mul {\n-        ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n-            let (a, b) = ($a, $b);\n-            let half_bits = ::core::mem::size_of::<$tyh>().wrapping_mul(4) as u32;\n-            let lower_mask = (!0u64).wrapping_shr(half_bits);\n-            let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n-            let mut t = low.wrapping_shr(half_bits);\n-            low &= lower_mask;\n-            t = t.wrapping_add(a.low().wrapping_shr(half_bits)\n-                                      .wrapping_mul(b.low() & lower_mask));\n-            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n-            let mut high = t.wrapping_shr(half_bits) as $tyh;\n-            t = low.wrapping_shr(half_bits);\n-            low &= lower_mask;\n-            t = t.wrapping_add(b.low().wrapping_shr(half_bits)\n-                                      .wrapping_mul(a.low() & lower_mask));\n-            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n-            high = high.wrapping_add(t.wrapping_shr(half_bits) as $tyh);\n-            high = high.wrapping_add(a.low().wrapping_shr(half_bits)\n-                           .wrapping_mul(b.low().wrapping_shr(half_bits)) as $tyh);\n-            high = high\n-                .wrapping_add(a.high()\n-                .wrapping_mul(b.low() as $tyh))\n-                .wrapping_add((a.low() as $tyh)\n-                .wrapping_mul(b.high()));\n-            <$ty>::from_parts(low, high)\n-        }}\n-    }\n-\n-    #[export_name=\"__multi3\"]\n-    pub extern \"C\" fn u128_mul(a: i128, b: i128) -> i128 {\n-        mul!(a, b, i128, i64)\n-    }\n-\n-    trait AbsExt: Sized {\n-        fn uabs(self) -> u128;\n-        fn iabs(self) -> i128;\n-    }\n-\n-    impl AbsExt for i128 {\n-        fn uabs(self) -> u128 {\n-            self.iabs() as u128\n-        }\n-        fn iabs(self) -> i128 {\n-            let s = self.wrapping_shr(127);\n-            ((self ^ s).wrapping_sub(s))\n-        }\n-    }\n-\n-    trait NegExt: Sized {\n-        fn unchecked_neg(self) -> i128;\n-    }\n-\n-    impl NegExt for i128 {\n-        fn unchecked_neg(self) -> i128 {\n-            (!self).wrapping_add(1)\n-        }\n-    }\n-\n-    trait FloatStuff: Sized {\n-        type ToBytes;\n-\n-        const MANTISSA_BITS: u32;\n-        const MAX_EXP: i32;\n-        const EXP_MASK: Self::ToBytes;\n-        const MANTISSA_MASK: Self::ToBytes;\n-        const MANTISSA_LEAD_BIT: Self::ToBytes;\n-\n-        fn to_bytes(self) -> Self::ToBytes;\n-        fn get_exponent(self) -> i32;\n-    }\n-\n-    impl FloatStuff for f32 {\n-        type ToBytes = u32;\n-        const MANTISSA_BITS: u32 = 23;\n-        const MAX_EXP: i32 = 127;\n-        const EXP_MASK: u32 = 0x7F80_0000;\n-        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n-        const MANTISSA_LEAD_BIT: u32 = 0x0080_0000;\n-\n-        fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n-        fn get_exponent(self) -> i32 {\n-            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n-            .wrapping_sub(Self::MAX_EXP)\n-        }\n-    }\n-\n-    impl FloatStuff for f64 {\n-        type ToBytes = u64;\n-        const MANTISSA_BITS: u32 = 52;\n-        const MAX_EXP: i32 = 1023;\n-        const EXP_MASK: u64 = 0x7FF0_0000_0000_0000;\n-        const MANTISSA_MASK: u64 = 0x000F_FFFF_FFFF_FFFF;\n-        const MANTISSA_LEAD_BIT: u64 = 0x0010_0000_0000_0000;\n-\n-        fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n-        fn get_exponent(self) -> i32 {\n-            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n-            .wrapping_sub(Self::MAX_EXP)\n-        }\n-    }\n-\n-    macro_rules! float_as_unsigned {\n-        ($from: expr, $fromty: ty, $outty: ty) => { {\n-            use core::num::Float;\n-            let repr = $from.to_bytes();\n-            let sign = $from.signum();\n-            let exponent = $from.get_exponent();\n-            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n-            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n-            if sign == -1.0 || exponent < 0 { return 0 as u128; }\n-            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n-                return !(0 as u128);\n-            }\n-            (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n-                (mantissa as $outty)\n-                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n-                                  .wrapping_sub(exponent) as u32)\n-            } else {\n-                (mantissa as $outty)\n-                    .wrapping_shl(exponent.wrapping_sub(\n-                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n-            })\n-        } }\n-    }\n-\n-    macro_rules! float_as_signed {\n-        ($from: expr, $fromty: ty, $outty: ty) => {{\n-            use core::num::Float;\n-            let repr = $from.to_bytes();\n-            let sign = $from.signum();\n-            let exponent = $from.get_exponent();\n-            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n-            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n-\n-            if exponent < 0 { return 0 as i128; }\n-            if exponent > ::core::mem::size_of::<$outty>().wrapping_mul(8) as i32 {\n-                let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n-                return ret\n-            }\n-            let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n-                (mantissa as $outty)\n-                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n-                                  .wrapping_sub(exponent) as u32)\n-            } else {\n-                (mantissa as $outty)\n-                    .wrapping_shl(exponent.wrapping_sub(\n-                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n-            };\n-            (if sign >= 0.0 { r } else { r.unchecked_neg() })\n-        }}\n-    }\n-\n-\n-    fn i128_as_f64(a: i128) -> f64 {\n-        match a.signum() {\n-            1 => u128_as_f64(a.uabs()),\n-            0 => 0.0,\n-            _ => -u128_as_f64(a.uabs()),\n-        }\n-    }\n-\n-    fn i128_as_f32(a: i128) -> f32 {\n-        match a.signum() {\n-            1 => u128_as_f32(a.uabs()),\n-            0 => 0.0,\n-            _ => -u128_as_f32(a.uabs()),\n-        }\n-    }\n-\n-    fn u128_as_f64(mut a: u128) -> f64 {\n-        use ::core::f64::MANTISSA_DIGITS;\n-        if a == 0 { return 0.0; }\n-        let sd = 128u32.wrapping_sub(a.leading_zeros());\n-        let mut e = sd.wrapping_sub(1);\n-        const MD1 : u32 = MANTISSA_DIGITS + 1;\n-        const MD2 : u32 = MANTISSA_DIGITS + 2;\n-\n-        let negn = !0u128;\n-\n-        if sd > MANTISSA_DIGITS {\n-            a = match sd {\n-                MD1 => a.wrapping_shl(1),\n-                MD2 => a,\n-                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n-                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n-                                   .wrapping_sub(sd as u128))) == 0 { 0 } else { 1 })\n-            };\n-            a |= if (a & 4) == 0 { 0 } else { 1 };\n-            a = a.wrapping_add(1);\n-            a = a.wrapping_shr(2);\n-            if a & (1 << MANTISSA_DIGITS) != 0 {\n-                a = a.wrapping_shr(1);\n-                e = e.wrapping_add(1);\n-            }\n-        } else {\n-            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n-        }\n-        unsafe {\n-            ::core::mem::transmute((e as u64).wrapping_add(1023).wrapping_shl(52)\n-                                   | (a as u64 & 0x000f_ffff_ffff_ffff))\n-        }\n-    }\n-\n-    fn u128_as_f32(mut a: u128) -> f32 {\n-        use ::core::f32::MANTISSA_DIGITS;\n-        if a == 0 { return 0.0; }\n-        let sd = 128u32.wrapping_sub(a.leading_zeros());\n-        let mut e = sd.wrapping_sub(1);\n-        const MD1 : u32 = MANTISSA_DIGITS + 1;\n-        const MD2 : u32 = MANTISSA_DIGITS + 2;\n-\n-        let negn = !0u128;\n-\n-        if sd > MANTISSA_DIGITS {\n-            a = match sd {\n-                MD1 => a.wrapping_shl(1),\n-                MD2 => a,\n-                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n-                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n-                                   .wrapping_sub(sd as u128))) == 0 { 0 } else { 1 })\n-            };\n-            a |= if (a & 4) == 0 { 0 } else { 1 };\n-            a = a.wrapping_add(1);\n-            a = a.wrapping_shr(2);\n-            if a & (1 << MANTISSA_DIGITS) != 0 {\n-                a = a.wrapping_shr(1);\n-                e = e.wrapping_add(1);\n-            }\n-        } else {\n-            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n-        }\n-        unsafe {\n-            ::core::mem::transmute((e as u32).wrapping_add(127).wrapping_shl(23)\n-                                   | (a as u32 & 0x007f_ffff))\n-        }\n-    }\n-\n-\n-    macro_rules! why_are_abi_strings_checked_by_parser { ($cret:ty, $conv:expr, $unadj:tt) => {\n-    mod imp {\n-        use super::{LargeInt, FloatStuff, NegExt, AbsExt};\n-        use super::{i128_as_f64, i128_as_f32, u128_as_f64, u128_as_f32,\n-                    i128_div, i128_mod, u128_div_mod, unchecked_div, ptr};\n-        // For x64\n-        // rdx:rcx, r9:r8, stack -> rdx:rax\n-        // aka.\n-        // define i128 @__muloti4(i128, i128, i32*)\n-        #[export_name=\"__muloti4\"]\n-        pub unsafe extern $unadj fn i128_mul_oflow(a: i128, b: i128, o: *mut i32) -> i128 {\n-            mulo!(a, b, o, i128)\n-        }\n-\n-        // For x64\n-        // rdx:rax -> xmm0\n-        // aka.\n-        // define double @__muloti4(i128)\n-        #[export_name=\"__floattidf\"]\n-        pub extern $unadj fn i128_as_f64_(a: i128) -> f64 {\n-            i128_as_f64(a)\n-        }\n-        #[export_name=\"__floattisf\"]\n-        pub extern $unadj fn i128_as_f32_(a: i128) -> f32 {\n-            i128_as_f32(a)\n-        }\n-        #[export_name=\"__floatuntidf\"]\n-        pub extern $unadj fn u128_as_f64_(a: u128) -> f64 {\n-            u128_as_f64(a)\n-        }\n-        #[export_name=\"__floatuntisf\"]\n-        pub extern $unadj fn u128_as_f32_(a: u128) -> f32 {\n-            u128_as_f32(a)\n-        }\n-\n-        // For x64\n-        // xmm0 -> rdx:rax\n-        // aka.\n-        // define i128 @stuff(double)\n-        #[export_name=\"__fixunsdfti\"]\n-        pub extern $unadj fn f64_as_u128(a: f64) -> u128 {\n-            float_as_unsigned!(a, f64, u128)\n-        }\n-\n-        #[export_name=\"__fixunssfti\"]\n-        pub extern $unadj fn f32_as_u128(a: f32) -> u128 {\n-            float_as_unsigned!(a, f32, u128)\n-        }\n-\n-        #[export_name=\"__fixdfti\"]\n-        pub extern $unadj fn f64_as_i128(a: f64) -> i128 {\n-            float_as_signed!(a, f64, i128)\n-        }\n-\n-        #[export_name=\"__fixsfti\"]\n-        pub extern $unadj fn f32_as_i128(a: f32) -> i128 {\n-            float_as_signed!(a, f32, i128)\n-        }\n-\n-        #[repr(simd)]\n-        pub struct u64x2(u64, u64);\n-\n-        // For x64\n-        // pointers -> xmm0\n-        // aka.\n-        // define <2 x u64> @stuff(i128*, i128*, i128*)\n-        //\n-        // That almost matches the C ABI, so we simply use the C ABI\n-        #[export_name=\"__udivmodti4\"]\n-        pub extern \"C\" fn u128_div_mod_(n: u128, d: u128, rem: *mut u128) -> $cret {\n-            let x = u128_div_mod(n, d, rem);\n-            ($conv)(x)\n-        }\n-\n-        #[export_name=\"__udivti3\"]\n-        pub extern \"C\" fn u128_div_(a: u128, b: u128) -> $cret {\n-            let x = u128_div_mod(a, b, ptr::null_mut());\n-            ($conv)(x)\n-        }\n-\n-        #[export_name=\"__umodti3\"]\n-        pub extern \"C\" fn u128_mod_(a: u128, b: u128) -> $cret {\n-            unsafe {\n-                let mut r = ::core::mem::zeroed();\n-                u128_div_mod(a, b, &mut r);\n-                ($conv)(r)\n-            }\n-        }\n-\n-        #[export_name=\"__divti3\"]\n-        pub extern \"C\" fn i128_div_(a: i128, b: i128) -> $cret {\n-            let x = i128_div(a, b);\n-            ($conv)(x as u128)\n-        }\n-\n-        #[export_name=\"__modti3\"]\n-        pub extern \"C\" fn i128_mod_(a: i128, b: i128) -> $cret {\n-            let x = i128_mod(a, b);\n-            ($conv)(x as u128)\n-        }\n-    }\n-    } }\n-\n-    // LLVM expectations for ABI on windows x64 are pure madness.\n-    #[cfg(all(windows, target_pointer_width=\"64\"))]\n-    why_are_abi_strings_checked_by_parser!(u64x2,\n-                                           |i: u128| u64x2(i.low(), i.high()),\n-                                           \"unadjusted\");\n-\n-    #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n-    why_are_abi_strings_checked_by_parser!(u128, |i|{ i }, \"C\");\n-    pub use self::imp::*;\n-}"}, {"sha": "55df14ea2150ab282f90a9ee9262ff1e61735c86", "filename": "src/libprofiler_builtins/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibprofiler_builtins%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibprofiler_builtins%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibprofiler_builtins%2Fbuild.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -53,7 +53,7 @@ fn main() {\n     }\n \n     for src in profile_sources {\n-        cfg.file(Path::new(\"../compiler-rt/lib/profile\").join(src));\n+        cfg.file(Path::new(\"../libcompiler_builtins/compiler-rt/lib/profile\").join(src));\n     }\n \n     cfg.compile(\"libprofiler-rt.a\");"}, {"sha": "fa93c005dcd8fff838f1538f51da51be7702b621", "filename": "src/librustc_trans/attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fattributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fattributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fattributes.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -13,7 +13,7 @@ use std::ffi::{CStr, CString};\n \n use llvm::{self, Attribute, ValueRef};\n use llvm::AttributePlace::Function;\n-pub use syntax::attr::InlineAttr;\n+pub use syntax::attr::{self, InlineAttr};\n use syntax::ast;\n use context::CrateContext;\n "}, {"sha": "a4bbdef82f094bc9192fd66ba5c780273580a168", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 25, "deletions": 2, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -370,6 +370,24 @@ pub fn each_linked_rlib(sess: &Session,\n     Ok(())\n }\n \n+/// Returns a boolean indicating whether the specified crate should be ignored\n+/// during LTO.\n+///\n+/// Crates ignored during LTO are not lumped together in the \"massive object\n+/// file\" that we create and are linked in their normal rlib states. See\n+/// comments below for what crates do not participate in LTO.\n+///\n+/// It's unusual for a crate to not participate in LTO. Typically only\n+/// compiler-specific and unstable crates have a reason to not participate in\n+/// LTO.\n+pub fn ignored_for_lto(sess: &Session, cnum: CrateNum) -> bool {\n+    // `#![no_builtins]` crates don't participate in LTO because the state\n+    // of builtins gets messed up (our crate isn't tagged with no builtins).\n+    // Similarly `#![compiler_builtins]` doesn't participate because we want\n+    // those builtins!\n+    sess.cstore.is_no_builtins(cnum) || sess.cstore.is_compiler_builtins(cnum)\n+}\n+\n fn out_filename(sess: &Session,\n                 crate_type: config::CrateType,\n                 outputs: &OutputFilenames,\n@@ -736,7 +754,10 @@ fn link_staticlib(sess: &Session,\n         let skip_object_files = native_libs.iter().any(|lib| {\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n-        ab.add_rlib(path, &name.as_str(), sess.lto(), skip_object_files).unwrap();\n+        ab.add_rlib(path,\n+                    &name.as_str(),\n+                    sess.lto() && !ignored_for_lto(sess, cnum),\n+                    skip_object_files).unwrap();\n \n         all_native_libs.extend(sess.cstore.native_libraries(cnum));\n     });\n@@ -1289,7 +1310,9 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if !sess.lto() && crate_type != config::CrateTypeDylib && !skip_native {\n+        if (!sess.lto() || ignored_for_lto(sess, cnum)) &&\n+           crate_type != config::CrateTypeDylib &&\n+           !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n             return\n         }"}, {"sha": "5e227ec467abb050e0e8a402f75270f8c83c90fa", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -1220,8 +1220,7 @@ fn spawn_work<'a>(sess: &'a Session,\n     let crate_types = sess.crate_types.borrow().clone();\n     let mut each_linked_rlib_for_lto = Vec::new();\n     drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n-        // `#![no_builtins]` crates don't participate in LTO.\n-        if sess.cstore.is_no_builtins(cnum) {\n+        if link::ignored_for_lto(sess, cnum) {\n             return\n         }\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));"}, {"sha": "8f9146283effe103f5dd8193e8e167c412bd9458", "filename": "src/librustc_trans/declare.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fdeclare.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Fdeclare.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdeclare.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -30,7 +30,6 @@ use context::CrateContext;\n use common;\n use type_::Type;\n use value::Value;\n-use syntax::attr;\n \n use std::ffi::CString;\n \n@@ -88,16 +87,6 @@ fn declare_raw_fn(ccx: &CrateContext, name: &str, callconv: llvm::CallConv, ty:\n         }\n     }\n \n-    // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n-    // compiler-rt, then we want to implicitly compile everything with hidden\n-    // visibility as we're going to link this object all over the place but\n-    // don't want the symbols to get exported.\n-    if attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n-        unsafe {\n-            llvm::LLVMRustSetVisibility(llfn, llvm::Visibility::Hidden);\n-        }\n-    }\n-\n     match ccx.tcx().sess.opts.cg.opt_level.as_ref().map(String::as_ref) {\n         Some(\"s\") => {\n             llvm::Attribute::OptimizeForSize.apply_llfn(Function, llfn);"}, {"sha": "200f6dee334ad40e9093260596a8d001044c8e47", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -162,6 +162,18 @@ impl<'a, 'tcx> TransItem<'tcx> {\n             llvm::SetUniqueComdat(ccx.llmod(), lldecl);\n         }\n \n+        // If we're compiling the compiler-builtins crate, e.g. the equivalent of\n+        // compiler-rt, then we want to implicitly compile everything with hidden\n+        // visibility as we're going to link this object all over the place but\n+        // don't want the symbols to get exported.\n+        if linkage != llvm::Linkage::InternalLinkage &&\n+           linkage != llvm::Linkage::PrivateLinkage &&\n+           attr::contains_name(ccx.tcx().hir.krate_attrs(), \"compiler_builtins\") {\n+            unsafe {\n+                llvm::LLVMRustSetVisibility(lldecl, llvm::Visibility::Hidden);\n+            }\n+        }\n+\n         debug!(\"predefine_fn: mono_ty = {:?} instance = {:?}\", mono_ty, instance);\n         if common::is_inline_instance(ccx.tcx(), &instance) {\n             attributes::inline(lldecl, attributes::InlineAttr::Hint);"}, {"sha": "09c168169348b4c4884fa1b658f7ab04d8e4dd5a", "filename": "src/libstd/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Flibstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2FCargo.toml?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -19,7 +19,7 @@ collections = { path = \"../libcollections\" }\n core = { path = \"../libcore\" }\n libc = { path = \"../rustc/libc_shim\" }\n rand = { path = \"../librand\" }\n-compiler_builtins = { path = \"../libcompiler_builtins\" }\n+compiler_builtins = { path = \"../rustc/compiler_builtins_shim\" }\n profiler_builtins = { path = \"../libprofiler_builtins\", optional = true }\n std_unicode = { path = \"../libstd_unicode\" }\n unwind = { path = \"../libunwind\" }"}, {"sha": "e0026078a5d72651e9c83304ffe65e1ab049c955", "filename": "src/rustc/compiler_builtins_shim/Cargo.toml", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fcompiler_builtins_shim%2FCargo.toml?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -0,0 +1,24 @@\n+# See libc_shim/Cargo.toml for why this exists\n+\n+[package]\n+name = \"compiler_builtins\"\n+authors = [\"The Rust Project Developers\"]\n+version = \"0.0.0\"\n+build = \"../../libcompiler_builtins/build.rs\"\n+\n+[lib]\n+path = \"../../libcompiler_builtins/src/lib.rs\"\n+test = false\n+doctest = false\n+\n+[dependencies]\n+core = { path = \"../../libcore\" }\n+\n+[build-dependencies]\n+gcc = \"0.3\"\n+\n+[features]\n+c = []\n+default = [\"c\", \"rustbuild\", \"compiler-builtins\"]\n+rustbuild = []\n+compiler-builtins = []"}, {"sha": "546f60482e7bcd21561227ecff7ed2b496baf2af", "filename": "src/rustc/compiler_builtins_shim/build.rs", "status": "renamed", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Frustc%2Fcompiler_builtins_shim%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Frustc%2Fcompiler_builtins_shim%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fcompiler_builtins_shim%2Fbuild.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,8 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// no-prefer-dynamic\n-#![crate_type = \"staticlib\"]\n+#![deny(warnings)]\n \n-#[no_mangle]\n-pub extern \"C\" fn foo(x:i32) -> i32 { x }\n+// See comments in Cargo.toml for why this exists\n+\n+fn main() {\n+    println!(\"cargo:rustc-cfg=stdbuild\");\n+    println!(\"cargo:rerun-if-changed=build.rs\");\n+}", "previous_filename": "src/test/run-pass/auxiliary/clibrary.rs"}, {"sha": "020570e61dc63fe7495ac72a4461367ff0f8526f", "filename": "src/tools/tidy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cab2c73d47a4b0ec7dc1bf40eb59492139fb707/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Flib.rs?ref=8cab2c73d47a4b0ec7dc1bf40eb59492139fb707", "patch": "@@ -54,6 +54,7 @@ fn filter_dirs(path: &Path) -> bool {\n         \"src/jemalloc\",\n         \"src/llvm\",\n         \"src/libbacktrace\",\n+        \"src/libcompiler_builtins\",\n         \"src/compiler-rt\",\n         \"src/rustllvm\",\n         \"src/liblibc\","}]}