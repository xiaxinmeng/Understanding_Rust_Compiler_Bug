{"sha": "637ac17c5292ce723430de0e87b92271989e1436", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzN2FjMTdjNTI5MmNlNzIzNDMwZGUwZTg3YjkyMjcxOTg5ZTE0MzY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-03T11:50:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-04-03T11:50:11Z"}, "message": "Auto merge of #49447 - pnkfelix:remove-cfg-const-pat-hack-47295, r=nikomatsakis\n\nRemove adjacent all-const match arm hack.\n\nAn old fix for moves-in-guards had a hack for adjacent all-const match arms.\n\nThe hack was explained in a comment, which you can see here:\nhttps://github.com/rust-lang/rust/pull/22580/files#diff-402a0fa4b3c6755c5650027c6d4cf1efR497\n\nBut hack was incomplete (and thus unsound), as pointed out here:\nhttps://github.com/rust-lang/rust/issues/47295#issuecomment-357108458\n\nPlus, it is likely to be at least tricky to reimplement this hack in\nthe new NLL borrowck.\n\nSo rather than try to preserve the hack, we want to try to just remove\nit outright. (At least to see the results of a crater run.)\n\n[breaking-change]\n\nThis is a breaking-change, but our hope is that no one is actually\nrelying on such an extreme special case. (We hypothesize the hack was\noriginally added to accommodate a file in our own test suite, not code\nin the wild.)", "tree": {"sha": "4e1ed24e03373c2473660a352c1aaa0f823511e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e1ed24e03373c2473660a352c1aaa0f823511e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/637ac17c5292ce723430de0e87b92271989e1436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/637ac17c5292ce723430de0e87b92271989e1436", "html_url": "https://github.com/rust-lang/rust/commit/637ac17c5292ce723430de0e87b92271989e1436", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/637ac17c5292ce723430de0e87b92271989e1436/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b12af86a776364f01f65e3bd551e2641b4fac4ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/b12af86a776364f01f65e3bd551e2641b4fac4ec", "html_url": "https://github.com/rust-lang/rust/commit/b12af86a776364f01f65e3bd551e2641b4fac4ec"}, {"sha": "347cf21290c80c528363cc33d9cade6cd1e77888", "url": "https://api.github.com/repos/rust-lang/rust/commits/347cf21290c80c528363cc33d9cade6cd1e77888", "html_url": "https://github.com/rust-lang/rust/commit/347cf21290c80c528363cc33d9cade6cd1e77888"}], "stats": {"total": 54, "additions": 18, "deletions": 36}, "files": [{"sha": "1247db55f58506b0519a456a2137b88e3ce0ee0e", "filename": "src/librustc/cfg/construct.rs", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/637ac17c5292ce723430de0e87b92271989e1436/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637ac17c5292ce723430de0e87b92271989e1436/src%2Flibrustc%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fcfg%2Fconstruct.rs?ref=637ac17c5292ce723430de0e87b92271989e1436", "patch": "@@ -473,8 +473,6 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n \n         // Keep track of the previous guard expressions\n         let mut prev_guards = Vec::new();\n-        // Track if the previous pattern contained bindings or wildcards\n-        let mut prev_has_bindings = false;\n \n         for arm in arms {\n             // Add an exit node for when we've visited all the\n@@ -493,40 +491,16 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                     // Visit the guard expression\n                     let guard_exit = self.expr(&guard, guard_start);\n \n-                    let this_has_bindings = pat.contains_bindings_or_wild();\n-\n-                    // If both this pattern and the previous pattern\n-                    // were free of bindings, they must consist only\n-                    // of \"constant\" patterns. Note we cannot match an\n-                    // all-constant pattern, fail the guard, and then\n-                    // match *another* all-constant pattern. This is\n-                    // because if the previous pattern matches, then\n-                    // we *cannot* match this one, unless all the\n-                    // constants are the same (which is rejected by\n-                    // `check_match`).\n-                    //\n-                    // We can use this to be smarter about the flow\n-                    // along guards. If the previous pattern matched,\n-                    // then we know we will not visit the guard in\n-                    // this one (whether or not the guard succeeded),\n-                    // if the previous pattern failed, then we know\n-                    // the guard for that pattern will not have been\n-                    // visited. Thus, it is not possible to visit both\n-                    // the previous guard and the current one when\n-                    // both patterns consist only of constant\n-                    // sub-patterns.\n-                    //\n-                    // However, if the above does not hold, then all\n-                    // previous guards need to be wired to visit the\n-                    // current guard pattern.\n-                    if prev_has_bindings || this_has_bindings {\n-                        while let Some(prev) = prev_guards.pop() {\n-                            self.add_contained_edge(prev, guard_start);\n-                        }\n+                    // #47295: We used to have very special case code\n+                    // here for when a pair of arms are both formed\n+                    // solely from constants, and if so, not add these\n+                    // edges.  But this was not actually sound without\n+                    // other constraints that we stopped enforcing at\n+                    // some point.\n+                    while let Some(prev) = prev_guards.pop() {\n+                        self.add_contained_edge(prev, guard_start);\n                     }\n \n-                    prev_has_bindings = this_has_bindings;\n-\n                     // Push the guard onto the list of previous guards\n                     prev_guards.push(guard_exit);\n "}, {"sha": "05fe48e0199dfafef867952a70ed822dfa24115b", "filename": "src/test/compile-fail/move-guard-same-consts.rs", "status": "renamed", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/637ac17c5292ce723430de0e87b92271989e1436/src%2Ftest%2Fcompile-fail%2Fmove-guard-same-consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/637ac17c5292ce723430de0e87b92271989e1436/src%2Ftest%2Fcompile-fail%2Fmove-guard-same-consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmove-guard-same-consts.rs?ref=637ac17c5292ce723430de0e87b92271989e1436", "patch": "@@ -8,7 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n+// #47295: We used to have a hack of special-casing adjacent amtch\n+// arms whose patterns were composed solely of constants to not have\n+// them linked in the cfg.\n+//\n+// THis was broken for various reasons. In particular, that hack was\n+// originally authored under the assunption that other checks\n+// elsewhere would ensure that the two patterns did not overlap.  But\n+// that assumption did not hold, at least not in the long run (namely,\n+// overlapping patterns were turned into warnings rather than errors).\n \n #![feature(box_syntax)]\n \n@@ -18,8 +26,8 @@ fn main() {\n     let v = (1, 2);\n \n     match v {\n-        (2, 1) if take(x) => (),\n         (1, 2) if take(x) => (),\n+        (1, 2) if take(x) => (), //~ ERROR use of moved value: `x`\n         _ => (),\n     }\n }", "previous_filename": "src/test/run-pass/move-guard-const.rs"}]}