{"sha": "5d642e8b234e96b360ef94734f724af12b36abb6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVkNjQyZThiMjM0ZTk2YjM2MGVmOTQ3MzRmNzI0YWYxMmIzNmFiYjY=", "commit": {"author": {"name": "crw5996", "email": "henry11", "date": "2018-08-27T16:31:26Z"}, "committer": {"name": "crw5996", "email": "henry11", "date": "2018-08-27T19:25:40Z"}, "message": "Fixed #2955. Added value to determine whether or not rustfmt has condensed a tuple-struct\n\nRefactored to not use a mutable variable", "tree": {"sha": "71f347eef1d41455c73c86cb65c3ace48f6025d0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/71f347eef1d41455c73c86cb65c3ace48f6025d0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5d642e8b234e96b360ef94734f724af12b36abb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5d642e8b234e96b360ef94734f724af12b36abb6", "html_url": "https://github.com/rust-lang/rust/commit/5d642e8b234e96b360ef94734f724af12b36abb6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5d642e8b234e96b360ef94734f724af12b36abb6/comments", "author": null, "committer": null, "parents": [{"sha": "448460958347cc633c9aea993253be076fda1580", "url": "https://api.github.com/repos/rust-lang/rust/commits/448460958347cc633c9aea993253be076fda1580", "html_url": "https://github.com/rust-lang/rust/commit/448460958347cc633c9aea993253be076fda1580"}], "stats": {"total": 4578, "additions": 4561, "deletions": 17}, "files": [{"sha": "760333955a054599991ed37c0a43dc0539bd1e57", "filename": "bin/main.rs", "status": "added", "additions": 589, "deletions": 0, "changes": 589, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/bin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/bin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/bin%2Fmain.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,589 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![cfg(not(test))]\n+#![feature(extern_prelude)]\n+\n+extern crate env_logger;\n+#[macro_use]\n+extern crate failure;\n+extern crate getopts;\n+extern crate rustfmt_nightly as rustfmt;\n+\n+use std::env;\n+use std::fs::File;\n+use std::io::{self, stdout, Read, Write};\n+use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n+\n+use failure::err_msg;\n+\n+use getopts::{Matches, Options};\n+\n+use rustfmt::{\n+    load_config, CliOptions, Color, Config, EmitMode, ErrorKind, FileLines, FileName, Input,\n+    Session, Verbosity,\n+};\n+\n+fn main() {\n+    env_logger::init();\n+    let opts = make_opts();\n+\n+    let exit_code = match execute(&opts) {\n+        Ok(code) => code,\n+        Err(e) => {\n+            eprintln!(\"{}\", e.to_string());\n+            1\n+        }\n+    };\n+    // Make sure standard output is flushed before we exit.\n+    std::io::stdout().flush().unwrap();\n+\n+    // Exit with given exit code.\n+    //\n+    // NOTE: This immediately terminates the process without doing any cleanup,\n+    // so make sure to finish all necessary cleanup before this is called.\n+    std::process::exit(exit_code);\n+}\n+\n+/// Rustfmt operations.\n+enum Operation {\n+    /// Format files and their child modules.\n+    Format {\n+        files: Vec<PathBuf>,\n+        minimal_config_path: Option<String>,\n+    },\n+    /// Print the help message.\n+    Help(HelpOp),\n+    // Print version information\n+    Version,\n+    /// Output default config to a file, or stdout if None\n+    ConfigOutputDefault {\n+        path: Option<String>,\n+    },\n+    /// No file specified, read from stdin\n+    Stdin {\n+        input: String,\n+    },\n+}\n+\n+/// Arguments to `--help`\n+enum HelpOp {\n+    None,\n+    Config,\n+    FileLines,\n+}\n+\n+fn make_opts() -> Options {\n+    let mut opts = Options::new();\n+\n+    opts.optflag(\n+        \"\",\n+        \"check\",\n+        \"Run in 'check' mode. Exits with 0 if input if formatted correctly. Exits \\\n+         with 1 and prints a diff if formatting is required.\",\n+    );\n+    let is_nightly = is_nightly();\n+    let emit_opts = if is_nightly {\n+        \"[files|stdout|coverage|checkstyle]\"\n+    } else {\n+        \"[files|stdout]\"\n+    };\n+    opts.optopt(\"\", \"emit\", \"What data to emit and how\", emit_opts);\n+    opts.optflag(\"\", \"backup\", \"Backup any modified files.\");\n+    opts.optopt(\n+        \"\",\n+        \"config-path\",\n+        \"Recursively searches the given path for the rustfmt.toml config file. If not \\\n+         found reverts to the input file path\",\n+        \"[Path for the configuration file]\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"color\",\n+        \"Use colored output (if supported)\",\n+        \"[always|never|auto]\",\n+    );\n+    opts.optopt(\n+        \"\",\n+        \"print-config\",\n+        \"Dumps a default or minimal config to PATH. A minimal config is the \\\n+         subset of the current config file used for formatting the current program.\",\n+        \"[minimal|default] PATH\",\n+    );\n+\n+    if is_nightly {\n+        opts.optflag(\n+            \"\",\n+            \"unstable-features\",\n+            \"Enables unstable features. Only available on nightly channel.\",\n+        );\n+        opts.optopt(\n+            \"\",\n+            \"file-lines\",\n+            \"Format specified line ranges. Run with `--help=file-lines` for \\\n+             more detail (unstable).\",\n+            \"JSON\",\n+        );\n+        opts.optflag(\n+            \"\",\n+            \"error-on-unformatted\",\n+            \"Error if unable to get comments or string literals within max_width, \\\n+             or they are left with trailing whitespaces (unstable).\",\n+        );\n+        opts.optflag(\n+            \"\",\n+            \"skip-children\",\n+            \"Don't reformat child modules (unstable).\",\n+        );\n+    }\n+\n+    opts.optflag(\"v\", \"verbose\", \"Print verbose output\");\n+    opts.optflag(\"q\", \"quiet\", \"Print less output\");\n+    opts.optflag(\"V\", \"version\", \"Show version information\");\n+    opts.optflagopt(\n+        \"h\",\n+        \"help\",\n+        \"Show this message or help about a specific topic: `config` or `file-lines`\",\n+        \"=TOPIC\",\n+    );\n+\n+    opts\n+}\n+\n+fn is_nightly() -> bool {\n+    option_env!(\"CFG_RELEASE_CHANNEL\")\n+        .map(|c| c == \"nightly\" || c == \"dev\")\n+        .unwrap_or(false)\n+}\n+\n+// Returned i32 is an exit code\n+fn execute(opts: &Options) -> Result<i32, failure::Error> {\n+    let matches = opts.parse(env::args().skip(1))?;\n+    let options = GetOptsOptions::from_matches(&matches)?;\n+\n+    match determine_operation(&matches)? {\n+        Operation::Help(HelpOp::None) => {\n+            print_usage_to_stdout(opts, \"\");\n+            return Ok(0);\n+        }\n+        Operation::Help(HelpOp::Config) => {\n+            Config::print_docs(&mut stdout(), options.unstable_features);\n+            return Ok(0);\n+        }\n+        Operation::Help(HelpOp::FileLines) => {\n+            print_help_file_lines();\n+            return Ok(0);\n+        }\n+        Operation::Version => {\n+            print_version();\n+            return Ok(0);\n+        }\n+        Operation::ConfigOutputDefault { path } => {\n+            let toml = Config::default().all_options().to_toml().map_err(err_msg)?;\n+            if let Some(path) = path {\n+                let mut file = File::create(path)?;\n+                file.write_all(toml.as_bytes())?;\n+            } else {\n+                io::stdout().write_all(toml.as_bytes())?;\n+            }\n+            return Ok(0);\n+        }\n+        Operation::Stdin { input } => format_string(input, options),\n+        Operation::Format {\n+            files,\n+            minimal_config_path,\n+        } => format(files, minimal_config_path, options),\n+    }\n+}\n+\n+fn format_string(input: String, options: GetOptsOptions) -> Result<i32, failure::Error> {\n+    // try to read config from local directory\n+    let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n+\n+    // emit mode is always Stdout for Stdin.\n+    config.set().emit_mode(EmitMode::Stdout);\n+    config.set().verbose(Verbosity::Quiet);\n+\n+    // parse file_lines\n+    config.set().file_lines(options.file_lines);\n+    for f in config.file_lines().files() {\n+        match *f {\n+            FileName::Stdin => {}\n+            _ => eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f),\n+        }\n+    }\n+\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n+    format_and_emit_report(&mut session, Input::Text(input));\n+\n+    let exit_code = if session.has_operational_errors() || session.has_parsing_errors() {\n+        1\n+    } else {\n+        0\n+    };\n+    Ok(exit_code)\n+}\n+\n+fn format(\n+    files: Vec<PathBuf>,\n+    minimal_config_path: Option<String>,\n+    options: GetOptsOptions,\n+) -> Result<i32, failure::Error> {\n+    options.verify_file_lines(&files);\n+    let (config, config_path) = load_config(None, Some(options.clone()))?;\n+\n+    if config.verbose() == Verbosity::Verbose {\n+        if let Some(path) = config_path.as_ref() {\n+            println!(\"Using rustfmt config file {}\", path.display());\n+        }\n+    }\n+\n+    let out = &mut stdout();\n+    let mut session = Session::new(config, Some(out));\n+\n+    for file in files {\n+        if !file.exists() {\n+            eprintln!(\"Error: file `{}` does not exist\", file.to_str().unwrap());\n+            session.add_operational_error();\n+        } else if file.is_dir() {\n+            eprintln!(\"Error: `{}` is a directory\", file.to_str().unwrap());\n+            session.add_operational_error();\n+        } else {\n+            // Check the file directory if the config-path could not be read or not provided\n+            if config_path.is_none() {\n+                let (local_config, config_path) =\n+                    load_config(Some(file.parent().unwrap()), Some(options.clone()))?;\n+                if local_config.verbose() == Verbosity::Verbose {\n+                    if let Some(path) = config_path {\n+                        println!(\n+                            \"Using rustfmt config file {} for {}\",\n+                            path.display(),\n+                            file.display()\n+                        );\n+                    }\n+                }\n+\n+                session.override_config(local_config, |sess| {\n+                    format_and_emit_report(sess, Input::File(file))\n+                });\n+            } else {\n+                format_and_emit_report(&mut session, Input::File(file));\n+            }\n+        }\n+    }\n+\n+    // If we were given a path via dump-minimal-config, output any options\n+    // that were used during formatting as TOML.\n+    if let Some(path) = minimal_config_path {\n+        let mut file = File::create(path)?;\n+        let toml = session.config.used_options().to_toml().map_err(err_msg)?;\n+        file.write_all(toml.as_bytes())?;\n+    }\n+\n+    let exit_code = if session.has_operational_errors()\n+        || session.has_parsing_errors()\n+        || ((session.has_diff() || session.has_check_errors()) && options.check)\n+    {\n+        1\n+    } else {\n+        0\n+    };\n+    Ok(exit_code)\n+}\n+\n+fn format_and_emit_report<T: Write>(session: &mut Session<T>, input: Input) {\n+    match session.format(input) {\n+        Ok(report) => {\n+            if report.has_warnings() {\n+                match term::stderr() {\n+                    Some(ref t)\n+                        if session.config.color().use_colored_tty()\n+                            && t.supports_color()\n+                            && t.supports_attr(term::Attr::Bold) =>\n+                    {\n+                        match report.fancy_print(term::stderr().unwrap()) {\n+                            Ok(..) => (),\n+                            Err(..) => panic!(\"Unable to write to stderr: {}\", report),\n+                        }\n+                    }\n+                    _ => eprintln!(\"{}\", report),\n+                }\n+            }\n+        }\n+        Err(msg) => {\n+            eprintln!(\"Error writing files: {}\", msg);\n+            session.add_operational_error();\n+        }\n+    }\n+}\n+\n+fn print_usage_to_stdout(opts: &Options, reason: &str) {\n+    let sep = if reason.is_empty() {\n+        String::new()\n+    } else {\n+        format!(\"{}\\n\\n\", reason)\n+    };\n+    let msg = format!(\n+        \"{}Format Rust code\\n\\nusage: {} [options] <file>...\",\n+        sep,\n+        env::args_os().next().unwrap().to_string_lossy()\n+    );\n+    println!(\"{}\", opts.usage(&msg));\n+}\n+\n+fn print_help_file_lines() {\n+    println!(\n+        \"If you want to restrict reformatting to specific sets of lines, you can\n+use the `--file-lines` option. Its argument is a JSON array of objects\n+with `file` and `range` properties, where `file` is a file name, and\n+`range` is an array representing a range of lines like `[7,13]`. Ranges\n+are 1-based and inclusive of both end points. Specifying an empty array\n+will result in no files being formatted. For example,\n+\n+```\n+rustfmt --file-lines '[\n+    {{\\\"file\\\":\\\"src/lib.rs\\\",\\\"range\\\":[7,13]}},\n+    {{\\\"file\\\":\\\"src/lib.rs\\\",\\\"range\\\":[21,29]}},\n+    {{\\\"file\\\":\\\"src/foo.rs\\\",\\\"range\\\":[10,11]}},\n+    {{\\\"file\\\":\\\"src/foo.rs\\\",\\\"range\\\":[15,15]}}]'\n+```\n+\n+would format lines `7-13` and `21-29` of `src/lib.rs`, and lines `10-11`,\n+and `15` of `src/foo.rs`. No other files would be formatted, even if they\n+are included as out of line modules from `src/lib.rs`.\"\n+    );\n+}\n+\n+fn print_version() {\n+    let version_info = format!(\n+        \"{}-{}\",\n+        option_env!(\"CARGO_PKG_VERSION\").unwrap_or(\"unknown\"),\n+        include_str!(concat!(env!(\"OUT_DIR\"), \"/commit-info.txt\"))\n+    );\n+\n+    println!(\"rustfmt {}\", version_info);\n+}\n+\n+fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n+    if matches.opt_present(\"h\") {\n+        let topic = matches.opt_str(\"h\");\n+        if topic == None {\n+            return Ok(Operation::Help(HelpOp::None));\n+        } else if topic == Some(\"config\".to_owned()) {\n+            return Ok(Operation::Help(HelpOp::Config));\n+        } else if topic == Some(\"file-lines\".to_owned()) {\n+            return Ok(Operation::Help(HelpOp::FileLines));\n+        } else {\n+            println!(\"Unknown help topic: `{}`\\n\", topic.unwrap());\n+            return Ok(Operation::Help(HelpOp::None));\n+        }\n+    }\n+\n+    let mut minimal_config_path = None;\n+    if let Some(ref kind) = matches.opt_str(\"print-config\") {\n+        let path = matches.free.get(0).cloned();\n+        if kind == \"default\" {\n+            return Ok(Operation::ConfigOutputDefault { path });\n+        } else if kind == \"minimal\" {\n+            minimal_config_path = path;\n+            if minimal_config_path.is_none() {\n+                println!(\"WARNING: PATH required for `--print-config minimal`\");\n+            }\n+        }\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        return Ok(Operation::Version);\n+    }\n+\n+    // if no file argument is supplied, read from stdin\n+    if matches.free.is_empty() {\n+        let mut buffer = String::new();\n+        io::stdin().read_to_string(&mut buffer)?;\n+\n+        return Ok(Operation::Stdin { input: buffer });\n+    }\n+\n+    let files: Vec<_> = matches\n+        .free\n+        .iter()\n+        .map(|s| {\n+            let p = PathBuf::from(s);\n+            // we will do comparison later, so here tries to canonicalize first\n+            // to get the expected behavior.\n+            p.canonicalize().unwrap_or(p)\n+        }).collect();\n+\n+    Ok(Operation::Format {\n+        files,\n+        minimal_config_path,\n+    })\n+}\n+\n+const STABLE_EMIT_MODES: [EmitMode; 3] = [EmitMode::Files, EmitMode::Stdout, EmitMode::Diff];\n+\n+/// Parsed command line options.\n+#[derive(Clone, Debug, Default)]\n+struct GetOptsOptions {\n+    skip_children: Option<bool>,\n+    quiet: bool,\n+    verbose: bool,\n+    config_path: Option<PathBuf>,\n+    emit_mode: EmitMode,\n+    backup: bool,\n+    check: bool,\n+    color: Option<Color>,\n+    file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n+    error_on_unformatted: Option<bool>,\n+}\n+\n+impl GetOptsOptions {\n+    pub fn from_matches(matches: &Matches) -> Result<GetOptsOptions, failure::Error> {\n+        let mut options = GetOptsOptions::default();\n+        options.verbose = matches.opt_present(\"verbose\");\n+        options.quiet = matches.opt_present(\"quiet\");\n+        if options.verbose && options.quiet {\n+            return Err(format_err!(\"Can't use both `--verbose` and `--quiet`\"));\n+        }\n+\n+        let rust_nightly = is_nightly();\n+\n+        if rust_nightly {\n+            options.unstable_features = matches.opt_present(\"unstable-features\");\n+\n+            if options.unstable_features {\n+                if matches.opt_present(\"skip-children\") {\n+                    options.skip_children = Some(true);\n+                }\n+                if matches.opt_present(\"error-on-unformatted\") {\n+                    options.error_on_unformatted = Some(true);\n+                }\n+                if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+                    options.file_lines = file_lines.parse().map_err(err_msg)?;\n+                }\n+            } else {\n+                let mut unstable_options = vec![];\n+                if matches.opt_present(\"skip-children\") {\n+                    unstable_options.push(\"`--skip-children`\");\n+                }\n+                if matches.opt_present(\"error-on-unformatted\") {\n+                    unstable_options.push(\"`--error-on-unformatted`\");\n+                }\n+                if matches.opt_present(\"file-lines\") {\n+                    unstable_options.push(\"`--file-lines`\");\n+                }\n+                if !unstable_options.is_empty() {\n+                    let s = if unstable_options.len() == 1 { \"\" } else { \"s\" };\n+                    return Err(format_err!(\n+                        \"Unstable option{} ({}) used without `--unstable-features`\",\n+                        s,\n+                        unstable_options.join(\", \"),\n+                    ));\n+                }\n+            }\n+        }\n+\n+        options.config_path = matches.opt_str(\"config-path\").map(PathBuf::from);\n+\n+        options.check = matches.opt_present(\"check\");\n+        if let Some(ref emit_str) = matches.opt_str(\"emit\") {\n+            if options.check {\n+                return Err(format_err!(\"Invalid to use `--emit` and `--check`\"));\n+            }\n+            if let Ok(emit_mode) = emit_mode_from_emit_str(emit_str) {\n+                options.emit_mode = emit_mode;\n+            } else {\n+                return Err(format_err!(\"Invalid value for `--emit`\"));\n+            }\n+        }\n+\n+        if matches.opt_present(\"backup\") {\n+            options.backup = true;\n+        }\n+\n+        if !rust_nightly {\n+            if !STABLE_EMIT_MODES.contains(&options.emit_mode) {\n+                return Err(format_err!(\n+                    \"Invalid value for `--emit` - using an unstable \\\n+                     value without `--unstable-features`\",\n+                ));\n+            }\n+        }\n+\n+        if let Some(ref color) = matches.opt_str(\"color\") {\n+            match Color::from_str(color) {\n+                Ok(color) => options.color = Some(color),\n+                _ => return Err(format_err!(\"Invalid color: {}\", color)),\n+            }\n+        }\n+\n+        Ok(options)\n+    }\n+\n+    fn verify_file_lines(&self, files: &[PathBuf]) {\n+        for f in self.file_lines.files() {\n+            match *f {\n+                FileName::Real(ref f) if files.contains(f) => {}\n+                FileName::Real(_) => {\n+                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                }\n+                FileName::Stdin => eprintln!(\"Warning: Not a file '{}'\", f),\n+            }\n+        }\n+    }\n+}\n+\n+impl CliOptions for GetOptsOptions {\n+    fn apply_to(self, config: &mut Config) {\n+        if self.verbose {\n+            config.set().verbose(Verbosity::Verbose);\n+        } else if self.quiet {\n+            config.set().verbose(Verbosity::Quiet);\n+        } else {\n+            config.set().verbose(Verbosity::Normal);\n+        }\n+        config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n+        if let Some(skip_children) = self.skip_children {\n+            config.set().skip_children(skip_children);\n+        }\n+        if let Some(error_on_unformatted) = self.error_on_unformatted {\n+            config.set().error_on_unformatted(error_on_unformatted);\n+        }\n+        if self.check {\n+            config.set().emit_mode(EmitMode::Diff);\n+        } else {\n+            config.set().emit_mode(self.emit_mode);\n+        }\n+        if self.backup {\n+            config.set().make_backup(true);\n+        }\n+        if let Some(color) = self.color {\n+            config.set().color(color);\n+        }\n+    }\n+\n+    fn config_path(&self) -> Option<&Path> {\n+        self.config_path.as_ref().map(|p| &**p)\n+    }\n+}\n+\n+fn emit_mode_from_emit_str(emit_str: &str) -> Result<EmitMode, failure::Error> {\n+    match emit_str {\n+        \"files\" => Ok(EmitMode::Files),\n+        \"stdout\" => Ok(EmitMode::Stdout),\n+        \"coverage\" => Ok(EmitMode::Coverage),\n+        \"checkstyle\" => Ok(EmitMode::Checkstyle),\n+        _ => Err(format_err!(\"Invalid value for `--emit`\")),\n+    }\n+}"}, {"sha": "2d8234ef41e39a50e9dae1d79cbed67a40e6bd62", "filename": "cargo-fmt/main.rs", "status": "added", "additions": 381, "deletions": 0, "changes": 381, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/cargo-fmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/cargo-fmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/cargo-fmt%2Fmain.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,381 @@\n+// Copyright 2015-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Inspired by Paul Woolcock's cargo-fmt (https://github.com/pwoolcoc/cargo-fmt/)\n+\n+#![cfg(not(test))]\n+#![deny(warnings)]\n+\n+extern crate cargo_metadata;\n+extern crate getopts;\n+extern crate serde_json as json;\n+\n+use std::collections::HashSet;\n+use std::env;\n+use std::fs;\n+use std::hash::{Hash, Hasher};\n+use std::io::{self, Write};\n+use std::iter::FromIterator;\n+use std::path::{Path, PathBuf};\n+use std::process::{Command, ExitStatus};\n+use std::str;\n+\n+use getopts::{Matches, Options};\n+\n+fn main() {\n+    let exit_status = execute();\n+    std::io::stdout().flush().unwrap();\n+    std::process::exit(exit_status);\n+}\n+\n+const SUCCESS: i32 = 0;\n+const FAILURE: i32 = 1;\n+\n+fn execute() -> i32 {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optflag(\"q\", \"quiet\", \"no output printed to stdout\");\n+    opts.optflag(\"v\", \"verbose\", \"use verbose output\");\n+    opts.optmulti(\n+        \"p\",\n+        \"package\",\n+        \"specify package to format (only usable in workspaces)\",\n+        \"<package>\",\n+    );\n+    opts.optflag(\"\", \"version\", \"print rustfmt version and exit\");\n+    opts.optflag(\"\", \"all\", \"format all packages (only usable in workspaces)\");\n+\n+    // If there is any invalid argument passed to `cargo fmt`, return without formatting.\n+    let mut is_package_arg = false;\n+    for arg in env::args().skip(2).take_while(|a| a != \"--\") {\n+        if arg.starts_with('-') {\n+            is_package_arg = arg.starts_with(\"--package\");\n+        } else if !is_package_arg {\n+            print_usage_to_stderr(&opts, &format!(\"Invalid argument: `{}`.\", arg));\n+            return FAILURE;\n+        } else {\n+            is_package_arg = false;\n+        }\n+    }\n+\n+    let matches = match opts.parse(env::args().skip(1).take_while(|a| a != \"--\")) {\n+        Ok(m) => m,\n+        Err(e) => {\n+            print_usage_to_stderr(&opts, &e.to_string());\n+            return FAILURE;\n+        }\n+    };\n+\n+    let verbosity = match (matches.opt_present(\"v\"), matches.opt_present(\"q\")) {\n+        (false, false) => Verbosity::Normal,\n+        (false, true) => Verbosity::Quiet,\n+        (true, false) => Verbosity::Verbose,\n+        (true, true) => {\n+            print_usage_to_stderr(&opts, \"quiet mode and verbose mode are not compatible\");\n+            return FAILURE;\n+        }\n+    };\n+\n+    if matches.opt_present(\"h\") {\n+        print_usage_to_stdout(&opts, \"\");\n+        return SUCCESS;\n+    }\n+\n+    if matches.opt_present(\"version\") {\n+        return handle_command_status(get_version(verbosity), &opts);\n+    }\n+\n+    let strategy = CargoFmtStrategy::from_matches(&matches);\n+    handle_command_status(format_crate(verbosity, &strategy), &opts)\n+}\n+\n+macro_rules! print_usage {\n+    ($print:ident, $opts:ident, $reason:expr) => {{\n+        let msg = format!(\"{}\\nusage: cargo fmt [options]\", $reason);\n+        $print!(\n+            \"{}\\nThis utility formats all bin and lib files of the current crate using rustfmt. \\\n+             Arguments after `--` are passed to rustfmt.\",\n+            $opts.usage(&msg)\n+        );\n+    }};\n+}\n+\n+fn print_usage_to_stdout(opts: &Options, reason: &str) {\n+    print_usage!(println, opts, reason);\n+}\n+\n+fn print_usage_to_stderr(opts: &Options, reason: &str) {\n+    print_usage!(eprintln, opts, reason);\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq)]\n+pub enum Verbosity {\n+    Verbose,\n+    Normal,\n+    Quiet,\n+}\n+\n+fn handle_command_status(status: Result<ExitStatus, io::Error>, opts: &getopts::Options) -> i32 {\n+    match status {\n+        Err(e) => {\n+            print_usage_to_stderr(opts, &e.to_string());\n+            FAILURE\n+        }\n+        Ok(status) => {\n+            if status.success() {\n+                SUCCESS\n+            } else {\n+                status.code().unwrap_or(FAILURE)\n+            }\n+        }\n+    }\n+}\n+\n+fn get_version(verbosity: Verbosity) -> Result<ExitStatus, io::Error> {\n+    run_rustfmt(&[], &[String::from(\"--version\")], verbosity)\n+}\n+\n+fn format_crate(\n+    verbosity: Verbosity,\n+    strategy: &CargoFmtStrategy,\n+) -> Result<ExitStatus, io::Error> {\n+    let rustfmt_args = get_fmt_args();\n+    let targets = if rustfmt_args\n+        .iter()\n+        .any(|s| [\"--print-config\", \"-h\", \"--help\", \"-V\", \"--verison\"].contains(&s.as_str()))\n+    {\n+        HashSet::new()\n+    } else {\n+        get_targets(strategy)?\n+    };\n+\n+    // Currently only bin and lib files get formatted\n+    let files: Vec<_> = targets\n+        .into_iter()\n+        .inspect(|t| {\n+            if verbosity == Verbosity::Verbose {\n+                println!(\"[{}] {:?}\", t.kind, t.path)\n+            }\n+        }).map(|t| t.path)\n+        .collect();\n+\n+    run_rustfmt(&files, &rustfmt_args, verbosity)\n+}\n+\n+fn get_fmt_args() -> Vec<String> {\n+    // All arguments after -- are passed to rustfmt\n+    env::args().skip_while(|a| a != \"--\").skip(1).collect()\n+}\n+\n+/// Target uses a `path` field for equality and hashing.\n+#[derive(Debug)]\n+pub struct Target {\n+    /// A path to the main source file of the target.\n+    path: PathBuf,\n+    /// A kind of target (e.g. lib, bin, example, ...).\n+    kind: String,\n+}\n+\n+impl Target {\n+    pub fn from_target(target: &cargo_metadata::Target) -> Self {\n+        let path = PathBuf::from(&target.src_path);\n+        let canonicalized = fs::canonicalize(&path).unwrap_or(path);\n+\n+        Target {\n+            path: canonicalized,\n+            kind: target.kind[0].clone(),\n+        }\n+    }\n+}\n+\n+impl PartialEq for Target {\n+    fn eq(&self, other: &Target) -> bool {\n+        self.path == other.path\n+    }\n+}\n+\n+impl Eq for Target {}\n+\n+impl Hash for Target {\n+    fn hash<H: Hasher>(&self, state: &mut H) {\n+        self.path.hash(state);\n+    }\n+}\n+\n+#[derive(Debug, PartialEq, Eq)]\n+pub enum CargoFmtStrategy {\n+    /// Format every packages and dependencies.\n+    All,\n+    /// Format packages that are specified by the command line argument.\n+    Some(Vec<String>),\n+    /// Format the root packages only.\n+    Root,\n+}\n+\n+impl CargoFmtStrategy {\n+    pub fn from_matches(matches: &Matches) -> CargoFmtStrategy {\n+        match (matches.opt_present(\"all\"), matches.opt_present(\"p\")) {\n+            (false, false) => CargoFmtStrategy::Root,\n+            (true, _) => CargoFmtStrategy::All,\n+            (false, true) => CargoFmtStrategy::Some(matches.opt_strs(\"p\")),\n+        }\n+    }\n+}\n+\n+/// Based on the specified `CargoFmtStrategy`, returns a set of main source files.\n+fn get_targets(strategy: &CargoFmtStrategy) -> Result<HashSet<Target>, io::Error> {\n+    let mut targets = HashSet::new();\n+\n+    match *strategy {\n+        CargoFmtStrategy::Root => get_targets_root_only(&mut targets)?,\n+        CargoFmtStrategy::All => get_targets_recursive(None, &mut targets, &mut HashSet::new())?,\n+        CargoFmtStrategy::Some(ref hitlist) => get_targets_with_hitlist(hitlist, &mut targets)?,\n+    }\n+\n+    if targets.is_empty() {\n+        Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"Failed to find targets\".to_owned(),\n+        ))\n+    } else {\n+        Ok(targets)\n+    }\n+}\n+\n+fn get_targets_root_only(targets: &mut HashSet<Target>) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+    let current_dir = env::current_dir()?.canonicalize()?;\n+    let current_dir_manifest = current_dir.join(\"Cargo.toml\");\n+    let workspace_root_path = PathBuf::from(&metadata.workspace_root).canonicalize()?;\n+    let in_workspace_root = workspace_root_path == current_dir;\n+\n+    for package in metadata.packages {\n+        if in_workspace_root || PathBuf::from(&package.manifest_path) == current_dir_manifest {\n+            for target in package.targets {\n+                targets.insert(Target::from_target(&target));\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_recursive(\n+    manifest_path: Option<&Path>,\n+    mut targets: &mut HashSet<Target>,\n+    visited: &mut HashSet<String>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(manifest_path)?;\n+\n+    for package in metadata.packages {\n+        add_targets(&package.targets, &mut targets);\n+\n+        // Look for local dependencies.\n+        for dependency in package.dependencies {\n+            if dependency.source.is_some() || visited.contains(&dependency.name) {\n+                continue;\n+            }\n+\n+            let mut manifest_path = PathBuf::from(&package.manifest_path);\n+\n+            manifest_path.pop();\n+            manifest_path.push(&dependency.name);\n+            manifest_path.push(\"Cargo.toml\");\n+\n+            if manifest_path.exists() {\n+                visited.insert(dependency.name);\n+                get_targets_recursive(Some(&manifest_path), &mut targets, visited)?;\n+            }\n+        }\n+    }\n+\n+    Ok(())\n+}\n+\n+fn get_targets_with_hitlist(\n+    hitlist: &[String],\n+    targets: &mut HashSet<Target>,\n+) -> Result<(), io::Error> {\n+    let metadata = get_cargo_metadata(None)?;\n+\n+    let mut workspace_hitlist: HashSet<&String> = HashSet::from_iter(hitlist);\n+\n+    for package in metadata.packages {\n+        if workspace_hitlist.remove(&package.name) {\n+            for target in package.targets {\n+                targets.insert(Target::from_target(&target));\n+            }\n+        }\n+    }\n+\n+    if workspace_hitlist.is_empty() {\n+        Ok(())\n+    } else {\n+        let package = workspace_hitlist.iter().next().unwrap();\n+        Err(io::Error::new(\n+            io::ErrorKind::InvalidInput,\n+            format!(\"package `{}` is not a member of the workspace\", package),\n+        ))\n+    }\n+}\n+\n+fn add_targets(target_paths: &[cargo_metadata::Target], targets: &mut HashSet<Target>) {\n+    for target in target_paths {\n+        targets.insert(Target::from_target(target));\n+    }\n+}\n+\n+fn run_rustfmt(\n+    files: &[PathBuf],\n+    fmt_args: &[String],\n+    verbosity: Verbosity,\n+) -> Result<ExitStatus, io::Error> {\n+    let stdout = if verbosity == Verbosity::Quiet {\n+        std::process::Stdio::null()\n+    } else {\n+        std::process::Stdio::inherit()\n+    };\n+\n+    if verbosity == Verbosity::Verbose {\n+        print!(\"rustfmt\");\n+        for a in fmt_args {\n+            print!(\" {}\", a);\n+        }\n+        for f in files {\n+            print!(\" {}\", f.display());\n+        }\n+        println!();\n+    }\n+\n+    let mut command = Command::new(\"rustfmt\")\n+        .stdout(stdout)\n+        .args(files)\n+        .args(fmt_args)\n+        .spawn()\n+        .map_err(|e| match e.kind() {\n+            io::ErrorKind::NotFound => io::Error::new(\n+                io::ErrorKind::Other,\n+                \"Could not run rustfmt, please make sure it is in your PATH.\",\n+            ),\n+            _ => e,\n+        })?;\n+\n+    command.wait()\n+}\n+\n+fn get_cargo_metadata(manifest_path: Option<&Path>) -> Result<cargo_metadata::Metadata, io::Error> {\n+    match cargo_metadata::metadata(manifest_path) {\n+        Ok(metadata) => Ok(metadata),\n+        Err(..) => Err(io::Error::new(\n+            io::ErrorKind::Other,\n+            \"`cargo manifest` failed.\",\n+        )),\n+    }\n+}"}, {"sha": "aea19b34375ca8b8ff707b2004738eff3cf28531", "filename": "config/config_type.rs", "status": "added", "additions": 452, "deletions": 0, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Fconfig_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Fconfig_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Fconfig_type.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,452 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use config::file_lines::FileLines;\n+use config::options::{IgnoreList, WidthHeuristics};\n+\n+/// Trait for types that can be used in `Config`.\n+pub trait ConfigType: Sized {\n+    /// Returns hint text for use in `Config::print_docs()`. For enum types, this is a\n+    /// pipe-separated list of variants; for other types it returns \"<type>\".\n+    fn doc_hint() -> String;\n+}\n+\n+impl ConfigType for bool {\n+    fn doc_hint() -> String {\n+        String::from(\"<boolean>\")\n+    }\n+}\n+\n+impl ConfigType for usize {\n+    fn doc_hint() -> String {\n+        String::from(\"<unsigned integer>\")\n+    }\n+}\n+\n+impl ConfigType for isize {\n+    fn doc_hint() -> String {\n+        String::from(\"<signed integer>\")\n+    }\n+}\n+\n+impl ConfigType for String {\n+    fn doc_hint() -> String {\n+        String::from(\"<string>\")\n+    }\n+}\n+\n+impl ConfigType for FileLines {\n+    fn doc_hint() -> String {\n+        String::from(\"<json>\")\n+    }\n+}\n+\n+impl ConfigType for WidthHeuristics {\n+    fn doc_hint() -> String {\n+        String::new()\n+    }\n+}\n+\n+impl ConfigType for IgnoreList {\n+    fn doc_hint() -> String {\n+        String::from(\"[<string>,..]\")\n+    }\n+}\n+\n+/// Check if we're in a nightly build.\n+///\n+/// The environment variable `CFG_RELEASE_CHANNEL` is set during the rustc bootstrap\n+/// to \"stable\", \"beta\", or \"nightly\" depending on what toolchain is being built.\n+/// If we are being built as part of the stable or beta toolchains, we want\n+/// to disable unstable configuration options.\n+///\n+/// If we're being built by cargo (e.g. `cargo +nightly install rustfmt-nightly`),\n+/// `CFG_RELEASE_CHANNEL` is not set. As we only support being built against the\n+/// nightly compiler when installed from crates.io, default to nightly mode.\n+macro_rules! is_nightly_channel {\n+    () => {\n+        option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\" || c == \"dev\")\n+            .unwrap_or(true)\n+    };\n+}\n+\n+macro_rules! create_config {\n+    ($($i:ident: $ty:ty, $def:expr, $stb:expr, $( $dstring:expr ),+ );+ $(;)*) => (\n+        #[cfg(test)]\n+        use std::collections::HashSet;\n+        use std::io::Write;\n+\n+        #[derive(Clone)]\n+        pub struct Config {\n+            // if a license_template_path has been specified, successfully read, parsed and compiled\n+            // into a regex, it will be stored here\n+            pub license_template: Option<Regex>,\n+            // For each config item, we store a bool indicating whether it has\n+            // been accessed and the value, and a bool whether the option was\n+            // manually initialised, or taken from the default,\n+            $($i: (Cell<bool>, bool, $ty, bool)),+\n+        }\n+\n+        // Just like the Config struct but with each property wrapped\n+        // as Option<T>. This is used to parse a rustfmt.toml that doesn't\n+        // specify all properties of `Config`.\n+        // We first parse into `PartialConfig`, then create a default `Config`\n+        // and overwrite the properties with corresponding values from `PartialConfig`.\n+        #[derive(Deserialize, Serialize, Clone)]\n+        pub struct PartialConfig {\n+            $(pub $i: Option<$ty>),+\n+        }\n+\n+        impl PartialConfig {\n+            pub fn to_toml(&self) -> Result<String, String> {\n+                // Non-user-facing options can't be specified in TOML\n+                let mut cloned = self.clone();\n+                cloned.file_lines = None;\n+                cloned.verbose = None;\n+                cloned.width_heuristics = None;\n+\n+                ::toml::to_string(&cloned)\n+                    .map_err(|e| format!(\"Could not output config: {}\", e.to_string()))\n+            }\n+        }\n+\n+        // Macro hygiene won't allow us to make `set_$i()` methods on Config\n+        // for each item, so this struct is used to give the API to set values:\n+        // `config.set().option(false)`. It's pretty ugly. Consider replacing\n+        // with `config.set_option(false)` if we ever get a stable/usable\n+        // `concat_idents!()`.\n+        pub struct ConfigSetter<'a>(&'a mut Config);\n+\n+        impl<'a> ConfigSetter<'a> {\n+            $(\n+            pub fn $i(&mut self, value: $ty) {\n+                (self.0).$i.2 = value;\n+                match stringify!($i) {\n+                    \"max_width\" | \"use_small_heuristics\" => self.0.set_heuristics(),\n+                    \"license_template_path\" => self.0.set_license_template(),\n+                    &_ => (),\n+                }\n+            }\n+            )+\n+        }\n+\n+        // Query each option, returns true if the user set the option, false if\n+        // a default was used.\n+        pub struct ConfigWasSet<'a>(&'a Config);\n+\n+        impl<'a> ConfigWasSet<'a> {\n+            $(\n+            pub fn $i(&self) -> bool {\n+                (self.0).$i.1\n+            }\n+            )+\n+        }\n+\n+        impl Config {\n+            pub(crate) fn version_meets_requirement(&self) -> bool {\n+                if self.was_set().required_version() {\n+                    let version = env!(\"CARGO_PKG_VERSION\");\n+                    let required_version = self.required_version();\n+                    if version != required_version {\n+                        println!(\n+                            \"Error: rustfmt version ({}) doesn't match the required version ({})\",\n+                            version,\n+                            required_version,\n+                        );\n+                        return false;\n+                    }\n+                }\n+\n+                true\n+            }\n+\n+            $(\n+            pub fn $i(&self) -> $ty {\n+                self.$i.0.set(true);\n+                self.$i.2.clone()\n+            }\n+            )+\n+\n+            pub fn set<'a>(&'a mut self) -> ConfigSetter<'a> {\n+                ConfigSetter(self)\n+            }\n+\n+            pub fn was_set<'a>(&'a self) -> ConfigWasSet<'a> {\n+                ConfigWasSet(self)\n+            }\n+\n+            fn fill_from_parsed_config(mut self, parsed: PartialConfig, dir: &Path) -> Config {\n+            $(\n+                if let Some(val) = parsed.$i {\n+                    if self.$i.3 {\n+                        self.$i.1 = true;\n+                        self.$i.2 = val;\n+                    } else {\n+                        if is_nightly_channel!() {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val;\n+                        } else {\n+                            eprintln!(\"Warning: can't set `{} = {:?}`, unstable features are only \\\n+                                       available in nightly channel.\", stringify!($i), val);\n+                        }\n+                    }\n+                }\n+            )+\n+                self.set_heuristics();\n+                self.set_license_template();\n+                self.set_ignore(dir);\n+                self\n+            }\n+\n+            /// Returns a hash set initialized with every user-facing config option name.\n+            #[cfg(test)]\n+            pub(crate) fn hash_set() -> HashSet<String> {\n+                let mut hash_set = HashSet::new();\n+                $(\n+                    hash_set.insert(stringify!($i).to_owned());\n+                )+\n+                hash_set\n+            }\n+\n+            pub(crate) fn is_valid_name(name: &str) -> bool {\n+                match name {\n+                    $(\n+                        stringify!($i) => true,\n+                    )+\n+                        _ => false,\n+                }\n+            }\n+\n+            pub(crate) fn from_toml(toml: &str, dir: &Path) -> Result<Config, String> {\n+                let parsed: ::toml::Value =\n+                    toml.parse().map_err(|e| format!(\"Could not parse TOML: {}\", e))?;\n+                let mut err: String = String::new();\n+                {\n+                    let table = parsed\n+                        .as_table()\n+                        .ok_or(String::from(\"Parsed config was not table\"))?;\n+                    for key in table.keys() {\n+                        if !Config::is_valid_name(key) {\n+                            let msg = &format!(\"Warning: Unknown configuration option `{}`\\n\", key);\n+                            err.push_str(msg)\n+                        }\n+                    }\n+                }\n+                match parsed.try_into() {\n+                    Ok(parsed_config) => {\n+                        if !err.is_empty() {\n+                            eprint!(\"{}\", err);\n+                        }\n+                        Ok(Config::default().fill_from_parsed_config(parsed_config, dir: &Path))\n+                    }\n+                    Err(e) => {\n+                        err.push_str(\"Error: Decoding config file failed:\\n\");\n+                        err.push_str(format!(\"{}\\n\", e).as_str());\n+                        err.push_str(\"Please check your config file.\");\n+                        Err(err)\n+                    }\n+                }\n+            }\n+\n+            pub fn used_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: if self.$i.0.get() {\n+                                Some(self.$i.2.clone())\n+                            } else {\n+                                None\n+                            },\n+                    )+\n+                }\n+            }\n+\n+            pub fn all_options(&self) -> PartialConfig {\n+                PartialConfig {\n+                    $(\n+                        $i: Some(self.$i.2.clone()),\n+                    )+\n+                }\n+            }\n+\n+            pub fn override_value(&mut self, key: &str, val: &str)\n+            {\n+                match key {\n+                    $(\n+                        stringify!($i) => {\n+                            self.$i.1 = true;\n+                            self.$i.2 = val.parse::<$ty>()\n+                                .expect(&format!(\"Failed to parse override for {} (\\\"{}\\\") as a {}\",\n+                                                 stringify!($i),\n+                                                 val,\n+                                                 stringify!($ty)));\n+                        }\n+                    )+\n+                    _ => panic!(\"Unknown config key in override: {}\", key)\n+                }\n+\n+                match key {\n+                    \"max_width\" | \"use_small_heuristics\" => self.set_heuristics(),\n+                    \"license_template_path\" => self.set_license_template(),\n+                    &_ => (),\n+                }\n+            }\n+\n+            /// Construct a `Config` from the toml file specified at `file_path`.\n+            ///\n+            /// This method only looks at the provided path, for a method that\n+            /// searches parents for a `rustfmt.toml` see `from_resolved_toml_path`.\n+            ///\n+            /// Return a `Config` if the config could be read and parsed from\n+            /// the file, Error otherwise.\n+            pub(super) fn from_toml_path(file_path: &Path) -> Result<Config, Error> {\n+                let mut file = File::open(&file_path)?;\n+                let mut toml = String::new();\n+                file.read_to_string(&mut toml)?;\n+                Config::from_toml(&toml, file_path.parent().unwrap())\n+                    .map_err(|err| Error::new(ErrorKind::InvalidData, err))\n+            }\n+\n+            /// Resolve the config for input in `dir`.\n+            ///\n+            /// Searches for `rustfmt.toml` beginning with `dir`, and\n+            /// recursively checking parents of `dir` if no config file is found.\n+            /// If no config file exists in `dir` or in any parent, a\n+            /// default `Config` will be returned (and the returned path will be empty).\n+            ///\n+            /// Returns the `Config` to use, and the path of the project file if there was\n+            /// one.\n+            pub(super) fn from_resolved_toml_path(\n+                dir: &Path,\n+            ) -> Result<(Config, Option<PathBuf>), Error> {\n+                /// Try to find a project file in the given directory and its parents.\n+                /// Returns the path of a the nearest project file if one exists,\n+                /// or `None` if no project file was found.\n+                fn resolve_project_file(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+                    let mut current = if dir.is_relative() {\n+                        env::current_dir()?.join(dir)\n+                    } else {\n+                        dir.to_path_buf()\n+                    };\n+\n+                    current = fs::canonicalize(current)?;\n+\n+                    loop {\n+                        match get_toml_path(&current) {\n+                            Ok(Some(path)) => return Ok(Some(path)),\n+                            Err(e) => return Err(e),\n+                            _ => ()\n+                        }\n+\n+                        // If the current directory has no parent, we're done searching.\n+                        if !current.pop() {\n+                            return Ok(None);\n+                        }\n+                    }\n+                }\n+\n+                match resolve_project_file(dir)? {\n+                    None => Ok((Config::default(), None)),\n+                    Some(path) => Config::from_toml_path(&path).map(|config| (config, Some(path))),\n+                }\n+            }\n+\n+            pub fn is_hidden_option(name: &str) -> bool {\n+                const HIDE_OPTIONS: [&str; 4] =\n+                    [\"verbose\", \"verbose_diff\", \"file_lines\", \"width_heuristics\"];\n+                HIDE_OPTIONS.contains(&name)\n+            }\n+\n+            pub fn print_docs(out: &mut Write, include_unstable: bool) {\n+                use std::cmp;\n+                let max = 0;\n+                $( let max = cmp::max(max, stringify!($i).len()+1); )+\n+                let mut space_str = String::with_capacity(max);\n+                for _ in 0..max {\n+                    space_str.push(' ');\n+                }\n+                writeln!(out, \"Configuration Options:\").unwrap();\n+                $(\n+                    if $stb || include_unstable {\n+                        let name_raw = stringify!($i);\n+\n+                        if !Config::is_hidden_option(name_raw) {\n+                            let mut name_out = String::with_capacity(max);\n+                            for _ in name_raw.len()..max-1 {\n+                                name_out.push(' ')\n+                            }\n+                            name_out.push_str(name_raw);\n+                            name_out.push(' ');\n+                            writeln!(out,\n+                                    \"{}{} Default: {:?}{}\",\n+                                    name_out,\n+                                    <$ty>::doc_hint(),\n+                                    $def,\n+                                    if !$stb { \" (unstable)\" } else { \"\" }).unwrap();\n+                            $(\n+                                writeln!(out, \"{}{}\", space_str, $dstring).unwrap();\n+                            )+\n+                            writeln!(out).unwrap();\n+                        }\n+                    }\n+                )+\n+            }\n+\n+            fn set_heuristics(&mut self) {\n+                if self.use_small_heuristics.2 == Heuristics::Default {\n+                    let max_width = self.max_width.2;\n+                    self.set().width_heuristics(WidthHeuristics::scaled(max_width));\n+                } else if self.use_small_heuristics.2 == Heuristics::Max {\n+                    let max_width = self.max_width.2;\n+                    self.set().width_heuristics(WidthHeuristics::set(max_width));\n+                } else {\n+                    self.set().width_heuristics(WidthHeuristics::null());\n+                }\n+            }\n+\n+            fn set_license_template(&mut self) {\n+                if self.was_set().license_template_path() {\n+                    let lt_path = self.license_template_path();\n+                    match license::load_and_compile_template(&lt_path) {\n+                        Ok(re) => self.license_template = Some(re),\n+                        Err(msg) => eprintln!(\"Warning for license template file {:?}: {}\",\n+                                              lt_path, msg),\n+                    }\n+                }\n+            }\n+\n+            fn set_ignore(&mut self, dir: &Path) {\n+                self.ignore.2.add_prefix(dir);\n+            }\n+\n+            /// Returns true if the config key was explicitely set and is the default value.\n+            pub fn is_default(&self, key: &str) -> bool {\n+                $(\n+                    if let stringify!($i) = key {\n+                        return self.$i.1 && self.$i.2 == $def;\n+                    }\n+                 )+\n+                false\n+            }\n+        }\n+\n+        // Template for the default configuration\n+        impl Default for Config {\n+            fn default() -> Config {\n+                Config {\n+                    license_template: None,\n+                    $(\n+                        $i: (Cell::new(false), false, $def, $stb),\n+                    )+\n+                }\n+            }\n+        }\n+    )\n+}"}, {"sha": "e113118c64303dd2cf00090da70a3c6ebc301079", "filename": "config/file_lines.rs", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Ffile_lines.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,422 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains types and functions to support formatting specific line ranges.\n+\n+use std::collections::HashMap;\n+use std::path::PathBuf;\n+use std::rc::Rc;\n+use std::{cmp, fmt, iter, str};\n+\n+use serde::de::{Deserialize, Deserializer};\n+use serde::ser::{self, Serialize, Serializer};\n+use serde_json as json;\n+\n+use syntax::source_map::{self, SourceFile};\n+\n+/// A range of lines in a file, inclusive of both ends.\n+pub struct LineRange {\n+    pub file: Rc<SourceFile>,\n+    pub lo: usize,\n+    pub hi: usize,\n+}\n+\n+/// Defines the name of an input - either a file or stdin.\n+#[derive(Clone, Debug, Eq, PartialEq, Hash, Ord, PartialOrd)]\n+pub enum FileName {\n+    Real(PathBuf),\n+    Stdin,\n+}\n+\n+impl From<source_map::FileName> for FileName {\n+    fn from(name: source_map::FileName) -> FileName {\n+        match name {\n+            source_map::FileName::Real(p) => FileName::Real(p),\n+            source_map::FileName::Custom(ref f) if f == \"stdin\" => FileName::Stdin,\n+            _ => unreachable!(),\n+        }\n+    }\n+}\n+\n+impl fmt::Display for FileName {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self {\n+            FileName::Real(p) => write!(f, \"{}\", p.to_str().unwrap()),\n+            FileName::Stdin => write!(f, \"stdin\"),\n+        }\n+    }\n+}\n+\n+impl<'de> Deserialize<'de> for FileName {\n+    fn deserialize<D>(deserializer: D) -> Result<FileName, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        let s = String::deserialize(deserializer)?;\n+        if s == \"stdin\" {\n+            Ok(FileName::Stdin)\n+        } else {\n+            Ok(FileName::Real(s.into()))\n+        }\n+    }\n+}\n+\n+impl Serialize for FileName {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        let s = match self {\n+            FileName::Stdin => Ok(\"stdin\"),\n+            FileName::Real(path) => path\n+                .to_str()\n+                .ok_or_else(|| ser::Error::custom(\"path can't be serialized as UTF-8 string\")),\n+        };\n+\n+        s.and_then(|s| serializer.serialize_str(s))\n+    }\n+}\n+\n+impl LineRange {\n+    pub fn file_name(&self) -> FileName {\n+        self.file.name.clone().into()\n+    }\n+}\n+\n+/// A range that is inclusive of both ends.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq, PartialOrd, Ord, Deserialize)]\n+pub struct Range {\n+    lo: usize,\n+    hi: usize,\n+}\n+\n+impl<'a> From<&'a LineRange> for Range {\n+    fn from(range: &'a LineRange) -> Range {\n+        Range::new(range.lo, range.hi)\n+    }\n+}\n+\n+impl Range {\n+    pub fn new(lo: usize, hi: usize) -> Range {\n+        Range { lo, hi }\n+    }\n+\n+    fn is_empty(self) -> bool {\n+        self.lo > self.hi\n+    }\n+\n+    #[allow(dead_code)]\n+    fn contains(self, other: Range) -> bool {\n+        if other.is_empty() {\n+            true\n+        } else {\n+            !self.is_empty() && self.lo <= other.lo && self.hi >= other.hi\n+        }\n+    }\n+\n+    fn intersects(self, other: Range) -> bool {\n+        if self.is_empty() || other.is_empty() {\n+            false\n+        } else {\n+            (self.lo <= other.hi && other.hi <= self.hi)\n+                || (other.lo <= self.hi && self.hi <= other.hi)\n+        }\n+    }\n+\n+    fn adjacent_to(self, other: Range) -> bool {\n+        if self.is_empty() || other.is_empty() {\n+            false\n+        } else {\n+            self.hi + 1 == other.lo || other.hi + 1 == self.lo\n+        }\n+    }\n+\n+    /// Returns a new `Range` with lines from `self` and `other` if they were adjacent or\n+    /// intersect; returns `None` otherwise.\n+    fn merge(self, other: Range) -> Option<Range> {\n+        if self.adjacent_to(other) || self.intersects(other) {\n+            Some(Range::new(\n+                cmp::min(self.lo, other.lo),\n+                cmp::max(self.hi, other.hi),\n+            ))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// A set of lines in files.\n+///\n+/// It is represented as a multimap keyed on file names, with values a collection of\n+/// non-overlapping ranges sorted by their start point. An inner `None` is interpreted to mean all\n+/// lines in all files.\n+#[derive(Clone, Debug, Default, PartialEq)]\n+pub struct FileLines(Option<HashMap<FileName, Vec<Range>>>);\n+\n+/// Normalizes the ranges so that the invariants for `FileLines` hold: ranges are non-overlapping,\n+/// and ordered by their start point.\n+fn normalize_ranges(ranges: &mut HashMap<FileName, Vec<Range>>) {\n+    for ranges in ranges.values_mut() {\n+        ranges.sort();\n+        let mut result = vec![];\n+        {\n+            let mut iter = ranges.into_iter().peekable();\n+            while let Some(next) = iter.next() {\n+                let mut next = *next;\n+                while let Some(&&mut peek) = iter.peek() {\n+                    if let Some(merged) = next.merge(peek) {\n+                        iter.next().unwrap();\n+                        next = merged;\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                result.push(next)\n+            }\n+        }\n+        *ranges = result;\n+    }\n+}\n+\n+impl FileLines {\n+    /// Creates a `FileLines` that contains all lines in all files.\n+    pub(crate) fn all() -> FileLines {\n+        FileLines(None)\n+    }\n+\n+    /// Returns true if this `FileLines` contains all lines in all files.\n+    pub(crate) fn is_all(&self) -> bool {\n+        self.0.is_none()\n+    }\n+\n+    pub fn from_ranges(mut ranges: HashMap<FileName, Vec<Range>>) -> FileLines {\n+        normalize_ranges(&mut ranges);\n+        FileLines(Some(ranges))\n+    }\n+\n+    /// Returns an iterator over the files contained in `self`.\n+    pub fn files(&self) -> Files {\n+        Files(self.0.as_ref().map(|m| m.keys()))\n+    }\n+\n+    /// Returns JSON representation as accepted by the `--file-lines JSON` arg.\n+    pub fn to_json_spans(&self) -> Vec<JsonSpan> {\n+        match &self.0 {\n+            None => vec![],\n+            Some(file_ranges) => file_ranges\n+                .iter()\n+                .flat_map(|(file, ranges)| ranges.iter().map(move |r| (file, r)))\n+                .map(|(file, range)| JsonSpan {\n+                    file: file.to_owned(),\n+                    range: (range.lo, range.hi),\n+                }).collect(),\n+        }\n+    }\n+\n+    /// Returns true if `self` includes all lines in all files. Otherwise runs `f` on all ranges in\n+    /// the designated file (if any) and returns true if `f` ever does.\n+    fn file_range_matches<F>(&self, file_name: &FileName, f: F) -> bool\n+    where\n+        F: FnMut(&Range) -> bool,\n+    {\n+        let map = match self.0 {\n+            // `None` means \"all lines in all files\".\n+            None => return true,\n+            Some(ref map) => map,\n+        };\n+\n+        match canonicalize_path_string(file_name).and_then(|file| map.get(&file)) {\n+            Some(ranges) => ranges.iter().any(f),\n+            None => false,\n+        }\n+    }\n+\n+    /// Returns true if `range` is fully contained in `self`.\n+    #[allow(dead_code)]\n+    pub(crate) fn contains(&self, range: &LineRange) -> bool {\n+        self.file_range_matches(&range.file_name(), |r| r.contains(Range::from(range)))\n+    }\n+\n+    /// Returns true if any lines in `range` are in `self`.\n+    pub(crate) fn intersects(&self, range: &LineRange) -> bool {\n+        self.file_range_matches(&range.file_name(), |r| r.intersects(Range::from(range)))\n+    }\n+\n+    /// Returns true if `line` from `file_name` is in `self`.\n+    pub(crate) fn contains_line(&self, file_name: &FileName, line: usize) -> bool {\n+        self.file_range_matches(file_name, |r| r.lo <= line && r.hi >= line)\n+    }\n+\n+    /// Returns true if all the lines between `lo` and `hi` from `file_name` are in `self`.\n+    pub(crate) fn contains_range(&self, file_name: &FileName, lo: usize, hi: usize) -> bool {\n+        self.file_range_matches(file_name, |r| r.contains(Range::new(lo, hi)))\n+    }\n+}\n+\n+/// `FileLines` files iterator.\n+pub struct Files<'a>(Option<::std::collections::hash_map::Keys<'a, FileName, Vec<Range>>>);\n+\n+impl<'a> iter::Iterator for Files<'a> {\n+    type Item = &'a FileName;\n+\n+    fn next(&mut self) -> Option<&'a FileName> {\n+        self.0.as_mut().and_then(Iterator::next)\n+    }\n+}\n+\n+fn canonicalize_path_string(file: &FileName) -> Option<FileName> {\n+    match *file {\n+        FileName::Real(ref path) => path.canonicalize().ok().map(FileName::Real),\n+        _ => Some(file.clone()),\n+    }\n+}\n+\n+// This impl is needed for `Config::override_value` to work for use in tests.\n+impl str::FromStr for FileLines {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<FileLines, String> {\n+        let v: Vec<JsonSpan> = json::from_str(s).map_err(|e| e.to_string())?;\n+        let mut m = HashMap::new();\n+        for js in v {\n+            let (s, r) = JsonSpan::into_tuple(js)?;\n+            m.entry(s).or_insert_with(|| vec![]).push(r);\n+        }\n+        Ok(FileLines::from_ranges(m))\n+    }\n+}\n+\n+// For JSON decoding.\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Debug, Deserialize, Serialize)]\n+pub struct JsonSpan {\n+    file: FileName,\n+    range: (usize, usize),\n+}\n+\n+impl JsonSpan {\n+    fn into_tuple(self) -> Result<(FileName, Range), String> {\n+        let (lo, hi) = self.range;\n+        let canonical = canonicalize_path_string(&self.file)\n+            .ok_or_else(|| format!(\"Can't canonicalize {}\", &self.file))?;\n+        Ok((canonical, Range::new(lo, hi)))\n+    }\n+}\n+\n+// This impl is needed for inclusion in the `Config` struct. We don't have a toml representation\n+// for `FileLines`, so it will just panic instead.\n+impl<'de> ::serde::de::Deserialize<'de> for FileLines {\n+    fn deserialize<D>(_: D) -> Result<Self, D::Error>\n+    where\n+        D: ::serde::de::Deserializer<'de>,\n+    {\n+        panic!(\n+            \"FileLines cannot be deserialized from a project rustfmt.toml file: please \\\n+             specify it via the `--file-lines` option instead\"\n+        );\n+    }\n+}\n+\n+// We also want to avoid attempting to serialize a FileLines to toml. The\n+// `Config` struct should ensure this impl is never reached.\n+impl ::serde::ser::Serialize for FileLines {\n+    fn serialize<S>(&self, _: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: ::serde::ser::Serializer,\n+    {\n+        unreachable!(\"FileLines cannot be serialized. This is a rustfmt bug.\");\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::Range;\n+\n+    #[test]\n+    fn test_range_intersects() {\n+        assert!(Range::new(1, 2).intersects(Range::new(1, 1)));\n+        assert!(Range::new(1, 2).intersects(Range::new(2, 2)));\n+        assert!(!Range::new(1, 2).intersects(Range::new(0, 0)));\n+        assert!(!Range::new(1, 2).intersects(Range::new(3, 10)));\n+        assert!(!Range::new(1, 3).intersects(Range::new(5, 5)));\n+    }\n+\n+    #[test]\n+    fn test_range_adjacent_to() {\n+        assert!(!Range::new(1, 2).adjacent_to(Range::new(1, 1)));\n+        assert!(!Range::new(1, 2).adjacent_to(Range::new(2, 2)));\n+        assert!(Range::new(1, 2).adjacent_to(Range::new(0, 0)));\n+        assert!(Range::new(1, 2).adjacent_to(Range::new(3, 10)));\n+        assert!(!Range::new(1, 3).adjacent_to(Range::new(5, 5)));\n+    }\n+\n+    #[test]\n+    fn test_range_contains() {\n+        assert!(Range::new(1, 2).contains(Range::new(1, 1)));\n+        assert!(Range::new(1, 2).contains(Range::new(2, 2)));\n+        assert!(!Range::new(1, 2).contains(Range::new(0, 0)));\n+        assert!(!Range::new(1, 2).contains(Range::new(3, 10)));\n+    }\n+\n+    #[test]\n+    fn test_range_merge() {\n+        assert_eq!(None, Range::new(1, 3).merge(Range::new(5, 5)));\n+        assert_eq!(None, Range::new(4, 7).merge(Range::new(0, 1)));\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(4, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(5, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 5).merge(Range::new(6, 7))\n+        );\n+        assert_eq!(\n+            Some(Range::new(3, 7)),\n+            Range::new(3, 7).merge(Range::new(4, 5))\n+        );\n+    }\n+\n+    use super::json::{self, json};\n+    use super::{FileLines, FileName};\n+    use std::{collections::HashMap, path::PathBuf};\n+\n+    #[test]\n+    fn file_lines_to_json() {\n+        let ranges: HashMap<FileName, Vec<Range>> = [\n+            (\n+                FileName::Real(PathBuf::from(\"src/main.rs\")),\n+                vec![Range::new(1, 3), Range::new(5, 7)],\n+            ),\n+            (\n+                FileName::Real(PathBuf::from(\"src/lib.rs\")),\n+                vec![Range::new(1, 7)],\n+            ),\n+        ]\n+            .iter()\n+            .cloned()\n+            .collect();\n+\n+        let file_lines = FileLines::from_ranges(ranges);\n+        let mut spans = file_lines.to_json_spans();\n+        spans.sort();\n+        let json = json::to_value(&spans).unwrap();\n+        assert_eq!(\n+            json,\n+            json! {[\n+                {\"file\": \"src/lib.rs\",  \"range\": [1, 7]},\n+                {\"file\": \"src/main.rs\", \"range\": [1, 3]},\n+                {\"file\": \"src/main.rs\", \"range\": [5, 7]},\n+            ]}\n+        );\n+    }\n+}"}, {"sha": "630399319c1b5ab97e8e5149f3964f5a03eb9e77", "filename": "config/license.rs", "status": "added", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Flicense.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Flicense.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Flicense.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,266 @@\n+use std::fmt;\n+use std::fs::File;\n+use std::io;\n+use std::io::Read;\n+\n+use regex;\n+use regex::Regex;\n+\n+#[derive(Debug)]\n+pub enum LicenseError {\n+    IO(io::Error),\n+    Regex(regex::Error),\n+    Parse(String),\n+}\n+\n+impl fmt::Display for LicenseError {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            LicenseError::IO(ref err) => err.fmt(f),\n+            LicenseError::Regex(ref err) => err.fmt(f),\n+            LicenseError::Parse(ref err) => write!(f, \"parsing failed, {}\", err),\n+        }\n+    }\n+}\n+\n+impl From<io::Error> for LicenseError {\n+    fn from(err: io::Error) -> LicenseError {\n+        LicenseError::IO(err)\n+    }\n+}\n+\n+impl From<regex::Error> for LicenseError {\n+    fn from(err: regex::Error) -> LicenseError {\n+        LicenseError::Regex(err)\n+    }\n+}\n+\n+// the template is parsed using a state machine\n+enum ParsingState {\n+    Lit,\n+    LitEsc,\n+    // the u32 keeps track of brace nesting\n+    Re(u32),\n+    ReEsc(u32),\n+    Abort(String),\n+}\n+\n+use self::ParsingState::*;\n+\n+pub struct TemplateParser {\n+    parsed: String,\n+    buffer: String,\n+    state: ParsingState,\n+    linum: u32,\n+    open_brace_line: u32,\n+}\n+\n+impl TemplateParser {\n+    fn new() -> Self {\n+        Self {\n+            parsed: \"^\".to_owned(),\n+            buffer: String::new(),\n+            state: Lit,\n+            linum: 1,\n+            // keeps track of last line on which a regex placeholder was started\n+            open_brace_line: 0,\n+        }\n+    }\n+\n+    /// Convert a license template into a string which can be turned into a regex.\n+    ///\n+    /// The license template could use regex syntax directly, but that would require a lot of manual\n+    /// escaping, which is inconvenient. It is therefore literal by default, with optional regex\n+    /// subparts delimited by `{` and `}`. Additionally:\n+    ///\n+    /// - to insert literal `{`, `}` or `\\`, escape it with `\\`\n+    /// - an empty regex placeholder (`{}`) is shorthand for `{.*?}`\n+    ///\n+    /// This function parses this input format and builds a properly escaped *string* representation\n+    /// of the equivalent regular expression. It **does not** however guarantee that the returned\n+    /// string is a syntactically valid regular expression.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```ignore\n+    /// assert_eq!(\n+    ///     TemplateParser::parse(\n+    ///         r\"\n+    /// // Copyright {\\d+} The \\} Rust \\\\ Project \\{ Developers. See the {([A-Z]+)}\n+    /// // file at the top-level directory of this distribution and at\n+    /// // {}.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+    /// // http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+    /// // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+    /// // option. This file may not be copied, modified, or distributed\n+    /// // except according to those terms.\n+    /// \"\n+    ///     ).unwrap(),\n+    ///     r\"^\n+    /// // Copyright \\d+ The \\} Rust \\\\ Project \\{ Developers\\. See the ([A-Z]+)\n+    /// // file at the top\\-level directory of this distribution and at\n+    /// // .*?\\.\n+    /// //\n+    /// // Licensed under the Apache License, Version 2\\.0 <LICENSE\\-APACHE or\n+    /// // http://www\\.apache\\.org/licenses/LICENSE\\-2\\.0> or the MIT license\n+    /// // <LICENSE\\-MIT or http://opensource\\.org/licenses/MIT>, at your\n+    /// // option\\. This file may not be copied, modified, or distributed\n+    /// // except according to those terms\\.\n+    /// \"\n+    /// );\n+    /// ```\n+    pub fn parse(template: &str) -> Result<String, LicenseError> {\n+        let mut parser = Self::new();\n+        for chr in template.chars() {\n+            if chr == '\\n' {\n+                parser.linum += 1;\n+            }\n+            parser.state = match parser.state {\n+                Lit => parser.trans_from_lit(chr),\n+                LitEsc => parser.trans_from_litesc(chr),\n+                Re(brace_nesting) => parser.trans_from_re(chr, brace_nesting),\n+                ReEsc(brace_nesting) => parser.trans_from_reesc(chr, brace_nesting),\n+                Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            };\n+        }\n+        // check if we've ended parsing in a valid state\n+        match parser.state {\n+            Abort(msg) => return Err(LicenseError::Parse(msg)),\n+            Re(_) | ReEsc(_) => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"escape or balance opening brace on l. {}\",\n+                    parser.open_brace_line\n+                )));\n+            }\n+            LitEsc => {\n+                return Err(LicenseError::Parse(format!(\n+                    \"incomplete escape sequence on l. {}\",\n+                    parser.linum\n+                )))\n+            }\n+            _ => (),\n+        }\n+        parser.parsed.push_str(&regex::escape(&parser.buffer));\n+\n+        Ok(parser.parsed)\n+    }\n+\n+    fn trans_from_lit(&mut self, chr: char) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.parsed.push_str(&regex::escape(&self.buffer));\n+                self.buffer.clear();\n+                self.open_brace_line = self.linum;\n+                Re(1)\n+            }\n+            '}' => Abort(format!(\n+                \"escape or balance closing brace on l. {}\",\n+                self.linum\n+            )),\n+            '\\\\' => LitEsc,\n+            _ => {\n+                self.buffer.push(chr);\n+                Lit\n+            }\n+        }\n+    }\n+\n+    fn trans_from_litesc(&mut self, chr: char) -> ParsingState {\n+        self.buffer.push(chr);\n+        Lit\n+    }\n+\n+    fn trans_from_re(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        match chr {\n+            '{' => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting + 1)\n+            }\n+            '}' => {\n+                match brace_nesting {\n+                    1 => {\n+                        // default regex for empty placeholder {}\n+                        if self.buffer.is_empty() {\n+                            self.parsed.push_str(\".*?\");\n+                        } else {\n+                            self.parsed.push_str(&self.buffer);\n+                        }\n+                        self.buffer.clear();\n+                        Lit\n+                    }\n+                    _ => {\n+                        self.buffer.push(chr);\n+                        Re(brace_nesting - 1)\n+                    }\n+                }\n+            }\n+            '\\\\' => {\n+                self.buffer.push(chr);\n+                ReEsc(brace_nesting)\n+            }\n+            _ => {\n+                self.buffer.push(chr);\n+                Re(brace_nesting)\n+            }\n+        }\n+    }\n+\n+    fn trans_from_reesc(&mut self, chr: char, brace_nesting: u32) -> ParsingState {\n+        self.buffer.push(chr);\n+        Re(brace_nesting)\n+    }\n+}\n+\n+pub fn load_and_compile_template(path: &str) -> Result<Regex, LicenseError> {\n+    let mut lt_file = File::open(&path)?;\n+    let mut lt_str = String::new();\n+    lt_file.read_to_string(&mut lt_str)?;\n+    let lt_parsed = TemplateParser::parse(&lt_str)?;\n+    Ok(Regex::new(&lt_parsed)?)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::TemplateParser;\n+\n+    #[test]\n+    fn test_parse_license_template() {\n+        assert_eq!(\n+            TemplateParser::parse(\"literal (.*)\").unwrap(),\n+            r\"^literal \\(\\.\\*\\)\"\n+        );\n+        assert_eq!(\n+            TemplateParser::parse(r\"escaping \\}\").unwrap(),\n+            r\"^escaping \\}\"\n+        );\n+        assert!(TemplateParser::parse(\"unbalanced } without escape\").is_err());\n+        assert_eq!(\n+            TemplateParser::parse(r\"{\\d+} place{-?}holder{s?}\").unwrap(),\n+            r\"^\\d+ place-?holders?\"\n+        );\n+        assert_eq!(TemplateParser::parse(\"default {}\").unwrap(), \"^default .*?\");\n+        assert_eq!(\n+            TemplateParser::parse(r\"unbalanced nested braces {\\{{3}}\").unwrap(),\n+            r\"^unbalanced nested braces \\{{3}\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error }\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance closing brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(\"parsing error {\\nsecond line\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, escape or balance opening brace on l. 1\"\n+        );\n+        assert_eq!(\n+            &TemplateParser::parse(r\"parsing error \\\")\n+                .unwrap_err()\n+                .to_string(),\n+            \"parsing failed, incomplete escape sequence on l. 1\"\n+        );\n+    }\n+}"}, {"sha": "04406e8d5669636ea40955ed0b654297a3a8e8ab", "filename": "config/lists.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Flists.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Configuration options related to rewriting a list.\n+\n+use config::config_type::ConfigType;\n+use config::IndentStyle;\n+\n+/// The definitive formatting tactic for lists.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum DefinitiveListTactic {\n+    Vertical,\n+    Horizontal,\n+    Mixed,\n+    /// Special case tactic for `format!()`, `write!()` style macros.\n+    SpecialMacro(usize),\n+}\n+\n+impl DefinitiveListTactic {\n+    pub fn ends_with_newline(&self, indent_style: IndentStyle) -> bool {\n+        match indent_style {\n+            IndentStyle::Block => *self != DefinitiveListTactic::Horizontal,\n+            IndentStyle::Visual => false,\n+        }\n+    }\n+}\n+\n+/// Formatting tactic for lists. This will be cast down to a\n+/// `DefinitiveListTactic` depending on the number and length of the items and\n+/// their comments.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum ListTactic {\n+    // One item per row.\n+    Vertical,\n+    // All items on one row.\n+    Horizontal,\n+    // Try Horizontal layout, if that fails then vertical.\n+    HorizontalVertical,\n+    // HorizontalVertical with a soft limit of n characters.\n+    LimitedHorizontalVertical(usize),\n+    // Pack as many items as possible per row over (possibly) many rows.\n+    Mixed,\n+}\n+\n+impl_enum_serialize_and_deserialize!(ListTactic, Vertical, Horizontal, HorizontalVertical, Mixed);\n+\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorTactic {\n+    Always,\n+    Never,\n+    Vertical,\n+}\n+\n+impl_enum_serialize_and_deserialize!(SeparatorTactic, Always, Never, Vertical);\n+\n+impl SeparatorTactic {\n+    pub fn from_bool(b: bool) -> SeparatorTactic {\n+        if b {\n+            SeparatorTactic::Always\n+        } else {\n+            SeparatorTactic::Never\n+        }\n+    }\n+}\n+\n+/// Where to put separator.\n+#[derive(Eq, PartialEq, Debug, Copy, Clone)]\n+pub enum SeparatorPlace {\n+    Front,\n+    Back,\n+}\n+\n+impl_enum_serialize_and_deserialize!(SeparatorPlace, Front, Back);\n+\n+impl SeparatorPlace {\n+    pub fn is_front(&self) -> bool {\n+        *self == SeparatorPlace::Front\n+    }\n+\n+    pub fn is_back(&self) -> bool {\n+        *self == SeparatorPlace::Back\n+    }\n+\n+    pub fn from_tactic(\n+        default: SeparatorPlace,\n+        tactic: DefinitiveListTactic,\n+        sep: &str,\n+    ) -> SeparatorPlace {\n+        match tactic {\n+            DefinitiveListTactic::Vertical => default,\n+            _ => if sep == \",\" {\n+                SeparatorPlace::Back\n+            } else {\n+                default\n+            },\n+        }\n+    }\n+}"}, {"sha": "f240c7b13c68b1ffcf0df9f86a7ba3e0b0b3b085", "filename": "config/mod.rs", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Fmod.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,360 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use regex::Regex;\n+use std::cell::Cell;\n+use std::default::Default;\n+use std::fs::File;\n+use std::io::{Error, ErrorKind, Read};\n+use std::path::{Path, PathBuf};\n+use std::{env, fs};\n+\n+use config::config_type::ConfigType;\n+pub use config::file_lines::{FileLines, FileName, Range};\n+pub use config::lists::*;\n+pub use config::options::*;\n+\n+#[macro_use]\n+pub mod config_type;\n+#[macro_use]\n+pub mod options;\n+\n+pub mod file_lines;\n+pub mod license;\n+pub mod lists;\n+\n+/// This macro defines configuration options used in rustfmt. Each option\n+/// is defined as follows:\n+///\n+/// `name: value type, default value, is stable, description;`\n+create_config! {\n+    // Fundamental stuff\n+    max_width: usize, 100, true, \"Maximum width of each line\";\n+    hard_tabs: bool, false, true, \"Use tab characters for indentation, spaces for alignment\";\n+    tab_spaces: usize, 4, true, \"Number of spaces per tab\";\n+    newline_style: NewlineStyle, NewlineStyle::Auto, true, \"Unix or Windows line endings\";\n+    use_small_heuristics: Heuristics, Heuristics::Default, true, \"Whether to use different \\\n+        formatting for items and expressions if they satisfy a heuristic notion of 'small'\";\n+    indent_style: IndentStyle, IndentStyle::Block, false, \"How do we indent expressions or items\";\n+\n+    // Comments. macros, and strings\n+    wrap_comments: bool, false, false, \"Break comments to fit on the line\";\n+    comment_width: usize, 80, false,\n+        \"Maximum length of comments. No effect unless wrap_comments = true\";\n+    normalize_comments: bool, false, false, \"Convert /* */ comments to // comments where possible\";\n+    license_template_path: String, String::default(), false,\n+        \"Beginning of file must match license template\";\n+    format_strings: bool, false, false, \"Format string literals where necessary\";\n+    format_macro_matchers: bool, false, false,\n+        \"Format the metavariable matching patterns in macros\";\n+    format_macro_bodies: bool, true, false, \"Format the bodies of macros\";\n+\n+    // Single line expressions and items\n+    empty_item_single_line: bool, true, false,\n+        \"Put empty-body functions and impls on a single line\";\n+    struct_lit_single_line: bool, true, false,\n+        \"Put small struct literals on a single line\";\n+    fn_single_line: bool, false, false, \"Put single-expression functions on a single line\";\n+    where_single_line: bool, false, false, \"Force where clauses to be on a single line\";\n+\n+    // Imports\n+    imports_indent: IndentStyle, IndentStyle::Block, false, \"Indent of imports\";\n+    imports_layout: ListTactic, ListTactic::Mixed, false, \"Item layout inside a import block\";\n+    merge_imports: bool, false, false, \"Merge imports\";\n+\n+    // Ordering\n+    reorder_imports: bool, true, true, \"Reorder import and extern crate statements alphabetically\";\n+    reorder_modules: bool, true, true, \"Reorder module statements alphabetically in group\";\n+    reorder_impl_items: bool, false, false, \"Reorder impl items\";\n+\n+    // Spaces around punctuation\n+    type_punctuation_density: TypeDensity, TypeDensity::Wide, false,\n+        \"Determines if '+' or '=' are wrapped in spaces in the punctuation of types\";\n+    space_before_colon: bool, false, false, \"Leave a space before the colon\";\n+    space_after_colon: bool, true, false, \"Leave a space after the colon\";\n+    spaces_around_ranges: bool, false, false, \"Put spaces around the  .. and ..= range operators\";\n+    binop_separator: SeparatorPlace, SeparatorPlace::Front, false,\n+        \"Where to put a binary operator when a binary expression goes multiline\";\n+\n+    // Misc.\n+    remove_nested_parens: bool, true, true, \"Remove nested parens\";\n+    combine_control_expr: bool, true, false, \"Combine control expressions with function calls\";\n+    struct_field_align_threshold: usize, 0, false, \"Align struct fields if their diffs fits within \\\n+                                             threshold\";\n+    match_arm_blocks: bool, true, false, \"Wrap the body of arms in blocks when it does not fit on \\\n+        the same line with the pattern of arms\";\n+    force_multiline_blocks: bool, false, false,\n+        \"Force multiline closure bodies and match arms to be wrapped in a block\";\n+    fn_args_density: Density, Density::Tall, false, \"Argument density in functions\";\n+    brace_style: BraceStyle, BraceStyle::SameLineWhere, false, \"Brace style for items\";\n+    control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine, false,\n+        \"Brace style for control flow constructs\";\n+    trailing_semicolon: bool, true, false,\n+        \"Add trailing semicolon after break, continue and return\";\n+    trailing_comma: SeparatorTactic, SeparatorTactic::Vertical, false,\n+        \"How to handle trailing commas for lists\";\n+    match_block_trailing_comma: bool, false, false,\n+        \"Put a trailing comma after a block based match arm (non-block arms are not affected)\";\n+    blank_lines_upper_bound: usize, 1, false,\n+        \"Maximum number of blank lines which can be put between items\";\n+    blank_lines_lower_bound: usize, 0, false,\n+        \"Minimum number of blank lines which must be put between items\";\n+    edition: Edition, Edition::Edition2015, false, \"The edition of the parser (RFC 2052)\";\n+\n+    // Options that can change the source code beyond whitespace/blocks (somewhat linty things)\n+    merge_derives: bool, true, true, \"Merge multiple `#[derive(...)]` into a single one\";\n+    use_try_shorthand: bool, false, true, \"Replace uses of the try! macro by the ? shorthand\";\n+    use_field_init_shorthand: bool, false, true, \"Use field initialization shorthand if possible\";\n+    force_explicit_abi: bool, true, true, \"Always print the abi for extern items\";\n+    condense_wildcard_suffixes: bool, false, false, \"Replace strings of _ wildcards by a single .. \\\n+                                                     in tuple patterns\";\n+\n+    // Control options (changes the operation of rustfmt, rather than the formatting)\n+    color: Color, Color::Auto, false,\n+        \"What Color option to use when none is supplied: Always, Never, Auto\";\n+    required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n+        \"Require a specific version of rustfmt\";\n+    unstable_features: bool, false, false,\n+            \"Enables unstable features. Only available on nightly channel\";\n+    disable_all_formatting: bool, false, false, \"Don't reformat anything\";\n+    skip_children: bool, false, false, \"Don't reformat out of line modules\";\n+    hide_parse_errors: bool, false, false, \"Hide errors from the parser\";\n+    error_on_line_overflow: bool, false, false, \"Error if unable to get all lines within max_width\";\n+    error_on_unformatted: bool, false, false,\n+        \"Error if unable to get comments or string literals within max_width, \\\n+         or they are left with trailing whitespaces\";\n+    report_todo: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of TODO in source file comments\";\n+    report_fixme: ReportTactic, ReportTactic::Never, false,\n+        \"Report all, none or unnumbered occurrences of FIXME in source file comments\";\n+    ignore: IgnoreList, IgnoreList::default(), false,\n+        \"Skip formatting the specified files and directories\";\n+\n+    // Not user-facing\n+    verbose: Verbosity, Verbosity::Normal, false, \"How much to information to emit to the user\";\n+    file_lines: FileLines, FileLines::all(), false,\n+        \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n+         via the --file-lines option\";\n+    width_heuristics: WidthHeuristics, WidthHeuristics::scaled(100), false,\n+        \"'small' heuristic values\";\n+    emit_mode: EmitMode, EmitMode::Files, false,\n+        \"What emit Mode to use when none is supplied\";\n+    make_backup: bool, false, false, \"Backup changed files\";\n+}\n+\n+/// Load a config by checking the client-supplied options and if appropriate, the\n+/// file system (including searching the file system for overrides).\n+pub fn load_config<O: CliOptions>(\n+    file_path: Option<&Path>,\n+    options: Option<O>,\n+) -> Result<(Config, Option<PathBuf>), Error> {\n+    let over_ride = match options {\n+        Some(ref opts) => config_path(opts)?,\n+        None => None,\n+    };\n+\n+    let result = if let Some(over_ride) = over_ride {\n+        Config::from_toml_path(over_ride.as_ref()).map(|p| (p, Some(over_ride.to_owned())))\n+    } else if let Some(file_path) = file_path {\n+        Config::from_resolved_toml_path(file_path)\n+    } else {\n+        Ok((Config::default(), None))\n+    };\n+\n+    result.map(|(mut c, p)| {\n+        if let Some(options) = options {\n+            options.apply_to(&mut c);\n+        }\n+        (c, p)\n+    })\n+}\n+\n+// Check for the presence of known config file names (`rustfmt.toml, `.rustfmt.toml`) in `dir`\n+//\n+// Return the path if a config file exists, empty if no file exists, and Error for IO errors\n+fn get_toml_path(dir: &Path) -> Result<Option<PathBuf>, Error> {\n+    const CONFIG_FILE_NAMES: [&str; 2] = [\".rustfmt.toml\", \"rustfmt.toml\"];\n+    for config_file_name in &CONFIG_FILE_NAMES {\n+        let config_file = dir.join(config_file_name);\n+        match fs::metadata(&config_file) {\n+            // Only return if it's a file to handle the unlikely situation of a directory named\n+            // `rustfmt.toml`.\n+            Ok(ref md) if md.is_file() => return Ok(Some(config_file)),\n+            // Return the error if it's something other than `NotFound`; otherwise we didn't\n+            // find the project file yet, and continue searching.\n+            Err(e) => {\n+                if e.kind() != ErrorKind::NotFound {\n+                    return Err(e);\n+                }\n+            }\n+            _ => {}\n+        }\n+    }\n+    Ok(None)\n+}\n+\n+fn config_path(options: &CliOptions) -> Result<Option<PathBuf>, Error> {\n+    let config_path_not_found = |path: &str| -> Result<Option<PathBuf>, Error> {\n+        Err(Error::new(\n+            ErrorKind::NotFound,\n+            format!(\n+                \"Error: unable to find a config file for the given path: `{}`\",\n+                path\n+            ),\n+        ))\n+    };\n+\n+    // Read the config_path and convert to parent dir if a file is provided.\n+    // If a config file cannot be found from the given path, return error.\n+    match options.config_path() {\n+        Some(path) if !path.exists() => config_path_not_found(path.to_str().unwrap()),\n+        Some(path) if path.is_dir() => {\n+            let config_file_path = get_toml_path(path)?;\n+            if config_file_path.is_some() {\n+                Ok(config_file_path)\n+            } else {\n+                config_path_not_found(path.to_str().unwrap())\n+            }\n+        }\n+        path => Ok(path.map(|p| p.to_owned())),\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use std::str;\n+\n+    #[allow(dead_code)]\n+    mod mock {\n+        use super::super::*;\n+\n+        create_config! {\n+            // Options that are used by the generated functions\n+            max_width: usize, 100, true, \"Maximum width of each line\";\n+            use_small_heuristics: Heuristics, Heuristics::Default, true,\n+                \"Whether to use different formatting for items and \\\n+                 expressions if they satisfy a heuristic notion of 'small'.\";\n+            license_template_path: String, String::default(), false,\n+                \"Beginning of file must match license template\";\n+            required_version: String, env!(\"CARGO_PKG_VERSION\").to_owned(), false,\n+                \"Require a specific version of rustfmt.\";\n+            ignore: IgnoreList, IgnoreList::default(), false,\n+                \"Skip formatting the specified files and directories.\";\n+            verbose: Verbosity, Verbosity::Normal, false,\n+                \"How much to information to emit to the user\";\n+            file_lines: FileLines, FileLines::all(), false,\n+                \"Lines to format; this is not supported in rustfmt.toml, and can only be specified \\\n+                    via the --file-lines option\";\n+            width_heuristics: WidthHeuristics, WidthHeuristics::scaled(100), false,\n+                \"'small' heuristic values\";\n+\n+            // Options that are used by the tests\n+            stable_option: bool, false, true, \"A stable option\";\n+            unstable_option: bool, false, false, \"An unstable option\";\n+        }\n+    }\n+\n+    #[test]\n+    fn test_config_set() {\n+        let mut config = Config::default();\n+        config.set().verbose(Verbosity::Quiet);\n+        assert_eq!(config.verbose(), Verbosity::Quiet);\n+        config.set().verbose(Verbosity::Normal);\n+        assert_eq!(config.verbose(), Verbosity::Normal);\n+    }\n+\n+    #[test]\n+    fn test_config_used_to_toml() {\n+        let config = Config::default();\n+\n+        let merge_derives = config.merge_derives();\n+        let skip_children = config.skip_children();\n+\n+        let used_options = config.used_options();\n+        let toml = used_options.to_toml().unwrap();\n+        assert_eq!(\n+            toml,\n+            format!(\n+                \"merge_derives = {}\\nskip_children = {}\\n\",\n+                merge_derives, skip_children,\n+            )\n+        );\n+    }\n+\n+    #[test]\n+    fn test_was_set() {\n+        use std::path::Path;\n+        let config = Config::from_toml(\"hard_tabs = true\", Path::new(\"\")).unwrap();\n+\n+        assert_eq!(config.was_set().hard_tabs(), true);\n+        assert_eq!(config.was_set().verbose(), false);\n+    }\n+\n+    #[test]\n+    fn test_print_docs_exclude_unstable() {\n+        use self::mock::Config;\n+\n+        let mut output = Vec::new();\n+        Config::print_docs(&mut output, false);\n+\n+        let s = str::from_utf8(&output).unwrap();\n+\n+        assert_eq!(s.contains(\"stable_option\"), true);\n+        assert_eq!(s.contains(\"unstable_option\"), false);\n+        assert_eq!(s.contains(\"(unstable)\"), false);\n+    }\n+\n+    #[test]\n+    fn test_print_docs_include_unstable() {\n+        use self::mock::Config;\n+\n+        let mut output = Vec::new();\n+        Config::print_docs(&mut output, true);\n+\n+        let s = str::from_utf8(&output).unwrap();\n+        assert_eq!(s.contains(\"stable_option\"), true);\n+        assert_eq!(s.contains(\"unstable_option\"), true);\n+        assert_eq!(s.contains(\"(unstable)\"), true);\n+    }\n+\n+    // FIXME(#2183) these tests cannot be run in parallel because they use env vars\n+    // #[test]\n+    // fn test_as_not_nightly_channel() {\n+    //     let mut config = Config::default();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    // }\n+\n+    // #[test]\n+    // fn test_as_nightly_channel() {\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     let mut config = Config::default();\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     config.set().unstable_features(true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+\n+    // #[test]\n+    // fn test_unstable_from_toml() {\n+    //     let mut config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), false);\n+    //     let v = ::std::env::var(\"CFG_RELEASE_CHANNEL\").unwrap_or(String::from(\"\"));\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", \"nightly\");\n+    //     config = Config::from_toml(\"unstable_features = true\").unwrap();\n+    //     assert_eq!(config.was_set().unstable_features(), true);\n+    //     assert_eq!(config.unstable_features(), true);\n+    //     ::std::env::set_var(\"CFG_RELEASE_CHANNEL\", v);\n+    // }\n+}"}, {"sha": "d2a74f5467763ac810fa2972ecce968f7b71c789", "filename": "config/options.rs", "status": "added", "additions": 482, "deletions": 0, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/config%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config%2Foptions.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,482 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use config::config_type::ConfigType;\n+use config::lists::*;\n+use config::{Config, FileName};\n+\n+use isatty::stdout_isatty;\n+\n+use std::collections::HashSet;\n+use std::path::{Path, PathBuf};\n+\n+/// Macro for deriving implementations of Serialize/Deserialize for enums\n+#[macro_export]\n+macro_rules! impl_enum_serialize_and_deserialize {\n+    ( $e:ident, $( $x:ident ),* ) => {\n+        impl ::serde::ser::Serialize for $e {\n+            fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+                where S: ::serde::ser::Serializer\n+            {\n+                use serde::ser::Error;\n+\n+                // We don't know whether the user of the macro has given us all options.\n+                #[allow(unreachable_patterns)]\n+                match *self {\n+                    $(\n+                        $e::$x => serializer.serialize_str(stringify!($x)),\n+                    )*\n+                    _ => {\n+                        Err(S::Error::custom(format!(\"Cannot serialize {:?}\", self)))\n+                    }\n+                }\n+            }\n+        }\n+\n+        impl<'de> ::serde::de::Deserialize<'de> for $e {\n+            fn deserialize<D>(d: D) -> Result<Self, D::Error>\n+                    where D: ::serde::Deserializer<'de> {\n+                use serde::de::{Error, Visitor};\n+                use std::marker::PhantomData;\n+                use std::fmt;\n+                struct StringOnly<T>(PhantomData<T>);\n+                impl<'de, T> Visitor<'de> for StringOnly<T>\n+                        where T: ::serde::Deserializer<'de> {\n+                    type Value = String;\n+                    fn expecting(&self, formatter: &mut fmt::Formatter) -> fmt::Result {\n+                        formatter.write_str(\"string\")\n+                    }\n+                    fn visit_str<E>(self, value: &str) -> Result<String, E> {\n+                        Ok(String::from(value))\n+                    }\n+                }\n+                let s = d.deserialize_string(StringOnly::<D>(PhantomData))?;\n+                $(\n+                    if stringify!($x).eq_ignore_ascii_case(&s) {\n+                      return Ok($e::$x);\n+                    }\n+                )*\n+                static ALLOWED: &'static[&str] = &[$(stringify!($x),)*];\n+                Err(D::Error::unknown_variant(&s, ALLOWED))\n+            }\n+        }\n+\n+        impl ::std::str::FromStr for $e {\n+            type Err = &'static str;\n+\n+            fn from_str(s: &str) -> Result<Self, Self::Err> {\n+                $(\n+                    if stringify!($x).eq_ignore_ascii_case(s) {\n+                        return Ok($e::$x);\n+                    }\n+                )*\n+                Err(\"Bad variant\")\n+            }\n+        }\n+\n+        impl ConfigType for $e {\n+            fn doc_hint() -> String {\n+                let mut variants = Vec::new();\n+                $(\n+                    variants.push(stringify!($x));\n+                )*\n+                format!(\"[{}]\", variants.join(\"|\"))\n+            }\n+        }\n+    };\n+}\n+\n+macro_rules! configuration_option_enum{\n+    ($e:ident: $( $x:ident ),+ $(,)*) => {\n+        #[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+        pub enum $e {\n+            $( $x ),+\n+        }\n+\n+        impl_enum_serialize_and_deserialize!($e, $( $x ),+);\n+    }\n+}\n+\n+configuration_option_enum! { NewlineStyle:\n+    Auto, // Auto-detect based on the raw source input\n+    Windows, // \\r\\n\n+    Unix, // \\n\n+    Native, // \\r\\n in Windows, \\n on other platforms\n+}\n+\n+impl NewlineStyle {\n+    fn auto_detect(raw_input_text: &str) -> NewlineStyle {\n+        if let Some(pos) = raw_input_text.find('\\n') {\n+            let pos = pos.saturating_sub(1);\n+            if let Some('\\r') = raw_input_text.chars().nth(pos) {\n+                NewlineStyle::Windows\n+            } else {\n+                NewlineStyle::Unix\n+            }\n+        } else {\n+            NewlineStyle::Native\n+        }\n+    }\n+\n+    fn native() -> NewlineStyle {\n+        if cfg!(windows) {\n+            NewlineStyle::Windows\n+        } else {\n+            NewlineStyle::Unix\n+        }\n+    }\n+\n+    /// Apply this newline style to the formatted text. When the style is set\n+    /// to `Auto`, the `raw_input_text` is used to detect the existing line\n+    /// endings.\n+    ///\n+    /// If the style is set to `Auto` and `raw_input_text` contains no\n+    /// newlines, the `Native` style will be used.\n+    pub(crate) fn apply(self, formatted_text: &mut String, raw_input_text: &str) {\n+        use NewlineStyle::*;\n+        let mut style = self;\n+        if style == Auto {\n+            style = Self::auto_detect(raw_input_text);\n+        }\n+        if style == Native {\n+            style = Self::native();\n+        }\n+        match style {\n+            Windows => {\n+                let mut transformed = String::with_capacity(2 * formatted_text.capacity());\n+                for c in formatted_text.chars() {\n+                    match c {\n+                        '\\n' => transformed.push_str(\"\\r\\n\"),\n+                        '\\r' => continue,\n+                        c => transformed.push(c),\n+                    }\n+                }\n+                *formatted_text = transformed;\n+            }\n+            Unix => return,\n+            Native => unreachable!(\"NewlineStyle::Native\"),\n+            Auto => unreachable!(\"NewlineStyle::Auto\"),\n+        }\n+    }\n+}\n+\n+configuration_option_enum! { BraceStyle:\n+    AlwaysNextLine,\n+    PreferSameLine,\n+    // Prefer same line except where there is a where clause, in which case force\n+    // the brace to the next line.\n+    SameLineWhere,\n+}\n+\n+configuration_option_enum! { ControlBraceStyle:\n+    // K&R style, Rust community default\n+    AlwaysSameLine,\n+    // Stroustrup style\n+    ClosingNextLine,\n+    // Allman style\n+    AlwaysNextLine,\n+}\n+\n+configuration_option_enum! { IndentStyle:\n+    // First line on the same line as the opening brace, all lines aligned with\n+    // the first line.\n+    Visual,\n+    // First line is on a new line and all lines align with block indent.\n+    Block,\n+}\n+\n+configuration_option_enum! { Density:\n+    // Fit as much on one line as possible.\n+    Compressed,\n+    // Use more lines.\n+    Tall,\n+    // Place every item on a separate line.\n+    Vertical,\n+}\n+\n+configuration_option_enum! { TypeDensity:\n+    // No spaces around \"=\" and \"+\"\n+    Compressed,\n+    // Spaces around \" = \" and \" + \"\n+    Wide,\n+}\n+\n+configuration_option_enum! { Heuristics:\n+    // Turn off any heuristics\n+    Off,\n+    // Turn on max heuristics\n+    Max,\n+    // Use Rustfmt's defaults\n+    Default,\n+}\n+\n+impl Density {\n+    pub fn to_list_tactic(self) -> ListTactic {\n+        match self {\n+            Density::Compressed => ListTactic::Mixed,\n+            Density::Tall => ListTactic::HorizontalVertical,\n+            Density::Vertical => ListTactic::Vertical,\n+        }\n+    }\n+}\n+\n+configuration_option_enum! { ReportTactic:\n+    Always,\n+    Unnumbered,\n+    Never,\n+}\n+\n+// What Rustfmt should emit. Mostly corresponds to the `--emit` command line\n+// option.\n+configuration_option_enum! { EmitMode:\n+    // Emits to files.\n+    Files,\n+    // Writes the output to stdout.\n+    Stdout,\n+    // Displays how much of the input file was processed\n+    Coverage,\n+    // Unfancy stdout\n+    Checkstyle,\n+    // Output the changed lines (for internal value only)\n+    ModifiedLines,\n+    // Checks if a diff can be generated. If so, rustfmt outputs a diff and quits with exit code 1.\n+    // This option is designed to be run in CI where a non-zero exit signifies non-standard code\n+    // formatting. Used for `--check`.\n+    Diff,\n+}\n+\n+// Client-preference for coloured output.\n+configuration_option_enum! { Color:\n+    // Always use color, whether it is a piped or terminal output\n+    Always,\n+    // Never use color\n+    Never,\n+    // Automatically use color, if supported by terminal\n+    Auto,\n+}\n+\n+impl Color {\n+    /// Whether we should use a coloured terminal.\n+    pub fn use_colored_tty(&self) -> bool {\n+        match self {\n+            Color::Always => true,\n+            Color::Never => false,\n+            Color::Auto => stdout_isatty(),\n+        }\n+    }\n+}\n+\n+// How chatty should Rustfmt be?\n+configuration_option_enum! { Verbosity:\n+    // Emit more.\n+    Verbose,\n+    Normal,\n+    // Emit as little as possible.\n+    Quiet,\n+}\n+\n+#[derive(Deserialize, Serialize, Clone, Debug, PartialEq)]\n+pub struct WidthHeuristics {\n+    // Maximum width of the args of a function call before falling back\n+    // to vertical formatting.\n+    pub fn_call_width: usize,\n+    // Maximum width in the body of a struct lit before falling back to\n+    // vertical formatting.\n+    pub struct_lit_width: usize,\n+    // Maximum width in the body of a struct variant before falling back\n+    // to vertical formatting.\n+    pub struct_variant_width: usize,\n+    // Maximum width of an array literal before falling back to vertical\n+    // formatting.\n+    pub array_width: usize,\n+    // Maximum length of a chain to fit on a single line.\n+    pub chain_width: usize,\n+    // Maximum line length for single line if-else expressions. A value\n+    // of zero means always break if-else expressions.\n+    pub single_line_if_else_max_width: usize,\n+}\n+\n+impl WidthHeuristics {\n+    // Using this WidthHeuristics means we ignore heuristics.\n+    pub fn null() -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: usize::max_value(),\n+            struct_lit_width: 0,\n+            struct_variant_width: 0,\n+            array_width: usize::max_value(),\n+            chain_width: usize::max_value(),\n+            single_line_if_else_max_width: 0,\n+        }\n+    }\n+\n+    pub fn set(max_width: usize) -> WidthHeuristics {\n+        WidthHeuristics {\n+            fn_call_width: max_width,\n+            struct_lit_width: max_width,\n+            struct_variant_width: max_width,\n+            array_width: max_width,\n+            chain_width: max_width,\n+            single_line_if_else_max_width: max_width,\n+        }\n+    }\n+\n+    // scale the default WidthHeuristics according to max_width\n+    pub fn scaled(max_width: usize) -> WidthHeuristics {\n+        const DEFAULT_MAX_WIDTH: usize = 100;\n+        let max_width_ratio = if max_width > DEFAULT_MAX_WIDTH {\n+            let ratio = max_width as f32 / DEFAULT_MAX_WIDTH as f32;\n+            // round to the closest 0.1\n+            (ratio * 10.0).round() / 10.0\n+        } else {\n+            1.0\n+        };\n+        WidthHeuristics {\n+            fn_call_width: (60.0 * max_width_ratio).round() as usize,\n+            struct_lit_width: (18.0 * max_width_ratio).round() as usize,\n+            struct_variant_width: (35.0 * max_width_ratio).round() as usize,\n+            array_width: (60.0 * max_width_ratio).round() as usize,\n+            chain_width: (60.0 * max_width_ratio).round() as usize,\n+            single_line_if_else_max_width: (50.0 * max_width_ratio).round() as usize,\n+        }\n+    }\n+}\n+\n+impl ::std::str::FromStr for WidthHeuristics {\n+    type Err = &'static str;\n+\n+    fn from_str(_: &str) -> Result<Self, Self::Err> {\n+        Err(\"WidthHeuristics is not parsable\")\n+    }\n+}\n+\n+impl Default for EmitMode {\n+    fn default() -> EmitMode {\n+        EmitMode::Files\n+    }\n+}\n+\n+/// A set of directories, files and modules that rustfmt should ignore.\n+#[derive(Default, Deserialize, Serialize, Clone, Debug, PartialEq)]\n+pub struct IgnoreList(HashSet<PathBuf>);\n+\n+impl IgnoreList {\n+    pub fn add_prefix(&mut self, dir: &Path) {\n+        self.0 = self\n+            .0\n+            .iter()\n+            .map(|s| {\n+                if s.has_root() {\n+                    s.clone()\n+                } else {\n+                    let mut path = PathBuf::from(dir);\n+                    path.push(s);\n+                    path\n+                }\n+            }).collect();\n+    }\n+\n+    fn skip_file_inner(&self, file: &Path) -> bool {\n+        self.0.iter().any(|path| file.starts_with(path))\n+    }\n+\n+    pub fn skip_file(&self, file: &FileName) -> bool {\n+        if let FileName::Real(ref path) = file {\n+            self.skip_file_inner(path)\n+        } else {\n+            false\n+        }\n+    }\n+}\n+\n+impl ::std::str::FromStr for IgnoreList {\n+    type Err = &'static str;\n+\n+    fn from_str(_: &str) -> Result<Self, Self::Err> {\n+        Err(\"IgnoreList is not parsable\")\n+    }\n+}\n+\n+/// Maps client-supplied options to Rustfmt's internals, mostly overriding\n+/// values in a config with values from the command line.\n+pub trait CliOptions {\n+    fn apply_to(self, config: &mut Config);\n+    fn config_path(&self) -> Option<&Path>;\n+}\n+\n+/// The edition of the compiler (RFC 2052)\n+configuration_option_enum!{ Edition:\n+    Edition2015,\n+    Edition2018,\n+}\n+\n+impl Edition {\n+    pub(crate) fn to_libsyntax_pos_edition(&self) -> syntax_pos::edition::Edition {\n+        match self {\n+            Edition::Edition2015 => syntax_pos::edition::Edition::Edition2015,\n+            Edition::Edition2018 => syntax_pos::edition::Edition::Edition2018,\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_newline_style_auto_detect() {\n+    let lf = \"One\\nTwo\\nThree\";\n+    let crlf = \"One\\r\\nTwo\\r\\nThree\";\n+    let none = \"One Two Three\";\n+\n+    assert_eq!(NewlineStyle::Unix, NewlineStyle::auto_detect(lf));\n+    assert_eq!(NewlineStyle::Windows, NewlineStyle::auto_detect(crlf));\n+    assert_eq!(NewlineStyle::Native, NewlineStyle::auto_detect(none));\n+}\n+\n+#[test]\n+fn test_newline_style_auto_apply() {\n+    let auto = NewlineStyle::Auto;\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\nTwo\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\nTwo\\nThree\", &out, \"auto should detect 'lf'\");\n+\n+    let formatted_text = \"One\\nTwo\\nThree\";\n+    let raw_input_text = \"One\\r\\nTwo\\r\\nThree\";\n+\n+    let mut out = String::from(formatted_text);\n+    auto.apply(&mut out, raw_input_text);\n+    assert_eq!(\"One\\r\\nTwo\\r\\nThree\", &out, \"auto should detect 'crlf'\");\n+\n+    #[cfg(not(windows))]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\nTwo\\nThree\", &out,\n+            \"auto-native-unix should detect 'lf'\"\n+        );\n+    }\n+\n+    #[cfg(windows)]\n+    {\n+        let formatted_text = \"One\\nTwo\\nThree\";\n+        let raw_input_text = \"One Two Three\";\n+\n+        let mut out = String::from(formatted_text);\n+        auto.apply(&mut out, raw_input_text);\n+        assert_eq!(\n+            \"One\\r\\nTwo\\r\\nThree\", &out,\n+            \"auto-native-windows should detect 'crlf'\"\n+        );\n+    }\n+}"}, {"sha": "37ad4f35a1d1027f863f62d9f9b63f1ec7be5be0", "filename": "format-diff/main.rs", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/format-diff%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/format-diff%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/format-diff%2Fmain.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Inspired by Clang's clang-format-diff:\n+//\n+// https://github.com/llvm-mirror/clang/blob/master/tools/clang-format/clang-format-diff.py\n+\n+#![deny(warnings)]\n+\n+extern crate env_logger;\n+#[macro_use]\n+extern crate failure;\n+extern crate getopts;\n+#[macro_use]\n+extern crate log;\n+extern crate regex;\n+#[macro_use]\n+extern crate serde_derive;\n+extern crate serde_json as json;\n+\n+use std::collections::HashSet;\n+use std::io::{self, BufRead};\n+use std::{env, process};\n+\n+use regex::Regex;\n+\n+/// The default pattern of files to format.\n+///\n+/// We only want to format rust files by default.\n+const DEFAULT_PATTERN: &str = r\".*\\.rs\";\n+\n+#[derive(Fail, Debug)]\n+enum FormatDiffError {\n+    #[fail(display = \"{}\", _0)]\n+    IncorrectOptions(#[cause] getopts::Fail),\n+    #[fail(display = \"{}\", _0)]\n+    IncorrectFilter(#[cause] regex::Error),\n+    #[fail(display = \"{}\", _0)]\n+    IoError(#[cause] io::Error),\n+}\n+\n+impl From<getopts::Fail> for FormatDiffError {\n+    fn from(fail: getopts::Fail) -> Self {\n+        FormatDiffError::IncorrectOptions(fail)\n+    }\n+}\n+\n+impl From<regex::Error> for FormatDiffError {\n+    fn from(err: regex::Error) -> Self {\n+        FormatDiffError::IncorrectFilter(err)\n+    }\n+}\n+\n+impl From<io::Error> for FormatDiffError {\n+    fn from(fail: io::Error) -> Self {\n+        FormatDiffError::IoError(fail)\n+    }\n+}\n+\n+fn main() {\n+    env_logger::init();\n+\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optopt(\n+        \"p\",\n+        \"skip-prefix\",\n+        \"skip the smallest prefix containing NUMBER slashes\",\n+        \"NUMBER\",\n+    );\n+    opts.optopt(\n+        \"f\",\n+        \"filter\",\n+        \"custom pattern selecting file paths to reformat\",\n+        \"PATTERN\",\n+    );\n+\n+    if let Err(e) = run(&opts) {\n+        println!(\"{}\", opts.usage(&format!(\"{}\", e)));\n+        process::exit(1);\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Serialize, Deserialize)]\n+struct Range {\n+    file: String,\n+    range: [u32; 2],\n+}\n+\n+fn run(opts: &getopts::Options) -> Result<(), FormatDiffError> {\n+    let matches = opts.parse(env::args().skip(1))?;\n+\n+    if matches.opt_present(\"h\") {\n+        println!(\"{}\", opts.usage(\"usage: \"));\n+        return Ok(());\n+    }\n+\n+    let filter = matches\n+        .opt_str(\"f\")\n+        .unwrap_or_else(|| DEFAULT_PATTERN.to_owned());\n+\n+    let skip_prefix = matches\n+        .opt_str(\"p\")\n+        .and_then(|p| p.parse::<u32>().ok())\n+        .unwrap_or(0);\n+\n+    let (files, ranges) = scan_diff(io::stdin(), skip_prefix, &filter)?;\n+\n+    run_rustfmt(&files, &ranges)\n+}\n+\n+fn run_rustfmt(files: &HashSet<String>, ranges: &[Range]) -> Result<(), FormatDiffError> {\n+    if files.is_empty() || ranges.is_empty() {\n+        debug!(\"No files to format found\");\n+        return Ok(());\n+    }\n+\n+    let ranges_as_json = json::to_string(ranges).unwrap();\n+\n+    debug!(\"Files: {:?}\", files);\n+    debug!(\"Ranges: {:?}\", ranges);\n+\n+    let exit_status = process::Command::new(\"rustfmt\")\n+        .args(files)\n+        .arg(\"--file-lines\")\n+        .arg(ranges_as_json)\n+        .status()?;\n+\n+    if !exit_status.success() {\n+        return Err(FormatDiffError::IoError(io::Error::new(\n+            io::ErrorKind::Other,\n+            format!(\"rustfmt failed with {}\", exit_status),\n+        )));\n+    }\n+    Ok(())\n+}\n+\n+/// Scans a diff from `from`, and returns the set of files found, and the ranges\n+/// in those files.\n+fn scan_diff<R>(\n+    from: R,\n+    skip_prefix: u32,\n+    file_filter: &str,\n+) -> Result<(HashSet<String>, Vec<Range>), FormatDiffError>\n+where\n+    R: io::Read,\n+{\n+    let diff_pattern = format!(r\"^\\+\\+\\+\\s(?:.*?/){{{}}}(\\S*)\", skip_prefix);\n+    let diff_pattern = Regex::new(&diff_pattern).unwrap();\n+\n+    let lines_pattern = Regex::new(r\"^@@.*\\+(\\d+)(,(\\d+))?\").unwrap();\n+\n+    let file_filter = Regex::new(&format!(\"^{}$\", file_filter))?;\n+\n+    let mut current_file = None;\n+\n+    let mut files = HashSet::new();\n+    let mut ranges = vec![];\n+    for line in io::BufReader::new(from).lines() {\n+        let line = line.unwrap();\n+\n+        if let Some(captures) = diff_pattern.captures(&line) {\n+            current_file = Some(captures.get(1).unwrap().as_str().to_owned());\n+        }\n+\n+        let file = match current_file {\n+            Some(ref f) => &**f,\n+            None => continue,\n+        };\n+\n+        // FIXME(emilio): We could avoid this most of the time if needed, but\n+        // it's not clear it's worth it.\n+        if !file_filter.is_match(file) {\n+            continue;\n+        }\n+\n+        let lines_captures = match lines_pattern.captures(&line) {\n+            Some(captures) => captures,\n+            None => continue,\n+        };\n+\n+        let start_line = lines_captures\n+            .get(1)\n+            .unwrap()\n+            .as_str()\n+            .parse::<u32>()\n+            .unwrap();\n+        let line_count = match lines_captures.get(3) {\n+            Some(line_count) => line_count.as_str().parse::<u32>().unwrap(),\n+            None => 1,\n+        };\n+\n+        if line_count == 0 {\n+            continue;\n+        }\n+\n+        let end_line = start_line + line_count - 1;\n+        files.insert(file.to_owned());\n+        ranges.push(Range {\n+            file: file.to_owned(),\n+            range: [start_line, end_line],\n+        });\n+    }\n+\n+    Ok((files, ranges))\n+}\n+\n+#[test]\n+fn scan_simple_git_diff() {\n+    const DIFF: &'static str = include_str!(\"test/bindgen.diff\");\n+    let (files, ranges) = scan_diff(DIFF.as_bytes(), 1, r\".*\\.rs\").expect(\"scan_diff failed?\");\n+\n+    assert!(\n+        files.contains(\"src/ir/traversal.rs\"),\n+        \"Should've matched the filter\"\n+    );\n+\n+    assert!(\n+        !files.contains(\"tests/headers/anon_enum.hpp\"),\n+        \"Shouldn't have matched the filter\"\n+    );\n+\n+    assert_eq!(\n+        &ranges,\n+        &[\n+            Range {\n+                file: \"src/ir/item.rs\".to_owned(),\n+                range: [148, 158],\n+            },\n+            Range {\n+                file: \"src/ir/item.rs\".to_owned(),\n+                range: [160, 170],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".to_owned(),\n+                range: [9, 16],\n+            },\n+            Range {\n+                file: \"src/ir/traversal.rs\".to_owned(),\n+                range: [35, 43],\n+            },\n+        ]\n+    );\n+}"}, {"sha": "d2fd379f471654699ec84c3f7ce628243023f1b9", "filename": "format-diff/test/bindgen.diff", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/format-diff%2Ftest%2Fbindgen.diff", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/format-diff%2Ftest%2Fbindgen.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/format-diff%2Ftest%2Fbindgen.diff?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,67 @@\n+diff --git a/src/ir/item.rs b/src/ir/item.rs\n+index 7f3afefb..90d15e96 100644\n+--- a/src/ir/item.rs\n++++ b/src/ir/item.rs\n+@@ -148,7 +148,11 @@ impl<'a, 'b> Iterator for ItemAncestorsIter<'a, 'b>\n+ impl AsTemplateParam for ItemId {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         ctx.resolve_item(*self).as_template_param(ctx, &())\n+     }\n+ }\n+@@ -156,7 +160,11 @@ impl AsTemplateParam for ItemId {\n+ impl AsTemplateParam for Item {\n+     type Extra = ();\n+ \n+-    fn as_template_param(&self, ctx: &BindgenContext, _: &()) -> Option<ItemId> {\n++    fn as_template_param(\n++        &self,\n++        ctx: &BindgenContext,\n++        _: &(),\n++    ) -> Option<ItemId> {\n+         self.kind.as_template_param(ctx, self)\n+     }\n+ }\n+diff --git a/src/ir/traversal.rs b/src/ir/traversal.rs\n+index 762a3e2d..b9c9dd4e 100644\n+--- a/src/ir/traversal.rs\n++++ b/src/ir/traversal.rs\n+@@ -9,6 +9,8 @@ use std::collections::{BTreeMap, VecDeque};\n+ ///\n+ ///   from --> to\n+ ///\n++/// Random content to generate a diff.\n++///\n+ /// The `from` is left implicit: it is the concrete `Trace` implementer which\n+ /// yielded this outgoing edge.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+@@ -33,7 +35,9 @@ impl Into<ItemId> for Edge {\n+     }\n+ }\n+ \n+-/// The kind of edge reference. This is useful when we wish to only consider\n++/// The kind of edge reference.\n++///\n++/// This is useful when we wish to only consider\n+ /// certain kinds of edges for a particular traversal or analysis.\n+ #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+ pub enum EdgeKind {\n+diff --git a/tests/headers/anon_enum.hpp b/tests/headers/anon_enum.hpp\n+index 1961fe6c..34759df3 100644\n+--- a/tests/headers/anon_enum.hpp\n++++ b/tests/headers/anon_enum.hpp\n+@@ -1,7 +1,7 @@\n+ struct Test {\n+   int foo;\n+   float bar;\n+-  enum { T_NONE };\n++  enum { T_NONE, T_SOME };\n+ };\n+ \n+ typedef enum {"}, {"sha": "0042ff353a7ceb698363edc81429294319c9cc8b", "filename": "git-rustfmt/main.rs", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/git-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/git-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/git-rustfmt%2Fmain.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,206 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate env_logger;\n+extern crate getopts;\n+#[macro_use]\n+extern crate log;\n+extern crate rustfmt_nightly as rustfmt;\n+\n+use std::env;\n+use std::io::stdout;\n+use std::path::{Path, PathBuf};\n+use std::process::Command;\n+use std::str::FromStr;\n+\n+use getopts::{Matches, Options};\n+\n+use rustfmt::{load_config, CliOptions, Input, Session};\n+\n+fn prune_files(files: Vec<&str>) -> Vec<&str> {\n+    let prefixes: Vec<_> = files\n+        .iter()\n+        .filter(|f| f.ends_with(\"mod.rs\") || f.ends_with(\"lib.rs\"))\n+        .map(|f| &f[..f.len() - 6])\n+        .collect();\n+\n+    let mut pruned_prefixes = vec![];\n+    for p1 in prefixes {\n+        if p1.starts_with(\"src/bin/\") || pruned_prefixes.iter().all(|p2| !p1.starts_with(p2)) {\n+            pruned_prefixes.push(p1);\n+        }\n+    }\n+    debug!(\"prefixes: {:?}\", pruned_prefixes);\n+\n+    files\n+        .into_iter()\n+        .filter(|f| {\n+            if f.ends_with(\"mod.rs\") || f.ends_with(\"lib.rs\") || f.starts_with(\"src/bin/\") {\n+                return true;\n+            }\n+            pruned_prefixes.iter().all(|pp| !f.starts_with(pp))\n+        }).collect()\n+}\n+\n+fn git_diff(commits: &str) -> String {\n+    let mut cmd = Command::new(\"git\");\n+    cmd.arg(\"diff\");\n+    if commits != \"0\" {\n+        cmd.arg(format!(\"HEAD~{}\", commits));\n+    }\n+    let output = cmd.output().expect(\"Couldn't execute `git diff`\");\n+    String::from_utf8_lossy(&output.stdout).into_owned()\n+}\n+\n+fn get_files(input: &str) -> Vec<&str> {\n+    input\n+        .lines()\n+        .filter(|line| line.starts_with(\"+++ b/\") && line.ends_with(\".rs\"))\n+        .map(|line| &line[6..])\n+        .collect()\n+}\n+\n+fn fmt_files(files: &[&str]) -> i32 {\n+    let (config, _) =\n+        load_config::<NullOptions>(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n+\n+    let mut exit_code = 0;\n+    let mut out = stdout();\n+    let mut session = Session::new(config, Some(&mut out));\n+    for file in files {\n+        let report = session.format(Input::File(PathBuf::from(file))).unwrap();\n+        if report.has_warnings() {\n+            eprintln!(\"{}\", report);\n+        }\n+        if !session.has_no_errors() {\n+            exit_code = 1;\n+        }\n+    }\n+    exit_code\n+}\n+\n+struct NullOptions;\n+\n+impl CliOptions for NullOptions {\n+    fn apply_to(self, _: &mut rustfmt::Config) {\n+        unreachable!();\n+    }\n+    fn config_path(&self) -> Option<&Path> {\n+        unreachable!();\n+    }\n+}\n+\n+fn uncommitted_files() -> Vec<String> {\n+    let mut cmd = Command::new(\"git\");\n+    cmd.arg(\"ls-files\");\n+    cmd.arg(\"--others\");\n+    cmd.arg(\"--modified\");\n+    cmd.arg(\"--exclude-standard\");\n+    let output = cmd.output().expect(\"Couldn't execute Git\");\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    stdout\n+        .lines()\n+        .filter(|s| s.ends_with(\".rs\"))\n+        .map(|s| s.to_owned())\n+        .collect()\n+}\n+\n+fn check_uncommitted() {\n+    let uncommitted = uncommitted_files();\n+    debug!(\"uncommitted files: {:?}\", uncommitted);\n+    if !uncommitted.is_empty() {\n+        println!(\"Found untracked changes:\");\n+        for f in &uncommitted {\n+            println!(\"  {}\", f);\n+        }\n+        println!(\"Commit your work, or run with `-u`.\");\n+        println!(\"Exiting.\");\n+        std::process::exit(1);\n+    }\n+}\n+\n+fn make_opts() -> Options {\n+    let mut opts = Options::new();\n+    opts.optflag(\"h\", \"help\", \"show this message\");\n+    opts.optflag(\"c\", \"check\", \"check only, don't format (unimplemented)\");\n+    opts.optflag(\"u\", \"uncommitted\", \"format uncommitted files\");\n+    opts\n+}\n+\n+struct Config {\n+    commits: String,\n+    uncommitted: bool,\n+    check: bool,\n+}\n+\n+impl Config {\n+    fn from_args(matches: &Matches, opts: &Options) -> Config {\n+        // `--help` display help message and quit\n+        if matches.opt_present(\"h\") {\n+            let message = format!(\n+                \"\\nusage: {} <commits> [options]\\n\\n\\\n+                 commits: number of commits to format, default: 1\",\n+                env::args_os().next().unwrap().to_string_lossy()\n+            );\n+            println!(\"{}\", opts.usage(&message));\n+            std::process::exit(0);\n+        }\n+\n+        let mut config = Config {\n+            commits: \"1\".to_owned(),\n+            uncommitted: false,\n+            check: false,\n+        };\n+\n+        if matches.opt_present(\"c\") {\n+            config.check = true;\n+            unimplemented!();\n+        }\n+\n+        if matches.opt_present(\"u\") {\n+            config.uncommitted = true;\n+        }\n+\n+        if matches.free.len() > 1 {\n+            panic!(\"unknown arguments, use `-h` for usage\");\n+        }\n+        if matches.free.len() == 1 {\n+            let commits = matches.free[0].trim();\n+            if u32::from_str(commits).is_err() {\n+                panic!(\"Couldn't parse number of commits\");\n+            }\n+            config.commits = commits.to_owned();\n+        }\n+\n+        config\n+    }\n+}\n+\n+fn main() {\n+    env_logger::init();\n+\n+    let opts = make_opts();\n+    let matches = opts\n+        .parse(env::args().skip(1))\n+        .expect(\"Couldn't parse command line\");\n+    let config = Config::from_args(&matches, &opts);\n+\n+    if !config.uncommitted {\n+        check_uncommitted();\n+    }\n+\n+    let stdout = git_diff(&config.commits);\n+    let files = get_files(&stdout);\n+    debug!(\"files: {:?}\", files);\n+    let files = prune_files(files);\n+    debug!(\"pruned files: {:?}\", files);\n+    let exit_code = fmt_files(&files);\n+    std::process::exit(exit_code);\n+}"}, {"sha": "d5c4802904b65ed9747d90099e413d556b7b4400", "filename": "src/patterns.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/src%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/src%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpatterns.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -336,29 +336,28 @@ fn rewrite_tuple_pat(\n         ));\n         pat_vec.insert(pos, dotdot);\n     }\n-\n     if pat_vec.is_empty() {\n         return Some(format!(\"{}()\", path_str.unwrap_or_default()));\n     }\n-\n     let wildcard_suffix_len = count_wildcard_suffix_len(context, &pat_vec, span, shape);\n-    let (pat_vec, span) = if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2\n-    {\n-        let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n-        let sp = pat_vec[new_item_count - 1].span();\n-        let snippet = context.snippet(sp);\n-        let lo = sp.lo() + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n-        pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n-        (\n-            &pat_vec[..new_item_count],\n-            mk_sp(span.lo(), lo + BytePos(1)),\n-        )\n-    } else {\n-        (&pat_vec[..], span)\n-    };\n+    let (pat_vec, span, condensed) =\n+        if context.config.condense_wildcard_suffixes() && wildcard_suffix_len >= 2 {\n+            let new_item_count = 1 + pat_vec.len() - wildcard_suffix_len;\n+            let sp = pat_vec[new_item_count - 1].span();\n+            let snippet = context.snippet(sp);\n+            let lo = sp.lo() + BytePos(snippet.find_uncommented(\"_\").unwrap() as u32);\n+            pat_vec[new_item_count - 1] = TuplePatField::Dotdot(mk_sp(lo, lo + BytePos(1)));\n+            (\n+                &pat_vec[..new_item_count],\n+                mk_sp(span.lo(), lo + BytePos(1)),\n+                true,\n+            )\n+        } else {\n+            (&pat_vec[..], span, false)\n+        };\n \n     // add comma if `(x,)`\n-    let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none();\n+    let add_comma = path_str.is_none() && pat_vec.len() == 1 && dotdot_pos.is_none() && !condensed;\n     let path_str = path_str.unwrap_or_default();\n     let pat_ref_vec = pat_vec.iter().collect::<Vec<_>>();\n "}, {"sha": "8b2358f1ada3a5a025fc33b9b268cdb278b85a8e", "filename": "test/mod.rs", "status": "added", "additions": 964, "deletions": 0, "changes": 964, "blob_url": "https://github.com/rust-lang/rust/blob/5d642e8b234e96b360ef94734f724af12b36abb6/test%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5d642e8b234e96b360ef94734f724af12b36abb6/test%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/test%2Fmod.rs?ref=5d642e8b234e96b360ef94734f724af12b36abb6", "patch": "@@ -0,0 +1,964 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern crate assert_cli;\n+\n+use std::collections::{HashMap, HashSet};\n+use std::env;\n+use std::fs;\n+use std::io::{self, BufRead, BufReader, Read, Write};\n+use std::iter::{Enumerate, Peekable};\n+use std::mem;\n+use std::path::{Path, PathBuf};\n+use std::str::Chars;\n+\n+use config::{Color, Config, EmitMode, FileName, ReportTactic};\n+use formatting::{ModifiedChunk, SourceFile};\n+use rustfmt_diff::{make_diff, print_diff, DiffLine, Mismatch, OutputWriter};\n+use source_file;\n+use {FormatReport, Input, Session};\n+\n+const DIFF_CONTEXT_SIZE: usize = 3;\n+const CONFIGURATIONS_FILE_NAME: &str = \"Configurations.md\";\n+\n+// Returns a `Vec` containing `PathBuf`s of files with a rs extension in the\n+// given path. The `recursive` argument controls if files from subdirectories\n+// are also returned.\n+fn get_test_files(path: &Path, recursive: bool) -> Vec<PathBuf> {\n+    let mut files = vec![];\n+    if path.is_dir() {\n+        for entry in fs::read_dir(path).expect(&format!(\n+            \"Couldn't read directory {}\",\n+            path.to_str().unwrap()\n+        )) {\n+            let entry = entry.expect(\"Couldn't get DirEntry\");\n+            let path = entry.path();\n+            if path.is_dir() && recursive {\n+                files.append(&mut get_test_files(&path, recursive));\n+            } else if path.extension().map_or(false, |f| f == \"rs\") {\n+                files.push(path);\n+            }\n+        }\n+    }\n+    files\n+}\n+\n+fn verify_config_used(path: &Path, config_name: &str) {\n+    for entry in fs::read_dir(path).expect(&format!(\n+        \"Couldn't read {} directory\",\n+        path.to_str().unwrap()\n+    )) {\n+        let entry = entry.expect(\"Couldn't get directory entry\");\n+        let path = entry.path();\n+        if path.extension().map_or(false, |f| f == \"rs\") {\n+            // check if \"// rustfmt-<config_name>:\" appears in the file.\n+            let filebuf = BufReader::new(\n+                fs::File::open(&path).expect(&format!(\"Couldn't read file {}\", path.display())),\n+            );\n+            assert!(\n+                filebuf\n+                    .lines()\n+                    .map(|l| l.unwrap())\n+                    .take_while(|l| l.starts_with(\"//\"))\n+                    .any(|l| l.starts_with(&format!(\"// rustfmt-{}\", config_name))),\n+                format!(\n+                    \"config option file {} does not contain expected config name\",\n+                    path.display()\n+                )\n+            );\n+        }\n+    }\n+}\n+\n+#[test]\n+fn verify_config_test_names() {\n+    for path in &[\n+        Path::new(\"tests/source/configs\"),\n+        Path::new(\"tests/target/configs\"),\n+    ] {\n+        for entry in fs::read_dir(path).expect(\"Couldn't read configs directory\") {\n+            let entry = entry.expect(\"Couldn't get directory entry\");\n+            let path = entry.path();\n+            if path.is_dir() {\n+                let config_name = path.file_name().unwrap().to_str().unwrap();\n+\n+                // Make sure that config name is used in the files in the directory.\n+                verify_config_used(&path, config_name);\n+            }\n+        }\n+    }\n+}\n+\n+// This writes to the terminal using the same approach (via term::stdout or\n+// println!) that is used by `rustfmt::rustfmt_diff::print_diff`. Writing\n+// using only one or the other will cause the output order to differ when\n+// `print_diff` selects the approach not used.\n+fn write_message(msg: &str) {\n+    let mut writer = OutputWriter::new(Color::Auto);\n+    writer.writeln(&format!(\"{}\", msg), None);\n+}\n+\n+// Integration tests. The files in the tests/source are formatted and compared\n+// to their equivalent in tests/target. The target file and config can be\n+// overridden by annotations in the source file. The input and output must match\n+// exactly.\n+#[test]\n+fn system_tests() {\n+    // Get all files in the tests/source directory.\n+    let files = get_test_files(Path::new(\"tests/source\"), true);\n+    let (_reports, count, fails) = check_files(files, None);\n+\n+    // Display results.\n+    println!(\"Ran {} system tests.\", count);\n+    assert_eq!(fails, 0, \"{} system tests failed\", fails);\n+}\n+\n+// Do the same for tests/coverage-source directory\n+// the only difference is the coverage mode\n+#[test]\n+fn coverage_tests() {\n+    let files = get_test_files(Path::new(\"tests/coverage/source\"), true);\n+    let (_reports, count, fails) = check_files(files, None);\n+\n+    println!(\"Ran {} tests in coverage mode.\", count);\n+    assert_eq!(fails, 0, \"{} tests failed\", fails);\n+}\n+\n+#[test]\n+fn checkstyle_test() {\n+    let filename = \"tests/writemode/source/fn-single-line.rs\";\n+    let expected_filename = \"tests/writemode/target/checkstyle.xml\";\n+    assert_output(Path::new(filename), Path::new(expected_filename));\n+}\n+\n+#[test]\n+fn modified_test() {\n+    use std::io::BufRead;\n+\n+    // Test \"modified\" output\n+    let filename = \"tests/writemode/source/modified.rs\";\n+    let mut data = Vec::new();\n+    let mut config = Config::default();\n+    config.set().emit_mode(::config::EmitMode::ModifiedLines);\n+\n+    {\n+        let mut session = Session::new(config, Some(&mut data));\n+        session.format(Input::File(filename.into())).unwrap();\n+    }\n+\n+    let mut lines = data.lines();\n+    let mut chunks = Vec::new();\n+    while let Some(Ok(header)) = lines.next() {\n+        // Parse the header line\n+        let values: Vec<_> = header\n+            .split(' ')\n+            .map(|s| s.parse::<u32>().unwrap())\n+            .collect();\n+        assert_eq!(values.len(), 3);\n+        let line_number_orig = values[0];\n+        let lines_removed = values[1];\n+        let num_added = values[2];\n+        let mut added_lines = Vec::new();\n+        for _ in 0..num_added {\n+            added_lines.push(lines.next().unwrap().unwrap());\n+        }\n+        chunks.push(ModifiedChunk {\n+            line_number_orig,\n+            lines_removed,\n+            lines: added_lines,\n+        });\n+    }\n+\n+    assert_eq!(\n+        chunks,\n+        vec![\n+            ModifiedChunk {\n+                line_number_orig: 4,\n+                lines_removed: 4,\n+                lines: vec![\"fn blah() {}\".into()],\n+            },\n+            ModifiedChunk {\n+                line_number_orig: 9,\n+                lines_removed: 6,\n+                lines: vec![\"#[cfg(a, b)]\".into(), \"fn main() {}\".into()],\n+            },\n+        ],\n+    );\n+}\n+\n+// Helper function for comparing the results of rustfmt\n+// to a known output file generated by one of the write modes.\n+fn assert_output(source: &Path, expected_filename: &Path) {\n+    let config = read_config(source);\n+    let (_, source_file, _) = format_file(source, config.clone());\n+\n+    // Populate output by writing to a vec.\n+    let mut out = vec![];\n+    let _ = source_file::write_all_files(&source_file, &mut out, &config);\n+    let output = String::from_utf8(out).unwrap();\n+\n+    let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n+    let mut expected_text = String::new();\n+    expected_file\n+        .read_to_string(&mut expected_text)\n+        .expect(\"Failed reading target\");\n+\n+    let compare = make_diff(&expected_text, &output, DIFF_CONTEXT_SIZE);\n+    if !compare.is_empty() {\n+        let mut failures = HashMap::new();\n+        failures.insert(source.to_owned(), compare);\n+        print_mismatches_default_message(failures);\n+        assert!(false, \"Text does not match expected output\");\n+    }\n+}\n+\n+// Idempotence tests. Files in tests/target are checked to be unaltered by\n+// rustfmt.\n+#[test]\n+fn idempotence_tests() {\n+    match option_env!(\"CFG_RELEASE_CHANNEL\") {\n+        None | Some(\"nightly\") => {}\n+        _ => return, // these tests require nightly\n+    }\n+    // Get all files in the tests/target directory.\n+    let files = get_test_files(Path::new(\"tests/target\"), true);\n+    let (_reports, count, fails) = check_files(files, None);\n+\n+    // Display results.\n+    println!(\"Ran {} idempotent tests.\", count);\n+    assert_eq!(fails, 0, \"{} idempotent tests failed\", fails);\n+}\n+\n+// Run rustfmt on itself. This operation must be idempotent. We also check that\n+// no warnings are emitted.\n+#[test]\n+fn self_tests() {\n+    let mut files = get_test_files(Path::new(\"tests\"), false);\n+    let bin_directories = vec![\"cargo-fmt\", \"git-rustfmt\", \"bin\", \"format-diff\"];\n+    for dir in bin_directories {\n+        let mut path = PathBuf::from(\"src\");\n+        path.push(dir);\n+        path.push(\"main.rs\");\n+        files.push(path);\n+    }\n+    files.push(PathBuf::from(\"src/lib.rs\"));\n+\n+    let (reports, count, fails) = check_files(files, Some(PathBuf::from(\"rustfmt.toml\")));\n+    let mut warnings = 0;\n+\n+    // Display results.\n+    println!(\"Ran {} self tests.\", count);\n+    assert_eq!(fails, 0, \"{} self tests failed\", fails);\n+\n+    for format_report in reports {\n+        println!(\"{}\", format_report);\n+        warnings += format_report.warning_count();\n+    }\n+\n+    assert_eq!(\n+        warnings, 0,\n+        \"Rustfmt's code generated {} warnings\",\n+        warnings\n+    );\n+}\n+\n+#[test]\n+fn stdin_formatting_smoke_test() {\n+    let input = Input::Text(\"fn main () {}\".to_owned());\n+    let mut config = Config::default();\n+    config.set().emit_mode(EmitMode::Stdout);\n+    let mut buf: Vec<u8> = vec![];\n+    {\n+        let mut session = Session::new(config, Some(&mut buf));\n+        session.format(input).unwrap();\n+        assert!(session.has_no_errors());\n+    }\n+    //eprintln!(\"{:?}\", );\n+    #[cfg(not(windows))]\n+    assert_eq!(buf, \"fn main() {}\\n\".as_bytes());\n+    #[cfg(windows)]\n+    assert_eq!(buf, \"fn main() {}\\r\\n\".as_bytes());\n+}\n+\n+// FIXME(#1990) restore this test\n+// #[test]\n+// fn stdin_disable_all_formatting_test() {\n+//     let input = String::from(\"fn main() { println!(\\\"This should not be formatted.\\\"); }\");\n+//     let mut child = Command::new(\"./target/debug/rustfmt\")\n+//         .stdin(Stdio::piped())\n+//         .stdout(Stdio::piped())\n+//         .arg(\"--config-path=./tests/config/disable_all_formatting.toml\")\n+//         .spawn()\n+//         .expect(\"failed to execute child\");\n+\n+//     {\n+//         let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n+//         stdin\n+//             .write_all(input.as_bytes())\n+//             .expect(\"failed to write stdin\");\n+//     }\n+//     let output = child.wait_with_output().expect(\"failed to wait on child\");\n+//     assert!(output.status.success());\n+//     assert!(output.stderr.is_empty());\n+//     assert_eq!(input, String::from_utf8(output.stdout).unwrap());\n+// }\n+\n+#[test]\n+fn format_lines_errors_are_reported() {\n+    let long_identifier = String::from_utf8(vec![b'a'; 239]).unwrap();\n+    let input = Input::Text(format!(\"fn {}() {{}}\", long_identifier));\n+    let mut config = Config::default();\n+    config.set().error_on_line_overflow(true);\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    session.format(input).unwrap();\n+    assert!(session.has_formatting_errors());\n+}\n+\n+#[test]\n+fn format_lines_errors_are_reported_with_tabs() {\n+    let long_identifier = String::from_utf8(vec![b'a'; 97]).unwrap();\n+    let input = Input::Text(format!(\"fn a() {{\\n\\t{}\\n}}\", long_identifier));\n+    let mut config = Config::default();\n+    config.set().error_on_line_overflow(true);\n+    config.set().hard_tabs(true);\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    session.format(input).unwrap();\n+    assert!(session.has_formatting_errors());\n+}\n+\n+// For each file, run rustfmt and collect the output.\n+// Returns the number of files checked and the number of failures.\n+fn check_files(files: Vec<PathBuf>, opt_config: Option<PathBuf>) -> (Vec<FormatReport>, u32, u32) {\n+    let mut count = 0;\n+    let mut fails = 0;\n+    let mut reports = vec![];\n+\n+    for file_name in files {\n+        debug!(\"Testing '{}'...\", file_name.display());\n+\n+        match idempotent_check(&file_name, &opt_config) {\n+            Ok(ref report) if report.has_warnings() => {\n+                print!(\"{}\", report);\n+                fails += 1;\n+            }\n+            Ok(report) => reports.push(report),\n+            Err(err) => {\n+                if let IdempotentCheckError::Mismatch(msg) = err {\n+                    print_mismatches_default_message(msg);\n+                }\n+                fails += 1;\n+            }\n+        }\n+\n+        count += 1;\n+    }\n+\n+    (reports, count, fails)\n+}\n+\n+fn print_mismatches_default_message(result: HashMap<PathBuf, Vec<Mismatch>>) {\n+    for (file_name, diff) in result {\n+        let mismatch_msg_formatter =\n+            |line_num| format!(\"\\nMismatch at {}:{}:\", file_name.display(), line_num);\n+        print_diff(diff, &mismatch_msg_formatter, &Default::default());\n+    }\n+\n+    if let Some(mut t) = term::stdout() {\n+        t.reset().unwrap_or(());\n+    }\n+}\n+\n+fn print_mismatches<T: Fn(u32) -> String>(\n+    result: HashMap<PathBuf, Vec<Mismatch>>,\n+    mismatch_msg_formatter: T,\n+) {\n+    for (_file_name, diff) in result {\n+        print_diff(diff, &mismatch_msg_formatter, &Default::default());\n+    }\n+\n+    if let Some(mut t) = term::stdout() {\n+        t.reset().unwrap_or(());\n+    }\n+}\n+\n+fn read_config(filename: &Path) -> Config {\n+    let sig_comments = read_significant_comments(filename);\n+    // Look for a config file... If there is a 'config' property in the significant comments, use\n+    // that. Otherwise, if there are no significant comments at all, look for a config file with\n+    // the same name as the test file.\n+    let mut config = if !sig_comments.is_empty() {\n+        get_config(sig_comments.get(\"config\").map(Path::new))\n+    } else {\n+        get_config(filename.with_extension(\"toml\").file_name().map(Path::new))\n+    };\n+\n+    for (key, val) in &sig_comments {\n+        if key != \"target\" && key != \"config\" {\n+            config.override_value(key, val);\n+            if config.is_default(key) {\n+                warn!(\"Default value {} used explicitly for {}\", val, key);\n+            }\n+        }\n+    }\n+\n+    // Don't generate warnings for to-do items.\n+    config.set().report_todo(ReportTactic::Never);\n+\n+    config\n+}\n+\n+fn format_file<P: Into<PathBuf>>(filepath: P, config: Config) -> (bool, SourceFile, FormatReport) {\n+    let filepath = filepath.into();\n+    let input = Input::File(filepath);\n+    let mut session = Session::<io::Stdout>::new(config, None);\n+    let result = session.format(input).unwrap();\n+    let parsing_errors = session.has_parsing_errors();\n+    let mut source_file = SourceFile::new();\n+    mem::swap(&mut session.source_file, &mut source_file);\n+    (parsing_errors, source_file, result)\n+}\n+\n+enum IdempotentCheckError {\n+    Mismatch(HashMap<PathBuf, Vec<Mismatch>>),\n+    Parse,\n+}\n+\n+fn idempotent_check(\n+    filename: &PathBuf,\n+    opt_config: &Option<PathBuf>,\n+) -> Result<FormatReport, IdempotentCheckError> {\n+    let sig_comments = read_significant_comments(filename);\n+    let config = if let Some(ref config_file_path) = opt_config {\n+        Config::from_toml_path(config_file_path).expect(\"rustfmt.toml not found\")\n+    } else {\n+        read_config(filename)\n+    };\n+    let (parsing_errors, source_file, format_report) = format_file(filename, config);\n+    if parsing_errors {\n+        return Err(IdempotentCheckError::Parse);\n+    }\n+\n+    let mut write_result = HashMap::new();\n+    for (filename, text) in source_file {\n+        if let FileName::Real(ref filename) = filename {\n+            write_result.insert(filename.to_owned(), text);\n+        }\n+    }\n+\n+    let target = sig_comments.get(\"target\").map(|x| &(*x)[..]);\n+\n+    handle_result(write_result, target).map(|_| format_report)\n+}\n+\n+// Reads test config file using the supplied (optional) file name. If there's no file name or the\n+// file doesn't exist, just return the default config. Otherwise, the file must be read\n+// successfully.\n+fn get_config(config_file: Option<&Path>) -> Config {\n+    let config_file_name = match config_file {\n+        None => return Default::default(),\n+        Some(file_name) => {\n+            let mut full_path = PathBuf::from(\"tests/config/\");\n+            full_path.push(file_name);\n+            if !full_path.exists() {\n+                return Default::default();\n+            };\n+            full_path\n+        }\n+    };\n+\n+    let mut def_config_file = fs::File::open(config_file_name).expect(\"Couldn't open config\");\n+    let mut def_config = String::new();\n+    def_config_file\n+        .read_to_string(&mut def_config)\n+        .expect(\"Couldn't read config\");\n+\n+    Config::from_toml(&def_config, Path::new(\"tests/config/\")).expect(\"Invalid toml\")\n+}\n+\n+// Reads significant comments of the form: // rustfmt-key: value\n+// into a hash map.\n+fn read_significant_comments(file_name: &Path) -> HashMap<String, String> {\n+    let file =\n+        fs::File::open(file_name).expect(&format!(\"Couldn't read file {}\", file_name.display()));\n+    let reader = BufReader::new(file);\n+    let pattern = r\"^\\s*//\\s*rustfmt-([^:]+):\\s*(\\S+)\";\n+    let regex = regex::Regex::new(pattern).expect(\"Failed creating pattern 1\");\n+\n+    // Matches lines containing significant comments or whitespace.\n+    let line_regex = regex::Regex::new(r\"(^\\s*$)|(^\\s*//\\s*rustfmt-[^:]+:\\s*\\S+)\")\n+        .expect(\"Failed creating pattern 2\");\n+\n+    reader\n+        .lines()\n+        .map(|line| line.expect(\"Failed getting line\"))\n+        .take_while(|line| line_regex.is_match(line))\n+        .filter_map(|line| {\n+            regex.captures_iter(&line).next().map(|capture| {\n+                (\n+                    capture\n+                        .get(1)\n+                        .expect(\"Couldn't unwrap capture\")\n+                        .as_str()\n+                        .to_owned(),\n+                    capture\n+                        .get(2)\n+                        .expect(\"Couldn't unwrap capture\")\n+                        .as_str()\n+                        .to_owned(),\n+                )\n+            })\n+        }).collect()\n+}\n+\n+// Compare output to input.\n+// TODO: needs a better name, more explanation.\n+fn handle_result(\n+    result: HashMap<PathBuf, String>,\n+    target: Option<&str>,\n+) -> Result<(), IdempotentCheckError> {\n+    let mut failures = HashMap::new();\n+\n+    for (file_name, fmt_text) in result {\n+        // If file is in tests/source, compare to file with same name in tests/target.\n+        let target = get_target(&file_name, target);\n+        let open_error = format!(\"Couldn't open target {:?}\", &target);\n+        let mut f = fs::File::open(&target).expect(&open_error);\n+\n+        let mut text = String::new();\n+        let read_error = format!(\"Failed reading target {:?}\", &target);\n+        f.read_to_string(&mut text).expect(&read_error);\n+\n+        // Ignore LF and CRLF difference for Windows.\n+        if !string_eq_ignore_newline_repr(&fmt_text, &text) {\n+            let diff = make_diff(&text, &fmt_text, DIFF_CONTEXT_SIZE);\n+            assert!(\n+                !diff.is_empty(),\n+                \"Empty diff? Maybe due to a missing a newline at the end of a file?\"\n+            );\n+            failures.insert(file_name, diff);\n+        }\n+    }\n+\n+    if failures.is_empty() {\n+        Ok(())\n+    } else {\n+        Err(IdempotentCheckError::Mismatch(failures))\n+    }\n+}\n+\n+// Map source file paths to their target paths.\n+fn get_target(file_name: &Path, target: Option<&str>) -> PathBuf {\n+    if let Some(n) = file_name\n+        .components()\n+        .position(|c| c.as_os_str() == \"source\")\n+    {\n+        let mut target_file_name = PathBuf::new();\n+        for (i, c) in file_name.components().enumerate() {\n+            if i == n {\n+                target_file_name.push(\"target\");\n+            } else {\n+                target_file_name.push(c.as_os_str());\n+            }\n+        }\n+        if let Some(replace_name) = target {\n+            target_file_name.with_file_name(replace_name)\n+        } else {\n+            target_file_name\n+        }\n+    } else {\n+        // This is either and idempotence check or a self check\n+        file_name.to_owned()\n+    }\n+}\n+\n+#[test]\n+fn rustfmt_diff_make_diff_tests() {\n+    let diff = make_diff(\"a\\nb\\nc\\nd\", \"a\\ne\\nc\\nd\", 3);\n+    assert_eq!(\n+        diff,\n+        vec![Mismatch {\n+            line_number: 1,\n+            line_number_orig: 1,\n+            lines: vec![\n+                DiffLine::Context(\"a\".into()),\n+                DiffLine::Resulting(\"b\".into()),\n+                DiffLine::Expected(\"e\".into()),\n+                DiffLine::Context(\"c\".into()),\n+                DiffLine::Context(\"d\".into()),\n+            ],\n+        }]\n+    );\n+}\n+\n+#[test]\n+fn rustfmt_diff_no_diff_test() {\n+    let diff = make_diff(\"a\\nb\\nc\\nd\", \"a\\nb\\nc\\nd\", 3);\n+    assert_eq!(diff, vec![]);\n+}\n+\n+// Compare strings without distinguishing between CRLF and LF\n+fn string_eq_ignore_newline_repr(left: &str, right: &str) -> bool {\n+    let left = CharsIgnoreNewlineRepr(left.chars().peekable());\n+    let right = CharsIgnoreNewlineRepr(right.chars().peekable());\n+    left.eq(right)\n+}\n+\n+struct CharsIgnoreNewlineRepr<'a>(Peekable<Chars<'a>>);\n+\n+impl<'a> Iterator for CharsIgnoreNewlineRepr<'a> {\n+    type Item = char;\n+\n+    fn next(&mut self) -> Option<char> {\n+        self.0.next().map(|c| {\n+            if c == '\\r' {\n+                if *self.0.peek().unwrap_or(&'\\0') == '\\n' {\n+                    self.0.next();\n+                    '\\n'\n+                } else {\n+                    '\\r'\n+                }\n+            } else {\n+                c\n+            }\n+        })\n+    }\n+}\n+\n+#[test]\n+fn string_eq_ignore_newline_repr_test() {\n+    assert!(string_eq_ignore_newline_repr(\"\", \"\"));\n+    assert!(!string_eq_ignore_newline_repr(\"\", \"abc\"));\n+    assert!(!string_eq_ignore_newline_repr(\"abc\", \"\"));\n+    assert!(string_eq_ignore_newline_repr(\"a\\nb\\nc\\rd\", \"a\\nb\\r\\nc\\rd\"));\n+    assert!(string_eq_ignore_newline_repr(\"a\\r\\n\\r\\n\\r\\nb\", \"a\\n\\n\\nb\"));\n+    assert!(!string_eq_ignore_newline_repr(\"a\\r\\nbcd\", \"a\\nbcdefghijk\"));\n+}\n+\n+// This enum is used to represent one of three text features in Configurations.md: a block of code\n+// with its starting line number, the name of a rustfmt configuration option, or the value of a\n+// rustfmt configuration option.\n+enum ConfigurationSection {\n+    CodeBlock((String, u32)), // (String: block of code, u32: line number of code block start)\n+    ConfigName(String),\n+    ConfigValue(String),\n+}\n+\n+impl ConfigurationSection {\n+    fn get_section<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+    ) -> Option<ConfigurationSection> {\n+        lazy_static! {\n+            static ref CONFIG_NAME_REGEX: regex::Regex =\n+                regex::Regex::new(r\"^## `([^`]+)`\").expect(\"Failed creating configuration pattern\");\n+            static ref CONFIG_VALUE_REGEX: regex::Regex =\n+                regex::Regex::new(r#\"^#### `\"?([^`\"]+)\"?`\"#)\n+                    .expect(\"Failed creating configuration value pattern\");\n+        }\n+\n+        loop {\n+            match file.next() {\n+                Some((i, line)) => {\n+                    if line.starts_with(\"```rust\") {\n+                        // Get the lines of the code block.\n+                        let lines: Vec<String> = file\n+                            .map(|(_i, l)| l)\n+                            .take_while(|l| !l.starts_with(\"```\"))\n+                            .collect();\n+                        let block = format!(\"{}\\n\", lines.join(\"\\n\"));\n+\n+                        // +1 to translate to one-based indexing\n+                        // +1 to get to first line of code (line after \"```\")\n+                        let start_line = (i + 2) as u32;\n+\n+                        return Some(ConfigurationSection::CodeBlock((block, start_line)));\n+                    } else if let Some(c) = CONFIG_NAME_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigName(String::from(&c[1])));\n+                    } else if let Some(c) = CONFIG_VALUE_REGEX.captures(&line) {\n+                        return Some(ConfigurationSection::ConfigValue(String::from(&c[1])));\n+                    }\n+                }\n+                None => return None, // reached the end of the file\n+            }\n+        }\n+    }\n+}\n+\n+// This struct stores the information about code blocks in the configurations\n+// file, formats the code blocks, and prints formatting errors.\n+struct ConfigCodeBlock {\n+    config_name: Option<String>,\n+    config_value: Option<String>,\n+    code_block: Option<String>,\n+    code_block_start: Option<u32>,\n+}\n+\n+impl ConfigCodeBlock {\n+    fn new() -> ConfigCodeBlock {\n+        ConfigCodeBlock {\n+            config_name: None,\n+            config_value: None,\n+            code_block: None,\n+            code_block_start: None,\n+        }\n+    }\n+\n+    fn set_config_name(&mut self, name: Option<String>) {\n+        self.config_name = name;\n+        self.config_value = None;\n+    }\n+\n+    fn set_config_value(&mut self, value: Option<String>) {\n+        self.config_value = value;\n+    }\n+\n+    fn set_code_block(&mut self, code_block: String, code_block_start: u32) {\n+        self.code_block = Some(code_block);\n+        self.code_block_start = Some(code_block_start);\n+    }\n+\n+    fn get_block_config(&self) -> Config {\n+        let mut config = Config::default();\n+        if self.config_value.is_some() && self.config_value.is_some() {\n+            config.override_value(\n+                self.config_name.as_ref().unwrap(),\n+                self.config_value.as_ref().unwrap(),\n+            );\n+        }\n+        config\n+    }\n+\n+    fn code_block_valid(&self) -> bool {\n+        // We never expect to not have a code block.\n+        assert!(self.code_block.is_some() && self.code_block_start.is_some());\n+\n+        // See if code block begins with #![rustfmt::skip].\n+        let fmt_skip = self\n+            .code_block\n+            .as_ref()\n+            .unwrap()\n+            .split('\\n')\n+            .nth(0)\n+            .unwrap_or(\"\")\n+            == \"#![rustfmt::skip]\";\n+\n+        if self.config_name.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration name for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        if self.config_value.is_none() && !fmt_skip {\n+            write_message(&format!(\n+                \"No configuration value for {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return false;\n+        }\n+        true\n+    }\n+\n+    fn has_parsing_errors<T: Write>(&self, session: &Session<T>) -> bool {\n+        if session.has_parsing_errors() {\n+            write_message(&format!(\n+                \"\\u{261d}\\u{1f3fd} Cannot format {}:{}\",\n+                CONFIGURATIONS_FILE_NAME,\n+                self.code_block_start.unwrap()\n+            ));\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    fn print_diff(&self, compare: Vec<Mismatch>) {\n+        let mut mismatches = HashMap::new();\n+        mismatches.insert(PathBuf::from(CONFIGURATIONS_FILE_NAME), compare);\n+        print_mismatches(mismatches, |line_num| {\n+            format!(\n+                \"\\nMismatch at {}:{}:\",\n+                CONFIGURATIONS_FILE_NAME,\n+                line_num + self.code_block_start.unwrap() - 1\n+            )\n+        });\n+    }\n+\n+    fn formatted_has_diff(&self, text: &str) -> bool {\n+        let compare = make_diff(self.code_block.as_ref().unwrap(), text, DIFF_CONTEXT_SIZE);\n+        if !compare.is_empty() {\n+            self.print_diff(compare);\n+            return true;\n+        }\n+\n+        false\n+    }\n+\n+    // Return a bool indicating if formatting this code block is an idempotent\n+    // operation. This function also triggers printing any formatting failure\n+    // messages.\n+    fn formatted_is_idempotent(&self) -> bool {\n+        // Verify that we have all of the expected information.\n+        if !self.code_block_valid() {\n+            return false;\n+        }\n+\n+        let input = Input::Text(self.code_block.as_ref().unwrap().to_owned());\n+        let mut config = self.get_block_config();\n+        config.set().emit_mode(EmitMode::Stdout);\n+        let mut buf: Vec<u8> = vec![];\n+\n+        {\n+            let mut session = Session::new(config, Some(&mut buf));\n+            session.format(input).unwrap();\n+            if self.has_parsing_errors(&session) {\n+                return false;\n+            }\n+        }\n+\n+        !self.formatted_has_diff(&String::from_utf8(buf).unwrap())\n+    }\n+\n+    // Extract a code block from the iterator. Behavior:\n+    // - Rust code blocks are identifed by lines beginning with \"```rust\".\n+    // - One explicit configuration setting is supported per code block.\n+    // - Rust code blocks with no configuration setting are illegal and cause an\n+    //   assertion failure, unless the snippet begins with #![rustfmt::skip].\n+    // - Configuration names in Configurations.md must be in the form of\n+    //   \"## `NAME`\".\n+    // - Configuration values in Configurations.md must be in the form of\n+    //   \"#### `VALUE`\".\n+    fn extract<I: Iterator<Item = String>>(\n+        file: &mut Enumerate<I>,\n+        prev: Option<&ConfigCodeBlock>,\n+        hash_set: &mut HashSet<String>,\n+    ) -> Option<ConfigCodeBlock> {\n+        let mut code_block = ConfigCodeBlock::new();\n+        code_block.config_name = prev.and_then(|cb| cb.config_name.clone());\n+\n+        loop {\n+            match ConfigurationSection::get_section(file) {\n+                Some(ConfigurationSection::CodeBlock((block, start_line))) => {\n+                    code_block.set_code_block(block, start_line);\n+                    break;\n+                }\n+                Some(ConfigurationSection::ConfigName(name)) => {\n+                    assert!(\n+                        Config::is_valid_name(&name),\n+                        \"an unknown configuration option was found: {}\",\n+                        name\n+                    );\n+                    assert!(\n+                        hash_set.remove(&name),\n+                        \"multiple configuration guides found for option {}\",\n+                        name\n+                    );\n+                    code_block.set_config_name(Some(name));\n+                }\n+                Some(ConfigurationSection::ConfigValue(value)) => {\n+                    code_block.set_config_value(Some(value));\n+                }\n+                None => return None, // end of file was reached\n+            }\n+        }\n+\n+        Some(code_block)\n+    }\n+}\n+\n+#[test]\n+fn configuration_snippet_tests() {\n+    // Read Configurations.md and build a `Vec` of `ConfigCodeBlock` structs with one\n+    // entry for each Rust code block found.\n+    fn get_code_blocks() -> Vec<ConfigCodeBlock> {\n+        let mut file_iter = BufReader::new(\n+            fs::File::open(Path::new(CONFIGURATIONS_FILE_NAME))\n+                .expect(&format!(\"Couldn't read file {}\", CONFIGURATIONS_FILE_NAME)),\n+        ).lines()\n+        .map(|l| l.unwrap())\n+        .enumerate();\n+        let mut code_blocks: Vec<ConfigCodeBlock> = Vec::new();\n+        let mut hash_set = Config::hash_set();\n+\n+        while let Some(cb) =\n+            ConfigCodeBlock::extract(&mut file_iter, code_blocks.last(), &mut hash_set)\n+        {\n+            code_blocks.push(cb);\n+        }\n+\n+        for name in hash_set {\n+            if !Config::is_hidden_option(&name) {\n+                panic!(\"{} does not have a configuration guide\", name);\n+            }\n+        }\n+\n+        code_blocks\n+    }\n+\n+    let blocks = get_code_blocks();\n+    let failures = blocks\n+        .iter()\n+        .map(|b| b.formatted_is_idempotent())\n+        .fold(0, |acc, r| acc + (!r as u32));\n+\n+    // Display results.\n+    println!(\"Ran {} configurations tests.\", blocks.len());\n+    assert_eq!(failures, 0, \"{} configurations tests failed\", failures);\n+}\n+\n+struct TempFile {\n+    path: PathBuf,\n+}\n+\n+fn make_temp_file(file_name: &'static str) -> TempFile {\n+    use std::env::var;\n+    use std::fs::File;\n+\n+    // Used in the Rust build system.\n+    let target_dir = var(\"RUSTFMT_TEST_DIR\").unwrap_or_else(|_| \".\".to_owned());\n+    let path = Path::new(&target_dir).join(file_name);\n+\n+    let mut file = File::create(&path).expect(\"Couldn't create temp file\");\n+    let content = \"fn main() {}\\n\";\n+    file.write_all(content.as_bytes())\n+        .expect(\"Couldn't write temp file\");\n+    TempFile { path }\n+}\n+\n+impl Drop for TempFile {\n+    fn drop(&mut self) {\n+        use std::fs::remove_file;\n+        remove_file(&self.path).expect(\"Couldn't delete temp file\");\n+    }\n+}\n+\n+fn rustfmt() -> PathBuf {\n+    let mut me = env::current_exe().expect(\"failed to get current executable\");\n+    me.pop(); // chop of the test name\n+    me.pop(); // chop off `deps`\n+    me.push(\"rustfmt\");\n+    assert!(\n+        me.is_file() || me.with_extension(\"exe\").is_file(),\n+        \"no rustfmt bin, try running `cargo build` before testing\"\n+    );\n+    return me;\n+}\n+\n+#[test]\n+fn verify_check_works() {\n+    let temp_file = make_temp_file(\"temp_check.rs\");\n+    assert_cli::Assert::command(&[\n+        rustfmt().to_str().unwrap(),\n+        \"--check\",\n+        temp_file.path.to_str().unwrap(),\n+    ]).succeeds()\n+    .unwrap();\n+}"}]}