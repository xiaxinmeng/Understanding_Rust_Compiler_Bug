{"sha": "2b643e987173b36cb0279a018579372e31a35776", "node_id": "C_kwDOAAsO6NoAKDJiNjQzZTk4NzE3M2IzNmNiMDI3OWEwMTg1NzkzNzJlMzFhMzU3NzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T07:21:21Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-10-30T07:21:21Z"}, "message": "Auto merge of #89174 - ChrisDenton:automatic-verbatim-paths, r=dtolnay\n\nAutomatically convert paths to verbatim for filesystem operations that support it\n\nThis allows using longer paths without the user needing to `canonicalize` or manually prefix paths. If the path is already verbatim then this has no effect.\n\nFixes: #32689", "tree": {"sha": "26f39dc8a31536e3ae0cf12a005b9a5cc2e21af9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26f39dc8a31536e3ae0cf12a005b9a5cc2e21af9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b643e987173b36cb0279a018579372e31a35776", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b643e987173b36cb0279a018579372e31a35776", "html_url": "https://github.com/rust-lang/rust/commit/2b643e987173b36cb0279a018579372e31a35776", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b643e987173b36cb0279a018579372e31a35776/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "url": "https://api.github.com/repos/rust-lang/rust/commits/22f1ad75e95500b3cab1d07c80d04c34d0f15f96", "html_url": "https://github.com/rust-lang/rust/commit/22f1ad75e95500b3cab1d07c80d04c34d0f15f96"}, {"sha": "37e4c84b239c58196c888eabf5550f398ea0b7a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/37e4c84b239c58196c888eabf5550f398ea0b7a2", "html_url": "https://github.com/rust-lang/rust/commit/37e4c84b239c58196c888eabf5550f398ea0b7a2"}], "stats": {"total": 216, "additions": 203, "deletions": 13}, "files": [{"sha": "628de13156c67f4bff68fee4cff9f7d1161f45ed", "filename": "library/std/src/fs/tests.rs", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs%2Ftests.rs?ref=2b643e987173b36cb0279a018579372e31a35776", "patch": "@@ -1411,3 +1411,32 @@ fn symlink_hard_link() {\n     // \"hard_link\" should still appear as a symlink.\n     assert!(check!(fs::symlink_metadata(tmpdir.join(\"hard_link\"))).file_type().is_symlink());\n }\n+\n+/// Ensure `fs::create_dir` works on Windows with longer paths.\n+#[test]\n+#[cfg(windows)]\n+fn create_dir_long_paths() {\n+    use crate::{ffi::OsStr, iter, os::windows::ffi::OsStrExt};\n+    const PATH_LEN: usize = 247;\n+\n+    let tmpdir = tmpdir();\n+    let mut path = tmpdir.path().to_path_buf();\n+    path.push(\"a\");\n+    let mut path = path.into_os_string();\n+\n+    let utf16_len = path.encode_wide().count();\n+    if utf16_len >= PATH_LEN {\n+        // Skip the test in the unlikely event the local user has a long temp directory path.\n+        // This should not affect CI.\n+        return;\n+    }\n+    // Increase the length of the path.\n+    path.extend(iter::repeat(OsStr::new(\"a\")).take(PATH_LEN - utf16_len));\n+\n+    // This should succeed.\n+    fs::create_dir(&path).unwrap();\n+\n+    // This will fail if the path isn't converted to verbatim.\n+    path.push(\"a\");\n+    fs::create_dir(&path).unwrap();\n+}"}, {"sha": "9dfc8114eb596e29ad2079d4efd9d7586bee24f6", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=2b643e987173b36cb0279a018579372e31a35776", "patch": "@@ -977,6 +977,12 @@ extern \"system\" {\n         cchCount2: c_int,\n         bIgnoreCase: BOOL,\n     ) -> c_int;\n+    pub fn GetFullPathNameW(\n+        lpFileName: LPCWSTR,\n+        nBufferLength: DWORD,\n+        lpBuffer: LPWSTR,\n+        lpFilePart: *mut LPWSTR,\n+    ) -> DWORD;\n }\n \n #[link(name = \"ws2_32\")]"}, {"sha": "9859000c8d417480f97823bc6c585341d1a92bfc", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=2b643e987173b36cb0279a018579372e31a35776", "patch": "@@ -14,6 +14,7 @@ use crate::sys::time::SystemTime;\n use crate::sys::{c, cvt};\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n \n+use super::path::maybe_verbatim;\n use super::to_u16s;\n \n pub struct File {\n@@ -281,7 +282,7 @@ impl OpenOptions {\n \n impl File {\n     pub fn open(path: &Path, opts: &OpenOptions) -> io::Result<File> {\n-        let path = to_u16s(path)?;\n+        let path = maybe_verbatim(path)?;\n         let handle = unsafe {\n             c::CreateFileW(\n                 path.as_ptr(),\n@@ -706,7 +707,7 @@ impl DirBuilder {\n     }\n \n     pub fn mkdir(&self, p: &Path) -> io::Result<()> {\n-        let p = to_u16s(p)?;\n+        let p = maybe_verbatim(p)?;\n         cvt(unsafe { c::CreateDirectoryW(p.as_ptr(), ptr::null_mut()) })?;\n         Ok(())\n     }\n@@ -715,7 +716,7 @@ impl DirBuilder {\n pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n     let root = p.to_path_buf();\n     let star = p.join(\"*\");\n-    let path = to_u16s(&star)?;\n+    let path = maybe_verbatim(&star)?;\n \n     unsafe {\n         let mut wfd = mem::zeroed();\n@@ -733,20 +734,20 @@ pub fn readdir(p: &Path) -> io::Result<ReadDir> {\n }\n \n pub fn unlink(p: &Path) -> io::Result<()> {\n-    let p_u16s = to_u16s(p)?;\n+    let p_u16s = maybe_verbatim(p)?;\n     cvt(unsafe { c::DeleteFileW(p_u16s.as_ptr()) })?;\n     Ok(())\n }\n \n pub fn rename(old: &Path, new: &Path) -> io::Result<()> {\n-    let old = to_u16s(old)?;\n-    let new = to_u16s(new)?;\n+    let old = maybe_verbatim(old)?;\n+    let new = maybe_verbatim(new)?;\n     cvt(unsafe { c::MoveFileExW(old.as_ptr(), new.as_ptr(), c::MOVEFILE_REPLACE_EXISTING) })?;\n     Ok(())\n }\n \n pub fn rmdir(p: &Path) -> io::Result<()> {\n-    let p = to_u16s(p)?;\n+    let p = maybe_verbatim(p)?;\n     cvt(unsafe { c::RemoveDirectoryW(p.as_ptr()) })?;\n     Ok(())\n }\n@@ -794,7 +795,7 @@ pub fn symlink(original: &Path, link: &Path) -> io::Result<()> {\n \n pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()> {\n     let original = to_u16s(original)?;\n-    let link = to_u16s(link)?;\n+    let link = maybe_verbatim(link)?;\n     let flags = if dir { c::SYMBOLIC_LINK_FLAG_DIRECTORY } else { 0 };\n     // Formerly, symlink creation required the SeCreateSymbolicLink privilege. For the Windows 10\n     // Creators Update, Microsoft loosened this to allow unprivileged symlink creation if the\n@@ -823,8 +824,8 @@ pub fn symlink_inner(original: &Path, link: &Path, dir: bool) -> io::Result<()>\n \n #[cfg(not(target_vendor = \"uwp\"))]\n pub fn link(original: &Path, link: &Path) -> io::Result<()> {\n-    let original = to_u16s(original)?;\n-    let link = to_u16s(link)?;\n+    let original = maybe_verbatim(original)?;\n+    let link = maybe_verbatim(link)?;\n     cvt(unsafe { c::CreateHardLinkW(link.as_ptr(), original.as_ptr(), ptr::null_mut()) })?;\n     Ok(())\n }\n@@ -857,7 +858,7 @@ pub fn lstat(path: &Path) -> io::Result<FileAttr> {\n }\n \n pub fn set_perm(p: &Path, perm: FilePermissions) -> io::Result<()> {\n-    let p = to_u16s(p)?;\n+    let p = maybe_verbatim(p)?;\n     unsafe {\n         cvt(c::SetFileAttributesW(p.as_ptr(), perm.attrs))?;\n         Ok(())\n@@ -900,8 +901,8 @@ pub fn copy(from: &Path, to: &Path) -> io::Result<u64> {\n         }\n         c::PROGRESS_CONTINUE\n     }\n-    let pfrom = to_u16s(from)?;\n-    let pto = to_u16s(to)?;\n+    let pfrom = maybe_verbatim(from)?;\n+    let pto = maybe_verbatim(to)?;\n     let mut size = 0i64;\n     cvt(unsafe {\n         c::CopyFileExW("}, {"sha": "460c1eff7788d1cfd105002a9c3ab91f004bc6b0", "filename": "library/std/src/sys/windows/path.rs", "status": "modified", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath.rs?ref=2b643e987173b36cb0279a018579372e31a35776", "patch": "@@ -1,6 +1,10 @@\n+use super::{c, fill_utf16_buf, to_u16s};\n use crate::ffi::OsStr;\n+use crate::io;\n use crate::mem;\n+use crate::path::Path;\n use crate::path::Prefix;\n+use crate::ptr;\n \n #[cfg(test)]\n mod tests;\n@@ -141,3 +145,100 @@ fn parse_next_component(path: &OsStr, verbatim: bool) -> (&OsStr, &OsStr) {\n         None => (path, OsStr::new(\"\")),\n     }\n }\n+\n+/// Returns a UTF-16 encoded path capable of bypassing the legacy `MAX_PATH` limits.\n+///\n+/// This path may or may not have a verbatim prefix.\n+pub(crate) fn maybe_verbatim(path: &Path) -> io::Result<Vec<u16>> {\n+    // Normally the MAX_PATH is 260 UTF-16 code units (including the NULL).\n+    // However, for APIs such as CreateDirectory[1], the limit is 248.\n+    //\n+    // [1]: https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createdirectorya#parameters\n+    const LEGACY_MAX_PATH: usize = 248;\n+    // UTF-16 encoded code points, used in parsing and building UTF-16 paths.\n+    // All of these are in the ASCII range so they can be cast directly to `u16`.\n+    const SEP: u16 = b'\\\\' as _;\n+    const ALT_SEP: u16 = b'/' as _;\n+    const QUERY: u16 = b'?' as _;\n+    const COLON: u16 = b':' as _;\n+    const DOT: u16 = b'.' as _;\n+    const U: u16 = b'U' as _;\n+    const N: u16 = b'N' as _;\n+    const C: u16 = b'C' as _;\n+\n+    // \\\\?\\\n+    const VERBATIM_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP];\n+    // \\??\\\n+    const NT_PREFIX: &[u16] = &[SEP, QUERY, QUERY, SEP];\n+    // \\\\?\\UNC\\\n+    const UNC_PREFIX: &[u16] = &[SEP, SEP, QUERY, SEP, U, N, C, SEP];\n+\n+    let mut path = to_u16s(path)?;\n+    if path.starts_with(VERBATIM_PREFIX) || path.starts_with(NT_PREFIX) {\n+        // Early return for paths that are already verbatim.\n+        return Ok(path);\n+    } else if path.len() < LEGACY_MAX_PATH {\n+        // Early return if an absolute path is less < 260 UTF-16 code units.\n+        // This is an optimization to avoid calling `GetFullPathNameW` unnecessarily.\n+        match path.as_slice() {\n+            // Starts with `D:`, `D:\\`, `D:/`, etc.\n+            // Does not match if the path starts with a `\\` or `/`.\n+            [drive, COLON, 0] | [drive, COLON, SEP | ALT_SEP, ..]\n+                if *drive != SEP && *drive != ALT_SEP =>\n+            {\n+                return Ok(path);\n+            }\n+            // Starts with `\\\\`, `//`, etc\n+            [SEP | ALT_SEP, SEP | ALT_SEP, ..] => return Ok(path),\n+            _ => {}\n+        }\n+    }\n+\n+    // Firstly, get the absolute path using `GetFullPathNameW`.\n+    // https://docs.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-getfullpathnamew\n+    let lpfilename = path.as_ptr();\n+    fill_utf16_buf(\n+        // SAFETY: `fill_utf16_buf` ensures the `buffer` and `size` are valid.\n+        // `lpfilename` is a pointer to a null terminated string that is not\n+        // invalidated until after `GetFullPathNameW` returns successfully.\n+        |buffer, size| unsafe {\n+            // While the docs for `GetFullPathNameW` have the standard note\n+            // about needing a `\\\\?\\` path for a long lpfilename, this does not\n+            // appear to be true in practice.\n+            // See:\n+            // https://stackoverflow.com/questions/38036943/getfullpathnamew-and-long-windows-file-paths\n+            // https://googleprojectzero.blogspot.com/2016/02/the-definitive-guide-on-win32-to-nt.html\n+            c::GetFullPathNameW(lpfilename, size, buffer, ptr::null_mut())\n+        },\n+        |mut absolute| {\n+            path.clear();\n+\n+            // Secondly, add the verbatim prefix. This is easier here because we know the\n+            // path is now absolute and fully normalized (e.g. `/` has been changed to `\\`).\n+            let prefix = match absolute {\n+                // C:\\ => \\\\?\\C:\\\n+                [_, COLON, SEP, ..] => VERBATIM_PREFIX,\n+                // \\\\.\\ => \\\\?\\\n+                [SEP, SEP, DOT, SEP, ..] => {\n+                    absolute = &absolute[4..];\n+                    VERBATIM_PREFIX\n+                }\n+                // Leave \\\\?\\ and \\??\\ as-is.\n+                [SEP, SEP, QUERY, SEP, ..] | [SEP, QUERY, QUERY, SEP, ..] => &[],\n+                // \\\\ => \\\\?\\UNC\\\n+                [SEP, SEP, ..] => {\n+                    absolute = &absolute[2..];\n+                    UNC_PREFIX\n+                }\n+                // Anything else we leave alone.\n+                _ => &[],\n+            };\n+\n+            path.reserve_exact(prefix.len() + absolute.len() + 1);\n+            path.extend_from_slice(prefix);\n+            path.extend_from_slice(absolute);\n+            path.push(0);\n+        },\n+    )?;\n+    Ok(path)\n+}"}, {"sha": "c6c84519f419cbe750582153d96e906d59e7de69", "filename": "library/std/src/sys/windows/path/tests.rs", "status": "modified", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b643e987173b36cb0279a018579372e31a35776/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=2b643e987173b36cb0279a018579372e31a35776", "patch": "@@ -42,3 +42,56 @@ fn test_parse_next_component() {\n         (OsStr::new(r\"server\"), OsStr::new(r\"\\\\\\\\\\\\\\\\\\\\\\\\\\share\"))\n     );\n }\n+\n+#[test]\n+fn verbatim() {\n+    use crate::path::Path;\n+    fn check(path: &str, expected: &str) {\n+        let verbatim = maybe_verbatim(Path::new(path)).unwrap();\n+        let verbatim = String::from_utf16_lossy(verbatim.strip_suffix(&[0]).unwrap());\n+        assert_eq!(&verbatim, expected, \"{}\", path);\n+    }\n+\n+    // Ensure long paths are correctly prefixed.\n+    check(\n+        r\"C:\\Program Files\\Rust\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\C:\\Program Files\\Rust\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    check(\n+        r\"\\\\server\\share\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\UNC\\server\\share\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    check(\n+        r\"\\\\.\\PIPE\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\PIPE\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    // `\\\\?\\` prefixed paths are left unchanged...\n+    check(\n+        r\"\\\\?\\verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+    // But `//?/` is not a verbatim prefix so it will be normalized.\n+    check(\n+        r\"//?/E:/verbatim.\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+        r\"\\\\?\\E:\\verbatim\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\\foo.txt\",\n+    );\n+\n+    // For performance, short absolute paths are left unchanged.\n+    check(r\"C:\\Program Files\\Rust\", r\"C:\\Program Files\\Rust\");\n+    check(r\"\\\\server\\share\", r\"\\\\server\\share\");\n+    check(r\"\\\\.\\COM1\", r\"\\\\.\\COM1\");\n+\n+    // Check that paths of length 247 are converted to verbatim.\n+    // This is necessary for `CreateDirectory`.\n+    check(\n+        r\"C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n+        r\"\\\\?\\C:\\aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n+    );\n+\n+    // Make sure opening a drive will work.\n+    check(\"Z:\", \"Z:\");\n+\n+    // An empty path or a path that contains null are not valid paths.\n+    assert!(maybe_verbatim(Path::new(\"\")).is_err());\n+    assert!(maybe_verbatim(Path::new(\"\\0\")).is_err());\n+}"}]}