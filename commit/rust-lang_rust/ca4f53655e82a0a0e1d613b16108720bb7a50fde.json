{"sha": "ca4f53655e82a0a0e1d613b16108720bb7a50fde", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNhNGY1MzY1NWU4MmEwYTBlMWQ2MTNiMTYxMDg3MjBiYjdhNTBmZGU=", "commit": {"author": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2014-11-23T17:22:30Z"}, "committer": {"name": "Barosl Lee", "email": "vcs@barosl.com", "date": "2014-12-08T09:02:12Z"}, "message": "libserialize: Remove float preprocessing in serialize::json::Encoder\n\nserialize::json::Encoder currently uses f64 to emit any integral type.\nThis is possibly due to the behavior of JavaScript, which uses f64 to\nrepresent any numeric value.\n\nThis leads to a problem that only the integers in the range of [-2^53+1,\n2^53-1] can be encoded. Therefore, i64 and u64 cannot be used reliably\nin the current implementation.\n\nRFC 7159 suggests that good interoperability can be achieved if the\nrange is respected by implementations. However, it also says that\nimplementations are allowed to set the range of number accepted. And it\nseems that the JSON encoders outside of the JavaScript world usually\nmake use of i64 values.\n\nThis commit removes the float preprocessing done in the emit_* methods.\nIt also increases performance, because transforming f64 into String\ncosts more than that of an integral type.\n\nFixes #18319\n\n[breaking-change]", "tree": {"sha": "72d36b4ee75e4676c5610c0b1b8c6024f7b82746", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/72d36b4ee75e4676c5610c0b1b8c6024f7b82746"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ca4f53655e82a0a0e1d613b16108720bb7a50fde", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ca4f53655e82a0a0e1d613b16108720bb7a50fde", "html_url": "https://github.com/rust-lang/rust/commit/ca4f53655e82a0a0e1d613b16108720bb7a50fde", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ca4f53655e82a0a0e1d613b16108720bb7a50fde/comments", "author": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "committer": {"login": "barosl", "id": 573768, "node_id": "MDQ6VXNlcjU3Mzc2OA==", "avatar_url": "https://avatars.githubusercontent.com/u/573768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/barosl", "html_url": "https://github.com/barosl", "followers_url": "https://api.github.com/users/barosl/followers", "following_url": "https://api.github.com/users/barosl/following{/other_user}", "gists_url": "https://api.github.com/users/barosl/gists{/gist_id}", "starred_url": "https://api.github.com/users/barosl/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/barosl/subscriptions", "organizations_url": "https://api.github.com/users/barosl/orgs", "repos_url": "https://api.github.com/users/barosl/repos", "events_url": "https://api.github.com/users/barosl/events{/privacy}", "received_events_url": "https://api.github.com/users/barosl/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "url": "https://api.github.com/repos/rust-lang/rust/commits/83a44c7fa676b4e5e546ce3d4624e585f9a1e899", "html_url": "https://github.com/rust-lang/rust/commit/83a44c7fa676b4e5e546ce3d4624e585f9a1e899"}], "stats": {"total": 45, "additions": 24, "deletions": 21}, "files": [{"sha": "371034746fc7795dfa3f479932821ef4523b4888", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ca4f53655e82a0a0e1d613b16108720bb7a50fde/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ca4f53655e82a0a0e1d613b16108720bb7a50fde/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=ca4f53655e82a0a0e1d613b16108720bb7a50fde", "patch": "@@ -419,17 +419,17 @@ impl<'a> Encoder<'a> {\n impl<'a> ::Encoder<io::IoError> for Encoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult  { self.emit_f64(v as f64) }\n-\n-    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult  { self.emit_f64(v as f64) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+\n+    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n@@ -620,17 +620,17 @@ impl<'a> PrettyEncoder<'a> {\n impl<'a> ::Encoder<io::IoError> for PrettyEncoder<'a> {\n     fn emit_nil(&mut self) -> EncodeResult { write!(self.writer, \"null\") }\n \n-    fn emit_uint(&mut self, v: uint) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u64(&mut self, v: u64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u32(&mut self, v: u32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u16(&mut self, v: u16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_u8(&mut self, v: u8) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_uint(&mut self, v: uint) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u64(&mut self, v: u64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u32(&mut self, v: u32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u16(&mut self, v: u16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_u8(&mut self, v: u8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n-    fn emit_int(&mut self, v: int) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i64(&mut self, v: i64) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i32(&mut self, v: i32) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i16(&mut self, v: i16) -> EncodeResult { self.emit_f64(v as f64) }\n-    fn emit_i8(&mut self, v: i8) -> EncodeResult { self.emit_f64(v as f64) }\n+    fn emit_int(&mut self, v: int) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i64(&mut self, v: i64) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i32(&mut self, v: i32) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i16(&mut self, v: i16) -> EncodeResult { write!(self.writer, \"{}\", v) }\n+    fn emit_i8(&mut self, v: i8) -> EncodeResult { write!(self.writer, \"{}\", v) }\n \n     fn emit_bool(&mut self, v: bool) -> EncodeResult {\n         if v {\n@@ -2500,6 +2500,9 @@ mod tests {\n \n         assert_eq!(I64(-5678).to_string().into_string(), \"-5678\");\n         assert_eq!(I64(-5678).to_pretty_str().into_string(), \"-5678\");\n+\n+        assert_eq!(U64(7650007200025252000).to_string(), \"7650007200025252000\");\n+        assert_eq!(U64(7650007200025252000).to_pretty_str(), \"7650007200025252000\");\n     }\n \n     #[test]"}]}