{"sha": "c7e967148c0de44efe325a9ab8c25b990da53acb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM3ZTk2NzE0OGMwZGU0NGVmZTMyNWE5YWI4YzI1Yjk5MGRhNTNhY2I=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-12T18:13:15Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-07-23T01:45:34Z"}, "message": "Task-ified the word count program.\n\nThis meant most of the generic-ness of it had to go away, since our\ntype system doesn't quite support it yet. Hopefully someday...\n\nThis version has lots of memory management errors. My next commit will\nhopefully fix these.", "tree": {"sha": "8af5fc5e1e850d2323c04204165d2fa8c4730eb6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8af5fc5e1e850d2323c04204165d2fa8c4730eb6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7e967148c0de44efe325a9ab8c25b990da53acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7e967148c0de44efe325a9ab8c25b990da53acb", "html_url": "https://github.com/rust-lang/rust/commit/c7e967148c0de44efe325a9ab8c25b990da53acb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7e967148c0de44efe325a9ab8c25b990da53acb/comments", "author": null, "committer": null, "parents": [{"sha": "0cacbe901d0defe79188b08e6b8d224456a34653", "url": "https://api.github.com/repos/rust-lang/rust/commits/0cacbe901d0defe79188b08e6b8d224456a34653", "html_url": "https://github.com/rust-lang/rust/commit/0cacbe901d0defe79188b08e6b8d224456a34653"}], "stats": {"total": 170, "additions": 117, "deletions": 53}, "files": [{"sha": "e22e77d0a530ad4e450d0b763e5f4ef63524c381", "filename": "src/test/bench/task-perf/word-count.rs", "status": "modified", "additions": 117, "deletions": 53, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/c7e967148c0de44efe325a9ab8c25b990da53acb/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7e967148c0de44efe325a9ab8c25b990da53acb/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Ftask-perf%2Fword-count.rs?ref=c7e967148c0de44efe325a9ab8c25b990da53acb", "patch": "@@ -18,6 +18,35 @@ import std::str;\n import std::vec;\n import std::map;\n \n+fn map(str filename, map_reduce::putter emit) {\n+    auto f = io::file_reader(filename);\n+\n+    while(true) {\n+        alt(read_word(f)) {\n+            case (some(?w)) {\n+                emit(w, \"1\");\n+            }\n+            case (none) {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+fn reduce(str word, map_reduce::getter get) {\n+    auto count = 0;\n+\n+    while(true) {\n+        alt(get()) {\n+            case(some(_)) { count += 1 }\n+            case(none) { break }\n+        }\n+    }\n+\n+    auto out = io::stdout();\n+    out.write_line(#fmt(\"%s: %d\", word, count));\n+}\n+\n mod map_reduce {\n     export putter;\n     export getter;\n@@ -33,84 +62,119 @@ mod map_reduce {\n \n     type reducer = fn(str, getter);\n \n+    tag ctrl_proto {\n+        find_reducer(str, chan[chan[reduce_proto]]);\n+        mapper_done;\n+    }\n+\n+    tag reduce_proto {\n+        emit_val(str);\n+        done;\n+    }\n+\n+    fn start_mappers(chan[ctrl_proto] ctrl,\n+                     vec[str] inputs) {\n+        for(str i in inputs) {\n+            spawn map_task(ctrl, i);\n+        }\n+    }\n+\n+    fn map_task(chan[ctrl_proto] ctrl,\n+                str input) {\n \n-    fn map_reduce (vec[str] inputs,\n-                   mapper f,\n-                   reducer reduce) {\n-        auto intermediates = map::new_str_hash[vec[str]]();\n+        auto intermediates = map::new_str_hash();\n \n-        fn emit(&map::hashmap[str, vec[str]] im,\n+        fn emit(&map::hashmap[str, chan[reduce_proto]] im,\n+                chan[ctrl_proto] ctrl,\n                 str key, str val) {\n-            auto old = [];\n-            alt(im.remove(key)) {\n-                case (some(?v)) {\n-                    old = v;\n+            auto c;\n+            alt(im.find(key)) {\n+                case(some(?_c)) {\n+                    c = _c\n+                }\n+                case(none) {\n+                    auto p = port[chan[reduce_proto]]();\n+                    ctrl <| find_reducer(key, chan(p));\n+                    p |> c;\n+                    im.insert(key, c);\n                 }\n-                case (none) { }\n             }\n-\n-            im.insert(key, old + [val]);\n+            c <| emit_val(val);\n         }\n \n-        for (str i in inputs) {\n-            f(i, bind emit(intermediates, _, _));\n-        }\n+        map(input, bind emit(intermediates, ctrl, _, _));\n+        ctrl <| mapper_done;\n+    }\n \n-        fn get(vec[str] vals, &mutable uint i) -> option[str] {\n-            i += 1u;\n-            if(i <= vec::len(vals)) {\n-                some(vals.(i - 1u))\n-            }\n-            else {\n-                none\n+    fn reduce_task(str key, chan[chan[reduce_proto]] out) {\n+        auto p = port();\n+\n+        out <| chan(p);\n+\n+        fn get(port[reduce_proto] p) -> option[str] {\n+            auto m;\n+            p |> m;\n+\n+            alt(m) {\n+                case(emit_val(?v)) { ret some(v); }\n+                case(done) { ret none; }\n             }\n         }\n \n-        for each (@tup(str, vec[str]) kv in intermediates.items()) {\n-            auto i = 0u;\n-            reduce(kv._0, bind get(kv._1, i));\n-        }\n+        reduce(key, bind get(p));\n     }\n-}\n \n-fn main(vec[str] argv) {\n-    if(vec::len(argv) < 2u) {\n-        auto out = io::stdout();\n+    fn map_reduce (vec[str] inputs) {\n+        auto ctrl = port[ctrl_proto]();\n \n-        out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n-        fail;\n-    }\n+        // This task becomes the master control task. It spawns others\n+        // to do the rest.\n \n-    fn map(str filename, map_reduce::putter emit) {\n-        auto f = io::file_reader(filename);\n+        let map::hashmap[str, chan[reduce_proto]] reducers;\n \n-        while(true) {\n-            alt(read_word(f)) {\n-                case (some(?w)) {\n-                    emit(w, \"1\");\n-                }\n-                case (none) {\n-                    break;\n+        reducers = map::new_str_hash();\n+\n+        start_mappers(chan(ctrl), inputs);\n+\n+        auto num_mappers = vec::len(inputs) as int;\n+\n+        while(num_mappers > 0) {\n+            auto m;\n+            ctrl |> m;\n+\n+            alt(m) {\n+                case(mapper_done) { num_mappers -= 1; }\n+                case(find_reducer(?k, ?cc)) {\n+                    auto c;\n+                    alt(reducers.find(k)) {\n+                        case(some(?_c)) { c = _c; }\n+                        case(none) {\n+                            auto p = port();\n+                            spawn reduce_task(k, chan(p));\n+                            p |> c;\n+                            reducers.insert(k, c);\n+                        }\n+                    }\n+                    cc <| c;\n                 }\n             }\n         }\n-    }\n \n-    fn reduce(str word, map_reduce::getter get) {\n-        auto count = 0;\n-\n-        while(true) {\n-            alt(get()) {\n-                case(some(_)) { count += 1 }\n-                case(none) { break }\n-            }\n+        for each(@tup(str, chan[reduce_proto]) kv in reducers.items()) {\n+            kv._1 <| done;\n         }\n+    }\n+}\n \n+fn main(vec[str] argv) {\n+    if(vec::len(argv) < 2u) {\n         auto out = io::stdout();\n-        out.write_line(#fmt(\"%s: %d\", word, count));\n+\n+        out.write_line(#fmt(\"Usage: %s <filename> ...\", argv.(0)));\n+        fail;\n     }\n \n-    map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)), map, reduce);\n+    map_reduce::map_reduce(vec::slice(argv, 1u, vec::len(argv)));\n }\n \n fn read_word(io::reader r) -> option[str] {"}]}