{"sha": "286be2d94e8904765e1ef0f5fcc2899f8501a654", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4NmJlMmQ5NGU4OTA0NzY1ZTFlZjBmNWZjYzI4OTlmODUwMWE2NTQ=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-02T01:42:29Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-08-02T01:43:05Z"}, "message": "Adding an intrinsic for recv.", "tree": {"sha": "c025c461035782706223952036b4c3e716ac169f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c025c461035782706223952036b4c3e716ac169f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/286be2d94e8904765e1ef0f5fcc2899f8501a654", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/286be2d94e8904765e1ef0f5fcc2899f8501a654", "html_url": "https://github.com/rust-lang/rust/commit/286be2d94e8904765e1ef0f5fcc2899f8501a654", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/286be2d94e8904765e1ef0f5fcc2899f8501a654/comments", "author": null, "committer": null, "parents": [{"sha": "2f7ed335178c7fbe5d35e015774ca06486c69ce3", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f7ed335178c7fbe5d35e015774ca06486c69ce3", "html_url": "https://github.com/rust-lang/rust/commit/2f7ed335178c7fbe5d35e015774ca06486c69ce3"}], "stats": {"total": 262, "additions": 209, "deletions": 53}, "files": [{"sha": "24f501ad0f57e009a9a31fbba82fc6ad73571ebc", "filename": "src/rt/intrinsics/intrinsics.cpp", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.cpp?ref=286be2d94e8904765e1ef0f5fcc2899f8501a654", "patch": "@@ -55,3 +55,8 @@ rust_intrinsic_addr_of(rust_task *task, void **retptr, type_desc *ty,\n     *retptr = valptr;\n }\n \n+extern \"C\" void\n+rust_intrinsic_recv(rust_task *task, void **retptr, type_desc *ty,\n+                    rust_port *port) {\n+    port_recv(task, (uintptr_t*)*retptr, port);\n+}"}, {"sha": "8f02e4b3d9809dd30ab3849950d0ace69a0905f0", "filename": "src/rt/intrinsics/intrinsics.ll.bak", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak", "raw_url": "https://github.com/rust-lang/rust/raw/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.bak?ref=286be2d94e8904765e1ef0f5fcc2899f8501a654", "patch": "@@ -0,0 +1,149 @@\n+; ModuleID = 'intrinsics.cpp'\n+target triple = \"@CFG_LLVM_TRIPLE@\"\n+\n+%struct.rust_task = type { i32, %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %class.context, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, %class.lock_and_signal }\n+%struct.stk_seg = type { i32, i32, [0 x i8] }\n+%struct.gc_alloc = type { %struct.gc_alloc*, %struct.gc_alloc*, i32, [0 x i8] }\n+%struct.rust_scheduler = type { %class.rust_thread, %struct.rc_base, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, %class.hash_map, %class.hash_map.3, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env* }\n+%class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n+%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n+%struct.__darwin_pthread_handler_rec = type { {}*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct.rc_base = type { i32 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n+%struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list.0, i8, i8, %class.lock_and_signal, i8 }\n+%class.array_list.0 = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n+%\"struct.memory_region::alloc_header\" = type { i32, i32, i8*, [0 x i8] }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t*, i8, i8 }\n+%struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n+%struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n+%class.indexed_list = type { i32 (...)**, %class.array_list }\n+%class.array_list = type { i32, %struct.rust_task**, i32 }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, {}*, {}*, {}*, {}*, {}*, {}*, i32, {}*, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n+%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n+%struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.4, %struct.randctx, i32, i32, i32, %struct.rust_env* }\n+%class.array_list.4 = type { i32, %struct.rust_scheduler**, i32 }\n+%class.hash_map = type { %\"struct.hash_map<rust_task *, rust_task *>::map_entry\"* }\n+%\"struct.hash_map<rust_task *, rust_task *>::map_entry\" = type opaque\n+%class.hash_map.3 = type { %\"struct.hash_map<rust_port *, rust_port *>::map_entry\"* }\n+%\"struct.hash_map<rust_port *, rust_port *>::map_entry\" = type opaque\n+%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n+%struct.rust_cond = type { i8 }\n+%class.timer = type { i32 (...)**, i64, i64 }\n+%class.context = type { %struct.registers_t, %class.context* }\n+%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n+%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n+%struct.rust_vec = type { %struct.rc_base.5, i32, i32, i32, [0 x i8] }\n+%struct.rc_base.5 = type { i32 }\n+%struct.rust_ivec = type { i32, i32, %union.rust_ivec_payload }\n+%union.rust_ivec_payload = type { %struct.rust_ivec_heap* }\n+%struct.rust_ivec_heap = type { i32, [0 x i8] }\n+%class.rust_port = type { i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.ptr_vec, %class.ptr_vec.7, %class.rust_chan*, %class.lock_and_signal }\n+%class.ptr_vec = type { %struct.rust_task*, i32, i32, %struct.rust_token** }\n+%struct.rust_token = type opaque\n+%class.ptr_vec.7 = type { %struct.rust_task*, i32, i32, %class.rust_chan** }\n+%class.rust_chan = type { i32, %class.rust_kernel*, %struct.rust_task*, %class.rust_port*, i32, %class.circular_buffer }\n+%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n+\n+@.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n+@.str1 = private unnamed_addr constant [15 x i8] c\"intrinsics.cpp\\00\", align 1\n+\n+define linkonce_odr void @rust_intrinsic_vec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_vec* nocapture %v) nounwind {\n+entry:\n+  %fill = getelementptr inbounds %struct.rust_vec* %v, i32 0, i32 2\n+  %tmp1 = load i32* %fill, align 4, !tbaa !0\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp3 = load i32* %size, align 4, !tbaa !0\n+  %div = udiv i32 %tmp1, %tmp3\n+  store i32 %div, i32* %retptr, align 4, !tbaa !0\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_ivec_len(%struct.rust_task* nocapture %task, i32* nocapture %retptr, %struct.type_desc* nocapture %ty, %struct.rust_ivec* nocapture %v) nounwind {\n+entry:\n+  %fill1 = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 0\n+  %tmp2 = load i32* %fill1, align 4, !tbaa !0\n+  %tobool = icmp eq i32 %tmp2, 0\n+  br i1 %tobool, label %if.else, label %if.end17\n+\n+if.else:                                          ; preds = %entry\n+  %ptr = getelementptr inbounds %struct.rust_ivec* %v, i32 0, i32 2, i32 0\n+  %tmp7 = load %struct.rust_ivec_heap** %ptr, align 4, !tbaa !3\n+  %tobool8 = icmp eq %struct.rust_ivec_heap* %tmp7, null\n+  br i1 %tobool8, label %if.end17, label %if.then9\n+\n+if.then9:                                         ; preds = %if.else\n+  %fill14 = getelementptr inbounds %struct.rust_ivec_heap* %tmp7, i32 0, i32 0\n+  %tmp15 = load i32* %fill14, align 4, !tbaa !0\n+  br label %if.end17\n+\n+if.end17:                                         ; preds = %if.else, %entry, %if.then9\n+  %fill.0 = phi i32 [ %tmp15, %if.then9 ], [ %tmp2, %entry ], [ 0, %if.else ]\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp20 = load i32* %size, align 4, !tbaa !0\n+  %div = udiv i32 %fill.0, %tmp20\n+  store i32 %div, i32* %retptr, align 4, !tbaa !0\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_ptr_offset(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %ptr, i32 %count) nounwind {\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %ty, i32 0, i32 1\n+  %tmp1 = load i32* %size, align 4, !tbaa !0\n+  %mul = mul i32 %tmp1, %count\n+  %arrayidx = getelementptr inbounds i8* %ptr, i32 %mul\n+  store i8* %arrayidx, i8** %retptr, align 4, !tbaa !3\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_cast(%struct.rust_task* %task, i8* nocapture %retptr, %struct.type_desc* nocapture %t1, %struct.type_desc* nocapture %t2, i8* nocapture %src) {\n+entry:\n+  %size = getelementptr inbounds %struct.type_desc* %t1, i32 0, i32 1\n+  %tmp1 = load i32* %size, align 4, !tbaa !0\n+  %size3 = getelementptr inbounds %struct.type_desc* %t2, i32 0, i32 1\n+  %tmp4 = load i32* %size3, align 4, !tbaa !0\n+  %cmp = icmp eq i32 %tmp1, %tmp4\n+  br i1 %cmp, label %if.end, label %if.then\n+\n+if.then:                                          ; preds = %entry\n+  tail call void @upcall_fail(%struct.rust_task* %task, i8* getelementptr inbounds ([42 x i8]* @.str, i32 0, i32 0), i8* getelementptr inbounds ([15 x i8]* @.str1, i32 0, i32 0), i32 45)\n+  br label %return\n+\n+if.end:                                           ; preds = %entry\n+  tail call void @llvm.memmove.p0i8.p0i8.i32(i8* %retptr, i8* %src, i32 %tmp1, i32 1, i1 false)\n+  br label %return\n+\n+return:                                           ; preds = %if.end, %if.then\n+  ret void\n+}\n+\n+declare void @upcall_fail(%struct.rust_task*, i8*, i8*, i32)\n+\n+declare void @llvm.memmove.p0i8.p0i8.i32(i8* nocapture, i8* nocapture, i32, i32, i1) nounwind\n+\n+define linkonce_odr void @rust_intrinsic_addr_of(%struct.rust_task* nocapture %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, i8* %valptr) nounwind {\n+entry:\n+  store i8* %valptr, i8** %retptr, align 4, !tbaa !3\n+  ret void\n+}\n+\n+define linkonce_odr void @rust_intrinsic_recv(%struct.rust_task* %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+entry:\n+  %tmp2 = load i8** %retptr, align 4, !tbaa !3\n+  %0 = bitcast i8* %tmp2 to i32*\n+  tail call void @port_recv(%struct.rust_task* %task, i32* %0, %class.rust_port* %port)\n+  ret void\n+}\n+\n+declare void @port_recv(%struct.rust_task*, i32*, %class.rust_port*)\n+\n+!0 = metadata !{metadata !\"long\", metadata !1}\n+!1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n+!2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}\n+!3 = metadata !{metadata !\"any pointer\", metadata !1}"}, {"sha": "8f02e4b3d9809dd30ab3849950d0ace69a0905f0", "filename": "src/rt/intrinsics/intrinsics.ll.in", "status": "modified", "additions": 52, "deletions": 51, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "raw_url": "https://github.com/rust-lang/rust/raw/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fintrinsics%2Fintrinsics.ll.in?ref=286be2d94e8904765e1ef0f5fcc2899f8501a654", "patch": "@@ -1,64 +1,55 @@\n ; ModuleID = 'intrinsics.cpp'\n target triple = \"@CFG_LLVM_TRIPLE@\"\n \n-%0 = type { i32, i8**, i32 }\n-%1 = type { i32, %struct.rust_task**, i32 }\n-%2 = type { %\"struct.hash_map<rust_port *, rust_handle<rust_port> *>::map_entry\"* }\n-%3 = type { %\"struct.hash_map<rust_scheduler *, rust_handle<rust_scheduler> *>::map_entry\"* }\n-%4 = type { i32, %class.rust_task_thread**, i32 }\n-%5 = type { i32 (...)**, %6 }\n-%6 = type { i32, %class.rust_message_queue**, i32 }\n-%7 = type opaque\n-%8 = type opaque\n-%9 = type { %\"struct.hash_map<rust_task *, rust_proxy<rust_task> *>::map_entry\"* }\n-%10 = type { %\"struct.hash_map<rust_port *, rust_proxy<rust_port> *>::map_entry\"* }\n-%class.array_list = type { i32, %struct.maybe_proxy**, i32 }\n-%class.context = type { %struct.registers_t, %class.context* }\n-%class.hash_map = type { %\"struct.hash_map<rust_task *, rust_handle<rust_task> *>::map_entry\"* }\n-%class.indexed_list = type { i32 (...)**, %1 }\n-%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t*, i8 }\n-%class.lock_free_queue = type { i32 (...)**, %\"struct.lock_free_queue<rust_message *>::pointer_t\", %\"struct.lock_free_queue<rust_message *>::pointer_t\" }\n-%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %0, i8, i8, %class.lock_and_signal }\n-%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n-%class.rust_handle = type opaque\n-%class.rust_kernel = type { %class.rust_thread, %class.memory_region*, %class.rust_log, %class.rust_srv*, %class.hash_map, %2, %3, i8, %class.lock_and_signal, %4, %struct.rust_scheduler*, %class.lock_and_signal, %5 }\n-%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8, i8 }\n-%class.rust_message_queue = type { %class.lock_free_queue, %class.memory_region, %class.rust_kernel*, %8*, i32 }\n-%class.rust_srv = type { i32 (...)**, %class.memory_region }\n-%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n-%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n-%class.rust_task_thread = type { %class.rust_thread, i32, %class.rust_kernel* }\n+%struct.rust_task = type { i32, %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %class.context, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, i8, i8, %class.lock_and_signal }\n+%struct.stk_seg = type { i32, i32, [0 x i8] }\n+%struct.gc_alloc = type { %struct.gc_alloc*, %struct.gc_alloc*, i32, [0 x i8] }\n+%struct.rust_scheduler = type { %class.rust_thread, %struct.rc_base, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %class.rust_kernel*, i32, %class.hash_map, %class.hash_map.3, i32, %class.lock_and_signal, i32, %struct._opaque_pthread_attr_t, %struct.rust_env* }\n %class.rust_thread = type { i32 (...)**, i8, %struct._opaque_pthread_t* }\n-%class.timer = type { i32 (...)**, i64, i64 }\n-%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n-%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n-%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n-%struct.__darwin_pthread_handler_rec = type { void (i8*)*, i8*, %struct.__darwin_pthread_handler_rec* }\n-%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n+%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n+%struct.__darwin_pthread_handler_rec = type { {}*, i8*, %struct.__darwin_pthread_handler_rec* }\n+%struct.rc_base = type { i32 }\n+%class.rust_log = type { i32 (...)**, %class.rust_srv*, %struct.rust_scheduler*, i8 }\n+%class.rust_srv = type { i32 (...)**, %struct.rust_env*, %class.memory_region }\n+%struct.rust_env = type { i32, i32, i8*, i8, i8, i8* }\n+%class.memory_region = type { i32 (...)**, %class.rust_srv*, %class.memory_region*, i32, %class.array_list.0, i8, i8, %class.lock_and_signal, i8 }\n+%class.array_list.0 = type { i32, %\"struct.memory_region::alloc_header\"**, i32 }\n+%\"struct.memory_region::alloc_header\" = type { i32, i32, i8*, [0 x i8] }\n+%class.lock_and_signal = type { i32 (...)**, %struct._opaque_pthread_cond_t, %struct._opaque_pthread_mutex_t, %struct._opaque_pthread_t*, i8, i8 }\n %struct._opaque_pthread_cond_t = type { i32, [24 x i8] }\n %struct._opaque_pthread_mutex_t = type { i32, [40 x i8] }\n-%struct._opaque_pthread_t = type { i32, %struct.__darwin_pthread_handler_rec*, [596 x i8] }\n-%struct.gc_alloc = type { %struct.gc_alloc*, %struct.gc_alloc*, i32, [0 x i8] }\n-%\"struct.hash_map<rust_port *, rust_handle<rust_port> *>::map_entry\" = type opaque\n-%\"struct.hash_map<rust_port *, rust_proxy<rust_port> *>::map_entry\" = type opaque\n-%\"struct.hash_map<rust_scheduler *, rust_handle<rust_scheduler> *>::map_entry\" = type opaque\n-%\"struct.hash_map<rust_task *, rust_handle<rust_task> *>::map_entry\" = type opaque\n-%\"struct.hash_map<rust_task *, rust_proxy<rust_task> *>::map_entry\" = type opaque\n-%\"struct.lock_free_queue<rust_message *>::node_t\" = type { %7*, %\"struct.lock_free_queue<rust_message *>::pointer_t\" }\n-%\"struct.lock_free_queue<rust_message *>::pointer_t\" = type { %\"struct.lock_free_queue<rust_message *>::node_t\"*, i32 }\n-%struct.maybe_proxy = type { %struct.rc_base, %struct.rust_task* }\n+%class.rust_task_list = type { %class.indexed_list, %struct.rust_scheduler*, i8* }\n+%class.indexed_list = type { i32 (...)**, %class.array_list }\n+%class.array_list = type { i32, %struct.rust_task**, i32 }\n+%class.rust_crate_cache = type { %struct.type_desc*, %struct.rust_scheduler*, i32 }\n+%struct.type_desc = type { %struct.type_desc**, i32, i32, {}*, {}*, {}*, {}*, {}*, {}*, i32, {}*, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n+%struct.UT_hash_handle = type { %struct.UT_hash_table*, i8*, i8*, %struct.UT_hash_handle*, %struct.UT_hash_handle*, i8*, i32, i32 }\n+%struct.UT_hash_table = type { %struct.UT_hash_bucket*, i32, i32, i32, %struct.UT_hash_handle*, i32, i32, i32, i32, i32 }\n+%struct.UT_hash_bucket = type { %struct.UT_hash_handle*, i32, i32 }\n %struct.randctx = type { i32, [256 x i32], [256 x i32], i32, i32, i32 }\n-%struct.rc_base = type { i32 }\n-%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n+%class.rust_kernel = type { i32 (...)**, %class.memory_region, %class.rust_log, %class.rust_srv*, %class.lock_and_signal, %class.array_list.4, %struct.randctx, i32, i32, i32, %struct.rust_env* }\n+%class.array_list.4 = type { i32, %struct.rust_scheduler**, i32 }\n+%class.hash_map = type { %\"struct.hash_map<rust_task *, rust_task *>::map_entry\"* }\n+%\"struct.hash_map<rust_task *, rust_task *>::map_entry\" = type opaque\n+%class.hash_map.3 = type { %\"struct.hash_map<rust_port *, rust_port *>::map_entry\"* }\n+%\"struct.hash_map<rust_port *, rust_port *>::map_entry\" = type opaque\n+%struct._opaque_pthread_attr_t = type { i32, [36 x i8] }\n %struct.rust_cond = type { i8 }\n+%class.timer = type { i32 (...)**, i64, i64 }\n+%class.context = type { %struct.registers_t, %class.context* }\n+%struct.registers_t = type { i32, i32, i32, i32, i32, i32, i32, i32, i16, i16, i16, i16, i16, i16, i32, i32 }\n+%\"class.rust_task::wakeup_callback\" = type { i32 (...)** }\n+%struct.rust_vec = type { %struct.rc_base.5, i32, i32, i32, [0 x i8] }\n+%struct.rc_base.5 = type { i32 }\n %struct.rust_ivec = type { i32, i32, %union.rust_ivec_payload }\n-%struct.rust_ivec_heap = type { i32, [0 x i8] }\n-%struct.rust_scheduler = type { %struct.rc_base, i32, %class.rust_log, i32, %class.rust_srv*, i8*, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_task_list, %class.rust_crate_cache, %struct.randctx, %struct.rust_task*, %struct.rust_task*, i32, %class.rust_kernel*, i32, %9, %10, %class.rust_message_queue*, %struct._opaque_pthread_attr_t }\n-%struct.rust_task = type { %struct.maybe_proxy, %struct.stk_seg*, i32, i32, %struct.gc_alloc*, %struct.rust_scheduler*, %class.rust_crate_cache*, %class.rust_kernel*, i8*, %class.rust_task_list*, %struct.rust_cond*, i8*, %struct.rust_task*, i32, i32, i32, %class.timer, i32*, %class.array_list, %class.rust_handle*, %class.context, i32, i32, %class.memory_region, %\"class.rust_task::wakeup_callback\"*, %class.lock_and_signal }\n-%struct.rust_vec = type { %struct.rc_base, i32, i32, i32, [0 x i8] }\n-%struct.stk_seg = type { i32, i32, [0 x i8] }\n-%struct.type_desc = type { %struct.type_desc**, i32, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*)*, i32, void (i8*, %struct.rust_task*, i8*, %struct.type_desc**, i8*, i8*, i8)*, %struct.UT_hash_handle, i32, [0 x %struct.type_desc*] }\n %union.rust_ivec_payload = type { %struct.rust_ivec_heap* }\n+%struct.rust_ivec_heap = type { i32, [0 x i8] }\n+%class.rust_port = type { i32, %class.rust_kernel*, %struct.rust_task*, i32, %class.ptr_vec, %class.ptr_vec.7, %class.rust_chan*, %class.lock_and_signal }\n+%class.ptr_vec = type { %struct.rust_task*, i32, i32, %struct.rust_token** }\n+%struct.rust_token = type opaque\n+%class.ptr_vec.7 = type { %struct.rust_task*, i32, i32, %class.rust_chan** }\n+%class.rust_chan = type { i32, %class.rust_kernel*, %struct.rust_task*, %class.rust_port*, i32, %class.circular_buffer }\n+%class.circular_buffer = type { %class.rust_kernel*, i32, i32, i32, i32, i8* }\n \n @.str = private unnamed_addr constant [42 x i8] c\"attempt to cast values of differing sizes\\00\", align 1\n @.str1 = private unnamed_addr constant [15 x i8] c\"intrinsics.cpp\\00\", align 1\n@@ -142,6 +133,16 @@ entry:\n   ret void\n }\n \n+define linkonce_odr void @rust_intrinsic_recv(%struct.rust_task* %task, i8** nocapture %retptr, %struct.type_desc* nocapture %ty, %class.rust_port* %port) {\n+entry:\n+  %tmp2 = load i8** %retptr, align 4, !tbaa !3\n+  %0 = bitcast i8* %tmp2 to i32*\n+  tail call void @port_recv(%struct.rust_task* %task, i32* %0, %class.rust_port* %port)\n+  ret void\n+}\n+\n+declare void @port_recv(%struct.rust_task*, i32*, %class.rust_port*)\n+\n !0 = metadata !{metadata !\"long\", metadata !1}\n !1 = metadata !{metadata !\"omnipotent char\", metadata !2}\n !2 = metadata !{metadata !\"Simple C/C++ TBAA\", null}"}, {"sha": "48cb575dfa84fb94c2178357aba8f2914347b221", "filename": "src/rt/rust_internal.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Frust_internal.h", "raw_url": "https://github.com/rust-lang/rust/raw/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Frust_internal.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_internal.h?ref=286be2d94e8904765e1ef0f5fcc2899f8501a654", "patch": "@@ -295,6 +295,9 @@ typedef ptr_vec<rust_alarm> rust_wait_queue;\n #include \"rust_port.h\"\n #include \"memory.h\"\n \n+extern \"C\" CDECL void\n+port_recv(rust_task *task, uintptr_t *dptr, rust_port *port);\n+\n #include \"test/rust_test_harness.h\"\n #include \"test/rust_test_util.h\"\n #include \"test/rust_test_runtime.h\""}, {"sha": "2554868c986e8e96e3538dbba7bc5d600d6b5544", "filename": "src/rt/rust_upcall.cpp", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Frust_upcall.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/286be2d94e8904765e1ef0f5fcc2899f8501a654/src%2Frt%2Frust_upcall.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_upcall.cpp?ref=286be2d94e8904765e1ef0f5fcc2899f8501a654", "patch": "@@ -193,8 +193,6 @@ upcall_send(rust_task *task, rust_chan *chan, void *sptr) {\n     LOG(task, comm, \"=== sent data ===>\");\n }\n \n-extern \"C\" CDECL void\n-port_recv(rust_task *task, uintptr_t *dptr, rust_port *port);\n extern \"C\" CDECL void\n upcall_recv(rust_task *task, uintptr_t *dptr, rust_port *port) {\n     LOG_UPCALL_ENTRY(task);"}]}