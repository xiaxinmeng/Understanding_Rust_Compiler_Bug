{"sha": "0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmYmY3ZWFmODE4NjgxMWZhZDE3YWQ2NmI5ZWE2OGNiZTQ5MDZkZjU=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-07T22:18:38Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-07T22:18:38Z"}, "message": "Rollup merge of #28896 - mkpankov:core-fmt, r=nrc\n\n\n\n<!-- Reviewable:start -->\n[<img src=\"https://reviewable.io/review_button.png\" height=40 alt=\"Review on Reviewable\"/>](https://reviewable.io/reviews/rust-lang/rust/28896)\n<!-- Reviewable:end -->", "tree": {"sha": "b666c753c218310c267a57a5e17467aea8e32a16", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b666c753c218310c267a57a5e17467aea8e32a16"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "html_url": "https://github.com/rust-lang/rust/commit/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fb09639d926ac32080770f8acffc738895692f3e", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb09639d926ac32080770f8acffc738895692f3e", "html_url": "https://github.com/rust-lang/rust/commit/fb09639d926ac32080770f8acffc738895692f3e"}, {"sha": "11a7773a3acfb3c48d56cecb6a5ab076f9d71dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/11a7773a3acfb3c48d56cecb6a5ab076f9d71dfe", "html_url": "https://github.com/rust-lang/rust/commit/11a7773a3acfb3c48d56cecb6a5ab076f9d71dfe"}], "stats": {"total": 128, "additions": 93, "deletions": 35}, "files": [{"sha": "0d4c0bb6480086c34a71e37ed13c45458cf26e1e", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 48, "deletions": 14, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "patch": "@@ -61,7 +61,8 @@ pub struct DebugStruct<'a, 'b: 'a> {\n     has_fields: bool,\n }\n \n-pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>, name: &str)\n+pub fn debug_struct_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>,\n+                                name: &str)\n                                 -> DebugStruct<'a, 'b> {\n     let result = fmt.write_str(name);\n     DebugStruct {\n@@ -84,7 +85,8 @@ impl<'a, 'b: 'a> DebugStruct<'a, 'b> {\n \n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                fmt::write(&mut writer, format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n+                fmt::write(&mut writer,\n+                           format_args!(\"{}\\n{}: {:#?}\", prefix, name, value))\n             } else {\n                 write!(self.fmt, \"{} {}: {:?}\", prefix, name, value)\n             }\n@@ -195,10 +197,18 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                let prefix = if self.has_fields { \",\" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \",\"\n+                } else {\n+                    \"\"\n+                };\n                 fmt::write(&mut writer, format_args!(\"{}\\n{:#?}\", prefix, entry))\n             } else {\n-                let prefix = if self.has_fields { \", \" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \", \"\n+                } else {\n+                    \"\"\n+                };\n                 write!(self.fmt, \"{}{:?}\", prefix, entry)\n             }\n         });\n@@ -207,7 +217,11 @@ impl<'a, 'b: 'a> DebugInner<'a, 'b> {\n     }\n \n     pub fn finish(&mut self) {\n-        let prefix = if self.is_pretty() && self.has_fields { \"\\n\" } else { \"\" };\n+        let prefix = if self.is_pretty() && self.has_fields {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n         self.result = self.result.and_then(|_| self.fmt.write_str(prefix));\n     }\n \n@@ -232,7 +246,7 @@ pub fn debug_set_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugSet<'a, 'b\n             fmt: fmt,\n             result: result,\n             has_fields: false,\n-        }\n+        },\n     }\n }\n \n@@ -247,7 +261,9 @@ impl<'a, 'b: 'a> DebugSet<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the set output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugSet<'a, 'b>\n-            where D: fmt::Debug, I: IntoIterator<Item=D> {\n+        where D: fmt::Debug,\n+              I: IntoIterator<Item = D>\n+    {\n         for entry in entries {\n             self.entry(&entry);\n         }\n@@ -278,7 +294,7 @@ pub fn debug_list_new<'a, 'b>(fmt: &'a mut fmt::Formatter<'b>) -> DebugList<'a,\n             fmt: fmt,\n             result: result,\n             has_fields: false,\n-        }\n+        },\n     }\n }\n \n@@ -293,7 +309,9 @@ impl<'a, 'b: 'a> DebugList<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the list output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<D, I>(&mut self, entries: I) -> &mut DebugList<'a, 'b>\n-            where D: fmt::Debug, I: IntoIterator<Item=D> {\n+        where D: fmt::Debug,\n+              I: IntoIterator<Item = D>\n+    {\n         for entry in entries {\n             self.entry(&entry);\n         }\n@@ -335,10 +353,19 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n         self.result = self.result.and_then(|_| {\n             if self.is_pretty() {\n                 let mut writer = PadAdapter::new(self.fmt);\n-                let prefix = if self.has_fields { \",\" } else { \"\" };\n-                fmt::write(&mut writer, format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n+                let prefix = if self.has_fields {\n+                    \",\"\n+                } else {\n+                    \"\"\n+                };\n+                fmt::write(&mut writer,\n+                           format_args!(\"{}\\n{:#?}: {:#?}\", prefix, key, value))\n             } else {\n-                let prefix = if self.has_fields { \", \" } else { \"\" };\n+                let prefix = if self.has_fields {\n+                    \", \"\n+                } else {\n+                    \"\"\n+                };\n                 write!(self.fmt, \"{}{:?}: {:?}\", prefix, key, value)\n             }\n         });\n@@ -350,7 +377,10 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// Adds the contents of an iterator of entries to the map output.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn entries<K, V, I>(&mut self, entries: I) -> &mut DebugMap<'a, 'b>\n-            where K: fmt::Debug, V: fmt::Debug, I: IntoIterator<Item=(K, V)> {\n+        where K: fmt::Debug,\n+              V: fmt::Debug,\n+              I: IntoIterator<Item = (K, V)>\n+    {\n         for (k, v) in entries {\n             self.entry(&k, &v);\n         }\n@@ -360,7 +390,11 @@ impl<'a, 'b: 'a> DebugMap<'a, 'b> {\n     /// Finishes output and returns any error encountered.\n     #[stable(feature = \"debug_builders\", since = \"1.2.0\")]\n     pub fn finish(&mut self) -> fmt::Result {\n-        let prefix = if self.is_pretty() && self.has_fields { \"\\n\" } else { \"\" };\n+        let prefix = if self.is_pretty() && self.has_fields {\n+            \"\\n\"\n+        } else {\n+            \"\"\n+        };\n         self.result.and_then(|_| write!(self.fmt, \"{}}}\", prefix))\n     }\n "}, {"sha": "23642790a88984ffe707820183d7dcb521d6ce06", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "patch": "@@ -48,7 +48,9 @@ trait GenericRadix {\n     fn base(&self) -> u8;\n \n     /// A radix-specific prefix string.\n-    fn prefix(&self) -> &'static str { \"\" }\n+    fn prefix(&self) -> &'static str {\n+        \"\"\n+    }\n \n     /// Converts an integer to corresponding radix digit.\n     fn digit(&self, x: u8) -> u8;\n@@ -70,7 +72,10 @@ trait GenericRadix {\n                 x = x / base;                  // Deaccumulate the number.\n                 *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };        // No more digits left to accumulate.\n+                if x == zero {\n+                    // No more digits left to accumulate.\n+                    break\n+                };\n             }\n         } else {\n             // Do the same as above, but accounting for two's complement.\n@@ -79,7 +84,10 @@ trait GenericRadix {\n                 x = x / base;                  // Deaccumulate the number.\n                 *byte = self.digit(n.to_u8()); // Store the digit in the buffer.\n                 curr -= 1;\n-                if x == zero { break };        // No more digits left to accumulate.\n+                if x == zero {\n+                    // No more digits left to accumulate.\n+                    break\n+                };\n             }\n         }\n         let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n@@ -141,13 +149,17 @@ pub struct Radix {\n \n impl Radix {\n     fn new(base: u8) -> Radix {\n-        assert!(2 <= base && base <= 36, \"the base must be in the range of 2..36: {}\", base);\n+        assert!(2 <= base && base <= 36,\n+                \"the base must be in the range of 2..36: {}\",\n+                base);\n         Radix { base: base }\n     }\n }\n \n impl GenericRadix for Radix {\n-    fn base(&self) -> u8 { self.base }\n+    fn base(&self) -> u8 {\n+        self.base\n+    }\n     fn digit(&self, x: u8) -> u8 {\n         match x {\n             x @  0 ... 9 => b'0' + x,"}, {"sha": "f889045a3f59568b14eeca4689a0bf21c11975d1", "filename": "src/libcore/fmt/rt/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Frt%2Fv1.rs?ref=0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "patch": "@@ -53,5 +53,5 @@ pub enum Count {\n #[derive(Copy, Clone)]\n pub enum Position {\n     Next,\n-    At(usize)\n+    At(usize),\n }"}, {"sha": "4e038f455e1bea1bc5b17d851fbfea1f7bfdaaa1", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 22, "deletions": 9, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "patch": "@@ -100,7 +100,9 @@ pub trait Hash {\n \n     /// Feeds a slice of this type into the state provided.\n     #[stable(feature = \"hash_slice\", since = \"1.3.0\")]\n-    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H) where Self: Sized {\n+    fn hash_slice<H: Hasher>(data: &[Self], state: &mut H)\n+        where Self: Sized\n+    {\n         for piece in data {\n             piece.hash(state);\n         }\n@@ -121,7 +123,9 @@ pub trait Hasher {\n     /// Write a single `u8` into this hasher\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_u8(&mut self, i: u8) { self.write(&[i]) }\n+    fn write_u8(&mut self, i: u8) {\n+        self.write(&[i])\n+    }\n     /// Write a single `u16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -145,32 +149,41 @@ pub trait Hasher {\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n     fn write_usize(&mut self, i: usize) {\n         let bytes = unsafe {\n-            ::slice::from_raw_parts(&i as *const usize as *const u8,\n-                                    mem::size_of::<usize>())\n+            ::slice::from_raw_parts(&i as *const usize as *const u8, mem::size_of::<usize>())\n         };\n         self.write(bytes);\n     }\n \n     /// Write a single `i8` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i8(&mut self, i: i8) { self.write_u8(i as u8) }\n+    fn write_i8(&mut self, i: i8) {\n+        self.write_u8(i as u8)\n+    }\n     /// Write a single `i16` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i16(&mut self, i: i16) { self.write_u16(i as u16) }\n+    fn write_i16(&mut self, i: i16) {\n+        self.write_u16(i as u16)\n+    }\n     /// Write a single `i32` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i32(&mut self, i: i32) { self.write_u32(i as u32) }\n+    fn write_i32(&mut self, i: i32) {\n+        self.write_u32(i as u32)\n+    }\n     /// Write a single `i64` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_i64(&mut self, i: i64) { self.write_u64(i as u64) }\n+    fn write_i64(&mut self, i: i64) {\n+        self.write_u64(i as u64)\n+    }\n     /// Write a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n-    fn write_isize(&mut self, i: isize) { self.write_usize(i as usize) }\n+    fn write_isize(&mut self, i: isize) {\n+        self.write_usize(i as usize)\n+    }\n }\n \n //////////////////////////////////////////////////////////////////////////////"}, {"sha": "722d77a8a11efeccdc26f0eecfdf8eb905a1f999", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0fbf7eaf8186811fad17ad66b9ea68cbe4906df5/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=0fbf7eaf8186811fad17ad66b9ea68cbe4906df5", "patch": "@@ -37,12 +37,12 @@ pub struct SipHasher {\n     // and simd implementations of SipHash will use vectors\n     // of v02 and v13. By placing them in this order in the struct,\n     // the compiler can pick up on just a few simd optimizations by itself.\n-    v0: u64,      // hash state\n+    v0: u64, // hash state\n     v2: u64,\n     v1: u64,\n     v3: u64,\n     tail: u64, // unprocessed bytes le\n-    ntail: usize,  // how many bytes in tail are valid\n+    ntail: usize, // how many bytes in tail are valid\n }\n \n // sadly, these macro definitions can't appear later,\n@@ -80,8 +80,7 @@ macro_rules! u8to64_le {\n unsafe fn load_u64_le(buf: &[u8], i: usize) -> u64 {\n     debug_assert!(i + 8 <= buf.len());\n     let mut data = 0u64;\n-    ptr::copy_nonoverlapping(buf.get_unchecked(i),\n-                             &mut data as *mut _ as *mut u8, 8);\n+    ptr::copy_nonoverlapping(buf.get_unchecked(i), &mut data as *mut _ as *mut u8, 8);\n     data.to_le()\n }\n \n@@ -152,12 +151,12 @@ impl Hasher for SipHasher {\n         if self.ntail != 0 {\n             needed = 8 - self.ntail;\n             if length < needed {\n-                self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;\n+                self.tail |= u8to64_le!(msg, 0, length) << 8 * self.ntail;\n                 self.ntail += length;\n                 return\n             }\n \n-            let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;\n+            let m = self.tail | u8to64_le!(msg, 0, needed) << 8 * self.ntail;\n \n             self.v3 ^= m;\n             compress!(self.v0, self.v1, self.v2, self.v3);"}]}