{"sha": "fc7efab3ab48e119e1a59281c26e666634ad1224", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZjN2VmYWIzYWI0OGUxMTllMWE1OTI4MWMyNmU2NjY2MzRhZDEyMjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-16T02:25:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-16T02:25:36Z"}, "message": "Auto merge of #27851 - nikomatsakis:cleanup-ty-decoder, r=eddyb\n\nJust a little code cleanup I was doing as part of another refactoring (which may turn out not to be needed). The main thrust of this is to cleanup the interface to `tydecode.rs` to be less ridiculously repetitive. I also purged the generic \"def-id conversion\" parameter in favor of a trait object, just to reduce code duplication a bit and make the signatures a bit less messy. I measured the bootstrapping time to build stage2 with these changes, it was identical. (But it'd be easy enough to restore the unboxed closure if we wanted it.)", "tree": {"sha": "6c179c8be107f4c9dbaa761367ce6f045003d512", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6c179c8be107f4c9dbaa761367ce6f045003d512"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fc7efab3ab48e119e1a59281c26e666634ad1224", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fc7efab3ab48e119e1a59281c26e666634ad1224", "html_url": "https://github.com/rust-lang/rust/commit/fc7efab3ab48e119e1a59281c26e666634ad1224", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fc7efab3ab48e119e1a59281c26e666634ad1224/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f05b22efb5e739b92b47527d29c5fa903f7e64b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/f05b22efb5e739b92b47527d29c5fa903f7e64b6", "html_url": "https://github.com/rust-lang/rust/commit/f05b22efb5e739b92b47527d29c5fa903f7e64b6"}, {"sha": "7a3a1be5e462775ff5556db79c35ea5979aac8f8", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a3a1be5e462775ff5556db79c35ea5979aac8f8", "html_url": "https://github.com/rust-lang/rust/commit/7a3a1be5e462775ff5556db79c35ea5979aac8f8"}], "stats": {"total": 1797, "additions": 786, "deletions": 1011}, "files": [{"sha": "b38c15d0f6a1e47aaf5c9694addeb1415fe3bba5", "filename": "src/librustc/ast_map/mod.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fast_map%2Fmod.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -12,6 +12,8 @@ pub use self::Node::*;\n pub use self::PathElem::*;\n use self::MapEntry::*;\n \n+use metadata::inline::InlinedItem;\n+use metadata::inline::InlinedItem as II;\n use syntax::abi;\n use syntax::ast::*;\n use syntax::ast_util;\n@@ -374,8 +376,8 @@ impl<'ast> Map<'ast> {\n     pub fn get_parent_did(&self, id: NodeId) -> DefId {\n         let parent = self.get_parent(id);\n         match self.find_entry(parent) {\n-            Some(RootInlinedParent(&InlinedParent {ii: IITraitItem(did, _), ..})) => did,\n-            Some(RootInlinedParent(&InlinedParent {ii: IIImplItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: II::TraitItem(did, _), ..})) => did,\n+            Some(RootInlinedParent(&InlinedParent {ii: II::ImplItem(did, _), ..})) => did,\n             _ => ast_util::local_def(parent)\n         }\n     }\n@@ -967,16 +969,16 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n                                           -> &'ast InlinedItem {\n     let mut fld = IdAndSpanUpdater { fold_ops: fold_ops };\n     let ii = match ii {\n-        IIItem(i) => IIItem(fld.fold_item(i).expect_one(\"expected one item\")),\n-        IITraitItem(d, ti) => {\n-            IITraitItem(fld.fold_ops.new_def_id(d),\n-                        fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n+        II::Item(i) => II::Item(fld.fold_item(i).expect_one(\"expected one item\")),\n+        II::TraitItem(d, ti) => {\n+            II::TraitItem(fld.fold_ops.new_def_id(d),\n+                          fld.fold_trait_item(ti).expect_one(\"expected one trait item\"))\n         }\n-        IIImplItem(d, ii) => {\n-            IIImplItem(fld.fold_ops.new_def_id(d),\n-                       fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n+        II::ImplItem(d, ii) => {\n+            II::ImplItem(fld.fold_ops.new_def_id(d),\n+                         fld.fold_impl_item(ii).expect_one(\"expected one impl item\"))\n         }\n-        IIForeign(i) => IIForeign(fld.fold_foreign_item(i))\n+        II::Foreign(i) => II::Foreign(fld.fold_foreign_item(i))\n     };\n \n     let ii_parent = map.forest.inlined_items.alloc(InlinedParent {\n@@ -990,20 +992,20 @@ pub fn map_decoded_item<'ast, F: FoldOps>(map: &Map<'ast>,\n         parent_node: ii_parent_id,\n     };\n     collector.insert_entry(ii_parent_id, RootInlinedParent(ii_parent));\n-    visit::walk_inlined_item(&mut collector, &ii_parent.ii);\n+    ii_parent.ii.visit(&mut collector);\n \n     // Methods get added to the AST map when their impl is visited.  Since we\n     // don't decode and instantiate the impl, but just the method, we have to\n     // add it to the table now. Likewise with foreign items.\n     match ii_parent.ii {\n-        IIItem(_) => {}\n-        IITraitItem(_, ref ti) => {\n+        II::Item(_) => {}\n+        II::TraitItem(_, ref ti) => {\n             collector.insert(ti.id, NodeTraitItem(ti));\n         }\n-        IIImplItem(_, ref ii) => {\n+        II::ImplItem(_, ref ii) => {\n             collector.insert(ii.id, NodeImplItem(ii));\n         }\n-        IIForeign(ref i) => {\n+        II::Foreign(ref i) => {\n             collector.insert(i.id, NodeForeignItem(i));\n         }\n     }"}, {"sha": "d33b163c9725abb91cb993ea41ee7dc325f16779", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -14,6 +14,7 @@ use ast_map;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n+use metadata::inline::InlinedItem;\n use middle::lang_items;\n use middle::ty;\n \n@@ -96,8 +97,8 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n }\n \n pub enum FoundAst<'ast> {\n-    Found(&'ast ast::InlinedItem),\n-    FoundParent(ast::DefId, &'ast ast::InlinedItem),\n+    Found(&'ast InlinedItem),\n+    FoundParent(ast::DefId, &'ast InlinedItem),\n     NotFound,\n }\n "}, {"sha": "0554d35a92097a94bedd96c00f955072a902e5bc", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -23,9 +23,8 @@ use metadata::csearch::MethodInfo;\n use metadata::csearch;\n use metadata::cstore;\n use metadata::encoder::def_to_u64;\n-use metadata::tydecode::{parse_ty_data, parse_region_data,\n-                         parse_type_param_def_data, parse_bare_fn_ty_data,\n-                         parse_trait_ref_data, parse_predicate_data};\n+use metadata::inline::InlinedItem;\n+use metadata::tydecode::TyDecoder;\n use middle::def;\n use middle::lang_items;\n use middle::subst;\n@@ -234,22 +233,25 @@ fn variant_disr_val(d: rbml::Doc) -> Option<ty::Disr> {\n \n fn doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Ty<'tcx> {\n     let tp = reader::get_doc(doc, tag_items_data_item_type);\n-    parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n-                  |_, did| translate_def_id(cdata, did))\n+    TyDecoder::with_doc(tcx, cdata.cnum, tp,\n+                        &mut |_, did| translate_def_id(cdata, did))\n+        .parse_ty()\n }\n \n fn maybe_doc_type<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd) -> Option<Ty<'tcx>> {\n     reader::maybe_get_doc(doc, tag_items_data_item_type).map(|tp| {\n-        parse_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n-                      |_, did| translate_def_id(cdata, did))\n+        TyDecoder::with_doc(tcx, cdata.cnum, tp,\n+                            &mut |_, did| translate_def_id(cdata, did))\n+            .parse_ty()\n     })\n }\n \n fn doc_method_fty<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>,\n                         cdata: Cmd) -> ty::BareFnTy<'tcx> {\n     let tp = reader::get_doc(doc, tag_item_method_fty);\n-    parse_bare_fn_ty_data(tp.data, cdata.cnum, tp.start, tcx,\n-                          |_, did| translate_def_id(cdata, did))\n+    TyDecoder::with_doc(tcx, cdata.cnum, tp,\n+                        &mut |_, did| translate_def_id(cdata, did))\n+        .parse_bare_fn_ty()\n }\n \n pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n@@ -259,8 +261,9 @@ pub fn item_type<'tcx>(_item_id: ast::DefId, item: rbml::Doc,\n \n fn doc_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n                        -> ty::TraitRef<'tcx> {\n-    parse_trait_ref_data(doc.data, cdata.cnum, doc.start, tcx,\n-                         |_, did| translate_def_id(cdata, did))\n+    TyDecoder::with_doc(tcx, cdata.cnum, doc,\n+                        &mut |_, did| translate_def_id(cdata, did))\n+        .parse_trait_ref()\n }\n \n fn item_trait_ref<'tcx>(doc: rbml::Doc, tcx: &ty::ctxt<'tcx>, cdata: Cmd)\n@@ -776,7 +779,7 @@ pub type DecodeInlinedItem<'a> =\n                         &ty::ctxt<'tcx>,\n                         Vec<ast_map::PathElem>,\n                         rbml::Doc)\n-                        -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> + 'a>;\n+                        -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> + 'a>;\n \n pub fn maybe_get_item_ast<'tcx>(cdata: Cmd, tcx: &ty::ctxt<'tcx>, id: ast::NodeId,\n                                 mut decode_inlined_item: DecodeInlinedItem)\n@@ -1468,9 +1471,10 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n \n     let mut types = subst::VecPerParamSpace::empty();\n     for p in reader::tagged_docs(doc, tag_type_param_def) {\n-        let bd = parse_type_param_def_data(\n-            p.data, p.start, cdata.cnum, tcx,\n-            |_, did| translate_def_id(cdata, did));\n+        let bd =\n+            TyDecoder::with_doc(tcx, cdata.cnum, p,\n+                                &mut |_, did| translate_def_id(cdata, did))\n+            .parse_type_param_def();\n         types.push(bd.space, bd);\n     }\n \n@@ -1490,8 +1494,9 @@ fn doc_generics<'tcx>(base_doc: rbml::Doc,\n         let index = reader::doc_as_u64(doc) as u32;\n \n         let bounds = reader::tagged_docs(rp_doc, tag_items_data_region).map(|p| {\n-            parse_region_data(p.data, cdata.cnum, p.start, tcx,\n-                              |_, did| translate_def_id(cdata, did))\n+            TyDecoder::with_doc(tcx, cdata.cnum, p,\n+                                &mut |_, did| translate_def_id(cdata, did))\n+            .parse_region()\n         }).collect();\n \n         regions.push(space, ty::RegionParameterDef { name: name,\n@@ -1518,8 +1523,10 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n         let space = subst::ParamSpace::from_uint(reader::doc_as_u8(space_doc) as usize);\n \n         let data_doc = reader::get_doc(predicate_doc, tag_predicate_data);\n-        let data = parse_predicate_data(data_doc.data, data_doc.start, cdata.cnum, tcx,\n-                                        |_, did| translate_def_id(cdata, did));\n+        let data =\n+            TyDecoder::with_doc(tcx, cdata.cnum, data_doc,\n+                                &mut |_, did| translate_def_id(cdata, did))\n+            .parse_predicate();\n \n         predicates.push(space, data);\n     }"}, {"sha": "91638f0de7e3f28a743d4c5ad3c95df3ed8080c4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 11, "deletions": 19, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -13,15 +13,14 @@\n #![allow(unused_must_use)] // everything is just a MemWriter, can't fail\n #![allow(non_camel_case_types)]\n \n-pub use self::InlinedItemRef::*;\n-\n use ast_map::{self, LinkedPath, PathElem, PathElems};\n use back::svh::Svh;\n use session::config;\n use metadata::common::*;\n use metadata::cstore;\n use metadata::decoder;\n use metadata::tyencode;\n+use metadata::inline::InlinedItemRef;\n use middle::def;\n use middle::dependency_format::Linkage;\n use middle::stability;\n@@ -48,14 +47,6 @@ use syntax::visit;\n use syntax;\n use rbml::writer::Encoder;\n \n-/// A borrowed version of `ast::InlinedItem`.\n-pub enum InlinedItemRef<'a> {\n-    IIItemRef(&'a ast::Item),\n-    IITraitItemRef(DefId, &'a ast::TraitItem),\n-    IIImplItemRef(DefId, &'a ast::ImplItem),\n-    IIForeignRef(&'a ast::ForeignItem)\n-}\n-\n pub type EncodeInlinedItem<'a> =\n     Box<FnMut(&EncodeContext, &mut Encoder, InlinedItemRef) + 'a>;\n \n@@ -832,7 +823,7 @@ fn encode_info_for_associated_const(ecx: &EncodeContext,\n \n     if let Some(ii) = impl_item_opt {\n         encode_attributes(rbml_w, &ii.attrs);\n-        encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id), ii));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id), ii));\n     }\n \n     rbml_w.end_tag();\n@@ -870,7 +861,7 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             let needs_inline = any_types || is_default_impl ||\n                                attr::requests_inline(&impl_item.attrs);\n             if needs_inline || sig.constness == ast::Constness::Const {\n-                encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n+                encode_inlined_item(ecx, rbml_w, InlinedItemRef::ImplItem(local_def(parent_id),\n                                                                impl_item));\n             }\n             encode_constness(rbml_w, sig.constness);\n@@ -1052,7 +1043,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n@@ -1069,7 +1060,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_attributes(rbml_w, &item.attrs);\n         let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n         if needs_inline || constness == ast::Constness::Const {\n-            encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n@@ -1134,7 +1125,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         for v in &enum_definition.variants {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n         encode_path(rbml_w, path);\n \n         // Encode inherent implementations for this enumeration.\n@@ -1182,7 +1173,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         needs to know*/\n         encode_struct_fields(rbml_w, variant, def_id);\n \n-        encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n+        encode_inlined_item(ecx, rbml_w, InlinedItemRef::Item(item));\n \n         // Encode inherent implementations for this structure.\n         encode_inherent_implementations(ecx, rbml_w, def_id);\n@@ -1457,7 +1448,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             match trait_item.node {\n                 ast::ConstTraitItem(_, _) => {\n                     encode_inlined_item(ecx, rbml_w,\n-                                        IITraitItemRef(def_id, trait_item));\n+                                        InlinedItemRef::TraitItem(def_id, trait_item));\n                 }\n                 ast::MethodTraitItem(ref sig, ref body) => {\n                     // If this is a static method, we've already\n@@ -1471,7 +1462,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                     if body.is_some() {\n                         encode_item_sort(rbml_w, 'p');\n-                        encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n+                        encode_inlined_item(ecx, rbml_w,\n+                                            InlinedItemRef::TraitItem(def_id, trait_item));\n                     } else {\n                         encode_item_sort(rbml_w, 'r');\n                     }\n@@ -1510,7 +1502,7 @@ fn encode_info_for_foreign_item(ecx: &EncodeContext,\n         encode_bounds_and_type_for_item(rbml_w, ecx, nitem.id);\n         encode_name(rbml_w, nitem.ident.name);\n         if abi == abi::RustIntrinsic {\n-            encode_inlined_item(ecx, rbml_w, IIForeignRef(nitem));\n+            encode_inlined_item(ecx, rbml_w, InlinedItemRef::Foreign(nitem));\n         }\n         encode_attributes(rbml_w, &*nitem.attrs);\n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(nitem.id));"}, {"sha": "ba09e173fd80d5cf29bc73b8afff0fb4d8cdbdcf", "filename": "src/librustc/metadata/inline.rs", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Finline.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -0,0 +1,64 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::ast;\n+use syntax::ast_util::{IdRange, IdRangeComputingVisitor,\n+                       IdVisitor, IdVisitingOperation};\n+use syntax::ptr::P;\n+use syntax::visit::Visitor;\n+use self::InlinedItem::*;\n+\n+/// The data we save and restore about an inlined item or method.  This is not\n+/// part of the AST that we parse from a file, but it becomes part of the tree\n+/// that we trans.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum InlinedItem {\n+    Item(P<ast::Item>),\n+    TraitItem(ast::DefId /* impl id */, P<ast::TraitItem>),\n+    ImplItem(ast::DefId /* impl id */, P<ast::ImplItem>),\n+    Foreign(P<ast::ForeignItem>),\n+}\n+\n+/// A borrowed version of `ast::InlinedItem`.\n+pub enum InlinedItemRef<'a> {\n+    Item(&'a ast::Item),\n+    TraitItem(ast::DefId, &'a ast::TraitItem),\n+    ImplItem(ast::DefId, &'a ast::ImplItem),\n+    Foreign(&'a ast::ForeignItem)\n+}\n+\n+impl InlinedItem {\n+    pub fn visit<'ast,V>(&'ast self, visitor: &mut V)\n+        where V: Visitor<'ast>\n+    {\n+        match *self {\n+            Item(ref i) => visitor.visit_item(&**i),\n+            Foreign(ref i) => visitor.visit_foreign_item(&**i),\n+            TraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n+            ImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n+        }\n+    }\n+\n+    pub fn visit_ids<O: IdVisitingOperation>(&self, operation: &mut O) {\n+        let mut id_visitor = IdVisitor {\n+            operation: operation,\n+            pass_through_items: true,\n+            visited_outermost: false,\n+        };\n+        self.visit(&mut id_visitor);\n+    }\n+\n+    pub fn compute_id_range(&self) -> IdRange {\n+        let mut visitor = IdRangeComputingVisitor::new();\n+        self.visit_ids(&mut visitor);\n+        visitor.result()\n+    }\n+}\n+"}, {"sha": "44901eb05479138eb74aba347f76d0d09476abc9", "filename": "src/librustc/metadata/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fmod.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -19,3 +19,4 @@ pub mod csearch;\n pub mod loader;\n pub mod filesearch;\n pub mod macro_import;\n+pub mod inline;"}, {"sha": "9219442cf6282cd9de5ff565539517f269e6f577", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 564, "deletions": 788, "changes": 1352, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -23,6 +23,7 @@ use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, ToPredicate, Ty, HasTypeFlags};\n \n+use rbml;\n use std::str;\n use syntax::abi;\n use syntax::ast;\n@@ -57,677 +58,629 @@ pub enum DefIdSource {\n     ClosureSource\n }\n \n-// type conv_did = impl FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n+pub type DefIdConvert<'a> = &'a mut FnMut(DefIdSource, ast::DefId) -> ast::DefId;\n \n-pub struct PState<'a, 'tcx: 'a> {\n+pub struct TyDecoder<'a, 'tcx: 'a> {\n     data: &'a [u8],\n     krate: ast::CrateNum,\n     pos: usize,\n-    tcx: &'a ty::ctxt<'tcx>\n+    tcx: &'a ty::ctxt<'tcx>,\n+    conv_def_id: DefIdConvert<'a>,\n }\n \n-fn peek(st: &PState) -> char {\n-    st.data[st.pos] as char\n-}\n-\n-fn next(st: &mut PState) -> char {\n-    let ch = st.data[st.pos] as char;\n-    st.pos = st.pos + 1;\n-    return ch;\n-}\n-\n-fn next_byte(st: &mut PState) -> u8 {\n-    let b = st.data[st.pos];\n-    st.pos = st.pos + 1;\n-    return b;\n-}\n+impl<'a,'tcx> TyDecoder<'a,'tcx> {\n+    pub fn with_doc(tcx: &'a ty::ctxt<'tcx>,\n+                    crate_num: ast::CrateNum,\n+                    doc: rbml::Doc<'a>,\n+                    conv: DefIdConvert<'a>)\n+                    -> TyDecoder<'a,'tcx> {\n+        TyDecoder::new(doc.data, crate_num, doc.start, tcx, conv)\n+    }\n \n-fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n-    F: FnMut(char) -> bool,\n-    G: FnOnce(&[u8]) -> R,\n-{\n-    let start_pos = st.pos;\n-    debug!(\"scan: '{}' (start)\", st.data[st.pos] as char);\n-    while !is_last(st.data[st.pos] as char) {\n-        st.pos += 1;\n-        debug!(\"scan: '{}'\", st.data[st.pos] as char);\n-    }\n-    let end_pos = st.pos;\n-    st.pos += 1;\n-    return op(&st.data[start_pos..end_pos]);\n-}\n+    pub fn new(data: &'a [u8],\n+               crate_num: ast::CrateNum,\n+               pos: usize,\n+               tcx: &'a ty::ctxt<'tcx>,\n+               conv: DefIdConvert<'a>)\n+               -> TyDecoder<'a, 'tcx> {\n+        TyDecoder {\n+            data: data,\n+            krate: crate_num,\n+            pos: pos,\n+            tcx: tcx,\n+            conv_def_id: conv,\n+        }\n+    }\n \n-pub fn parse_name(st: &mut PState, last: char) -> ast::Name {\n-    fn is_last(b: char, c: char) -> bool { return c == b; }\n-    parse_name_(st, |a| is_last(last, a) )\n-}\n+    fn peek(&self) -> char {\n+        self.data[self.pos] as char\n+    }\n \n-fn parse_name_<F>(st: &mut PState, is_last: F) -> ast::Name where\n-    F: FnMut(char) -> bool,\n-{\n-    scan(st, is_last, |bytes| {\n-        token::intern(str::from_utf8(bytes).unwrap())\n-    })\n-}\n+    fn next(&mut self) -> char {\n+        let ch = self.data[self.pos] as char;\n+        self.pos = self.pos + 1;\n+        return ch;\n+    }\n \n-pub fn parse_state_from_data<'a, 'tcx>(data: &'a [u8], crate_num: ast::CrateNum,\n-                                       pos: usize, tcx: &'a ty::ctxt<'tcx>)\n-                                       -> PState<'a, 'tcx> {\n-    PState {\n-        data: data,\n-        krate: crate_num,\n-        pos: pos,\n-        tcx: tcx\n+    fn next_byte(&mut self) -> u8 {\n+        let b = self.data[self.pos];\n+        self.pos = self.pos + 1;\n+        return b;\n     }\n-}\n \n-fn data_log_string(data: &[u8], pos: usize) -> String {\n-    let mut buf = String::new();\n-    buf.push_str(\"<<\");\n-    for i in pos..data.len() {\n-        let c = data[i];\n-        if c > 0x20 && c <= 0x7F {\n-            buf.push(c as char);\n-        } else {\n-            buf.push('.');\n+    fn scan<F>(&mut self, mut is_last: F) -> &'a [u8]\n+        where F: FnMut(char) -> bool,\n+    {\n+        let start_pos = self.pos;\n+        debug!(\"scan: '{}' (start)\", self.data[self.pos] as char);\n+        while !is_last(self.data[self.pos] as char) {\n+            self.pos += 1;\n+            debug!(\"scan: '{}'\", self.data[self.pos] as char);\n         }\n+        let end_pos = self.pos;\n+        self.pos += 1;\n+        return &self.data[start_pos..end_pos];\n     }\n-    buf.push_str(\">>\");\n-    buf\n-}\n \n-pub fn parse_ty_closure_data<'tcx, F>(data: &[u8],\n-                                      crate_num: ast::CrateNum,\n-                                      pos: usize,\n-                                      tcx: &ty::ctxt<'tcx>,\n-                                      conv: F)\n-                                      -> ty::ClosureTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_closure_ty(&mut st, conv)\n-}\n+    fn parse_name(&mut self, last: char) -> ast::Name {\n+        fn is_last(b: char, c: char) -> bool { return c == b; }\n+        let bytes = self.scan(|a| is_last(last, a));\n+        token::intern(str::from_utf8(bytes).unwrap())\n+    }\n \n-pub fn parse_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                              tcx: &ty::ctxt<'tcx>, conv: F) -> Ty<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    debug!(\"parse_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_ty(&mut st, conv)\n-}\n+    fn parse_size(&mut self) -> Option<usize> {\n+        assert_eq!(self.next(), '/');\n \n-pub fn parse_region_data<F>(data: &[u8], crate_num: ast::CrateNum, pos: usize, tcx: &ty::ctxt,\n-                            conv: F) -> ty::Region where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    debug!(\"parse_region_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_region(&mut st, conv)\n-}\n+        if self.peek() == '|' {\n+            assert_eq!(self.next(), '|');\n+            None\n+        } else {\n+            let n = self.parse_uint();\n+            assert_eq!(self.next(), '|');\n+            Some(n)\n+        }\n+    }\n \n-pub fn parse_bare_fn_ty_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                      tcx: &ty::ctxt<'tcx>, conv: F)\n-                                      -> ty::BareFnTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    debug!(\"parse_bare_fn_ty_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_bare_fn_ty(&mut st, conv)\n-}\n+    fn parse_vec_per_param_space<T, F>(&mut self, mut f: F) -> VecPerParamSpace<T> where\n+        F: FnMut(&mut TyDecoder<'a, 'tcx>) -> T,\n+    {\n+        let mut r = VecPerParamSpace::empty();\n+        for &space in &subst::ParamSpace::all() {\n+            assert_eq!(self.next(), '[');\n+            while self.peek() != ']' {\n+                r.push(space, f(self));\n+            }\n+            assert_eq!(self.next(), ']');\n+        }\n+        r\n+    }\n \n-pub fn parse_trait_ref_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                     tcx: &ty::ctxt<'tcx>, conv: F)\n-                                     -> ty::TraitRef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    debug!(\"parse_trait_ref_data {}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_trait_ref(&mut st, conv)\n-}\n+    pub fn parse_substs(&mut self) -> subst::Substs<'tcx> {\n+        let regions = self.parse_region_substs();\n+        let types = self.parse_vec_per_param_space(|this| this.parse_ty());\n+        subst::Substs { types: types, regions: regions }\n+    }\n \n-pub fn parse_substs_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum, pos: usize,\n-                                  tcx: &ty::ctxt<'tcx>, conv: F) -> subst::Substs<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    debug!(\"parse_substs_data{}\", data_log_string(data, pos));\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_substs(&mut st, conv)\n-}\n+    fn parse_region_substs(&mut self) -> subst::RegionSubsts {\n+        match self.next() {\n+            'e' => subst::ErasedRegions,\n+            'n' => {\n+                subst::NonerasedRegions(\n+                    self.parse_vec_per_param_space(|this| this.parse_region()))\n+            }\n+            _ => panic!(\"parse_bound_region: bad input\")\n+        }\n+    }\n \n-pub fn parse_existential_bounds_data<'tcx, F>(data: &[u8], crate_num: ast::CrateNum,\n-                                              pos: usize, tcx: &ty::ctxt<'tcx>, conv: F)\n-                                              -> ty::ExistentialBounds<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_existential_bounds(&mut st, conv)\n-}\n+    fn parse_bound_region(&mut self) -> ty::BoundRegion {\n+        match self.next() {\n+            'a' => {\n+                let id = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                ty::BrAnon(id)\n+            }\n+            '[' => {\n+                let def = self.parse_def(RegionParameter);\n+                let ident = token::str_to_ident(&self.parse_str(']'));\n+                ty::BrNamed(def, ident.name)\n+            }\n+            'f' => {\n+                let id = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                ty::BrFresh(id)\n+            }\n+            'e' => ty::BrEnv,\n+            _ => panic!(\"parse_bound_region: bad input\")\n+        }\n+    }\n \n-pub fn parse_builtin_bounds_data<F>(data: &[u8], crate_num: ast::CrateNum,\n-                                    pos: usize, tcx: &ty::ctxt, conv: F)\n-                                    -> ty::BuiltinBounds where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, pos, tcx);\n-    parse_builtin_bounds(&mut st, conv)\n-}\n+    pub fn parse_region(&mut self) -> ty::Region {\n+        match self.next() {\n+            'b' => {\n+                assert_eq!(self.next(), '[');\n+                let id = ty::DebruijnIndex::new(self.parse_u32());\n+                assert_eq!(self.next(), '|');\n+                let br = self.parse_bound_region();\n+                assert_eq!(self.next(), ']');\n+                ty::ReLateBound(id, br)\n+            }\n+            'B' => {\n+                assert_eq!(self.next(), '[');\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let space = self.parse_param_space();\n+                assert_eq!(self.next(), '|');\n+                let index = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                let nm = token::str_to_ident(&self.parse_str(']'));\n+                ty::ReEarlyBound(ty::EarlyBoundRegion {\n+                    param_id: node_id,\n+                    space: space,\n+                    index: index,\n+                    name: nm.name\n+                })\n+            }\n+            'f' => {\n+                assert_eq!(self.next(), '[');\n+                let scope = self.parse_destruction_scope_data();\n+                assert_eq!(self.next(), '|');\n+                let br = self.parse_bound_region();\n+                assert_eq!(self.next(), ']');\n+                ty::ReFree(ty::FreeRegion { scope: scope,\n+                                            bound_region: br})\n+            }\n+            's' => {\n+                let scope = self.parse_scope();\n+                assert_eq!(self.next(), '|');\n+                ty::ReScope(scope)\n+            }\n+            't' => {\n+                ty::ReStatic\n+            }\n+            'e' => {\n+                ty::ReStatic\n+            }\n+            _ => panic!(\"parse_region: bad input\")\n+        }\n+    }\n \n-fn parse_size(st: &mut PState) -> Option<usize> {\n-    assert_eq!(next(st), '/');\n+    fn parse_scope(&mut self) -> region::CodeExtent {\n+        match self.next() {\n+            'P' => {\n+                assert_eq!(self.next(), '[');\n+                let fn_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let body_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), ']');\n+                region::CodeExtent::ParameterScope {\n+                    fn_id: fn_id, body_id: body_id\n+                }\n+            }\n+            'M' => {\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                region::CodeExtent::Misc(node_id)\n+            }\n+            'D' => {\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                region::CodeExtent::DestructionScope(node_id)\n+            }\n+            'B' => {\n+                assert_eq!(self.next(), '[');\n+                let node_id = self.parse_uint() as ast::NodeId;\n+                assert_eq!(self.next(), '|');\n+                let first_stmt_index = self.parse_uint();\n+                assert_eq!(self.next(), ']');\n+                let block_remainder = region::BlockRemainder {\n+                    block: node_id, first_statement_index: first_stmt_index,\n+                };\n+                region::CodeExtent::Remainder(block_remainder)\n+            }\n+            _ => panic!(\"parse_scope: bad input\")\n+        }\n+    }\n \n-    if peek(st) == '|' {\n-        assert_eq!(next(st), '|');\n-        None\n-    } else {\n-        let n = parse_uint(st);\n-        assert_eq!(next(st), '|');\n-        Some(n)\n+    fn parse_destruction_scope_data(&mut self) -> region::DestructionScopeData {\n+        let node_id = self.parse_uint() as ast::NodeId;\n+        region::DestructionScopeData::new(node_id)\n     }\n-}\n \n-fn parse_vec_per_param_space<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>,\n-                                             mut f: F)\n-                                             -> VecPerParamSpace<T> where\n-    F: FnMut(&mut PState<'a, 'tcx>) -> T,\n-{\n-    let mut r = VecPerParamSpace::empty();\n-    for &space in &subst::ParamSpace::all() {\n-        assert_eq!(next(st), '[');\n-        while peek(st) != ']' {\n-            r.push(space, f(st));\n+    fn parse_opt<T, F>(&mut self, f: F) -> Option<T>\n+        where F: FnOnce(&mut TyDecoder<'a, 'tcx>) -> T,\n+    {\n+        match self.next() {\n+            'n' => None,\n+            's' => Some(f(self)),\n+            _ => panic!(\"parse_opt: bad input\")\n         }\n-        assert_eq!(next(st), ']');\n     }\n-    r\n-}\n-\n-fn parse_substs<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                             mut conv: F) -> subst::Substs<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_substs_(st, &mut conv)\n-}\n \n-fn parse_substs_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                              conv: &mut F) -> subst::Substs<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let regions =\n-        parse_region_substs_(st, conv);\n+    fn parse_str(&mut self, term: char) -> String {\n+        let mut result = String::new();\n+        while self.peek() != term {\n+            unsafe {\n+                result.as_mut_vec().push_all(&[self.next_byte()])\n+            }\n+        }\n+        self.next();\n+        result\n+    }\n \n-    let types =\n-        parse_vec_per_param_space(st, |st| parse_ty_(st, conv));\n+    pub fn parse_trait_ref(&mut self) -> ty::TraitRef<'tcx> {\n+        let def = self.parse_def(NominalType);\n+        let substs = self.tcx.mk_substs(self.parse_substs());\n+        ty::TraitRef {def_id: def, substs: substs}\n+    }\n \n-    subst::Substs { types: types,\n-                    regions: regions }\n-}\n+    pub fn parse_ty(&mut self) -> Ty<'tcx> {\n+        let tcx = self.tcx;\n+        match self.next() {\n+            'b' => return tcx.types.bool,\n+            'i' => { /* eat the s of is */ self.next(); return tcx.types.isize },\n+            'u' => { /* eat the s of us */ self.next(); return tcx.types.usize },\n+            'M' => {\n+                match self.next() {\n+                    'b' => return tcx.types.u8,\n+                    'w' => return tcx.types.u16,\n+                    'l' => return tcx.types.u32,\n+                    'd' => return tcx.types.u64,\n+                    'B' => return tcx.types.i8,\n+                    'W' => return tcx.types.i16,\n+                    'L' => return tcx.types.i32,\n+                    'D' => return tcx.types.i64,\n+                    'f' => return tcx.types.f32,\n+                    'F' => return tcx.types.f64,\n+                    _ => panic!(\"parse_ty: bad numeric type\")\n+                }\n+            }\n+            'c' => return tcx.types.char,\n+            't' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(NominalType);\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                let def = self.tcx.lookup_adt_def(did);\n+                return tcx.mk_enum(def, self.tcx.mk_substs(substs));\n+            }\n+            'x' => {\n+                assert_eq!(self.next(), '[');\n+                let trait_ref = ty::Binder(self.parse_trait_ref());\n+                let bounds = self.parse_existential_bounds();\n+                assert_eq!(self.next(), ']');\n+                return tcx.mk_trait(trait_ref, bounds);\n+            }\n+            'p' => {\n+                assert_eq!(self.next(), '[');\n+                let index = self.parse_u32();\n+                assert_eq!(self.next(), '|');\n+                let space = self.parse_param_space();\n+                assert_eq!(self.next(), '|');\n+                let name = token::intern(&self.parse_str(']'));\n+                return tcx.mk_param(space, index, name);\n+            }\n+            '~' => return tcx.mk_box(self.parse_ty()),\n+            '*' => return tcx.mk_ptr(self.parse_mt()),\n+            '&' => {\n+                let r = self.parse_region();\n+                let mt = self.parse_mt();\n+                return tcx.mk_ref(tcx.mk_region(r), mt);\n+            }\n+            'V' => {\n+                let t = self.parse_ty();\n+                return match self.parse_size() {\n+                    Some(n) => tcx.mk_array(t, n),\n+                    None => tcx.mk_slice(t)\n+                };\n+            }\n+            'v' => {\n+                return tcx.mk_str();\n+            }\n+            'T' => {\n+                assert_eq!(self.next(), '[');\n+                let mut params = Vec::new();\n+                while self.peek() != ']' { params.push(self.parse_ty()); }\n+                self.pos = self.pos + 1;\n+                return tcx.mk_tup(params);\n+            }\n+            'F' => {\n+                let def_id = self.parse_def(NominalType);\n+                return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+            }\n+            'G' => {\n+                return tcx.mk_fn(None, tcx.mk_bare_fn(self.parse_bare_fn_ty()));\n+            }\n+            '#' => {\n+                // This is a hacky little caching scheme. The idea is that if we encode\n+                // the same type twice, the second (and third, and fourth...) time we will\n+                // just write `#123`, where `123` is the offset in the metadata of the\n+                // first appearance. Now when we are *decoding*, if we see a `#123`, we\n+                // can first check a cache (`tcx.rcache`) for that offset. If we find something,\n+                // we return it (modulo closure types, see below). But if not, then we\n+                // jump to offset 123 and read the type from there.\n+\n+                let pos = self.parse_hex();\n+                assert_eq!(self.next(), ':');\n+                let len = self.parse_hex();\n+                assert_eq!(self.next(), '#');\n+                let key = ty::CReaderCacheKey {cnum: self.krate, pos: pos, len: len };\n+                match tcx.rcache.borrow().get(&key).cloned() {\n+                    Some(tt) => {\n+                        // If there is a closure buried in the type some where, then we\n+                        // need to re-convert any def ids (see case 'k', below). That means\n+                        // we can't reuse the cached version.\n+                        if !tt.has_closure_types() {\n+                            return tt;\n+                        }\n+                    }\n+                    None => {}\n+                }\n \n-fn parse_region_substs_<F>(st: &mut PState, conv: &mut F) -> subst::RegionSubsts where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        'e' => subst::ErasedRegions,\n-        'n' => {\n-            subst::NonerasedRegions(\n-                parse_vec_per_param_space(\n-                    st, |st| parse_region_(st, conv)))\n+                let mut substate = TyDecoder::new(self.data,\n+                                                  self.krate,\n+                                                  pos,\n+                                                  self.tcx,\n+                                                  self.conv_def_id);\n+                let tt = substate.parse_ty();\n+                tcx.rcache.borrow_mut().insert(key, tt);\n+                return tt;\n+            }\n+            '\\\"' => {\n+                let _ = self.parse_def(TypeWithId);\n+                let inner = self.parse_ty();\n+                inner\n+            }\n+            'a' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(NominalType);\n+                let substs = self.parse_substs();\n+                assert_eq!(self.next(), ']');\n+                let def = self.tcx.lookup_adt_def(did);\n+                return self.tcx.mk_struct(def, self.tcx.mk_substs(substs));\n+            }\n+            'k' => {\n+                assert_eq!(self.next(), '[');\n+                let did = self.parse_def(ClosureSource);\n+                let substs = self.parse_substs();\n+                let mut tys = vec![];\n+                while self.peek() != '.' {\n+                    tys.push(self.parse_ty());\n+                }\n+                assert_eq!(self.next(), '.');\n+                assert_eq!(self.next(), ']');\n+                return self.tcx.mk_closure(did, self.tcx.mk_substs(substs), tys);\n+            }\n+            'P' => {\n+                assert_eq!(self.next(), '[');\n+                let trait_ref = self.parse_trait_ref();\n+                let name = token::intern(&self.parse_str(']'));\n+                return tcx.mk_projection(trait_ref, name);\n+            }\n+            'e' => {\n+                return tcx.types.err;\n+            }\n+            c => { panic!(\"unexpected char in type string: {}\", c);}\n         }\n-        _ => panic!(\"parse_bound_region: bad input\")\n     }\n-}\n \n-fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        'a' => {\n-            let id = parse_u32(st);\n-            assert_eq!(next(st), '|');\n-            ty::BrAnon(id)\n+    fn parse_mutability(&mut self) -> ast::Mutability {\n+        match self.peek() {\n+            'm' => { self.next(); ast::MutMutable }\n+            _ => { ast::MutImmutable }\n         }\n-        '[' => {\n-            let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(&parse_str(st, ']'));\n-            ty::BrNamed(def, ident.name)\n-        }\n-        'f' => {\n-            let id = parse_u32(st);\n-            assert_eq!(next(st), '|');\n-            ty::BrFresh(id)\n-        }\n-        'e' => ty::BrEnv,\n-        _ => panic!(\"parse_bound_region: bad input\")\n     }\n-}\n \n-fn parse_region<F>(st: &mut PState, mut conv: F) -> ty::Region where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_region_(st, &mut conv)\n-}\n+    fn parse_mt(&mut self) -> ty::TypeAndMut<'tcx> {\n+        let m = self.parse_mutability();\n+        ty::TypeAndMut { ty: self.parse_ty(), mutbl: m }\n+    }\n \n-fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-      'b' => {\n-        assert_eq!(next(st), '[');\n-        let id = ty::DebruijnIndex::new(parse_u32(st));\n-        assert_eq!(next(st), '|');\n-        let br = parse_bound_region_(st, conv);\n-        assert_eq!(next(st), ']');\n-        ty::ReLateBound(id, br)\n-      }\n-      'B' => {\n-        assert_eq!(next(st), '[');\n-        let node_id = parse_uint(st) as ast::NodeId;\n-        assert_eq!(next(st), '|');\n-        let space = parse_param_space(st);\n-        assert_eq!(next(st), '|');\n-        let index = parse_u32(st);\n-        assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(&parse_str(st, ']'));\n-        ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            param_id: node_id,\n-            space: space,\n-            index: index,\n-            name: nm.name\n-        })\n-      }\n-      'f' => {\n-        assert_eq!(next(st), '[');\n-        let scope = parse_destruction_scope_data(st);\n-        assert_eq!(next(st), '|');\n-        let br = parse_bound_region_(st, conv);\n-        assert_eq!(next(st), ']');\n-        ty::ReFree(ty::FreeRegion { scope: scope,\n-                                    bound_region: br})\n-      }\n-      's' => {\n-        let scope = parse_scope(st);\n-        assert_eq!(next(st), '|');\n-        ty::ReScope(scope)\n-      }\n-      't' => {\n-        ty::ReStatic\n-      }\n-      'e' => {\n-        ty::ReStatic\n-      }\n-      _ => panic!(\"parse_region: bad input\")\n+    fn parse_def(&mut self, source: DefIdSource) -> ast::DefId {\n+        let def_id = parse_defid(self.scan(|c| c == '|'));\n+        return (self.conv_def_id)(source, def_id);\n     }\n-}\n \n-fn parse_scope(st: &mut PState) -> region::CodeExtent {\n-    match next(st) {\n-        'P' => {\n-            assert_eq!(next(st), '[');\n-            let fn_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), '|');\n-            let body_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), ']');\n-            region::CodeExtent::ParameterScope {\n-                fn_id: fn_id, body_id: body_id\n-            }\n-        }\n-        'M' => {\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            region::CodeExtent::Misc(node_id)\n-        }\n-        'D' => {\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            region::CodeExtent::DestructionScope(node_id)\n-        }\n-        'B' => {\n-            assert_eq!(next(st), '[');\n-            let node_id = parse_uint(st) as ast::NodeId;\n-            assert_eq!(next(st), '|');\n-            let first_stmt_index = parse_uint(st);\n-            assert_eq!(next(st), ']');\n-            let block_remainder = region::BlockRemainder {\n-                block: node_id, first_statement_index: first_stmt_index,\n-            };\n-            region::CodeExtent::Remainder(block_remainder)\n-        }\n-        _ => panic!(\"parse_scope: bad input\")\n+    fn parse_uint(&mut self) -> usize {\n+        let mut n = 0;\n+        loop {\n+            let cur = self.peek();\n+            if cur < '0' || cur > '9' { return n; }\n+            self.pos = self.pos + 1;\n+            n *= 10;\n+            n += (cur as usize) - ('0' as usize);\n+        };\n     }\n-}\n \n-fn parse_destruction_scope_data(st: &mut PState) -> region::DestructionScopeData {\n-    let node_id = parse_uint(st) as ast::NodeId;\n-    region::DestructionScopeData::new(node_id)\n-}\n+    fn parse_u32(&mut self) -> u32 {\n+        let n = self.parse_uint();\n+        let m = n as u32;\n+        assert_eq!(m as usize, n);\n+        m\n+    }\n \n-fn parse_opt<'a, 'tcx, T, F>(st: &mut PState<'a, 'tcx>, f: F) -> Option<T> where\n-    F: FnOnce(&mut PState<'a, 'tcx>) -> T,\n-{\n-    match next(st) {\n-      'n' => None,\n-      's' => Some(f(st)),\n-      _ => panic!(\"parse_opt: bad input\")\n+    fn parse_param_space(&mut self) -> subst::ParamSpace {\n+        subst::ParamSpace::from_uint(self.parse_uint())\n     }\n-}\n \n-fn parse_str(st: &mut PState, term: char) -> String {\n-    let mut result = String::new();\n-    while peek(st) != term {\n-        unsafe {\n-            result.as_mut_vec().push_all(&[next_byte(st)])\n-        }\n+    fn parse_hex(&mut self) -> usize {\n+        let mut n = 0;\n+        loop {\n+            let cur = self.peek();\n+            if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n+            self.pos = self.pos + 1;\n+            n *= 16;\n+            if '0' <= cur && cur <= '9' {\n+                n += (cur as usize) - ('0' as usize);\n+            } else { n += 10 + (cur as usize) - ('a' as usize); }\n+        };\n     }\n-    next(st);\n-    result\n-}\n \n-fn parse_trait_ref<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                -> ty::TraitRef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_trait_ref_(st, &mut conv)\n-}\n+    fn parse_abi_set(&mut self) -> abi::Abi {\n+        assert_eq!(self.next(), '[');\n+        let bytes = self.scan(|c| c == ']');\n+        let abi_str = str::from_utf8(bytes).unwrap();\n+        abi::lookup(&abi_str[..]).expect(abi_str)\n+    }\n \n-fn parse_trait_ref_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                              -> ty::TraitRef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let def = parse_def_(st, NominalType, conv);\n-    let substs = st.tcx.mk_substs(parse_substs_(st, conv));\n-    ty::TraitRef {def_id: def, substs: substs}\n-}\n+    pub fn parse_closure_ty(&mut self) -> ty::ClosureTy<'tcx> {\n+        let unsafety = parse_unsafety(self.next());\n+        let sig = self.parse_sig();\n+        let abi = self.parse_abi_set();\n+        ty::ClosureTy {\n+            unsafety: unsafety,\n+            sig: sig,\n+            abi: abi,\n+        }\n+    }\n \n-fn parse_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F) -> Ty<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_ty_(st, &mut conv)\n-}\n+    pub fn parse_bare_fn_ty(&mut self) -> ty::BareFnTy<'tcx> {\n+        let unsafety = parse_unsafety(self.next());\n+        let abi = self.parse_abi_set();\n+        let sig = self.parse_sig();\n+        ty::BareFnTy {\n+            unsafety: unsafety,\n+            abi: abi,\n+            sig: sig\n+        }\n+    }\n \n-fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let tcx = st.tcx;\n-    match next(st) {\n-      'b' => return tcx.types.bool,\n-      'i' => { /* eat the s of is */ next(st); return tcx.types.isize },\n-      'u' => { /* eat the s of us */ next(st); return tcx.types.usize },\n-      'M' => {\n-        match next(st) {\n-          'b' => return tcx.types.u8,\n-          'w' => return tcx.types.u16,\n-          'l' => return tcx.types.u32,\n-          'd' => return tcx.types.u64,\n-          'B' => return tcx.types.i8,\n-          'W' => return tcx.types.i16,\n-          'L' => return tcx.types.i32,\n-          'D' => return tcx.types.i64,\n-          'f' => return tcx.types.f32,\n-          'F' => return tcx.types.f64,\n-          _ => panic!(\"parse_ty: bad numeric type\")\n+    fn parse_sig(&mut self) -> ty::PolyFnSig<'tcx> {\n+        assert_eq!(self.next(), '[');\n+        let mut inputs = Vec::new();\n+        while self.peek() != ']' {\n+            inputs.push(self.parse_ty());\n         }\n-      }\n-      'c' => return tcx.types.char,\n-      't' => {\n-        assert_eq!(next(st), '[');\n-        let did = parse_def_(st, NominalType, conv);\n-        let substs = parse_substs_(st, conv);\n-        assert_eq!(next(st), ']');\n-        let def = st.tcx.lookup_adt_def(did);\n-        return tcx.mk_enum(def, st.tcx.mk_substs(substs));\n-      }\n-      'x' => {\n-        assert_eq!(next(st), '[');\n-        let trait_ref = ty::Binder(parse_trait_ref_(st, conv));\n-        let bounds = parse_existential_bounds_(st, conv);\n-        assert_eq!(next(st), ']');\n-        return tcx.mk_trait(trait_ref, bounds);\n-      }\n-      'p' => {\n-        assert_eq!(next(st), '[');\n-        let index = parse_u32(st);\n-        assert_eq!(next(st), '|');\n-        let space = parse_param_space(st);\n-        assert_eq!(next(st), '|');\n-        let name = token::intern(&parse_str(st, ']'));\n-        return tcx.mk_param(space, index, name);\n-      }\n-      '~' => return tcx.mk_box(parse_ty_(st, conv)),\n-      '*' => return tcx.mk_ptr(parse_mt_(st, conv)),\n-      '&' => {\n-        let r = parse_region_(st, conv);\n-        let mt = parse_mt_(st, conv);\n-        return tcx.mk_ref(tcx.mk_region(r), mt);\n-      }\n-      'V' => {\n-        let t = parse_ty_(st, conv);\n-        return match parse_size(st) {\n-            Some(n) => tcx.mk_array(t, n),\n-            None => tcx.mk_slice(t)\n+        self.pos += 1; // eat the ']'\n+        let variadic = match self.next() {\n+            'V' => true,\n+            'N' => false,\n+            r => panic!(format!(\"bad variadic: {}\", r)),\n         };\n-      }\n-      'v' => {\n-        return tcx.mk_str();\n-      }\n-      'T' => {\n-        assert_eq!(next(st), '[');\n-        let mut params = Vec::new();\n-        while peek(st) != ']' { params.push(parse_ty_(st, conv)); }\n-        st.pos = st.pos + 1;\n-        return tcx.mk_tup(params);\n-      }\n-      'F' => {\n-          let def_id = parse_def_(st, NominalType, conv);\n-          return tcx.mk_fn(Some(def_id), tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n-      }\n-      'G' => {\n-          return tcx.mk_fn(None, tcx.mk_bare_fn(parse_bare_fn_ty_(st, conv)));\n-      }\n-      '#' => {\n-        let pos = parse_hex(st);\n-        assert_eq!(next(st), ':');\n-        let len = parse_hex(st);\n-        assert_eq!(next(st), '#');\n-        let key = ty::CReaderCacheKey {cnum: st.krate,\n-                                         pos: pos,\n-                                         len: len };\n-\n-        match tcx.rcache.borrow().get(&key).cloned() {\n-          Some(tt) => {\n-            // If there is a closure buried in the type some where, then we\n-            // need to re-convert any def ids (see case 'k', below). That means\n-            // we can't reuse the cached version.\n-            if !tt.has_closure_types() {\n-                return tt;\n+        let output = match self.peek() {\n+            'z' => {\n+                self.pos += 1;\n+                ty::FnDiverging\n             }\n-          }\n-          None => {}\n-        }\n-        let mut ps = PState {\n-            pos: pos,\n-            .. *st\n+            _ => ty::FnConverging(self.parse_ty())\n         };\n-        let tt = parse_ty_(&mut ps, conv);\n-        tcx.rcache.borrow_mut().insert(key, tt);\n-        return tt;\n-      }\n-      '\\\"' => {\n-        let _ = parse_def_(st, TypeWithId, conv);\n-        let inner = parse_ty_(st, conv);\n-        inner\n-      }\n-      'a' => {\n-          assert_eq!(next(st), '[');\n-          let did = parse_def_(st, NominalType, conv);\n-          let substs = parse_substs_(st, conv);\n-          assert_eq!(next(st), ']');\n-          let def = st.tcx.lookup_adt_def(did);\n-          return st.tcx.mk_struct(def, st.tcx.mk_substs(substs));\n-      }\n-      'k' => {\n-          assert_eq!(next(st), '[');\n-          let did = parse_def_(st, ClosureSource, conv);\n-          let substs = parse_substs_(st, conv);\n-          let mut tys = vec![];\n-          while peek(st) != '.' {\n-              tys.push(parse_ty_(st, conv));\n-          }\n-          assert_eq!(next(st), '.');\n-          assert_eq!(next(st), ']');\n-          return st.tcx.mk_closure(did, st.tcx.mk_substs(substs), tys);\n-      }\n-      'P' => {\n-          assert_eq!(next(st), '[');\n-          let trait_ref = parse_trait_ref_(st, conv);\n-          let name = token::intern(&parse_str(st, ']'));\n-          return tcx.mk_projection(trait_ref, name);\n-      }\n-      'e' => {\n-          return tcx.types.err;\n-      }\n-      c => { panic!(\"unexpected char in type string: {}\", c);}\n+        ty::Binder(ty::FnSig {inputs: inputs,\n+                              output: output,\n+                              variadic: variadic})\n     }\n-}\n \n-fn parse_mutability(st: &mut PState) -> ast::Mutability {\n-    match peek(st) {\n-      'm' => { next(st); ast::MutMutable }\n-      _ => { ast::MutImmutable }\n+    pub fn parse_predicate(&mut self) -> ty::Predicate<'tcx> {\n+        match self.next() {\n+            't' => ty::Binder(self.parse_trait_ref()).to_predicate(),\n+            'e' => ty::Binder(ty::EquatePredicate(self.parse_ty(),\n+                                                  self.parse_ty())).to_predicate(),\n+            'r' => ty::Binder(ty::OutlivesPredicate(self.parse_region(),\n+                                                    self.parse_region())).to_predicate(),\n+            'o' => ty::Binder(ty::OutlivesPredicate(self.parse_ty(),\n+                                                    self.parse_region())).to_predicate(),\n+            'p' => ty::Binder(self.parse_projection_predicate()).to_predicate(),\n+            'w' => ty::Predicate::WellFormed(self.parse_ty()),\n+            'O' => {\n+                let def_id = self.parse_def(NominalType);\n+                assert_eq!(self.next(), '|');\n+                ty::Predicate::ObjectSafe(def_id)\n+            }\n+            c => panic!(\"Encountered invalid character in metadata: {}\", c)\n+        }\n     }\n-}\n \n-fn parse_mt_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::TypeAndMut<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let m = parse_mutability(st);\n-    ty::TypeAndMut { ty: parse_ty_(st, conv), mutbl: m }\n-}\n-\n-fn parse_def_<F>(st: &mut PState, source: DefIdSource, conv: &mut F) -> ast::DefId where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    return (*conv)(source, scan(st, |c| { c == '|' }, parse_def_id));\n-}\n-\n-fn parse_uint(st: &mut PState) -> usize {\n-    let mut n = 0;\n-    loop {\n-        let cur = peek(st);\n-        if cur < '0' || cur > '9' { return n; }\n-        st.pos = st.pos + 1;\n-        n *= 10;\n-        n += (cur as usize) - ('0' as usize);\n-    };\n-}\n-\n-fn parse_u32(st: &mut PState) -> u32 {\n-    let n = parse_uint(st);\n-    let m = n as u32;\n-    assert_eq!(m as usize, n);\n-    m\n-}\n-\n-fn parse_param_space(st: &mut PState) -> subst::ParamSpace {\n-    subst::ParamSpace::from_uint(parse_uint(st))\n-}\n-\n-fn parse_hex(st: &mut PState) -> usize {\n-    let mut n = 0;\n-    loop {\n-        let cur = peek(st);\n-        if (cur < '0' || cur > '9') && (cur < 'a' || cur > 'f') { return n; }\n-        st.pos = st.pos + 1;\n-        n *= 16;\n-        if '0' <= cur && cur <= '9' {\n-            n += (cur as usize) - ('0' as usize);\n-        } else { n += 10 + (cur as usize) - ('a' as usize); }\n-    };\n-}\n-\n-fn parse_unsafety(c: char) -> ast::Unsafety {\n-    match c {\n-        'u' => ast::Unsafety::Unsafe,\n-        'n' => ast::Unsafety::Normal,\n-        _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n+    fn parse_projection_predicate(&mut self) -> ty::ProjectionPredicate<'tcx> {\n+        ty::ProjectionPredicate {\n+            projection_ty: ty::ProjectionTy {\n+                trait_ref: self.parse_trait_ref(),\n+                item_name: token::str_to_ident(&self.parse_str('|')).name,\n+            },\n+            ty: self.parse_ty(),\n+        }\n     }\n-}\n \n-fn parse_abi_set(st: &mut PState) -> abi::Abi {\n-    assert_eq!(next(st), '[');\n-    scan(st, |c| c == ']', |bytes| {\n-        let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(&abi_str[..]).expect(abi_str)\n-    })\n-}\n-\n-fn parse_closure_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 mut conv: F) -> ty::ClosureTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_closure_ty_(st, &mut conv)\n-}\n+    pub fn parse_type_param_def(&mut self) -> ty::TypeParameterDef<'tcx> {\n+        let name = self.parse_name(':');\n+        let def_id = self.parse_def(NominalType);\n+        let space = self.parse_param_space();\n+        assert_eq!(self.next(), '|');\n+        let index = self.parse_u32();\n+        assert_eq!(self.next(), '|');\n+        let default_def_id = self.parse_def(NominalType);\n+        let default = self.parse_opt(|this| this.parse_ty());\n+        let object_lifetime_default = self.parse_object_lifetime_default();\n+\n+        ty::TypeParameterDef {\n+            name: name,\n+            def_id: def_id,\n+            space: space,\n+            index: index,\n+            default_def_id: default_def_id,\n+            default: default,\n+            object_lifetime_default: object_lifetime_default,\n+        }\n+    }\n \n-fn parse_closure_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 conv: &mut F) -> ty::ClosureTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let unsafety = parse_unsafety(next(st));\n-    let sig = parse_sig_(st, conv);\n-    let abi = parse_abi_set(st);\n-    ty::ClosureTy {\n-        unsafety: unsafety,\n-        sig: sig,\n-        abi: abi,\n+    fn parse_object_lifetime_default(&mut self) -> ty::ObjectLifetimeDefault {\n+        match self.next() {\n+            'a' => ty::ObjectLifetimeDefault::Ambiguous,\n+            'b' => ty::ObjectLifetimeDefault::BaseDefault,\n+            's' => {\n+                let region = self.parse_region();\n+                ty::ObjectLifetimeDefault::Specific(region)\n+            }\n+            _ => panic!(\"parse_object_lifetime_default: bad input\")\n+        }\n     }\n-}\n \n-fn parse_bare_fn_ty<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 mut conv: F) -> ty::BareFnTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_bare_fn_ty_(st, &mut conv)\n-}\n+    pub fn parse_existential_bounds(&mut self) -> ty::ExistentialBounds<'tcx> {\n+        let builtin_bounds = self.parse_builtin_bounds();\n+        let region_bound = self.parse_region();\n+        let mut projection_bounds = Vec::new();\n \n-fn parse_bare_fn_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                 conv: &mut F) -> ty::BareFnTy<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let unsafety = parse_unsafety(next(st));\n-    let abi = parse_abi_set(st);\n-    let sig = parse_sig_(st, conv);\n-    ty::BareFnTy {\n-        unsafety: unsafety,\n-        abi: abi,\n-        sig: sig\n+        loop {\n+            match self.next() {\n+                'P' => {\n+                    projection_bounds.push(ty::Binder(self.parse_projection_predicate()));\n+                }\n+                '.' => { break; }\n+                c => {\n+                    panic!(\"parse_bounds: bad bounds ('{}')\", c)\n+                }\n+            }\n+        }\n+\n+        return ty::ExistentialBounds { region_bound: region_bound,\n+                                       builtin_bounds: builtin_bounds,\n+                                       projection_bounds: projection_bounds };\n     }\n-}\n \n-fn parse_sig_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> ty::PolyFnSig<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    assert_eq!(next(st), '[');\n-    let mut inputs = Vec::new();\n-    while peek(st) != ']' {\n-        inputs.push(parse_ty_(st, conv));\n-    }\n-    st.pos += 1; // eat the ']'\n-    let variadic = match next(st) {\n-        'V' => true,\n-        'N' => false,\n-        r => panic!(format!(\"bad variadic: {}\", r)),\n-    };\n-    let output = match peek(st) {\n-        'z' => {\n-          st.pos += 1;\n-          ty::FnDiverging\n+    fn parse_builtin_bounds(&mut self) -> ty::BuiltinBounds {\n+        let mut builtin_bounds = ty::BuiltinBounds::empty();\n+        loop {\n+            match self.next() {\n+                'S' => {\n+                    builtin_bounds.insert(ty::BoundSend);\n+                }\n+                'Z' => {\n+                    builtin_bounds.insert(ty::BoundSized);\n+                }\n+                'P' => {\n+                    builtin_bounds.insert(ty::BoundCopy);\n+                }\n+                'T' => {\n+                    builtin_bounds.insert(ty::BoundSync);\n+                }\n+                '.' => {\n+                    return builtin_bounds;\n+                }\n+                c => {\n+                    panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n+                }\n+            }\n         }\n-        _ => ty::FnConverging(parse_ty_(st, conv))\n-    };\n-    ty::Binder(ty::FnSig {inputs: inputs,\n-                        output: output,\n-                        variadic: variadic})\n+    }\n }\n \n // Rust metadata parsing\n-pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n+fn parse_defid(buf: &[u8]) -> ast::DefId {\n     let mut colon_idx = 0;\n     let len = buf.len();\n     while colon_idx < len && buf[colon_idx] != ':' as u8 { colon_idx += 1; }\n@@ -742,202 +695,25 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-       Some(cn) => cn as ast::CrateNum,\n-       None => panic!(\"internal error: parse_def_id: crate number expected, found {:?}\",\n-                     crate_part)\n+        Some(cn) => cn as ast::CrateNum,\n+        None => panic!(\"internal error: parse_defid: crate number expected, found {:?}\",\n+                       crate_part)\n     };\n     let def_num = match str::from_utf8(def_part).ok().and_then(|s| {\n         s.parse::<usize>().ok()\n     }) {\n-       Some(dn) => dn as ast::NodeId,\n-       None => panic!(\"internal error: parse_def_id: id expected, found {:?}\",\n-                     def_part)\n+        Some(dn) => dn as ast::NodeId,\n+        None => panic!(\"internal error: parse_defid: id expected, found {:?}\",\n+                       def_part)\n     };\n     ast::DefId { krate: crate_num, node: def_num }\n }\n \n-pub fn parse_predicate_data<'tcx, F>(data: &[u8],\n-                                     start: usize,\n-                                     crate_num: ast::CrateNum,\n-                                     tcx: &ty::ctxt<'tcx>,\n-                                     conv: F)\n-                                     -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_predicate(&mut st, conv)\n-}\n-\n-pub fn parse_predicate<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                   mut conv: F)\n-                                   -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_predicate_(st, &mut conv)\n-}\n-\n-fn parse_predicate_<'a,'tcx, F>(st: &mut PState<'a, 'tcx>,\n-                                conv: &mut F)\n-                                -> ty::Predicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        't' => ty::Binder(parse_trait_ref_(st, conv)).to_predicate(),\n-        'e' => ty::Binder(ty::EquatePredicate(parse_ty_(st, conv),\n-                                              parse_ty_(st, conv))).to_predicate(),\n-        'r' => ty::Binder(ty::OutlivesPredicate(parse_region_(st, conv),\n-                                                parse_region_(st, conv))).to_predicate(),\n-        'o' => ty::Binder(ty::OutlivesPredicate(parse_ty_(st, conv),\n-                                                parse_region_(st, conv))).to_predicate(),\n-        'p' => ty::Binder(parse_projection_predicate_(st, conv)).to_predicate(),\n-        'w' => ty::Predicate::WellFormed(parse_ty_(st, conv)),\n-        'O' => {\n-            let def_id = parse_def_(st, NominalType, conv);\n-            assert_eq!(next(st), '|');\n-            ty::Predicate::ObjectSafe(def_id)\n-        }\n-        c => panic!(\"Encountered invalid character in metadata: {}\", c)\n-    }\n-}\n-\n-fn parse_projection_predicate_<'a,'tcx, F>(\n-    st: &mut PState<'a, 'tcx>,\n-    conv: &mut F,\n-) -> ty::ProjectionPredicate<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    ty::ProjectionPredicate {\n-        projection_ty: ty::ProjectionTy {\n-            trait_ref: parse_trait_ref_(st, conv),\n-            item_name: token::str_to_ident(&parse_str(st, '|')).name,\n-        },\n-        ty: parse_ty_(st, conv),\n-    }\n-}\n-\n-pub fn parse_type_param_def_data<'tcx, F>(data: &[u8], start: usize,\n-                                          crate_num: ast::CrateNum, tcx: &ty::ctxt<'tcx>,\n-                                          conv: F) -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut st = parse_state_from_data(data, crate_num, start, tcx);\n-    parse_type_param_def(&mut st, conv)\n-}\n-\n-fn parse_type_param_def<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, mut conv: F)\n-                                     -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_type_param_def_(st, &mut conv)\n-}\n-\n-fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n-                                      -> ty::TypeParameterDef<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let name = parse_name(st, ':');\n-    let def_id = parse_def_(st, NominalType, conv);\n-    let space = parse_param_space(st);\n-    assert_eq!(next(st), '|');\n-    let index = parse_u32(st);\n-    assert_eq!(next(st), '|');\n-    let default_def_id = parse_def_(st, NominalType, conv);\n-    let default = parse_opt(st, |st| parse_ty_(st, conv));\n-    let object_lifetime_default = parse_object_lifetime_default(st, conv);\n-\n-    ty::TypeParameterDef {\n-        name: name,\n-        def_id: def_id,\n-        space: space,\n-        index: index,\n-        default_def_id: default_def_id,\n-        default: default,\n-        object_lifetime_default: object_lifetime_default,\n-    }\n-}\n-\n-fn parse_object_lifetime_default<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                             conv: &mut F)\n-                                             -> ty::ObjectLifetimeDefault\n-    where F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    match next(st) {\n-        'a' => ty::ObjectLifetimeDefault::Ambiguous,\n-        'b' => ty::ObjectLifetimeDefault::BaseDefault,\n-        's' => {\n-            let region = parse_region_(st, conv);\n-            ty::ObjectLifetimeDefault::Specific(region)\n-        }\n-        _ => panic!(\"parse_object_lifetime_default: bad input\")\n-    }\n-}\n-\n-fn parse_existential_bounds<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                        mut conv: F)\n-                                        -> ty::ExistentialBounds<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_existential_bounds_(st, &mut conv)\n-}\n-\n-fn parse_existential_bounds_<'a,'tcx, F>(st: &mut PState<'a,'tcx>,\n-                                        conv: &mut F)\n-                                        -> ty::ExistentialBounds<'tcx> where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let builtin_bounds = parse_builtin_bounds_(st, conv);\n-    let region_bound = parse_region_(st, conv);\n-    let mut projection_bounds = Vec::new();\n-\n-    loop {\n-        match next(st) {\n-            'P' => {\n-                projection_bounds.push(\n-                    ty::Binder(parse_projection_predicate_(st, conv)));\n-                }\n-            '.' => { break; }\n-            c => {\n-                panic!(\"parse_bounds: bad bounds ('{}')\", c)\n-            }\n-        }\n+fn parse_unsafety(c: char) -> ast::Unsafety {\n+    match c {\n+        'u' => ast::Unsafety::Unsafe,\n+        'n' => ast::Unsafety::Normal,\n+        _ => panic!(\"parse_unsafety: bad unsafety {}\", c)\n     }\n-\n-    return ty::ExistentialBounds { region_bound: region_bound,\n-                                   builtin_bounds: builtin_bounds,\n-                                   projection_bounds: projection_bounds };\n }\n \n-fn parse_builtin_bounds<F>(st: &mut PState, mut _conv: F) -> ty::BuiltinBounds where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    parse_builtin_bounds_(st, &mut _conv)\n-}\n-\n-fn parse_builtin_bounds_<F>(st: &mut PState, _conv: &mut F) -> ty::BuiltinBounds where\n-    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n-{\n-    let mut builtin_bounds = ty::BuiltinBounds::empty();\n-\n-    loop {\n-        match next(st) {\n-            'S' => {\n-                builtin_bounds.insert(ty::BoundSend);\n-            }\n-            'Z' => {\n-                builtin_bounds.insert(ty::BoundSized);\n-            }\n-            'P' => {\n-                builtin_bounds.insert(ty::BoundCopy);\n-            }\n-            'T' => {\n-                builtin_bounds.insert(ty::BoundSync);\n-            }\n-            '.' => {\n-                return builtin_bounds;\n-            }\n-            c => {\n-                panic!(\"parse_bounds: bad builtin bounds ('{}')\", c)\n-            }\n-        }\n-    }\n-}"}, {"sha": "591fc043f914c8d8c74ef8ff493320e4ada8d276", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 72, "deletions": 109, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -17,16 +17,17 @@ use metadata::common as c;\n use metadata::cstore as cstore;\n use session::Session;\n use metadata::decoder;\n-use middle::def;\n use metadata::encoder as e;\n-use middle::region;\n+use metadata::inline::{InlinedItem, InlinedItemRef};\n use metadata::tydecode;\n use metadata::tydecode::{DefIdSource, NominalType, TypeWithId};\n use metadata::tydecode::{RegionParameter, ClosureSource};\n use metadata::tyencode;\n use middle::cast;\n use middle::check_const::ConstQualif;\n+use middle::def;\n use middle::privacy::{AllPublic, LastMod};\n+use middle::region;\n use middle::subst;\n use middle::subst::VecPerParamSpace;\n use middle::ty::{self, Ty};\n@@ -75,20 +76,20 @@ trait tr_intern {\n \n pub fn encode_inlined_item(ecx: &e::EncodeContext,\n                            rbml_w: &mut Encoder,\n-                           ii: e::InlinedItemRef) {\n+                           ii: InlinedItemRef) {\n     let id = match ii {\n-        e::IIItemRef(i) => i.id,\n-        e::IIForeignRef(i) => i.id,\n-        e::IITraitItemRef(_, ti) => ti.id,\n-        e::IIImplItemRef(_, ii) => ii.id,\n+        InlinedItemRef::Item(i) => i.id,\n+        InlinedItemRef::Foreign(i) => i.id,\n+        InlinedItemRef::TraitItem(_, ti) => ti.id,\n+        InlinedItemRef::ImplItem(_, ii) => ii.id,\n     };\n     debug!(\"> Encoding inlined item: {} ({:?})\",\n            ecx.tcx.map.path_to_string(id),\n            rbml_w.writer.seek(SeekFrom::Current(0)));\n \n     // Folding could be avoided with a smarter encoder.\n     let ii = simplify_ast(ii);\n-    let id_range = ast_util::compute_id_range_for_inlined_item(&ii);\n+    let id_range = ii.compute_id_range();\n \n     rbml_w.start_tag(c::tag_ast as usize);\n     id_range.encode(rbml_w);\n@@ -124,7 +125,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n                                  tcx: &ty::ctxt<'tcx>,\n                                  path: Vec<ast_map::PathElem>,\n                                  par_doc: rbml::Doc)\n-                                 -> Result<&'tcx ast::InlinedItem, Vec<ast_map::PathElem>> {\n+                                 -> Result<&'tcx InlinedItem, Vec<ast_map::PathElem>> {\n     match par_doc.opt_child(c::tag_ast) {\n       None => Err(path),\n       Some(ast_doc) => {\n@@ -150,10 +151,10 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         let ii = ast_map::map_decoded_item(&dcx.tcx.map, path, raw_ii, dcx);\n \n         let ident = match *ii {\n-            ast::IIItem(ref i) => i.ident,\n-            ast::IIForeign(ref i) => i.ident,\n-            ast::IITraitItem(_, ref ti) => ti.ident,\n-            ast::IIImplItem(_, ref ii) => ii.ident\n+            InlinedItem::Item(ref i) => i.ident,\n+            InlinedItem::Foreign(ref i) => i.ident,\n+            InlinedItem::TraitItem(_, ref ti) => ti.ident,\n+            InlinedItem::ImplItem(_, ref ii) => ii.ident\n         };\n         debug!(\"Fn named: {}\", ident);\n         debug!(\"< Decoded inlined fn: {}::{}\",\n@@ -162,7 +163,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n         region::resolve_inlined_item(&tcx.sess, &tcx.region_maps, ii);\n         decode_side_tables(dcx, ast_doc);\n         match *ii {\n-          ast::IIItem(ref i) => {\n+          InlinedItem::Item(ref i) => {\n             debug!(\">>> DECODED ITEM >>>\\n{}\\n<<< DECODED ITEM <<<\",\n                    syntax::print::pprust::item_to_string(&**i));\n           }\n@@ -349,7 +350,7 @@ impl<D:serialize::Decoder> def_id_decoder_helpers for D\n // We also have to adjust the spans: for now we just insert a dummy span,\n // but eventually we should add entries to the local codemap as required.\n \n-fn encode_ast(rbml_w: &mut Encoder, item: &ast::InlinedItem) {\n+fn encode_ast(rbml_w: &mut Encoder, item: &InlinedItem) {\n     rbml_w.start_tag(c::tag_tree as usize);\n     item.encode(rbml_w);\n     rbml_w.end_tag();\n@@ -399,34 +400,34 @@ impl Folder for NestedItemsDropper {\n // As it happens, trans relies on the fact that we do not export\n // nested items, as otherwise it would get confused when translating\n // inlined items.\n-fn simplify_ast(ii: e::InlinedItemRef) -> ast::InlinedItem {\n+fn simplify_ast(ii: InlinedItemRef) -> InlinedItem {\n     let mut fld = NestedItemsDropper;\n \n     match ii {\n         // HACK we're not dropping items.\n-        e::IIItemRef(i) => {\n-            ast::IIItem(fold::noop_fold_item(P(i.clone()), &mut fld)\n+        InlinedItemRef::Item(i) => {\n+            InlinedItem::Item(fold::noop_fold_item(P(i.clone()), &mut fld)\n                             .expect_one(\"expected one item\"))\n         }\n-        e::IITraitItemRef(d, ti) => {\n-            ast::IITraitItem(d,\n+        InlinedItemRef::TraitItem(d, ti) => {\n+            InlinedItem::TraitItem(d,\n                 fold::noop_fold_trait_item(P(ti.clone()), &mut fld)\n                     .expect_one(\"noop_fold_trait_item must produce \\\n                                  exactly one trait item\"))\n         }\n-        e::IIImplItemRef(d, ii) => {\n-            ast::IIImplItem(d,\n+        InlinedItemRef::ImplItem(d, ii) => {\n+            InlinedItem::ImplItem(d,\n                 fold::noop_fold_impl_item(P(ii.clone()), &mut fld)\n                     .expect_one(\"noop_fold_impl_item must produce \\\n                                  exactly one impl item\"))\n         }\n-        e::IIForeignRef(i) => {\n-            ast::IIForeign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n+        InlinedItemRef::Foreign(i) => {\n+            InlinedItem::Foreign(fold::noop_fold_foreign_item(P(i.clone()), &mut fld))\n         }\n     }\n }\n \n-fn decode_ast(par_doc: rbml::Doc) -> ast::InlinedItem {\n+fn decode_ast(par_doc: rbml::Doc) -> InlinedItem {\n     let chi_doc = par_doc.get(c::tag_tree as usize);\n     let mut d = reader::Decoder::new(chi_doc);\n     Decodable::decode(&mut d).unwrap()\n@@ -920,9 +921,9 @@ impl<'a, 'b, 'c, 'tcx> ast_util::IdVisitingOperation for\n \n fn encode_side_tables_for_ii(ecx: &e::EncodeContext,\n                              rbml_w: &mut Encoder,\n-                             ii: &ast::InlinedItem) {\n+                             ii: &InlinedItem) {\n     rbml_w.start_tag(c::tag_table as usize);\n-    ast_util::visit_ids_for_inlined_item(ii, &mut SideTableEncodingIdVisitor {\n+    ii.visit_ids(&mut SideTableEncodingIdVisitor {\n         ecx: ecx,\n         rbml_w: rbml_w\n     });\n@@ -1074,6 +1075,10 @@ impl<'a> doc_decoder_helpers for rbml::Doc<'a> {\n }\n \n trait rbml_decoder_decoder_helpers<'tcx> {\n+    fn read_ty_encoded<'a, 'b, F, R>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>,\n+                                     f: F) -> R\n+        where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x, 'tcx>) -> R;\n+\n     fn read_ty<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Ty<'tcx>;\n     fn read_tys<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>) -> Vec<Ty<'tcx>>;\n     fn read_trait_ref<'a, 'b>(&mut self, dcx: &DecodeContext<'a, 'b, 'tcx>)\n@@ -1122,14 +1127,14 @@ trait rbml_decoder_decoder_helpers<'tcx> {\n \n impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_ty_nodcx(&mut self,\n-                     tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata) -> Ty<'tcx> {\n+                     tcx: &ty::ctxt<'tcx>,\n+                     cdata: &cstore::crate_metadata)\n+                     -> Ty<'tcx> {\n         self.read_opaque(|_, doc| {\n-            Ok(tydecode::parse_ty_data(\n-                doc.data,\n-                cdata.cnum,\n-                doc.start,\n-                tcx,\n-                |_, id| decoder::translate_def_id(cdata, id)))\n+            Ok(\n+                tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n+                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                    .parse_ty())\n         }).unwrap()\n     }\n \n@@ -1148,32 +1153,22 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n                          -> subst::Substs<'tcx>\n     {\n         self.read_opaque(|_, doc| {\n-            Ok(tydecode::parse_substs_data(\n-                doc.data,\n-                cdata.cnum,\n-                doc.start,\n-                tcx,\n-                |_, id| decoder::translate_def_id(cdata, id)))\n+            Ok(\n+                tydecode::TyDecoder::with_doc(tcx, cdata.cnum, doc,\n+                                              &mut |_, id| decoder::translate_def_id(cdata, id))\n+                    .parse_substs())\n         }).unwrap()\n     }\n \n-    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n-        // Note: regions types embed local node ids.  In principle, we\n-        // should translate these node ids into the new decode\n-        // context.  However, we do not bother, because region types\n-        // are not used during trans.\n-\n+    fn read_ty_encoded<'b, 'c, F, R>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>, op: F) -> R\n+        where F: for<'x> FnOnce(&mut tydecode::TyDecoder<'x,'tcx>) -> R\n+    {\n         return self.read_opaque(|this, doc| {\n-            debug!(\"read_ty({})\", type_string(doc));\n-\n-            let ty = tydecode::parse_ty_data(\n-                doc.data,\n-                dcx.cdata.cnum,\n-                doc.start,\n-                dcx.tcx,\n-                |s, a| this.convert_def_id(dcx, s, a));\n-\n-            Ok(ty)\n+            debug!(\"read_ty_encoded({})\", type_string(doc));\n+            Ok(op(\n+                &mut tydecode::TyDecoder::with_doc(\n+                    dcx.tcx, dcx.cdata.cnum, doc,\n+                    &mut |s, a| this.convert_def_id(dcx, s, a))))\n         }).unwrap();\n \n         fn type_string(doc: rbml::Doc) -> String {\n@@ -1185,56 +1180,39 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         }\n     }\n \n+    fn read_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>) -> Ty<'tcx> {\n+        // Note: regions types embed local node ids.  In principle, we\n+        // should translate these node ids into the new decode\n+        // context.  However, we do not bother, because region types\n+        // are not used during trans.\n+\n+        return self.read_ty_encoded(dcx, |decoder| decoder.parse_ty());\n+    }\n+\n     fn read_tys<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                         -> Vec<Ty<'tcx>> {\n         self.read_to_vec(|this| Ok(this.read_ty(dcx))).unwrap().into_iter().collect()\n     }\n \n     fn read_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::TraitRef<'tcx> {\n-        self.read_opaque(|this, doc| {\n-            let ty = tydecode::parse_trait_ref_data(\n-                doc.data,\n-                dcx.cdata.cnum,\n-                doc.start,\n-                dcx.tcx,\n-                |s, a| this.convert_def_id(dcx, s, a));\n-            Ok(ty)\n-        }).unwrap()\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_trait_ref())\n     }\n \n     fn read_poly_trait_ref<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::PolyTraitRef<'tcx> {\n-        ty::Binder(self.read_opaque(|this, doc| {\n-            let ty = tydecode::parse_trait_ref_data(\n-                doc.data,\n-                dcx.cdata.cnum,\n-                doc.start,\n-                dcx.tcx,\n-                |s, a| this.convert_def_id(dcx, s, a));\n-            Ok(ty)\n-        }).unwrap())\n+        ty::Binder(self.read_ty_encoded(dcx, |decoder| decoder.parse_trait_ref()))\n     }\n \n     fn read_type_param_def<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                    -> ty::TypeParameterDef<'tcx> {\n-        self.read_opaque(|this, doc| {\n-            Ok(tydecode::parse_type_param_def_data(\n-                doc.data,\n-                doc.start,\n-                dcx.cdata.cnum,\n-                dcx.tcx,\n-                |s, a| this.convert_def_id(dcx, s, a)))\n-        }).unwrap()\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_type_param_def())\n     }\n \n     fn read_predicate<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                               -> ty::Predicate<'tcx>\n     {\n-        self.read_opaque(|this, doc| {\n-            Ok(tydecode::parse_predicate_data(doc.data, doc.start, dcx.cdata.cnum, dcx.tcx,\n-                                              |s, a| this.convert_def_id(dcx, s, a)))\n-        }).unwrap()\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_predicate())\n     }\n \n     fn read_type_scheme<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n@@ -1268,23 +1246,15 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_existential_bounds<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                        -> ty::ExistentialBounds<'tcx>\n     {\n-        self.read_opaque(|this, doc| {\n-            Ok(tydecode::parse_existential_bounds_data(doc.data,\n-                                                       dcx.cdata.cnum,\n-                                                       doc.start,\n-                                                       dcx.tcx,\n-                                                       |s, a| this.convert_def_id(dcx, s, a)))\n-        }).unwrap()\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_existential_bounds())\n     }\n \n     fn read_substs<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                            -> subst::Substs<'tcx> {\n         self.read_opaque(|this, doc| {\n-            Ok(tydecode::parse_substs_data(doc.data,\n-                                           dcx.cdata.cnum,\n-                                           doc.start,\n-                                           dcx.tcx,\n-                                           |s, a| this.convert_def_id(dcx, s, a)))\n+            Ok(tydecode::TyDecoder::with_doc(dcx.tcx, dcx.cdata.cnum, doc,\n+                                             &mut |s, a| this.convert_def_id(dcx, s, a))\n+               .parse_substs())\n         }).unwrap()\n     }\n \n@@ -1379,14 +1349,7 @@ impl<'a, 'tcx> rbml_decoder_decoder_helpers<'tcx> for reader::Decoder<'a> {\n     fn read_closure_ty<'b, 'c>(&mut self, dcx: &DecodeContext<'b, 'c, 'tcx>)\n                                -> ty::ClosureTy<'tcx>\n     {\n-        self.read_opaque(|this, doc| {\n-            Ok(tydecode::parse_ty_closure_data(\n-                doc.data,\n-                dcx.cdata.cnum,\n-                doc.start,\n-                dcx.tcx,\n-                |s, a| this.convert_def_id(dcx, s, a)))\n-        }).unwrap()\n+        self.read_ty_encoded(dcx, |decoder| decoder.parse_closure_ty())\n     }\n \n     /// Converts a def-id that appears in a type.  The correct\n@@ -1644,15 +1607,15 @@ fn test_simplification() {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap();\n-    let item_in = e::IIItemRef(&*item);\n+    let item_in = InlinedItemRef::Item(&*item);\n     let item_out = simplify_ast(item_in);\n-    let item_exp = ast::IIItem(quote_item!(&cx,\n+    let item_exp = InlinedItem::Item(quote_item!(&cx,\n         fn new_int_alist<B>() -> alist<isize, B> {\n             return alist {eq_fn: eq_int, data: Vec::new()};\n         }\n     ).unwrap());\n     match (item_out, item_exp) {\n-      (ast::IIItem(item_out), ast::IIItem(item_exp)) => {\n+      (InlinedItem::Item(item_out), InlinedItem::Item(item_exp)) => {\n         assert!(pprust::item_to_string(&*item_out) ==\n                 pprust::item_to_string(&*item_exp));\n       }"}, {"sha": "a1327df224a977644aaaaa80f3cdef7a489dbced", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -17,6 +17,7 @@ use self::EvalHint::*;\n use ast_map;\n use ast_map::blocks::FnLikeNode;\n use metadata::csearch;\n+use metadata::inline::InlinedItem;\n use middle::{astencode, def, infer, subst, traits};\n use middle::pat_util::def_to_path;\n use middle::ty::{self, Ty};\n@@ -86,7 +87,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n         }\n         let expr_id = match csearch::maybe_get_item_ast(tcx, enum_def,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n-            csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n+            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n@@ -161,11 +162,11 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n         let mut used_ref_id = false;\n         let expr_id = match csearch::maybe_get_item_ast(tcx, def_id,\n             Box::new(|a, b, c, d| astencode::decode_inlined_item(a, b, c, d))) {\n-            csearch::FoundAst::Found(&ast::IIItem(ref item)) => match item.node {\n+            csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => match item.node {\n                 ast::ItemConst(_, ref const_expr) => Some(const_expr.id),\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&ast::IITraitItem(trait_id, ref ti)) => match ti.node {\n+            csearch::FoundAst::Found(&InlinedItem::TraitItem(trait_id, ref ti)) => match ti.node {\n                 ast::ConstTraitItem(_, _) => {\n                     used_ref_id = true;\n                     match maybe_ref_id {\n@@ -184,7 +185,7 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n                 }\n                 _ => None\n             },\n-            csearch::FoundAst::Found(&ast::IIImplItem(_, ref ii)) => match ii.node {\n+            csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref ii)) => match ii.node {\n                 ast::ConstImplItem(_, ref expr) => Some(expr.id),\n                 _ => None\n             },\n@@ -217,8 +218,8 @@ fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n \n     let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n         box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n-        csearch::FoundAst::Found(&ast::IIItem(ref item)) => Some(item.id),\n-        csearch::FoundAst::Found(&ast::IIImplItem(_, ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&InlinedItem::ImplItem(_, ref item)) => Some(item.id),\n         _ => None\n     };\n     tcx.extern_const_fns.borrow_mut().insert(def_id,"}, {"sha": "dafc1e900f3f903bde60dbc3a107c1848848a672", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -17,8 +17,9 @@\n //! `middle/typeck/infer/region_inference.rs`\n \n use ast_map;\n-use session::Session;\n+use metadata::inline::InlinedItem;\n use middle::ty::{self, Ty};\n+use session::Session;\n use util::nodemap::{FnvHashMap, FnvHashSet, NodeMap};\n \n use std::cell::RefCell;\n@@ -1231,7 +1232,7 @@ pub fn resolve_crate(sess: &Session, krate: &ast::Crate) -> RegionMaps {\n \n pub fn resolve_inlined_item(sess: &Session,\n                             region_maps: &RegionMaps,\n-                            item: &ast::InlinedItem) {\n+                            item: &InlinedItem) {\n     let mut visitor = RegionResolutionVisitor {\n         sess: sess,\n         region_maps: region_maps,\n@@ -1241,5 +1242,5 @@ pub fn resolve_inlined_item(sess: &Session,\n             var_parent: InnermostDeclaringBlock::None\n         }\n     };\n-    visit::walk_inlined_item(&mut visitor, item);\n+    item.visit(&mut visitor);\n }"}, {"sha": "c6450d06eb66c92361f7ad021a621fbc05e8c4a4", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -10,6 +10,7 @@\n \n use llvm::{AvailableExternallyLinkage, InternalLinkage, SetLinkage};\n use metadata::csearch;\n+use metadata::inline::InlinedItem;\n use middle::astencode;\n use middle::subst::Substs;\n use trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n@@ -48,7 +49,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.external().borrow_mut().insert(fn_id, None);\n             return None;\n         }\n-        csearch::FoundAst::Found(&ast::IIItem(ref item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n \n@@ -91,12 +92,12 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n \n             item.id\n         }\n-        csearch::FoundAst::Found(&ast::IIForeign(ref item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::Foreign(ref item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, fn_id);\n             item.id\n         }\n-        csearch::FoundAst::FoundParent(parent_id, &ast::IIItem(ref item)) => {\n+        csearch::FoundAst::FoundParent(parent_id, &InlinedItem::Item(ref item)) => {\n             ccx.external().borrow_mut().insert(parent_id, Some(item.id));\n             ccx.external_srcs().borrow_mut().insert(item.id, parent_id);\n \n@@ -131,7 +132,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             ccx.sess().bug(\"maybe_get_item_ast returned a FoundParent \\\n                             with a non-item parent\");\n         }\n-        csearch::FoundAst::Found(&ast::IITraitItem(_, ref trait_item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::TraitItem(_, ref trait_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(trait_item.id));\n             ccx.external_srcs().borrow_mut().insert(trait_item.id, fn_id);\n \n@@ -150,7 +151,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             // don't.\n             trait_item.id\n         }\n-        csearch::FoundAst::Found(&ast::IIImplItem(impl_did, ref impl_item)) => {\n+        csearch::FoundAst::Found(&InlinedItem::ImplItem(impl_did, ref impl_item)) => {\n             ccx.external().borrow_mut().insert(fn_id, Some(impl_item.id));\n             ccx.external_srcs().borrow_mut().insert(impl_item.id, fn_id);\n "}, {"sha": "0bcd97cfe873feca537fb41e1ba27480ab8e449b", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -23,7 +23,6 @@ pub use self::FloatTy::*;\n pub use self::FunctionRetTy::*;\n pub use self::ForeignItem_::*;\n pub use self::ImplItem_::*;\n-pub use self::InlinedItem::*;\n pub use self::IntTy::*;\n pub use self::Item_::*;\n pub use self::KleeneOp::*;\n@@ -1925,17 +1924,6 @@ impl ForeignItem_ {\n     }\n }\n \n-/// The data we save and restore about an inlined item or method.  This is not\n-/// part of the AST that we parse from a file, but it becomes part of the tree\n-/// that we trans.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n-pub enum InlinedItem {\n-    IIItem(P<Item>),\n-    IITraitItem(DefId /* impl id */, P<TraitItem>),\n-    IIImplItem(DefId /* impl id */, P<ImplItem>),\n-    IIForeign(P<ForeignItem>),\n-}\n-\n /// A macro definition, in this crate or imported from another.\n ///\n /// Not parsed directly, but created on macro import or `macro_rules!` expansion."}, {"sha": "7aff92ecb709080b6f97d0933a5b6ee290e55b38", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 11, "deletions": 22, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -503,19 +503,18 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n     }\n }\n \n-pub fn visit_ids_for_inlined_item<O: IdVisitingOperation>(item: &InlinedItem,\n-                                                          operation: &mut O) {\n-    let mut id_visitor = IdVisitor {\n-        operation: operation,\n-        pass_through_items: true,\n-        visited_outermost: false,\n-    };\n-\n-    visit::walk_inlined_item(&mut id_visitor, item);\n+pub struct IdRangeComputingVisitor {\n+    result: IdRange,\n }\n \n-struct IdRangeComputingVisitor {\n-    result: IdRange,\n+impl IdRangeComputingVisitor {\n+    pub fn new() -> IdRangeComputingVisitor {\n+        IdRangeComputingVisitor { result: IdRange::max() }\n+    }\n+\n+    pub fn result(&self) -> IdRange {\n+        self.result\n+    }\n }\n \n impl IdVisitingOperation for IdRangeComputingVisitor {\n@@ -524,14 +523,6 @@ impl IdVisitingOperation for IdRangeComputingVisitor {\n     }\n }\n \n-pub fn compute_id_range_for_inlined_item(item: &InlinedItem) -> IdRange {\n-    let mut visitor = IdRangeComputingVisitor {\n-        result: IdRange::max()\n-    };\n-    visit_ids_for_inlined_item(item, &mut visitor);\n-    visitor.result\n-}\n-\n /// Computes the id range for a single fn body, ignoring nested items.\n pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n                                     decl: &FnDecl,\n@@ -540,9 +531,7 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n                                     id: NodeId)\n                                     -> IdRange\n {\n-    let mut visitor = IdRangeComputingVisitor {\n-        result: IdRange::max()\n-    };\n+    let mut visitor = IdRangeComputingVisitor::new();\n     let mut id_visitor = IdVisitor {\n         operation: &mut visitor,\n         pass_through_items: false,"}, {"sha": "259564337a21bbaf8170df641c8c05fa2d40b32d", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fc7efab3ab48e119e1a59281c26e666634ad1224/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=fc7efab3ab48e119e1a59281c26e666634ad1224", "patch": "@@ -142,17 +142,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_attribute(&mut self, _attr: &'v Attribute) {}\n }\n \n-pub fn walk_inlined_item<'v,V>(visitor: &mut V, item: &'v InlinedItem)\n-                         where V: Visitor<'v> {\n-    match *item {\n-        IIItem(ref i) => visitor.visit_item(&**i),\n-        IIForeign(ref i) => visitor.visit_foreign_item(&**i),\n-        IITraitItem(_, ref ti) => visitor.visit_trait_item(ti),\n-        IIImplItem(_, ref ii) => visitor.visit_impl_item(ii),\n-    }\n-}\n-\n-\n pub fn walk_crate<'v, V: Visitor<'v>>(visitor: &mut V, krate: &'v Crate) {\n     visitor.visit_mod(&krate.module, krate.span, CRATE_NODE_ID);\n     for attr in &krate.attrs {"}]}