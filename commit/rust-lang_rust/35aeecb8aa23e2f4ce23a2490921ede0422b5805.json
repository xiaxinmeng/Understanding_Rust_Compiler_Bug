{"sha": "35aeecb8aa23e2f4ce23a2490921ede0422b5805", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1YWVlY2I4YWEyM2UyZjRjZTIzYTI0OTA5MjFlZGUwNDIyYjU4MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T14:04:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-06-06T14:04:06Z"}, "message": "Auto merge of #51201 - estebank:dotdot, r=petrochenkov\n\nAccept `..` in incorrect position to avoid further errors\n\nWe currently give a specific message when encountering a `..` anywhere\nother than the end of a pattern. Modify the parser to accept it (while\nstill emitting the error) so that we don't also trigger \"missing fields\nin pattern\" errors afterwards.\n\nAdd suggestions to either remove trailing `,` or moving the `..` to the\nend.\n\nFollow up to #49268.", "tree": {"sha": "8f5daf652e67c71d067f6491538096cee85ab4c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f5daf652e67c71d067f6491538096cee85ab4c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35aeecb8aa23e2f4ce23a2490921ede0422b5805", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35aeecb8aa23e2f4ce23a2490921ede0422b5805", "html_url": "https://github.com/rust-lang/rust/commit/35aeecb8aa23e2f4ce23a2490921ede0422b5805", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35aeecb8aa23e2f4ce23a2490921ede0422b5805/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ac372568b0a63c0abb8953431fa6a392de040a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ac372568b0a63c0abb8953431fa6a392de040a3", "html_url": "https://github.com/rust-lang/rust/commit/9ac372568b0a63c0abb8953431fa6a392de040a3"}, {"sha": "d66d35bb9184b7f3a4e155386ca44410c0d09ff2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d66d35bb9184b7f3a4e155386ca44410c0d09ff2", "html_url": "https://github.com/rust-lang/rust/commit/d66d35bb9184b7f3a4e155386ca44410c0d09ff2"}], "stats": {"total": 247, "additions": 169, "deletions": 78}, "files": [{"sha": "ebb53335da301332ade72a2fcaff7df558100791", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 135, "deletions": 69, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=35aeecb8aa23e2f4ce23a2490921ede0422b5805", "patch": "@@ -3710,26 +3710,89 @@ impl<'a> Parser<'a> {\n         Ok((before, slice, after))\n     }\n \n+    fn parse_pat_field(\n+        &mut self,\n+        lo: Span,\n+        attrs: Vec<Attribute>\n+    ) -> PResult<'a, codemap::Spanned<ast::FieldPat>> {\n+        // Check if a colon exists one ahead. This means we're parsing a fieldname.\n+        let hi;\n+        let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n+            // Parsing a pattern of the form \"fieldname: pat\"\n+            let fieldname = self.parse_field_name()?;\n+            self.bump();\n+            let pat = self.parse_pat()?;\n+            hi = pat.span;\n+            (pat, fieldname, false)\n+        } else {\n+            // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n+            let is_box = self.eat_keyword(keywords::Box);\n+            let boxed_span = self.span;\n+            let is_ref = self.eat_keyword(keywords::Ref);\n+            let is_mut = self.eat_keyword(keywords::Mut);\n+            let fieldname = self.parse_ident()?;\n+            hi = self.prev_span;\n+\n+            let bind_type = match (is_ref, is_mut) {\n+                (true, true) => BindingMode::ByRef(Mutability::Mutable),\n+                (true, false) => BindingMode::ByRef(Mutability::Immutable),\n+                (false, true) => BindingMode::ByValue(Mutability::Mutable),\n+                (false, false) => BindingMode::ByValue(Mutability::Immutable),\n+            };\n+            let fieldpat = P(Pat {\n+                id: ast::DUMMY_NODE_ID,\n+                node: PatKind::Ident(bind_type, fieldname, None),\n+                span: boxed_span.to(hi),\n+            });\n+\n+            let subpat = if is_box {\n+                P(Pat {\n+                    id: ast::DUMMY_NODE_ID,\n+                    node: PatKind::Box(fieldpat),\n+                    span: lo.to(hi),\n+                })\n+            } else {\n+                fieldpat\n+            };\n+            (subpat, fieldname, true)\n+        };\n+\n+        Ok(codemap::Spanned {\n+            span: lo.to(hi),\n+            node: ast::FieldPat {\n+                ident: fieldname,\n+                pat: subpat,\n+                is_shorthand,\n+                attrs: attrs.into(),\n+           }\n+        })\n+    }\n+\n     /// Parse the fields of a struct-like pattern\n     fn parse_pat_fields(&mut self) -> PResult<'a, (Vec<codemap::Spanned<ast::FieldPat>>, bool)> {\n         let mut fields = Vec::new();\n         let mut etc = false;\n-        let mut first = true;\n-        while self.token != token::CloseDelim(token::Brace) {\n-            if first {\n-                first = false;\n-            } else {\n-                self.expect(&token::Comma)?;\n-                // accept trailing commas\n-                if self.check(&token::CloseDelim(token::Brace)) { break }\n-            }\n+        let mut ate_comma = true;\n+        let mut delayed_err: Option<DiagnosticBuilder<'a>> = None;\n+        let mut etc_span = None;\n \n+        while self.token != token::CloseDelim(token::Brace) {\n             let attrs = self.parse_outer_attributes()?;\n             let lo = self.span;\n-            let hi;\n+\n+            // check that a comma comes after every field\n+            if !ate_comma {\n+                let err = self.struct_span_err(self.prev_span, \"expected `,`\");\n+                return Err(err);\n+            }\n+            ate_comma = false;\n \n             if self.check(&token::DotDot) || self.token == token::DotDotDot {\n+                etc = true;\n+                let mut etc_sp = self.span;\n+\n                 if self.token == token::DotDotDot { // Issue #46718\n+                    // Accept `...` as if it were `..` to avoid further errors\n                     let mut err = self.struct_span_err(self.span,\n                                                        \"expected field pattern, found `...`\");\n                     err.span_suggestion_with_applicability(\n@@ -3740,73 +3803,76 @@ impl<'a> Parser<'a> {\n                     );\n                     err.emit();\n                 }\n+                self.bump();  // `..` || `...`:w\n \n-                self.bump();\n-                if self.token != token::CloseDelim(token::Brace) {\n-                    let token_str = self.this_token_to_string();\n-                    let mut err = self.fatal(&format!(\"expected `{}`, found `{}`\", \"}\", token_str));\n-                    if self.token == token::Comma { // Issue #49257\n-                        err.span_label(self.span,\n-                                       \"`..` must be in the last position, \\\n-                                        and cannot have a trailing comma\");\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    etc_span = Some(etc_sp);\n+                    break;\n+                }\n+                let token_str = self.this_token_to_string();\n+                let mut err = self.fatal(&format!(\"expected `}}`, found `{}`\", token_str));\n+\n+                err.span_label(self.span, \"expected `}`\");\n+                let mut comma_sp = None;\n+                if self.token == token::Comma { // Issue #49257\n+                    etc_sp = etc_sp.to(self.sess.codemap().span_until_non_whitespace(self.span));\n+                    err.span_label(etc_sp,\n+                                   \"`..` must be at the end and cannot have a trailing comma\");\n+                    comma_sp = Some(self.span);\n+                    self.bump();\n+                    ate_comma = true;\n+                }\n+\n+                etc_span = Some(etc_sp);\n+                if self.token == token::CloseDelim(token::Brace) {\n+                    // If the struct looks otherwise well formed, recover and continue.\n+                    if let Some(sp) = comma_sp {\n+                        err.span_suggestion_short(sp, \"remove this comma\", \"\".into());\n+                    }\n+                    err.emit();\n+                    break;\n+                } else if self.token.is_ident() && ate_comma {\n+                    // Accept fields coming after `..,`.\n+                    // This way we avoid \"pattern missing fields\" errors afterwards.\n+                    // We delay this error until the end in order to have a span for a\n+                    // suggested fix.\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                        return Err(err);\n                     } else {\n-                        err.span_label(self.span, \"expected `}`\");\n+                        delayed_err = Some(err);\n+                    }\n+                } else {\n+                    if let Some(mut err) = delayed_err {\n+                        err.emit();\n                     }\n                     return Err(err);\n                 }\n-                etc = true;\n-                break;\n             }\n \n-            // Check if a colon exists one ahead. This means we're parsing a fieldname.\n-            let (subpat, fieldname, is_shorthand) = if self.look_ahead(1, |t| t == &token::Colon) {\n-                // Parsing a pattern of the form \"fieldname: pat\"\n-                let fieldname = self.parse_field_name()?;\n-                self.bump();\n-                let pat = self.parse_pat()?;\n-                hi = pat.span;\n-                (pat, fieldname, false)\n-            } else {\n-                // Parsing a pattern of the form \"(box) (ref) (mut) fieldname\"\n-                let is_box = self.eat_keyword(keywords::Box);\n-                let boxed_span = self.span;\n-                let is_ref = self.eat_keyword(keywords::Ref);\n-                let is_mut = self.eat_keyword(keywords::Mut);\n-                let fieldname = self.parse_ident()?;\n-                hi = self.prev_span;\n-\n-                let bind_type = match (is_ref, is_mut) {\n-                    (true, true) => BindingMode::ByRef(Mutability::Mutable),\n-                    (true, false) => BindingMode::ByRef(Mutability::Immutable),\n-                    (false, true) => BindingMode::ByValue(Mutability::Mutable),\n-                    (false, false) => BindingMode::ByValue(Mutability::Immutable),\n-                };\n-                let fieldpat = P(Pat {\n-                    id: ast::DUMMY_NODE_ID,\n-                    node: PatKind::Ident(bind_type, fieldname, None),\n-                    span: boxed_span.to(hi),\n-                });\n-\n-                let subpat = if is_box {\n-                    P(Pat {\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: PatKind::Box(fieldpat),\n-                        span: lo.to(hi),\n-                    })\n-                } else {\n-                    fieldpat\n-                };\n-                (subpat, fieldname, true)\n-            };\n-\n-            fields.push(codemap::Spanned { span: lo.to(hi),\n-                                           node: ast::FieldPat {\n-                                               ident: fieldname,\n-                                               pat: subpat,\n-                                               is_shorthand,\n-                                               attrs: attrs.into(),\n-                                           }\n+            fields.push(match self.parse_pat_field(lo, attrs) {\n+                Ok(field) => field,\n+                Err(err) => {\n+                    if let Some(mut delayed_err) = delayed_err {\n+                        delayed_err.emit();\n+                    }\n+                    return Err(err);\n+                }\n             });\n+            ate_comma = self.eat(&token::Comma);\n+        }\n+\n+        if let Some(mut err) = delayed_err {\n+            if let Some(etc_span) = etc_span {\n+                err.multipart_suggestion(\n+                    \"move the `..` to the end of the field list\",\n+                    vec![\n+                        (etc_span, \"\".into()),\n+                        (self.span, format!(\"{}.. }}\", if ate_comma { \"\" } else { \", \" })),\n+                    ],\n+                );\n+            }\n+            err.emit();\n         }\n         return Ok((fields, etc));\n     }"}, {"sha": "e9e76af11a530a7c26056fe0205cbae229868aea", "filename": "src/test/parse-fail/bind-struct-early-modifiers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fparse-fail%2Fbind-struct-early-modifiers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fparse-fail%2Fbind-struct-early-modifiers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fbind-struct-early-modifiers.rs?ref=35aeecb8aa23e2f4ce23a2490921ede0422b5805", "patch": "@@ -13,7 +13,7 @@\n fn main() {\n     struct Foo { x: isize }\n     match (Foo { x: 10 }) {\n-        Foo { ref x: ref x } => {}, //~ ERROR expected `,`, found `:`\n+        Foo { ref x: ref x } => {}, //~ ERROR expected `,`\n         _ => {}\n     }\n }"}, {"sha": "f288a2b2174289b506c5f0171d7914334c0fcc51", "filename": "src/test/ui/issue-49257.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fui%2Fissue-49257.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fui%2Fissue-49257.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.rs?ref=35aeecb8aa23e2f4ce23a2490921ede0422b5805", "patch": "@@ -17,6 +17,8 @@ struct Point { x: u8, y: u8 }\n \n fn main() {\n     let p = Point { x: 0, y: 0 };\n+    let Point { .., y, } = p; //~ ERROR expected `}`, found `,`\n     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n-    //~| ERROR pattern does not mention fields `x`, `y`\n+    let Point { .., } = p; //~ ERROR expected `}`, found `,`\n+    let Point { .. } = p;\n }"}, {"sha": "40179832b49b271bee71a2151c2ec9ecc1a6775a", "filename": "src/test/ui/issue-49257.stderr", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fui%2Fissue-49257.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/35aeecb8aa23e2f4ce23a2490921ede0422b5805/src%2Ftest%2Fui%2Fissue-49257.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-49257.stderr?ref=35aeecb8aa23e2f4ce23a2490921ede0422b5805", "patch": "@@ -1,15 +1,38 @@\n error: expected `}`, found `,`\n   --> $DIR/issue-49257.rs:20:19\n    |\n-LL |     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n-   |                   ^ `..` must be in the last position, and cannot have a trailing comma\n+LL |     let Point { .., y, } = p; //~ ERROR expected `}`, found `,`\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 `..` must be at the end and cannot have a trailing comma\n+help: move the `..` to the end of the field list\n+   |\n+LL |     let Point {  y, .. } = p; //~ ERROR expected `}`, found `,`\n+   |                --   ^^^^\n \n-error[E0027]: pattern does not mention fields `x`, `y`\n-  --> $DIR/issue-49257.rs:20:9\n+error: expected `}`, found `,`\n+  --> $DIR/issue-49257.rs:21:19\n    |\n LL |     let Point { .., y } = p; //~ ERROR expected `}`, found `,`\n-   |         ^^^^^^^^^^^^^^^ missing fields `x`, `y`\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 `..` must be at the end and cannot have a trailing comma\n+help: move the `..` to the end of the field list\n+   |\n+LL |     let Point {  y , .. } = p; //~ ERROR expected `}`, found `,`\n+   |                --  ^^^^^^\n+\n+error: expected `}`, found `,`\n+  --> $DIR/issue-49257.rs:22:19\n+   |\n+LL |     let Point { .., } = p; //~ ERROR expected `}`, found `,`\n+   |                 --^\n+   |                 | |\n+   |                 | expected `}`\n+   |                 | help: remove this comma\n+   |                 `..` must be at the end and cannot have a trailing comma\n \n-error: aborting due to 2 previous errors\n+error: aborting due to 3 previous errors\n \n-For more information about this error, try `rustc --explain E0027`."}]}