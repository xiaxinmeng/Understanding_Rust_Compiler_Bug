{"sha": "6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NzRkYjQ4ODcyYzFiODRmZTNhYzNmZWI5NGI4ZDNlMGVlODJiMjQ=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-20T09:16:57Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-11-20T09:55:37Z"}, "message": "Reuse the `P` in `InvocationCollector::fold_{,opt_}expr`.\n\nThis requires adding a new method, `P::filter_map`.\n\nThis commit reduces instruction counts for various benchmarks by up to\n0.7%.", "tree": {"sha": "9dd07dcc5c5ef467670ded150e320106c7223727", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9dd07dcc5c5ef467670ded150e320106c7223727"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "html_url": "https://github.com/rust-lang/rust/commit/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9649c1f70fddd01843024932df97fb5a2b10bfe8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9649c1f70fddd01843024932df97fb5a2b10bfe8", "html_url": "https://github.com/rust-lang/rust/commit/9649c1f70fddd01843024932df97fb5a2b10bfe8"}], "stats": {"total": 112, "additions": 73, "deletions": 39}, "files": [{"sha": "68a96293891a0c0bbce93e0c9ad83d9c8e95f85b", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 48, "deletions": 36, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "patch": "@@ -1201,50 +1201,62 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n \n impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n     fn fold_expr(&mut self, expr: P<ast::Expr>) -> P<ast::Expr> {\n-        let mut expr = self.cfg.configure_expr(expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n-\n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n-\n-        if attr.is_some() {\n-            // collect the invoc regardless of whether or not attributes are permitted here\n-            // expansion will eat the attribute so it won't error later\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n-\n-            // AstFragmentKind::Expr requires the macro to emit an expression\n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::Expr, after_derive).make_expr();\n-        }\n+        let expr = self.cfg.configure_expr(expr);\n+        expr.map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n+\n+            // ignore derives so they remain unused\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+\n+            if attr.is_some() {\n+                // Collect the invoc regardless of whether or not attributes are permitted here\n+                // expansion will eat the attribute so it won't error later.\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+\n+                // AstFragmentKind::Expr requires the macro to emit an expression.\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::Expr, after_derive)\n+                    .make_expr()\n+                    .into_inner()\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::Expr).make_expr()\n-        } else {\n-            P(noop_fold_expr(expr, self))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::Expr)\n+                    .make_expr()\n+                    .into_inner()\n+            } else {\n+                noop_fold_expr(expr, self)\n+            }\n+        })\n     }\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n-        let mut expr = configure!(self, expr).into_inner();\n-        expr.node = self.cfg.configure_expr_kind(expr.node);\n+        let expr = configure!(self, expr);\n+        expr.filter_map(|mut expr| {\n+            expr.node = self.cfg.configure_expr_kind(expr.node);\n \n-        // ignore derives so they remain unused\n-        let (attr, expr, after_derive) = self.classify_nonitem(expr);\n+            // Ignore derives so they remain unused.\n+            let (attr, expr, after_derive) = self.classify_nonitem(expr);\n \n-        if attr.is_some() {\n-            attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n+            if attr.is_some() {\n+                attr.as_ref().map(|a| self.cfg.maybe_emit_expr_attr_err(a));\n \n-            return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n-                                     AstFragmentKind::OptExpr, after_derive).make_opt_expr();\n-        }\n+                return self.collect_attr(attr, vec![], Annotatable::Expr(P(expr)),\n+                                         AstFragmentKind::OptExpr, after_derive)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            }\n \n-        if let ast::ExprKind::Mac(mac) = expr.node {\n-            self.check_attributes(&expr.attrs);\n-            self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr).make_opt_expr()\n-        } else {\n-            Some(P(noop_fold_expr(expr, self)))\n-        }\n+            if let ast::ExprKind::Mac(mac) = expr.node {\n+                self.check_attributes(&expr.attrs);\n+                self.collect_bang(mac, expr.span, AstFragmentKind::OptExpr)\n+                    .make_opt_expr()\n+                    .map(|expr| expr.into_inner())\n+            } else {\n+                Some(noop_fold_expr(expr, self))\n+            }\n+        })\n     }\n \n     fn fold_pat(&mut self, pat: P<ast::Pat>) -> P<ast::Pat> {"}, {"sha": "9fbc64758da4dc773cfd5dbf57d2d52e1863c1d2", "filename": "src/libsyntax/ptr.rs", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24/src%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6674db48872c1b84fe3ac3feb94b8d3e0ee82b24/src%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fptr.rs?ref=6674db48872c1b84fe3ac3feb94b8d3e0ee82b24", "patch": "@@ -72,7 +72,7 @@ impl<T: 'static> P<T> {\n         *self.ptr\n     }\n \n-    /// Transform the inner value, consuming `self` and producing a new `P<T>`.\n+    /// Produce a new `P<T>` from `self` without reallocating.\n     pub fn map<F>(mut self, f: F) -> P<T> where\n         F: FnOnce(T) -> T,\n     {\n@@ -88,8 +88,30 @@ impl<T: 'static> P<T> {\n             ptr::write(p, f(ptr::read(p)));\n \n             // Recreate self from the raw pointer.\n-            P {\n-                ptr: Box::from_raw(p)\n+            P { ptr: Box::from_raw(p) }\n+        }\n+    }\n+\n+    /// Optionally produce a new `P<T>` from `self` without reallocating.\n+    pub fn filter_map<F>(mut self, f: F) -> Option<P<T>> where\n+        F: FnOnce(T) -> Option<T>,\n+    {\n+        let p: *mut T = &mut *self.ptr;\n+\n+        // Leak self in case of panic.\n+        // FIXME(eddyb) Use some sort of \"free guard\" that\n+        // only deallocates, without dropping the pointee,\n+        // in case the call the `f` below ends in a panic.\n+        mem::forget(self);\n+\n+        unsafe {\n+            if let Some(v) = f(ptr::read(p)) {\n+                ptr::write(p, v);\n+\n+                // Recreate self from the raw pointer.\n+                Some(P { ptr: Box::from_raw(p) })\n+            } else {\n+                None\n             }\n         }\n     }"}]}