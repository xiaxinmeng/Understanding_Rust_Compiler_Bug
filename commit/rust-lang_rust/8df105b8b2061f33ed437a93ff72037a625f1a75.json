{"sha": "8df105b8b2061f33ed437a93ff72037a625f1a75", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkZjEwNWI4YjIwNjFmMzNlZDQzN2E5M2ZmNzIwMzdhNjI1ZjFhNzU=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-07-23T14:55:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-23T14:55:22Z"}, "message": "Merge #5505\n\n5505: Cleanup CFG API r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "d7966981b7682eac07a24d57eb24b847323d0d25", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7966981b7682eac07a24d57eb24b847323d0d25"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8df105b8b2061f33ed437a93ff72037a625f1a75", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfGaTaCRBK7hj4Ov3rIwAAdHIIACm38Fqc/fxicld2wliuq4Wk\n34UDbagiYW+z0CNg2Zlk4JnvMjMQMn1xuxUTMpdKF9MCsWo9L9IeMvpua3Nqa1l8\n6jODkjHsq1wbp94DXUcbgYy6N2Ak6ml6kUdAuzCCde28dVTU/EVXOTkyA4szuq8m\nFO0LLH0N1tG8zwdEXQmDvUHTVgeyaTBpqnm0xtkEelVrY8Qi8o2xHTU/dnmOWyNP\nw/buTHnDvwF9AooreYnrQ0Ij9CgSV+6b1WTe4LYzxVnnxDm0lQLo1FBCHujpB6+r\n3szC6SH2vduzDOq+28mRy+vL70rAbrm7RsxQQ+XdZmdHx6Vp6D2Y4ZbV8w8YTxU=\n=sJNC\n-----END PGP SIGNATURE-----\n", "payload": "tree d7966981b7682eac07a24d57eb24b847323d0d25\nparent 7bada8a76dd6438cb6549d735d06e60fc50f6388\nparent 38e38d9b290ff90973c25a06962b81dbbb5d3d9e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1595516122 +0000\ncommitter GitHub <noreply@github.com> 1595516122 +0000\n\nMerge #5505\n\n5505: Cleanup CFG API r=matklad a=matklad\n\n\n\nbors r+\n\ud83e\udd16\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8df105b8b2061f33ed437a93ff72037a625f1a75", "html_url": "https://github.com/rust-lang/rust/commit/8df105b8b2061f33ed437a93ff72037a625f1a75", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8df105b8b2061f33ed437a93ff72037a625f1a75/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7bada8a76dd6438cb6549d735d06e60fc50f6388", "url": "https://api.github.com/repos/rust-lang/rust/commits/7bada8a76dd6438cb6549d735d06e60fc50f6388", "html_url": "https://github.com/rust-lang/rust/commit/7bada8a76dd6438cb6549d735d06e60fc50f6388"}, {"sha": "38e38d9b290ff90973c25a06962b81dbbb5d3d9e", "url": "https://api.github.com/repos/rust-lang/rust/commits/38e38d9b290ff90973c25a06962b81dbbb5d3d9e", "html_url": "https://github.com/rust-lang/rust/commit/38e38d9b290ff90973c25a06962b81dbbb5d3d9e"}], "stats": {"total": 111, "additions": 44, "deletions": 67}, "files": [{"sha": "f48928aee874e5946de7b29b6eca45e312a6670c", "filename": "crates/ra_cfg/src/cfg_expr.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Fcfg_expr.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -5,7 +5,6 @@\n use std::slice::Iter as SliceIter;\n \n use ra_syntax::SmolStr;\n-use tt::{Leaf, Subtree, TokenTree};\n \n #[derive(Debug, Clone, PartialEq, Eq)]\n pub enum CfgExpr {\n@@ -18,6 +17,9 @@ pub enum CfgExpr {\n }\n \n impl CfgExpr {\n+    pub fn parse(tt: &tt::Subtree) -> CfgExpr {\n+        next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n+    }\n     /// Fold the cfg by querying all basic `Atom` and `KeyValue` predicates.\n     pub fn fold(&self, query: &dyn Fn(&SmolStr, Option<&SmolStr>) -> bool) -> Option<bool> {\n         match self {\n@@ -35,22 +37,18 @@ impl CfgExpr {\n     }\n }\n \n-pub fn parse_cfg(tt: &Subtree) -> CfgExpr {\n-    next_cfg_expr(&mut tt.token_trees.iter()).unwrap_or(CfgExpr::Invalid)\n-}\n-\n fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     let name = match it.next() {\n         None => return None,\n-        Some(TokenTree::Leaf(Leaf::Ident(ident))) => ident.text.clone(),\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Ident(ident))) => ident.text.clone(),\n         Some(_) => return Some(CfgExpr::Invalid),\n     };\n \n     // Peek\n     let ret = match it.as_slice().first() {\n-        Some(TokenTree::Leaf(Leaf::Punct(punct))) if punct.char == '=' => {\n+        Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) if punct.char == '=' => {\n             match it.as_slice().get(1) {\n-                Some(TokenTree::Leaf(Leaf::Literal(literal))) => {\n+                Some(tt::TokenTree::Leaf(tt::Leaf::Literal(literal))) => {\n                     it.next();\n                     it.next();\n                     // FIXME: escape? raw string?\n@@ -61,7 +59,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n                 _ => return Some(CfgExpr::Invalid),\n             }\n         }\n-        Some(TokenTree::Subtree(subtree)) => {\n+        Some(tt::TokenTree::Subtree(subtree)) => {\n             it.next();\n             let mut sub_it = subtree.token_trees.iter();\n             let mut subs = std::iter::from_fn(|| next_cfg_expr(&mut sub_it)).collect();\n@@ -76,7 +74,7 @@ fn next_cfg_expr(it: &mut SliceIter<tt::TokenTree>) -> Option<CfgExpr> {\n     };\n \n     // Eat comma separator\n-    if let Some(TokenTree::Leaf(Leaf::Punct(punct))) = it.as_slice().first() {\n+    if let Some(tt::TokenTree::Leaf(tt::Leaf::Punct(punct))) = it.as_slice().first() {\n         if punct.char == ',' {\n             it.next();\n         }\n@@ -99,7 +97,8 @@ mod tests {\n \n     fn assert_parse_result(input: &str, expected: CfgExpr) {\n         let (tt, _) = get_token_tree_generated(input);\n-        assert_eq!(parse_cfg(&tt), expected);\n+        let cfg = CfgExpr::parse(&tt);\n+        assert_eq!(cfg, expected);\n     }\n \n     #[test]"}, {"sha": "cd5a0a7b64032653406adcfba3e77fa939d4c610", "filename": "crates/ra_cfg/src/lib.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_cfg%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_cfg%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cfg%2Fsrc%2Flib.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -5,7 +5,7 @@ mod cfg_expr;\n use ra_syntax::SmolStr;\n use rustc_hash::FxHashSet;\n \n-pub use cfg_expr::{parse_cfg, CfgExpr};\n+pub use cfg_expr::CfgExpr;\n \n /// Configuration options used for conditional compilition on items with `cfg` attributes.\n /// We have two kind of options in different namespaces: atomic options like `unix`, and\n@@ -31,18 +31,10 @@ impl CfgOptions {\n         })\n     }\n \n-    pub fn is_cfg_enabled(&self, attr: &tt::Subtree) -> Option<bool> {\n-        self.check(&parse_cfg(attr))\n-    }\n-\n     pub fn insert_atom(&mut self, key: SmolStr) {\n         self.atoms.insert(key);\n     }\n \n-    pub fn remove_atom(&mut self, name: &str) {\n-        self.atoms.remove(name);\n-    }\n-\n     pub fn insert_key_value(&mut self, key: SmolStr, value: SmolStr) {\n         self.key_values.insert((key, value));\n     }"}, {"sha": "70ccd430526471b99b1288c960ba30c50d20e100", "filename": "crates/ra_hir_def/src/attr.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_hir_def%2Fsrc%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fattr.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -5,7 +5,7 @@ use std::{ops, sync::Arc};\n use either::Either;\n use hir_expand::{hygiene::Hygiene, AstId, InFile};\n use mbe::ast_to_token_tree;\n-use ra_cfg::CfgOptions;\n+use ra_cfg::{CfgExpr, CfgOptions};\n use ra_syntax::{\n     ast::{self, AstNode, AttrsOwner},\n     SmolStr,\n@@ -125,9 +125,12 @@ impl Attrs {\n         AttrQuery { attrs: self, key }\n     }\n \n-    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+    pub fn cfg(&self) -> impl Iterator<Item = CfgExpr> + '_ {\n         // FIXME: handle cfg_attr :-)\n-        self.by_key(\"cfg\").tt_values().all(|tt| cfg_options.is_cfg_enabled(tt) != Some(false))\n+        self.by_key(\"cfg\").tt_values().map(CfgExpr::parse)\n+    }\n+    pub(crate) fn is_cfg_enabled(&self, cfg_options: &CfgOptions) -> bool {\n+        self.cfg().all(|cfg| cfg_options.check(&cfg) != Some(false))\n     }\n }\n "}, {"sha": "95a35a28db4cb30c78ef4341c22a2a508b719cc4", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -168,8 +168,7 @@ fn runnable_fn(\n     };\n \n     let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &fn_def));\n-    let cfg_exprs =\n-        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n+    let cfg_exprs = attrs.cfg().collect();\n \n     let nav = if let RunnableKind::DocTest { .. } = kind {\n         NavigationTarget::from_doc_commented(\n@@ -242,9 +241,7 @@ fn runnable_mod(\n         .join(\"::\");\n \n     let attrs = Attrs::from_attrs_owner(sema.db, InFile::new(HirFileId::from(file_id), &module));\n-    let cfg_exprs =\n-        attrs.by_key(\"cfg\").tt_values().map(|subtree| ra_cfg::parse_cfg(subtree)).collect();\n-\n+    let cfg_exprs = attrs.cfg().collect();\n     let nav = module_def.to_nav(sema.db);\n     Some(Runnable { nav, kind: RunnableKind::TestMod { path }, cfg_exprs })\n }"}, {"sha": "8053712ff8383a8ddaa5f94fb79ef9c74443b36b", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -15,6 +15,7 @@ use paths::{AbsPath, AbsPathBuf};\n use ra_cfg::CfgOptions;\n use ra_db::{CrateGraph, CrateId, CrateName, Edition, Env, FileId};\n use rustc_hash::{FxHashMap, FxHashSet};\n+use stdx::split_delim;\n \n pub use crate::{\n     cargo_workspace::{CargoConfig, CargoWorkspace, Package, Target, TargetKind},\n@@ -529,11 +530,10 @@ fn get_rustc_cfg_options(target: Option<&str>) -> CfgOptions {\n     match rustc_cfgs {\n         Ok(rustc_cfgs) => {\n             for line in rustc_cfgs.lines() {\n-                match line.find('=') {\n+                match split_delim(line, '=') {\n                     None => cfg_options.insert_atom(line.into()),\n-                    Some(pos) => {\n-                        let key = &line[..pos];\n-                        let value = line[pos + 1..].trim_matches('\"');\n+                    Some((key, value)) => {\n+                        let value = value.trim_matches('\"');\n                         cfg_options.insert_key_value(key.into(), value.into());\n                     }\n                 }"}, {"sha": "03c41263aa70faa81bbb828c208d0c28feef0d2e", "filename": "crates/rust-analyzer/src/cargo_target_spec.rs", "status": "modified", "additions": 21, "deletions": 35, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8df105b8b2061f33ed437a93ff72037a625f1a75/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcargo_target_spec.rs?ref=8df105b8b2061f33ed437a93ff72037a625f1a75", "patch": "@@ -177,49 +177,35 @@ fn required_features(cfg_expr: &CfgExpr, features: &mut Vec<String>) {\n mod tests {\n     use super::*;\n \n-    use mbe::{ast_to_token_tree, TokenMap};\n-    use ra_cfg::parse_cfg;\n+    use mbe::ast_to_token_tree;\n+    use ra_cfg::CfgExpr;\n     use ra_syntax::{\n         ast::{self, AstNode},\n         SmolStr,\n     };\n \n-    fn get_token_tree_generated(input: &str) -> (tt::Subtree, TokenMap) {\n-        let source_file = ast::SourceFile::parse(input).ok().unwrap();\n-        let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n-        ast_to_token_tree(&tt).unwrap()\n-    }\n-\n-    #[test]\n-    fn test_cfg_expr_minimal_features_needed() {\n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(feature = \"baz\")]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-        let mut min_features = vec![];\n-        required_features(&cfg_expr, &mut min_features);\n-\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n-\n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n-\n-        let mut min_features = vec![];\n-        required_features(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\"), SmolStr::new(\"foo\")]);\n+    fn check(cfg: &str, expected_features: &[&str]) {\n+        let cfg_expr = {\n+            let source_file = ast::SourceFile::parse(cfg).ok().unwrap();\n+            let tt = source_file.syntax().descendants().find_map(ast::TokenTree::cast).unwrap();\n+            let (tt, _) = ast_to_token_tree(&tt).unwrap();\n+            CfgExpr::parse(&tt)\n+        };\n \n-        let (subtree, _) =\n-            get_token_tree_generated(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n+        let mut features = vec![];\n+        required_features(&cfg_expr, &mut features);\n \n-        let mut min_features = vec![];\n-        required_features(&cfg_expr, &mut min_features);\n-        assert_eq!(min_features, vec![SmolStr::new(\"baz\")]);\n+        let expected_features =\n+            expected_features.iter().map(|&it| SmolStr::new(it)).collect::<Vec<_>>();\n \n-        let (subtree, _) = get_token_tree_generated(r#\"#![cfg(foo)]\"#);\n-        let cfg_expr = parse_cfg(&subtree);\n+        assert_eq!(features, expected_features);\n+    }\n \n-        let mut min_features = vec![];\n-        required_features(&cfg_expr, &mut min_features);\n-        assert!(min_features.is_empty());\n+    #[test]\n+    fn test_cfg_expr_minimal_features_needed() {\n+        check(r#\"#![cfg(feature = \"baz\")]\"#, &[\"baz\"]);\n+        check(r#\"#![cfg(all(feature = \"baz\", feature = \"foo\"))]\"#, &[\"baz\", \"foo\"]);\n+        check(r#\"#![cfg(any(feature = \"baz\", feature = \"foo\", unix))]\"#, &[\"baz\"]);\n+        check(r#\"#![cfg(foo)]\"#, &[]);\n     }\n }"}]}