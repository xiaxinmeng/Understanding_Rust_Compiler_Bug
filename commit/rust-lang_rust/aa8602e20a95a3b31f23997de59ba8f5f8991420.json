{"sha": "aa8602e20a95a3b31f23997de59ba8f5f8991420", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFhODYwMmUyMGE5NWEzYjMxZjIzOTk3ZGU1OWJhOGY1Zjg5OTE0MjA=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-03T00:03:36Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-07T18:11:14Z"}, "message": "Guide: closures", "tree": {"sha": "7bdc5614a9d95e6eb050700e4ba4693c1a768d7e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bdc5614a9d95e6eb050700e4ba4693c1a768d7e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aa8602e20a95a3b31f23997de59ba8f5f8991420", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aa8602e20a95a3b31f23997de59ba8f5f8991420", "html_url": "https://github.com/rust-lang/rust/commit/aa8602e20a95a3b31f23997de59ba8f5f8991420", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aa8602e20a95a3b31f23997de59ba8f5f8991420/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7cfc34a222c0280670690be0d618b67014cc28d", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7cfc34a222c0280670690be0d618b67014cc28d", "html_url": "https://github.com/rust-lang/rust/commit/d7cfc34a222c0280670690be0d618b67014cc28d"}], "stats": {"total": 204, "additions": 203, "deletions": 1}, "files": [{"sha": "71bd40ae789ee75defc3c512131391715c86ffa3", "filename": "src/doc/guide.md", "status": "modified", "additions": 203, "deletions": 1, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/aa8602e20a95a3b31f23997de59ba8f5f8991420/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/aa8602e20a95a3b31f23997de59ba8f5f8991420/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=aa8602e20a95a3b31f23997de59ba8f5f8991420", "patch": "@@ -3642,7 +3642,209 @@ guide](http://doc.rust-lang.org/guide-pointers.html#rc-and-arc).\n \n # Patterns\n \n-# Lambdas\n+# Closures\n+\n+So far, we've made lots of functions in Rust. But we've given them all names.\n+Rust also allows us to create anonymous functions too. Rust's anonymous\n+functions are called **closure**s. By themselves, closures aren't all that\n+interesting, but when you combine them with functions that take closures as\n+arguments, really powerful things are possible.\n+\n+Let's make a closure:\n+\n+```{rust}\n+let add_one = |x| { 1i + x };\n+\n+println!(\"The 5 plus 1 is {}.\", add_one(5i));\n+```\n+\n+We create a closure using the `|...| { ... }` syntax, and then we create a\n+binding so we can use it later. Note that we call the function using the\n+binding name and two parentheses, just like we would for a named function.\n+\n+Let's compare syntax. The two are pretty close:\n+\n+```{rust}\n+let add_one = |x: int| -> int { 1i + x };\n+fn  add_one   (x: int) -> int { 1i + x }\n+```\n+\n+As you may have noticed, closures infer their argument and return types, so you\n+don't need to declare one. This is different from named functions, which\n+default to returning unit (`()`).\n+\n+There's one big difference between a closure and named functions, and it's in\n+the name: a function \"closes over its environment.\" What's that mean? It means\n+this:\n+\n+```{rust}\n+fn main() {\n+    let x = 5i;\n+\n+    let printer = || { println!(\"x is: {}\", x); };\n+\n+    printer(); // prints \"x is: 5\"\n+}\n+```\n+\n+The `||` syntax means this is an anonymous closure that takes no arguments.\n+Without it, we'd just have a block of code in `{}`s.\n+\n+In other words, a closure has access to variables in the scope that it's\n+defined. The closure borrows any variables that it uses. This will error:\n+\n+```{rust,ignore}\n+fn main() {\n+    let mut x = 5i;\n+\n+    let printer = || { println!(\"x is: {}\", x); };\n+\n+    x = 6i; // error: cannot assign to `x` because it is borrowed\n+}\n+```\n+\n+## Procs\n+\n+Rust has a second type of closure, called a **proc**. Procs are created\n+with the `proc` keyword:\n+\n+```{rust}\n+let x = 5i;\n+\n+let p = proc() { x * x };\n+println!(\"{}\", p()); // prints 25\n+```\n+\n+Procs have a big difference from closures: they may only be called once. This\n+will error when we try to compile:\n+\n+```{rust,ignore}\n+let x = 5i;\n+\n+let p = proc() { x * x };\n+println!(\"{}\", p());\n+println!(\"{}\", p()); // error: use of moved value `p`\n+```\n+\n+This restriction is important. Procs are allowed to consume values that they\n+capture, and thus have to be restricted to being called once for soundness\n+reasons: any value consumed would be invalid on a second call.\n+\n+Procs are most useful with Rust's concurrency features, and so we'll just leave\n+it at this for now. We'll talk about them more in the \"Tasks\" section of the\n+guide.\n+\n+## Accepting closures as arguments\n+\n+Closures are most useful as an argument to another function. Here's an example:\n+\n+```{rust}\n+fn twice(x: int, f: |int| -> int) -> int {\n+    f(x) + f(x)\n+}\n+\n+fn main() {\n+    let square = |x: int| { x * x };\n+\n+    twice(5i, square); // evaluates to 50\n+}\n+```\n+\n+Let's break example down, starting with `main`:\n+\n+```{rust}\n+let square = |x: int| { x * x };\n+```\n+\n+We've seen this before. We make a closure that takes an integer, and returns\n+its square.\n+\n+```{rust,ignore}\n+twice(5i, square); // evaluates to 50\n+```\n+\n+This line is more interesting. Here, we call our function, `twice`, and we pass\n+it two arguments: an integer, `5`, and our closure, `square`. This is just like\n+passing any other two variable bindings to a function, but if you've never\n+worked with closures before, it can seem a little complex. Just think: \"I'm\n+passing two variables, one is an int, and one is a function.\"\n+\n+Next, let's look at how `twice` is defined:\n+\n+```{rust,ignore}\n+fn twice(x: int, f: |int| -> int) -> int {\n+```\n+\n+`twice` takes two arguments, `x` and `f`. That's why we called it with two\n+arguments. `x` is an `int`, we've done that a ton of times. `f` is a function,\n+though, and that function takes an `int` and returns an `int`. Notice\n+how the `|int| -> int` syntax looks a lot like our definition of `square`\n+above, if we added the return type in:\n+\n+```{rust}\n+let square = |x: int| -> int { x * x };\n+//           |int|    -> int\n+```\n+\n+This function takes an `int` and returns an `int`.\n+\n+This is the most complicated function signature we've seen yet! Give it a read\n+a few times until you can see how it works. It takes a teeny bit of practice, and\n+then it's easy.\n+\n+Finally, `twice` returns an `int` as well.\n+\n+Okay, let's look at the body of `twice`:\n+\n+```{rust}\n+fn twice(x: int, f: |int| -> int) -> int {\n+  f(x) + f(x)\n+}\n+```\n+\n+Since our closure is named `f`, we can call it just like we called our closures\n+before. And we pass in our `x` argument to each one. Hence 'twice.'\n+\n+If you do the math, `(5 * 5) + (5 * 5) == 50`, so that's the output we get.\n+\n+Play around with this concept until you're comfortable with it. Rust's standard\n+library uses lots of closures, where appropriate, so you'll be using\n+this technique a lot.\n+\n+If we didn't want to give `square` a name, we could also just define it inline.\n+This example is the same as the previous one:\n+\n+```{rust}\n+fn twice(x: int, f: |int| -> int) -> int {\n+    f(x) + f(x)\n+}\n+\n+fn main() {\n+    twice(5i, |x: int| { x * x }); // evaluates to 50\n+}\n+```\n+\n+A named function's name can be used wherever you'd use a closure. Another\n+way of writing the previous example:\n+\n+```{rust}\n+fn twice(x: int, f: |int| -> int) -> int {\n+    f(x) + f(x)\n+}\n+\n+fn square(x: int) -> int { x * x }\n+\n+fn main() {\n+    twice(5i, square); // evaluates to 50\n+}\n+```\n+\n+Doing this is not particularly common, but every once in a while, it's useful.\n+\n+That's all you need to get the hang of closures! Closures are a little bit\n+strange at first, but once you're used to using them, you'll miss them in any\n+language that doesn't have them. Passing functions to other functions is\n+incredibly powerful.  Next, let's look at one of those things: iterators.\n \n # iterators\n "}]}