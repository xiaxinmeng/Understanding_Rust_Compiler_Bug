{"sha": "fe73d382eeabaed0c37425388ab15ad690e5906f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlNzNkMzgyZWVhYmFlZDBjMzc0MjUzODhhYjE1YWQ2OTBlNTkwNmY=", "commit": {"author": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-02T15:34:50Z"}, "committer": {"name": "Kang Seonghoon", "email": "public+git@mearie.org", "date": "2015-03-03T02:55:37Z"}, "message": "metadata: Compact integer encoding.\n\nPreviously every auto-serialized tags are strongly typed. However\nthis is not strictly required, and instead it can be exploited\nto provide the optimal encoding for smaller integers. This commit\nrepurposes `EsI8`/`EsU8` through `EsI64`/`EsU64` tags to represent\n*any* integers with given ranges: It is now possible to encode\n`42u64` as two bytes `EsU8 0x2a`, for example.\n\nThere are some limitations:\n\n* It does not apply to non-auto-serialized tags for obvious reasons.\n  Fortunately, we have already eliminated the biggest source of\n  such tag in favor of auto-serialized tags: `tag_table_id`.\n* Bigger tags cannot be used to represent smaller types.\n* Signed tags and unsigned tags do not mix.", "tree": {"sha": "132367064f05aaa3e312ae1b0824c48e58120bf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/132367064f05aaa3e312ae1b0824c48e58120bf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe73d382eeabaed0c37425388ab15ad690e5906f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe73d382eeabaed0c37425388ab15ad690e5906f", "html_url": "https://github.com/rust-lang/rust/commit/fe73d382eeabaed0c37425388ab15ad690e5906f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe73d382eeabaed0c37425388ab15ad690e5906f/comments", "author": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lifthrasiir", "id": 323836, "node_id": "MDQ6VXNlcjMyMzgzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/323836?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lifthrasiir", "html_url": "https://github.com/lifthrasiir", "followers_url": "https://api.github.com/users/lifthrasiir/followers", "following_url": "https://api.github.com/users/lifthrasiir/following{/other_user}", "gists_url": "https://api.github.com/users/lifthrasiir/gists{/gist_id}", "starred_url": "https://api.github.com/users/lifthrasiir/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lifthrasiir/subscriptions", "organizations_url": "https://api.github.com/users/lifthrasiir/orgs", "repos_url": "https://api.github.com/users/lifthrasiir/repos", "events_url": "https://api.github.com/users/lifthrasiir/events{/privacy}", "received_events_url": "https://api.github.com/users/lifthrasiir/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a09a162dd04cf1ba092a837978cecea88bc529", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a09a162dd04cf1ba092a837978cecea88bc529", "html_url": "https://github.com/rust-lang/rust/commit/36a09a162dd04cf1ba092a837978cecea88bc529"}], "stats": {"total": 207, "additions": 114, "deletions": 93}, "files": [{"sha": "c13aeb4cd614bf6bfe2b4d97ce2bed2d6efeb299", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 114, "deletions": 93, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/fe73d382eeabaed0c37425388ab15ad690e5906f/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe73d382eeabaed0c37425388ab15ad690e5906f/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=fe73d382eeabaed0c37425388ab15ad690e5906f", "patch": "@@ -87,39 +87,37 @@ pub enum EbmlEncoderTag {\n     // tags 00..1f are reserved for auto-serialization.\n     // first NUM_IMPLICIT_TAGS tags are implicitly sized and lengths are not encoded.\n \n-    EsUint     = 0x00, // + 8 bytes\n-    EsU64      = 0x01, // + 8 bytes\n-    EsU32      = 0x02, // + 4 bytes\n-    EsU16      = 0x03, // + 2 bytes\n-    EsU8       = 0x04, // + 1 byte\n-    EsInt      = 0x05, // + 8 bytes\n-    EsI64      = 0x06, // + 8 bytes\n-    EsI32      = 0x07, // + 4 bytes\n-    EsI16      = 0x08, // + 2 bytes\n-    EsI8       = 0x09, // + 1 byte\n-    EsBool     = 0x0a, // + 1 byte\n-    EsChar     = 0x0b, // + 4 bytes\n-    EsF64      = 0x0c, // + 8 bytes\n-    EsF32      = 0x0d, // + 4 bytes\n-    EsSub8     = 0x0e, // + 1 byte\n-    EsSub32    = 0x0f, // + 4 bytes\n-\n-    EsStr      = 0x10,\n-    EsEnum     = 0x11, // encodes the variant id as the first EsSub*\n-    EsVec      = 0x12, // encodes the # of elements as the first EsSub*\n-    EsVecElt   = 0x13,\n-    EsMap      = 0x14, // encodes the # of pairs as the first EsSub*\n-    EsMapKey   = 0x15,\n-    EsMapVal   = 0x16,\n-    EsOpaque   = 0x17,\n+    EsU64      = 0x00, // + 8 bytes\n+    EsU32      = 0x01, // + 4 bytes\n+    EsU16      = 0x02, // + 2 bytes\n+    EsU8       = 0x03, // + 1 byte\n+    EsI64      = 0x04, // + 8 bytes\n+    EsI32      = 0x05, // + 4 bytes\n+    EsI16      = 0x06, // + 2 bytes\n+    EsI8       = 0x07, // + 1 byte\n+    EsBool     = 0x08, // + 1 byte\n+    EsChar     = 0x09, // + 4 bytes\n+    EsF64      = 0x0a, // + 8 bytes\n+    EsF32      = 0x0b, // + 4 bytes\n+    EsSub8     = 0x0c, // + 1 byte\n+    EsSub32    = 0x0d, // + 4 bytes\n+\n+    EsStr      = 0x0e,\n+    EsEnum     = 0x0f, // encodes the variant id as the first EsSub*\n+    EsVec      = 0x10, // encodes the # of elements as the first EsSub*\n+    EsVecElt   = 0x11,\n+    EsMap      = 0x12, // encodes the # of pairs as the first EsSub*\n+    EsMapKey   = 0x13,\n+    EsMapVal   = 0x14,\n+    EsOpaque   = 0x15,\n }\n \n const NUM_TAGS: uint = 0x1000;\n-const NUM_IMPLICIT_TAGS: uint = 0x10;\n+const NUM_IMPLICIT_TAGS: uint = 0x0e;\n \n static TAG_IMPLICIT_LEN: [i8; NUM_IMPLICIT_TAGS] = [\n-    8, 8, 4, 2, 1, // EsU*\n-    8, 8, 4, 2, 1, // ESI*\n+    8, 4, 2, 1, // EsU*\n+    8, 4, 2, 1, // ESI*\n     1, // EsBool\n     4, // EsChar\n     8, 4, // EsF*\n@@ -154,9 +152,9 @@ pub mod reader {\n     use serialize;\n \n     use super::{ ApplicationError, EsVec, EsMap, EsEnum, EsSub8, EsSub32,\n-        EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsInt, EsI64,\n+        EsVecElt, EsMapKey, EsU64, EsU32, EsU16, EsU8, EsI64,\n         EsI32, EsI16, EsI8, EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n-        EsUint, EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n+        EsOpaque, EbmlEncoderTag, Doc, TaggedDoc,\n         Error, IntTooBig, InvalidTag, Expected, NUM_IMPLICIT_TAGS, TAG_IMPLICIT_LEN };\n \n     pub type DecodeResult<T> = Result<T, Error>;\n@@ -420,37 +418,6 @@ pub mod reader {\n             Ok(r_doc)\n         }\n \n-        fn next_doc2(&mut self,\n-                     exp_tag1: EbmlEncoderTag,\n-                     exp_tag2: EbmlEncoderTag) -> DecodeResult<(bool, Doc<'doc>)> {\n-            assert!((exp_tag1 as uint) != (exp_tag2 as uint));\n-            debug!(\". next_doc2(exp_tag1={:?}, exp_tag2={:?})\", exp_tag1, exp_tag2);\n-            if self.pos >= self.parent.end {\n-                return Err(Expected(format!(\"no more documents in \\\n-                                             current node!\")));\n-            }\n-            let TaggedDoc { tag: r_tag, doc: r_doc } =\n-                try!(doc_at(self.parent.data, self.pos));\n-            debug!(\"self.parent={:?}-{:?} self.pos={:?} r_tag={:?} r_doc={:?}-{:?}\",\n-                   self.parent.start,\n-                   self.parent.end,\n-                   self.pos,\n-                   r_tag,\n-                   r_doc.start,\n-                   r_doc.end);\n-            if r_tag != (exp_tag1 as uint) && r_tag != (exp_tag2 as uint) {\n-                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n-                                             found tag {:?}\", exp_tag1, exp_tag2, r_tag)));\n-            }\n-            if r_doc.end > self.parent.end {\n-                return Err(Expected(format!(\"invalid EBML, child extends to \\\n-                                             {:#x}, parent to {:#x}\",\n-                                            r_doc.end, self.parent.end)));\n-            }\n-            self.pos = r_doc.end;\n-            Ok((r_tag == (exp_tag2 as uint), r_doc))\n-        }\n-\n         fn push_doc<T, F>(&mut self, exp_tag: EbmlEncoderTag, f: F) -> DecodeResult<T> where\n             F: FnOnce(&mut Decoder<'doc>) -> DecodeResult<T>,\n         {\n@@ -471,16 +438,59 @@ pub mod reader {\n                 return Ok(0);\n             }\n \n-            let (big, doc) = try!(self.next_doc2(EsSub8, EsSub32));\n-            let r = if big {\n-                doc_as_u32(doc) as uint\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                try!(doc_at(self.parent.data, self.pos));\n+            let r = if r_tag == (EsSub8 as uint) {\n+                doc_as_u8(r_doc) as uint\n+            } else if r_tag == (EsSub32 as uint) {\n+                doc_as_u32(r_doc) as uint\n             } else {\n-                doc_as_u8(doc) as uint\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} or {:?} but \\\n+                                             found tag {:?}\", EsSub8, EsSub32, r_tag)));\n             };\n+            if r_doc.end > self.parent.end {\n+                return Err(Expected(format!(\"invalid EBML, child extends to \\\n+                                             {:#x}, parent to {:#x}\",\n+                                            r_doc.end, self.parent.end)));\n+            }\n+            self.pos = r_doc.end;\n             debug!(\"_next_sub result={:?}\", r);\n             Ok(r)\n         }\n \n+        // variable-length unsigned integer with different tags\n+        fn _next_int(&mut self,\n+                     first_tag: EbmlEncoderTag,\n+                     last_tag: EbmlEncoderTag) -> DecodeResult<u64> {\n+            if self.pos >= self.parent.end {\n+                return Err(Expected(format!(\"no more documents in \\\n+                                             current node!\")));\n+            }\n+\n+            let TaggedDoc { tag: r_tag, doc: r_doc } =\n+                try!(doc_at(self.parent.data, self.pos));\n+            let r = if first_tag as uint <= r_tag && r_tag <= last_tag as uint {\n+                match last_tag as uint - r_tag {\n+                    0 => doc_as_u8(r_doc) as u64,\n+                    1 => doc_as_u16(r_doc) as u64,\n+                    2 => doc_as_u32(r_doc) as u64,\n+                    3 => doc_as_u64(r_doc) as u64,\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                return Err(Expected(format!(\"expected EBML doc with tag {:?} through {:?} but \\\n+                                             found tag {:?}\", first_tag, last_tag, r_tag)));\n+            };\n+            if r_doc.end > self.parent.end {\n+                return Err(Expected(format!(\"invalid EBML, child extends to \\\n+                                             {:#x}, parent to {:#x}\",\n+                                            r_doc.end, self.parent.end)));\n+            }\n+            self.pos = r_doc.end;\n+            debug!(\"_next_int({:?}, {:?}) result={:?}\", first_tag, last_tag, r);\n+            Ok(r)\n+        }\n+\n         pub fn read_opaque<R, F>(&mut self, op: F) -> DecodeResult<R> where\n             F: FnOnce(&mut Decoder, Doc) -> DecodeResult<R>,\n         {\n@@ -502,33 +512,25 @@ pub mod reader {\n         type Error = Error;\n         fn read_nil(&mut self) -> DecodeResult<()> { Ok(()) }\n \n-        fn read_u64(&mut self) -> DecodeResult<u64> { Ok(doc_as_u64(try!(self.next_doc(EsU64)))) }\n-        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(doc_as_u32(try!(self.next_doc(EsU32)))) }\n-        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(doc_as_u16(try!(self.next_doc(EsU16)))) }\n-        fn read_u8 (&mut self) -> DecodeResult<u8 > { Ok(doc_as_u8 (try!(self.next_doc(EsU8 )))) }\n+        fn read_u64(&mut self) -> DecodeResult<u64> { self._next_int(EsU64, EsU8) }\n+        fn read_u32(&mut self) -> DecodeResult<u32> { Ok(try!(self._next_int(EsU32, EsU8)) as u32) }\n+        fn read_u16(&mut self) -> DecodeResult<u16> { Ok(try!(self._next_int(EsU16, EsU8)) as u16) }\n+        fn read_u8(&mut self) -> DecodeResult<u8> { Ok(doc_as_u8(try!(self.next_doc(EsU8)))) }\n         fn read_uint(&mut self) -> DecodeResult<uint> {\n-            let v = doc_as_u64(try!(self.next_doc(EsUint)));\n+            let v = try!(self._next_int(EsU64, EsU8));\n             if v > (::std::usize::MAX as u64) {\n                 Err(IntTooBig(v as uint))\n             } else {\n                 Ok(v as uint)\n             }\n         }\n \n-        fn read_i64(&mut self) -> DecodeResult<i64> {\n-            Ok(doc_as_u64(try!(self.next_doc(EsI64))) as i64)\n-        }\n-        fn read_i32(&mut self) -> DecodeResult<i32> {\n-            Ok(doc_as_u32(try!(self.next_doc(EsI32))) as i32)\n-        }\n-        fn read_i16(&mut self) -> DecodeResult<i16> {\n-            Ok(doc_as_u16(try!(self.next_doc(EsI16))) as i16)\n-        }\n-        fn read_i8 (&mut self) -> DecodeResult<i8> {\n-            Ok(doc_as_u8(try!(self.next_doc(EsI8 ))) as i8)\n-        }\n+        fn read_i64(&mut self) -> DecodeResult<i64> { Ok(try!(self._next_int(EsI64, EsI8)) as i64) }\n+        fn read_i32(&mut self) -> DecodeResult<i32> { Ok(try!(self._next_int(EsI32, EsI8)) as i32) }\n+        fn read_i16(&mut self) -> DecodeResult<i16> { Ok(try!(self._next_int(EsI16, EsI8)) as i16) }\n+        fn read_i8(&mut self) -> DecodeResult<i8> { Ok(doc_as_u8(try!(self.next_doc(EsI8))) as i8) }\n         fn read_int(&mut self) -> DecodeResult<int> {\n-            let v = doc_as_u64(try!(self.next_doc(EsInt))) as i64;\n+            let v = try!(self._next_int(EsI64, EsI8)) as i64;\n             if v > (isize::MAX as i64) || v < (isize::MIN as i64) {\n                 debug!(\"FIXME \\\\#6122: Removing this makes this function miscompile\");\n                 Err(IntTooBig(v as uint))\n@@ -739,10 +741,11 @@ pub mod writer {\n     use std::old_io::{Writer, Seek};\n     use std::old_io;\n     use std::slice::bytes;\n+    use std::num::ToPrimitive;\n \n     use super::{ EsVec, EsMap, EsEnum, EsSub8, EsSub32, EsVecElt, EsMapKey,\n-        EsU64, EsU32, EsU16, EsU8, EsInt, EsI64, EsI32, EsI16, EsI8,\n-        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal, EsUint,\n+        EsU64, EsU32, EsU16, EsU8, EsI64, EsI32, EsI16, EsI8,\n+        EsBool, EsF64, EsF32, EsChar, EsStr, EsMapVal,\n         EsOpaque, NUM_IMPLICIT_TAGS, NUM_TAGS };\n     use super::io::SeekableMemWriter;\n \n@@ -1010,32 +1013,50 @@ pub mod writer {\n         }\n \n         fn emit_uint(&mut self, v: uint) -> EncodeResult {\n-            self.wr_tagged_raw_u64(EsUint as uint, v as u64)\n+            self.emit_u64(v as u64)\n         }\n         fn emit_u64(&mut self, v: u64) -> EncodeResult {\n-            self.wr_tagged_raw_u64(EsU64 as uint, v)\n+            match v.to_u32() {\n+                Some(v) => self.emit_u32(v),\n+                None => self.wr_tagged_raw_u64(EsU64 as uint, v)\n+            }\n         }\n         fn emit_u32(&mut self, v: u32) -> EncodeResult {\n-            self.wr_tagged_raw_u32(EsU32 as uint, v)\n+            match v.to_u16() {\n+                Some(v) => self.emit_u16(v),\n+                None => self.wr_tagged_raw_u32(EsU32 as uint, v)\n+            }\n         }\n         fn emit_u16(&mut self, v: u16) -> EncodeResult {\n-            self.wr_tagged_raw_u16(EsU16 as uint, v)\n+            match v.to_u8() {\n+                Some(v) => self.emit_u8(v),\n+                None => self.wr_tagged_raw_u16(EsU16 as uint, v)\n+            }\n         }\n         fn emit_u8(&mut self, v: u8) -> EncodeResult {\n             self.wr_tagged_raw_u8(EsU8 as uint, v)\n         }\n \n         fn emit_int(&mut self, v: int) -> EncodeResult {\n-            self.wr_tagged_raw_i64(EsInt as uint, v as i64)\n+            self.emit_i64(v as i64)\n         }\n         fn emit_i64(&mut self, v: i64) -> EncodeResult {\n-            self.wr_tagged_raw_i64(EsI64 as uint, v)\n+            match v.to_i32() {\n+                Some(v) => self.emit_i32(v),\n+                None => self.wr_tagged_raw_i64(EsI64 as uint, v)\n+            }\n         }\n         fn emit_i32(&mut self, v: i32) -> EncodeResult {\n-            self.wr_tagged_raw_i32(EsI32 as uint, v)\n+            match v.to_i16() {\n+                Some(v) => self.emit_i16(v),\n+                None => self.wr_tagged_raw_i32(EsI32 as uint, v)\n+            }\n         }\n         fn emit_i16(&mut self, v: i16) -> EncodeResult {\n-            self.wr_tagged_raw_i16(EsI16 as uint, v)\n+            match v.to_i8() {\n+                Some(v) => self.emit_i8(v),\n+                None => self.wr_tagged_raw_i16(EsI16 as uint, v)\n+            }\n         }\n         fn emit_i8(&mut self, v: i8) -> EncodeResult {\n             self.wr_tagged_raw_i8(EsI8 as uint, v)"}]}