{"sha": "c4c55285daf803750ec21ecdb77b6a04eb464566", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM0YzU1Mjg1ZGFmODAzNzUwZWMyMWVjZGI3N2I2YTA0ZWI0NjQ1NjY=", "commit": {"author": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-27T15:17:19Z"}, "committer": {"name": "topecongiro", "email": "seuchida@gmail.com", "date": "2017-08-27T15:17:19Z"}, "message": "Recover comments between 'trait' and the opening brace", "tree": {"sha": "ade26f798eda52f42f89777edd458e80fa9b3c91", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ade26f798eda52f42f89777edd458e80fa9b3c91"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c4c55285daf803750ec21ecdb77b6a04eb464566", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c4c55285daf803750ec21ecdb77b6a04eb464566", "html_url": "https://github.com/rust-lang/rust/commit/c4c55285daf803750ec21ecdb77b6a04eb464566", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c4c55285daf803750ec21ecdb77b6a04eb464566/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fa7c4d503015638a9696a54432beca7af6999f10", "url": "https://api.github.com/repos/rust-lang/rust/commits/fa7c4d503015638a9696a54432beca7af6999f10", "html_url": "https://github.com/rust-lang/rust/commit/fa7c4d503015638a9696a54432beca7af6999f10"}], "stats": {"total": 37, "additions": 28, "deletions": 9}, "files": [{"sha": "3c4aab69fcc61bbd23b1f2ace895cf43721b3491", "filename": "src/items.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/c4c55285daf803750ec21ecdb77b6a04eb464566/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c4c55285daf803750ec21ecdb77b6a04eb464566/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=c4c55285daf803750ec21ecdb77b6a04eb464566", "patch": "@@ -868,7 +868,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n     if let ast::ItemKind::Trait(unsafety, ref generics, ref type_param_bounds, ref trait_items) =\n         item.node\n     {\n-        let mut result = String::new();\n+        let mut result = String::with_capacity(128);\n         let header = format!(\n             \"{}{}trait {}\",\n             format_visibility(&item.vis),\n@@ -925,14 +925,7 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n                 .checked_sub(last_line_width(&result))\n         );\n         let pos_before_where = if type_param_bounds.is_empty() {\n-            if generics.where_clause.predicates.is_empty() {\n-                // We do not use this, so it does not matter\n-                item.span.lo\n-            } else {\n-                let snippet = context.snippet(item.span);\n-                let where_pos = snippet.find_uncommented(\"where\");\n-                item.span.lo + where_pos.map_or(BytePos(0), |p| BytePos(p as u32))\n-            }\n+            generics.where_clause.span.lo\n         } else {\n             type_param_bounds[type_param_bounds.len() - 1].span().hi\n         };\n@@ -961,7 +954,33 @@ pub fn format_trait(context: &RewriteContext, item: &ast::Item, offset: Indent)\n         }\n         result.push_str(&where_clause_str);\n \n+        if generics.where_clause.predicates.is_empty() {\n+            let item_snippet = context.snippet(item.span);\n+            if let Some(lo) = item_snippet.chars().position(|c| c == '/') {\n+                // 1 = `{`\n+                let comment_hi = body_lo - BytePos(1);\n+                let comment_lo = item.span.lo + BytePos(lo as u32);\n+                if comment_lo < comment_hi {\n+                    match recover_missing_comment_in_span(\n+                        mk_sp(comment_lo, comment_hi),\n+                        Shape::indented(offset, context.config),\n+                        context,\n+                        last_line_width(&result),\n+                    ) {\n+                        Some(ref missing_comment) if !missing_comment.is_empty() => {\n+                            result.push_str(missing_comment);\n+                        }\n+                        _ => (),\n+                    }\n+                }\n+            }\n+        }\n+\n         match context.config.item_brace_style() {\n+            _ if last_line_contains_single_line_comment(&result) => {\n+                result.push('\\n');\n+                result.push_str(&offset.to_string(context.config));\n+            }\n             BraceStyle::AlwaysNextLine => {\n                 result.push('\\n');\n                 result.push_str(&offset.to_string(context.config));"}]}