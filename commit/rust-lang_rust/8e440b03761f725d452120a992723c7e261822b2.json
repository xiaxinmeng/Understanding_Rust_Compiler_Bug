{"sha": "8e440b03761f725d452120a992723c7e261822b2", "node_id": "C_kwDOAAsO6NoAKDhlNDQwYjAzNzYxZjcyNWQ0NTIxMjBhOTkyNzIzYzdlMjYxODIyYjI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-05T21:46:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-12-05T21:46:58Z"}, "message": "Auto merge of #105328 - matthiaskrgr:rollup-qnfksmq, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #104912 (PartialEq: PERs are homogeneous)\n - #104952 (Streamline the user experience for `x.py setup`)\n - #104953 (Ensure required submodules at the same time as updating existing submodules)\n - #105180 (Use proper HirId for async track_caller attribute check)\n - #105222 (std update libc version and freebsd image build dependencies)\n - #105223 (suggest parenthesis around ExprWithBlock BinOp ExprWithBlock)\n - #105230 (Skip recording resolution for duplicated generic params.)\n - #105301 (update Miri)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "e85aa0fe3bd1dee381a66567ae7dbe9eaad23a51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e85aa0fe3bd1dee381a66567ae7dbe9eaad23a51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8e440b03761f725d452120a992723c7e261822b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8e440b03761f725d452120a992723c7e261822b2", "html_url": "https://github.com/rust-lang/rust/commit/8e440b03761f725d452120a992723c7e261822b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8e440b03761f725d452120a992723c7e261822b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d819583f0bf13b016b119c1c2c43e6d3979450", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d819583f0bf13b016b119c1c2c43e6d3979450", "html_url": "https://github.com/rust-lang/rust/commit/e1d819583f0bf13b016b119c1c2c43e6d3979450"}, {"sha": "612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/612e89a1fba354f36f4ae74096e3a69d1abfcbc8", "html_url": "https://github.com/rust-lang/rust/commit/612e89a1fba354f36f4ae74096e3a69d1abfcbc8"}], "stats": {"total": 531, "additions": 359, "deletions": 172}, "files": [{"sha": "970b1719aa1202c5e967bf891e326a79d59dad60", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -2085,9 +2085,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.135\"\n+version = \"0.2.138\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"68783febc7782c6c5cb401fbda4de5a9898be1762314da0bb2c10ced61f18b0c\"\n+checksum = \"db6d7e329c562c5dfab7a46a2afabc8b987ab9a4834c9d1ca04dc54c1546cef8\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "695ccec0b1cb15dd658d1b7aa75460c758b204ee", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -147,6 +147,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ),\n                 ExprKind::Async(capture_clause, closure_node_id, block) => self.make_async_expr(\n                     *capture_clause,\n+                    None,\n                     *closure_node_id,\n                     None,\n                     e.span,\n@@ -584,6 +585,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn make_async_expr(\n         &mut self,\n         capture_clause: CaptureBy,\n+        outer_hir_id: Option<hir::HirId>,\n         closure_node_id: NodeId,\n         ret_ty: Option<hir::FnRetTy<'hir>>,\n         span: Span,\n@@ -651,18 +653,20 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             hir::ExprKind::Closure(c)\n         };\n-        let parent_has_track_caller = self\n-            .attrs\n-            .values()\n-            .find(|attrs| attrs.into_iter().find(|attr| attr.has_name(sym::track_caller)).is_some())\n-            .is_some();\n-        let unstable_span =\n-            self.mark_span_with_reason(DesugaringKind::Async, span, self.allow_gen_future.clone());\n \n-        let hir_id = if parent_has_track_caller {\n-            let generator_hir_id = self.lower_node_id(closure_node_id);\n+        let track_caller = outer_hir_id\n+            .and_then(|id| self.attrs.get(&id.local_id))\n+            .map_or(false, |attrs| attrs.into_iter().any(|attr| attr.has_name(sym::track_caller)));\n+\n+        let hir_id = self.lower_node_id(closure_node_id);\n+        if track_caller {\n+            let unstable_span = self.mark_span_with_reason(\n+                DesugaringKind::Async,\n+                span,\n+                self.allow_gen_future.clone(),\n+            );\n             self.lower_attrs(\n-                generator_hir_id,\n+                hir_id,\n                 &[Attribute {\n                     kind: AttrKind::Normal(ptr::P(NormalAttr {\n                         item: AttrItem {\n@@ -677,10 +681,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     span: unstable_span,\n                 }],\n             );\n-            generator_hir_id\n-        } else {\n-            self.lower_node_id(closure_node_id)\n-        };\n+        }\n \n         let generator = hir::Expr { hir_id, kind: generator_kind, span: self.lower_span(span) };\n \n@@ -1019,6 +1020,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n                 let async_body = this.make_async_expr(\n                     capture_clause,\n+                    // FIXME(nbdd0121): This should also use a proper HIR id so `#[track_caller]`\n+                    // can be applied on async closures as well.\n+                    None,\n                     inner_closure_id,\n                     async_ret_ty,\n                     body.span,"}, {"sha": "9eda48e93294bb8f496cdf859e27b8d51051950c", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -253,8 +253,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     // only cares about the input argument patterns in the function\n                     // declaration (decl), not the return types.\n                     let asyncness = header.asyncness;\n-                    let body_id =\n-                        this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n+                    let body_id = this.lower_maybe_async_body(\n+                        span,\n+                        hir_id,\n+                        &decl,\n+                        asyncness,\n+                        body.as_deref(),\n+                    );\n \n                     let mut itctx = ImplTraitContext::Universal;\n                     let (generics, decl) = this.lower_generics(generics, id, &mut itctx, |this| {\n@@ -701,6 +706,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n     fn lower_trait_item(&mut self, i: &AssocItem) -> &'hir hir::TraitItem<'hir> {\n         let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n         let trait_item_def_id = hir_id.expect_owner();\n \n         let (generics, kind, has_default) = match &i.kind {\n@@ -724,7 +730,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Fn(box Fn { sig, generics, body: Some(body), .. }) => {\n                 let asyncness = sig.header.asyncness;\n                 let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, Some(&body));\n+                    self.lower_maybe_async_body(i.span, hir_id, &sig.decl, asyncness, Some(&body));\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n@@ -759,7 +765,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"macro item shouldn't exist at this point\"),\n         };\n \n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::TraitItem {\n             owner_id: trait_item_def_id,\n             ident: self.lower_ident(i.ident),\n@@ -798,6 +803,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         // Since `default impl` is not yet implemented, this is always true in impls.\n         let has_value = true;\n         let (defaultness, _) = self.lower_defaultness(i.kind.defaultness(), has_value);\n+        let hir_id = self.lower_node_id(i.id);\n+        self.lower_attrs(hir_id, &i.attrs);\n \n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n@@ -810,8 +817,13 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::Fn(box Fn { sig, generics, body, .. }) => {\n                 self.current_item = Some(i.span);\n                 let asyncness = sig.header.asyncness;\n-                let body_id =\n-                    self.lower_maybe_async_body(i.span, &sig.decl, asyncness, body.as_deref());\n+                let body_id = self.lower_maybe_async_body(\n+                    i.span,\n+                    hir_id,\n+                    &sig.decl,\n+                    asyncness,\n+                    body.as_deref(),\n+                );\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n@@ -844,8 +856,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             AssocItemKind::MacCall(..) => panic!(\"`TyMac` should have been expanded by now\"),\n         };\n \n-        let hir_id = self.lower_node_id(i.id);\n-        self.lower_attrs(hir_id, &i.attrs);\n         let item = hir::ImplItem {\n             owner_id: hir_id.expect_owner(),\n             ident: self.lower_ident(i.ident),\n@@ -978,6 +988,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     fn lower_maybe_async_body(\n         &mut self,\n         span: Span,\n+        fn_id: hir::HirId,\n         decl: &FnDecl,\n         asyncness: Async,\n         body: Option<&Block>,\n@@ -1128,6 +1139,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n \n             let async_expr = this.make_async_expr(\n                 CaptureBy::Value,\n+                Some(fn_id),\n                 closure_id,\n                 None,\n                 body.span,"}, {"sha": "4f92477b5d87ef221239c71054742025efb7bf32", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/suggestions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fsuggestions.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -32,11 +32,13 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     }\n \n     pub(in super::super) fn suggest_semicolon_at_end(&self, span: Span, err: &mut Diagnostic) {\n+        // This suggestion is incorrect for\n+        // fn foo() -> bool { match () { () => true } || match () { () => true } }\n         err.span_suggestion_short(\n             span.shrink_to_hi(),\n             \"consider using a semicolon here\",\n             \";\",\n-            Applicability::MachineApplicable,\n+            Applicability::MaybeIncorrect,\n         );\n     }\n "}, {"sha": "f6a6ed379a2b595de95d36534b1e234187e6a40d", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -390,20 +390,11 @@ impl<'a> Parser<'a> {\n             // want to keep their span info to improve diagnostics in these cases in a later stage.\n             (true, Some(AssocOp::Multiply)) | // `{ 42 } *foo = bar;` or `{ 42 } * 3`\n             (true, Some(AssocOp::Subtract)) | // `{ 42 } -5`\n-            (true, Some(AssocOp::Add)) // `{ 42 } + 42\n-            // If the next token is a keyword, then the tokens above *are* unambiguously incorrect:\n-            // `if x { a } else { b } && if y { c } else { d }`\n-            if !self.look_ahead(1, |t| t.is_used_keyword()) => {\n-                // These cases are ambiguous and can't be identified in the parser alone.\n-                let sp = self.sess.source_map().start_point(self.token.span);\n-                self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n-                false\n-            }\n-            (true, Some(AssocOp::LAnd)) |\n-            (true, Some(AssocOp::LOr)) |\n-            (true, Some(AssocOp::BitOr)) => {\n-                // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`. Separated from the\n-                // above due to #74233.\n+            (true, Some(AssocOp::Add)) | // `{ 42 } + 42` (unary plus)\n+            (true, Some(AssocOp::LAnd)) | // `{ 42 } &&x` (#61475) or `{ 42 } && if x { 1 } else { 0 }`\n+            (true, Some(AssocOp::LOr)) | // `{ 42 } || 42` (\"logical or\" or closure)\n+            (true, Some(AssocOp::BitOr)) // `{ 42 } | 42` or `{ 42 } |x| 42`\n+            => {\n                 // These cases are ambiguous and can't be identified in the parser alone.\n                 //\n                 // Bitwise AND is left out because guessing intent is hard. We can make"}, {"sha": "fc9c9334aea8cf1c5897a39a413ceeeb3ef4612c", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -2360,8 +2360,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     if let GenericParamKind::Lifetime = param.kind {\n                         // Record lifetime res, so lowering knows there is something fishy.\n                         self.record_lifetime_param(param.id, LifetimeRes::Error);\n-                        continue;\n                     }\n+                    continue;\n                 }\n                 Entry::Vacant(entry) => {\n                     entry.insert(param.ident.span);"}, {"sha": "949896e57480677b8192509782d00380558c9ed9", "filename": "library/core/src/cmp.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/library%2Fcore%2Fsrc%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/library%2Fcore%2Fsrc%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fcmp.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -29,15 +29,16 @@ use crate::marker::StructuralPartialEq;\n \n use self::Ordering::*;\n \n-/// Trait for equality comparisons which are [partial equivalence\n-/// relations](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n+/// Trait for equality comparisons.\n ///\n /// `x.eq(y)` can also be written `x == y`, and `x.ne(y)` can be written `x != y`.\n /// We use the easier-to-read infix notation in the remainder of this documentation.\n ///\n /// This trait allows for partial equality, for types that do not have a full\n /// equivalence relation. For example, in floating point numbers `NaN != NaN`,\n /// so floating point types implement `PartialEq` but not [`trait@Eq`].\n+/// Formally speaking, when `Rhs == Self`, this trait corresponds to a [partial equivalence\n+/// relation](https://en.wikipedia.org/wiki/Partial_equivalence_relation).\n ///\n /// Implementations must ensure that `eq` and `ne` are consistent with each other:\n ///"}, {"sha": "a7aefc26b97c7e0ac8008303e3e92b674a55e2cc", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -15,7 +15,7 @@ cfg-if = { version = \"1.0\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.135\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.138\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.82\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "37a8eb884efb02beba7ca57c462108a1bca96ae1", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -143,7 +143,7 @@ pub enum Subcommand {\n         args: Vec<String>,\n     },\n     Setup {\n-        profile: Profile,\n+        profile: Option<Profile>,\n     },\n }\n \n@@ -628,14 +628,15 @@ Arguments:\n                         |path| format!(\"{} is not a valid UTF8 string\", path.to_string_lossy())\n                     ));\n \n-                    profile_string.parse().unwrap_or_else(|err| {\n+                    let profile = profile_string.parse().unwrap_or_else(|err| {\n                         eprintln!(\"error: {}\", err);\n                         eprintln!(\"help: the available profiles are:\");\n                         eprint!(\"{}\", Profile::all_for_help(\"- \"));\n                         crate::detail_exit(1);\n-                    })\n+                    });\n+                    Some(profile)\n                 } else {\n-                    t!(crate::setup::interactive_path())\n+                    None\n                 };\n                 Subcommand::Setup { profile }\n             }"}, {"sha": "3ed53452309c76a54d0c11eec05cfb28b8d39447", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -542,16 +542,6 @@ impl Build {\n             metrics: metrics::BuildMetrics::init(),\n         };\n \n-        build.verbose(\"finding compilers\");\n-        cc_detect::find(&mut build);\n-        // When running `setup`, the profile is about to change, so any requirements we have now may\n-        // be different on the next invocation. Don't check for them until the next time x.py is\n-        // run. This is ok because `setup` never runs any build commands, so it won't fail if commands are missing.\n-        if !matches!(build.config.cmd, Subcommand::Setup { .. }) {\n-            build.verbose(\"running sanity check\");\n-            sanity::check(&mut build);\n-        }\n-\n         // If local-rust is the same major.minor as the current version, then force a\n         // local-rebuild\n         let local_version_verbose =\n@@ -567,16 +557,34 @@ impl Build {\n             build.local_rebuild = true;\n         }\n \n-        // Make sure we update these before gathering metadata so we don't get an error about missing\n-        // Cargo.toml files.\n-        let rust_submodules =\n-            [\"src/tools/rust-installer\", \"src/tools/cargo\", \"library/backtrace\", \"library/stdarch\"];\n-        for s in rust_submodules {\n-            build.update_submodule(Path::new(s));\n-        }\n+        build.verbose(\"finding compilers\");\n+        cc_detect::find(&mut build);\n+        // When running `setup`, the profile is about to change, so any requirements we have now may\n+        // be different on the next invocation. Don't check for them until the next time x.py is\n+        // run. This is ok because `setup` never runs any build commands, so it won't fail if commands are missing.\n+        //\n+        // Similarly, for `setup` we don't actually need submodules or cargo metadata.\n+        if !matches!(build.config.cmd, Subcommand::Setup { .. }) {\n+            build.verbose(\"running sanity check\");\n+            sanity::check(&mut build);\n+\n+            // Make sure we update these before gathering metadata so we don't get an error about missing\n+            // Cargo.toml files.\n+            let rust_submodules = [\n+                \"src/tools/rust-installer\",\n+                \"src/tools/cargo\",\n+                \"library/backtrace\",\n+                \"library/stdarch\",\n+            ];\n+            for s in rust_submodules {\n+                build.update_submodule(Path::new(s));\n+            }\n+            // Now, update all existing submodules.\n+            build.update_existing_submodules();\n \n-        build.verbose(\"learning about cargo\");\n-        metadata::build(&mut build);\n+            build.verbose(\"learning about cargo\");\n+            metadata::build(&mut build);\n+        }\n \n         build\n     }\n@@ -668,7 +676,7 @@ impl Build {\n \n     /// If any submodule has been initialized already, sync it unconditionally.\n     /// This avoids contributors checking in a submodule change by accident.\n-    pub fn maybe_update_submodules(&self) {\n+    pub fn update_existing_submodules(&self) {\n         // Avoid running git when there isn't a git checkout.\n         if !self.config.submodules(&self.rust_info()) {\n             return;\n@@ -697,8 +705,6 @@ impl Build {\n             job::setup(self);\n         }\n \n-        self.maybe_update_submodules();\n-\n         if let Subcommand::Format { check, paths } = &self.config.cmd {\n             return format::format(&builder::Builder::new(&self), *check, &paths);\n         }"}, {"sha": "c7f98a7d0d149ae28c21ad6dadb109034e9bbff6", "filename": "src/bootstrap/setup.rs", "status": "modified", "additions": 47, "deletions": 44, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Fsetup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Fbootstrap%2Fsetup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsetup.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -1,15 +1,13 @@\n+use crate::Config;\n use crate::{t, VERSION};\n-use crate::{Config, TargetSelection};\n use std::env::consts::EXE_SUFFIX;\n use std::fmt::Write as _;\n use std::fs::File;\n+use std::io::Write;\n use std::path::{Path, PathBuf, MAIN_SEPARATOR};\n use std::process::Command;\n use std::str::FromStr;\n-use std::{\n-    env, fmt, fs,\n-    io::{self, Write},\n-};\n+use std::{fmt, fs, io};\n \n #[derive(Clone, Copy, Debug, Eq, PartialEq)]\n pub enum Profile {\n@@ -81,38 +79,10 @@ impl fmt::Display for Profile {\n     }\n }\n \n-pub fn setup(config: &Config, profile: Profile) {\n-    let path = &config.config.clone().unwrap_or(PathBuf::from(\"config.toml\"));\n-\n-    if path.exists() {\n-        eprintln!(\n-            \"error: you asked `x.py` to setup a new config file, but one already exists at `{}`\",\n-            path.display()\n-        );\n-        eprintln!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, path.display());\n-        eprintln!(\n-            \"note: this will use the configuration in {}\",\n-            profile.include_path(&config.src).display()\n-        );\n-        crate::detail_exit(1);\n-    }\n-\n-    let settings = format!(\n-        \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n-    profile = \\\"{}\\\"\\n\\\n-    changelog-seen = {}\\n\",\n-        profile, VERSION\n-    );\n-    t!(fs::write(path, settings));\n-\n-    let include_path = profile.include_path(&config.src);\n-    println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n-\n-    let build = TargetSelection::from_user(&env!(\"BUILD_TRIPLE\"));\n+pub fn setup(config: &Config, profile: Option<Profile>) {\n+    let profile = profile.unwrap_or_else(|| t!(interactive_path()));\n     let stage_path =\n-        [\"build\", build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n-\n-    println!();\n+        [\"build\", config.build.rustc_target_arg(), \"stage1\"].join(&MAIN_SEPARATOR.to_string());\n \n     if !rustup_installed() && profile != Profile::User {\n         eprintln!(\"`rustup` is not installed; cannot link `stage1` toolchain\");\n@@ -134,8 +104,6 @@ pub fn setup(config: &Config, profile: Profile) {\n         Profile::User => &[\"dist\", \"build\"],\n     };\n \n-    println!();\n-\n     t!(install_git_hook_maybe(&config));\n \n     println!();\n@@ -150,6 +118,36 @@ pub fn setup(config: &Config, profile: Profile) {\n             \"For more suggestions, see https://rustc-dev-guide.rust-lang.org/building/suggested.html\"\n         );\n     }\n+\n+    let path = &config.config.clone().unwrap_or(PathBuf::from(\"config.toml\"));\n+    setup_config_toml(path, profile, config);\n+}\n+\n+fn setup_config_toml(path: &PathBuf, profile: Profile, config: &Config) {\n+    if path.exists() {\n+        eprintln!();\n+        eprintln!(\n+            \"error: you asked `x.py` to setup a new config file, but one already exists at `{}`\",\n+            path.display()\n+        );\n+        eprintln!(\"help: try adding `profile = \\\"{}\\\"` at the top of {}\", profile, path.display());\n+        eprintln!(\n+            \"note: this will use the configuration in {}\",\n+            profile.include_path(&config.src).display()\n+        );\n+        crate::detail_exit(1);\n+    }\n+\n+    let settings = format!(\n+        \"# Includes one of the default files in src/bootstrap/defaults\\n\\\n+    profile = \\\"{}\\\"\\n\\\n+    changelog-seen = {}\\n\",\n+        profile, VERSION\n+    );\n+    t!(fs::write(path, settings));\n+\n+    let include_path = profile.include_path(&config.src);\n+    println!(\"`x.py` will now use the configuration at {}\", include_path.display());\n }\n \n fn rustup_installed() -> bool {\n@@ -303,7 +301,18 @@ pub fn interactive_path() -> io::Result<Profile> {\n \n // install a git hook to automatically run tidy --bless, if they want\n fn install_git_hook_maybe(config: &Config) -> io::Result<()> {\n+    let git = t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n+        assert!(output.status.success(), \"failed to run `git`\");\n+        PathBuf::from(t!(String::from_utf8(output.stdout)).trim())\n+    }));\n+    let dst = git.join(\"hooks\").join(\"pre-push\");\n+    if dst.exists() {\n+        // The git hook has already been set up, or the user already has a custom hook.\n+        return Ok(());\n+    }\n+\n     let mut input = String::new();\n+    println!();\n     println!(\n         \"Rust's CI will automatically fail if it doesn't pass `tidy`, the internal tool for ensuring code quality.\n If you'd like, x.py can install a git hook for you that will automatically run `tidy --bless` before\n@@ -329,12 +338,6 @@ undesirable, simply delete the `pre-push` file from .git/hooks.\"\n \n     if should_install {\n         let src = config.src.join(\"src\").join(\"etc\").join(\"pre-push.sh\");\n-        let git =\n-            t!(config.git().args(&[\"rev-parse\", \"--git-common-dir\"]).output().map(|output| {\n-                assert!(output.status.success(), \"failed to run `git`\");\n-                PathBuf::from(t!(String::from_utf8(output.stdout)).trim())\n-            }));\n-        let dst = git.join(\"hooks\").join(\"pre-push\");\n         match fs::hard_link(src, &dst) {\n             Err(e) => eprintln!(\n                 \"error: could not create hook {}: do you already have the git hook installed?\\n{}\","}, {"sha": "17cd456b995a1fcccd4970777a693ef7cc81bfba", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -53,7 +53,7 @@ files_to_extract=(\n for lib in c cxxrt gcc_s m thr util; do\n   files_to_extract=(\"${files_to_extract[@]}\" \"./lib/lib${lib}.*\" \"./usr/lib/lib${lib}.*\")\n done\n-for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared procstat devstat kvm; do\n+for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared procstat devstat kvm memstat; do\n   files_to_extract=(\"${files_to_extract[@]}\" \"./usr/lib/lib${lib}.*\")\n done\n "}, {"sha": "4e52b8e250b9fa6b3e8989089052fc63e4616184", "filename": "src/test/ui/async-await/track-caller/issue-105134.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fissue-105134.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -0,0 +1,11 @@\n+// check-pass\n+// edition:2021\n+\n+#[track_caller]\n+fn f() {\n+    let _ = async {};\n+}\n+\n+fn main() {\n+    f();\n+}"}, {"sha": "5ebfeb3f36ac162f402dc3b780f6767c2911d35a", "filename": "src/test/ui/async-await/track-caller/panic-track-caller.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fasync-await%2Ftrack-caller%2Fpanic-track-caller.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -54,6 +54,19 @@ async fn foo_track_caller() {\n     bar_track_caller().await\n }\n \n+struct Foo;\n+\n+impl Foo {\n+    #[track_caller]\n+    async fn bar_assoc() {\n+        panic!();\n+    }\n+}\n+\n+async fn foo_assoc() {\n+    Foo::bar_assoc().await\n+}\n+\n fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n     let loc = Arc::new(Mutex::new(None));\n \n@@ -73,4 +86,5 @@ fn panicked_at(f: impl FnOnce() + panic::UnwindSafe) -> u32 {\n fn main() {\n     assert_eq!(panicked_at(|| block_on(foo())), 41);\n     assert_eq!(panicked_at(|| block_on(foo_track_caller())), 54);\n+    assert_eq!(panicked_at(|| block_on(foo_assoc())), 67);\n }"}, {"sha": "14a870dc39bf6a3ca2e1754aab5aaff9ee99dbe3", "filename": "src/test/ui/const-generics/defaults/self-referential.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -0,0 +1,4 @@\n+trait Foo<const M: u8, const M: u8 = M> {}\n+//~^ ERROR the name `M` is already used for a generic parameter in this item's generic parameters\n+impl Foo<2> for () {}\n+fn main() {}"}, {"sha": "170c1f7f7b2aedc91ec37c83159f13d281bfe3cf", "filename": "src/test/ui/const-generics/defaults/self-referential.stderr", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fdefaults%2Fself-referential.stderr?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -0,0 +1,11 @@\n+error[E0403]: the name `M` is already used for a generic parameter in this item's generic parameters\n+  --> $DIR/self-referential.rs:1:30\n+   |\n+LL | trait Foo<const M: u8, const M: u8 = M> {}\n+   |                 -            ^ already used\n+   |                 |\n+   |                 first use of `M`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0403`."}, {"sha": "628f898d5c8790a7232b6dc43a184386dbc4dad5", "filename": "src/test/ui/duplicate/duplicate-type-parameter.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fduplicate%2Fduplicate-type-parameter.stderr?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -55,10 +55,10 @@ LL | impl<T,T> Qux<T,T> for Option<T> {}\n    |      first use of `T`\n \n error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predicates\n-  --> $DIR/duplicate-type-parameter.rs:24:6\n+  --> $DIR/duplicate-type-parameter.rs:24:8\n    |\n LL | impl<T,T> Qux<T,T> for Option<T> {}\n-   |      ^ unconstrained type parameter\n+   |        ^ unconstrained type parameter\n \n error: aborting due to 8 previous errors\n "}, {"sha": "b06f62794c4e3a4632930ed8ed7d90866bac79bd", "filename": "src/test/ui/parser/expr-as-stmt.fixed", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.fixed?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -64,4 +64,16 @@ fn asteroids() -> impl FnOnce() -> bool {\n     { foo(); } || { true } //~ ERROR E0308\n }\n \n+// https://github.com/rust-lang/rust/issues/105179\n+fn r#match() -> i32 {\n+    (match () { () => 1 }) + match () { () => 1 } //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+// https://github.com/rust-lang/rust/issues/102171\n+fn r#unsafe() -> i32 {\n+    (unsafe { 1 }) + unsafe { 1 } //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "b39d2b88647c0a5d806ce3c4b227801dbe86ee7f", "filename": "src/test/ui/parser/expr-as-stmt.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -64,4 +64,16 @@ fn asteroids() -> impl FnOnce() -> bool {\n     { foo() } || { true } //~ ERROR E0308\n }\n \n+// https://github.com/rust-lang/rust/issues/105179\n+fn r#match() -> i32 {\n+    match () { () => 1 } + match () { () => 1 } //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n+// https://github.com/rust-lang/rust/issues/102171\n+fn r#unsafe() -> i32 {\n+    unsafe { 1 } + unsafe { 1 } //~ ERROR expected expression, found `+`\n+    //~^ ERROR mismatched types\n+}\n+\n fn main() {}"}, {"sha": "18c8b0b7c506bbb6b0fd069ecb07d2df43ac6e79", "filename": "src/test/ui/parser/expr-as-stmt.stderr", "status": "modified", "additions": 42, "deletions": 1, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fparser%2Fexpr-as-stmt.stderr?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -55,6 +55,28 @@ help: parentheses are required to parse this as an expression\n LL |     ({ true }) | { true }\n    |     +        +\n \n+error: expected expression, found `+`\n+  --> $DIR/expr-as-stmt.rs:69:26\n+   |\n+LL |     match () { () => 1 } + match () { () => 1 }\n+   |                          ^ expected expression\n+   |\n+help: parentheses are required to parse this as an expression\n+   |\n+LL |     (match () { () => 1 }) + match () { () => 1 }\n+   |     +                    +\n+\n+error: expected expression, found `+`\n+  --> $DIR/expr-as-stmt.rs:75:18\n+   |\n+LL |     unsafe { 1 } + unsafe { 1 }\n+   |                  ^ expected expression\n+   |\n+help: parentheses are required to parse this as an expression\n+   |\n+LL |     (unsafe { 1 }) + unsafe { 1 }\n+   |     +            +\n+\n error[E0308]: mismatched types\n   --> $DIR/expr-as-stmt.rs:64:7\n    |\n@@ -201,7 +223,26 @@ help: parentheses are required to parse this as an expression\n LL |     ({ true }) || { true }\n    |     +        +\n \n-error: aborting due to 18 previous errors\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:69:5\n+   |\n+LL |     match () { () => 1 } + match () { () => 1 }\n+   |     ^^^^^^^^^^^^^^^^^^^^- help: consider using a semicolon here\n+   |     |\n+   |     expected `()`, found integer\n+\n+error[E0308]: mismatched types\n+  --> $DIR/expr-as-stmt.rs:75:14\n+   |\n+LL |     unsafe { 1 } + unsafe { 1 }\n+   |              ^ expected `()`, found integer\n+   |\n+help: you might have meant to return this value\n+   |\n+LL |     unsafe { return 1; } + unsafe { 1 }\n+   |              ++++++  +\n+\n+error: aborting due to 22 previous errors\n \n Some errors have detailed explanations: E0308, E0600, E0614.\n For more information about an error, try `rustc --explain E0308`."}, {"sha": "8dd18ae98e6d62304a55fc6417ac2f021fbd4fef", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -1 +1 @@\n-cef44f53034eac46be3a0e3eec7b2b3d4ef5140b\n+203c8765ea33c65d888febe0e8219c4bb11b0d89"}, {"sha": "bcac873251f587509c766cd4197cb929feb950f2", "filename": "src/tools/miri/src/borrow_tracker/stacked_borrows/mod.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fstacked_borrows%2Fmod.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -45,7 +45,9 @@ pub struct Stacks {\n /// new pointer.\n #[derive(Copy, Clone, Hash, PartialEq, Eq)]\n enum RefKind {\n-    /// `&mut` and `Box`.\n+    /// `Box`.\n+    Box,\n+    /// `&mut`.\n     Unique { two_phase: bool },\n     /// `&` with or without interior mutability.\n     Shared,\n@@ -56,6 +58,7 @@ enum RefKind {\n impl fmt::Display for RefKind {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n+            RefKind::Box => write!(f, \"Box\"),\n             RefKind::Unique { two_phase: false } => write!(f, \"unique reference\"),\n             RefKind::Unique { two_phase: true } => write!(f, \"unique reference (two-phase)\"),\n             RefKind::Shared => write!(f, \"shared reference\"),\n@@ -654,15 +657,17 @@ trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'\n         let (perm, access) = match kind {\n             RefKind::Unique { two_phase } => {\n                 // Permission is Unique only if the type is `Unpin` and this is not twophase\n-                let perm = if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n-                    Permission::Unique\n+                if !two_phase && place.layout.ty.is_unpin(*this.tcx, this.param_env()) {\n+                    (Permission::Unique, Some(AccessKind::Write))\n                 } else {\n-                    Permission::SharedReadWrite\n-                };\n-                // We do an access for all full borrows, even if `!Unpin`.\n-                let access = if !two_phase { Some(AccessKind::Write) } else { None };\n-                (perm, access)\n+                    // FIXME: We emit `dereferenceable` for `!Unpin` mutable references, so we\n+                    // should do fake accesses here. But then we run into\n+                    // <https://github.com/rust-lang/unsafe-code-guidelines/issues/381>, so for now\n+                    // we don't do that.\n+                    (Permission::SharedReadWrite, None)\n+                }\n             }\n+            RefKind::Box => (Permission::Unique, Some(AccessKind::Write)),\n             RefKind::Raw { mutable: true } => {\n                 // Creating a raw ptr does not count as an access\n                 (Permission::SharedReadWrite, None)\n@@ -853,7 +858,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 // Boxes get a weak protectors, since they may be deallocated.\n                 self.retag_place(\n                     place,\n-                    RefKind::Unique { two_phase: false },\n+                    RefKind::Box,\n                     self.retag_cause,\n                     /*protector*/\n                     (self.kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),"}, {"sha": "d660921bfe6e2d4755bb18e3c79e8da602fd707a", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/e1d819583f0bf13b016b119c1c2c43e6d3979450/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1d819583f0bf13b016b119c1c2c43e6d3979450/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.rs?ref=e1d819583f0bf13b016b119c1c2c43e6d3979450", "patch": "@@ -1,17 +0,0 @@\n-//! Reborrowing a `&mut !Unpin` must still act like a (fake) read.\n-use std::marker::PhantomPinned;\n-\n-struct NotUnpin(i32, PhantomPinned);\n-\n-fn main() {\n-    unsafe {\n-        let mut x = NotUnpin(0, PhantomPinned);\n-        // Mutable borrow of `Unpin` field (with lifetime laundering)\n-        let fieldref = &mut *(&mut x.0 as *mut i32);\n-        // Mutable reborrow of the entire `x`, which is `!Unpin` but should\n-        // still count as a read since we would add `dereferenceable`.\n-        let _xref = &mut x;\n-        // That read should have invalidated `fieldref`.\n-        *fieldref = 0; //~ ERROR: /write access .* tag does not exist in the borrow stack/\n-    }\n-}"}, {"sha": "3ef8a8e0e9c6a8939975bc3829fbd16e50092577", "filename": "src/tools/miri/tests/fail/stacked_borrows/notunpin_dereferenceable_fakeread.stderr", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/e1d819583f0bf13b016b119c1c2c43e6d3979450/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e1d819583f0bf13b016b119c1c2c43e6d3979450/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fnotunpin_dereferenceable_fakeread.stderr?ref=e1d819583f0bf13b016b119c1c2c43e6d3979450", "patch": "@@ -1,28 +0,0 @@\n-error: Undefined Behavior: attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         *fieldref = 0;\n-   |         ^^^^^^^^^^^^^\n-   |         |\n-   |         attempting a write access using <TAG> at ALLOC[0x0], but that tag does not exist in the borrow stack for this location\n-   |         this error occurs as part of an access at ALLOC[0x0..0x4]\n-   |\n-   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Stacked Borrows rules it violated are still experimental\n-   = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n-help: <TAG> was created by a Unique retag at offsets [0x0..0x4]\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let fieldref = &mut *(&mut x.0 as *mut i32);\n-   |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-help: <TAG> was later invalidated at offsets [0x0..0x4] by a SharedReadWrite retag\n-  --> $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-   |\n-LL |         let _xref = &mut x;\n-   |                     ^^^^^^\n-   = note: BACKTRACE:\n-   = note: inside `main` at $DIR/notunpin_dereferenceable_fakeread.rs:LL:CC\n-\n-note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n-\n-error: aborting due to previous error\n-"}, {"sha": "3ba21552fd362da1ce18c442c6e4a559e095f17e", "filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs", "status": "added", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8e440b03761f725d452120a992723c7e261822b2/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Ffuture-self-referential.rs?ref=8e440b03761f725d452120a992723c7e261822b2", "patch": "@@ -0,0 +1,102 @@\n+#![feature(pin_macro)]\n+\n+use std::future::*;\n+use std::marker::PhantomPinned;\n+use std::pin::*;\n+use std::ptr;\n+use std::task::*;\n+\n+struct Delay {\n+    delay: usize,\n+}\n+\n+impl Delay {\n+    fn new(delay: usize) -> Self {\n+        Delay { delay }\n+    }\n+}\n+\n+impl Future for Delay {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, _cx: &mut Context<'_>) -> Poll<()> {\n+        if self.delay > 0 {\n+            self.delay -= 1;\n+            Poll::Pending\n+        } else {\n+            Poll::Ready(())\n+        }\n+    }\n+}\n+\n+async fn do_stuff() {\n+    (&mut Delay::new(1)).await;\n+}\n+\n+// Same thing implemented by hand\n+struct DoStuff {\n+    state: usize,\n+    delay: Delay,\n+    delay_ref: *mut Delay,\n+    _marker: PhantomPinned,\n+}\n+\n+impl DoStuff {\n+    fn new() -> Self {\n+        DoStuff {\n+            state: 0,\n+            delay: Delay::new(1),\n+            delay_ref: ptr::null_mut(),\n+            _marker: PhantomPinned,\n+        }\n+    }\n+}\n+\n+impl Future for DoStuff {\n+    type Output = ();\n+    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+        unsafe {\n+            let this = self.get_unchecked_mut();\n+            match this.state {\n+                0 => {\n+                    // Set up self-ref.\n+                    this.delay_ref = &mut this.delay;\n+                    // Move to next state.\n+                    this.state = 1;\n+                    Poll::Pending\n+                }\n+                1 => {\n+                    let delay = &mut *this.delay_ref;\n+                    Pin::new_unchecked(delay).poll(cx)\n+                }\n+                _ => unreachable!(),\n+            }\n+        }\n+    }\n+}\n+\n+fn run_fut<T>(fut: impl Future<Output = T>) -> T {\n+    use std::sync::Arc;\n+\n+    struct MyWaker;\n+    impl Wake for MyWaker {\n+        fn wake(self: Arc<Self>) {\n+            unimplemented!()\n+        }\n+    }\n+\n+    let waker = Waker::from(Arc::new(MyWaker));\n+    let mut context = Context::from_waker(&waker);\n+\n+    let mut pinned = pin!(fut);\n+    loop {\n+        match pinned.as_mut().poll(&mut context) {\n+            Poll::Pending => continue,\n+            Poll::Ready(v) => return v,\n+        }\n+    }\n+}\n+\n+fn main() {\n+    run_fut(do_stuff());\n+    run_fut(DoStuff::new());\n+}"}]}