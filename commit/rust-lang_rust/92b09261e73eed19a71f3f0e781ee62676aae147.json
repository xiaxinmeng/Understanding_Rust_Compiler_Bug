{"sha": "92b09261e73eed19a71f3f0e781ee62676aae147", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyYjA5MjYxZTczZWVkMTlhNzFmM2YwZTc4MWVlNjI2NzZhYWUxNDc=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-08T05:46:33Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2014-09-10T07:50:39Z"}, "message": "micro-optimize dynamic allocation alignment\n\nPreviously, some parts of this optimization were impossible because the\nalignment passed to the free function was not correct. That was fully\nfixed by #17012.\n\nCloses #17092", "tree": {"sha": "93d66241eb93b2c196e70e243163a8bed8eba6db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93d66241eb93b2c196e70e243163a8bed8eba6db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92b09261e73eed19a71f3f0e781ee62676aae147", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92b09261e73eed19a71f3f0e781ee62676aae147", "html_url": "https://github.com/rust-lang/rust/commit/92b09261e73eed19a71f3f0e781ee62676aae147", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92b09261e73eed19a71f3f0e781ee62676aae147/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b625d43f8fd2e9a800ca8a419f7d3f5f52604205", "url": "https://api.github.com/repos/rust-lang/rust/commits/b625d43f8fd2e9a800ca8a419f7d3f5f52604205", "html_url": "https://github.com/rust-lang/rust/commit/b625d43f8fd2e9a800ca8a419f7d3f5f52604205"}], "stats": {"total": 100, "additions": 65, "deletions": 35}, "files": [{"sha": "aae04170ccbfeea620502106b581c3c216cd132a", "filename": "src/jemalloc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fjemalloc?ref=92b09261e73eed19a71f3f0e781ee62676aae147", "patch": "@@ -1 +1 @@\n-Subproject commit 024c67ad651e1a3ca228936c4cfb13a37329baf2\n+Subproject commit aae04170ccbfeea620502106b581c3c216cd132a"}, {"sha": "204d8ee3a411334aab698f2aa61f63f0801f945a", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 64, "deletions": 34, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/92b09261e73eed19a71f3f0e781ee62676aae147/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92b09261e73eed19a71f3f0e781ee62676aae147/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=92b09261e73eed19a71f3f0e781ee62676aae147", "patch": "@@ -149,12 +149,24 @@ unsafe fn closure_exchange_malloc(drop_glue: fn(*mut u8), size: uint,\n     alloc as *mut u8\n }\n \n+// The minimum alignment guaranteed by the architecture. This value is used to\n+// add fast paths for low alignment values. In practice, the alignment is a\n+// constant at the call site and the branch will be optimized out.\n+#[cfg(target_arch = \"arm\")]\n+#[cfg(target_arch = \"mips\")]\n+#[cfg(target_arch = \"mipsel\")]\n+static MIN_ALIGN: uint = 8;\n+#[cfg(target_arch = \"x86\")]\n+#[cfg(target_arch = \"x86_64\")]\n+static MIN_ALIGN: uint = 16;\n+\n #[cfg(jemalloc)]\n mod imp {\n     use core::option::{None, Option};\n     use core::ptr::{RawPtr, mut_null, null};\n     use core::num::Int;\n     use libc::{c_char, c_int, c_void, size_t};\n+    use super::MIN_ALIGN;\n \n     #[link(name = \"jemalloc\", kind = \"static\")]\n     #[cfg(not(test))]\n@@ -183,9 +195,15 @@ mod imp {\n     #[inline(always)]\n     fn mallocx_align(a: uint) -> c_int { a.trailing_zeros() as c_int }\n \n+    #[inline(always)]\n+    fn align_to_flags(align: uint) -> c_int {\n+        if align <= MIN_ALIGN { 0 } else { mallocx_align(align) }\n+    }\n+\n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        let ptr = je_mallocx(size as size_t, mallocx_align(align)) as *mut u8;\n+        let flags = align_to_flags(align);\n+        let ptr = je_mallocx(size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             ::oom()\n         }\n@@ -195,8 +213,8 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              _old_size: uint) -> *mut u8 {\n-        let ptr = je_rallocx(ptr as *mut c_void, size as size_t,\n-                             mallocx_align(align)) as *mut u8;\n+        let flags = align_to_flags(align);\n+        let ptr = je_rallocx(ptr as *mut c_void, size as size_t, flags) as *mut u8;\n         if ptr.is_null() {\n             ::oom()\n         }\n@@ -206,18 +224,20 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate_inplace(ptr: *mut u8, size: uint, align: uint,\n                                      _old_size: uint) -> bool {\n-        je_xallocx(ptr as *mut c_void, size as size_t, 0,\n-                   mallocx_align(align)) == size as size_t\n+        let flags = align_to_flags(align);\n+        je_xallocx(ptr as *mut c_void, size as size_t, 0, flags) == size as size_t\n     }\n \n     #[inline]\n     pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n-        je_dallocx(ptr as *mut c_void, mallocx_align(align))\n+        let flags = align_to_flags(align);\n+        je_dallocx(ptr as *mut c_void, flags)\n     }\n \n     #[inline]\n     pub fn usable_size(size: uint, align: uint) -> uint {\n-        unsafe { je_nallocx(size as size_t, mallocx_align(align)) as uint }\n+        let flags = align_to_flags(align);\n+        unsafe { je_nallocx(size as size_t, flags) as uint }\n     }\n \n     pub fn stats_print() {\n@@ -234,6 +254,7 @@ mod imp {\n     use core::ptr;\n     use libc;\n     use libc_heap;\n+    use super::MIN_ALIGN;\n \n     extern {\n         fn posix_memalign(memptr: *mut *mut libc::c_void,\n@@ -243,16 +264,7 @@ mod imp {\n \n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        // The posix_memalign manpage states\n-        //\n-        //      alignment [...] must be a power of and a multiple of\n-        //      sizeof(void *)\n-        //\n-        // The `align` parameter to this function is the *minimum* alignment for\n-        // a block of memory, so we special case everything under `*uint` to\n-        // just pass it to malloc, which is guaranteed to align to at least the\n-        // size of `*uint`.\n-        if align < mem::size_of::<uint>() {\n+        if align <= MIN_ALIGN {\n             libc_heap::malloc_raw(size)\n         } else {\n             let mut out = 0 as *mut libc::c_void;\n@@ -269,10 +281,14 @@ mod imp {\n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              old_size: uint) -> *mut u8 {\n-        let new_ptr = allocate(size, align);\n-        ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n-        deallocate(ptr, old_size, align);\n-        return new_ptr;\n+        if align <= MIN_ALIGN {\n+            libc_heap::realloc_raw(ptr, size)\n+        } else {\n+            let new_ptr = allocate(size, align);\n+            ptr::copy_memory(new_ptr, ptr as *const u8, cmp::min(size, old_size));\n+            deallocate(ptr, old_size, align);\n+            new_ptr\n+        }\n     }\n \n     #[inline]\n@@ -291,14 +307,16 @@ mod imp {\n         size\n     }\n \n-    pub fn stats_print() {\n-    }\n+    pub fn stats_print() {}\n }\n \n #[cfg(not(jemalloc), windows)]\n mod imp {\n     use libc::{c_void, size_t};\n+    use libc;\n+    use libc_heap;\n     use core::ptr::RawPtr;\n+    use super::MIN_ALIGN;\n \n     extern {\n         fn _aligned_malloc(size: size_t, align: size_t) -> *mut c_void;\n@@ -309,22 +327,30 @@ mod imp {\n \n     #[inline]\n     pub unsafe fn allocate(size: uint, align: uint) -> *mut u8 {\n-        let ptr = _aligned_malloc(size as size_t, align as size_t);\n-        if ptr.is_null() {\n-            ::oom();\n+        if align <= MIN_ALIGN {\n+            libc_heap::malloc_raw(size)\n+        } else {\n+            let ptr = _aligned_malloc(size as size_t, align as size_t);\n+            if ptr.is_null() {\n+                ::oom();\n+            }\n+            ptr as *mut u8\n         }\n-        ptr as *mut u8\n     }\n \n     #[inline]\n     pub unsafe fn reallocate(ptr: *mut u8, size: uint, align: uint,\n                              _old_size: uint) -> *mut u8 {\n-        let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n-                                   align as size_t);\n-        if ptr.is_null() {\n-            ::oom();\n+        if align <= MIN_ALIGN {\n+            libc_heap::realloc_raw(ptr, size)\n+        } else {\n+            let ptr = _aligned_realloc(ptr as *mut c_void, size as size_t,\n+                                       align as size_t);\n+            if ptr.is_null() {\n+                ::oom();\n+            }\n+            ptr as *mut u8\n         }\n-        ptr as *mut u8\n     }\n \n     #[inline]\n@@ -334,8 +360,12 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, _align: uint) {\n-        _aligned_free(ptr as *mut c_void)\n+    pub unsafe fn deallocate(ptr: *mut u8, _size: uint, align: uint) {\n+        if align <= MIN_ALIGN {\n+            libc::free(ptr as *mut libc::c_void)\n+        } else {\n+            _aligned_free(ptr as *mut c_void)\n+        }\n     }\n \n     #[inline]"}]}