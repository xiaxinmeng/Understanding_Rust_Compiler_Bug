{"sha": "1962a70e71e82516a4436e00933654a990203c9e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE5NjJhNzBlNzFlODI1MTZhNDQzNmUwMDkzMzY1NGE5OTAyMDNjOWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T12:24:48Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-05-23T12:24:48Z"}, "message": "Auto merge of #50866 - michaelwoerister:relocations-in-vec, r=oli-obk\n\nUse different datastructure for MIRI relocations\n\nThis PR makes relocations in MIRI used a sorted vector instead of a `BTreeMap` which should make a few common operations more efficient. Let's see if that's true.\n\nr? @oli-obk", "tree": {"sha": "16e65602d2f975fc8348ba72ba21ce322f3f05f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/16e65602d2f975fc8348ba72ba21ce322f3f05f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1962a70e71e82516a4436e00933654a990203c9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1962a70e71e82516a4436e00933654a990203c9e", "html_url": "https://github.com/rust-lang/rust/commit/1962a70e71e82516a4436e00933654a990203c9e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1962a70e71e82516a4436e00933654a990203c9e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8", "html_url": "https://github.com/rust-lang/rust/commit/c3733a770edb1eb0f8b8943e7a0a962f4e1e91a8"}, {"sha": "95fac99a2036a0120be26262110a1e473a85950d", "url": "https://api.github.com/repos/rust-lang/rust/commits/95fac99a2036a0120be26262110a1e473a85950d", "html_url": "https://github.com/rust-lang/rust/commit/95fac99a2036a0120be26262110a1e473a85950d"}], "stats": {"total": 571, "additions": 545, "deletions": 26}, "files": [{"sha": "9827ee51ba29d739f0bb49392268b6dbb8930483", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=1962a70e71e82516a4436e00933654a990203c9e", "patch": "@@ -12,7 +12,6 @@ pub use self::error::{EvalError, EvalResult, EvalErrorKind, AssertMessage};\n \n pub use self::value::{PrimVal, PrimValKind, Value, Pointer, ConstValue};\n \n-use std::collections::BTreeMap;\n use std::fmt;\n use mir;\n use hir::def_id::DefId;\n@@ -21,9 +20,11 @@ use ty::layout::{self, Align, HasDataLayout, Size};\n use middle::region;\n use std::iter;\n use std::io;\n+use std::ops::{Deref, DerefMut};\n use std::hash::Hash;\n use syntax::ast::Mutability;\n use rustc_serialize::{Encoder, Decoder, Decodable, Encodable};\n+use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::fx::FxHashMap;\n use byteorder::{WriteBytesExt, ReadBytesExt, LittleEndian, BigEndian};\n \n@@ -341,7 +342,7 @@ pub struct Allocation {\n     pub bytes: Vec<u8>,\n     /// Maps from byte addresses to allocations.\n     /// Only the first byte of a pointer is inserted into the map.\n-    pub relocations: BTreeMap<Size, AllocId>,\n+    pub relocations: Relocations,\n     /// Denotes undefined memory. Reading from undefined memory is forbidden in miri\n     pub undef_mask: UndefMask,\n     /// The alignment of the allocation to detect unaligned reads.\n@@ -358,7 +359,7 @@ impl Allocation {\n         undef_mask.grow(Size::from_bytes(slice.len() as u64), true);\n         Self {\n             bytes: slice.to_owned(),\n-            relocations: BTreeMap::new(),\n+            relocations: Relocations::new(),\n             undef_mask,\n             align,\n             runtime_mutability: Mutability::Immutable,\n@@ -373,7 +374,7 @@ impl Allocation {\n         assert_eq!(size.bytes() as usize as u64, size.bytes());\n         Allocation {\n             bytes: vec![0; size.bytes() as usize],\n-            relocations: BTreeMap::new(),\n+            relocations: Relocations::new(),\n             undef_mask: UndefMask::new(size),\n             align,\n             runtime_mutability: Mutability::Immutable,\n@@ -383,6 +384,35 @@ impl Allocation {\n \n impl<'tcx> ::serialize::UseSpecializedDecodable for &'tcx Allocation {}\n \n+#[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]\n+pub struct Relocations(SortedMap<Size, AllocId>);\n+\n+impl Relocations {\n+    pub fn new() -> Relocations {\n+        Relocations(SortedMap::new())\n+    }\n+\n+    // The caller must guarantee that the given relocations are already sorted\n+    // by address and contain no duplicates.\n+    pub fn from_presorted(r: Vec<(Size, AllocId)>) -> Relocations {\n+        Relocations(SortedMap::from_presorted_elements(r))\n+    }\n+}\n+\n+impl Deref for Relocations {\n+    type Target = SortedMap<Size, AllocId>;\n+\n+    fn deref(&self) -> &Self::Target {\n+        &self.0\n+    }\n+}\n+\n+impl DerefMut for Relocations {\n+    fn deref_mut(&mut self) -> &mut Self::Target {\n+        &mut self.0\n+    }\n+}\n+\n ////////////////////////////////////////////////////////////////////////////////\n // Methods to access integers in the target endianness\n ////////////////////////////////////////////////////////////////////////////////"}, {"sha": "a4fe85135de7a36e64e68dc784b889082b5411aa", "filename": "src/librustc_codegen_llvm/mir/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fmir%2Fconstant.rs?ref=1962a70e71e82516a4436e00933654a990203c9e", "patch": "@@ -83,7 +83,7 @@ pub fn const_alloc_to_llvm(cx: &CodegenCx, alloc: &Allocation) -> ValueRef {\n     let pointer_size = layout.pointer_size.bytes() as usize;\n \n     let mut next_offset = 0;\n-    for (&offset, &alloc_id) in &alloc.relocations {\n+    for &(offset, alloc_id) in alloc.relocations.iter() {\n         let offset = offset.bytes();\n         assert_eq!(offset as usize as u64, offset);\n         let offset = offset as usize;"}, {"sha": "cd707152af6c28f91b7afda764e2911b97e143d8", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=1962a70e71e82516a4436e00933654a990203c9e", "patch": "@@ -73,6 +73,7 @@ pub mod control_flow_graph;\n pub mod flock;\n pub mod sync;\n pub mod owning_ref;\n+pub mod sorted_map;\n \n pub struct OnDrop<F: Fn()>(pub F);\n "}, {"sha": "e14bd33c82c1a56610380a23190ad61e11491e52", "filename": "src/librustc_data_structures/sorted_map.rs", "status": "added", "additions": 488, "deletions": 0, "changes": 488, "blob_url": "https://github.com/rust-lang/rust/blob/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_data_structures%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_data_structures%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsorted_map.rs?ref=1962a70e71e82516a4436e00933654a990203c9e", "patch": "@@ -0,0 +1,488 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::borrow::Borrow;\n+use std::cmp::Ordering;\n+use std::convert::From;\n+use std::mem;\n+use std::ops::{RangeBounds, Bound, Index, IndexMut};\n+\n+/// `SortedMap` is a data structure with similar characteristics as BTreeMap but\n+/// slightly different trade-offs: lookup, inseration, and removal are O(log(N))\n+/// and elements can be iterated in order cheaply.\n+///\n+/// `SortedMap` can be faster than a `BTreeMap` for small sizes (<50) since it\n+/// stores data in a more compact way. It also supports accessing contiguous\n+/// ranges of elements as a slice, and slices of already sorted elements can be\n+/// inserted efficiently.\n+#[derive(Clone, PartialEq, Eq, Hash, Default, Debug, RustcEncodable, RustcDecodable)]\n+pub struct SortedMap<K: Ord, V> {\n+    data: Vec<(K,V)>\n+}\n+\n+impl<K: Ord, V> SortedMap<K, V> {\n+\n+    #[inline]\n+    pub fn new() -> SortedMap<K, V> {\n+        SortedMap {\n+            data: vec![]\n+        }\n+    }\n+\n+    /// Construct a `SortedMap` from a presorted set of elements. This is faster\n+    /// than creating an empty map and then inserting the elements individually.\n+    ///\n+    /// It is up to the caller to make sure that the elements are sorted by key\n+    /// and that there are no duplicates.\n+    #[inline]\n+    pub fn from_presorted_elements(elements: Vec<(K, V)>) -> SortedMap<K, V>\n+    {\n+        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+\n+        SortedMap {\n+            data: elements\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn insert(&mut self, key: K, mut value: V) -> Option<V> {\n+        match self.lookup_index_for(&key) {\n+            Ok(index) => {\n+                let mut slot = unsafe {\n+                    self.data.get_unchecked_mut(index)\n+                };\n+                mem::swap(&mut slot.1, &mut value);\n+                Some(value)\n+            }\n+            Err(index) => {\n+                self.data.insert(index, (key, value));\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn remove(&mut self, key: &K) -> Option<V> {\n+        match self.lookup_index_for(key) {\n+            Ok(index) => {\n+                Some(self.data.remove(index).1)\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get(&self, key: &K) -> Option<&V> {\n+        match self.lookup_index_for(key) {\n+            Ok(index) => {\n+                unsafe {\n+                    Some(&self.data.get_unchecked(index).1)\n+                }\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn get_mut(&mut self, key: &K) -> Option<&mut V> {\n+        match self.lookup_index_for(key) {\n+            Ok(index) => {\n+                unsafe {\n+                    Some(&mut self.data.get_unchecked_mut(index).1)\n+                }\n+            }\n+            Err(_) => {\n+                None\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    pub fn clear(&mut self) {\n+        self.data.clear();\n+    }\n+\n+    /// Iterate over elements, sorted by key\n+    #[inline]\n+    pub fn iter(&self) -> ::std::slice::Iter<(K, V)> {\n+        self.data.iter()\n+    }\n+\n+    /// Iterate over the keys, sorted\n+    #[inline]\n+    pub fn keys(&self) -> impl Iterator<Item=&K> + ExactSizeIterator {\n+        self.data.iter().map(|&(ref k, _)| k)\n+    }\n+\n+    /// Iterate over values, sorted by key\n+    #[inline]\n+    pub fn values(&self) -> impl Iterator<Item=&V> + ExactSizeIterator {\n+        self.data.iter().map(|&(_, ref v)| v)\n+    }\n+\n+    #[inline]\n+    pub fn len(&self) -> usize {\n+        self.data.len()\n+    }\n+\n+    #[inline]\n+    pub fn range<R>(&self, range: R) -> &[(K, V)]\n+        where R: RangeBounds<K>\n+    {\n+        let (start, end) = self.range_slice_indices(range);\n+        (&self.data[start .. end])\n+    }\n+\n+    #[inline]\n+    pub fn remove_range<R>(&mut self, range: R)\n+        where R: RangeBounds<K>\n+    {\n+        let (start, end) = self.range_slice_indices(range);\n+        self.data.splice(start .. end, ::std::iter::empty());\n+    }\n+\n+    /// Mutate all keys with the given function `f`. This mutation must not\n+    /// change the sort-order of keys.\n+    #[inline]\n+    pub fn offset_keys<F>(&mut self, f: F)\n+        where F: Fn(&mut K)\n+    {\n+        self.data.iter_mut().map(|&mut (ref mut k, _)| k).for_each(f);\n+    }\n+\n+    /// Inserts a presorted range of elements into the map. If the range can be\n+    /// inserted as a whole in between to existing elements of the map, this\n+    /// will be faster than inserting the elements individually.\n+    ///\n+    /// It is up to the caller to make sure that the elements are sorted by key\n+    /// and that there are no duplicates.\n+    #[inline]\n+    pub fn insert_presorted(&mut self, mut elements: Vec<(K, V)>) {\n+        if elements.is_empty() {\n+            return\n+        }\n+\n+        debug_assert!(elements.windows(2).all(|w| w[0].0 < w[1].0));\n+\n+        let start_index = self.lookup_index_for(&elements[0].0);\n+\n+        let drain = match start_index {\n+            Ok(index) => {\n+                let mut drain = elements.drain(..);\n+                self.data[index] = drain.next().unwrap();\n+                drain\n+            }\n+            Err(index) => {\n+                if index == self.data.len() ||\n+                   elements.last().unwrap().0 < self.data[index].0 {\n+                    // We can copy the whole range without having to mix with\n+                    // existing elements.\n+                    self.data.splice(index .. index, elements.drain(..));\n+                    return\n+                }\n+\n+                let mut drain = elements.drain(..);\n+                self.data.insert(index, drain.next().unwrap());\n+                drain\n+            }\n+        };\n+\n+        // Insert the rest\n+        for (k, v) in drain {\n+            self.insert(k, v);\n+        }\n+    }\n+\n+    /// Looks up the key in `self.data` via `slice::binary_search()`.\n+    #[inline(always)]\n+    fn lookup_index_for(&self, key: &K) -> Result<usize, usize> {\n+        self.data.binary_search_by(|&(ref x, _)| x.cmp(key))\n+    }\n+\n+    #[inline]\n+    fn range_slice_indices<R>(&self, range: R) -> (usize, usize)\n+        where R: RangeBounds<K>\n+    {\n+        let start = match range.start() {\n+            Bound::Included(ref k) => {\n+                match self.lookup_index_for(k) {\n+                    Ok(index) | Err(index) => index\n+                }\n+            }\n+            Bound::Excluded(ref k) => {\n+                match self.lookup_index_for(k) {\n+                    Ok(index) => index + 1,\n+                    Err(index) => index,\n+                }\n+            }\n+            Bound::Unbounded => 0,\n+        };\n+\n+        let end = match range.end() {\n+            Bound::Included(ref k) => {\n+                match self.lookup_index_for(k) {\n+                    Ok(index) => index + 1,\n+                    Err(index) => index,\n+                }\n+            }\n+            Bound::Excluded(ref k) => {\n+                match self.lookup_index_for(k) {\n+                    Ok(index) | Err(index) => index,\n+                }\n+            }\n+            Bound::Unbounded => self.data.len(),\n+        };\n+\n+        (start, end)\n+    }\n+}\n+\n+impl<K: Ord, V> IntoIterator for SortedMap<K, V> {\n+    type Item = (K, V);\n+    type IntoIter = ::std::vec::IntoIter<(K, V)>;\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.data.into_iter()\n+    }\n+}\n+\n+impl<K: Ord, V, Q: Borrow<K>> Index<Q> for SortedMap<K, V> {\n+    type Output = V;\n+    fn index(&self, index: Q) -> &Self::Output {\n+        let k: &K = index.borrow();\n+        self.get(k).unwrap()\n+    }\n+}\n+\n+impl<K: Ord, V, Q: Borrow<K>> IndexMut<Q> for SortedMap<K, V> {\n+    fn index_mut(&mut self, index: Q) -> &mut Self::Output {\n+        let k: &K = index.borrow();\n+        self.get_mut(k).unwrap()\n+    }\n+}\n+\n+impl<K: Ord, V, I: Iterator<Item=(K, V)>> From<I> for SortedMap<K, V> {\n+    fn from(data: I) -> Self {\n+        let mut data: Vec<(K, V)> = data.collect();\n+        data.sort_unstable_by(|&(ref k1, _), &(ref k2, _)| k1.cmp(k2));\n+        data.dedup_by(|&mut (ref k1, _), &mut (ref k2, _)| {\n+            k1.cmp(k2) == Ordering::Equal\n+        });\n+        SortedMap {\n+            data\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::SortedMap;\n+\n+    #[test]\n+    fn test_insert_and_iter() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0 .. 100 {\n+            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+\n+            let x = 1000 - x * 2;\n+            map.insert(x, x);\n+            expected.insert(0, (x, x));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_get_and_index() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0 .. 100 {\n+            let x = 1000 - x;\n+            if x & 1 == 0 {\n+                map.insert(x, x);\n+            }\n+            expected.push(x);\n+        }\n+\n+        for mut x in expected {\n+            if x & 1 == 0 {\n+                assert_eq!(map.get(&x), Some(&x));\n+                assert_eq!(map.get_mut(&x), Some(&mut x));\n+                assert_eq!(map[&x], x);\n+                assert_eq!(&mut map[&x], &mut x);\n+            } else {\n+                assert_eq!(map.get(&x), None);\n+                assert_eq!(map.get_mut(&x), None);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_range() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+        map.insert(9, 9);\n+\n+        let keys = |s: &[(_, _)]| {\n+            s.into_iter().map(|e| e.0).collect::<Vec<u32>>()\n+        };\n+\n+        for start in 0 .. 11 {\n+            for end in 0 .. 11 {\n+                if end < start {\n+                    continue\n+                }\n+\n+                let mut expected = vec![1, 3, 6, 9];\n+                expected.retain(|&x| x >= start && x < end);\n+\n+                assert_eq!(keys(map.range(start..end)), expected, \"range = {}..{}\", start, end);\n+            }\n+        }\n+    }\n+\n+\n+    #[test]\n+    fn test_offset_keys() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+\n+        map.offset_keys(|k| *k += 1);\n+\n+        let mut expected = SortedMap::new();\n+        expected.insert(2, 1);\n+        expected.insert(4, 3);\n+        expected.insert(7, 6);\n+\n+        assert_eq!(map, expected);\n+    }\n+\n+    fn keys(s: SortedMap<u32, u32>) -> Vec<u32> {\n+        s.into_iter().map(|(k, _)| k).collect::<Vec<u32>>()\n+    }\n+\n+    fn elements(s: SortedMap<u32, u32>) -> Vec<(u32, u32)> {\n+        s.into_iter().collect::<Vec<(u32, u32)>>()\n+    }\n+\n+    #[test]\n+    fn test_remove_range() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(3, 3);\n+        map.insert(6, 6);\n+        map.insert(9, 9);\n+\n+        for start in 0 .. 11 {\n+            for end in 0 .. 11 {\n+                if end < start {\n+                    continue\n+                }\n+\n+                let mut expected = vec![1, 3, 6, 9];\n+                expected.retain(|&x| x < start || x >= end);\n+\n+                let mut map = map.clone();\n+                map.remove_range(start .. end);\n+\n+                assert_eq!(keys(map), expected, \"range = {}..{}\", start, end);\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_remove() {\n+        let mut map = SortedMap::new();\n+        let mut expected = Vec::new();\n+\n+        for x in 0..10 {\n+            map.insert(x, x);\n+            expected.push((x, x));\n+        }\n+\n+        for x in 0 .. 10 {\n+            let mut map = map.clone();\n+            let mut expected = expected.clone();\n+\n+            assert_eq!(map.remove(&x), Some(x));\n+            expected.remove(x as usize);\n+\n+            assert_eq!(map.iter().cloned().collect::<Vec<_>>(), expected);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_non_overlapping() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 0);\n+        map.insert(8, 0);\n+\n+        map.insert_presorted(vec![(3, 0), (7, 0)]);\n+\n+        let expected = vec![2, 3, 7, 8];\n+        assert_eq!(keys(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_first_elem_equal() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(8, 8);\n+\n+        map.insert_presorted(vec![(2, 0), (7, 7)]);\n+\n+        let expected = vec![(2, 0), (7, 7), (8, 8)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_last_elem_equal() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(8, 8);\n+\n+        map.insert_presorted(vec![(3, 3), (8, 0)]);\n+\n+        let expected = vec![(2, 2), (3, 3), (8, 0)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_shuffle() {\n+        let mut map = SortedMap::new();\n+        map.insert(2, 2);\n+        map.insert(7, 7);\n+\n+        map.insert_presorted(vec![(1, 1), (3, 3), (8, 8)]);\n+\n+        let expected = vec![(1, 1), (2, 2), (3, 3), (7, 7), (8, 8)];\n+        assert_eq!(elements(map), expected);\n+    }\n+\n+    #[test]\n+    fn test_insert_presorted_at_end() {\n+        let mut map = SortedMap::new();\n+        map.insert(1, 1);\n+        map.insert(2, 2);\n+\n+        map.insert_presorted(vec![(3, 3), (8, 8)]);\n+\n+        let expected = vec![(1, 1), (2, 2), (3, 3), (8, 8)];\n+        assert_eq!(elements(map), expected);\n+    }\n+}"}, {"sha": "3f7ecf9dfb282603c09bc2352a2acc4c322cc2af", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1962a70e71e82516a4436e00933654a990203c9e/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=1962a70e71e82516a4436e00933654a990203c9e", "patch": "@@ -1,4 +1,4 @@\n-use std::collections::{btree_map, VecDeque};\n+use std::collections::VecDeque;\n use std::ptr;\n \n use rustc::hir::def_id::DefId;\n@@ -519,7 +519,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n     fn get_bytes(&self, ptr: MemoryPointer, size: Size, align: Align) -> EvalResult<'tcx, &[u8]> {\n         assert_ne!(size.bytes(), 0);\n-        if self.relocations(ptr, size)?.count() != 0 {\n+        if self.relocations(ptr, size)?.len() != 0 {\n             return err!(ReadPointerAsBytes);\n         }\n         self.check_defined(ptr, size)?;\n@@ -614,9 +614,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         // first copy the relocations to a temporary buffer, because\n         // `get_bytes_mut` will clear the relocations, which is correct,\n         // since we don't want to keep any relocations at the target.\n-\n         let relocations: Vec<_> = self.relocations(src, size)?\n-            .map(|(&offset, &alloc_id)| {\n+            .iter()\n+            .map(|&(offset, alloc_id)| {\n                 // Update relocation offsets for the new positions in the destination allocation.\n                 (offset + dest.offset - src.offset, alloc_id)\n             })\n@@ -648,7 +648,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n \n         self.copy_undef_mask(src, dest, size)?;\n         // copy back the relocations\n-        self.get_mut(dest.alloc_id)?.relocations.extend(relocations);\n+        self.get_mut(dest.alloc_id)?.relocations.insert_presorted(relocations);\n \n         Ok(())\n     }\n@@ -660,7 +660,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         match alloc.bytes[offset..].iter().position(|&c| c == 0) {\n             Some(size) => {\n                 let p1 = Size::from_bytes((size + 1) as u64);\n-                if self.relocations(ptr, p1)?.count() != 0 {\n+                if self.relocations(ptr, p1)?.len() != 0 {\n                     return err!(ReadPointerAsBytes);\n                 }\n                 self.check_defined(ptr, p1)?;\n@@ -720,7 +720,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         let bytes = read_target_uint(endianness, bytes).unwrap();\n         // See if we got a pointer\n         if size != self.pointer_size() {\n-            if self.relocations(ptr, size)?.count() != 0 {\n+            if self.relocations(ptr, size)?.len() != 0 {\n                 return err!(ReadPointerAsBytes);\n             }\n         } else {\n@@ -808,24 +808,26 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         &self,\n         ptr: MemoryPointer,\n         size: Size,\n-    ) -> EvalResult<'tcx, btree_map::Range<Size, AllocId>> {\n+    ) -> EvalResult<'tcx, &[(Size, AllocId)]> {\n         let start = ptr.offset.bytes().saturating_sub(self.pointer_size().bytes() - 1);\n         let end = ptr.offset + size;\n         Ok(self.get(ptr.alloc_id)?.relocations.range(Size::from_bytes(start)..end))\n     }\n \n     fn clear_relocations(&mut self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        // Find all relocations overlapping the given range.\n-        let keys: Vec<_> = self.relocations(ptr, size)?.map(|(&k, _)| k).collect();\n-        if keys.is_empty() {\n-            return Ok(());\n-        }\n-\n         // Find the start and end of the given range and its outermost relocations.\n+        let (first, last) = {\n+            // Find all relocations overlapping the given range.\n+            let relocations = self.relocations(ptr, size)?;\n+            if relocations.is_empty() {\n+                return Ok(());\n+            }\n+\n+            (relocations.first().unwrap().0,\n+             relocations.last().unwrap().0 + self.pointer_size())\n+        };\n         let start = ptr.offset;\n         let end = start + size;\n-        let first = *keys.first().unwrap();\n-        let last = *keys.last().unwrap() + self.pointer_size();\n \n         let alloc = self.get_mut(ptr.alloc_id)?;\n \n@@ -839,16 +841,14 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n         }\n \n         // Forget all the relocations.\n-        for k in keys {\n-            alloc.relocations.remove(&k);\n-        }\n+        alloc.relocations.remove_range(first ..= last);\n \n         Ok(())\n     }\n \n     fn check_relocation_edges(&self, ptr: MemoryPointer, size: Size) -> EvalResult<'tcx> {\n-        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.count();\n-        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.count();\n+        let overlapping_start = self.relocations(ptr, Size::from_bytes(0))?.len();\n+        let overlapping_end = self.relocations(ptr.offset(size, self)?, Size::from_bytes(0))?.len();\n         if overlapping_start + overlapping_end != 0 {\n             return err!(ReadPointerAsBytes);\n         }"}]}