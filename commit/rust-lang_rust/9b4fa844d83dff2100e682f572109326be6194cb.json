{"sha": "9b4fa844d83dff2100e682f572109326be6194cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliNGZhODQ0ZDgzZGZmMjEwMGU2ODJmNTcyMTA5MzI2YmU2MTk0Y2I=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T05:37:59Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-02-08T05:37:59Z"}, "message": "auto merge of #4835 : thestinger/rust/iterator, r=graydon\n\nThis adds a `BaseIter` impl to `PriorityQueue`, `TreeMap`, `LinearMap` and `SmallIntMap`, and introduces a `ReverseIter` trait + implementations for `TreeMap`, `TreeSet` and `SmallIntMap`.", "tree": {"sha": "3adcfdd9c0847a4c7c882bfeea5dd06485ab8c3f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3adcfdd9c0847a4c7c882bfeea5dd06485ab8c3f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b4fa844d83dff2100e682f572109326be6194cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b4fa844d83dff2100e682f572109326be6194cb", "html_url": "https://github.com/rust-lang/rust/commit/9b4fa844d83dff2100e682f572109326be6194cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b4fa844d83dff2100e682f572109326be6194cb/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e8fc4b347d3526d1adb21a5ff184c032fa2982c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8fc4b347d3526d1adb21a5ff184c032fa2982c1", "html_url": "https://github.com/rust-lang/rust/commit/e8fc4b347d3526d1adb21a5ff184c032fa2982c1"}, {"sha": "8c32cd2dc8de2dcadb020a51aa5254098f851ea1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8c32cd2dc8de2dcadb020a51aa5254098f851ea1", "html_url": "https://github.com/rust-lang/rust/commit/8c32cd2dc8de2dcadb020a51aa5254098f851ea1"}], "stats": {"total": 220, "additions": 133, "deletions": 87}, "files": [{"sha": "af86911426fdbdbb02fed40219eb4b1ebd91a9a1", "filename": "src/libcargo/cargo.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcargo%2Fcargo.rc", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcargo%2Fcargo.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcargo%2Fcargo.rc?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -495,7 +495,7 @@ pub fn try_parse_sources(filename: &Path,\n     let c = io::read_whole_file_str(filename);\n     match json::from_str(c.get()) {\n         Ok(json::Object(j)) => {\n-            for j.each |k, v| {\n+            for j.each |&(k, v)| {\n                 sources.insert(copy *k, parse_source(*k, v));\n                 debug!(\"source: %s\", *k);\n             }"}, {"sha": "36424d1bfaaa3cd20f6a61fa9c1dda0fa1a40e2f", "filename": "src/libcore/container.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fcontainer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fcontainer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcontainer.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -29,9 +29,6 @@ pub trait Map<K, V>: Mutable {\n     /// Return true if the map contains a value for the specified key\n     pure fn contains_key(&self, key: &K) -> bool;\n \n-    /// Visit all key-value pairs\n-    pure fn each(&self, f: fn(&K, &V) -> bool);\n-\n     /// Visit all keys\n     pure fn each_key(&self, f: fn(&K) -> bool);\n "}, {"sha": "a69cf4611bb7f83441aaa25cb7e233eafd7d4187", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -235,6 +235,23 @@ pub mod linear {\n         }\n     }\n \n+    impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: BaseIter<(&K, &V)> {\n+        /// Visit all key-value pairs\n+        pure fn each(&self, blk: fn(&(&self/K, &self/V)) -> bool) {\n+            for uint::range(0, self.buckets.len()) |i| {\n+                let mut broke = false;\n+                do self.buckets[i].map |bucket| {\n+                    if !blk(&(&bucket.key, &bucket.value)) {\n+                        broke = true; // FIXME(#3064) just write \"break;\"\n+                    }\n+                };\n+                if broke { break; }\n+            }\n+        }\n+        pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+    }\n+\n+\n     impl <K: Hash IterBytes Eq, V> LinearMap<K, V>: Container {\n         /// Return the number of elements in the map\n         pure fn len(&self) -> uint { self.size }\n@@ -262,27 +279,14 @@ pub mod linear {\n             }\n         }\n \n-        /// Visit all key-value pairs\n-        pure fn each(&self, blk: fn(k: &K, v: &V) -> bool) {\n-            for self.buckets.each |slot| {\n-                let mut broke = false;\n-                do slot.iter |bucket| {\n-                    if !blk(&bucket.key, &bucket.value) {\n-                        broke = true; // FIXME(#3064) just write \"break;\"\n-                    }\n-                }\n-                if broke { break; }\n-            }\n-        }\n-\n         /// Visit all keys\n         pure fn each_key(&self, blk: fn(k: &K) -> bool) {\n-            self.each(|k, _| blk(k))\n+            self.each(|&(k, _)| blk(k))\n         }\n \n         /// Visit all values\n         pure fn each_value(&self, blk: fn(v: &V) -> bool) {\n-            self.each(|_, v| blk(v))\n+            self.each(|&(_, v)| blk(v))\n         }\n \n         /// Return the value corresponding to the key in the map\n@@ -388,7 +392,7 @@ pub mod linear {\n         pure fn eq(&self, other: &LinearMap<K, V>) -> bool {\n             if self.len() != other.len() { return false; }\n \n-            for self.each |key, value| {\n+            for self.each |&(key, value)| {\n                 match other.find(key) {\n                     None => return false,\n                     Some(v) => if value != v { return false },\n@@ -603,7 +607,7 @@ mod test_map {\n             assert m.insert(i, i*2);\n         }\n         let mut observed = 0;\n-        for m.each |k, v| {\n+        for m.each |&(k, v)| {\n             assert *v == *k * 2;\n             observed |= (1 << *k);\n         }"}, {"sha": "f66f6b90e9e3b8ca5399bbba758244569840ad62", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -27,6 +27,10 @@ pub trait BaseIter<A> {\n     pure fn size_hint(&self) -> Option<uint>;\n }\n \n+pub trait ReverseIter<A>: BaseIter<A> {\n+    pure fn each_reverse(&self, blk: fn(&A) -> bool);\n+}\n+\n pub trait ExtendedIter<A> {\n     pure fn eachi(&self, blk: fn(uint, v: &A) -> bool);\n     pure fn all(&self, blk: fn(&A) -> bool) -> bool;"}, {"sha": "cfc2cba922602286d71586a385fee8eb47a1085f", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -102,7 +102,7 @@ pub pure fn get_ref<T>(opt: &r/Option<T>) -> &r/T {\n }\n \n #[inline(always)]\n-pub pure fn map<T, U>(opt: &Option<T>, f: fn(x: &T) -> U) -> Option<U> {\n+pub pure fn map<T, U>(opt: &r/Option<T>, f: fn(x: &r/T) -> U) -> Option<U> {\n     //! Maps a `some` value by reference from one type to another\n \n     match *opt { Some(ref x) => Some(f(x)), None => None }\n@@ -193,8 +193,8 @@ pub pure fn get_or_default<T: Copy>(opt: Option<T>, def: T) -> T {\n }\n \n #[inline(always)]\n-pub pure fn map_default<T, U>(opt: &Option<T>, def: U,\n-                              f: fn(x: &T) -> U) -> U {\n+pub pure fn map_default<T, U>(opt: &r/Option<T>, def: U,\n+                              f: fn(&r/T) -> U) -> U {\n     //! Applies a function to the contained value or returns a default\n \n     match *opt { None => move def, Some(ref t) => f(t) }\n@@ -273,7 +273,7 @@ impl<T> Option<T> {\n \n     /// Maps a `some` value from one type to another by reference\n     #[inline(always)]\n-    pure fn map<U>(&self, f: fn(x: &T) -> U) -> Option<U> { map(self, f) }\n+    pure fn map<U>(&self, f: fn(&self/T) -> U) -> Option<U> { map(self, f) }\n \n     /// As `map`, but consumes the option and gives `f` ownership to avoid\n     /// copying.\n@@ -284,7 +284,7 @@ impl<T> Option<T> {\n \n     /// Applies a function to the contained value or returns a default\n     #[inline(always)]\n-    pure fn map_default<U>(&self, def: U, f: fn(x: &T) -> U) -> U {\n+    pure fn map_default<U>(&self, def: U, f: fn(&self/T) -> U) -> U {\n         map_default(self, move def, f)\n     }\n "}, {"sha": "d5c91ea51478342d91fcf38828a72816fe016789", "filename": "src/libstd/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fjson.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -302,7 +302,7 @@ pub impl<S: serialize::Encoder> Json: serialize::Encodable<S> {\n             Object(ref v) => {\n                 do s.emit_rec || {\n                     let mut idx = 0;\n-                    for v.each |key, value| {\n+                    for v.each |&(key, value)| {\n                         do s.emit_field(*key, idx) {\n                             value.encode(s);\n                         }\n@@ -936,7 +936,7 @@ impl Json : Eq {\n                     &Object(ref d1) => {\n                         if d0.len() == d1.len() {\n                             let mut equal = true;\n-                            for d0.each |k, v0| {\n+                            for d0.each |&(k, v0)| {\n                                 match d1.find(k) {\n                                     Some(v1) if v0 == v1 => { },\n                                     _ => { equal = false; break }\n@@ -1000,12 +1000,12 @@ impl Json : Ord {\n                             let mut d1_flat = ~[];\n \n                             // FIXME #4430: this is horribly inefficient...\n-                            for d0.each |k, v| {\n+                            for d0.each |&(k, v)| {\n                                  d0_flat.push((@copy *k, @copy *v));\n                             }\n                             d0_flat.qsort();\n \n-                            for d1.each |k, v| {\n+                            for d1.each |&(k, v)| {\n                                 d1_flat.push((@copy *k, @copy *v));\n                             }\n                             d1_flat.qsort();\n@@ -1146,7 +1146,7 @@ impl <A: ToJson> ~[A]: ToJson {\n impl <A: ToJson Copy> LinearMap<~str, A>: ToJson {\n     fn to_json() -> Json {\n         let mut d = LinearMap::new();\n-        for self.each() |key, value| {\n+        for self.each |&(key, value)| {\n             d.insert(copy *key, value.to_json());\n         }\n         Object(~d)"}, {"sha": "1da3a64251405ac32eef42dc3f9de9d96a7d89c9", "filename": "src/libstd/net_url.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_url.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -219,10 +219,10 @@ pub fn encode_form_urlencoded(m: &LinearMap<~str, ~[~str]>) -> ~str {\n     let mut out = ~\"\";\n     let mut first = true;\n \n-    for m.each |key, values| {\n+    for m.each |&(key, values)| {\n         let key = encode_plus(*key);\n \n-        for (*values).each |value| {\n+        for values.each |value| {\n             if first {\n                 first = false;\n             } else {"}, {"sha": "5248ab1742eb6777fee80a31e12c04cce2c7ea3d", "filename": "src/libstd/priority_queue.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fpriority_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fpriority_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpriority_queue.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -12,6 +12,7 @@\n \n use core::container::{Container, Mutable};\n use core::cmp::Ord;\n+use core::iter::BaseIter;\n use core::prelude::*;\n use core::ptr::addr_of;\n use core::vec;\n@@ -26,6 +27,14 @@ pub struct PriorityQueue<T> {\n     priv data: ~[T],\n }\n \n+impl <T: Ord> PriorityQueue<T>: BaseIter<T> {\n+    /// Visit all values in the underlying vector.\n+    ///\n+    /// The values are **not** visited in order.\n+    pure fn each(&self, f: fn(&T) -> bool) { self.data.each(f) }\n+    pure fn size_hint(&self) -> Option<uint> { self.data.size_hint() }\n+}\n+\n impl <T: Ord> PriorityQueue<T>: Container {\n     /// Returns the length of the queue\n     pure fn len(&self) -> uint { self.data.len() }"}, {"sha": "9642dd0c3dd0f30fdc83bdec95d02a05a1b3f976", "filename": "src/libstd/smallintmap.rs", "status": "modified", "additions": 31, "deletions": 14, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsmallintmap.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -14,13 +14,40 @@\n  */\n \n use core::container::{Container, Mutable, Map, Set};\n+use core::iter::{BaseIter, ReverseIter};\n use core::option::{Some, None};\n use core::prelude::*;\n \n pub struct SmallIntMap<T> {\n     priv v: ~[Option<T>],\n }\n \n+impl<V> SmallIntMap<V>: BaseIter<(uint, &V)> {\n+    /// Visit all key-value pairs in order\n+    pure fn each(&self, it: fn(&(uint, &self/V)) -> bool) {\n+        for uint::range(0, self.v.len()) |i| {\n+            match self.v[i] {\n+              Some(ref elt) => if !it(&(i, elt)) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl<V> SmallIntMap<V>: ReverseIter<(uint, &V)> {\n+    /// Visit all key-value pairs in reverse order\n+    pure fn each_reverse(&self, it: fn(&(uint, &self/V)) -> bool) {\n+        for uint::range_rev(self.v.len(), 0) |i| {\n+            match self.v[i - 1] {\n+              Some(ref elt) => if !it(&(i - 1, elt)) { break },\n+              None => ()\n+            }\n+        }\n+    }\n+}\n+\n impl<V> SmallIntMap<V>: Container {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint {\n@@ -48,24 +75,14 @@ impl<V> SmallIntMap<V>: Map<uint, V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs\n-    pure fn each(&self, it: fn(key: &uint, value: &V) -> bool) {\n-        for uint::range(0, self.v.len()) |i| {\n-            match self.v[i] {\n-              Some(ref elt) => if !it(&i, elt) { break },\n-              None => ()\n-            }\n-        }\n-    }\n-\n-    /// Visit all keys\n+    /// Visit all keys in order\n     pure fn each_key(&self, blk: fn(key: &uint) -> bool) {\n-        self.each(|k, _| blk(k))\n+        self.each(|&(k, _)| blk(&k))\n     }\n \n-    /// Visit all values\n+    /// Visit all values in order\n     pure fn each_value(&self, blk: fn(value: &V) -> bool) {\n-        self.each(|_, v| blk(v))\n+        self.each(|&(_, v)| blk(v))\n     }\n \n     /// Return the value corresponding to the key in the map"}, {"sha": "d8deea60725a0dadc4544516ef2ceefbe8325a1e", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 37, "deletions": 27, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -14,6 +14,7 @@\n \n use core::container::{Container, Mutable, Map, Set};\n use core::cmp::{Eq, Ord};\n+use core::iter::{BaseIter, ReverseIter};\n use core::option::{Option, Some, None};\n use core::prelude::*;\n \n@@ -103,6 +104,21 @@ impl <K: Ord, V> TreeMap<K, V>: Ord {\n     }\n }\n \n+impl <K: Ord, V> TreeMap<K, V>: BaseIter<(&K, &V)> {\n+    /// Visit all key-value pairs in order\n+    pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+        each(&self.root, f)\n+    }\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n+impl <K: Ord, V> TreeMap<K, V>: ReverseIter<(&K, &V)> {\n+    /// Visit all key-value pairs in reverse order\n+    pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n+        each_reverse(&self.root, f);\n+    }\n+}\n+\n impl <K: Ord, V> TreeMap<K, V>: Container {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n@@ -125,14 +141,11 @@ impl <K: Ord, V> TreeMap<K, V>: Map<K, V> {\n         self.find(key).is_some()\n     }\n \n-    /// Visit all key-value pairs in order\n-    pure fn each(&self, f: fn(&K, &V) -> bool) { each(&self.root, f) }\n-\n     /// Visit all keys in order\n-    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|k, _| f(k)) }\n+    pure fn each_key(&self, f: fn(&K) -> bool) { self.each(|&(k, _)| f(k)) }\n \n     /// Visit all values in order\n-    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|_, v| f(v)) }\n+    pure fn each_value(&self, f: fn(&V) -> bool) { self.each(|&(_, v)| f(v)) }\n \n     /// Return the value corresponding to the key in the map\n     pure fn find(&self, key: &K) -> Option<&self/V> {\n@@ -175,19 +188,14 @@ impl <K: Ord, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n-    /// Visit all key-value pairs in reverse order\n-    pure fn each_reverse(&self, f: fn(&K, &V) -> bool) {\n-        each_reverse(&self.root, f);\n-    }\n-\n     /// Visit all keys in reverse order\n     pure fn each_key_reverse(&self, f: fn(&K) -> bool) {\n-        self.each_reverse(|k, _| f(k))\n+        self.each_reverse(|&(k, _)| f(k))\n     }\n \n     /// Visit all values in reverse order\n     pure fn each_value_reverse(&self, f: fn(&V) -> bool) {\n-        self.each_reverse(|_, v| f(v))\n+        self.each_reverse(|&(_, v)| f(v))\n     }\n \n     /// Get a lazy iterator over the key-value pairs in the map.\n@@ -238,12 +246,19 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl <T: Ord> TreeSet<T>: iter::BaseIter<T> {\n+impl <T: Ord> TreeSet<T>: BaseIter<T> {\n     /// Visit all values in order\n     pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n+impl <T: Ord> TreeSet<T>: ReverseIter<T> {\n+    /// Visit all values in reverse order\n+    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n+        self.map.each_key_reverse(f)\n+    }\n+}\n+\n impl <T: Eq Ord> TreeSet<T>: Eq {\n     pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n@@ -499,11 +514,6 @@ impl <T: Ord> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n-    /// Visit all values in reverse order\n-    pure fn each_reverse(&self, f: fn(&T) -> bool) {\n-        self.map.each_key_reverse(f)\n-    }\n-\n     /// Get a lazy iterator over the values in the set.\n     /// Requires that it be frozen (immutable).\n     pure fn iter(&self) -> TreeSetIterator/&self<T> {\n@@ -549,19 +559,19 @@ impl <K: Ord, V> TreeNode<K, V> {\n     }\n }\n \n-pure fn each<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n-                        f: fn(&K, &V) -> bool) {\n+pure fn each<K: Ord, V>(node: &r/Option<~TreeNode<K, V>>,\n+                        f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.map |x| {\n         each(&x.left, f);\n-        if f(&x.key, &x.value) { each(&x.right, f) }\n+        if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     };\n }\n \n-pure fn each_reverse<K: Ord, V>(node: &Option<~TreeNode<K, V>>,\n-                                f: fn(&K, &V) -> bool) {\n+pure fn each_reverse<K: Ord, V>(node: &r/Option<~TreeNode<K, V>>,\n+                                f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.map |x| {\n         each_reverse(&x.right, f);\n-        if f(&x.key, &x.value) { each_reverse(&x.left, f) }\n+        if f(&(&x.key, &x.value)) { each_reverse(&x.left, f) }\n     };\n }\n \n@@ -754,7 +764,7 @@ mod test_treemap {\n             let &(k, v) = x;\n             assert map.find(&k).unwrap() == &v\n         }\n-        for map.each |map_k, map_v| {\n+        for map.each |&(map_k, map_v)| {\n             let mut found = false;\n             for ctrl.each |x| {\n                 let &(ctrl_k, ctrl_v) = x;\n@@ -868,7 +878,7 @@ mod test_treemap {\n         assert m.insert(1, 2);\n \n         let mut n = 0;\n-        for m.each |k, v| {\n+        for m.each |&(k, v)| {\n             assert *k == n;\n             assert *v == n * 2;\n             n += 1;\n@@ -886,7 +896,7 @@ mod test_treemap {\n         assert m.insert(1, 2);\n \n         let mut n = 4;\n-        for m.each_reverse |k, v| {\n+        for m.each_reverse |&(k, v)| {\n             assert *k == n;\n             assert *v == n * 2;\n             n -= 1;"}, {"sha": "593d26d0124042607e8c7207de6f89d6a6cc9a41", "filename": "src/libstd/workcache.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fworkcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Flibstd%2Fworkcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fworkcache.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -142,7 +142,7 @@ type WorkMap = LinearMap<WorkKey, ~str>;\n pub impl<S: Encoder> WorkMap: Encodable<S> {\n     fn encode(&self, s: &S) {\n         let d = dvec::DVec();\n-        for self.each |k, v| {\n+        for self.each |&(k, v)| {\n             d.push((copy *k, copy *v))\n         }\n         let mut v = d.get();\n@@ -155,7 +155,7 @@ pub impl<D: Decoder> WorkMap: Decodable<D> {\n     static fn decode(&self, d: &D) -> WorkMap {\n         let v : ~[(WorkKey,~str)] = Decodable::decode(d);\n         let mut w = LinearMap::new();\n-        for v.each |&(k,v)| {\n+        for v.each |&(k, v)| {\n             w.insert(copy k, copy v);\n         }\n         w\n@@ -312,7 +312,7 @@ impl @Mut<Prep> : TPrep {\n     }\n \n     fn all_fresh(&self, cat: &str, map: &WorkMap) -> bool {\n-        for map.each |k,v| {\n+        for map.each |&(k, v)| {\n             if ! self.is_fresh(cat, k.kind, k.name, *v) {\n                 return false;\n             }"}, {"sha": "a0230d02981324598d871cf2139c6391b512a5ae", "filename": "src/test/run-pass/class-impl-very-parameterized-trait.rs", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9b4fa844d83dff2100e682f572109326be6194cb/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b4fa844d83dff2100e682f572109326be6194cb/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-impl-very-parameterized-trait.rs?ref=9b4fa844d83dff2100e682f572109326be6194cb", "patch": "@@ -11,6 +11,7 @@\n // xfail-fast\n \n use core::container::{Container, Mutable, Map};\n+use core::iter::BaseIter;\n \n enum cat_type { tuxedo, tabby, tortoiseshell }\n \n@@ -48,6 +49,18 @@ impl<T> cat<T> {\n     }\n }\n \n+impl<T> cat<T>: BaseIter<(int, &T)> {\n+    pure fn each(&self, f: fn(&(int, &self/T)) -> bool) {\n+        let mut n = int::abs(self.meows);\n+        while n > 0 {\n+            if !f(&(n, &self.name)) { break; }\n+            n -= 1;\n+        }\n+    }\n+\n+    pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n+}\n+\n impl<T> cat<T>: Container {\n     pure fn len(&self) -> uint { self.meows as uint }\n     pure fn is_empty(&self) -> bool { self.meows == 0 }\n@@ -60,20 +73,12 @@ impl<T> cat<T>: Mutable {\n impl<T> cat<T>: Map<int, T> {\n     pure fn contains_key(&self, k: &int) -> bool { *k <= self.meows }\n \n-    pure fn each(&self, f: fn(v: &int, v: &T) -> bool) {\n-        let mut n = int::abs(self.meows);\n-        while n > 0 {\n-            if !f(&n, &self.name) { break; }\n-            n -= 1;\n-        }\n-    }\n-\n     pure fn each_key(&self, f: fn(v: &int) -> bool) {\n-        for self.each |k, _| { if !f(k) { break; } loop;};\n+        for self.each |&(k, _)| { if !f(&k) { break; } loop;};\n     }\n \n     pure fn each_value(&self, f: fn(v: &T) -> bool) {\n-        for self.each |_, v| { if !f(v) { break; } loop;};\n+        for self.each |&(_, v)| { if !f(v) { break; } loop;};\n     }\n \n     fn insert(&mut self, k: int, _: T) -> bool {"}]}