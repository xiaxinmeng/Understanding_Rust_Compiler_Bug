{"sha": "4d941cd9812891af3b83dd4de64aa7d8ee99641a", "node_id": "C_kwDOAAsO6NoAKDRkOTQxY2Q5ODEyODkxYWYzYjgzZGQ0ZGU2NGFhN2Q4ZWU5OTY0MWE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T05:06:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-11T05:06:09Z"}, "message": "Auto merge of #111452 - matthiaskrgr:rollup-uic8dgy, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108705 (Prevent ICE with broken borrow in closure)\n - #111292 (Fix mishandled `--check-cfg` arguments order)\n - #111382 (Isolate coverage FFI type layouts from their underlying LLVM C++ types)\n - #111385 (vec-shrink-panik: update expectations to work on LLVM 17)\n - #111389 (Add esp-idf platform-support page)\n - #111432 (Use visit_assign to detect SSA locals.)\n - #111448 (Use proper impl self type for alias impl in rustdoc)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "458d6d5e2e9b8202b580eca7c9d61f9bfd19889c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/458d6d5e2e9b8202b580eca7c9d61f9bfd19889c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4d941cd9812891af3b83dd4de64aa7d8ee99641a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4d941cd9812891af3b83dd4de64aa7d8ee99641a", "html_url": "https://github.com/rust-lang/rust/commit/4d941cd9812891af3b83dd4de64aa7d8ee99641a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4d941cd9812891af3b83dd4de64aa7d8ee99641a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d", "html_url": "https://github.com/rust-lang/rust/commit/9a767b6b9e1e53c3cfc25103ed7c88d77ee65d5d"}, {"sha": "07af55edd4253e9eef7c170cec246af1a3589e20", "url": "https://api.github.com/repos/rust-lang/rust/commits/07af55edd4253e9eef7c170cec246af1a3589e20", "html_url": "https://github.com/rust-lang/rust/commit/07af55edd4253e9eef7c170cec246af1a3589e20"}], "stats": {"total": 492, "additions": 443, "deletions": 49}, "files": [{"sha": "aefd5b2a13c92ad1cfe5034d1c7b7e6ff2d10ada", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -680,7 +680,9 @@ pub type InlineAsmDiagHandlerTy = unsafe extern \"C\" fn(&SMDiagnostic, *const c_v\n pub mod coverageinfo {\n     use super::coverage_map;\n \n-    /// Aligns with [llvm::coverage::CounterMappingRegion::RegionKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L209-L230)\n+    /// Corresponds to enum `llvm::coverage::CounterMappingRegion::RegionKind`.\n+    ///\n+    /// Must match the layout of `LLVMRustCounterMappingRegionKind`.\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub enum RegionKind {\n@@ -714,7 +716,9 @@ pub mod coverageinfo {\n     /// array\", encoded separately), and source location (start and end positions of the represented\n     /// code region).\n     ///\n-    /// Matches LLVMRustCounterMappingRegion.\n+    /// Corresponds to struct `llvm::coverage::CounterMappingRegion`.\n+    ///\n+    /// Must match the layout of `LLVMRustCounterMappingRegion`.\n     #[derive(Copy, Clone, Debug)]\n     #[repr(C)]\n     pub struct CounterMappingRegion {"}, {"sha": "1791ce4b31559bcba88bba2c4cae5fa8c3f290f1", "filename": "compiler/rustc_codegen_ssa/src/coverageinfo/ffi.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fcoverageinfo%2Fffi.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -1,6 +1,6 @@\n use rustc_middle::mir::coverage::{CounterValueReference, MappedExpressionIndex};\n \n-/// Aligns with [llvm::coverage::Counter::CounterKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L95)\n+/// Must match the layout of `LLVMRustCounterKind`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum CounterKind {\n@@ -17,8 +17,10 @@ pub enum CounterKind {\n ///     `instrprof.increment()`)\n ///   * For `CounterKind::Expression`, `id` is the index into the coverage map's array of\n ///     counter expressions.\n-/// Aligns with [llvm::coverage::Counter](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L102-L103)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++ counterpart.\n+///\n+/// Corresponds to struct `llvm::coverage::Counter`.\n+///\n+/// Must match the layout of `LLVMRustCounter`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct Counter {\n@@ -59,17 +61,19 @@ impl Counter {\n     }\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression::ExprKind](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L150)\n+/// Corresponds to enum `llvm::coverage::CounterExpression::ExprKind`.\n+///\n+/// Must match the layout of `LLVMRustCounterExprKind`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub enum ExprKind {\n     Subtract = 0,\n     Add = 1,\n }\n \n-/// Aligns with [llvm::coverage::CounterExpression](https://github.com/rust-lang/llvm-project/blob/rustc/13.0-2021-09-30/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L152)\n-/// Important: The Rust struct layout (order and types of fields) must match its C++\n-/// counterpart.\n+/// Corresponds to struct `llvm::coverage::CounterExpression`.\n+///\n+/// Must match the layout of `LLVMRustCounterExpression`.\n #[derive(Copy, Clone, Debug)]\n #[repr(C)]\n pub struct CounterExpression {"}, {"sha": "51354c2b127990f8329aa21a20d1712b5c843fe6", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -173,12 +173,21 @@ pub fn parse_check_cfg(specs: Vec<String>) -> CheckCfg {\n                                         let expected_values = check_cfg\n                                             .expecteds\n                                             .entry(ident.name.to_string())\n+                                            .and_modify(|expected_values| match expected_values {\n+                                                ExpectedValues::Some(_) => {}\n+                                                ExpectedValues::Any => {\n+                                                    // handle the case where names(...) was done\n+                                                    // before values by changing to a list\n+                                                    *expected_values =\n+                                                        ExpectedValues::Some(FxHashSet::default());\n+                                                }\n+                                            })\n                                             .or_insert_with(|| {\n                                                 ExpectedValues::Some(FxHashSet::default())\n                                             });\n \n                                         let ExpectedValues::Some(expected_values) = expected_values else {\n-                                            bug!(\"shoudn't be possible\")\n+                                            bug!(\"`expected_values` should be a list a values\")\n                                         };\n \n                                         for val in values {"}, {"sha": "87906dee4d3481d4f59d3966d9e0a7e7ab0561c4", "filename": "compiler/rustc_llvm/llvm-wrapper/CoverageMappingWrapper.cpp", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FCoverageMappingWrapper.cpp?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -8,18 +8,100 @@\n \n using namespace llvm;\n \n+// FFI equivalent of enum `llvm::coverage::Counter::CounterKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L97-L99\n+enum class LLVMRustCounterKind {\n+  Zero = 0,\n+  CounterValueReference = 1,\n+  Expression = 2,\n+};\n+\n+// FFI equivalent of struct `llvm::coverage::Counter`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L94-L149\n+struct LLVMRustCounter {\n+  LLVMRustCounterKind CounterKind;\n+  uint32_t ID;\n+};\n+\n+static coverage::Counter fromRust(LLVMRustCounter Counter) {\n+  switch (Counter.CounterKind) {\n+  case LLVMRustCounterKind::Zero:\n+    return coverage::Counter::getZero();\n+  case LLVMRustCounterKind::CounterValueReference:\n+    return coverage::Counter::getCounter(Counter.ID);\n+  case LLVMRustCounterKind::Expression:\n+    return coverage::Counter::getExpression(Counter.ID);\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterKind!\");\n+}\n+\n+// FFI equivalent of enum `llvm::coverage::CounterMappingRegion::RegionKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L213-L234\n+enum class LLVMRustCounterMappingRegionKind {\n+  CodeRegion = 0,\n+  ExpansionRegion = 1,\n+  SkippedRegion = 2,\n+  GapRegion = 3,\n+  BranchRegion = 4,\n+};\n+\n+static coverage::CounterMappingRegion::RegionKind\n+fromRust(LLVMRustCounterMappingRegionKind Kind) {\n+  switch (Kind) {\n+  case LLVMRustCounterMappingRegionKind::CodeRegion:\n+    return coverage::CounterMappingRegion::CodeRegion;\n+  case LLVMRustCounterMappingRegionKind::ExpansionRegion:\n+    return coverage::CounterMappingRegion::ExpansionRegion;\n+  case LLVMRustCounterMappingRegionKind::SkippedRegion:\n+    return coverage::CounterMappingRegion::SkippedRegion;\n+  case LLVMRustCounterMappingRegionKind::GapRegion:\n+    return coverage::CounterMappingRegion::GapRegion;\n+  case LLVMRustCounterMappingRegionKind::BranchRegion:\n+    return coverage::CounterMappingRegion::BranchRegion;\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterMappingRegionKind!\");\n+}\n+\n+// FFI equivalent of struct `llvm::coverage::CounterMappingRegion`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L211-L304\n struct LLVMRustCounterMappingRegion {\n-  coverage::Counter Count;\n-  coverage::Counter FalseCount;\n+  LLVMRustCounter Count;\n+  LLVMRustCounter FalseCount;\n   uint32_t FileID;\n   uint32_t ExpandedFileID;\n   uint32_t LineStart;\n   uint32_t ColumnStart;\n   uint32_t LineEnd;\n   uint32_t ColumnEnd;\n-  coverage::CounterMappingRegion::RegionKind Kind;\n+  LLVMRustCounterMappingRegionKind Kind;\n+};\n+\n+// FFI equivalent of enum `llvm::coverage::CounterExpression::ExprKind`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L154\n+enum class LLVMRustCounterExprKind {\n+  Subtract = 0,\n+  Add = 1,\n };\n \n+// FFI equivalent of struct `llvm::coverage::CounterExpression`\n+// https://github.com/rust-lang/llvm-project/blob/ea6fa9c2/llvm/include/llvm/ProfileData/Coverage/CoverageMapping.h#L151-L160\n+struct LLVMRustCounterExpression {\n+  LLVMRustCounterExprKind Kind;\n+  LLVMRustCounter LHS;\n+  LLVMRustCounter RHS;\n+};\n+\n+static coverage::CounterExpression::ExprKind\n+fromRust(LLVMRustCounterExprKind Kind) {\n+  switch (Kind) {\n+  case LLVMRustCounterExprKind::Subtract:\n+    return coverage::CounterExpression::Subtract;\n+  case LLVMRustCounterExprKind::Add:\n+    return coverage::CounterExpression::Add;\n+  }\n+  report_fatal_error(\"Bad LLVMRustCounterExprKind!\");\n+}\n+\n extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n     const char* const Filenames[],\n     size_t FilenamesLen,\n@@ -37,9 +119,9 @@ extern \"C\" void LLVMRustCoverageWriteFilenamesSectionToBuffer(\n extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n     const unsigned *VirtualFileMappingIDs,\n     unsigned NumVirtualFileMappingIDs,\n-    const coverage::CounterExpression *Expressions,\n+    const LLVMRustCounterExpression *RustExpressions,\n     unsigned NumExpressions,\n-    LLVMRustCounterMappingRegion *RustMappingRegions,\n+    const LLVMRustCounterMappingRegion *RustMappingRegions,\n     unsigned NumMappingRegions,\n     RustStringRef BufferOut) {\n   // Convert from FFI representation to LLVM representation.\n@@ -48,13 +130,24 @@ extern \"C\" void LLVMRustCoverageWriteMappingToBuffer(\n   for (const auto &Region : ArrayRef<LLVMRustCounterMappingRegion>(\n            RustMappingRegions, NumMappingRegions)) {\n     MappingRegions.emplace_back(\n-        Region.Count, Region.FalseCount, Region.FileID, Region.ExpandedFileID,\n+        fromRust(Region.Count), fromRust(Region.FalseCount),\n+        Region.FileID, Region.ExpandedFileID,\n         Region.LineStart, Region.ColumnStart, Region.LineEnd, Region.ColumnEnd,\n-        Region.Kind);\n+        fromRust(Region.Kind));\n   }\n+\n+  std::vector<coverage::CounterExpression> Expressions;\n+  Expressions.reserve(NumExpressions);\n+  for (const auto &Expression :\n+       ArrayRef<LLVMRustCounterExpression>(RustExpressions, NumExpressions)) {\n+    Expressions.emplace_back(fromRust(Expression.Kind),\n+                             fromRust(Expression.LHS),\n+                             fromRust(Expression.RHS));\n+  }\n+\n   auto CoverageMappingWriter = coverage::CoverageMappingWriter(\n       ArrayRef<unsigned>(VirtualFileMappingIDs, NumVirtualFileMappingIDs),\n-      ArrayRef<coverage::CounterExpression>(Expressions, NumExpressions),\n+      Expressions,\n       MappingRegions);\n   RawRustStringOstream OS(BufferOut);\n   CoverageMappingWriter.write(OS);"}, {"sha": "9fad2816b0d842ed5c7160dd71d64502285fd1d6", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -1016,7 +1016,7 @@ rustc_queries! {\n         desc { \"converting literal to mir constant\" }\n     }\n \n-    query check_match(key: LocalDefId) {\n+    query check_match(key: LocalDefId) -> Result<(), rustc_errors::ErrorGuaranteed> {\n         desc { |tcx| \"match-checking `{}`\", tcx.def_path_str(key) }\n         cache_on_disk_if { true }\n     }"}, {"sha": "20d381eddb1fc0b8fa6f6f4dd0ba7ba864422d48", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -42,7 +42,9 @@ fn mir_build(tcx: TyCtxt<'_>, def: LocalDefId) -> Body<'_> {\n     // Ensure unsafeck and abstract const building is ran before we steal the THIR.\n     tcx.ensure_with_value().thir_check_unsafety(def);\n     tcx.ensure_with_value().thir_abstract_const(def);\n-    tcx.ensure_with_value().check_match(def);\n+    if let Err(e) = tcx.check_match(def) {\n+        return construct_error(tcx, def, e);\n+    }\n \n     let body = match tcx.thir_body(def) {\n         Err(error_reported) => construct_error(tcx, def, error_reported),"}, {"sha": "ca25f83e6437eb35fcad769824734c899e8b45d9", "filename": "compiler/rustc_mir_build/src/thir/pattern/check_match.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fcheck_match.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -26,8 +26,8 @@ use rustc_session::Session;\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::Span;\n \n-pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let Ok((thir, expr)) = tcx.thir_body(def_id) else { return };\n+pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Result<(), ErrorGuaranteed> {\n+    let (thir, expr) = tcx.thir_body(def_id)?;\n     let thir = thir.borrow();\n     let pattern_arena = TypedArena::default();\n     let mut visitor = MatchVisitor {\n@@ -37,13 +37,16 @@ pub(crate) fn check_match(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n         lint_level: tcx.hir().local_def_id_to_hir_id(def_id),\n         let_source: LetSource::None,\n         pattern_arena: &pattern_arena,\n+        error: Ok(()),\n     };\n     visitor.visit_expr(&thir[expr]);\n+\n     for param in thir.params.iter() {\n         if let Some(box ref pattern) = param.pat {\n             visitor.check_irrefutable(pattern, \"function argument\", None);\n         }\n     }\n+    visitor.error\n }\n \n fn create_e0004(\n@@ -77,6 +80,7 @@ struct MatchVisitor<'a, 'p, 'tcx> {\n     lint_level: HirId,\n     let_source: LetSource,\n     pattern_arena: &'p TypedArena<DeconstructedPat<'p, 'tcx>>,\n+    error: Result<(), ErrorGuaranteed>,\n }\n \n impl<'a, 'tcx> Visitor<'a, 'tcx> for MatchVisitor<'a, '_, 'tcx> {\n@@ -276,9 +280,9 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n                 let [pat_field] = &subpatterns[..] else { bug!() };\n                 self.check_irrefutable(&pat_field.pattern, \"`for` loop binding\", None);\n             } else {\n-                non_exhaustive_match(\n+                self.error = Err(non_exhaustive_match(\n                     &cx, self.thir, scrut_ty, scrut.span, witnesses, arms, expr_span,\n-                );\n+                ));\n             }\n         }\n     }\n@@ -406,7 +410,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n     }\n \n     #[instrument(level = \"trace\", skip(self))]\n-    fn check_irrefutable(&self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n+    fn check_irrefutable(&mut self, pat: &Pat<'tcx>, origin: &str, sp: Option<Span>) {\n         let mut cx = self.new_cx(self.lint_level, false);\n \n         let pattern = self.lower_pattern(&mut cx, pat);\n@@ -475,7 +479,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             AdtDefinedHere { adt_def_span, ty, variants }\n         };\n \n-        self.tcx.sess.emit_err(PatternNotCovered {\n+        self.error = Err(self.tcx.sess.emit_err(PatternNotCovered {\n             span: pat.span,\n             origin,\n             uncovered: Uncovered::new(pat.span, &cx, witnesses),\n@@ -486,7 +490,7 @@ impl<'p, 'tcx> MatchVisitor<'_, 'p, 'tcx> {\n             let_suggestion,\n             misc_suggestion,\n             adt_defined_here,\n-        });\n+        }));\n     }\n }\n \n@@ -628,7 +632,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     witnesses: Vec<DeconstructedPat<'p, 'tcx>>,\n     arms: &[ArmId],\n     expr_span: Span,\n-) {\n+) -> ErrorGuaranteed {\n     let is_empty_match = arms.is_empty();\n     let non_empty_enum = match scrut_ty.kind() {\n         ty::Adt(def, _) => def.is_enum() && !def.variants().is_empty(),\n@@ -640,13 +644,12 @@ fn non_exhaustive_match<'p, 'tcx>(\n     let pattern;\n     let patterns_len;\n     if is_empty_match && !non_empty_enum {\n-        cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n+        return cx.tcx.sess.emit_err(NonExhaustivePatternsTypeNotEmpty {\n             cx,\n             expr_span,\n             span: sp,\n             ty: scrut_ty,\n         });\n-        return;\n     } else {\n         // FIXME: migration of this diagnostic will require list support\n         let joined_patterns = joined_uncovered_patterns(cx, &witnesses);\n@@ -797,7 +800,7 @@ fn non_exhaustive_match<'p, 'tcx>(\n     } else {\n         err.help(msg);\n     }\n-    err.emit();\n+    err.emit()\n }\n \n pub(crate) fn joined_uncovered_patterns<'p, 'tcx>("}, {"sha": "a7b453666622a24ded2f9289fd49118b3d25f835", "filename": "compiler/rustc_mir_transform/src/ssa.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fssa.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -209,13 +209,6 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n         match ctxt {\n             PlaceContext::MutatingUse(MutatingUseContext::Projection)\n             | PlaceContext::NonMutatingUse(NonMutatingUseContext::Projection) => bug!(),\n-            PlaceContext::MutatingUse(MutatingUseContext::Store) => {\n-                self.assignments[local].insert(LocationExtended::Plain(loc));\n-                if let Set1::One(_) = self.assignments[local] {\n-                    // Only record if SSA-like, to avoid growing the vector needlessly.\n-                    self.assignment_order.push(local);\n-                }\n-            }\n             // Anything can happen with raw pointers, so remove them.\n             // We do not verify that all uses of the borrow dominate the assignment to `local`,\n             // so we have to remove them too.\n@@ -252,6 +245,19 @@ impl<'tcx> Visitor<'tcx> for SsaVisitor {\n             self.visit_local(place.local, ctxt, loc);\n         }\n     }\n+\n+    fn visit_assign(&mut self, place: &Place<'tcx>, rvalue: &Rvalue<'tcx>, loc: Location) {\n+        if let Some(local) = place.as_local() {\n+            self.assignments[local].insert(LocationExtended::Plain(loc));\n+            if let Set1::One(_) = self.assignments[local] {\n+                // Only record if SSA-like, to avoid growing the vector needlessly.\n+                self.assignment_order.push(local);\n+            }\n+        } else {\n+            self.visit_place(place, PlaceContext::MutatingUse(MutatingUseContext::Store), loc);\n+        }\n+        self.visit_rvalue(rvalue, loc);\n+    }\n }\n \n #[instrument(level = \"trace\", skip(ssa, body))]"}, {"sha": "73343ba9df51bc7f9e29a95646f9f0ee5a8b00f2", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -27,6 +27,7 @@\n     - [armv7-unknown-linux-uclibceabihf](platform-support/armv7-unknown-linux-uclibceabihf.md)\n     - [\\*-android and \\*-androideabi](platform-support/android.md)\n     - [\\*-linux-ohos](platform-support/openharmony.md)\n+    - [\\*-esp-espidf](platform-support/esp-idf.md)\n     - [\\*-unknown-fuchsia](platform-support/fuchsia.md)\n     - [\\*-kmc-solid_\\*](platform-support/kmc-solid.md)\n     - [loongarch\\*-unknown-linux-\\*](platform-support/loongarch-linux.md)"}, {"sha": "d22e1cf7f684addab48acbada4ce26dc6157a70e", "filename": "src/doc/rustc/src/platform-support.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support.md?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -297,7 +297,7 @@ target | std | host | notes\n `riscv32gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 5.4, musl + RISCV32 support patches)\n `riscv32im-unknown-none-elf` | * |  | Bare RISC-V (RV32IM ISA)\n [`riscv32imac-unknown-xous-elf`](platform-support/riscv32imac-unknown-xous-elf.md) | ? |  | RISC-V Xous (RV32IMAC ISA)\n-`riscv32imc-esp-espidf` | \u2713 |  | RISC-V ESP-IDF\n+[`riscv32imc-esp-espidf`](platform-support/esp-idf.md) | \u2713 |  | RISC-V ESP-IDF\n `riscv64gc-unknown-freebsd` |   |   | RISC-V FreeBSD\n `riscv64gc-unknown-fuchsia` |   |   | RISC-V Fuchsia\n `riscv64gc-unknown-linux-musl` |   |   | RISC-V Linux (kernel 4.20, musl 1.2.0)"}, {"sha": "8a4ca347e22f5b19d13868f93412f112fd453729", "filename": "src/doc/rustc/src/platform-support/esp-idf.md", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fplatform-support%2Fesp-idf.md?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,41 @@\n+# `*-esp-espidf`\n+\n+**Tier: 3**\n+\n+Targets for the [ESP-IDF](https://github.com/espressif/esp-idf) development framework running on RISC-V and Xtensa CPUs.\n+\n+## Target maintainers\n+\n+- Ivan Markov [@ivmarkov](https://github.com/ivmarkov)\n+- Scott Mabin [@MabezDev](https://github.com/MabezDev)\n+\n+## Requirements\n+\n+The target names follow this format: `$ARCH-esp-espidf`, where `$ARCH` specifies the target processor architecture. The following targets are currently defined:\n+\n+|          Target name           | Target CPU(s)         |\n+|--------------------------------|-----------------------|\n+| `riscv32imc-esp-espidf`        |  [ESP32-C3](https://www.espressif.com/en/products/socs/esp32-c3)             |\n+\n+The minimum supported ESP-IDF version is `v4.3`, though it is recommended to use the latest stable release if possible.\n+\n+## Building the target\n+\n+The target can be built by enabling it for a `rustc` build. The `build-std` feature is required to build the standard library for ESP-IDF. `ldproxy` is also required for linking, it can be installed from crates.io.\n+\n+```toml\n+[build]\n+target = [\"$ARCH-esp-espidf\"]\n+\n+[target.$ARCH-esp-espidf]\n+linker = \"ldproxy\"\n+\n+[unstable]\n+build-std = [\"std\", \"panic_abort\"]\n+```\n+\n+The `esp-idf-sys` crate will handle the compilation of ESP-IDF, including downloading the relevant toolchains for the build.\n+\n+## Cross-compilation toolchains and C code\n+\n+`esp-idf-sys` exposes the toolchain used in the compilation of ESP-IDF, see the crate [documentation for build output propagation](https://github.com/esp-rs/esp-idf-sys#conditional-compilation) for more information."}, {"sha": "59a3e63172406892bf116ff252e1268fae0a39cd", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -2414,14 +2414,15 @@ fn clean_impl<'tcx>(\n     }\n \n     let for_ = clean_ty(impl_.self_ty, cx);\n-    let type_alias = for_.def_id(&cx.cache).and_then(|did| match tcx.def_kind(did) {\n-        DefKind::TyAlias => Some(clean_middle_ty(\n-            ty::Binder::dummy(tcx.type_of(did).subst_identity()),\n-            cx,\n-            Some(did),\n-        )),\n-        _ => None,\n-    });\n+    let type_alias =\n+        for_.def_id(&cx.cache).and_then(|alias_def_id: DefId| match tcx.def_kind(alias_def_id) {\n+            DefKind::TyAlias => Some(clean_middle_ty(\n+                ty::Binder::dummy(tcx.type_of(def_id).subst_identity()),\n+                cx,\n+                Some(def_id.to_def_id()),\n+            )),\n+            _ => None,\n+        });\n     let mut make_item = |trait_: Option<Path>, for_: Type, items: Vec<Item>| {\n         let kind = ImplItem(Box::new(Impl {\n             unsafety: impl_.unsafety,"}, {"sha": "88b7edff260939ac95edfd013551862c69f518a2", "filename": "tests/codegen/vec-shrink-panik.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fcodegen%2Fvec-shrink-panik.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fcodegen%2Fvec-shrink-panik.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fvec-shrink-panik.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -25,7 +25,7 @@ pub fn issue71861(vec: Vec<u32>) -> Box<[u32]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: filter\n+    // old: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n \n@@ -40,7 +40,7 @@ pub fn issue75636<'a>(iter: &[&'a str]) -> Box<[&'a str]> {\n \n     // Call to panic_cannot_unwind in case of double-panic is expected,\n     // on LLVM 16 and older, but other panics are not.\n-    // CHECK: filter\n+    // old: filter\n     // old-NEXT: ; call core::panicking::panic_cannot_unwind\n     // old-NEXT: panic_cannot_unwind\n "}, {"sha": "5866439055e8da5b560fa0d9d7e16114301bc667", "filename": "tests/mir-opt/copy-prop/partial_init.main.CopyProp.diff", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.main.CopyProp.diff?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,13 @@\n+- // MIR for `main` before CopyProp\n++ // MIR for `main` after CopyProp\n+  \n+  fn main() -> () {\n+      let mut _0: ();                      // return place in scope 0 at $DIR/partial_init.rs:+0:15: +0:15\n+      let mut _1: (isize,);                // in scope 0 at $SRC_DIR/core/src/intrinsics/mir.rs:LL:COL\n+  \n+      bb0: {\n+          (_1.0: isize) = const 1_isize;   // scope 0 at $DIR/partial_init.rs:+4:13: +4:20\n+          return;                          // scope 0 at $DIR/partial_init.rs:+5:13: +5:21\n+      }\n+  }\n+  "}, {"sha": "f5ab9974f71e514b7e49a26939508bcd2d9cb359", "filename": "tests/mir-opt/copy-prop/partial_init.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fcopy-prop%2Fpartial_init.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,18 @@\n+// unit-test: CopyProp\n+// Verify that we do not ICE on partial initializations.\n+\n+#![feature(custom_mir, core_intrinsics)]\n+extern crate core;\n+use core::intrinsics::mir::*;\n+\n+// EMIT_MIR partial_init.main.CopyProp.diff\n+#[custom_mir(dialect = \"runtime\", phase = \"post-cleanup\")]\n+pub fn main() {\n+    mir! (\n+        let x: (isize, );\n+        {\n+            x.0 = 1;\n+            Return()\n+        }\n+    )\n+}"}, {"sha": "82dfffe5f1c223320d656de9bbfc9e2a8b899db1", "filename": "tests/rustdoc/impl-alias-substituted.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Frustdoc%2Fimpl-alias-substituted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Frustdoc%2Fimpl-alias-substituted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frustdoc%2Fimpl-alias-substituted.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,9 @@\n+pub struct Matrix<T, const N: usize, const M: usize>([[T; N]; M]);\n+\n+pub type Vector<T, const N: usize> = Matrix<T, N, 1>;\n+\n+// @has \"impl_alias_substituted/struct.Matrix.html\" '//*[@class=\"impl\"]//h3[@class=\"code-header\"]' \\\n+//  \"impl<T: Copy> Matrix<T, 3, 1>\"\n+impl<T: Copy> Vector<T, 3> {\n+    pub fn test() {}\n+}"}, {"sha": "91b81428b38a4d4785c2a14382067c9029cd94c2", "filename": "tests/ui/check-cfg/order-independant.names_after.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_after.stderr?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,19 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:8:7\n+   |\n+LL | #[cfg(a)]\n+   |       ^- help: specify a config value: `= \"b\"`\n+   |\n+   = note: expected values for `a` are: `b`\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:12:7\n+   |\n+LL | #[cfg(a = \"unk\")]\n+   |       ^^^^^^^^^\n+   |\n+   = note: expected values for `a` are: `b`\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "91b81428b38a4d4785c2a14382067c9029cd94c2", "filename": "tests/ui/check-cfg/order-independant.names_before.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.names_before.stderr?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,19 @@\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:8:7\n+   |\n+LL | #[cfg(a)]\n+   |       ^- help: specify a config value: `= \"b\"`\n+   |\n+   = note: expected values for `a` are: `b`\n+   = note: `#[warn(unexpected_cfgs)]` on by default\n+\n+warning: unexpected `cfg` condition value\n+  --> $DIR/order-independant.rs:12:7\n+   |\n+LL | #[cfg(a = \"unk\")]\n+   |       ^^^^^^^^^\n+   |\n+   = note: expected values for `a` are: `b`\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "ce056b8dcd6f858c7159488ed47d4bc46399f41d", "filename": "tests/ui/check-cfg/order-independant.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcheck-cfg%2Forder-independant.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,16 @@\n+// check-pass\n+// revisions: names_before names_after\n+// compile-flags: -Z unstable-options\n+// compile-flags: --check-cfg=names(names_before,names_after)\n+// [names_before]compile-flags: --check-cfg=names(a) --check-cfg=values(a,\"b\")\n+// [names_after]compile-flags: --check-cfg=values(a,\"b\") --check-cfg=names(a)\n+\n+#[cfg(a)]\n+//~^ WARNING unexpected `cfg` condition value\n+fn my_cfg() {}\n+\n+#[cfg(a = \"unk\")]\n+//~^ WARNING unexpected `cfg` condition value\n+fn my_cfg() {}\n+\n+fn main() {}"}, {"sha": "a7bf9b67d453ef2da607c74630b19f5c6679d765", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.rs?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,23 @@\n+// regression test for #108683\n+// edition:2021\n+\n+enum Refutable {\n+    A,\n+    B,\n+}\n+\n+fn example(v1: u32, v2: [u32; 4], v3: Refutable) {\n+    const PAT: u32 = 0;\n+    let v4 = &v2[..];\n+    || {\n+        let 0 = v1; //~ ERROR refutable pattern in local binding\n+        let (0 | 1) = v1; //~ ERROR refutable pattern in local binding\n+        let 1.. = v1; //~ ERROR refutable pattern in local binding\n+        let [0, 0, 0, 0] = v2; //~ ERROR refutable pattern in local binding\n+        let [0] = v4; //~ ERROR refutable pattern in local binding\n+        let Refutable::A = v3; //~ ERROR refutable pattern in local binding\n+        let PAT = v1; //~ ERROR refutable pattern in local binding\n+    };\n+}\n+\n+fn main() {}"}, {"sha": "ca8c2a16d323f9fcbca2c72d7c4a8377438e9ae1", "filename": "tests/ui/closures/2229_closure_analysis/bad-pattern.stderr", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4d941cd9812891af3b83dd4de64aa7d8ee99641a/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fclosures%2F2229_closure_analysis%2Fbad-pattern.stderr?ref=4d941cd9812891af3b83dd4de64aa7d8ee99641a", "patch": "@@ -0,0 +1,113 @@\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:13:13\n+   |\n+LL |         let 0 = v1;\n+   |             ^ pattern `1_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 0 = v1 { todo!() };\n+   |         ++            +++++++++++\n+help: alternatively, you could prepend the pattern with an underscore to define a new named variable; identifiers cannot begin with digits\n+   |\n+LL |         let _0 = v1;\n+   |             +\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:14:14\n+   |\n+LL |         let (0 | 1) = v1;\n+   |              ^^^^^ pattern `2_u32..=u32::MAX` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let (0 | 1) = v1 { todo!() };\n+   |         ++                  +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:15:13\n+   |\n+LL |         let 1.. = v1;\n+   |             ^^^ pattern `0_u32` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let 1.. = v1 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:16:13\n+   |\n+LL |         let [0, 0, 0, 0] = v2;\n+   |             ^^^^^^^^^^^^ pattern `[1_u32..=u32::MAX, _, _, _]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `[u32; 4]`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let [0, 0, 0, 0] = v2 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:17:13\n+   |\n+LL |         let [0] = v4;\n+   |             ^^^ patterns `&[]` and `&[_, _, ..]` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `&[u32]`\n+help: you might want to use `if let` to ignore the variants that aren't matched\n+   |\n+LL |         if let [0] = v4 { todo!() };\n+   |         ++              +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:18:13\n+   |\n+LL |         let Refutable::A = v3;\n+   |             ^^^^^^^^^^^^ pattern `Refutable::B` not covered\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+note: `Refutable` defined here\n+  --> $DIR/bad-pattern.rs:4:6\n+   |\n+LL | enum Refutable {\n+   |      ^^^^^^^^^\n+LL |     A,\n+LL |     B,\n+   |     - not covered\n+   = note: the matched value is of type `Refutable`\n+help: you might want to use `if let` to ignore the variant that isn't matched\n+   |\n+LL |         if let Refutable::A = v3 { todo!() };\n+   |         ++                       +++++++++++\n+\n+error[E0005]: refutable pattern in local binding\n+  --> $DIR/bad-pattern.rs:19:13\n+   |\n+LL |         let PAT = v1;\n+   |             ^^^\n+   |             |\n+   |             pattern `1_u32..=u32::MAX` not covered\n+   |             missing patterns are not covered because `PAT` is interpreted as a constant pattern, not a new variable\n+   |             help: introduce a variable instead: `PAT_var`\n+   |\n+   = note: `let` bindings require an \"irrefutable pattern\", like a `struct` or an `enum` with only one variant\n+   = note: for more information, visit https://doc.rust-lang.org/book/ch18-02-refutability.html\n+   = note: the matched value is of type `u32`\n+\n+error: aborting due to 7 previous errors\n+\n+For more information about this error, try `rustc --explain E0005`."}]}