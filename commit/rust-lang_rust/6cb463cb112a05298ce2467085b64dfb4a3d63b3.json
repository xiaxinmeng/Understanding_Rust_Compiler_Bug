{"sha": "6cb463cb112a05298ce2467085b64dfb4a3d63b3", "node_id": "C_kwDOAAsO6NoAKDZjYjQ2M2NiMTEyYTA1Mjk4Y2UyNDY3MDg1YjY0ZGZiNGEzZDYzYjM", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-06T14:31:11Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2022-04-08T11:49:18Z"}, "message": "Add futex-based RwLock on Linux.", "tree": {"sha": "85de3d06cd87fb5c8373f594642a9083d9e93ae3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85de3d06cd87fb5c8373f594642a9083d9e93ae3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6cb463cb112a05298ce2467085b64dfb4a3d63b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6cb463cb112a05298ce2467085b64dfb4a3d63b3", "html_url": "https://github.com/rust-lang/rust/commit/6cb463cb112a05298ce2467085b64dfb4a3d63b3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6cb463cb112a05298ce2467085b64dfb4a3d63b3/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1a40410ecce3c1b115e244c7e189e019e226c13", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a40410ecce3c1b115e244c7e189e019e226c13", "html_url": "https://github.com/rust-lang/rust/commit/f1a40410ecce3c1b115e244c7e189e019e226c13"}], "stats": {"total": 297, "additions": 295, "deletions": 2}, "files": [{"sha": "0665d7b3bfdc55c53ca0a4a9348992938fb199d3", "filename": "library/std/src/sys/unix/locks/futex_rwlock.rs", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/rust-lang/rust/blob/6cb463cb112a05298ce2467085b64dfb4a3d63b3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb463cb112a05298ce2467085b64dfb4a3d63b3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Ffutex_rwlock.rs?ref=6cb463cb112a05298ce2467085b64dfb4a3d63b3", "patch": "@@ -0,0 +1,293 @@\n+use crate::sync::atomic::{\n+    AtomicI32,\n+    Ordering::{Acquire, Relaxed, Release},\n+};\n+use crate::sys::futex::{futex_wait, futex_wake, futex_wake_all};\n+\n+pub type MovableRwLock = RwLock;\n+\n+pub struct RwLock {\n+    // The state consists of a 30-bit reader counter, a 'readers waiting' flag, and a 'writers waiting' flag.\n+    // Bits 0..30:\n+    //   0: Unlocked\n+    //   1..=0x3FFF_FFFE: Locked by N readers\n+    //   0x3FFF_FFFF: Write locked\n+    // Bit 30: Readers are waiting on this futex.\n+    // Bit 31: Writers are waiting on the writer_notify futex.\n+    state: AtomicI32,\n+    // The 'condition variable' to notify writers through.\n+    // Incremented on every signal.\n+    writer_notify: AtomicI32,\n+}\n+\n+const READ_LOCKED: i32 = 1;\n+const MASK: i32 = (1 << 30) - 1;\n+const WRITE_LOCKED: i32 = MASK;\n+const MAX_READERS: i32 = MASK - 1;\n+const READERS_WAITING: i32 = 1 << 30;\n+const WRITERS_WAITING: i32 = 1 << 31;\n+\n+fn unlocked(state: i32) -> bool {\n+    state & MASK == 0\n+}\n+\n+fn write_locked(state: i32) -> bool {\n+    state & MASK == WRITE_LOCKED\n+}\n+\n+fn readers_waiting(state: i32) -> bool {\n+    state & READERS_WAITING != 0\n+}\n+\n+fn writers_waiting(state: i32) -> bool {\n+    state & WRITERS_WAITING != 0\n+}\n+\n+fn read_lockable(state: i32) -> bool {\n+    // This also returns false if the counter could overflow if we tried to read lock it.\n+    state & MASK < MAX_READERS && !readers_waiting(state) && !writers_waiting(state)\n+}\n+\n+fn reached_max_readers(state: i32) -> bool {\n+    state & MASK == MAX_READERS\n+}\n+\n+impl RwLock {\n+    #[inline]\n+    pub const fn new() -> Self {\n+        Self { state: AtomicI32::new(0), writer_notify: AtomicI32::new(0) }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn destroy(&self) {}\n+\n+    #[inline]\n+    pub unsafe fn try_read(&self) -> bool {\n+        self.state\n+            .fetch_update(Acquire, Relaxed, |s| read_lockable(s).then(|| s + READ_LOCKED))\n+            .is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read(&self) {\n+        if !self.try_read() {\n+            self.read_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn read_unlock(&self) {\n+        let state = self.state.fetch_sub(READ_LOCKED, Release) - 1;\n+\n+        // It's impossible for a reader to be waiting on a read-locked RwLock,\n+        // except if there is also a writer waiting.\n+        debug_assert!(!readers_waiting(state) || writers_waiting(state));\n+\n+        // Wake up a writer if we were the last reader and there's a writer waiting.\n+        if unlocked(state) && writers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn read_contended(&self) {\n+        let mut state = self.spin_read();\n+\n+        loop {\n+            // If we can lock it, lock it.\n+            if read_lockable(state) {\n+                match self.state.compare_exchange(state, state + READ_LOCKED, Acquire, Relaxed) {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Check for overflow.\n+            if reached_max_readers(state) {\n+                panic!(\"too many active read locks on RwLock\");\n+            }\n+\n+            // Make sure the readers waiting bit is set before we go to sleep.\n+            if !readers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | READERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.state, state | READERS_WAITING, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_read();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn try_write(&self) -> bool {\n+        self.state.fetch_update(Acquire, Relaxed, |s| unlocked(s).then(|| s + WRITE_LOCKED)).is_ok()\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write(&self) {\n+        if !self.try_write() {\n+            self.write_contended();\n+        }\n+    }\n+\n+    #[inline]\n+    pub unsafe fn write_unlock(&self) {\n+        let state = self.state.fetch_sub(WRITE_LOCKED, Release) - WRITE_LOCKED;\n+\n+        debug_assert!(unlocked(state));\n+\n+        if writers_waiting(state) || readers_waiting(state) {\n+            self.wake_writer_or_readers(state);\n+        }\n+    }\n+\n+    #[cold]\n+    fn write_contended(&self) {\n+        let mut state = self.spin_write();\n+\n+        let mut other_writers_waiting = 0;\n+\n+        loop {\n+            // If it's unlocked, we try to lock it.\n+            if unlocked(state) {\n+                match self.state.compare_exchange(\n+                    state,\n+                    state | WRITE_LOCKED | other_writers_waiting,\n+                    Acquire,\n+                    Relaxed,\n+                ) {\n+                    Ok(_) => return, // Locked!\n+                    Err(s) => {\n+                        state = s;\n+                        continue;\n+                    }\n+                }\n+            }\n+\n+            // Set the waiting bit indicating that we're waiting on it.\n+            if !writers_waiting(state) {\n+                if let Err(s) =\n+                    self.state.compare_exchange(state, state | WRITERS_WAITING, Relaxed, Relaxed)\n+                {\n+                    state = s;\n+                    continue;\n+                }\n+            }\n+\n+            // Other writers might be waiting now too, so we should make sure\n+            // we keep that bit on once we manage lock it.\n+            other_writers_waiting = WRITERS_WAITING;\n+\n+            // Examine the notification counter before we check if `state` has changed,\n+            // to make sure we don't miss any notifications.\n+            let seq = self.writer_notify.load(Acquire);\n+\n+            // Don't go to sleep if the lock has become available,\n+            // or if the writers waiting bit is no longer set.\n+            let s = self.state.load(Relaxed);\n+            if unlocked(state) || !writers_waiting(s) {\n+                state = s;\n+                continue;\n+            }\n+\n+            // Wait for the state to change.\n+            futex_wait(&self.writer_notify, seq, None);\n+\n+            // Spin again after waking up.\n+            state = self.spin_write();\n+        }\n+    }\n+\n+    /// Wake up waiting threads after unlocking.\n+    ///\n+    /// If both are waiting, this will wake up only one writer, but will fall\n+    /// back to waking up readers if there was no writer to wake up.\n+    #[cold]\n+    fn wake_writer_or_readers(&self, mut state: i32) {\n+        assert!(unlocked(state));\n+\n+        // The readers waiting bit might be turned on at any point now,\n+        // since readers will block when there's anything waiting.\n+        // Writers will just lock the lock though, regardless of the waiting bits,\n+        // so we don't have to worry about the writer waiting bit.\n+        //\n+        // If the lock gets locked in the meantime, we don't have to do\n+        // anything, because then the thread that locked the lock will take\n+        // care of waking up waiters when it unlocks.\n+\n+        // If only writers are waiting, wake one of them up.\n+        if state == WRITERS_WAITING {\n+            match self.state.compare_exchange(state, 0, Relaxed, Relaxed) {\n+                Ok(_) => {\n+                    self.wake_writer();\n+                    return;\n+                }\n+                Err(s) => {\n+                    // Maybe some readers are now waiting too. So, continue to the next `if`.\n+                    state = s;\n+                }\n+            }\n+        }\n+\n+        // If both writers and readers are waiting, leave the readers waiting\n+        // and only wake up one writer.\n+        if state == READERS_WAITING + WRITERS_WAITING {\n+            if self.state.compare_exchange(state, READERS_WAITING, Relaxed, Relaxed).is_err() {\n+                // The lock got locked. Not our problem anymore.\n+                return;\n+            }\n+            if self.wake_writer() {\n+                return;\n+            }\n+            // No writers were actually waiting. Continue to wake up readers instead.\n+            state = READERS_WAITING;\n+        }\n+\n+        // If readers are waiting, wake them all up.\n+        if state == READERS_WAITING {\n+            if self.state.compare_exchange(state, 0, Relaxed, Relaxed).is_ok() {\n+                futex_wake_all(&self.state);\n+            }\n+        }\n+    }\n+\n+    fn wake_writer(&self) -> bool {\n+        self.writer_notify.fetch_add(1, Release);\n+        futex_wake(&self.writer_notify)\n+    }\n+\n+    /// Spin for a while, but stop directly at the given condition.\n+    fn spin_until(&self, f: impl Fn(i32) -> bool) -> i32 {\n+        let mut spin = 100; // Chosen by fair dice roll.\n+        loop {\n+            let state = self.state.load(Relaxed);\n+            if f(state) || spin == 0 {\n+                return state;\n+            }\n+            crate::hint::spin_loop();\n+            spin -= 1;\n+        }\n+    }\n+\n+    fn spin_write(&self) -> i32 {\n+        // Stop spinning when it's unlocked or when there's waiting writers, to keep things somewhat fair.\n+        self.spin_until(|state| unlocked(state) || writers_waiting(state))\n+    }\n+\n+    fn spin_read(&self) -> i32 {\n+        // Stop spinning when it's unlocked or read locked, or when there's waiting threads.\n+        self.spin_until(|state| {\n+            !write_locked(state) || readers_waiting(state) || writers_waiting(state)\n+        })\n+    }\n+}"}, {"sha": "85afc939d2e897e7c9f0ecf1e1f8269f852d6591", "filename": "library/std/src/sys/unix/locks/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6cb463cb112a05298ce2467085b64dfb4a3d63b3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6cb463cb112a05298ce2467085b64dfb4a3d63b3/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Flocks%2Fmod.rs?ref=6cb463cb112a05298ce2467085b64dfb4a3d63b3", "patch": "@@ -4,13 +4,13 @@ cfg_if::cfg_if! {\n         target_os = \"android\",\n     ))] {\n         mod futex;\n+        mod futex_rwlock;\n         #[allow(dead_code)]\n         mod pthread_mutex; // Only used for PthreadMutexAttr, needed by pthread_remutex.\n         mod pthread_remutex; // FIXME: Implement this using a futex\n-        mod pthread_rwlock; // FIXME: Implement this using a futex\n         pub use futex::{Mutex, MovableMutex, Condvar, MovableCondvar};\n         pub use pthread_remutex::ReentrantMutex;\n-        pub use pthread_rwlock::{RwLock, MovableRwLock};\n+        pub use futex_rwlock::{RwLock, MovableRwLock};\n     } else {\n         mod pthread_mutex;\n         mod pthread_remutex;"}]}