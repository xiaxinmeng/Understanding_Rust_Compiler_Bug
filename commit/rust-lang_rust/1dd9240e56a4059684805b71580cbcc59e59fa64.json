{"sha": "1dd9240e56a4059684805b71580cbcc59e59fa64", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkZDkyNDBlNTZhNDA1OTY4NDgwNWI3MTU4MGNiY2M1OWU1OWZhNjQ=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-10T23:13:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-08-11T00:11:24Z"}, "message": "Update docs regarding path syntax.", "tree": {"sha": "73ef86a4c89e1b9a4c2a5797427d16ad4d99de55", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/73ef86a4c89e1b9a4c2a5797427d16ad4d99de55"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1dd9240e56a4059684805b71580cbcc59e59fa64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1dd9240e56a4059684805b71580cbcc59e59fa64", "html_url": "https://github.com/rust-lang/rust/commit/1dd9240e56a4059684805b71580cbcc59e59fa64", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1dd9240e56a4059684805b71580cbcc59e59fa64/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f35f645c3a0231be7100318c459e450350124d1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f35f645c3a0231be7100318c459e450350124d1", "html_url": "https://github.com/rust-lang/rust/commit/2f35f645c3a0231be7100318c459e450350124d1"}], "stats": {"total": 110, "additions": 42, "deletions": 68}, "files": [{"sha": "a42e4c89fd3d30ecd538addd38339c951d61fa3e", "filename": "doc/rust.texi", "status": "modified", "additions": 42, "deletions": 68, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/1dd9240e56a4059684805b71580cbcc59e59fa64/doc%2Frust.texi", "raw_url": "https://github.com/rust-lang/rust/raw/1dd9240e56a4059684805b71580cbcc59e59fa64/doc%2Frust.texi", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.texi?ref=1dd9240e56a4059684805b71580cbcc59e59fa64", "patch": "@@ -550,7 +550,7 @@ Additional specific influences can be seen from the following languages:\n \n @menu\n * Ref.Lex::                     Lexical structure.\n-* Ref.Path::                    References to slots and items.\n+* Ref.Path::                    References to items.\n * Ref.Gram::                    Grammar.\n * Ref.Comp::                    Compilation and component model.\n * Ref.Mem::                     Semantic model of memory.\n@@ -977,69 +977,43 @@ The special symbols are:\n @page\n @node    Ref.Path\n @section Ref.Path\n-@c * Ref.Path::               References to slots and items.\n+@c * Ref.Path::               References to items.\n @cindex Names of items or slots\n @cindex Path name\n @cindex Type parameters\n \n-A @dfn{path} is a ubiquitous syntactic form in Rust that deserves special\n-attention. A path denotes a slot or an\n-item. @xref{Ref.Mem.Slot}. @xref{Ref.Item}. Every slot and item in a Rust\n-crate has a @emph{canonical path} that refers to it from the crate top-level,\n-as well as a number of shorter @emph{relative paths} that may also denote it\n-in inner scopes of the crate. There is no way to define a slot or item without\n-a canonical path within its crate (with the exception of the crate's implicit\n-top-level module). Paths have meaning only within a specific\n-crate. @xref{Ref.Comp.Crate}.\n+A @dfn{path} is a sequence of one or more path components separated by a\n+namespace qualifier (@code{::}). If a path consists of only one component, it\n+may refer to either an item or a slot in a local control\n+scope. @xref{Ref.Mem.Slot}. @xref{Ref.Item}. If a path has multiple\n+components, it refers to an item.\n \n-Paths consist of period-separated components. In the simplest form, path\n-components are identifiers. @xref{Ref.Lex.Ident}.\n+Every item has a @emph{canonical path} within its crate, but the path naming\n+an item is only meaningful within a given crate. There is no global namespace\n+across crates; an item's canonical path merely identifies it within the\n+crate. @xref{Ref.Comp.Crate} \n+\n+Path components are usually identifiers. @xref{Ref.Lex.Ident}. The last\n+component of a path may also have trailing explicit type arguments.\n \n Two examples of simple paths consisting of only identifier components:\n @example\n x;\n-x.y.z;\n-@end example\n-\n-Paths fall into two important categories: @emph{names} and\n-@emph{lvals}.\n-\n-A @dfn{name} denotes an item, and is statically resolved to its\n-referent at compile time.\n-\n-An @dfn{lval} denotes a slot or some component of a value held within a slot,\n-and is statically resolved at compile time to a sequence of memory operations\n-and primitive (arithmetic) expressions that will be executed to load or store\n-the associated value, starting from the task stack frame, at run time.\n-\n-In some contexts, the Rust grammar accepts a general @emph{path}, but a\n-subsequent syntactic restriction requires the path to be an lval or a name. In\n-other words: in some contexts an lval is required (for example, on the left\n-hand side of the copy operator, @pxref{Ref.Expr.Copy}) and in other contexts a\n-name is required (for example, as a type parameter, @pxref{Ref.Item}). In no\n-case is the grammar made ambiguous by accepting a general path and restricting\n-allowed paths to names or lvals after parsing. These restrictions are noted in\n-the grammar. @xref{Ref.Gram}.\n-\n-A name component may include type parameters. Type parameters are denoted by\n-square brackets. Square brackets are used @emph{only} to denote type\n-parameters in Rust. If a name component includes a type parameter, the type\n-parameter must also resolve statically to a type in the environment of the\n-name. Type parameters are only part of the names of items. @xref{Ref.Item}.\n-\n-An example of a name with type parameters:\n-@example\n-m.map[int,str];\n+x::y::z;\n @end example\n \n-An lval component may include an indexing operator. Index operators are\n-enclosed in parentheses and can include any integral expression. Indexing\n-operators can only be applied to vectors or strings, and imply a run-time\n-bounds-check. @xref{Ref.Type.Vec}.\n+In most contexts, the Rust grammar accepts a general @emph{path}, but\n+subsequent passes pay restrict paths occurring in various contexts to refer to\n+slots or items, depending on the semantics of the occurrence. In other words:\n+in some contexts a slot is required (for example, on the left hand side of the\n+copy operator, @pxref{Ref.Expr.Copy}) and in other contexts an item is\n+required (for example, as a type parameter, @pxref{Ref.Item}). In no case is\n+the grammar made ambiguous by accepting a general path and interpreting the\n+reference in later passes. @xref{Ref.Gram}.\n \n-An example of an lval with a dynamic indexing operator:\n+An example of a path with type parameters:\n @example\n-x.y.(1 + v).z;\n+m::map[int,str];\n @end example\n \n @page\n@@ -1110,8 +1084,8 @@ all members of the crate have canonical path names. @xref{Ref.Path}. The\n the crate: these are either directory modules, corresponding to directories in\n the filesystem of the compilation environment, or file modules, corresponding\n to Rust source files. The names given to such modules in @code{mod} directives\n-become prefixes of the paths of items and slots defined within any included\n-Rust source files.\n+become prefixes of the paths of items defined within any included Rust source\n+files.\n \n The @code{use} directives within the crate specify @emph{other crates} to scan\n for, locate, import into the crate's module namespace during compilation, and\n@@ -1381,7 +1355,7 @@ Some operations implicitly dereference boxes. Examples of such @dfn{implicit\n dereference} operations are:\n @itemize\n @item arithmetic operators (@code{x + y - z})\n-@item name-component selection (@code{x.y.z})\n+@item field selection (@code{x.y.z})\n @end itemize\n \n An example of an implicit-dereference operation performed on box values:\n@@ -1731,9 +1705,9 @@ declarations. @xref{Ref.Comp.Crate}.\n \n An example of an import:\n @example\n-import std.math.sin;\n+import std::math::sin;\n fn main() @{\n-    // Equivalent to 'log std.math.sin(1.0);'\n+    // Equivalent to 'log std::math::sin(1.0);'\n     log sin(1.0);\n @}\n @end example\n@@ -1767,8 +1741,8 @@ mod foo @{\n @}\n \n fn main() @{\n-    foo.primary();  // Will compile.\n-    foo.helper(2,3) // ERROR: will not compile.\n+    foo::primary();  // Will compile.\n+    foo::helper(2,3) // ERROR: will not compile.\n @}\n @end example\n \n@@ -3268,7 +3242,7 @@ fn read_file_lines(&str path) -> vec[str] @{\n     vec[str] r;\n     file f = open_read(path);\n     for each (str s in lines(f)) @{\n-        vec.append(r,s);\n+        vec::append(r,s);\n     @}\n     ret r;\n @}\n@@ -3368,7 +3342,7 @@ Example of 4 for loops, all identical:\n @example\n let v: vec[foo] = [a, b, c];\n \n-for (foo e in v.(0, _vec.len(v))) @{\n+for (foo e in v.(0, vec::len(v))) @{\n     bar(e);\n @}\n \n@@ -3400,8 +3374,8 @@ Example of a foreach loop:\n @example\n let txt: str;\n let lines: vec[str];\n-for each (str s in _str.split(txt, \"\\n\")) @{\n-    vec.push(lines, s);\n+for each (str s in str::split(txt, \"\\n\")) @{\n+    vec::push(lines, s);\n @}\n @end example\n \n@@ -3477,7 +3451,7 @@ let strs: vec[str];\n \n alt @{\n     case (str s <- p) @{\n-        vec.append(strs, s);\n+        vec::append(strs, s);\n     @}\n     case (c <| x) @{\n         x++;\n@@ -3762,16 +3736,16 @@ expressions can be enabled or disabled via a two-dimensional filtering process:\n By Item\n \n Each @emph{item} (module, function, iterator, object, type) in Rust has a\n-static name-path within its crate module, and can have logging enabled or\n-disabled on a name-path-prefix basis.\n+static path within its crate module, and can have logging enabled or\n+disabled on a path-prefix basis.\n \n @sp 1\n @item\n By Task\n \n-Each @emph{task} in a running Rust program has a unique ownership-path through\n-the task ownership tree, and can have logging enabled or disabled on an\n-ownership-path-prefix basis.\n+Each @emph{task} in a running Rust program has a unique ownership relation\n+through the task ownership tree, and can have logging enabled or disabled on\n+an ownership-ancestry basis.\n @end itemize\n \n Logging is integrated into the language for efficiency reasons, as well as the"}]}