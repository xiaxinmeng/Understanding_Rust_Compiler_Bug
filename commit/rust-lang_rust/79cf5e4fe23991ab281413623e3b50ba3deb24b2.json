{"sha": "79cf5e4fe23991ab281413623e3b50ba3deb24b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5Y2Y1ZTRmZTIzOTkxYWIyODE0MTM2MjNlM2I1MGJhM2RlYjI0YjI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-04T09:32:29Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-01-04T09:32:29Z"}, "message": "Auto merge of #67788 - cjgillot:delint-day, r=Zoxc\n\nMove early and late lint mechanisms to librustc_lint.\n\nAs requested, split from #67737\n\nr? @Zoxc", "tree": {"sha": "d2fc1b6397090bac9ee3f325625c97973316b42a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d2fc1b6397090bac9ee3f325625c97973316b42a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79cf5e4fe23991ab281413623e3b50ba3deb24b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79cf5e4fe23991ab281413623e3b50ba3deb24b2", "html_url": "https://github.com/rust-lang/rust/commit/79cf5e4fe23991ab281413623e3b50ba3deb24b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79cf5e4fe23991ab281413623e3b50ba3deb24b2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abf2e00e38ad404d563f03acbcf06b08813fd086", "url": "https://api.github.com/repos/rust-lang/rust/commits/abf2e00e38ad404d563f03acbcf06b08813fd086", "html_url": "https://github.com/rust-lang/rust/commit/abf2e00e38ad404d563f03acbcf06b08813fd086"}, {"sha": "1fab03e90810d2290e8632e99f36f553fc717817", "url": "https://api.github.com/repos/rust-lang/rust/commits/1fab03e90810d2290e8632e99f36f553fc717817", "html_url": "https://github.com/rust-lang/rust/commit/1fab03e90810d2290e8632e99f36f553fc717817"}], "stats": {"total": 1955, "additions": 1011, "deletions": 944}, "files": [{"sha": "e1350ad03a10f3406e56558a7bc53a75ac01d1e1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 15, "deletions": 814, "changes": 829, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -17,28 +17,24 @@\n use self::TargetLint::*;\n \n use crate::hir;\n-use crate::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n-use crate::hir::intravisit as hir_visit;\n-use crate::hir::intravisit::Visitor;\n+use crate::hir::def_id::{CrateNum, DefId};\n use crate::hir::map::{definitions::DisambiguatedDefPathData, DefPathData};\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::lint::levels::{LintLevelSets, LintLevelsBuilder};\n-use crate::lint::{EarlyLintPass, EarlyLintPassObject, LateLintPass, LateLintPassObject};\n-use crate::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId, LintPass};\n+use crate::lint::{EarlyLintPassObject, LateLintPassObject};\n+use crate::lint::{FutureIncompatibleInfo, Level, Lint, LintBuffer, LintId};\n use crate::middle::privacy::AccessLevels;\n use crate::session::Session;\n use crate::ty::layout::{LayoutError, LayoutOf, TyLayout};\n use crate::ty::{self, print::Printer, subst::GenericArg, Ty, TyCtxt};\n-use crate::util::common::time;\n use crate::util::nodemap::FxHashMap;\n \n use errors::DiagnosticBuilder;\n-use rustc_data_structures::sync::{self, join, par_iter, ParallelIterator};\n+use rustc_data_structures::sync;\n use rustc_span::{symbol::Symbol, MultiSpan, Span};\n use std::slice;\n use syntax::ast;\n use syntax::util::lev_distance::find_best_match_for_name;\n-use syntax::visit as ast_visit;\n \n use rustc_error_codes::*;\n \n@@ -56,11 +52,11 @@ pub struct LintStore {\n     /// interior mutability, we don't enforce this (and lints should, in theory,\n     /// be compatible with being constructed more than once, though not\n     /// necessarily in a sane manner. This is safe though.)\n-    pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n-    late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub pre_expansion_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    pub early_passes: Vec<Box<dyn Fn() -> EarlyLintPassObject + sync::Send + sync::Sync>>,\n+    pub late_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n     /// This is unique in that we construct them per-module, so not once.\n-    late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n+    pub late_module_passes: Vec<Box<dyn Fn() -> LateLintPassObject + sync::Send + sync::Sync>>,\n \n     /// Lints indexed by name.\n     by_name: FxHashMap<String, TargetLint>,\n@@ -447,20 +443,15 @@ pub struct LateContext<'a, 'tcx> {\n     pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: &'tcx LintStore,\n+    pub lint_store: &'tcx LintStore,\n \n-    last_node_with_lint_attrs: hir::HirId,\n+    pub last_node_with_lint_attrs: hir::HirId,\n \n     /// Generic type parameters in scope for the item we are in.\n     pub generics: Option<&'tcx hir::Generics<'tcx>>,\n \n     /// We are only looking at one module\n-    only_module: bool,\n-}\n-\n-pub struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n-    context: LateContext<'a, 'tcx>,\n-    pass: T,\n+    pub only_module: bool,\n }\n \n /// Context for lint checking of the AST, after expansion, before lowering to\n@@ -472,17 +463,12 @@ pub struct EarlyContext<'a> {\n     /// The crate being checked.\n     pub krate: &'a ast::Crate,\n \n-    builder: LintLevelsBuilder<'a>,\n+    pub builder: LintLevelsBuilder<'a>,\n \n     /// The store of registered lints and the lint levels.\n-    lint_store: &'a LintStore,\n-\n-    buffered: LintBuffer,\n-}\n+    pub lint_store: &'a LintStore,\n \n-pub struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n-    context: EarlyContext<'a>,\n-    pass: T,\n+    pub buffered: LintBuffer,\n }\n \n pub trait LintPassObject: Sized {}\n@@ -567,7 +553,7 @@ pub trait LintContext: Sized {\n }\n \n impl<'a> EarlyContext<'a> {\n-    fn new(\n+    pub fn new(\n         sess: &'a Session,\n         lint_store: &'a LintStore,\n         krate: &'a ast::Crate,\n@@ -584,52 +570,6 @@ impl<'a> EarlyContext<'a> {\n     }\n }\n \n-macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n-}) }\n-\n-macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n-    $cx.pass.$f(&$cx.context, $($args),*);\n-}) }\n-\n-impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n-    fn check_id(&mut self, id: ast::NodeId) {\n-        for early_lint in self.context.buffered.take(id) {\n-            self.context.lookup_and_emit_with_diagnostics(\n-                early_lint.lint_id.lint,\n-                Some(early_lint.span.clone()),\n-                &early_lint.msg,\n-                early_lint.diagnostic,\n-            );\n-        }\n-    }\n-\n-    /// Merge the lints specified by any lint attributes into the\n-    /// current lint context, call the provided function, then reset the\n-    /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: ast::NodeId, attrs: &'a [ast::Attribute], f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let push = self.context.builder.push(attrs, &self.context.lint_store);\n-        self.check_id(id);\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-        self.context.builder.pop(push);\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: enter_attrs({:?})\", attrs);\n-        run_early_pass!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n-        debug!(\"early context: exit_attrs({:?})\", attrs);\n-        run_early_pass!(self, exit_lint_attrs, attrs);\n-    }\n-}\n-\n impl LintContext for LateContext<'_, '_> {\n     type PassObject = LateLintPassObject;\n \n@@ -831,742 +771,3 @@ impl<'a, 'tcx> LayoutOf for LateContext<'a, 'tcx> {\n         self.tcx.layout_of(self.param_env.and(ty))\n     }\n }\n-\n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n-    /// Merge the lints specified by any lint attributes into the\n-    /// current lint context, call the provided function, then reset the\n-    /// lints in effect to their previous state.\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let prev = self.context.last_node_with_lint_attrs;\n-        self.context.last_node_with_lint_attrs = id;\n-        self.enter_attrs(attrs);\n-        f(self);\n-        self.exit_attrs(attrs);\n-        self.context.last_node_with_lint_attrs = prev;\n-    }\n-\n-    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let old_param_env = self.context.param_env;\n-        self.context.param_env =\n-            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n-        f(self);\n-        self.context.param_env = old_param_env;\n-    }\n-\n-    fn process_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n-        lint_callback!(self, check_mod, m, s, n);\n-        hir_visit::walk_mod(self, m, n);\n-        lint_callback!(self, check_mod_post, m, s, n);\n-    }\n-\n-    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: enter_attrs({:?})\", attrs);\n-        lint_callback!(self, enter_lint_attrs, attrs);\n-    }\n-\n-    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n-        debug!(\"late context: exit_attrs({:?})\", attrs);\n-        lint_callback!(self, exit_lint_attrs, attrs);\n-    }\n-}\n-\n-impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n-    for LateContextAndPass<'a, 'tcx, T>\n-{\n-    /// Because lints are scoped lexically, we want to walk nested\n-    /// items in the context of the outer item, so enable\n-    /// deep-walking.\n-    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n-        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n-    }\n-\n-    fn visit_nested_body(&mut self, body: hir::BodyId) {\n-        let old_tables = self.context.tables;\n-        self.context.tables = self.context.tcx.body_tables(body);\n-        let body = self.context.tcx.hir().body(body);\n-        self.visit_body(body);\n-        self.context.tables = old_tables;\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n-            lint_callback!(cx, check_param, param);\n-            hir_visit::walk_param(cx, param);\n-        });\n-    }\n-\n-    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n-        lint_callback!(self, check_body, body);\n-        hir_visit::walk_body(self, body);\n-        lint_callback!(self, check_body_post, body);\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = it.kind.generics();\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n-                lint_callback!(cx, check_item, it);\n-                hir_visit::walk_item(cx, it);\n-                lint_callback!(cx, check_item_post, it);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n-            cx.with_param_env(it.hir_id, |cx| {\n-                lint_callback!(cx, check_foreign_item, it);\n-                hir_visit::walk_foreign_item(cx, it);\n-                lint_callback!(cx, check_foreign_item_post, it);\n-            });\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n-        lint_callback!(self, check_pat, p);\n-        hir_visit::walk_pat(self, p);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n-            lint_callback!(cx, check_expr, e);\n-            hir_visit::walk_expr(cx, e);\n-            lint_callback!(cx, check_expr_post, e);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n-        // statement attributes are actually just attributes on one of\n-        // - item\n-        // - local\n-        // - expression\n-        // so we keep track of lint levels there\n-        lint_callback!(self, check_stmt, s);\n-        hir_visit::walk_stmt(self, s);\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: hir_visit::FnKind<'tcx>,\n-        decl: &'tcx hir::FnDecl<'tcx>,\n-        body_id: hir::BodyId,\n-        span: Span,\n-        id: hir::HirId,\n-    ) {\n-        // Wrap in tables here, not just in visit_nested_body,\n-        // in order for `check_fn` to be able to use them.\n-        let old_tables = self.context.tables;\n-        self.context.tables = self.context.tcx.body_tables(body_id);\n-        let body = self.context.tcx.hir().body(body_id);\n-        lint_callback!(self, check_fn, fk, decl, body, span, id);\n-        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n-        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n-        self.context.tables = old_tables;\n-    }\n-\n-    fn visit_variant_data(\n-        &mut self,\n-        s: &'tcx hir::VariantData<'tcx>,\n-        _: ast::Name,\n-        _: &'tcx hir::Generics<'tcx>,\n-        _: hir::HirId,\n-        _: Span,\n-    ) {\n-        lint_callback!(self, check_struct_def, s);\n-        hir_visit::walk_struct_def(self, s);\n-        lint_callback!(self, check_struct_def_post, s);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n-            lint_callback!(cx, check_struct_field, s);\n-            hir_visit::walk_struct_field(cx, s);\n-        })\n-    }\n-\n-    fn visit_variant(\n-        &mut self,\n-        v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics<'tcx>,\n-        item_id: hir::HirId,\n-    ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            lint_callback!(cx, check_variant, v);\n-            hir_visit::walk_variant(cx, v, g, item_id);\n-            lint_callback!(cx, check_variant_post, v);\n-        })\n-    }\n-\n-    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n-        lint_callback!(self, check_ty, t);\n-        hir_visit::walk_ty(self, t);\n-    }\n-\n-    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n-        lint_callback!(self, check_name, sp, name);\n-    }\n-\n-    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n-        if !self.context.only_module {\n-            self.process_mod(m, s, n);\n-        }\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n-            lint_callback!(cx, check_local, l);\n-            hir_visit::walk_local(cx, l);\n-        })\n-    }\n-\n-    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n-        lint_callback!(self, check_block, b);\n-        hir_visit::walk_block(self, b);\n-        lint_callback!(self, check_block_post, b);\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        lint_callback!(self, check_arm, a);\n-        hir_visit::walk_arm(self, a);\n-    }\n-\n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n-        lint_callback!(self, check_generic_param, p);\n-        hir_visit::walk_generic_param(self, p);\n-    }\n-\n-    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n-        lint_callback!(self, check_generics, g);\n-        hir_visit::walk_generics(self, g);\n-    }\n-\n-    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n-        lint_callback!(self, check_where_predicate, p);\n-        hir_visit::walk_where_predicate(self, p);\n-    }\n-\n-    fn visit_poly_trait_ref(\n-        &mut self,\n-        t: &'tcx hir::PolyTraitRef<'tcx>,\n-        m: hir::TraitBoundModifier,\n-    ) {\n-        lint_callback!(self, check_poly_trait_ref, t, m);\n-        hir_visit::walk_poly_trait_ref(self, t, m);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = Some(&trait_item.generics);\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n-            cx.with_param_env(trait_item.hir_id, |cx| {\n-                lint_callback!(cx, check_trait_item, trait_item);\n-                hir_visit::walk_trait_item(cx, trait_item);\n-                lint_callback!(cx, check_trait_item_post, trait_item);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        let generics = self.context.generics.take();\n-        self.context.generics = Some(&impl_item.generics);\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n-            cx.with_param_env(impl_item.hir_id, |cx| {\n-                lint_callback!(cx, check_impl_item, impl_item);\n-                hir_visit::walk_impl_item(cx, impl_item);\n-                lint_callback!(cx, check_impl_item_post, impl_item);\n-            });\n-        });\n-        self.context.generics = generics;\n-    }\n-\n-    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n-        lint_callback!(self, check_lifetime, lt);\n-        hir_visit::walk_lifetime(self, lt);\n-    }\n-\n-    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n-        lint_callback!(self, check_path, p, id);\n-        hir_visit::walk_path(self, p);\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n-        lint_callback!(self, check_attribute, attr);\n-    }\n-}\n-\n-impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n-    fn visit_param(&mut self, param: &'a ast::Param) {\n-        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n-            run_early_pass!(cx, check_param, param);\n-            ast_visit::walk_param(cx, param);\n-        });\n-    }\n-\n-    fn visit_item(&mut self, it: &'a ast::Item) {\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_pass!(cx, check_item, it);\n-            ast_visit::walk_item(cx, it);\n-            run_early_pass!(cx, check_item_post, it);\n-        })\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n-        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n-            run_early_pass!(cx, check_foreign_item, it);\n-            ast_visit::walk_foreign_item(cx, it);\n-            run_early_pass!(cx, check_foreign_item_post, it);\n-        })\n-    }\n-\n-    fn visit_pat(&mut self, p: &'a ast::Pat) {\n-        run_early_pass!(self, check_pat, p);\n-        self.check_id(p.id);\n-        ast_visit::walk_pat(self, p);\n-        run_early_pass!(self, check_pat_post, p);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'a ast::Expr) {\n-        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n-            run_early_pass!(cx, check_expr, e);\n-            ast_visit::walk_expr(cx, e);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n-        run_early_pass!(self, check_stmt, s);\n-        self.check_id(s.id);\n-        ast_visit::walk_stmt(self, s);\n-    }\n-\n-    fn visit_fn(\n-        &mut self,\n-        fk: ast_visit::FnKind<'a>,\n-        decl: &'a ast::FnDecl,\n-        span: Span,\n-        id: ast::NodeId,\n-    ) {\n-        run_early_pass!(self, check_fn, fk, decl, span, id);\n-        self.check_id(id);\n-        ast_visit::walk_fn(self, fk, decl, span);\n-        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n-    }\n-\n-    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n-        run_early_pass!(self, check_struct_def, s);\n-        if let Some(ctor_hir_id) = s.ctor_id() {\n-            self.check_id(ctor_hir_id);\n-        }\n-        ast_visit::walk_struct_def(self, s);\n-        run_early_pass!(self, check_struct_def_post, s);\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n-        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n-            run_early_pass!(cx, check_struct_field, s);\n-            ast_visit::walk_struct_field(cx, s);\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &'a ast::Variant) {\n-        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n-            run_early_pass!(cx, check_variant, v);\n-            ast_visit::walk_variant(cx, v);\n-            run_early_pass!(cx, check_variant_post, v);\n-        })\n-    }\n-\n-    fn visit_ty(&mut self, t: &'a ast::Ty) {\n-        run_early_pass!(self, check_ty, t);\n-        self.check_id(t.id);\n-        ast_visit::walk_ty(self, t);\n-    }\n-\n-    fn visit_ident(&mut self, ident: ast::Ident) {\n-        run_early_pass!(self, check_ident, ident);\n-    }\n-\n-    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n-        run_early_pass!(self, check_mod, m, s, n);\n-        self.check_id(n);\n-        ast_visit::walk_mod(self, m);\n-        run_early_pass!(self, check_mod_post, m, s, n);\n-    }\n-\n-    fn visit_local(&mut self, l: &'a ast::Local) {\n-        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n-            run_early_pass!(cx, check_local, l);\n-            ast_visit::walk_local(cx, l);\n-        })\n-    }\n-\n-    fn visit_block(&mut self, b: &'a ast::Block) {\n-        run_early_pass!(self, check_block, b);\n-        self.check_id(b.id);\n-        ast_visit::walk_block(self, b);\n-        run_early_pass!(self, check_block_post, b);\n-    }\n-\n-    fn visit_arm(&mut self, a: &'a ast::Arm) {\n-        run_early_pass!(self, check_arm, a);\n-        ast_visit::walk_arm(self, a);\n-    }\n-\n-    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n-        run_early_pass!(self, check_expr_post, e);\n-    }\n-\n-    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n-        run_early_pass!(self, check_generic_param, param);\n-        ast_visit::walk_generic_param(self, param);\n-    }\n-\n-    fn visit_generics(&mut self, g: &'a ast::Generics) {\n-        run_early_pass!(self, check_generics, g);\n-        ast_visit::walk_generics(self, g);\n-    }\n-\n-    fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n-        run_early_pass!(self, check_where_predicate, p);\n-        ast_visit::walk_where_predicate(self, p);\n-    }\n-\n-    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n-        run_early_pass!(self, check_poly_trait_ref, t, m);\n-        ast_visit::walk_poly_trait_ref(self, t, m);\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n-            run_early_pass!(cx, check_trait_item, trait_item);\n-            ast_visit::walk_trait_item(cx, trait_item);\n-            run_early_pass!(cx, check_trait_item_post, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n-        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n-            run_early_pass!(cx, check_impl_item, impl_item);\n-            ast_visit::walk_impl_item(cx, impl_item);\n-            run_early_pass!(cx, check_impl_item_post, impl_item);\n-        });\n-    }\n-\n-    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n-        run_early_pass!(self, check_lifetime, lt);\n-        self.check_id(lt.id);\n-    }\n-\n-    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n-        run_early_pass!(self, check_path, p, id);\n-        self.check_id(id);\n-        ast_visit::walk_path(self, p);\n-    }\n-\n-    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n-        run_early_pass!(self, check_attribute, attr);\n-    }\n-\n-    fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n-        run_early_pass!(self, check_mac_def, mac, id);\n-        self.check_id(id);\n-    }\n-\n-    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n-        // FIXME(#54110): So, this setup isn't really right. I think\n-        // that (a) the libsyntax visitor ought to be doing this as\n-        // part of `walk_mac`, and (b) we should be calling\n-        // `visit_path`, *but* that would require a `NodeId`, and I\n-        // want to get #53686 fixed quickly. -nmatsakis\n-        ast_visit::walk_path(self, &mac.path);\n-\n-        run_early_pass!(self, check_mac, mac);\n-    }\n-}\n-\n-struct LateLintPassObjects<'a> {\n-    lints: &'a mut [LateLintPassObject],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for LateLintPassObjects<'_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! expand_late_lint_pass_impl_methods {\n-    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n-macro_rules! late_lint_pass_impl {\n-    ([], [$hir:tt], $methods:tt) => (\n-        impl LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n-            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n-        }\n-    )\n-}\n-\n-late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n-\n-fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n-    pass: T,\n-) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-\n-    let context = LateContext {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(),\n-        access_levels,\n-        lint_store: &tcx.lint_store,\n-        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n-        generics: None,\n-        only_module: true,\n-    };\n-\n-    let mut cx = LateContextAndPass { context, pass };\n-\n-    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n-    cx.process_mod(module, span, hir_id);\n-\n-    // Visit the crate attributes\n-    if hir_id == hir::CRATE_HIR_ID {\n-        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n-    }\n-}\n-\n-pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    module_def_id: DefId,\n-    builtin_lints: T,\n-) {\n-    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n-        // These passes runs in late_lint_crate with -Z no_interleave_lints\n-        return;\n-    }\n-\n-    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n-\n-    let mut passes: Vec<_> =\n-        tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n-\n-    if !passes.is_empty() {\n-        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n-    }\n-}\n-\n-fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n-    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n-\n-    let krate = tcx.hir().krate();\n-\n-    let context = LateContext {\n-        tcx,\n-        tables: &ty::TypeckTables::empty(None),\n-        param_env: ty::ParamEnv::empty(),\n-        access_levels,\n-        lint_store: &tcx.lint_store,\n-        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n-        generics: None,\n-        only_module: false,\n-    };\n-\n-    let mut cx = LateContextAndPass { context, pass };\n-\n-    // Visit the whole crate.\n-    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        lint_callback!(cx, check_crate, krate);\n-\n-        hir_visit::walk_crate(cx, krate);\n-\n-        lint_callback!(cx, check_crate_post, krate);\n-    })\n-}\n-\n-fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n-    let mut passes = tcx.lint_store.late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n-\n-    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n-        if !passes.is_empty() {\n-            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n-        }\n-\n-        late_lint_pass_crate(tcx, builtin_lints);\n-    } else {\n-        for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n-        }\n-\n-        let mut passes: Vec<_> =\n-            tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n-\n-        for pass in &mut passes {\n-            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n-                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n-            });\n-        }\n-    }\n-}\n-\n-/// Performs lint checking on a crate.\n-pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n-    tcx: TyCtxt<'tcx>,\n-    builtin_lints: impl FnOnce() -> T + Send,\n-) {\n-    join(\n-        || {\n-            time(tcx.sess, \"crate lints\", || {\n-                // Run whole crate non-incremental lints\n-                late_lint_crate(tcx, builtin_lints());\n-            });\n-        },\n-        || {\n-            time(tcx.sess, \"module lints\", || {\n-                // Run per-module lints\n-                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n-                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n-                });\n-            });\n-        },\n-    );\n-}\n-\n-struct EarlyLintPassObjects<'a> {\n-    lints: &'a mut [EarlyLintPassObject],\n-}\n-\n-#[allow(rustc::lint_pass_impl_without_macro)]\n-impl LintPass for EarlyLintPassObjects<'_> {\n-    fn name(&self) -> &'static str {\n-        panic!()\n-    }\n-}\n-\n-macro_rules! expand_early_lint_pass_impl_methods {\n-    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n-        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n-            for obj in self.lints.iter_mut() {\n-                obj.$name(context, $($param),*);\n-            }\n-        })*\n-    )\n-}\n-\n-macro_rules! early_lint_pass_impl {\n-    ([], [$($methods:tt)*]) => (\n-        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n-            expand_early_lint_pass_impl_methods!([$($methods)*]);\n-        }\n-    )\n-}\n-\n-early_lint_methods!(early_lint_pass_impl, []);\n-\n-fn early_lint_crate<T: EarlyLintPass>(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    pass: T,\n-    buffered: LintBuffer,\n-    warn_about_weird_lints: bool,\n-) -> LintBuffer {\n-    let mut cx = EarlyContextAndPass {\n-        context: EarlyContext::new(sess, lint_store, krate, buffered, warn_about_weird_lints),\n-        pass,\n-    };\n-\n-    // Visit the whole crate.\n-    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n-        // since the root module isn't visited as an item (because it isn't an\n-        // item), warn for it here.\n-        run_early_pass!(cx, check_crate, krate);\n-\n-        ast_visit::walk_crate(cx, krate);\n-\n-        run_early_pass!(cx, check_crate_post, krate);\n-    });\n-    cx.context.buffered\n-}\n-\n-pub fn check_ast_crate<T: EarlyLintPass>(\n-    sess: &Session,\n-    lint_store: &LintStore,\n-    krate: &ast::Crate,\n-    pre_expansion: bool,\n-    lint_buffer: Option<LintBuffer>,\n-    builtin_lints: T,\n-) {\n-    let mut passes: Vec<_> = if pre_expansion {\n-        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n-    } else {\n-        lint_store.early_passes.iter().map(|p| (p)()).collect()\n-    };\n-    let mut buffered = lint_buffer.unwrap_or_default();\n-\n-    if !sess.opts.debugging_opts.no_interleave_lints {\n-        buffered =\n-            early_lint_crate(sess, lint_store, krate, builtin_lints, buffered, pre_expansion);\n-\n-        if !passes.is_empty() {\n-            buffered = early_lint_crate(\n-                sess,\n-                lint_store,\n-                krate,\n-                EarlyLintPassObjects { lints: &mut passes[..] },\n-                buffered,\n-                pre_expansion,\n-            );\n-        }\n-    } else {\n-        for pass in &mut passes {\n-            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n-                early_lint_crate(\n-                    sess,\n-                    lint_store,\n-                    krate,\n-                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n-                    buffered,\n-                    pre_expansion,\n-                )\n-            });\n-        }\n-    }\n-\n-    // All of the buffered lints should have been emitted at this point.\n-    // If not, that means that we somehow buffered a lint for a node id\n-    // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n-    //\n-    // Rustdoc runs everybody-loops before the early lints and removes\n-    // function bodies, so it's totally possible for linted\n-    // node ids to not exist (e.g., macros defined within functions for the\n-    // unused_macro lint) anymore. So we only run this check\n-    // when we're not in rustdoc mode. (see issue #47639)\n-    if !sess.opts.actually_rustdoc {\n-        for (_id, lints) in buffered.map {\n-            for early_lint in lints {\n-                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n-            }\n-        }\n-    }\n-}"}, {"sha": "b1894a1f9ba25eb868f30d5dadcdfc782081db72", "filename": "src/librustc/lint/levels.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Flevels.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -155,7 +155,7 @@ pub struct LintLevelsBuilder<'a> {\n \n pub struct BuilderPush {\n     prev: u32,\n-    pub(super) changed: bool,\n+    pub changed: bool,\n }\n \n impl<'a> LintLevelsBuilder<'a> {"}, {"sha": "680fb497e401495ff37c414eaba31541ee281bd4", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 124, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -24,11 +24,8 @@ pub use self::LintSource::*;\n use rustc_data_structures::sync;\n \n use crate::hir;\n-use crate::hir::def_id::{CrateNum, LOCAL_CRATE};\n-use crate::hir::intravisit;\n use crate::lint::builtin::BuiltinLintDiagnostics;\n use crate::session::{DiagnosticMessageId, Session};\n-use crate::ty::query::Providers;\n use crate::ty::TyCtxt;\n use crate::util::nodemap::NodeMap;\n use errors::{DiagnosticBuilder, DiagnosticId};\n@@ -39,8 +36,7 @@ use rustc_span::Span;\n use syntax::ast;\n \n pub use crate::lint::context::{\n-    check_ast_crate, check_crate, late_lint_mod, BufferedEarlyLint, CheckLintNameResult,\n-    EarlyContext, LateContext, LintContext, LintStore,\n+    BufferedEarlyLint, CheckLintNameResult, EarlyContext, LateContext, LintContext, LintStore,\n };\n \n pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n@@ -376,11 +372,11 @@ mod context;\n pub mod internal;\n mod levels;\n \n-pub use self::levels::{LintLevelMap, LintLevelSets};\n+pub use self::levels::{LintLevelMap, LintLevelSets, LintLevelsBuilder};\n \n #[derive(Default)]\n pub struct LintBuffer {\n-    map: NodeMap<Vec<BufferedEarlyLint>>,\n+    pub map: NodeMap<Vec<BufferedEarlyLint>>,\n }\n \n impl LintBuffer {\n@@ -405,7 +401,7 @@ impl LintBuffer {\n         }\n     }\n \n-    fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n+    pub fn take(&mut self, id: ast::NodeId) -> Vec<BufferedEarlyLint> {\n         self.map.remove(&id).unwrap_or_default()\n     }\n \n@@ -564,122 +560,6 @@ pub fn maybe_lint_level_root(tcx: TyCtxt<'_>, id: hir::HirId) -> bool {\n     attrs.iter().any(|attr| Level::from_symbol(attr.name_or_empty()).is_some())\n }\n \n-fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n-    assert_eq!(cnum, LOCAL_CRATE);\n-    let store = &tcx.lint_store;\n-    let mut builder = LintLevelMapBuilder {\n-        levels: LintLevelSets::builder(tcx.sess, false, &store),\n-        tcx: tcx,\n-        store: store,\n-    };\n-    let krate = tcx.hir().krate();\n-\n-    let push = builder.levels.push(&krate.attrs, &store);\n-    builder.levels.register_id(hir::CRATE_HIR_ID);\n-    for macro_def in krate.exported_macros {\n-        builder.levels.register_id(macro_def.hir_id);\n-    }\n-    intravisit::walk_crate(&mut builder, krate);\n-    builder.levels.pop(push);\n-\n-    tcx.arena.alloc(builder.levels.build_map())\n-}\n-\n-struct LintLevelMapBuilder<'a, 'tcx> {\n-    levels: levels::LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-    store: &'a LintStore,\n-}\n-\n-impl LintLevelMapBuilder<'_, '_> {\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &[ast::Attribute], f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let push = self.levels.push(attrs, self.store);\n-        if push.changed {\n-            self.levels.register_id(id);\n-        }\n-        f(self);\n-        self.levels.pop(push);\n-    }\n-}\n-\n-impl intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n-    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n-        intravisit::NestedVisitorMap::All(&self.tcx.hir())\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n-            intravisit::walk_param(builder, param);\n-        });\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n-            intravisit::walk_item(builder, it);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n-            intravisit::walk_foreign_item(builder, it);\n-        })\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n-            intravisit::walk_expr(builder, e);\n-        })\n-    }\n-\n-    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n-            intravisit::walk_struct_field(builder, s);\n-        })\n-    }\n-\n-    fn visit_variant(\n-        &mut self,\n-        v: &'tcx hir::Variant<'tcx>,\n-        g: &'tcx hir::Generics<'tcx>,\n-        item_id: hir::HirId,\n-    ) {\n-        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n-            intravisit::walk_variant(builder, v, g, item_id);\n-        })\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n-            intravisit::walk_local(builder, l);\n-        })\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n-            intravisit::walk_arm(builder, a);\n-        })\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n-            intravisit::walk_trait_item(builder, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n-            intravisit::walk_impl_item(builder, impl_item);\n-        });\n-    }\n-}\n-\n-pub fn provide(providers: &mut Providers<'_>) {\n-    providers.lint_levels = lint_levels;\n-}\n-\n /// Returns whether `span` originates in a foreign crate's external macro.\n ///\n /// This is used to test whether a lint should not even begin to figure out whether it should"}, {"sha": "4de0d358afb09ecdacf611b585a3eab7406d0641", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -231,7 +231,7 @@ fn configure_and_expand_inner<'a>(\n     metadata_loader: &'a MetadataLoaderDyn,\n ) -> Result<(ast::Crate, Resolver<'a>)> {\n     time(sess, \"pre-AST-expansion lint checks\", || {\n-        lint::check_ast_crate(\n+        rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n             &krate,\n@@ -458,7 +458,7 @@ pub fn lower_to_hir<'res, 'tcx>(\n     });\n \n     time(sess, \"early lint checks\", || {\n-        lint::check_ast_crate(\n+        rustc_lint::check_ast_crate(\n             sess,\n             lint_store,\n             &krate,\n@@ -691,7 +691,6 @@ pub fn default_provide(providers: &mut ty::query::Providers<'_>) {\n     rustc_resolve::provide(providers);\n     rustc_traits::provide(providers);\n     rustc_metadata::provide(providers);\n-    lint::provide(providers);\n     rustc_lint::provide(providers);\n     rustc_codegen_utils::provide(providers);\n     rustc_codegen_ssa::provide(providers);\n@@ -885,7 +884,7 @@ fn analysis(tcx: TyCtxt<'_>, cnum: CrateNum) -> Result<()> {\n                     },\n                     {\n                         time(sess, \"lint checking\", || {\n-                            lint::check_crate(tcx, || {\n+                            rustc_lint::check_crate(tcx, || {\n                                 rustc_lint::BuiltinCombinedLateLintPass::new()\n                             });\n                         });"}, {"sha": "482a7822b7679f428b63b4f37df35d8675e46364", "filename": "src/librustc_lint/early.rs", "status": "added", "additions": 383, "deletions": 0, "changes": 383, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fearly.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -0,0 +1,383 @@\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs\n+//! after all other analyses. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an ID of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used.\n+//! A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use rustc::lint::{EarlyContext, LintStore};\n+use rustc::lint::{EarlyLintPass, EarlyLintPassObject};\n+use rustc::lint::{LintBuffer, LintContext, LintPass};\n+use rustc::session::Session;\n+use rustc::util::common::time;\n+\n+use rustc_span::Span;\n+use std::slice;\n+use syntax::ast;\n+use syntax::visit as ast_visit;\n+\n+use log::debug;\n+\n+macro_rules! run_early_pass { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n+struct EarlyContextAndPass<'a, T: EarlyLintPass> {\n+    context: EarlyContext<'a>,\n+    pass: T,\n+}\n+\n+impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n+    fn check_id(&mut self, id: ast::NodeId) {\n+        for early_lint in self.context.buffered.take(id) {\n+            self.context.lookup_and_emit_with_diagnostics(\n+                early_lint.lint_id.lint,\n+                Some(early_lint.span.clone()),\n+                &early_lint.msg,\n+                early_lint.diagnostic,\n+            );\n+        }\n+    }\n+\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n+    fn with_lint_attrs<F>(&mut self, id: ast::NodeId, attrs: &'a [ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let push = self.context.builder.push(attrs, &self.context.lint_store);\n+        self.check_id(id);\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.context.builder.pop(push);\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: enter_attrs({:?})\", attrs);\n+        run_early_pass!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'a [ast::Attribute]) {\n+        debug!(\"early context: exit_attrs({:?})\", attrs);\n+        run_early_pass!(self, exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a, T: EarlyLintPass> ast_visit::Visitor<'a> for EarlyContextAndPass<'a, T> {\n+    fn visit_param(&mut self, param: &'a ast::Param) {\n+        self.with_lint_attrs(param.id, &param.attrs, |cx| {\n+            run_early_pass!(cx, check_param, param);\n+            ast_visit::walk_param(cx, param);\n+        });\n+    }\n+\n+    fn visit_item(&mut self, it: &'a ast::Item) {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+            run_early_pass!(cx, check_item, it);\n+            ast_visit::walk_item(cx, it);\n+            run_early_pass!(cx, check_item_post, it);\n+        })\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'a ast::ForeignItem) {\n+        self.with_lint_attrs(it.id, &it.attrs, |cx| {\n+            run_early_pass!(cx, check_foreign_item, it);\n+            ast_visit::walk_foreign_item(cx, it);\n+            run_early_pass!(cx, check_foreign_item_post, it);\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &'a ast::Pat) {\n+        run_early_pass!(self, check_pat, p);\n+        self.check_id(p.id);\n+        ast_visit::walk_pat(self, p);\n+        run_early_pass!(self, check_pat_post, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'a ast::Expr) {\n+        self.with_lint_attrs(e.id, &e.attrs, |cx| {\n+            run_early_pass!(cx, check_expr, e);\n+            ast_visit::walk_expr(cx, e);\n+        })\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'a ast::Stmt) {\n+        run_early_pass!(self, check_stmt, s);\n+        self.check_id(s.id);\n+        ast_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(\n+        &mut self,\n+        fk: ast_visit::FnKind<'a>,\n+        decl: &'a ast::FnDecl,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n+        run_early_pass!(self, check_fn, fk, decl, span, id);\n+        self.check_id(id);\n+        ast_visit::walk_fn(self, fk, decl, span);\n+        run_early_pass!(self, check_fn_post, fk, decl, span, id);\n+    }\n+\n+    fn visit_variant_data(&mut self, s: &'a ast::VariantData) {\n+        run_early_pass!(self, check_struct_def, s);\n+        if let Some(ctor_hir_id) = s.ctor_id() {\n+            self.check_id(ctor_hir_id);\n+        }\n+        ast_visit::walk_struct_def(self, s);\n+        run_early_pass!(self, check_struct_def_post, s);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'a ast::StructField) {\n+        self.with_lint_attrs(s.id, &s.attrs, |cx| {\n+            run_early_pass!(cx, check_struct_field, s);\n+            ast_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(&mut self, v: &'a ast::Variant) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            run_early_pass!(cx, check_variant, v);\n+            ast_visit::walk_variant(cx, v);\n+            run_early_pass!(cx, check_variant_post, v);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &'a ast::Ty) {\n+        run_early_pass!(self, check_ty, t);\n+        self.check_id(t.id);\n+        ast_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_ident(&mut self, ident: ast::Ident) {\n+        run_early_pass!(self, check_ident, ident);\n+    }\n+\n+    fn visit_mod(&mut self, m: &'a ast::Mod, s: Span, _a: &[ast::Attribute], n: ast::NodeId) {\n+        run_early_pass!(self, check_mod, m, s, n);\n+        self.check_id(n);\n+        ast_visit::walk_mod(self, m);\n+        run_early_pass!(self, check_mod_post, m, s, n);\n+    }\n+\n+    fn visit_local(&mut self, l: &'a ast::Local) {\n+        self.with_lint_attrs(l.id, &l.attrs, |cx| {\n+            run_early_pass!(cx, check_local, l);\n+            ast_visit::walk_local(cx, l);\n+        })\n+    }\n+\n+    fn visit_block(&mut self, b: &'a ast::Block) {\n+        run_early_pass!(self, check_block, b);\n+        self.check_id(b.id);\n+        ast_visit::walk_block(self, b);\n+        run_early_pass!(self, check_block_post, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'a ast::Arm) {\n+        run_early_pass!(self, check_arm, a);\n+        ast_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_expr_post(&mut self, e: &'a ast::Expr) {\n+        run_early_pass!(self, check_expr_post, e);\n+    }\n+\n+    fn visit_generic_param(&mut self, param: &'a ast::GenericParam) {\n+        run_early_pass!(self, check_generic_param, param);\n+        ast_visit::walk_generic_param(self, param);\n+    }\n+\n+    fn visit_generics(&mut self, g: &'a ast::Generics) {\n+        run_early_pass!(self, check_generics, g);\n+        ast_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'a ast::WherePredicate) {\n+        run_early_pass!(self, check_where_predicate, p);\n+        ast_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(&mut self, t: &'a ast::PolyTraitRef, m: &'a ast::TraitBoundModifier) {\n+        run_early_pass!(self, check_poly_trait_ref, t, m);\n+        ast_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'a ast::AssocItem) {\n+        self.with_lint_attrs(trait_item.id, &trait_item.attrs, |cx| {\n+            run_early_pass!(cx, check_trait_item, trait_item);\n+            ast_visit::walk_trait_item(cx, trait_item);\n+            run_early_pass!(cx, check_trait_item_post, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'a ast::AssocItem) {\n+        self.with_lint_attrs(impl_item.id, &impl_item.attrs, |cx| {\n+            run_early_pass!(cx, check_impl_item, impl_item);\n+            ast_visit::walk_impl_item(cx, impl_item);\n+            run_early_pass!(cx, check_impl_item_post, impl_item);\n+        });\n+    }\n+\n+    fn visit_lifetime(&mut self, lt: &'a ast::Lifetime) {\n+        run_early_pass!(self, check_lifetime, lt);\n+        self.check_id(lt.id);\n+    }\n+\n+    fn visit_path(&mut self, p: &'a ast::Path, id: ast::NodeId) {\n+        run_early_pass!(self, check_path, p, id);\n+        self.check_id(id);\n+        ast_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &'a ast::Attribute) {\n+        run_early_pass!(self, check_attribute, attr);\n+    }\n+\n+    fn visit_mac_def(&mut self, mac: &'a ast::MacroDef, id: ast::NodeId) {\n+        run_early_pass!(self, check_mac_def, mac, id);\n+        self.check_id(id);\n+    }\n+\n+    fn visit_mac(&mut self, mac: &'a ast::Mac) {\n+        // FIXME(#54110): So, this setup isn't really right. I think\n+        // that (a) the libsyntax visitor ought to be doing this as\n+        // part of `walk_mac`, and (b) we should be calling\n+        // `visit_path`, *but* that would require a `NodeId`, and I\n+        // want to get #53686 fixed quickly. -nmatsakis\n+        ast_visit::walk_path(self, &mac.path);\n+\n+        run_early_pass!(self, check_mac, mac);\n+    }\n+}\n+\n+struct EarlyLintPassObjects<'a> {\n+    lints: &'a mut [EarlyLintPassObject],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for EarlyLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_early_lint_pass_impl_methods {\n+    ([$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &EarlyContext<'_>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! early_lint_pass_impl {\n+    ([], [$($methods:tt)*]) => (\n+        impl EarlyLintPass for EarlyLintPassObjects<'_> {\n+            expand_early_lint_pass_impl_methods!([$($methods)*]);\n+        }\n+    )\n+}\n+\n+early_lint_methods!(early_lint_pass_impl, []);\n+\n+fn early_lint_crate<T: EarlyLintPass>(\n+    sess: &Session,\n+    lint_store: &LintStore,\n+    krate: &ast::Crate,\n+    pass: T,\n+    buffered: LintBuffer,\n+    warn_about_weird_lints: bool,\n+) -> LintBuffer {\n+    let mut cx = EarlyContextAndPass {\n+        context: EarlyContext::new(sess, lint_store, krate, buffered, warn_about_weird_lints),\n+        pass,\n+    };\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(ast::CRATE_NODE_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        run_early_pass!(cx, check_crate, krate);\n+\n+        ast_visit::walk_crate(cx, krate);\n+\n+        run_early_pass!(cx, check_crate_post, krate);\n+    });\n+    cx.context.buffered\n+}\n+\n+pub fn check_ast_crate<T: EarlyLintPass>(\n+    sess: &Session,\n+    lint_store: &LintStore,\n+    krate: &ast::Crate,\n+    pre_expansion: bool,\n+    lint_buffer: Option<LintBuffer>,\n+    builtin_lints: T,\n+) {\n+    let mut passes: Vec<_> = if pre_expansion {\n+        lint_store.pre_expansion_passes.iter().map(|p| (p)()).collect()\n+    } else {\n+        lint_store.early_passes.iter().map(|p| (p)()).collect()\n+    };\n+    let mut buffered = lint_buffer.unwrap_or_default();\n+\n+    if !sess.opts.debugging_opts.no_interleave_lints {\n+        buffered =\n+            early_lint_crate(sess, lint_store, krate, builtin_lints, buffered, pre_expansion);\n+\n+        if !passes.is_empty() {\n+            buffered = early_lint_crate(\n+                sess,\n+                lint_store,\n+                krate,\n+                EarlyLintPassObjects { lints: &mut passes[..] },\n+                buffered,\n+                pre_expansion,\n+            );\n+        }\n+    } else {\n+        for pass in &mut passes {\n+            buffered = time(sess, &format!(\"running lint: {}\", pass.name()), || {\n+                early_lint_crate(\n+                    sess,\n+                    lint_store,\n+                    krate,\n+                    EarlyLintPassObjects { lints: slice::from_mut(pass) },\n+                    buffered,\n+                    pre_expansion,\n+                )\n+            });\n+        }\n+    }\n+\n+    // All of the buffered lints should have been emitted at this point.\n+    // If not, that means that we somehow buffered a lint for a node id\n+    // that was not lint-checked (perhaps it doesn't exist?). This is a bug.\n+    //\n+    // Rustdoc runs everybody-loops before the early lints and removes\n+    // function bodies, so it's totally possible for linted\n+    // node ids to not exist (e.g., macros defined within functions for the\n+    // unused_macro lint) anymore. So we only run this check\n+    // when we're not in rustdoc mode. (see issue #47639)\n+    if !sess.opts.actually_rustdoc {\n+        for (_id, lints) in buffered.map {\n+            for early_lint in lints {\n+                sess.delay_span_bug(early_lint.span, \"failed to process buffered lint here\");\n+            }\n+        }\n+    }\n+}"}, {"sha": "1248cfd3bc26910adb65021ce665dfdddac0f737", "filename": "src/librustc_lint/late.rs", "status": "added", "additions": 473, "deletions": 0, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -0,0 +1,473 @@\n+//! Implementation of lint checking.\n+//!\n+//! The lint checking is mostly consolidated into one pass which runs\n+//! after all other analyses. Throughout compilation, lint warnings\n+//! can be added via the `add_lint` method on the Session structure. This\n+//! requires a span and an ID of the node that the lint is being added to. The\n+//! lint isn't actually emitted at that time because it is unknown what the\n+//! actual lint level at that location is.\n+//!\n+//! To actually emit lint warnings/errors, a separate pass is used.\n+//! A context keeps track of the current state of all lint levels.\n+//! Upon entering a node of the ast which can modify the lint settings, the\n+//! previous lint state is pushed onto a stack and the ast is then recursed\n+//! upon. As the ast is traversed, this keeps track of the current lint level\n+//! for all lint attributes.\n+\n+use rustc::hir;\n+use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc::hir::intravisit as hir_visit;\n+use rustc::hir::intravisit::Visitor;\n+use rustc::lint::LateContext;\n+use rustc::lint::LintPass;\n+use rustc::lint::{LateLintPass, LateLintPassObject};\n+use rustc::ty::{self, TyCtxt};\n+use rustc::util::common::time;\n+\n+use rustc_data_structures::sync::{join, par_iter, ParallelIterator};\n+use rustc_span::Span;\n+use std::slice;\n+use syntax::ast;\n+\n+use log::debug;\n+use syntax::walk_list;\n+\n+macro_rules! lint_callback { ($cx:expr, $f:ident, $($args:expr),*) => ({\n+    $cx.pass.$f(&$cx.context, $($args),*);\n+}) }\n+\n+struct LateContextAndPass<'a, 'tcx, T: LateLintPass<'a, 'tcx>> {\n+    context: LateContext<'a, 'tcx>,\n+    pass: T,\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> LateContextAndPass<'a, 'tcx, T> {\n+    /// Merge the lints specified by any lint attributes into the\n+    /// current lint context, call the provided function, then reset the\n+    /// lints in effect to their previous state.\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &'tcx [ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let prev = self.context.last_node_with_lint_attrs;\n+        self.context.last_node_with_lint_attrs = id;\n+        self.enter_attrs(attrs);\n+        f(self);\n+        self.exit_attrs(attrs);\n+        self.context.last_node_with_lint_attrs = prev;\n+    }\n+\n+    fn with_param_env<F>(&mut self, id: hir::HirId, f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let old_param_env = self.context.param_env;\n+        self.context.param_env =\n+            self.context.tcx.param_env(self.context.tcx.hir().local_def_id(id));\n+        f(self);\n+        self.context.param_env = old_param_env;\n+    }\n+\n+    fn process_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n+        lint_callback!(self, check_mod, m, s, n);\n+        hir_visit::walk_mod(self, m, n);\n+        lint_callback!(self, check_mod_post, m, s, n);\n+    }\n+\n+    fn enter_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: enter_attrs({:?})\", attrs);\n+        lint_callback!(self, enter_lint_attrs, attrs);\n+    }\n+\n+    fn exit_attrs(&mut self, attrs: &'tcx [ast::Attribute]) {\n+        debug!(\"late context: exit_attrs({:?})\", attrs);\n+        lint_callback!(self, exit_lint_attrs, attrs);\n+    }\n+}\n+\n+impl<'a, 'tcx, T: LateLintPass<'a, 'tcx>> hir_visit::Visitor<'tcx>\n+    for LateContextAndPass<'a, 'tcx, T>\n+{\n+    /// Because lints are scoped lexically, we want to walk nested\n+    /// items in the context of the outer item, so enable\n+    /// deep-walking.\n+    fn nested_visit_map<'this>(&'this mut self) -> hir_visit::NestedVisitorMap<'this, 'tcx> {\n+        hir_visit::NestedVisitorMap::All(&self.context.tcx.hir())\n+    }\n+\n+    fn visit_nested_body(&mut self, body: hir::BodyId) {\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body);\n+        let body = self.context.tcx.hir().body(body);\n+        self.visit_body(body);\n+        self.context.tables = old_tables;\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |cx| {\n+            lint_callback!(cx, check_param, param);\n+            hir_visit::walk_param(cx, param);\n+        });\n+    }\n+\n+    fn visit_body(&mut self, body: &'tcx hir::Body<'tcx>) {\n+        lint_callback!(self, check_body, body);\n+        hir_visit::walk_body(self, body);\n+        lint_callback!(self, check_body_post, body);\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = it.kind.generics();\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n+                lint_callback!(cx, check_item, it);\n+                hir_visit::walk_item(cx, it);\n+                lint_callback!(cx, check_item_post, it);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |cx| {\n+            cx.with_param_env(it.hir_id, |cx| {\n+                lint_callback!(cx, check_foreign_item, it);\n+                hir_visit::walk_foreign_item(cx, it);\n+                lint_callback!(cx, check_foreign_item_post, it);\n+            });\n+        })\n+    }\n+\n+    fn visit_pat(&mut self, p: &'tcx hir::Pat<'tcx>) {\n+        lint_callback!(self, check_pat, p);\n+        hir_visit::walk_pat(self, p);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |cx| {\n+            lint_callback!(cx, check_expr, e);\n+            hir_visit::walk_expr(cx, e);\n+            lint_callback!(cx, check_expr_post, e);\n+        })\n+    }\n+\n+    fn visit_stmt(&mut self, s: &'tcx hir::Stmt<'tcx>) {\n+        // statement attributes are actually just attributes on one of\n+        // - item\n+        // - local\n+        // - expression\n+        // so we keep track of lint levels there\n+        lint_callback!(self, check_stmt, s);\n+        hir_visit::walk_stmt(self, s);\n+    }\n+\n+    fn visit_fn(\n+        &mut self,\n+        fk: hir_visit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl<'tcx>,\n+        body_id: hir::BodyId,\n+        span: Span,\n+        id: hir::HirId,\n+    ) {\n+        // Wrap in tables here, not just in visit_nested_body,\n+        // in order for `check_fn` to be able to use them.\n+        let old_tables = self.context.tables;\n+        self.context.tables = self.context.tcx.body_tables(body_id);\n+        let body = self.context.tcx.hir().body(body_id);\n+        lint_callback!(self, check_fn, fk, decl, body, span, id);\n+        hir_visit::walk_fn(self, fk, decl, body_id, span, id);\n+        lint_callback!(self, check_fn_post, fk, decl, body, span, id);\n+        self.context.tables = old_tables;\n+    }\n+\n+    fn visit_variant_data(\n+        &mut self,\n+        s: &'tcx hir::VariantData<'tcx>,\n+        _: ast::Name,\n+        _: &'tcx hir::Generics<'tcx>,\n+        _: hir::HirId,\n+        _: Span,\n+    ) {\n+        lint_callback!(self, check_struct_def, s);\n+        hir_visit::walk_struct_def(self, s);\n+        lint_callback!(self, check_struct_def_post, s);\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |cx| {\n+            lint_callback!(cx, check_struct_field, s);\n+            hir_visit::walk_struct_field(cx, s);\n+        })\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        v: &'tcx hir::Variant<'tcx>,\n+        g: &'tcx hir::Generics<'tcx>,\n+        item_id: hir::HirId,\n+    ) {\n+        self.with_lint_attrs(v.id, &v.attrs, |cx| {\n+            lint_callback!(cx, check_variant, v);\n+            hir_visit::walk_variant(cx, v, g, item_id);\n+            lint_callback!(cx, check_variant_post, v);\n+        })\n+    }\n+\n+    fn visit_ty(&mut self, t: &'tcx hir::Ty<'tcx>) {\n+        lint_callback!(self, check_ty, t);\n+        hir_visit::walk_ty(self, t);\n+    }\n+\n+    fn visit_name(&mut self, sp: Span, name: ast::Name) {\n+        lint_callback!(self, check_name, sp, name);\n+    }\n+\n+    fn visit_mod(&mut self, m: &'tcx hir::Mod<'tcx>, s: Span, n: hir::HirId) {\n+        if !self.context.only_module {\n+            self.process_mod(m, s, n);\n+        }\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |cx| {\n+            lint_callback!(cx, check_local, l);\n+            hir_visit::walk_local(cx, l);\n+        })\n+    }\n+\n+    fn visit_block(&mut self, b: &'tcx hir::Block<'tcx>) {\n+        lint_callback!(self, check_block, b);\n+        hir_visit::walk_block(self, b);\n+        lint_callback!(self, check_block_post, b);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        lint_callback!(self, check_arm, a);\n+        hir_visit::walk_arm(self, a);\n+    }\n+\n+    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n+        lint_callback!(self, check_generic_param, p);\n+        hir_visit::walk_generic_param(self, p);\n+    }\n+\n+    fn visit_generics(&mut self, g: &'tcx hir::Generics<'tcx>) {\n+        lint_callback!(self, check_generics, g);\n+        hir_visit::walk_generics(self, g);\n+    }\n+\n+    fn visit_where_predicate(&mut self, p: &'tcx hir::WherePredicate<'tcx>) {\n+        lint_callback!(self, check_where_predicate, p);\n+        hir_visit::walk_where_predicate(self, p);\n+    }\n+\n+    fn visit_poly_trait_ref(\n+        &mut self,\n+        t: &'tcx hir::PolyTraitRef<'tcx>,\n+        m: hir::TraitBoundModifier,\n+    ) {\n+        lint_callback!(self, check_poly_trait_ref, t, m);\n+        hir_visit::walk_poly_trait_ref(self, t, m);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&trait_item.generics);\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |cx| {\n+            cx.with_param_env(trait_item.hir_id, |cx| {\n+                lint_callback!(cx, check_trait_item, trait_item);\n+                hir_visit::walk_trait_item(cx, trait_item);\n+                lint_callback!(cx, check_trait_item_post, trait_item);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        let generics = self.context.generics.take();\n+        self.context.generics = Some(&impl_item.generics);\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |cx| {\n+            cx.with_param_env(impl_item.hir_id, |cx| {\n+                lint_callback!(cx, check_impl_item, impl_item);\n+                hir_visit::walk_impl_item(cx, impl_item);\n+                lint_callback!(cx, check_impl_item_post, impl_item);\n+            });\n+        });\n+        self.context.generics = generics;\n+    }\n+\n+    fn visit_lifetime(&mut self, lt: &'tcx hir::Lifetime) {\n+        lint_callback!(self, check_lifetime, lt);\n+        hir_visit::walk_lifetime(self, lt);\n+    }\n+\n+    fn visit_path(&mut self, p: &'tcx hir::Path<'tcx>, id: hir::HirId) {\n+        lint_callback!(self, check_path, p, id);\n+        hir_visit::walk_path(self, p);\n+    }\n+\n+    fn visit_attribute(&mut self, attr: &'tcx ast::Attribute) {\n+        lint_callback!(self, check_attribute, attr);\n+    }\n+}\n+\n+struct LateLintPassObjects<'a> {\n+    lints: &'a mut [LateLintPassObject],\n+}\n+\n+#[allow(rustc::lint_pass_impl_without_macro)]\n+impl LintPass for LateLintPassObjects<'_> {\n+    fn name(&self) -> &'static str {\n+        panic!()\n+    }\n+}\n+\n+macro_rules! expand_late_lint_pass_impl_methods {\n+    ([$a:tt, $hir:tt], [$($(#[$attr:meta])* fn $name:ident($($param:ident: $arg:ty),*);)*]) => (\n+        $(fn $name(&mut self, context: &LateContext<$a, $hir>, $($param: $arg),*) {\n+            for obj in self.lints.iter_mut() {\n+                obj.$name(context, $($param),*);\n+            }\n+        })*\n+    )\n+}\n+\n+macro_rules! late_lint_pass_impl {\n+    ([], [$hir:tt], $methods:tt) => (\n+        impl<'a, $hir> LateLintPass<'a, $hir> for LateLintPassObjects<'_> {\n+            expand_late_lint_pass_impl_methods!(['a, $hir], $methods);\n+        }\n+    )\n+}\n+\n+late_lint_methods!(late_lint_pass_impl, [], ['tcx]);\n+\n+fn late_lint_mod_pass<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    module_def_id: DefId,\n+    pass: T,\n+) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: &tcx.lint_store,\n+        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id).unwrap(),\n+        generics: None,\n+        only_module: true,\n+    };\n+\n+    let mut cx = LateContextAndPass { context, pass };\n+\n+    let (module, span, hir_id) = tcx.hir().get_module(module_def_id);\n+    cx.process_mod(module, span, hir_id);\n+\n+    // Visit the crate attributes\n+    if hir_id == hir::CRATE_HIR_ID {\n+        walk_list!(cx, visit_attribute, tcx.hir().attrs(hir::CRATE_HIR_ID));\n+    }\n+}\n+\n+pub fn late_lint_mod<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    module_def_id: DefId,\n+    builtin_lints: T,\n+) {\n+    if tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        // These passes runs in late_lint_crate with -Z no_interleave_lints\n+        return;\n+    }\n+\n+    late_lint_mod_pass(tcx, module_def_id, builtin_lints);\n+\n+    let mut passes: Vec<_> =\n+        tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+\n+    if !passes.is_empty() {\n+        late_lint_mod_pass(tcx, module_def_id, LateLintPassObjects { lints: &mut passes[..] });\n+    }\n+}\n+\n+fn late_lint_pass_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, pass: T) {\n+    let access_levels = &tcx.privacy_access_levels(LOCAL_CRATE);\n+\n+    let krate = tcx.hir().krate();\n+\n+    let context = LateContext {\n+        tcx,\n+        tables: &ty::TypeckTables::empty(None),\n+        param_env: ty::ParamEnv::empty(),\n+        access_levels,\n+        lint_store: &tcx.lint_store,\n+        last_node_with_lint_attrs: hir::CRATE_HIR_ID,\n+        generics: None,\n+        only_module: false,\n+    };\n+\n+    let mut cx = LateContextAndPass { context, pass };\n+\n+    // Visit the whole crate.\n+    cx.with_lint_attrs(hir::CRATE_HIR_ID, &krate.attrs, |cx| {\n+        // since the root module isn't visited as an item (because it isn't an\n+        // item), warn for it here.\n+        lint_callback!(cx, check_crate, krate);\n+\n+        hir_visit::walk_crate(cx, krate);\n+\n+        lint_callback!(cx, check_crate_post, krate);\n+    })\n+}\n+\n+fn late_lint_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(tcx: TyCtxt<'tcx>, builtin_lints: T) {\n+    let mut passes = tcx.lint_store.late_passes.iter().map(|p| (p)()).collect::<Vec<_>>();\n+\n+    if !tcx.sess.opts.debugging_opts.no_interleave_lints {\n+        if !passes.is_empty() {\n+            late_lint_pass_crate(tcx, LateLintPassObjects { lints: &mut passes[..] });\n+        }\n+\n+        late_lint_pass_crate(tcx, builtin_lints);\n+    } else {\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+\n+        let mut passes: Vec<_> =\n+            tcx.lint_store.late_module_passes.iter().map(|pass| (pass)()).collect();\n+\n+        for pass in &mut passes {\n+            time(tcx.sess, &format!(\"running late module lint: {}\", pass.name()), || {\n+                late_lint_pass_crate(tcx, LateLintPassObjects { lints: slice::from_mut(pass) });\n+            });\n+        }\n+    }\n+}\n+\n+/// Performs lint checking on a crate.\n+pub fn check_crate<'tcx, T: for<'a> LateLintPass<'a, 'tcx>>(\n+    tcx: TyCtxt<'tcx>,\n+    builtin_lints: impl FnOnce() -> T + Send,\n+) {\n+    join(\n+        || {\n+            time(tcx.sess, \"crate lints\", || {\n+                // Run whole crate non-incremental lints\n+                late_lint_crate(tcx, builtin_lints());\n+            });\n+        },\n+        || {\n+            time(tcx.sess, \"module lints\", || {\n+                // Run per-module lints\n+                par_iter(&tcx.hir().krate().modules).for_each(|(&module, _)| {\n+                    tcx.ensure().lint_mod(tcx.hir().local_def_id(module));\n+                });\n+            });\n+        },\n+    );\n+}"}, {"sha": "c148d39c80c513a11e9e03fffa97208e5d782a7e", "filename": "src/librustc_lint/levels.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -0,0 +1,125 @@\n+use rustc::hir;\n+use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n+use rustc::hir::intravisit;\n+use rustc::lint::{LintLevelMap, LintLevelSets, LintLevelsBuilder, LintStore};\n+use rustc::ty::query::Providers;\n+use rustc::ty::TyCtxt;\n+use syntax::ast;\n+\n+pub use rustc_session::lint::{FutureIncompatibleInfo, Level, Lint, LintId};\n+\n+fn lint_levels(tcx: TyCtxt<'_>, cnum: CrateNum) -> &LintLevelMap {\n+    assert_eq!(cnum, LOCAL_CRATE);\n+    let store = &tcx.lint_store;\n+    let mut builder = LintLevelMapBuilder {\n+        levels: LintLevelSets::builder(tcx.sess, false, &store),\n+        tcx: tcx,\n+        store: store,\n+    };\n+    let krate = tcx.hir().krate();\n+\n+    let push = builder.levels.push(&krate.attrs, &store);\n+    builder.levels.register_id(hir::CRATE_HIR_ID);\n+    for macro_def in krate.exported_macros {\n+        builder.levels.register_id(macro_def.hir_id);\n+    }\n+    intravisit::walk_crate(&mut builder, krate);\n+    builder.levels.pop(push);\n+\n+    tcx.arena.alloc(builder.levels.build_map())\n+}\n+\n+struct LintLevelMapBuilder<'a, 'tcx> {\n+    levels: LintLevelsBuilder<'tcx>,\n+    tcx: TyCtxt<'tcx>,\n+    store: &'a LintStore,\n+}\n+\n+impl LintLevelMapBuilder<'_, '_> {\n+    fn with_lint_attrs<F>(&mut self, id: hir::HirId, attrs: &[ast::Attribute], f: F)\n+    where\n+        F: FnOnce(&mut Self),\n+    {\n+        let push = self.levels.push(attrs, self.store);\n+        if push.changed {\n+            self.levels.register_id(id);\n+        }\n+        f(self);\n+        self.levels.pop(push);\n+    }\n+}\n+\n+impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'_, 'tcx> {\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.tcx.hir())\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.with_lint_attrs(param.hir_id, &param.attrs, |builder| {\n+            intravisit::walk_param(builder, param);\n+        });\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+            intravisit::walk_item(builder, it);\n+        });\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.with_lint_attrs(it.hir_id, &it.attrs, |builder| {\n+            intravisit::walk_foreign_item(builder, it);\n+        })\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.with_lint_attrs(e.hir_id, &e.attrs, |builder| {\n+            intravisit::walk_expr(builder, e);\n+        })\n+    }\n+\n+    fn visit_struct_field(&mut self, s: &'tcx hir::StructField<'tcx>) {\n+        self.with_lint_attrs(s.hir_id, &s.attrs, |builder| {\n+            intravisit::walk_struct_field(builder, s);\n+        })\n+    }\n+\n+    fn visit_variant(\n+        &mut self,\n+        v: &'tcx hir::Variant<'tcx>,\n+        g: &'tcx hir::Generics<'tcx>,\n+        item_id: hir::HirId,\n+    ) {\n+        self.with_lint_attrs(v.id, &v.attrs, |builder| {\n+            intravisit::walk_variant(builder, v, g, item_id);\n+        })\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.with_lint_attrs(l.hir_id, &l.attrs, |builder| {\n+            intravisit::walk_local(builder, l);\n+        })\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        self.with_lint_attrs(a.hir_id, &a.attrs, |builder| {\n+            intravisit::walk_arm(builder, a);\n+        })\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        self.with_lint_attrs(trait_item.hir_id, &trait_item.attrs, |builder| {\n+            intravisit::walk_trait_item(builder, trait_item);\n+        });\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        self.with_lint_attrs(impl_item.hir_id, &impl_item.attrs, |builder| {\n+            intravisit::walk_impl_item(builder, impl_item);\n+        });\n+    }\n+}\n+\n+pub fn provide(providers: &mut Providers<'_>) {\n+    providers.lint_levels = lint_levels;\n+}"}, {"sha": "2a3b90f8c93b41f0e14f56556e3b4c1dab219fd6", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79cf5e4fe23991ab281413623e3b50ba3deb24b2/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=79cf5e4fe23991ab281413623e3b50ba3deb24b2", "patch": "@@ -24,6 +24,9 @@ extern crate rustc_session;\n \n mod array_into_iter;\n pub mod builtin;\n+mod early;\n+mod late;\n+mod levels;\n mod non_ascii_idents;\n mod nonstandard_style;\n mod redundant_semicolon;\n@@ -57,13 +60,16 @@ use unused::*;\n \n /// Useful for other parts of the compiler.\n pub use builtin::SoftLints;\n+pub use early::check_ast_crate;\n+pub use late::check_crate;\n \n pub fn provide(providers: &mut Providers<'_>) {\n+    levels::provide(providers);\n     *providers = Providers { lint_mod, ..*providers };\n }\n \n fn lint_mod(tcx: TyCtxt<'_>, module_def_id: DefId) {\n-    lint::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n+    late::late_lint_mod(tcx, module_def_id, BuiltinCombinedModuleLateLintPass::new());\n }\n \n macro_rules! pre_expansion_lint_passes {"}]}