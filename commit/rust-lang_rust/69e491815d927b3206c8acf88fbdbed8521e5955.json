{"sha": "69e491815d927b3206c8acf88fbdbed8521e5955", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5ZTQ5MTgxNWQ5MjdiMzIwNmM4YWNmODhmYmRiZWQ4NTIxZTU5NTU=", "commit": {"author": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2019-01-09T03:13:50Z"}, "committer": {"name": "Blitzerr", "email": "rusty.blitzerr@gmail.com", "date": "2019-01-09T03:19:34Z"}, "message": "addressing Niko's comments", "tree": {"sha": "3b7c9465b7c5b57d66e6314ee99a144c3d1cd468", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b7c9465b7c5b57d66e6314ee99a144c3d1cd468"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69e491815d927b3206c8acf88fbdbed8521e5955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69e491815d927b3206c8acf88fbdbed8521e5955", "html_url": "https://github.com/rust-lang/rust/commit/69e491815d927b3206c8acf88fbdbed8521e5955", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69e491815d927b3206c8acf88fbdbed8521e5955/comments", "author": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "blitzerr", "id": 28721905, "node_id": "MDQ6VXNlcjI4NzIxOTA1", "avatar_url": "https://avatars.githubusercontent.com/u/28721905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/blitzerr", "html_url": "https://github.com/blitzerr", "followers_url": "https://api.github.com/users/blitzerr/followers", "following_url": "https://api.github.com/users/blitzerr/following{/other_user}", "gists_url": "https://api.github.com/users/blitzerr/gists{/gist_id}", "starred_url": "https://api.github.com/users/blitzerr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/blitzerr/subscriptions", "organizations_url": "https://api.github.com/users/blitzerr/orgs", "repos_url": "https://api.github.com/users/blitzerr/repos", "events_url": "https://api.github.com/users/blitzerr/events{/privacy}", "received_events_url": "https://api.github.com/users/blitzerr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "url": "https://api.github.com/repos/rust-lang/rust/commits/15d8e8fb2b5ae3c1493b82077a2c5d3252926227", "html_url": "https://github.com/rust-lang/rust/commit/15d8e8fb2b5ae3c1493b82077a2c5d3252926227"}], "stats": {"total": 86, "additions": 45, "deletions": 41}, "files": [{"sha": "65ae111fbc0fcba1bf6b93c25aa565d671ea53b4", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/69e491815d927b3206c8acf88fbdbed8521e5955/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e491815d927b3206c8acf88fbdbed8521e5955/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=69e491815d927b3206c8acf88fbdbed8521e5955", "patch": "@@ -647,42 +647,46 @@ fn construct_fn<'a, 'gcx, 'tcx, A>(hir: Cx<'a, 'gcx, 'tcx>,\n     let fn_def_id = tcx_hir.local_def_id(fn_id);\n \n     // Gather the upvars of a closure, if any.\n-    let upvar_decls: Vec<_> = match hir_tables.upvar_list.get(&fn_def_id) {\n-        Some(upvars) => upvars\n-            .iter()\n-            .map(|upvar_id| {\n-                let var_hir_id = upvar_id.var_path.hir_id;\n-                let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n-                let capture = hir_tables.upvar_capture(*upvar_id);\n-                let by_ref = match capture {\n-                    ty::UpvarCapture::ByValue => false,\n-                    ty::UpvarCapture::ByRef(..) => true,\n-                };\n-                let mut decl = UpvarDecl {\n-                    debug_name: keywords::Invalid.name(),\n-                    var_hir_id: ClearCrossCrate::Set(var_hir_id),\n-                    by_ref,\n-                    mutability: Mutability::Not,\n-                };\n-                if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n-                    if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n-                        decl.debug_name = ident.name;\n-                        if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n-                            if bm == ty::BindByValue(hir::MutMutable) {\n-                                decl.mutability = Mutability::Mut;\n-                            } else {\n-                                decl.mutability = Mutability::Not;\n-                            }\n+    // In analyze_closure() in upvar.rs we gathered a list of upvars used by a\n+    // closure and we stored in a map called upvar_list in TypeckTables indexed\n+    // with the closure's DefId. Here, we run through that vec of UpvarIds for\n+    // the given closure and use the necessary information to create UpvarDecl.\n+    let upvar_decls: Vec<_> = hir_tables\n+        .upvar_list\n+        .get(&fn_def_id)\n+        .into_iter()\n+        .flatten()\n+        .map(|upvar_id| {\n+            let var_hir_id = upvar_id.var_path.hir_id;\n+            let var_node_id = tcx_hir.hir_to_node_id(var_hir_id);\n+            let capture = hir_tables.upvar_capture(*upvar_id);\n+            let by_ref = match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true,\n+            };\n+            let mut decl = UpvarDecl {\n+                debug_name: keywords::Invalid.name(),\n+                var_hir_id: ClearCrossCrate::Set(var_hir_id),\n+                by_ref,\n+                mutability: Mutability::Not,\n+            };\n+            if let Some(Node::Binding(pat)) = tcx_hir.find(var_node_id) {\n+                if let hir::PatKind::Binding(_, _, ident, _) = pat.node {\n+                    decl.debug_name = ident.name;\n+                    if let Some(&bm) = hir.tables.pat_binding_modes().get(pat.hir_id) {\n+                        if bm == ty::BindByValue(hir::MutMutable) {\n+                            decl.mutability = Mutability::Mut;\n                         } else {\n-                            tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n+                            decl.mutability = Mutability::Not;\n                         }\n+                    } else {\n+                        tcx.sess.delay_span_bug(pat.span, \"missing binding mode\");\n                     }\n                 }\n-                decl\n-            })\n-            .collect(),\n-        _ => vec![],\n-    };\n+            }\n+            decl\n+        })\n+        .collect();\n \n     let mut builder = Builder::new(hir,\n         span,"}, {"sha": "c61159eb4948121bb64bcfb2bfd46122a3bf3071", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/69e491815d927b3206c8acf88fbdbed8521e5955/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69e491815d927b3206c8acf88fbdbed8521e5955/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=69e491815d927b3206c8acf88fbdbed8521e5955", "patch": "@@ -20,16 +20,16 @@ use syntax_pos::Span;\n \n ///////////////////////////////////////////////////////////////////////////\n // Entry point\n-/// During type inference, partially inferred types are\n-/// represented using Type variables (ty::Infer). These don't appear in\n-/// the final TypeckTables since all of the types should have been\n-/// inferred once typeck_tables_of is done.\n-/// When type inference is running however, having to update the typeck\n-/// tables every time a new type is inferred would be unreasonably slow,\n-/// so instead all of the replacement happens at the end in\n-/// resolve_type_vars_in_body, which creates a new TypeTables which\n-/// doesn't contain any inference types.\n \n+// During type inference, partially inferred types are\n+// represented using Type variables (ty::Infer). These don't appear in\n+// the final TypeckTables since all of the types should have been\n+// inferred once typeck_tables_of is done.\n+// When type inference is running however, having to update the typeck\n+// tables every time a new type is inferred would be unreasonably slow,\n+// so instead all of the replacement happens at the end in\n+// resolve_type_vars_in_body, which creates a new TypeTables which\n+// doesn't contain any inference types.\n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n     pub fn resolve_type_vars_in_body(&self, body: &'gcx hir::Body) -> &'gcx ty::TypeckTables<'gcx> {\n         let item_id = self.tcx.hir().body_owner(body.id());"}]}