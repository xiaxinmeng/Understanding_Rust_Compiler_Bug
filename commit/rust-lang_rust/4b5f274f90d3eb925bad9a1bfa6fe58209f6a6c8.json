{"sha": "4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRiNWYyNzRmOTBkM2ViOTI1YmFkOWExYmZhNmZlNTgyMDlmNmE2Yzg=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-09-20T17:56:11Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-01-02T22:35:05Z"}, "message": "make evaluation track whether outlives relationships mattered\n\nPreviously, evaluation ignored outlives relationships. Since we using\nevaluation to skip the \"normal\" trait selection (which enforces\noutlives relationships) this led to incorrect results in some cases.", "tree": {"sha": "65b760f0332a30792627a77053b711189bb30ff4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/65b760f0332a30792627a77053b711189bb30ff4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "html_url": "https://github.com/rust-lang/rust/commit/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79efed84a006620c6e4596088074f7ff195580fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/79efed84a006620c6e4596088074f7ff195580fe", "html_url": "https://github.com/rust-lang/rust/commit/79efed84a006620c6e4596088074f7ff195580fe"}], "stats": {"total": 255, "additions": 129, "deletions": 126}, "files": [{"sha": "2eb9f1d67843363b46a18601e0d032b7dad55878", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -1455,7 +1455,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         // rightly refuses to work with inference variables, but\n         // moves_by_default has a cache, which we want to use in other\n         // cases.\n-        !traits::type_known_to_meet_bound(self, param_env, ty, copy_def_id, span)\n+        !traits::type_known_to_meet_bound_modulo_regions(self, param_env, ty, copy_def_id, span)\n     }\n \n     /// Obtains the latest type of the given closure; this may be a"}, {"sha": "219e971b3c9275233eb8e8bb0cdde44c87a95d29", "filename": "src/librustc/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ffulfill.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -282,7 +282,7 @@ impl<'a, 'b, 'gcx, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'b, 'gcx,\n                 if data.is_global() {\n                     // no type variables present, can use evaluation for better caching.\n                     // FIXME: consider caching errors too.\n-                    if self.selcx.infcx().predicate_must_hold(&obligation) {\n+                    if self.selcx.infcx().predicate_must_hold_considering_regions(&obligation) {\n                         debug!(\"selecting trait `{:?}` at depth {} evaluated to holds\",\n                                data, obligation.recursion_depth);\n                         return ProcessResult::Changed(vec![])"}, {"sha": "0377b98d3f863693e62ab670cb9c0de35e02d22a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -628,14 +628,14 @@ pub fn predicates_for_generics<'tcx>(cause: ObligationCause<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-                                                param_env: ty::ParamEnv<'tcx>,\n-                                                ty: Ty<'tcx>,\n-                                                def_id: DefId,\n-                                                span: Span)\n--> bool\n-{\n-    debug!(\"type_known_to_meet_bound(ty={:?}, bound={:?})\",\n+pub fn type_known_to_meet_bound_modulo_regions<'a, 'gcx, 'tcx>(\n+    infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n+    param_env: ty::ParamEnv<'tcx>,\n+    ty: Ty<'tcx>,\n+    def_id: DefId,\n+    span: Span,\n+) -> bool {\n+    debug!(\"type_known_to_meet_bound_modulo_regions(ty={:?}, bound={:?})\",\n            ty,\n            infcx.tcx.item_path_str(def_id));\n \n@@ -650,7 +650,7 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         predicate: trait_ref.to_predicate(),\n     };\n \n-    let result = infcx.predicate_must_hold(&obligation);\n+    let result = infcx.predicate_must_hold_modulo_regions(&obligation);\n     debug!(\"type_known_to_meet_ty={:?} bound={} => {:?}\",\n            ty, infcx.tcx.item_path_str(def_id), result);\n \n@@ -677,13 +677,13 @@ pub fn type_known_to_meet_bound<'a, 'gcx, 'tcx>(infcx: &InferCtxt<'a, 'gcx, 'tcx\n         // assume it is move; linear is always ok.\n         match fulfill_cx.select_all_or_error(infcx) {\n             Ok(()) => {\n-                debug!(\"type_known_to_meet_bound: ty={:?} bound={} success\",\n+                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} success\",\n                        ty,\n                        infcx.tcx.item_path_str(def_id));\n                 true\n             }\n             Err(e) => {\n-                debug!(\"type_known_to_meet_bound: ty={:?} bound={} errors={:?}\",\n+                debug!(\"type_known_to_meet_bound_modulo_regions: ty={:?} bound={} errors={:?}\",\n                        ty,\n                        infcx.tcx.item_path_str(def_id),\n                        e);"}, {"sha": "31342c250e2bdc86e7883c084cedc80c954c7bcb", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -568,7 +568,7 @@ impl<'a, 'tcx> TyCtxt<'a, 'tcx, 'tcx> {\n \n         self.infer_ctxt().enter(|ref infcx| {\n             // the receiver is dispatchable iff the obligation holds\n-            infcx.predicate_must_hold(&obligation)\n+            infcx.predicate_must_hold_modulo_regions(&obligation)\n         })\n     }\n "}, {"sha": "fdae7d833734e5ebc96c264b3d534dd56700f065", "filename": "src/librustc/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -16,11 +16,26 @@ impl<'cx, 'gcx, 'tcx> InferCtxt<'cx, 'gcx, 'tcx> {\n     /// Evaluates whether the predicate can be satisfied in the given\n     /// `ParamEnv`, and returns `false` if not certain. However, this is\n     /// not entirely accurate if inference variables are involved.\n-    pub fn predicate_must_hold(\n+    ///\n+    /// This version may conservatively fail when outlives obligations\n+    /// are required.\n+    pub fn predicate_must_hold_considering_regions(\n         &self,\n         obligation: &PredicateObligation<'tcx>,\n     ) -> bool {\n-        self.evaluate_obligation_no_overflow(obligation) == EvaluationResult::EvaluatedToOk\n+        self.evaluate_obligation_no_overflow(obligation).must_apply_considering_regions()\n+    }\n+\n+    /// Evaluates whether the predicate can be satisfied in the given\n+    /// `ParamEnv`, and returns `false` if not certain. However, this is\n+    /// not entirely accurate if inference variables are involved.\n+    ///\n+    /// This version ignores all outlives constraints.\n+    pub fn predicate_must_hold_modulo_regions(\n+        &self,\n+        obligation: &PredicateObligation<'tcx>,\n+    ) -> bool {\n+        self.evaluate_obligation_no_overflow(obligation).must_apply_modulo_regions()\n     }\n \n     /// Evaluate a given predicate, capturing overflow and propagating it back."}, {"sha": "6b4c3469acd5b006620302fb46f43252681c5b7e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 32, "deletions": 91, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -327,7 +327,8 @@ enum BuiltinImplConditions<'tcx> {\n /// evaluations.\n ///\n /// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n+///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n ///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n ///     - the \"union\" of evaluation results is equal to their maximum -\n ///     all the \"potential success\" candidates can potentially succeed,\n@@ -336,6 +337,8 @@ enum BuiltinImplConditions<'tcx> {\n pub enum EvaluationResult {\n     /// Evaluation successful\n     EvaluatedToOk,\n+    /// Evaluation successful, but there were unevaluated region obligations\n+    EvaluatedToOkModuloRegions,\n     /// Evaluation is known to be ambiguous - it *might* hold for some\n     /// assignment of inference variables, but it might not.\n     ///\n@@ -399,9 +402,23 @@ pub enum EvaluationResult {\n }\n \n impl EvaluationResult {\n+    /// True if this evaluation result is known to apply, even\n+    /// considering outlives constraints.\n+    pub fn must_apply_considering_regions(self) -> bool {\n+        self == EvaluatedToOk\n+    }\n+\n+    /// True if this evaluation result is known to apply, ignoring\n+    /// outlives constraints.\n+    pub fn must_apply_modulo_regions(self) -> bool {\n+        self <= EvaluatedToOkModuloRegions\n+    }\n+\n     pub fn may_apply(self) -> bool {\n         match self {\n-            EvaluatedToOk | EvaluatedToAmbig | EvaluatedToUnknown => true,\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n+                true\n+            }\n \n             EvaluatedToErr | EvaluatedToRecur => false,\n         }\n@@ -411,13 +428,14 @@ impl EvaluationResult {\n         match self {\n             EvaluatedToUnknown | EvaluatedToRecur => true,\n \n-            EvaluatedToOk | EvaluatedToAmbig | EvaluatedToErr => false,\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n         }\n     }\n }\n \n impl_stable_hash_for!(enum self::EvaluationResult {\n     EvaluatedToOk,\n+    EvaluatedToOkModuloRegions,\n     EvaluatedToAmbig,\n     EvaluatedToUnknown,\n     EvaluatedToRecur,\n@@ -686,92 +704,10 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 None => Ok(EvaluatedToAmbig),\n             },\n \n-            ty::Predicate::TypeOutlives(ref binder) => {\n-                assert!(!binder.has_escaping_bound_vars());\n-                // Check if the type has higher-ranked vars.\n-                if binder.skip_binder().0.has_escaping_bound_vars() {\n-                    // If so, this obligation is an error (for now). Eventually we should be\n-                    // able to support additional cases here, like `for<'a> &'a str: 'a`.\n-\n-                    // NOTE: this hack is implemented in both trait fulfillment and\n-                    // evaluation. If you fix it in one place, make sure you fix it\n-                    // in the other.\n-\n-                    // We don't want to allow this sort of reasoning in intercrate\n-                    // mode, for backwards-compatibility reasons.\n-                    if self.intercrate.is_some() {\n-                        Ok(EvaluatedToAmbig)\n-                    } else {\n-                        Ok(EvaluatedToErr)\n-                    }\n-                } else {\n-                    // If the type has no late bound vars, then if we assign all\n-                    // the inference variables in it to be 'static, then the type\n-                    // will be 'static itself.\n-                    //\n-                    // Therefore, `staticize(T): 'a` holds for any `'a`, so this\n-                    // obligation is fulfilled. Because evaluation works with\n-                    // staticized types (yes I know this is involved with #21974),\n-                    // we are 100% OK here.\n-                    Ok(EvaluatedToOk)\n-                }\n-            }\n-\n-            ty::Predicate::RegionOutlives(ref binder) => {\n-                let ty::OutlivesPredicate(r_a, r_b) = binder.skip_binder();\n-\n-                if r_a == r_b {\n-                    // for<'a> 'a: 'a. OK\n-                    Ok(EvaluatedToOk)\n-                } else if **r_a == ty::ReStatic {\n-                    // 'static: 'x always holds.\n-                    //\n-                    // This special case is handled somewhat inconsistently - if we\n-                    // have an inference variable that is supposed to be equal to\n-                    // `'static`, then we don't allow it to be equated to an LBR,\n-                    // but if we have a literal `'static`, then we *do*.\n-                    //\n-                    // This is actually consistent with how our region inference works.\n-                    //\n-                    // It would appear that this sort of inconsistency would\n-                    // cause \"instability\" problems with evaluation caching. However,\n-                    // evaluation caching is only for trait predicates, and when\n-                    // trait predicates create nested obligations, they contain\n-                    // inference variables for all the regions in the trait - the\n-                    // only way this codepath can be reached from trait predicate\n-                    // evaluation is when the user typed an explicit `where 'static: 'a`\n-                    // lifetime bound (in which case we want to return EvaluatedToOk).\n-                    //\n-                    // If we ever want to handle inference variables that might be\n-                    // equatable with ReStatic, we need to make sure we are not confused by\n-                    // technically-allowed-by-RFC-447-but-probably-should-not-be\n-                    // impls such as\n-                    // ```Rust\n-                    // impl<'a, 's, T> X<'s> for T where T: Debug + 'a, 'a: 's\n-                    // ```\n-                    Ok(EvaluatedToOk)\n-                } else if r_a.is_late_bound() || r_b.is_late_bound() {\n-                    // There is no current way to prove `for<'a> 'a: 'x`\n-                    // unless `'a = 'x`, because there are no bounds involving\n-                    // lifetimes.\n-\n-                    // It might be possible to prove `for<'a> 'x: 'a` by forcing `'x`\n-                    // to be `'static`. However, this is not currently done by type\n-                    // inference unless `'x` is literally ReStatic. See the comment\n-                    // above.\n-\n-                    // We don't want to allow this sort of reasoning in intercrate\n-                    // mode, for backwards-compatibility reasons.\n-                    if self.intercrate.is_some() {\n-                        Ok(EvaluatedToAmbig)\n-                    } else {\n-                        Ok(EvaluatedToErr)\n-                    }\n-                } else {\n-                    // Relating 2 inference variable regions. These will\n-                    // always hold if our query is \"staticized\".\n-                    Ok(EvaluatedToOk)\n-                }\n+            ty::Predicate::TypeOutlives(..) | ty::Predicate::RegionOutlives(..) => {\n+                // we do not consider region relationships when\n+                // evaluating trait matches\n+                Ok(EvaluatedToOkModuloRegions)\n             }\n \n             ty::Predicate::ObjectSafe(trait_def_id) => {\n@@ -985,6 +921,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n+            // Subtle: when checking for a coinductive cycle, we do\n+            // not compare using the \"freshened trait refs\" (which\n+            // have erased regions) but rather the fully explicit\n+            // trait refs. This is important because it's only a cycle\n+            // if the regions match exactly.\n             let cycle = stack.iter().skip(1).take(rec_index + 1);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {\n@@ -2324,7 +2265,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                 // See if we can toss out `victim` based on specialization.\n                 // This requires us to know *for sure* that the `other` impl applies\n                 // i.e., EvaluatedToOk:\n-                if other.evaluation == EvaluatedToOk {\n+                if other.evaluation.must_apply_modulo_regions() {\n                     match victim.candidate {\n                         ImplCandidate(victim_def) => {\n                             let tcx = self.tcx().global_tcx();\n@@ -2351,7 +2292,7 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n                     ParamCandidate(ref cand) => {\n                         // Prefer these to a global where-clause bound\n                         // (see issue #50825)\n-                        is_global(cand) && other.evaluation == EvaluatedToOk\n+                        is_global(cand) && other.evaluation.must_apply_modulo_regions()\n                     }\n                     _ => false,\n                 }"}, {"sha": "0fa4c98be6370de9af8d2b893da950ec059acafa", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 21, "deletions": 15, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -851,11 +851,13 @@ fn is_copy_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::CopyTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -865,11 +867,13 @@ fn is_sized_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::SizedTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -879,11 +883,13 @@ fn is_freeze_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let (param_env, ty) = query.into_parts();\n     let trait_def_id = tcx.require_lang_item(lang_items::FreezeTraitLangItem);\n     tcx.infer_ctxt()\n-       .enter(|infcx| traits::type_known_to_meet_bound(&infcx,\n-                                                       param_env,\n-                                                       ty,\n-                                                       trait_def_id,\n-                                                       DUMMY_SP))\n+        .enter(|infcx| traits::type_known_to_meet_bound_modulo_regions(\n+            &infcx,\n+            param_env,\n+            ty,\n+            trait_def_id,\n+            DUMMY_SP,\n+        ))\n }\n \n fn needs_drop_raw<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "9d418704f487d422d3fbac66c76b431ed13f8c67", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n             return Err(ErrorReported);\n         }\n \n-        if self.type_is_known_to_be_sized(t, span) {\n+        if self.type_is_known_to_be_sized_modulo_regions(t, span) {\n             return Ok(Some(PointerKind::Thin));\n         }\n \n@@ -397,7 +397,7 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n                self.expr_ty,\n                self.cast_ty);\n \n-        if !fcx.type_is_known_to_be_sized(self.cast_ty, self.span) {\n+        if !fcx.type_is_known_to_be_sized_modulo_regions(self.cast_ty, self.span) {\n             self.report_cast_to_unsized_type(fcx);\n         } else if self.expr_ty.references_error() || self.cast_ty.references_error() {\n             // No sense in giving duplicate error messages\n@@ -618,8 +618,8 @@ impl<'a, 'gcx, 'tcx> CastCheck<'tcx> {\n }\n \n impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n-    fn type_is_known_to_be_sized(&self, ty: Ty<'tcx>, span: Span) -> bool {\n+    fn type_is_known_to_be_sized_modulo_regions(&self, ty: Ty<'tcx>, span: Span) -> bool {\n         let lang_item = self.tcx.require_lang_item(lang_items::SizedTraitLangItem);\n-        traits::type_known_to_meet_bound(self, self.param_env, ty, lang_item, span)\n+        traits::type_known_to_meet_bound_modulo_regions(self, self.param_env, ty, lang_item, span)\n     }\n }"}, {"sha": "a20d03c7747cdb24078e791a4a31de085176744b", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.rs?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -0,0 +1,24 @@\n+// Regression test for #54302.\n+//\n+// We were incorrectly using the \"evaluation cache\" (which ignored\n+// region results) to conclude that `&'static str: Deserialize`, even\n+// though it would require that `for<'de> 'de: 'static`, which is\n+// clearly false.\n+\n+trait Deserialize<'de> {}\n+\n+trait DeserializeOwned: for<'de> Deserialize<'de> {}\n+impl<T> DeserializeOwned for T where T: for<'de> Deserialize<'de> {}\n+\n+// Based on this impl, `&'static str` only implements Deserialize<'static>.\n+// It does not implement for<'de> Deserialize<'de>.\n+impl<'de: 'a, 'a> Deserialize<'de> for &'a str {}\n+\n+fn main() {\n+    fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+    assert_deserialize_owned::<&'static str>(); //~ ERROR\n+\n+    // It correctly does not implement for<'de> Deserialize<'de>.\n+    // fn assert_hrtb<T: for<'de> Deserialize<'de>>() {}\n+    // assert_hrtb::<&'static str>();\n+}"}, {"sha": "061d0e309c500e9c29bd50ba45ba55f5c8197f70", "filename": "src/test/ui/hrtb/hrtb-cache-issue-54302.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-cache-issue-54302.stderr?ref=4b5f274f90d3eb925bad9a1bfa6fe58209f6a6c8", "patch": "@@ -0,0 +1,17 @@\n+error[E0279]: the requirement `for<'de> 'de : ` is not satisfied (`expected bound lifetime parameter 'de, found concrete lifetime`)\n+  --> $DIR/hrtb-cache-issue-54302.rs:19:5\n+   |\n+LL |     assert_deserialize_owned::<&'static str>(); //~ ERROR\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: required because of the requirements on the impl of `for<'de> Deserialize<'de>` for `&'static str`\n+   = note: required because of the requirements on the impl of `DeserializeOwned` for `&'static str`\n+note: required by `main::assert_deserialize_owned`\n+  --> $DIR/hrtb-cache-issue-54302.rs:18:5\n+   |\n+LL |     fn assert_deserialize_owned<T: DeserializeOwned>() {}\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0279`."}]}