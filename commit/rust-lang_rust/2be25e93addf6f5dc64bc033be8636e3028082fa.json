{"sha": "2be25e93addf6f5dc64bc033be8636e3028082fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiZTI1ZTkzYWRkZjZmNWRjNjRiYzAzM2JlODYzNmUzMDI4MDgyZmE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2019-05-31T19:49:30Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2019-06-03T08:59:45Z"}, "message": "Allow TraitRef as AnonConst parent", "tree": {"sha": "b2ebc4c844b9dc7b70efe084f6826b3085652766", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2ebc4c844b9dc7b70efe084f6826b3085652766"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be25e93addf6f5dc64bc033be8636e3028082fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be25e93addf6f5dc64bc033be8636e3028082fa", "html_url": "https://github.com/rust-lang/rust/commit/2be25e93addf6f5dc64bc033be8636e3028082fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be25e93addf6f5dc64bc033be8636e3028082fa/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5e3ff4c2f195cbaa0412550a997497aa53752e23", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e3ff4c2f195cbaa0412550a997497aa53752e23", "html_url": "https://github.com/rust-lang/rust/commit/5e3ff4c2f195cbaa0412550a997497aa53752e23"}], "stats": {"total": 155, "additions": 82, "deletions": 73}, "files": [{"sha": "a9a106b787fafcc85142f305e4987b323c09121c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 82, "deletions": 73, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/2be25e93addf6f5dc64bc033be8636e3028082fa/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be25e93addf6f5dc64bc033be8636e3028082fa/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2be25e93addf6f5dc64bc033be8636e3028082fa", "patch": "@@ -1335,88 +1335,97 @@ pub fn checked_type_of<'a, 'tcx>(\n \n                 Node::Ty(&hir::Ty { node: hir::TyKind::Path(_), .. }) |\n                 Node::Expr(&hir::Expr { node: ExprKind::Struct(..), .. }) |\n-                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) => {\n+                Node::Expr(&hir::Expr { node: ExprKind::Path(_), .. }) |\n+                Node::TraitRef(..) => {\n                     let path = match parent_node {\n-                        Node::Ty(&hir::Ty { node: hir::TyKind::Path(ref path), .. }) |\n-                        Node::Expr(&hir::Expr { node: ExprKind::Path(ref path), .. }) => {\n-                            path\n+                        Node::Ty(&hir::Ty {\n+                            node: hir::TyKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        })\n+                        | Node::Expr(&hir::Expr {\n+                            node: ExprKind::Path(QPath::Resolved(_, ref path)),\n+                            ..\n+                        }) => {\n+                            Some(&**path)\n                         }\n                         Node::Expr(&hir::Expr { node: ExprKind::Struct(ref path, ..), .. }) => {\n-                            &*path\n+                            if let QPath::Resolved(_, ref path) = **path {\n+                                Some(&**path)\n+                            } else {\n+                                None\n+                            }\n                         }\n-                        _ => unreachable!(),\n+                        Node::TraitRef(&hir::TraitRef { ref path, .. }) => Some(path),\n+                        _ => None,\n                     };\n \n-                    match path {\n-                        QPath::Resolved(_, ref path) => {\n-                            let arg_index = path.segments.iter()\n-                                .filter_map(|seg| seg.args.as_ref())\n-                                .map(|generic_args| generic_args.args.as_ref())\n-                                .find_map(|args| {\n-                                    args.iter()\n-                                        .filter(|arg| arg.is_const())\n-                                        .enumerate()\n-                                        .filter(|(_, arg)| arg.id() == hir_id)\n-                                        .map(|(index, _)| index)\n-                                        .next()\n-                                })\n-                                .or_else(|| {\n-                                    if !fail {\n-                                        None\n-                                    } else {\n-                                        bug!(\"no arg matching AnonConst in path\")\n-                                    }\n-                                })?;\n-\n-                            // We've encountered an `AnonConst` in some path, so we need to\n-                            // figure out which generic parameter it corresponds to and return\n-                            // the relevant type.\n-                            let generics = match path.res {\n-                                Res::Def(DefKind::Ctor(..), def_id) =>\n-                                    tcx.generics_of(tcx.parent(def_id).unwrap()),\n-                                Res::Def(_, def_id) =>\n-                                    tcx.generics_of(def_id),\n-                                Res::Err =>\n-                                    return Some(tcx.types.err),\n-                                _ if !fail =>\n-                                    return None,\n-                                x => {\n-                                    tcx.sess.delay_span_bug(\n-                                        DUMMY_SP,\n-                                        &format!(\n-                                            \"unexpected const parent path def {:?}\", x\n-                                        ),\n-                                    );\n-                                    return Some(tcx.types.err);\n+                    if let Some(path) = path {\n+                        let arg_index = path.segments.iter()\n+                            .filter_map(|seg| seg.args.as_ref())\n+                            .map(|generic_args| generic_args.args.as_ref())\n+                            .find_map(|args| {\n+                                args.iter()\n+                                    .filter(|arg| arg.is_const())\n+                                    .enumerate()\n+                                    .filter(|(_, arg)| arg.id() == hir_id)\n+                                    .map(|(index, _)| index)\n+                                    .next()\n+                            })\n+                            .or_else(|| {\n+                                if !fail {\n+                                    None\n+                                } else {\n+                                    bug!(\"no arg matching AnonConst in path\")\n                                 }\n-                            };\n-\n-                            generics.params.iter()\n-                                .filter(|param| {\n-                                    if let ty::GenericParamDefKind::Const = param.kind {\n-                                        true\n-                                    } else {\n-                                        false\n-                                    }\n-                                })\n-                                .nth(arg_index)\n-                                .map(|param| tcx.type_of(param.def_id))\n-                                // This is no generic parameter associated with the arg. This is\n-                                // probably from an extra arg where one is not needed.\n-                                .unwrap_or(tcx.types.err)\n-                        }\n-                        x => {\n-                            if !fail {\n-                                return None;\n+                            })?;\n+\n+                        // We've encountered an `AnonConst` in some path, so we need to\n+                        // figure out which generic parameter it corresponds to and return\n+                        // the relevant type.\n+                        let generics = match path.res {\n+                            Res::Def(DefKind::Ctor(..), def_id) => {\n+                                tcx.generics_of(tcx.parent(def_id).unwrap())\n                             }\n-                            tcx.sess.delay_span_bug(\n-                                DUMMY_SP,\n-                                &format!(\n-                                    \"unexpected const parent path {:?}\", x\n-                                ),\n-                            );\n-                            tcx.types.err\n+                            Res::Def(_, def_id) => tcx.generics_of(def_id),\n+                            Res::Err => return Some(tcx.types.err),\n+                            _ if !fail => return None,\n+                            res => {\n+                                tcx.sess.delay_span_bug(\n+                                    DUMMY_SP,\n+                                    &format!(\n+                                        \"unexpected const parent path def {:?}\",\n+                                        res,\n+                                    ),\n+                                );\n+                                return Some(tcx.types.err);\n+                            }\n+                        };\n+\n+                        generics.params.iter()\n+                            .filter(|param| {\n+                                if let ty::GenericParamDefKind::Const = param.kind {\n+                                    true\n+                                } else {\n+                                    false\n+                                }\n+                            })\n+                            .nth(arg_index)\n+                            .map(|param| tcx.type_of(param.def_id))\n+                            // This is no generic parameter associated with the arg. This is\n+                            // probably from an extra arg where one is not needed.\n+                            .unwrap_or(tcx.types.err)\n+                    } else {\n+                        if !fail {\n+                            return None;\n                         }\n+                        tcx.sess.delay_span_bug(\n+                            DUMMY_SP,\n+                            &format!(\n+                                \"unexpected const parent path {:?}\",\n+                                parent_node,\n+                            ),\n+                        );\n+                        return Some(tcx.types.err);\n                     }\n                 }\n "}]}