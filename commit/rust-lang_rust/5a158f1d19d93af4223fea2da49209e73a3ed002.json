{"sha": "5a158f1d19d93af4223fea2da49209e73a3ed002", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVhMTU4ZjFkMTlkOTNhZjQyMjNmZWEyZGE0OTIwOWU3M2EzZWQwMDI=", "commit": {"author": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-04T21:56:33Z"}, "committer": {"name": "John Clements", "email": "clements@racket-lang.org", "date": "2013-06-05T19:01:40Z"}, "message": "add hygiene support functions", "tree": {"sha": "f79fda064ff81ff3c3f5b7f7d69b9c1cf8fbad5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f79fda064ff81ff3c3f5b7f7d69b9c1cf8fbad5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5a158f1d19d93af4223fea2da49209e73a3ed002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5a158f1d19d93af4223fea2da49209e73a3ed002", "html_url": "https://github.com/rust-lang/rust/commit/5a158f1d19d93af4223fea2da49209e73a3ed002", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5a158f1d19d93af4223fea2da49209e73a3ed002/comments", "author": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jbclements", "id": 226617, "node_id": "MDQ6VXNlcjIyNjYxNw==", "avatar_url": "https://avatars.githubusercontent.com/u/226617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jbclements", "html_url": "https://github.com/jbclements", "followers_url": "https://api.github.com/users/jbclements/followers", "following_url": "https://api.github.com/users/jbclements/following{/other_user}", "gists_url": "https://api.github.com/users/jbclements/gists{/gist_id}", "starred_url": "https://api.github.com/users/jbclements/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jbclements/subscriptions", "organizations_url": "https://api.github.com/users/jbclements/orgs", "repos_url": "https://api.github.com/users/jbclements/repos", "events_url": "https://api.github.com/users/jbclements/events{/privacy}", "received_events_url": "https://api.github.com/users/jbclements/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ecdb6e472218ea6f542e4b95e1e3ce48a7e78056", "url": "https://api.github.com/repos/rust-lang/rust/commits/ecdb6e472218ea6f542e4b95e1e3ce48a7e78056", "html_url": "https://github.com/rust-lang/rust/commit/ecdb6e472218ea6f542e4b95e1e3ce48a7e78056"}], "stats": {"total": 105, "additions": 78, "deletions": 27}, "files": [{"sha": "a3432a00edc03f8b265f33ba54229ca072420df4", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5a158f1d19d93af4223fea2da49209e73a3ed002", "patch": "@@ -479,6 +479,15 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n         }\n     }\n \n+    fn find_in_topmost_frame(&self, key: &K) -> Option<@V> {\n+        let map = match *self {\n+            BaseMapChain(ref map) => map,\n+            ConsMapChain(ref map,_) => map\n+        };\n+        // strip one layer of indirection off the pointer.\n+        map.find(key).map(|r| {**r})\n+    }\n+\n     // insert the binding into the top-level map\n     fn insert (&mut self, key: K, ext: @V) -> bool {\n         // can't abstract over get_map because of flow sensitivity...\n@@ -512,6 +521,7 @@ impl <K: Eq + Hash + IterBytes ,V: Copy> MapChain<K,V>{\n     }\n }\n \n+// returns true if the binding for 'n' satisfies 'pred' in 'map'\n fn satisfies_pred<K : Eq + Hash + IterBytes,V>(map : &mut HashMap<K,V>,\n                                                n: &K,\n                                                pred: &fn(&V)->bool)"}, {"sha": "f5edc50377e8123839578c4e46b1f39198422a8d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 54, "deletions": 4, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5a158f1d19d93af4223fea2da49209e73a3ed002", "patch": "@@ -11,8 +11,8 @@\n use core::prelude::*;\n \n use ast::{blk_, attribute_, attr_outer, meta_word};\n-use ast::{crate, expr_, expr_mac, mac_invoc_tt};\n-use ast::{item_mac, stmt_, stmt_mac, stmt_expr, stmt_semi};\n+use ast::{crate, decl_local, expr_, expr_mac, mac_invoc_tt};\n+use ast::{item_mac, local_, stmt_, stmt_decl, stmt_mac, stmt_expr, stmt_semi};\n use ast::{SCTable, illegal_ctxt};\n use ast;\n use ast_util::{new_rename, new_mark, resolve, new_sctable};\n@@ -26,6 +26,8 @@ use fold::*;\n use parse;\n use parse::{parse_item_from_source_str};\n use parse::token::{ident_to_str, intern};\n+use visit;\n+use visit::{Visitor,mk_vt};\n \n use core::vec;\n \n@@ -276,13 +278,13 @@ pub fn expand_item_mac(extsbox: @mut SyntaxEnv,\n // insert a macro into the innermost frame that doesn't have the\n // macro_escape tag.\n fn insert_macro(exts: SyntaxEnv, name: ast::Name, transformer: @Transformer) {\n-    let block_err_msg = \"special identifier ' block' was bound to a non-BlockInfo\";\n     let is_non_escaping_block =\n         |t : &@Transformer| -> bool{\n         match t {\n             &@BlockInfo(BlockInfo {macros_escape:false,_}) => true,\n             &@BlockInfo(BlockInfo {_}) => false,\n-            _ => fail!(block_err_msg)\n+            _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n+                            special_block_name))\n         }\n     };\n     exts.insert_into_frame(name,transformer,intern(special_block_name),\n@@ -365,6 +367,34 @@ pub fn expand_stmt(extsbox: @mut SyntaxEnv,\n \n }\n \n+// return a visitor that extracts the pat_ident paths\n+// from a given pattern and puts them in a mutable\n+// array (passed in to the traversal\n+pub fn new_name_finder() -> @Visitor<@mut ~[ast::ident]> {\n+    let default_visitor = visit::default_visitor();\n+    @Visitor{\n+        visit_pat : |p:@ast::pat,ident_accum:@mut ~[ast::ident],v:visit::vt<@mut ~[ast::ident]>| {\n+            match *p {\n+                // we found a pat_ident!\n+                ast::pat{id:_, node: ast::pat_ident(_,path,ref inner), span:_} => {\n+                    match path {\n+                        // a path of length one:\n+                        @ast::Path{global: false,idents: [id], span:_,rp:_,types:_} =>\n+                        ident_accum.push(id),\n+                        // I believe these must be enums...\n+                        _ => ()\n+                    }\n+                    // visit optional subpattern of pat_ident:\n+                    for inner.each |subpat: &@ast::pat| { (v.visit_pat)(*subpat, ident_accum, v) }\n+                }\n+                // use the default traversal for non-pat_idents\n+                _ => visit::visit_pat(p,ident_accum,v)\n+            }\n+        },\n+        .. *default_visitor\n+    }\n+}\n+\n \n \n pub fn expand_block(extsbox: @mut SyntaxEnv,\n@@ -378,6 +408,17 @@ pub fn expand_block(extsbox: @mut SyntaxEnv,\n     with_exts_frame!(extsbox,false,orig(blk,sp,fld))\n }\n \n+\n+// get the (innermost) BlockInfo from an exts stack\n+fn get_block_info(exts : SyntaxEnv) -> BlockInfo {\n+    match exts.find_in_topmost_frame(&intern(special_block_name)) {\n+        Some(@BlockInfo(bi)) => bi,\n+        _ => fail!(fmt!(\"special identifier %? was bound to a non-BlockInfo\",\n+                       @~\" block\"))\n+    }\n+}\n+\n+\n // given a mutable list of renames, return a tree-folder that applies those\n // renames.\n fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n@@ -738,6 +779,7 @@ mod test {\n     use core::io;\n     use core::option::{None, Some};\n     use util::parser_testing::{string_to_item, string_to_pat, strs_to_idents};\n+    use visit::{mk_vt,Visitor};\n \n     // make sure that fail! is present\n     #[test] fn fail_exists_test () {\n@@ -857,4 +899,12 @@ mod test {\n         io::print(fmt!(\"ast: %?\\n\",resolved_ast))\n     }\n \n+    #[test]\n+    fn pat_idents(){\n+        let pat = string_to_pat(@~\"(a,Foo{x:c @ (b,9),y:Bar(4,d)})\");\n+        let pat_idents = new_name_finder();\n+        let idents = @mut ~[];\n+        ((*pat_idents).visit_pat)(pat,idents, mk_vt(pat_idents));\n+        assert_eq!(idents,@mut strs_to_idents(~[\"a\",\"c\",\"b\",\"d\"]));\n+    }\n }"}, {"sha": "d7248204e1cf74278e3065103b163883ccc4c68c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 22, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=5a158f1d19d93af4223fea2da49209e73a3ed002", "patch": "@@ -347,7 +347,7 @@ mod test {\n     use parse::token::{intern, str_to_ident};\n     use util::parser_testing::{string_to_tts_and_sess, string_to_parser};\n     use util::parser_testing::{string_to_expr, string_to_item};\n-    use util::parser_testing::{string_to_stmt};\n+    use util::parser_testing::{string_to_stmt, strs_to_idents};\n \n     // map a string to tts, return the tt without its parsesess\n     fn string_to_tts_only(source_str : @~str) -> ~[ast::token_tree] {\n@@ -368,22 +368,12 @@ mod test {\n         span{lo:BytePos(a),hi:BytePos(b),expn_info:None}\n     }\n \n-    // compose new_ident and intern:\n-    fn intern_ident(str : &str) -> ast::ident {\n-        new_ident(intern(str))\n-    }\n-\n-    // convert a vector of uints to a vector of ast::idents\n-    fn ints_to_idents(ids: ~[~str]) -> ~[ast::ident] {\n-        ids.map(|u| intern_ident(*u))\n-    }\n-\n     #[test] fn path_exprs_1 () {\n         assert_eq!(string_to_expr(@~\"a\"),\n                    @ast::expr{id:1,\n                               node:ast::expr_path(@ast::Path {span:sp(0,1),\n                                                               global:false,\n-                                                              idents:~[intern_ident(\"a\")],\n+                                                              idents:~[str_to_ident(\"a\")],\n                                                               rp:None,\n                                                               types:~[]}),\n                               span:sp(0,1)})\n@@ -395,7 +385,7 @@ mod test {\n                                node:ast::expr_path(\n                                    @ast::Path {span:sp(0,6),\n                                                global:true,\n-                                               idents:ints_to_idents(~[~\"a\",~\"b\"]),\n+                                               idents:strs_to_idents(~[\"a\",\"b\"]),\n                                                rp:None,\n                                                types:~[]}),\n                               span:sp(0,6)})\n@@ -445,7 +435,7 @@ mod test {\n                                                   node:ast::expr_path(\n                                                       @ast::Path{span:sp(7,8),\n                                                                  global:false,\n-                                                                 idents:~[intern_ident(\"d\")],\n+                                                                 idents:~[str_to_ident(\"d\")],\n                                                                  rp:None,\n                                                                  types:~[]\n                                                                 }),\n@@ -462,7 +452,7 @@ mod test {\n                                @ast::Path{\n                                    span:sp(0,1),\n                                    global:false,\n-                                   idents:~[intern_ident(\"b\")],\n+                                   idents:~[str_to_ident(\"b\")],\n                                    rp:None,\n                                    types: ~[]}),\n                            span: sp(0,1)},\n@@ -483,7 +473,7 @@ mod test {\n                                                   @ast::Path{\n                                                       span:sp(0,1),\n                                                       global:false,\n-                                                      idents:~[intern_ident(\"b\")],\n+                                                      idents:~[str_to_ident(\"b\")],\n                                                       rp: None,\n                                                       types: ~[]},\n                                                   None // no idea\n@@ -502,7 +492,7 @@ mod test {\n                                         span:sp(4,4), // this is bizarre...\n                                         // check this in the original parser?\n                                         global:false,\n-                                        idents:~[intern_ident(\"int\")],\n+                                        idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -512,7 +502,7 @@ mod test {\n                                                            @ast::Path{\n                                                                span:sp(0,1),\n                                                                global:false,\n-                                                               idents:~[intern_ident(\"b\")],\n+                                                               idents:~[str_to_ident(\"b\")],\n                                                                rp: None,\n                                                                types: ~[]},\n                                                            None // no idea\n@@ -528,7 +518,7 @@ mod test {\n         // assignment order of the node_ids.\n         assert_eq!(string_to_item(@~\"fn a (b : int) { b; }\"),\n                   Some(\n-                      @ast::item{ident:intern_ident(\"a\"),\n+                      @ast::item{ident:str_to_ident(\"a\"),\n                             attrs:~[],\n                             id: 9, // fixme\n                             node: ast::item_fn(ast::fn_decl{\n@@ -538,7 +528,7 @@ mod test {\n                                                 node: ast::ty_path(@ast::Path{\n                                         span:sp(10,13),\n                                         global:false,\n-                                        idents:~[intern_ident(\"int\")],\n+                                        idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n                                                        2),\n@@ -549,7 +539,7 @@ mod test {\n                                                        @ast::Path{\n                                                            span:sp(6,7),\n                                                            global:false,\n-                                                           idents:~[intern_ident(\"b\")],\n+                                                           idents:~[str_to_ident(\"b\")],\n                                                            rp: None,\n                                                            types: ~[]},\n                                                        None // no idea\n@@ -579,7 +569,7 @@ mod test {\n                                                         @ast::Path{\n                                                             span:sp(17,18),\n                                                             global:false,\n-                                                            idents:~[intern_ident(\"b\")],\n+                                                            idents:~[str_to_ident(\"b\")],\n                                                             rp:None,\n                                                             types: ~[]}),\n                                                     span: sp(17,18)},"}, {"sha": "c5528069926f0923d1a398802143a7cced0c17d0", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5a158f1d19d93af4223fea2da49209e73a3ed002/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=5a158f1d19d93af4223fea2da49209e73a3ed002", "patch": "@@ -54,7 +54,8 @@ pub fn string_to_item_and_sess (source_str : @~str) -> (Option<@ast::item>,@mut\n     (p.parse_item(~[]),ps)\n }\n \n-pub fn string_to_stmt (source_str : @~str) -> @ast::stmt {\n+// parse a string, return a stmt\n+pub fn string_to_stmt(source_str : @~str) -> @ast::stmt {\n     string_to_parser(source_str).parse_stmt(~[])\n }\n "}]}