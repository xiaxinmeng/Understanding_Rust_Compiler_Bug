{"sha": "bfaf4180ae8f048634d270564692d35f64a9c130", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmYWY0MTgwYWU4ZjA0ODYzNGQyNzA1NjQ2OTJkMzVmNjRhOWMxMzA=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-03-24T16:49:50Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-04-06T08:52:16Z"}, "message": "Make lifetime nonterminals closer to identifier nonterminals", "tree": {"sha": "447db804b4a7d405f2fb492434378a57bea33802", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/447db804b4a7d405f2fb492434378a57bea33802"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bfaf4180ae8f048634d270564692d35f64a9c130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bfaf4180ae8f048634d270564692d35f64a9c130", "html_url": "https://github.com/rust-lang/rust/commit/bfaf4180ae8f048634d270564692d35f64a9c130", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bfaf4180ae8f048634d270564692d35f64a9c130/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c", "html_url": "https://github.com/rust-lang/rust/commit/b3b5ef186c1f9f57179ab1dc922f6c7f02fb9d8c"}], "stats": {"total": 94, "additions": 47, "deletions": 47}, "files": [{"sha": "d9c3deb30da30a8b6107bbafb181e7e6c90adf84", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=bfaf4180ae8f048634d270564692d35f64a9c130", "patch": "@@ -365,7 +365,7 @@ pub fn parse_failure_msg(tok: Token) -> String {\n fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     if let (Some((id1, is_raw1)), Some((id2, is_raw2))) = (t1.ident(), t2.ident()) {\n         id1.name == id2.name && is_raw1 == is_raw2\n-    } else if let (&token::Lifetime(id1), &token::Lifetime(id2)) = (t1, t2) {\n+    } else if let (Some(id1), Some(id2)) = (t1.lifetime(), t2.lifetime()) {\n         id1.name == id2.name\n     } else {\n         *t1 == *t2\n@@ -835,7 +835,7 @@ fn parse_nt<'a>(p: &mut Parser<'a>, sp: Span, name: &str) -> Nonterminal {\n         \"path\" => token::NtPath(panictry!(p.parse_path_common(PathStyle::Type, false))),\n         \"meta\" => token::NtMeta(panictry!(p.parse_meta_item())),\n         \"vis\" => token::NtVis(panictry!(p.parse_visibility(true))),\n-        \"lifetime\" => token::NtLifetime(p.expect_lifetime()),\n+        \"lifetime\" => token::NtLifetime(p.expect_lifetime().ident),\n         // this is not supposed to happen, since it has been checked\n         // when compiling the macro.\n         _ => p.span_bug(sp, \"invalid fragment specifier\"),"}, {"sha": "e476a0c653ef0783b979645c00cd2b8a2be5bc08", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=bfaf4180ae8f048634d270564692d35f64a9c130", "patch": "@@ -633,7 +633,8 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n         token::NtPat(pat) => token::NtPat(fld.fold_pat(pat)),\n         token::NtExpr(expr) => token::NtExpr(fld.fold_expr(expr)),\n         token::NtTy(ty) => token::NtTy(fld.fold_ty(ty)),\n-        token::NtIdent(id, is_raw) => token::NtIdent(fld.fold_ident(id), is_raw),\n+        token::NtIdent(ident, is_raw) => token::NtIdent(fld.fold_ident(ident), is_raw),\n+        token::NtLifetime(ident) => token::NtLifetime(fld.fold_ident(ident)),\n         token::NtMeta(meta) => token::NtMeta(fld.fold_meta_item(meta)),\n         token::NtPath(path) => token::NtPath(fld.fold_path(path)),\n         token::NtTT(tt) => token::NtTT(fld.fold_tt(tt)),\n@@ -649,7 +650,6 @@ pub fn noop_fold_interpolated<T: Folder>(nt: token::Nonterminal, fld: &mut T)\n             token::NtWhereClause(fld.fold_where_clause(where_clause)),\n         token::NtArg(arg) => token::NtArg(fld.fold_arg(arg)),\n         token::NtVis(vis) => token::NtVis(fld.fold_vis(vis)),\n-        token::NtLifetime(lifetime) => token::NtLifetime(fld.fold_lifetime(lifetime)),\n         token::NtForeignItem(ni) =>\n             token::NtForeignItem(fld.fold_foreign_item(ni)\n                                  // see reasoning above"}, {"sha": "84c770605d5f4987b5a2b1e604559cb7aa3430db", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=bfaf4180ae8f048634d270564692d35f64a9c130", "patch": "@@ -2048,18 +2048,20 @@ impl<'a> Parser<'a> {\n \n     /// Parse single lifetime 'a or panic.\n     pub fn expect_lifetime(&mut self) -> Lifetime {\n-        if let Some(lifetime) = self.token.lifetime2(self.span) {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.span;\n             self.bump();\n-            lifetime\n+            Lifetime { ident: Ident::new(ident.name, span), id: ast::DUMMY_NODE_ID }\n         } else {\n             self.span_bug(self.span, \"not a lifetime\")\n         }\n     }\n \n     fn eat_label(&mut self) -> Option<Label> {\n-        if let Some(lifetime) = self.token.lifetime2(self.span) {\n+        if let Some(ident) = self.token.lifetime() {\n+            let span = self.span;\n             self.bump();\n-            Some(Label { ident: lifetime.ident })\n+            Some(Label { ident: Ident::new(ident.name, span) })\n         } else {\n             None\n         }\n@@ -2703,7 +2705,7 @@ impl<'a> Parser<'a> {\n     }\n \n     pub fn process_potential_macro_variable(&mut self) {\n-        let (ident, is_raw) = match self.token {\n+        let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n                              self.look_ahead(1, |t| t.is_ident()) => {\n                 self.bump();\n@@ -2718,15 +2720,18 @@ impl<'a> Parser<'a> {\n             }\n             token::Interpolated(ref nt) => {\n                 self.meta_var_span = Some(self.span);\n+                // Interpolated identifier and lifetime tokens are replaced with usual identifier\n+                // and lifetime tokens, so the former are never encountered during normal parsing.\n                 match nt.0 {\n-                    token::NtIdent(ident, is_raw) => (ident, is_raw),\n+                    token::NtIdent(ident, is_raw) => (token::Ident(ident, is_raw), ident.span),\n+                    token::NtLifetime(ident) => (token::Lifetime(ident), ident.span),\n                     _ => return,\n                 }\n             }\n             _ => return,\n         };\n-        self.token = token::Ident(ident, is_raw);\n-        self.span = ident.span;\n+        self.token = token;\n+        self.span = span;\n     }\n \n     /// parse a single token tree from the input."}, {"sha": "6544619af9c707379e9ade92f080e3300c500ec6", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 29, "deletions": 34, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=bfaf4180ae8f048634d270564692d35f64a9c130", "patch": "@@ -317,7 +317,8 @@ impl Token {\n         }\n     }\n \n-    pub fn ident(&self) -> Option<(ast::Ident, bool)> {\n+    /// Returns an identifier if this token is an identifier.\n+    pub fn ident(&self) -> Option<(ast::Ident, /* is_raw */ bool)> {\n         match *self {\n             Ident(ident, is_raw) => Some((ident, is_raw)),\n             Interpolated(ref nt) => match nt.0 {\n@@ -327,11 +328,25 @@ impl Token {\n             _ => None,\n         }\n     }\n-\n+    /// Returns a lifetime identifier if this token is a lifetime.\n+    pub fn lifetime(&self) -> Option<ast::Ident> {\n+        match *self {\n+            Lifetime(ident) => Some(ident),\n+            Interpolated(ref nt) => match nt.0 {\n+                NtLifetime(ident) => Some(ident),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n     /// Returns `true` if the token is an identifier.\n     pub fn is_ident(&self) -> bool {\n         self.ident().is_some()\n     }\n+    /// Returns `true` if the token is a lifetime.\n+    pub fn is_lifetime(&self) -> bool {\n+        self.lifetime().is_some()\n+    }\n \n     /// Returns `true` if the token is a documentation comment.\n     pub fn is_doc_comment(&self) -> bool {\n@@ -359,26 +374,6 @@ impl Token {\n         false\n     }\n \n-    /// Returns a lifetime with the span and a dummy id if it is a lifetime,\n-    /// or the original lifetime if it is an interpolated lifetime, ignoring\n-    /// the span.\n-    pub fn lifetime2(&self, span: Span) -> Option<ast::Lifetime> {\n-        match *self {\n-            Lifetime(ident) => Some(ast::Lifetime { id: ast::DUMMY_NODE_ID,\n-                                                    ident: ast::Ident::new(ident.name, span) }),\n-            Interpolated(ref nt) => match nt.0 {\n-                NtLifetime(lifetime) => Some(lifetime),\n-                _ => None,\n-            },\n-            _ => None,\n-        }\n-    }\n-\n-    /// Returns `true` if the token is a lifetime.\n-    pub fn is_lifetime(&self) -> bool {\n-        self.lifetime2(syntax_pos::DUMMY_SP).is_some()\n-    }\n-\n     /// Returns `true` if the token is either the `mut` or `const` keyword.\n     pub fn is_mutability(&self) -> bool {\n         self.is_keyword(keywords::Mut) ||\n@@ -431,6 +426,14 @@ impl Token {\n         }\n     }\n \n+    /// Returns `true` if the token is either a special identifier or a keyword.\n+    pub fn is_reserved_ident(&self) -> bool {\n+        match self.ident() {\n+            Some((id, false)) => is_reserved_ident(id),\n+            _ => false,\n+        }\n+    }\n+\n     pub fn glue(self, joint: Token) -> Option<Token> {\n         Some(match self {\n             Eq => match joint {\n@@ -497,14 +500,6 @@ impl Token {\n         }\n     }\n \n-    /// Returns `true` if the token is either a special identifier or a keyword.\n-    pub fn is_reserved_ident(&self) -> bool {\n-        match self.ident() {\n-            Some((id, false)) => is_reserved_ident(id),\n-            _ => false,\n-        }\n-    }\n-\n     pub fn interpolated_to_tokenstream(&self, sess: &ParseSess, span: Span)\n         -> TokenStream\n     {\n@@ -542,9 +537,9 @@ impl Token {\n                 let token = Token::Ident(ident, is_raw);\n                 tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n-            Nonterminal::NtLifetime(lifetime) => {\n-                let token = Token::Lifetime(lifetime.ident);\n-                tokens = Some(TokenTree::Token(lifetime.ident.span, token).into());\n+            Nonterminal::NtLifetime(ident) => {\n+                let token = Token::Lifetime(ident);\n+                tokens = Some(TokenTree::Token(ident.span, token).into());\n             }\n             Nonterminal::NtTT(ref tt) => {\n                 tokens = Some(tt.clone().into());\n@@ -572,6 +567,7 @@ pub enum Nonterminal {\n     NtExpr(P<ast::Expr>),\n     NtTy(P<ast::Ty>),\n     NtIdent(ast::Ident, /* is_raw */ bool),\n+    NtLifetime(ast::Ident),\n     /// Stuff inside brackets for attributes\n     NtMeta(ast::MetaItem),\n     NtPath(ast::Path),\n@@ -585,7 +581,6 @@ pub enum Nonterminal {\n     NtGenerics(ast::Generics),\n     NtWhereClause(ast::WhereClause),\n     NtArg(ast::Arg),\n-    NtLifetime(ast::Lifetime),\n }\n \n impl fmt::Debug for Nonterminal {"}, {"sha": "b233b145fddddf61708743485787c9e30826074d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bfaf4180ae8f048634d270564692d35f64a9c130/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=bfaf4180ae8f048634d270564692d35f64a9c130", "patch": "@@ -272,6 +272,7 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtPat(ref e)         => pat_to_string(e),\n             token::NtIdent(e, false)    => ident_to_string(e),\n             token::NtIdent(e, true)     => format!(\"r#{}\", ident_to_string(e)),\n+            token::NtLifetime(e)        => ident_to_string(e),\n             token::NtTT(ref tree)       => tt_to_string(tree.clone()),\n             token::NtArm(ref e)         => arm_to_string(e),\n             token::NtImplItem(ref e)    => impl_item_to_string(e),\n@@ -280,7 +281,6 @@ pub fn token_to_string(tok: &Token) -> String {\n             token::NtWhereClause(ref e) => where_clause_to_string(e),\n             token::NtArg(ref e)         => arg_to_string(e),\n             token::NtVis(ref e)         => vis_to_string(e),\n-            token::NtLifetime(ref e)    => lifetime_to_string(e),\n             token::NtForeignItem(ref e) => foreign_item_to_string(e),\n         }\n     }"}]}