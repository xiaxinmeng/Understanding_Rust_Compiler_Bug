{"sha": "ea211695bf924015f38d4a2de4f43a822f6c6a70", "node_id": "C_kwDOAAsO6NoAKGVhMjExNjk1YmY5MjQwMTVmMzhkNGEyZGU0ZjQzYTgyMmY2YzZhNzA", "commit": {"author": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2021-08-08T12:13:35Z"}, "committer": {"name": "Thom Chiovoloni", "email": "chiovolonit@gmail.com", "date": "2022-02-05T02:47:30Z"}, "message": "Optimize io::error::Repr layout on 64 bit targets.", "tree": {"sha": "48a2ad207555178233de9d5f06d95a75661d5207", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48a2ad207555178233de9d5f06d95a75661d5207"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea211695bf924015f38d4a2de4f43a822f6c6a70", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEh0+qV0hta6XFe2D54u/UMJ4RyKgFAmH95UIACgkQ4u/UMJ4R\nyKiuHhAApkk4IaFs5Wq10LI16V5MwgnwWNC+vxJYBVrS4pzBSvOflR7IBJ45jeAR\n5A/0F1f4GhSRDtZPFTP7rc5WUwqSIHNCgTmmaNpJFLr7PH7V9r694IA5zzf/cV5E\nDI3elb4+ROmbKKDlnnCvNKraE5CZTFMz1dTA44fjidavAigN/8vAWf8qDtAqUoz6\n5x0SkrzFN8j97BfKvJRsC0mmJZNCqMvIPkJYy5kqzDqkkednULqhjH+tE8jKlJau\nfGctQXfpewCgZ3dSQBTxvUguUx1cEg3Pf2CY4IpR9BU7v0AgSmAkPpT0xL1iFqMy\n13ytxDUH6uiPucYvnRN15gzrN5Q11B2ScsS8I4ux/vxa5Wft6uLKPNgmyugTfdE7\npS7zjh8VG7EAurEK8exZIqR6WEhjCRHkVx1OX7fU1UCz/5rj8c2J1gQet/EsRUx1\nKjY5tFoZRWNRuKAx2Pf26Un3jR7Bg0fAO64RnmoYYKRfO5FOy4Pqgn8Q7C4ad6yN\nnxirlqgaG+PttcsRgDjsCyXNZSsrOpSCE0vjhqURqpwyC3UZJjfmOVOiFOWnhON6\nT/cKyflYCaJshLSFlFjOF5twDgoQf3uWpds78fsriucKBD/tINSsHY0fhmvxu/FT\n+0tLZWUKsexSAZ43MsCtJAjYofY57BqIDGX6leONFnCDvgQLrPY=\n=FfmR\n-----END PGP SIGNATURE-----", "payload": "tree 48a2ad207555178233de9d5f06d95a75661d5207\nparent 554918e311a1221744aa9b6d60e2f00f5b3155e5\nauthor Thom Chiovoloni <chiovolonit@gmail.com> 1628424815 -0700\ncommitter Thom Chiovoloni <chiovolonit@gmail.com> 1644029250 -0800\n\nOptimize io::error::Repr layout on 64 bit targets.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea211695bf924015f38d4a2de4f43a822f6c6a70", "html_url": "https://github.com/rust-lang/rust/commit/ea211695bf924015f38d4a2de4f43a822f6c6a70", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea211695bf924015f38d4a2de4f43a822f6c6a70/comments", "author": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thomcc", "id": 860665, "node_id": "MDQ6VXNlcjg2MDY2NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/860665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thomcc", "html_url": "https://github.com/thomcc", "followers_url": "https://api.github.com/users/thomcc/followers", "following_url": "https://api.github.com/users/thomcc/following{/other_user}", "gists_url": "https://api.github.com/users/thomcc/gists{/gist_id}", "starred_url": "https://api.github.com/users/thomcc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thomcc/subscriptions", "organizations_url": "https://api.github.com/users/thomcc/orgs", "repos_url": "https://api.github.com/users/thomcc/repos", "events_url": "https://api.github.com/users/thomcc/events{/privacy}", "received_events_url": "https://api.github.com/users/thomcc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "554918e311a1221744aa9b6d60e2f00f5b3155e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/554918e311a1221744aa9b6d60e2f00f5b3155e5", "html_url": "https://github.com/rust-lang/rust/commit/554918e311a1221744aa9b6d60e2f00f5b3155e5"}], "stats": {"total": 368, "additions": 364, "deletions": 4}, "files": [{"sha": "449771c676148848baa545aff5e74b000ceb4779", "filename": "library/std/src/io/error.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror.rs?ref=ea211695bf924015f38d4a2de4f43a822f6c6a70", "patch": "@@ -1,7 +1,14 @@\n #[cfg(test)]\n mod tests;\n \n+#[cfg(target_pointer_width = \"64\")]\n+mod repr_bitpacked;\n+#[cfg(target_pointer_width = \"64\")]\n+use repr_bitpacked::Repr;\n+\n+#[cfg(not(target_pointer_width = \"64\"))]\n mod repr_unpacked;\n+#[cfg(not(target_pointer_width = \"64\"))]\n use repr_unpacked::Repr;\n \n use crate::convert::From;\n@@ -780,7 +787,7 @@ impl Error {\n     pub fn kind(&self) -> ErrorKind {\n         match self.repr.data() {\n             ErrorData::Os(code) => sys::decode_error_kind(code),\n-            ErrorData::Custom(ref c) => c.kind,\n+            ErrorData::Custom(c) => c.kind,\n             ErrorData::Simple(kind) => kind,\n             ErrorData::SimpleMessage(m) => m.kind,\n         }\n@@ -829,7 +836,7 @@ impl error::Error for Error {\n         match self.repr.data() {\n             ErrorData::Os(..) | ErrorData::Simple(..) => self.kind().as_str(),\n             ErrorData::SimpleMessage(msg) => msg.message,\n-            ErrorData::Custom(ref c) => c.error.description(),\n+            ErrorData::Custom(c) => c.error.description(),\n         }\n     }\n \n@@ -839,7 +846,7 @@ impl error::Error for Error {\n             ErrorData::Os(..) => None,\n             ErrorData::Simple(..) => None,\n             ErrorData::SimpleMessage(..) => None,\n-            ErrorData::Custom(ref c) => c.error.cause(),\n+            ErrorData::Custom(c) => c.error.cause(),\n         }\n     }\n \n@@ -848,7 +855,7 @@ impl error::Error for Error {\n             ErrorData::Os(..) => None,\n             ErrorData::Simple(..) => None,\n             ErrorData::SimpleMessage(..) => None,\n-            ErrorData::Custom(ref c) => c.error.source(),\n+            ErrorData::Custom(c) => c.error.source(),\n         }\n     }\n }"}, {"sha": "8ff0bcc7cb5cdce415116f7b1605cd368b76bf41", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "added", "additions": 338, "deletions": 0, "changes": 338, "blob_url": "https://github.com/rust-lang/rust/blob/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=ea211695bf924015f38d4a2de4f43a822f6c6a70", "patch": "@@ -0,0 +1,338 @@\n+//! This is a densely packed error representation which is used on targets with\n+//! 64-bit pointers.\n+//!\n+//! (Note that `bitpacked` vs `unpacked` here has no relationship to\n+//! `#[repr(packed)]`, it just refers to attempting to use any available\n+//! bits in a more clever manner than `rustc`'s default layout algorithm would).\n+//!\n+//! Conceptually, it stores the same information as the \"unpacked\" equivalent we\n+//! use on other targets: `repr_unpacked::Repr` (see repr_unpacked.rs), however\n+//! it packs it into a 64bit non-zero value.\n+//!\n+//! This optimization not only allows `io::Error` to occupy a single pointer,\n+//! but improves `io::Result` as well, especially for situations like\n+//! `Result<()>` (which is now 64 bits) or `Result<u64>` (which i), which are\n+//! quite common.\n+//!\n+//! # Layout\n+//! Tagged values are 64 bits, with the 2 least significant bits used for the\n+//! tag. This means there are there are 4 \"variants\":\n+//!\n+//! - **Tag 0b00**: The first variant is equivalent to\n+//!   `ErrorData::SimpleMessage`, and holds a `&'static SimpleMessage` directly.\n+//!\n+//!   `SimpleMessage` has an alignment >= 4 (which is requested with\n+//!   `#[repr(align)]` and checked statically at the bottom of this file), which\n+//!   means every `&'static SimpleMessage` should have the both tag bits as 0,\n+//!   meaning its tagged and untagged representation are equivalent.\n+//!\n+//!   This means we can skip tagging it, which is necessary as this variant can\n+//!   be constructed from a `const fn`, which probably cannot tag pointers (or\n+//!   at least it would be difficult.\n+//!\n+//! - **Tag 0b01**: The other pointer variant holds the data for\n+//!   `ErrorData::Custom` and the remaining 62 bits are used to store a\n+//!   `Box<Custom>`. `Custom` also has alignment >= 4, so the bottom two bits\n+//!   are free to use for the tag.\n+//!\n+//!   The only important thing to note is that `ptr::add` and `ptr::sub` are\n+//!   used to tag the pointer, rather than bitwise operations. This should\n+//!   preserve the pointer's provenance, which would otherwise be lost.\n+//!\n+//! - **Tag 0b10**: Holds the data for `ErrorData::Os(i32)`. We store the `i32`\n+//!   in the pointers most significant 32 bits, and don't use the bits `2..32`\n+//!   for anything. Using the top 32 bits is just to let us easily recover the\n+//!   `i32` code with the correct sign.\n+//!\n+//! - **Tag 0b11**: Holds the data for `ErrorData::Simple(ErrorKind)`. This\n+//!   stores the `ErrorKind` in the top 32 bits as well, although it doesn't\n+//!   occupy nearly that many. Most of the bits are unused here, but it's not\n+//!   like we need them for anything else yet.\n+//!\n+//! # Use of `NonNull<()>`\n+//!\n+//! Everything is stored in a `NonNull<()>`, which is odd, but actually serves a\n+//! purpose.\n+//!\n+//! Conceptually you might think of this more like:\n+//!\n+//! ```ignore\n+//! union Repr {\n+//!     // holds integer (Simple/Os) variants, and\n+//!     // provides access to the tag bits.\n+//!     bits: NonZeroU64,\n+//!     // Tag is 0, so this is stored untagged.\n+//!     msg: &'static SimpleMessage,\n+//!     // Tagged (offset) `Box<Custom>` pointer.\n+//!     tagged_custom: NonNull<()>,\n+//! }\n+//! ```\n+//!\n+//! But there are a few problems with this:\n+//!\n+//! 1. Union access is equivalent to a transmute, so this representation would\n+//!    require we transmute between integers and pointers in at least one\n+//!    direction, which may be UB (and even if not, it is likely harder for a\n+//!    compiler to reason about than explicit ptr->int operations).\n+//!\n+//! 2. Even if all fields of a union have a niche, the union itself doesn't,\n+//!    although this may change in the future. This would make things like\n+//!    `io::Result<()>` and `io::Result<usize>` larger, which defeats part of\n+//!    the motivation of this bitpacking.\n+//!\n+//! Storing everything in a `NonZeroUsize` (or some other integer) would be a\n+//! bit more traditional for pointer tagging, but it would lose provenance\n+//! information, couldn't be constructed from a `const fn`, and would probably\n+//! run into other issues as well.\n+//!\n+//! The `NonNull<()>` seems like the only alternative, even if it's fairly odd\n+//! to use a pointer type to store something that may hold an integer, some of\n+//! the time.\n+\n+use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n+use alloc::boxed::Box;\n+use core::mem::{align_of, size_of};\n+use core::ptr::NonNull;\n+\n+// The 2 least-significant bits are used as tag.\n+const TAG_MASK: usize = 0b11;\n+const TAG_SIMPLE_MESSAGE: usize = 0b00;\n+const TAG_CUSTOM: usize = 0b01;\n+const TAG_OS: usize = 0b10;\n+const TAG_SIMPLE: usize = 0b11;\n+\n+#[repr(transparent)]\n+pub(super) struct Repr(NonNull<()>);\n+\n+// All the types `Repr` stores internally are Send + Sync, and so is it.\n+unsafe impl Send for Repr {}\n+unsafe impl Sync for Repr {}\n+\n+impl Repr {\n+    pub(super) fn new_custom(b: Box<Custom>) -> Self {\n+        let p = Box::into_raw(b).cast::<u8>();\n+        // Should only be possible if an allocator handed out a pointer with\n+        // wrong alignment.\n+        debug_assert_eq!((p as usize & TAG_MASK), 0);\n+        // Safety: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n+        // end of file), and both the start and end of the expression must be\n+        // valid without address space wraparound due to `Box`'s semantics.\n+        // Note: `add` is used as a provenance-preserving way of pointer tagging.\n+        let tagged = unsafe { p.add(TAG_CUSTOM).cast::<()>() };\n+        // Safety: the above safety comment also means the result can't be null.\n+        let res = Self(unsafe { NonNull::new_unchecked(tagged) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(matches!(res.data(), ErrorData::Custom(_)), \"repr(custom) encoding failed\");\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) fn new_os(code: i32) -> Self {\n+        let utagged = ((code as usize) << 32) | TAG_OS;\n+        // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n+        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(\n+            matches!(res.data(), ErrorData::Os(c) if c == code),\n+            \"repr(os) encoding failed for {}\",\n+            code,\n+        );\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) fn new_simple(kind: ErrorKind) -> Self {\n+        let utagged = ((kind as usize) << 32) | TAG_SIMPLE;\n+        // Safety: `TAG_SIMPLE` is not zero, so the result of the `|` is not 0.\n+        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) });\n+        // quickly smoke-check we encoded the right thing (This generally will\n+        // only run in libstd's tests, unless the user uses -Zbuild-std)\n+        debug_assert!(\n+            matches!(res.data(), ErrorData::Simple(k) if k == kind),\n+            \"repr(simple) encoding failed {:?}\",\n+            kind,\n+        );\n+        res\n+    }\n+\n+    #[inline]\n+    pub(super) const fn new_simple_message(m: &'static SimpleMessage) -> Self {\n+        // Safety: We're a Repr, decode_repr is fine.\n+        Self(unsafe { NonNull::new_unchecked(m as *const _ as *mut ()) })\n+    }\n+\n+    #[inline]\n+    pub(super) fn data(&self) -> ErrorData<&Custom> {\n+        // Safety: We're a Repr, decode_repr is fine.\n+        unsafe { decode_repr(self.0, |c| &*c) }\n+    }\n+\n+    #[inline]\n+    pub(super) fn data_mut(&mut self) -> ErrorData<&mut Custom> {\n+        // Safety: We're a Repr, decode_repr is fine.\n+        unsafe { decode_repr(self.0, |c| &mut *c) }\n+    }\n+\n+    #[inline]\n+    pub(super) fn into_data(self) -> ErrorData<Box<Custom>> {\n+        let this = core::mem::ManuallyDrop::new(self);\n+        // Safety: We're a Repr, decode_repr is fine. The `Box::from_raw` is\n+        // safe because we prevent double-drop using `ManuallyDrop`.\n+        unsafe { decode_repr(this.0, |p| Box::from_raw(p)) }\n+    }\n+}\n+\n+impl Drop for Repr {\n+    #[inline]\n+    fn drop(&mut self) {\n+        // Safety: We're a Repr, decode_repr is fine. The `Box::from_raw` is\n+        // safe because we're being dropped.\n+        unsafe {\n+            let _ = decode_repr(self.0, |p| Box::<Custom>::from_raw(p));\n+        }\n+    }\n+}\n+\n+// Shared helper to decode a `Repr`'s internal pointer into an ErrorData.\n+//\n+// Safety: `ptr`'s bits should be encoded as described in the document at the\n+// top (it should `some_repr.0`)\n+#[inline]\n+unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\n+where\n+    F: FnOnce(*mut Custom) -> C,\n+{\n+    let bits = ptr.as_ptr() as usize;\n+    match bits & TAG_MASK {\n+        TAG_OS => {\n+            let code = ((bits as i64) >> 32) as i32;\n+            ErrorData::Os(code)\n+        }\n+        TAG_SIMPLE => {\n+            let kind_bits = (bits >> 32) as u32;\n+            let kind = kind_from_prim(kind_bits).unwrap_or_else(|| {\n+                debug_assert!(false, \"Invalid io::error::Repr bits: `Repr({:#016x})`\", bits);\n+                // This means the `ptr` passed in was not valid, which voilates\n+                // the unsafe contract of `decode_repr`.\n+                //\n+                // Using this rather than unwrap meaningfully improves the code\n+                // for callers which only care about one variant (usually\n+                // `Custom`)\n+                core::hint::unreachable_unchecked();\n+            });\n+            ErrorData::Simple(kind)\n+        }\n+        TAG_SIMPLE_MESSAGE => ErrorData::SimpleMessage(&*ptr.cast::<SimpleMessage>().as_ptr()),\n+        TAG_CUSTOM => {\n+            let custom = ptr.as_ptr().cast::<u8>().sub(TAG_CUSTOM).cast::<Custom>();\n+            ErrorData::Custom(make_custom(custom))\n+        }\n+        _ => {\n+            // Can't happen, and compiler can tell\n+            unreachable!();\n+        }\n+    }\n+}\n+\n+// This compiles to the same code as the check+transmute, but doesn't require\n+// unsafe, or to hard-code max ErrorKind or its size in a way the compiler\n+// couldn't verify.\n+#[inline]\n+fn kind_from_prim(ek: u32) -> Option<ErrorKind> {\n+    macro_rules! from_prim {\n+        ($prim:expr => $Enum:ident { $($Variant:ident),* $(,)? }) => {{\n+            // Force a compile error if the list gets out of date.\n+            const _: fn(e: $Enum) = |e: $Enum| match e {\n+                $($Enum::$Variant => ()),*\n+            };\n+            match $prim {\n+                $(v if v == ($Enum::$Variant as _) => Some($Enum::$Variant),)*\n+                _ => None,\n+            }\n+        }}\n+    }\n+    from_prim!(ek => ErrorKind {\n+        NotFound,\n+        PermissionDenied,\n+        ConnectionRefused,\n+        ConnectionReset,\n+        HostUnreachable,\n+        NetworkUnreachable,\n+        ConnectionAborted,\n+        NotConnected,\n+        AddrInUse,\n+        AddrNotAvailable,\n+        NetworkDown,\n+        BrokenPipe,\n+        AlreadyExists,\n+        WouldBlock,\n+        NotADirectory,\n+        IsADirectory,\n+        DirectoryNotEmpty,\n+        ReadOnlyFilesystem,\n+        FilesystemLoop,\n+        StaleNetworkFileHandle,\n+        InvalidInput,\n+        InvalidData,\n+        TimedOut,\n+        WriteZero,\n+        StorageFull,\n+        NotSeekable,\n+        FilesystemQuotaExceeded,\n+        FileTooLarge,\n+        ResourceBusy,\n+        ExecutableFileBusy,\n+        Deadlock,\n+        CrossesDevices,\n+        TooManyLinks,\n+        FilenameTooLong,\n+        ArgumentListTooLong,\n+        Interrupted,\n+        Other,\n+        UnexpectedEof,\n+        Unsupported,\n+        OutOfMemory,\n+        Uncategorized,\n+    })\n+}\n+\n+// Some static checking to alert us if a change breaks any of the assumptions\n+// that our encoding relies on. If any of these are hit on a platform that\n+// libstd supports, we should just make sure `repr_unpacked.rs` is used.\n+macro_rules! static_assert {\n+    ($condition:expr) => {\n+        const _: [(); 0] = [(); (!$condition) as usize];\n+    };\n+}\n+\n+// The bitpacking we use requires pointers be exactly 64 bits.\n+static_assert!(size_of::<NonNull<()>>() == 8);\n+\n+// We also require pointers and usize be the same size.\n+static_assert!(size_of::<NonNull<()>>() == size_of::<usize>());\n+\n+// `Custom` and `SimpleMessage` need to be thin pointers.\n+static_assert!(size_of::<&'static SimpleMessage>() == 8);\n+static_assert!(size_of::<Box<Custom>>() == 8);\n+\n+// And they must have >= 4 byte alignment.\n+static_assert!(align_of::<SimpleMessage>() >= 4);\n+static_assert!(align_of::<Custom>() >= 4);\n+\n+// This is obviously true (`TAG_CUSTOM` is `0b01`), but our implementation of\n+// `Repr::new_custom` and such would be UB if it were not, so we check.\n+static_assert!(size_of::<Custom>() >= TAG_CUSTOM);\n+// These two store a payload which is allowed to be zero, so they must be\n+// non-zero to preserve the `NonNull`'s range invariant.\n+static_assert!(TAG_OS != 0);\n+static_assert!(TAG_SIMPLE != 0);\n+// We can't tag `SimpleMessage`s, the tag must be 0.\n+static_assert!(TAG_SIMPLE_MESSAGE == 0);\n+\n+// Check that the point of all of this still holds.\n+static_assert!(size_of::<Repr>() == 8);\n+static_assert!(size_of::<Option<Repr>>() == 8);\n+static_assert!(size_of::<Result<(), Repr>>() == 8);\n+static_assert!(size_of::<Result<usize, Repr>>() == 16);"}, {"sha": "81657033f5cb412d58fa482aa2d24a207ddd120d", "filename": "library/std/src/io/error/tests.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea211695bf924015f38d4a2de4f43a822f6c6a70/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Ftests.rs?ref=ea211695bf924015f38d4a2de4f43a822f6c6a70", "patch": "@@ -67,3 +67,18 @@ fn test_const() {\n     assert!(format!(\"{:?}\", E).contains(\"\\\"hello\\\"\"));\n     assert!(format!(\"{:?}\", E).contains(\"NotFound\"));\n }\n+\n+#[test]\n+fn test_error_packing() {\n+    for code in -20i32..20i32 {\n+        let e = Error::from_raw_os_error(code);\n+        assert_eq!(e.raw_os_error(), Some(code));\n+    }\n+    assert_eq!(Error::from(ErrorKind::NotFound).kind(), ErrorKind::NotFound);\n+    assert_eq!(Error::from(ErrorKind::Uncategorized).kind(), ErrorKind::Uncategorized);\n+    assert_eq!(Error::from(ErrorKind::NotFound).kind(), ErrorKind::NotFound);\n+    assert_eq!(Error::from(ErrorKind::Uncategorized).kind(), ErrorKind::Uncategorized);\n+    let dunno = const_io_error!(ErrorKind::Uncategorized, \"dunno\");\n+    assert_eq!(dunno.kind(), ErrorKind::Uncategorized);\n+    assert!(format!(\"{:?}\", dunno).contains(\"dunno\"))\n+}"}]}